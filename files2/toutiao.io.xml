<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7a326b2537f4010937c5fd6b07deb357</guid>
<title>职场：工作五年之后，对技术和业务的思考</title>
<link>https://toutiao.io/k/zpo0xd7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;苦海无边，回头无岸。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;01&lt;/span&gt;&lt;/p&gt;&lt;p&gt;晃晃悠悠的，在互联网行业工作了五年，默然回首，你看哪里像灯火阑珊处？&lt;/p&gt;&lt;p&gt;初入职场，大部分程序员会觉得苦学技术，以后会顺风顺水升职加薪，这样的想法没有错，但是不算全面，五年后你会不会继续做技术写代码这是核心问题。&lt;/p&gt;&lt;p&gt;初入职场，会觉得努力加班可以不断提升能力，可以学到技术的公司就算薪水低点也可以接受，但是五年之后会认为加班都是在不断挤压自己的上升空间，薪水低是人生的天花板。&lt;/p&gt;&lt;p&gt;这里想说的关键问题就是：初入职场的认知和想法大部分不会再适用于五年后的认知。&lt;/p&gt;&lt;p&gt;工作五年之后面临的最大压力就是选择：职场天花板，技术能力天花板，薪水天花板，三十岁天花板。&lt;/p&gt;&lt;p&gt;如何面对这些问题，是大部分程序员都在思考和纠结的。做选择的唯一参考点就是：利益最大化，这里可以理解为职场更好的升职加薪，顺风顺水。&lt;/p&gt;&lt;p&gt;五年，变化最大不是工作经验，能力积累，而是心态，清楚的知道现实和理想之间是存在巨大的差距。&lt;/p&gt;&lt;p&gt;&lt;span&gt;02&lt;/span&gt;&lt;/p&gt;&lt;p&gt;回首自己的职场五年，最认可的一句话就是：学会适应变化，并积累能力。&lt;/p&gt;&lt;p&gt;变化的就是，五年的时间技术框架更新迭代，开发工具的变迁，公司环境队友的更换，甚至是不同城市的流浪，想着能把肉体和灵魂安放在一处，有句很经典的话就是：唯一不变的就是变化本身。&lt;/p&gt;&lt;p&gt;要积累的是：解决问题的能力，思考方式，拓宽认知。&lt;/p&gt;&lt;p&gt;这种很难直白的描述，属于个人认知的范畴，不同的人有不一样的看法，所以只能站在大众化的角度去思考。&lt;/p&gt;&lt;p&gt;首先聊聊技术，大部分小白级别的，都希望自己的技术能力不断提高，争取做到架构师级别，但是站在当前的互联网环境中，这种想法实现难度还是偏高，这里既不是打击也不是为了抬杠。&lt;/p&gt;&lt;p&gt;可以观察一下现状，技术团队大的20-30人，小的10-15人，能有一个架构师去专门管理底层框架都是少有现象。&lt;/p&gt;&lt;p&gt;这个问题的原因很多，首先架构师的成本过高，环境架构也不是需要经常升级，说的难听点可能框架比项目生命周期更高。&lt;/p&gt;&lt;p&gt;所以大部分公司的大部分业务，基于现有大部分成熟的开源框架都可以解决，这也就导致架构师这个角色通常由项目主管代替或者级别较高的开发直接负责，这就是现实情况。&lt;/p&gt;&lt;p&gt;这就导致技术框架的选择思路就是：只选对的。即这方面的人才多，开源解决方案多，以此降低技术方面对公司业务发展的影响。&lt;/p&gt;&lt;p&gt;那为什么还要不断学习和积累技术能力？如果没有这个能力，程序员岗位可能根本走不了五年之久，需要用技术深度积累不断解决工作中的各种问题，用技术的广度提升自己实现业务需求的认知边界，这是安放肉体的根本保障。&lt;/p&gt;&lt;p&gt;这就是导致很多五年以后的程序员压力陡然升高的原因，走向管理岗的另一个壁垒就是业务思维和认知。&lt;/p&gt;&lt;p&gt;&lt;span&gt;03&lt;/span&gt;&lt;/p&gt;&lt;p&gt;程序员该不该用心研究业务，这个问题真的没有纠结的必要，只要不是纯技术型的公司，都需要面对业务。&lt;/p&gt;&lt;p&gt;不管技术、运营、产品、管理层，都是在面向业务工作。&lt;/p&gt;&lt;p&gt;从自己职场轨迹来看，五年变化最大就是解决业务问题的能力，职场之初面对很多业务场景都不知道如何下手，到几年之后设计业务的解决方案。&lt;/p&gt;&lt;p&gt;这是大部分程序员在职场前五年跳槽就能涨薪的根本原因，面对业务场景，基于积累的经验和现有的开源工具，能快速给出合理的解决思路和实现过程。&lt;/p&gt;&lt;p&gt;工作五年可能对技术底层的清晰程度都没有初入职场的小白清楚，但是写的程序却可以避开很多坑坑洼洼，对于业务的审视也是很细节全面。&lt;/p&gt;&lt;p&gt;解决业务能力的积累，对于技术视野的宽度需求更甚，比如职场初期对于海量数据的处理束手无策，但是在工作几年之后见识数据行业的技术栈，真的就是技术选型的视野问题。&lt;/p&gt;&lt;p&gt;什么是衡量技术能力的标准？站在一个共识的角度上看：系统的架构与代码设计能适应业务的不断变化和各种需求。&lt;/p&gt;&lt;p&gt;相对比与技术，业务的变化更加快速频繁，高级工程师或者架构师之所以薪资高，这些角色一方面能适应业务的迭代，并且在工作中具有一定前瞻性，会考虑业务变化的情况下代码复用逻辑，这样的能力是需要一定的技术视野和业务思维的沉淀。&lt;/p&gt;&lt;p&gt;所以职场中：业务能说的井井有条，代码能写的明明白白，得到机会的可能性更大。&lt;/p&gt;&lt;p&gt;&lt;span&gt;04&lt;/span&gt;&lt;/p&gt;&lt;p&gt;从理性的角度看技术和业务两个方面，能让大部分人职场走的平稳顺利，但是不同的阶段对两者的平衡和选择是不一样的。&lt;/p&gt;&lt;p&gt;在思考如何选择的时候，可以参考二八原则的逻辑，即在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%尽管是多数，却是次要的，因此又称二八定律。&lt;/p&gt;&lt;p&gt;个人真的非常喜欢这个原则，大部分人都不是天才，所以很难三心二意同时做好几件事情，在同一时间段内应该集中精力做好一件事件。&lt;/p&gt;&lt;p&gt;但是单纯的二八原则模式可能不适应大部分职场初期的人，因为初期要学习很多内容，如何在职场生存：专业能力，职场关系，为人处世，产品设计等等。&lt;/p&gt;&lt;p&gt;当然这些东西不是都要用心刻意学习，但是合理安排二二六原则或其他组合是更明智的，首先是专业能力要重点练习，其次可以根据自己的兴趣合理选择一到两个方面去慢慢了解，例如产品，运营，运维，数据等，毕竟三五年以后会不会继续写代码很难说，多给自己留个机会总是有备无患。&lt;/p&gt;&lt;p&gt;在职场初期，基本都是从技术角度去思考问题，如何快速提升自己的编码能力，在公司能稳定是首要目标，因此大部分时间都是在做基础编码和学习规范，这时可能90%的心思都是放在基础编码上，另外10%会学习环境架构。&lt;/p&gt;&lt;p&gt;最多一到两年，就会开始独立负责模块需求开发，需要自己设计整个代码思路，这里业务就会进入视野，要懂得业务上下游关联关系，学会思考如何设计代码结构，才能在需求变动的情况下代码改动较少，这个时候可能就会放20%的心思在业务方面，30%学习架构方式。&lt;/p&gt;&lt;p&gt;三到五年这个时间段，是解决问题能力提升最快的时候，因为这个阶段的程序员基本都是在开发核心业务链路，例如交易、支付、结算、智能商业等模块，需要对业务整体有较清晰的把握能力，不然就是给自己挖坑，这个阶段要对业务流付出大量心血思考。&lt;/p&gt;&lt;p&gt;越是核心的业务线，越是容易爆发各种问题，如果在日常工作中不花心思处理各种细节问题，半夜异常自动的消息和邮件总是容易让人憔悴。&lt;/p&gt;&lt;p&gt;所以努力学习技术是提升自己，培养自己的业务认知也同样重要，个人认为这二者的分量平分秋色，只是需要在合适的阶段做出合理的权重划分。&lt;/p&gt;&lt;p&gt;&lt;span&gt;05&lt;/span&gt;&lt;/p&gt;&lt;p&gt;基于技术能力和业务思维，学会在职场做选择和生存，这些是职场前五年一路走来的最大体会。&lt;/p&gt;&lt;p&gt;不管是技术还是业务，这两个概念依旧是个很大的命题，不容易把握，所以学会理清这两个方面能力中的公共模块是关键。&lt;/p&gt;&lt;p&gt;不管技术还是业务，都不可能从一家公司完全复制到另一家公司，但是可以把一家公司的技术框架，业务解决方案学会，并且带到另一家公司，例如技术领域内的架构、设计、流程、数据管理，业务领域内的思考方式、产品逻辑、分析等，这些是核心能力并且是大部分公司人才招聘的要求，所以这些才是工作中需要重点积累的。&lt;/p&gt;&lt;p&gt;人的精力是有限的，而且面对三十这个天花板，各种事件也会接连而至，在职场中学会合理安排时间并不断提升核心能力，这样才能保证自己的竞争力。&lt;/p&gt;&lt;p&gt;职场就像苦海无边，回首望去可能也没有岸边停泊，但是要具有换船的能力或者有个小木筏也就大差不差了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;End&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7f9940eb4d3f12229c4390a3e8befdea</guid>
<title>谈谈 MySQL 锁</title>
<link>https://toutiao.io/k/z5c0vp0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 的并发控制是在数据安全性和并发处理能力之间的权衡，通过不同的锁策略来决定对系统开销和性能的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要存在多个客户端同时修改更新数据，就会存在并发问题，MySQL 通过 MVCC 和锁来处理这一问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、锁的粒度 Lock Type&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 源码中定义了两种锁的粒度，分别是表锁和行锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/** Lock types */&lt;br/&gt;&lt;span&gt;#define LOCK_TABLE 16  /*!&amp;lt; table lock */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#define LOCK_REC 32    /*!&amp;lt; record lock */&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1、表锁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表锁由 MySQL Server 控制，优点是开销小、加锁快，不会产生死锁，缺点是加锁粒度大，发生锁冲突的概率大，并发度比较低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般 DDL 语句会自动加表锁，也可以手动指定。表锁分为读锁和写锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//加读锁&lt;br/&gt;lock table products &lt;span&gt;read&lt;/span&gt;;&lt;br/&gt;//加写锁&lt;br/&gt;lock table products write;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当对表加了读锁，则会话只能读取当前被加锁的表，其它会话仍然可以对表进行读取但不能写入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当对表加了写锁，则会话可以读取或写入被加锁的表，其它会话不能对加锁的表进行读取或写入。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2、行锁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;行锁由存储引擎实现，InnoDB 支持，而 MyISAM 不支持。行锁的优点是锁粒度小，发生锁冲突概率小，并发度高，缺点是开销大、加锁慢，并且可能产生死锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InnoDB 行锁是通过索引项加锁来实现的，只有通过索引条件检索数据，才能锁住指定的索引记录，否则将使用行锁锁住全部数据&lt;span&gt;（有文章称会退化为表锁，是错误的理解）&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表级锁适合查询多、更新少的场景，行级锁适合按索引更新频率高的场景。InnoDB 默认使用行级锁。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、锁的模式 Lock Mode&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 源码中定义了多种锁的模式，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/* Basic lock modes */&lt;br/&gt;enum lock_mode {&lt;br/&gt;  LOCK_IS = 0,          /* intention shared */&lt;br/&gt;  LOCK_IX,              /* intention exclusive */&lt;br/&gt;  LOCK_S,               /* shared */&lt;br/&gt;  LOCK_X,               /* exclusive */&lt;br/&gt;  LOCK_AUTO_INC,        /* locks the auto-inc counter of a table &lt;span&gt;in&lt;/span&gt; an exclusive mode */&lt;br/&gt; ...&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1、共享锁和排它锁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共享锁和排它锁都是行级锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Shared Lock (S 锁)，共享锁，也称为读锁。当事务对行加共享锁后，允许其它事务对相同行加共享锁，但不允许加排它锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Exclusive Lock (X 锁)，排它锁，也称为写锁。当事务对行加排它锁后，不允许其它事务对相同行加共享锁或排它锁。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2、意向锁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;意向锁分为意向共享锁和意向排它锁，意向锁是表锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Intention Shared Lock (IS)，意向共享锁，也称为意向读锁。意向共享锁表示有事务打算在行记录上加共享锁，在事务获取行 S 锁前，必须先获得 IS 锁或更高级别的锁。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Intention Exclusive Lock (IX)，意向排它锁，也称为意向写锁。意向排它锁表示有事务打算在行记录上加排它锁，在事务获取行 X 锁前，必须先获 IX 锁。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;意向锁之间不会发生冲突，但共享锁、排它锁、意向锁之间会发生冲突，如下表所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;     |      X       |       IX       |       S        |       IS&lt;br/&gt;X    |   Conflict   |    Conflict    |    Conflict    |    Conflict&lt;br/&gt;IX   |   Conflict   |   Compatible   |    Conflict    |   Compatible&lt;br/&gt;S    |   Conflict   |    Conflict    |   Compatible   |   Compatible&lt;br/&gt;IS   |   Conflict   |   Compatible   |   Compatible   |   Compatible&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3、自增锁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AUTO-INC Locks，自增锁，它是一种特殊的表锁。当表有设置自增 auto_increment 列，在插入数据时会先获取自增锁，其它事务将会被阻塞插入操作，自增列 +1 后释放锁，如果事务回滚，自增值也不会回退，所以自增列并不一定是连续自增的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、行锁的分类&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 中定义了四种行锁的分类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#define LOCK_ORDINARY     0 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#define LOCK_GAP         512 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#define LOCK_REC_NOT_GAP   1024 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#define LOCK_INSERT_INTENTION  2048                    &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1、记录锁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Record Locks，记录锁是索引记录的锁定。例如 &lt;code&gt;SELECT a FROM t WHERE a = 15 FOR UPDATE&lt;/code&gt;，对索引记录 &lt;code&gt;15&lt;/code&gt; 进行锁定，防止其它事务插入、删除、更新值为 &lt;code&gt;15&lt;/code&gt; 的记录行。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记录锁是通过索引加锁，如果列没有设置索引，则将使用聚簇索引，如果没有人为指定聚簇索引，MySQL 会自动建立一个聚簇索引。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2、间隙锁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Gap Locks，间隙锁是对索引记录之间的间隙的锁定。对于键值在条件范围内但并不存在的记录，叫做&lt;code&gt;间隙（gap）&lt;/code&gt;。例如 &lt;code&gt;SELECT a FROM t WHERE a &amp;gt; 15 and a &amp;lt; 20 FOR UPDATE&lt;/code&gt;，且 a 存在的值为 1、2、5、10、15、20，则将 15,20 中的间隙锁住。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;间隙锁和间隙锁之间是互不冲突的，间隙锁唯一的作用就是为了防止其他事务的插入，在 RR（可重复读）级别下解决了幻读的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3、临键锁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Next-Key Lock，临键锁，是记录锁和间隙锁的合集。例如 &lt;code&gt;SELECT a FROM t WHERE a &amp;gt; 15 FOR UPDATE&lt;/code&gt;，且 a 存在的值为 1、2、5、10、15、20，则将 (15,20]、(20, +∞] 的中 15、20 及其间隙锁住。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4、插入意向锁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Insert Intention Locks，插入意向锁，是一种特殊的间隙锁，只有在执行 &lt;code&gt;INSERT&lt;/code&gt;操作时才会加锁，插入意向锁之间不冲突，可以向一个间隙中同时插入多行数据，但插入意向锁与间隙锁是冲突的，当有间隙锁存在时，插入语句将被阻塞，正是这个特性解决了幻读的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、何时加锁&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SELECT xxx 查询语句正常情况下为快照读，不加锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SELECT xxx LOCK IN SHARE MODE 语句为当前读，加 S 锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SELECT xxx FOR UPDATE 语句为当前读，加 X 锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DML 语句（INSERT、DELETE、UPDATE）为当前读，加 X 锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DDL 语句（ALTER、CREATE 等）加表级锁，且是隐式提交不能回滚；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前读和快照读是什么东西，这又涉及到 MVCC（Mutil Version Concurrent Control） 多版本并发控制的概念。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在不同的事务隔离级别下，会有不同的锁机制，也可以说是通过不同的锁机制实现了不同的事务隔离级别。在 RC（读已提交）级别下，只会有记录锁，不存在间隙锁和 Next-Key 锁，RR（可重复读）级别下才会有间隙锁及 Next-Key 锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仅通过锁来控制实现事务隔离级别会存在一些问题，比如要实现 RC（读已提交）级别，事务 a 更新一行数据，需要对行（实际是索引记录）加 X 锁，阻塞其它事务对该行的读写，事务 b 想要读取该行必须等到 a 提交或回滚释放锁，这样的话就会很大程度上限制读写的并发能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MVCC 的原理是通过在每行记录上加了隐藏的三列（隐式的 ID 字段、事务 ID、回滚指针），事务在写一条记录时会将其拷贝一份生成这条记录的一个原始拷贝，写操作是会对原记录加锁，但是读操作会读取未加锁的拷贝快照记录，这就保证了读写并行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 RC 和 RR 级别下，才会使用 MVCC 机制，RC 级别下事务总是读取最新的快照版本，RR 级别下事务总是读取事务开启时的快照版本，这称为快照读。当前读是指读取数据的最新版本，而非快照，也称为加锁读。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;六、加锁分析&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选取最常用的几个查询语句，来分析加锁的过程，由于 RC RR 级别加锁区别大致是 RC 没有间隙锁、Next-Key 锁，所以以 innoDB 默认的 RR 级别来实验，RC 的加锁分析不赘述。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; show create table test_lock;&lt;br/&gt;&lt;br/&gt;CREATE TABLE `test_lock` (&lt;br/&gt;  `id` int(11) NOT NULL,&lt;br/&gt;  `card` varchar(32) NOT NULL,&lt;br/&gt;  `name` varchar(32) NOT NULL,&lt;br/&gt;  `money` int(11) NOT NULL,&lt;br/&gt;  PRIMARY KEY (`id`),&lt;br/&gt;  UNIQUE KEY `idx_card` (`card`),&lt;br/&gt;  KEY `idx_name` (`name`)&lt;br/&gt;) ENGINE=InnoDB DEFAULT CHARSET=utf8;&lt;br/&gt;&lt;br/&gt;mysql&amp;gt; select * from test_lock;&lt;br/&gt;+----+------+------+-------+&lt;br/&gt;| id | card | name | money |&lt;br/&gt;+----+------+------+-------+&lt;br/&gt;|  1 | N100 | a    |  1000 |&lt;br/&gt;|  5 | N109 | e    |  2000 |&lt;br/&gt;|  8 | N203 | h    |  3000 |&lt;br/&gt;| 12 | N300 | l    |  4000 |&lt;br/&gt;| 15 | N400 | p    |  5000 |&lt;br/&gt;| 20 | N500 | v    |  6000 |&lt;br/&gt;+----+------+------+-------+&lt;br/&gt;6 rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.01 sec)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;聚簇索引，查询命中&lt;/p&gt;&lt;p&gt;聚簇索引，查询未命中&lt;/p&gt;&lt;p&gt;二级唯一索引，查询命中&lt;/p&gt;&lt;p&gt;二级唯一索引，查询未命中&lt;/p&gt;&lt;p&gt;二级非唯一索引，查询命中&lt;/p&gt;&lt;p&gt;二级非唯一索引，查询未命中&lt;/p&gt;&lt;p&gt;无索引&lt;/p&gt;&lt;p&gt;聚簇索引，范围查询&lt;/p&gt;&lt;p&gt;二级索引，范围查询&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1、聚簇索引，查询命中&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 事务 1 执行&lt;br/&gt;UPDATE test_lock SET money = 1500 WHERE id = 1;&lt;br/&gt;// 事务 2 执行，被阻塞&lt;br/&gt;UPDATE test_lock SET money = 1800 WHERE id = 1;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务 A 更新 id = 1 的数据，事务 2 也更新此行时被阻塞等待。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.16902834008097167&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDaiaVUFJIaicEfX0u0716EAfXOGNIBFuNLfUZWuqyZHUpde2iaibhUBiaWicow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1976&quot; data-backw=&quot;558&quot; data-backh=&quot;95&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;查看锁情况， 1335 被阻塞等待 1333 的事务，加锁类型是 Record，加锁索引是主键索引，加锁数据是 1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.24609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDaoicyjwQF2omphmYicp7Uzt1RN3eaJtRD2r2svjvk1C1LU5DWxBjjNmmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;558&quot; data-backh=&quot;137&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2、聚簇索引，查询未命中&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 事务 1 执行&lt;br/&gt;UPDATE test_lock SET money = 2500 WHERE id = 10;&lt;br/&gt;// 事务 2 执行，被阻塞&lt;br/&gt;INSERT INTO test_lock values (9, &lt;span&gt;&#x27;N250&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;j&#x27;&lt;/span&gt;, 5000);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.1078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDaECzmAhIVVx4jPc2RlFZXrYH8drIjOCFHTiaRiat0wlZfRel8xf0Auapw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;558&quot; data-backh=&quot;60&quot;/&gt;&lt;/p&gt;在 RR 级别下，更新 id = 10 的记录，记录不存在时，加了间隙锁 (8,12)，导致 id = 9 的记录插入也被阻塞。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.23828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDa9GMapTv7BFYOvJuJfgkupibCsoQv0ZMibicuyguIm4P0En8lD98Gv27cA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;138&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3、二级唯一索引，查询命中&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 事务 1 执行&lt;br/&gt;UPDATE test_lock SET money = 3500 WHERE card = &lt;span&gt;&#x27;N203&#x27;&lt;/span&gt;;&lt;br/&gt;// 事务 2 执行两次语句，均被阻塞&lt;br/&gt;UPDATE test_lock SET money = 3800 WHERE card = &lt;span&gt;&#x27;N203&#x27;&lt;/span&gt;;&lt;br/&gt;UPDATE test_lock SET money = 3800 WHERE id = 8;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.14609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDaLicgbLqzgKgribNNB6FUyAGLyS7eBTukTpYibBNDRamNERxaojicvp3Ksw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;85&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;查看锁情况，可以看到二级索引的 &lt;code&gt;N203&lt;/code&gt; 和主键索引的 &lt;code&gt;8&lt;/code&gt; 均被加上了 X 锁。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDaOwicNmJXQZTl5bywpay8I3oIibRl0IQevJdGBPKfKzraHG2EEXqWQ9MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;261&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4、二级唯一索引，查询未命中&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 事务 1 执行&lt;br/&gt;UPDATE test_lock SET money = 4500 WHERE card = &lt;span&gt;&#x27;N299&#x27;&lt;/span&gt;;&lt;br/&gt;// 事务 2 执行，被阻塞&lt;br/&gt;INSERT INTO test_lock values (9, &lt;span&gt;&#x27;N250&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;j&#x27;&lt;/span&gt;, 5000);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.17265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDagmJt66CH5zwZ605lcsWSIia9JaNDqicnzhpxiaobIgDFNB3hsAbQyvMAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;558&quot; data-backh=&quot;96&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;查看锁情况，和主键索引查询未命中一样，对二级索引加了间隙锁 (&#x27;N203&#x27;,&#x27;&#x27;N300&#x27;)，导致 N250 的记录插入也被阻塞。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.23203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDaiaGicdscrqIOovnTGYlsc2NxpnScicXufFEGsVJO88XFULQYwA78xAaPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;134&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5、二级非唯一索引，查询命中&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 事务 1 执行&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE name = &lt;span&gt;&#x27;h&#x27;&lt;/span&gt;;&lt;br/&gt;// 事务 2 执行&lt;br/&gt;UPDATE test_lock SET money = 1002 WHERE name = &lt;span&gt;&#x27;h&#x27;&lt;/span&gt;; //被阻塞&lt;br/&gt;UPDATE test_lock SET money = 1002 WHERE id = 8; //被阻塞&lt;br/&gt;UPDATE test_lock SET money = 1002 WHERE name = &lt;span&gt;&#x27;l&#x27;&lt;/span&gt;; //可执行&lt;br/&gt;INSERT INTO  test_lock values(10, &lt;span&gt;&#x27;N250&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;f&#x27;&lt;/span&gt;, 5000); //被阻塞&lt;br/&gt;INSERT INTO  test_lock values(9, &lt;span&gt;&#x27;N250&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;j&#x27;&lt;/span&gt;, 5000); //被阻塞&lt;br/&gt;INSERT INTO test_lock values(11, &lt;span&gt;&#x27;N250&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;m&#x27;&lt;/span&gt;, 5000); //可执行&lt;br/&gt;INSERT INTO  test_lock values(10, &lt;span&gt;&#x27;N251&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, 5000); //可执行&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.371875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDaokp4xooUI2CJgfwYibbJ89F7icPuc96MoCAIW9vsTkvffOgDnuNKLibYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;558&quot; data-backh=&quot;208&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;查看锁情况，可以看到二级索引的 &lt;code&gt;h&lt;/code&gt; 和主键索引的 &lt;code&gt;8&lt;/code&gt; 均被加上了 X 锁，并且 (e,h)、(h,l) 之间的间隙也被加了间隙锁，加锁示意图如下：&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5406698564593302&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDar0CrATO6pyrNLpPcNFQDKEK9gtiaMUP4bSDjrbqKfnbaAGmZrUSiaRdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1254&quot; data-backw=&quot;578&quot; data-backh=&quot;313&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.45390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDacao0Z4AmJ8GVYasjaD9rQNiaBia2a7yFycSGibJvTiaxK5W6w7UyWmAp3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;262&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.23671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDaia80GwrfUVlk4gJ7IodkxFn2jouc1Vr9pYFtBmnGBClDFZCeLt7mowA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;137&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6、二级非唯一索引，查询未命中&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 事务 1 执行&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE name = &lt;span&gt;&#x27;t&#x27;&lt;/span&gt;;&lt;br/&gt;// 事务 2 执行&lt;br/&gt;INSERT INTO  test_lock values(16, &lt;span&gt;&#x27;N250&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;r&#x27;&lt;/span&gt;, 5000); //被阻塞&lt;br/&gt;INSERT INTO  test_lock values(17, &lt;span&gt;&#x27;N250&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;u&#x27;&lt;/span&gt;, 5000); //被阻塞&lt;br/&gt;INSERT INTO  test_lock values(17, &lt;span&gt;&#x27;N250&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;w&#x27;&lt;/span&gt;, 5000); //可执行&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.19765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDak7bgoTT1YyjUTANd2kh7fD2kfjOnT3rVsakCLefN9ySCLHvUV3Eq1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;558&quot; data-backh=&quot;110&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;查看锁情况，在 (p,v)之间加了间隙锁，p 和 v 之间的数据插入将被阻塞。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.23125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDa43gQ5njClMic0fLeDibLxgnFLYN5pl0HpjoicwZ0ibysc2WQw3xhtnwoQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;134&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7、无索引&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 事务 1 执行&lt;br/&gt;UPDATE test_lock SET money = 7000 WHERE money = 6000;&lt;br/&gt;// 事务 2 执行&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE name = &lt;span&gt;&#x27;a&#x27;&lt;/span&gt;; //被阻塞&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE name = &lt;span&gt;&#x27;p&#x27;&lt;/span&gt;; //被阻塞&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE id = 1; //被阻塞&lt;br/&gt;INSERT INTO  test_lock values(99, &lt;span&gt;&#x27;N999&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;z&#x27;&lt;/span&gt;, 5000);  //被阻塞&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从执行结果可以看出，不仅在所有主键上加了 X 锁，主键之间的间隙都加上了 Gap 锁，由此也可以证实对于不走索引的更新语句需要慎用。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.115625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDaCRUPcdLKuOfXezcsMXXtA0Ric8TMIS6mvHrIhblByOEKrB50WqwU3mA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;67&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;8、聚簇索引，范围查询&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 事务 1 执行&lt;br/&gt;UPDATE test_lock SET money = 1100 WHERE id &amp;lt;= 12;&lt;br/&gt;// 事务 2 执行&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE id = 5; //被阻塞&lt;br/&gt;INSERT INTO  test_lock values(3, &lt;span&gt;&#x27;N251&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, 5000); //被阻塞&lt;br/&gt;INSERT INTO  test_lock values(13, &lt;span&gt;&#x27;N251&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, 5000); //被阻塞&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE id = 15; //被阻塞&lt;br/&gt;INSERT INTO  test_lock values(16, &lt;span&gt;&#x27;N251&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, 5000); //可执行&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从执行结果来看，所有小于 12 的主键上加了 X 锁，主键之间的间隙都加上了 Gap 锁，并且(12,15)的间隙也被加了 Gap 锁和主键 15 组成一个 Next-Key 锁。按正常思路 (12,15] 的 Next-Key 锁并不需要加，这点有点不好理解。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3814262023217247&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDaRMvGtAw1GduBF04VvdIQVb6I3HxGAiaCz9WmT6d2mqwGGNY6mFBMBibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1206&quot; data-backw=&quot;578&quot; data-backh=&quot;220&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;9、二级索引，范围查询&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 事务 1 执行&lt;br/&gt;UPDATE test_lock SET money = 1100 WHERE card &amp;lt;= &lt;span&gt;&#x27;N203&#x27;&lt;/span&gt;;&lt;br/&gt;// 事务 2 执行&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE id = 5; //被阻塞&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE id = 8; //被阻塞&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE id = 12; // 可执行&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE id = 15; // 可执行&lt;br/&gt;INSERT INTO  test_lock values(3, &lt;span&gt;&#x27;N999&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, 5000); //可执行&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE card = &lt;span&gt;&#x27;N100&#x27;&lt;/span&gt;; //被阻塞&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE card = &lt;span&gt;&#x27;N300&#x27;&lt;/span&gt;; //被阻塞&lt;br/&gt;INSERT INTO  test_lock values(99, &lt;span&gt;&#x27;N999&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, 5000); //可执行&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从执行结果和锁情况来看，所有小于 N203 的索引上加了 X 锁，索引之间的间隙都加上了 Gap 锁，并且 (N203,N300) 的间隙也被加了 Gap 锁和索引 N300 组成一个 Next-Key 锁。&lt;code&gt;idx_card&lt;/code&gt; 对应的主键索引值也加了 X 锁，如下图所示。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要额外注意的是，如果执行 &lt;code&gt;UPDATE test_lock SET money = 1100 WHERE card &amp;lt;= &#x27;N300&#x27;;&lt;/code&gt; 则会用 X 锁和 Gap 锁将全表锁上，是因为表记录少且根据优化策略走了全表扫描。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5110062893081762&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDa4icH4Mt5XB6OJYSjMY3KicJwO2IHS0dcJA95R4fMibEebAVJicqet9F3hA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1272&quot; data-backw=&quot;578&quot; data-backh=&quot;295&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDaOsV2g22jibQbLF2gJqEkqmiam1FrRzWAibyU8jRHlTiaVPkCw3pmmFicBLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;314&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结如下：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.74609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDaWkAGCmxcUDUy86yWJ5A6REdru8oQgwoqemm0cNRIjJnMQhYs1tib1wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;431&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;七、死锁是怎么产生的&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有多种场景会产生死锁，下面复现一种。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 第一步：事务 1 执行&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE id = 5;&lt;br/&gt;// 第一步：事务 2 执行&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE id = 12;&lt;br/&gt;// 第二步：事务 1 执行&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE id = 12;&lt;br/&gt;// 第二步：事务 2 执行&lt;br/&gt;UPDATE test_lock SET money = 1001 WHERE id = 5;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;按照以上语句顺序执行，第一步执行后，事务 1 对 &lt;/span&gt;&lt;code&gt;5&lt;/code&gt;&lt;span&gt; 持有 X 锁，事务 2 对 &lt;/span&gt;&lt;code&gt;12&lt;/code&gt;&lt;span&gt; 持有 X 锁。执行第二步时，事务 1 在等待事务 2 对 &lt;/span&gt;&lt;code&gt;12&lt;/code&gt;&lt;span&gt; 的释放，事务 2 在等待事务 1 对 &lt;/span&gt;&lt;code&gt;5&lt;/code&gt;&lt;span&gt; 的释放，由此产生了死锁：&lt;/span&gt;&lt;code&gt;Deadlock found when trying to get lock; try restarting transaction&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.16171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw1kFia3BdZIjt14Oms6rrTDaoFBD1lM9xwpWmznvtbTPibGuiaSlQ1fx8dJkLcV78XrmIeI7jcjrEWbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;558&quot; data-backh=&quot;90&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;八、总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 的锁机制非常复杂与精妙，了解到一些浅层知识对编写高效 SQL 及解决死锁问题也会有一定的帮助，注意减少锁冲突以提高并发。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2f89712049fa22e8958f8290c6c1206a</guid>
<title>Java 中的 equals() 和 hashCode()（超详细篇）</title>
<link>https://toutiao.io/k/yey6u1v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/10/iqUdVI2LmK6gtuh.png&quot; alt=&quot;c0836b5617c6bb54bb2ffc01ff2ee28&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;大家好啊，我是汤圆，今天给大家带来的是《Java中的equals()和hashCode() - 详细篇》，希望对大家有帮助，谢谢&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;文章纯属原创，个人总结难免有差错，如果有，麻烦在评论区回复或后台私信，谢啦&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/10/xXMTGsVuvb46Owk.png&quot; alt=&quot;比个耶&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;简介&lt;/h2&gt;

&lt;p&gt;说到equals和hashCode，首先要说下Object&lt;/p&gt;

&lt;p&gt;我们都知道，这个Object是Java所有类的超类，其他类都是从Object直接或间接继承而来的&lt;/p&gt;

&lt;p&gt;而Object中自带的equals和hashCode方法就是今天我们要谈论的话题&lt;/p&gt;

&lt;h2&gt;目录&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;什么是equals()方法&lt;/li&gt;
&lt;li&gt;什么是hashCode()方法&lt;/li&gt;
&lt;li&gt;equals和hashCode有啥关系&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;正文&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;PS：正文可能比较长，有点像是一层层在剥洋葱，所以会显得有点啰嗦，需要看结论的可以直接跳到文末看总结&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/10/WQaisEolCR1tAmb.jpg&quot; alt=&quot;传送&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;什么是equals方法&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;equals方法用来比较两个对象的属性是否相等&lt;/strong&gt;，也可以说是比较两个引用对象是否为同一个对象（因为Object中的equals就是这个意&lt;/p&gt;

&lt;p&gt;思，如果你没有覆写equals方法，那么就可以这么说）&lt;/p&gt;

&lt;p&gt;因为在Object中没有属性，所以就只比较了两个引用指向的对象是否相等&lt;/p&gt;

&lt;p&gt;只要对象不相等，那么就返回false（其实这样对子类来说是很不友好的，太绝对了，请往下看）&lt;/p&gt;

&lt;p&gt;代码如下所示：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class Object {
    public boolean equals(Object obj) {
        // 可以看到，官方括号的写法很规范（向老人家学习）
        return (this == obj);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是我们平时在定义类时，都或多或少会包含几个属性&lt;/p&gt;

&lt;p&gt;比如下面的例子&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class EqualsDemo {
    private int m;
    // 省略 getter,setter,constructor(m)
    public static void main(String[] args) {
        EqualsDemo demo1 = new EqualsDemo(1);
        EqualsDemo demo2 = new EqualsDemo(1);
        // 这里期望返回true，实际却是false
        System.out.println(demo1.equals(demo2));
    }

    // 这里延续Object的写法，只单纯地比较两个引用指向的对象是否相等
    @Override
    public boolean equals(Object o) {
        return this == o;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中定义了一个基本类型的属性 int m；&lt;/p&gt;

&lt;p&gt;然后两个实例 demo1 和 demo2 都拥有相同的属性 m = 1;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是equals方法却返回false&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原因就是，equals方法没有正确地编写&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;equals怎么才算正确编写呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;我们应该把属性也进行比对，而不是单纯地比较对象的引用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（这就好比我们选一半，不能只看外在，而是要外在内在一起看，那样就。。。就都单着吧）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008eGmZEgy1gpeyrlhzoaj306o06k40g.jpg&quot; alt=&quot;单身&quot;/&gt;&lt;/p&gt;

&lt;p&gt;修正后的代码如下所示：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class EqualsDemo {
    private int m;
    // 省略 getter,setter,constructor(m)
    public static void main(String[] args) {
        EqualsDemo demo1 = new EqualsDemo(1);
        EqualsDemo demo2 = new EqualsDemo(1);
        // 这时就会返回true
        System.out.println(demo1.equals(demo2));
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        // 加了下面这两行，对属性进了比对
        EqualsDemo that = (EqualsDemo) o;
        return m == that.m;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面看起来好像没什么问题了，但是实际运行却很容易出现&lt;strong&gt;空指针异常或者类型转换异常&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为equals方法中，我们在&lt;strong&gt;强转之前没有对参数 o 进行检查&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;检查什么呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;检查两个地方：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;首先要确保o不能为空null&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;其次确保o是EqualsDemo类或者子类&lt;/strong&gt;（父类行不行？不行，父类没有子类特有的属性，强转还是会报错）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class EqualsDemo {
    private int m;
    // 省略 getter,setter,constructor(m)
    public static void main(String[] args) {
        EqualsDemo demo1 = new EqualsDemo(1);
        EqualsDemo demo2 = new EqualsDemo(1);
        System.out.println(demo1.equals(demo2));
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        // 加了这一行判断
        if (!(o instanceof EqualsDemo)) return false;
        EqualsDemo that = (EqualsDemo) o;
        return m == that.m;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面用到了instanceof来判断（别，我知道你要说啥，朋友咱先往下看）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/10/RzsOjdWrLeFQPc8.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;

&lt;p&gt;instanceof的用法是 A instanceof B，用来判断A是否为B类或者B的子类&lt;/p&gt;

&lt;p&gt;这样就可以防止空指针和转换异常的出现&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以equals判断的内容总结下来就是三步&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;判断两个引用指向的对象是否相等&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;判断传来的参数是否为当前类或者当前类的子类&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;比较各个属性值是否相等&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;如果属性是对象的引用，那第三步该怎么比呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那就有点像套娃了（&lt;strong&gt;什么？没听过套娃？强烈推荐你去看陈翔六点半，里面有很多套娃的案例【您的账户已到账0.5毛】&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/10/MrxdGf6W93DVOa7.png&quot; alt=&quot;到账&quot;/&gt;&lt;/p&gt;

&lt;p&gt;比如下面的代码&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class EqualsDemo {
    private int m;
    private String str;

    public static void main(String[] args) {
        EqualsDemo demo1 = new EqualsDemo(1, &quot;JavaLover1&quot;);
        EqualsDemo demo2 = new EqualsDemo(1, &quot;JavaLover1&quot;);
        System.out.println(demo1.equals(demo2));
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof EqualsDemo)) return false;
        EqualsDemo demo = (EqualsDemo) o;
        // 改了这行
        return m == demo.m &amp;amp;&amp;amp; str.equals(demo.str);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，多了一个String对象引用作为属性&lt;/p&gt;

&lt;p&gt;那我们在比较的时候，根据套娃的原则，再次&lt;strong&gt;利用String对象的equals方法进行比较即可&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其他的部分都一样&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;好了，现在equals方法写完了，我上个厕所先&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;真的写完了吗？我不信（脑补ing。。。）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因为还是有潜在的空指针异常&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;设想一下，上面str真的会存在吗？如果str为null怎么办？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以我们还要对str进行空指针判断，不过不需要我们来做，而是通过Objects这个工具类（Java7诞生的一个工具类），它内置的equals&lt;/p&gt;

&lt;p&gt;方法可以帮你在比较两个对象的同时加上null判断&lt;/p&gt;

&lt;p&gt;Objects.equals方法如下：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public final class Objects {
    public static boolean equals(Object a, Object b) {
        return (a == b) || (a != null &amp;amp;&amp;amp; a.equals(b));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改了以后的equals()最终代码如下：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt; @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof EqualsDemo)) return false;
        EqualsDemo demo = (EqualsDemo) o;
        return m == demo.m &amp;amp;&amp;amp; Objects.equals(str,demo.str);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，万事俱备了，只欠东风&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/10/WeHUlABZijkfRy7.jpg&quot; alt=&quot;东风&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;东风？什么东风？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;东风就是你的父亲啊&lt;/p&gt;

&lt;p&gt;如果是在子类中定义equals，那么还要考虑到父类（如果直接继承自Object则不考虑）&lt;/p&gt;

&lt;p&gt;改了之后的代码如下：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;@Override
public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof EqualsDemo)) return false;
        // 加了这一行
        if(!super.equals(o)) return false;
        EqualsDemo demo = (EqualsDemo) o;
        return m == demo.m &amp;amp;&amp;amp; Objects.equals(str,demo.str);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;你可能想知道，为啥放到第三行？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那是因为前两行属于最外侧的判断&lt;/p&gt;

&lt;p&gt;你可以这样想，如果传来的对象o是父类的对象，那么父类super的判断放在这个位置就很合适了&lt;/p&gt;

&lt;p&gt;（因为此时&lt;code&gt;o instanceof EqualsDemo&lt;/code&gt;肯定返回false,这样就省去了super.equals()的判断)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;好了，我累了，可以结束了吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/10/D9h8wPkoAusWMOH.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;

&lt;p&gt;等一下，地球还没有毁灭，事情也还没有结束。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;上面的instanceof有个很大的缺陷，就是违反了equals的对称性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面我们顺藤摸瓜，来说下equals方法规范的5个特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;自反性：就是自己反过来跟自己比，要返回true；比如x.equals(x) == true&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对称性：就是x.equals(y) == true时，也要y.equals(y) == true&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传递性：就是x.equals(y) == true,同时y.equals(z) == true，那么x.equals(z) == true&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性：就是传说中的幂等性，即x.equals(y)调用多次，都应该返回一样的结果&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非空和空比较则返回false的特性：就是x.equals(y)中，如果x非空，而y空，则返回false&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;好了，回到instanceof，上面提到它没有满足对称性&lt;/p&gt;

&lt;p&gt;是因为用了instanceof来做比较的话，Son.equals(Father)永远不会为真，而Father.equals(Son)却有可能为真，这就不对称了&lt;/p&gt;

&lt;p&gt;所以干脆就让Father.equals(Son)也永远不为真&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;那要怎么做呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答案就是instanceof的弟弟：getClass&lt;/p&gt;

&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt;&lt;strong&gt;用来判断是否为当前类或者子类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;getClass&lt;/code&gt;&lt;strong&gt;只用来判断是否为当前类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;改了之后，代码如下&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if(!super.equals(o)) return false;
        EqualsDemo demo = (EqualsDemo) o;
        return m == demo.m &amp;amp;&amp;amp; Objects.equals(str,demo.str);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，看朋友们也累了，今天的equals方法就先到这里了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/10/WpQa6cbHPELNhro.png&quot; alt=&quot;over&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面总结下equals方法的核心内容，总共就是五步（这次真的是结束了）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;判断两个引用指向的对象是否相等&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;判断传来的参数是否为空&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;判断传来的参数是否属于当前类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果有继承父类，则也需要调用父类的super.equals()方法（Object除外）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最后比较各个属性值是否相等（如果属性为对象引用，则需要通过Objects.equals(a,b)方法来比较引用对象的属性值）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;什么是hashCode()方法&lt;/h3&gt;

&lt;p&gt;hashCode也叫散列码（哈希码），它用来计算对象中所有属性的散列值&lt;/p&gt;

&lt;p&gt;关于散列这里就不展开了，我们在这里只需要知道两点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;散列值为整数，可以为负值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;散列值可以用来确定元素在散列表中的位置&lt;/strong&gt;（有可能两个元素拥有相同的散列值，这个就是散列冲突）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在Object中，hashCode()是一个本地方法，因为Object没有属性，所以默认返回的是&lt;strong&gt;对象的内存地址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;代码如下所示：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class Test2 {
    public static void main(String[] args) {
        Object t = new Object();
        int a = t.hashCode();
        System.out.println(Integer.toHexString(a)); // 输出 4554617c
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;4554617c&lt;/code&gt;就是对象a的内存地址,这里转成16进制显示（是因为通常地址都是用16进制显示的，比如我们电脑的Mac地址）&lt;/p&gt;

&lt;p&gt;下面总结下&lt;code&gt;hashCode&lt;/code&gt;的几个特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;一致性：无论hashCode调用多少次，都应该返回一样的结果(这一点跟equals很像)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跟随性（自己编的一个性）：如果两个对象的equals返回为真，那么hashCode也应该相等&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反过来，如果两个对象的equals返回为假，那么hashCode有可能相等，但是如果散列的足够好，那么通常来说hashCode()也不应该相等&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;覆写equals方法时，一定要覆写hashCode方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;equals和hashCode有什么联系呢？&lt;/h3&gt;

&lt;p&gt;hashCode和equals可以说相辅相成的，他俩共同协作用来判断两个对象是否相等&lt;/p&gt;

&lt;p&gt;如果分开来看的话，他俩是没什么联系的，但是由于某些原因导致被联系上了（比如HashMap这个小月老）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/10/1ozwTpD9O2RAScF.jpg&quot; alt=&quot;红线&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面来细说一下&lt;/p&gt;

&lt;p&gt;我们知道 HashMap集合中的key是不能重复的，那它是怎么判断重复的呢？&lt;/p&gt;

&lt;p&gt;就是通过equals和hashCode来判断的&lt;/p&gt;

&lt;p&gt;下面是部分源码&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;if (e.hash == hash &amp;amp;&amp;amp;
    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
    return e;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，map先进行hash判断，然后进行equals判断&lt;/p&gt;

&lt;p&gt;也就是说，hash是前提，如果hash都不相等，那equals就不用比较了（先计算hash的一个原因是计算hash比equals快得多）&lt;/p&gt;

&lt;p&gt;所以我们在自定义对象时，如果覆写了equals，那么一定要记得覆写hashCode,(当然，假设这里的自定义对象是用来作为map中的key键的)&lt;/p&gt;

&lt;p&gt;覆写代码如下：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if(getClass() != o.getClass()) return false;
        if(!super.equals(o)) return false;
        EqualsDemo demo = (EqualsDemo) o;
        return m == demo.m &amp;amp;&amp;amp; Objects.equals(str,demo.str);
    }

    @Override
    public int hashCode() {
        return Objects.hash(m, str);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中Objects.hash有点类似于上面的Objects.equals()方法，很实用&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果只覆写了equals，没有覆写hashCode,会咋样呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;结果就是：&lt;/p&gt;

&lt;p&gt;当你创建两个对象（属性一致，但是内存地址不一致），作为key放到map中时就会被当成两个key来存放&lt;/p&gt;

&lt;p&gt;同理可得，获取数据value的时候，也是不一致的&lt;/p&gt;

&lt;p&gt;下面是只覆写equals没覆写hashCode的代码：可以看到，两次取到的值是不一样的&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class HashCodeDemo{

    public static void main(String[] args) {
        // 两个对象的属性都为n = 1
        HashCodeDemo demo1 = new HashCodeDemo(1);
        HashCodeDemo demo2 = new HashCodeDemo(1);
        Map&amp;lt;HashCodeDemo, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(demo1, 1);
        map.put(demo2, 2);
        System.out.println(map.get(demo1)); // 输出1
        System.out.println(map.get(demo2)); // 输出2
    }

    private int n;

    public HashCodeDemo(int n) {
        this.n = n;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        HashCodeDemo that = (HashCodeDemo) o;
        return n == that.n;
    }

    public int getN() {
        return n;
    }

    public void setN(int n) {
        this.n = n;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时覆写equals和hashCode的代码：可以看到，两次取到的值都是一样的&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class HashCodeDemo{

    public static void main(String[] args) {
        HashCodeDemo demo1 = new HashCodeDemo(1);
        HashCodeDemo demo2 = new HashCodeDemo(1);
        Map&amp;lt;HashCodeDemo, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(demo1, 1);
        // 第二次会覆盖第一次的值，因为key相等（equals和hashCode都相等）
        map.put(demo2, 2);
        System.out.println(map.get(demo1)); // 输出2
        System.out.println(map.get(demo2)); // 输出2
    }

    private int n;

    public HashCodeDemo(int n) {
        this.n = n;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        HashCodeDemo that = (HashCodeDemo) o;
        return n == that.n;
    }

    @Override
    public int hashCode() {
        return Objects.hash(m, str);
    }

    public int getN() {
        return n;
    }

    public void setN(int n) {
        this.n = n;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HashSet集合也是同理，因为它内部的就是依赖HashMap实现的（这个前面有简单介绍过，感兴趣的可以回顾一下）&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;



&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;自反性：就是自己反过来跟自己比，要返回true；比如x.equals(x) == true&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对称性：就是x.equals(y) == true时，也要y.equals(y) == true&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传递性：就是x.equals(y) == true,同时y.equals(z) == true，那么x.equals(z) == true&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性：就是传说中的幂等性，即x.equals(y)调用多次，都应该返回一样的结果&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;非空和空比较则返回false的特性：就是x.equals(y)中，如果x非空，而y空，则返回false&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;



&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;一致性：无论hashCode调用多少次，都应该返回一样的结果(这一点跟equals很像)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跟随性（自己编的一个性）：如果两个对象的equals返回为真，那么hashCode也应该相等&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反过来，如果两个对象的equals返回为假，那么hashCode有可能相等，但是如果散列的足够好，那么通常来说hashCode()也不应该相等&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;覆写equals方法时，一定要覆写hashCode方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;后记&lt;/h2&gt;

&lt;p&gt;最后，感谢大家的观看，谢谢&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9523cc695374272748ae5f1af4fabe42</guid>
<title>玩转 EhCache 缓存框架</title>
<link>https://toutiao.io/k/208pivk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心、分布式配置等常用开源组件，大概有几十篇文章，陆续会开放出来，感兴趣同学请提前关注&amp;amp;收藏&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Ehcache 介绍&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;EhCache 从 Hibernate 发展而来，是一个纯Java的进程内缓存框架，具有快速、精干等特点。Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存，Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器，缓存扩展，缓存异常处理程序，一个gzip缓存servlet过滤器，支持REST和SOAP api等特点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主要特性：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;快速，简单&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多种缓存策略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓存数据有两级：内存和磁盘，因此无需担心容量问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓存数据会在虚拟机重启的过程中写入磁盘&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以通过RMI、可插入API等方式进行分布式缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;具有缓存和缓存管理器的侦听接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持多缓存管理器实例，以及一个实例的多个缓存区域&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供Hibernate的缓存实现&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI5NDAwMzM0MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/3Ohm6WHibeXJY3p8ibo9XeCic0sLhnu7GGMo7TiacVcs0wM8dKUzwjjsX9CVPLTZqZsVNgWCWgjTiaFhZ2elNs9RB8Q/0?wx_fmt=png&quot; data-nickname=&quot;微观技术&quot; data-alias=&quot;weiguanjishu&quot; data-signature=&quot;业务架构、职业规划、源码解读等，畅想技术改变人生&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Show me the code&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在 pom.xml 文件中添加 Ehcache 依赖&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;spring-boot-starter-cache&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;net.sf.ehcache&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;ehcache&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;不需要配置version，SpringBoot的根pom已经对版本号做了统一声明！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;配置文件：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在配置文件 &lt;code&gt;application.yaml&lt;/code&gt; 中配置 ehcache 的相关参数，具体内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;spring:&lt;br/&gt;  application:&lt;br/&gt;    name: spring-boot-bulking-ehcache&lt;br/&gt;&lt;br/&gt;  cache:&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: ehcache&lt;br/&gt;    ehcache:&lt;br/&gt;      config: classpath:/ehcache.xml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;spring.cache.type 声明spring框架使用哪一种类型的缓存，因为spring框架提供了多种缓存可供选择。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;添加 Ehcache 配置：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;src/main/resources&lt;/code&gt; 目录下，创建配置文件&lt;code&gt;ehcache.xml&lt;/code&gt; ，内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;ehcache name=&lt;span&gt;&quot;test&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;diskStore path=&lt;span&gt;&quot;java.io.tmpdir&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;    &amp;lt;defaultCache&lt;br/&gt;            maxEntriesLocalHeap=&lt;span&gt;&quot;1000&quot;&lt;/span&gt;&lt;br/&gt;            eternal=&lt;span&gt;&quot;false&quot;&lt;/span&gt;&lt;br/&gt;            timeToIdleSeconds=&lt;span&gt;&quot;300&quot;&lt;/span&gt;&lt;br/&gt;            timeToLiveSeconds=&lt;span&gt;&quot;600&quot;&lt;/span&gt;&lt;br/&gt;            overflowToDisk=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&lt;br/&gt;            memoryStoreEvictionPolicy=&lt;span&gt;&quot;LRU&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;/defaultCache&amp;gt;&lt;br/&gt;    &amp;lt;cache name=&lt;span&gt;&quot;userCache&quot;&lt;/span&gt;&lt;br/&gt;           maxEntriesLocalHeap=&lt;span&gt;&quot;200&quot;&lt;/span&gt;&lt;br/&gt;           eternal=&lt;span&gt;&quot;false&quot;&lt;/span&gt;&lt;br/&gt;           timeToIdleSeconds=&lt;span&gt;&quot;300&quot;&lt;/span&gt;&lt;br/&gt;           timeToLiveSeconds=&lt;span&gt;&quot;600&quot;&lt;/span&gt;&lt;br/&gt;           overflowToDisk=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;/cache&amp;gt;&lt;br/&gt;&amp;lt;/ehcache&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参数含义：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;diskStore：磁盘缓存位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;name：缓存名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;maxElementsInMemory：内存中最大缓存对象数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;maxElementsOnDisk：硬盘中最大缓存对象数，若是0表示无穷大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;eternal：true表示对象永不过期，此时会忽略timeToIdleSeconds和timeToLiveSeconds属性，默认为false&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;timeToIdleSeconds：设定允许对象处于空闲状态的最长时间，以秒为单位。当对象自从最近一次被访问后，如果处于空闲状态的时间超过了timeToIdleSeconds属性值，这个对象就会过期，EHCache将把它从缓存中清空。只有当eternal属性为false，该属性才有效。如果该属性值为0，则表示对象可以无限期地处于空闲状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;timeToLiveSeconds：设定对象允许存在于缓存中的最长时间，以秒为单位。当对象自从被存放到缓存中后，如果处于缓存中的时间超过了 timeToLiveSeconds属性值，这个对象就会过期，EHCache将把它从缓存中清除。只有当eternal属性为false，该属性才有效。如果该属性值为0，则表示对象可以无限期地存在于缓存中。timeToLiveSeconds必须大于timeToIdleSeconds属性，才有意义&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;diskSpoolBufferSizeMB：磁盘缓存区大小，默认为30MB。每个Cache都应该有自己的一个缓存区。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;diskPersistent：是否缓存虚拟机重启期数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;clearOnFlush：内存数量最大时是否清除。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;开启缓存：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入口启动类添加注解 &lt;code&gt;@EnableCaching&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class,&lt;br/&gt;        DataSourceTransactionManagerAutoConfiguration.class})&lt;br/&gt;@EnableCaching  // 开启缓存，Spring Boot 会自动配置缓存的 CacheManager&lt;br/&gt;public class StartApplication {&lt;br/&gt;&lt;br/&gt;    public static void main(String[] args) {&lt;br/&gt;        SpringApplication.run(StartApplication.class, args);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缓存业务使用：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Component&lt;br/&gt;@CacheConfig(cacheNames = &lt;span&gt;&quot;userCache&quot;&lt;/span&gt;)&lt;br/&gt;public class UserService {&lt;br/&gt;&lt;br/&gt;    @Cacheable(key = &lt;span&gt;&quot;#id&quot;&lt;/span&gt;)&lt;br/&gt;    public User getUserById(Long id) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;缓存中无值&quot;&lt;/span&gt;);&lt;br/&gt;        User user = User.builder().id(id).userName(&lt;span&gt;&quot;雪糕(&quot;&lt;/span&gt; + id + &lt;span&gt;&quot;)&quot;&lt;/span&gt;).age(18).address(&lt;span&gt;&quot;杭州&quot;&lt;/span&gt;).build();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @CachePut(key = &lt;span&gt;&quot;#user.id&quot;&lt;/span&gt;)&lt;br/&gt;    public User updateUser(User user) {&lt;br/&gt;        user.setUserName(&lt;span&gt;&quot;雪糕（new name）&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @CacheEvict(key = &lt;span&gt;&quot;#id&quot;&lt;/span&gt;)&lt;br/&gt;    public void deleteById(Long id) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;db 删除数据，id=&quot;&lt;/span&gt; + id);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;@CacheConfig  作用于类上，用来描述该类中所有方法使用的缓存名称。当然也可以不使用该注解，直接在具体方法上的缓存注解里配置名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Cacheable 用于查询方法上，表示将一个方法的返回值缓存起来。默认情况下，缓存的 key 就是方法的参数，缓存的 value 就是方法的返回值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@CachePut  更新操作，当数据库中的数据更新后，缓存中的数据也要跟着更新，使用该注解，可以将方法的返回值自动更新到已经存在的 key 上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@CacheEvict  删除操作，当数据库中的数据删除后，相关的缓存数据也要自动清除。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了采用 &lt;code&gt;@Cacheable&lt;/code&gt; 、&lt;code&gt;@CachePut&lt;/code&gt; 等方法注解解耦式操作缓存外，我们也可以使用 &lt;code&gt;CacheManager&lt;/code&gt;显示方式手动来操作缓存。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CacheManager&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring定义了&lt;code&gt;CacheManager&lt;/code&gt;和&lt;code&gt;Cache&lt;/code&gt;接口统一不同的缓存技术。其中&lt;code&gt;CacheManager&lt;/code&gt;是Spring提供的各种缓存技术的抽象接口，而&lt;code&gt;Cache&lt;/code&gt;接口包含缓存的读、写、删等各种操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对不同的缓存技术，需要实现不同的&lt;code&gt;CacheManager&lt;/code&gt;，Spring预先定义了主流缓存框架的cacheManger实现类&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3564516129032258&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXIWIoFmcdJVzCHToFicBxWKfG19DzxGxU6VAf33l8o8U6JOPhwBO09ibnMZKMjIuBcG4WKZzw6KVjuQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;CacheManager&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;SimpleCacheManager&lt;/td&gt;&lt;td&gt;使用简单的Collection来存储缓存，主要用于测试&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ConcurrentMapCacheManager&lt;/td&gt;&lt;td&gt;使用ConcurrentMap作为缓存技术（默认）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;NoOpCacheManager&lt;/td&gt;&lt;td&gt;测试用&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;EhCacheCacheManager&lt;/td&gt;&lt;td&gt;使用EhCache作为缓存技术，以前在hibernate的时候经常用&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GuavaCacheManager&lt;/td&gt;&lt;td&gt;使用google guava的GuavaCache作为缓存技术&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;HazelcastCacheManager&lt;/td&gt;&lt;td&gt;使用Hazelcast作为缓存技术&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JCacheCacheManager&lt;/td&gt;&lt;td&gt;使用JCache标准的实现作为缓存技术，如Apache Commons JCS&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RedisCacheManager&lt;/td&gt;&lt;td&gt;使用Redis作为缓存技术&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CaffeineCacheManager&lt;/td&gt;&lt;td&gt;使用Caffeine作为缓存技术&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Spring Boot 为我们预留接口扩展，方便我们自动配置 EhCache、Redis、Guava、ConcurrentMap等缓存，默认使用ConcurrentMapCacheManager。Spring Boot的&lt;code&gt;application.yaml&lt;/code&gt;配置文件，使用&lt;code&gt;spring.cache&lt;/code&gt;前缀属性进行配置。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们使用 &lt;code&gt;EhCache&lt;/code&gt; 缓存，代码示例如下：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.41015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXIWIoFmcdJVzCHToFicBxWKfEicxPtj0es9OfS9hiafY2icGBHGZ2XibUTdUgjZKQ3RhXwxficvrjhh9wgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Component&lt;br/&gt;public class UserCacheManager {&lt;br/&gt;&lt;br/&gt;    @Resource&lt;br/&gt;    private CacheManager cacheManager;&lt;br/&gt;&lt;br/&gt;    public User getUserById(Long id) {&lt;br/&gt;        Cache cache = cacheManager.getCache(&lt;span&gt;&quot;userCache&quot;&lt;/span&gt;);&lt;br/&gt;        User user = cache.get(id, User.class);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (user == null) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;缓存中无值&quot;&lt;/span&gt;);&lt;br/&gt;            user = User.builder().id(id).userName(&lt;span&gt;&quot;雪糕(&quot;&lt;/span&gt; + id + &lt;span&gt;&quot;)&quot;&lt;/span&gt;).age(18).address(&lt;span&gt;&quot;杭州&quot;&lt;/span&gt;).build();&lt;br/&gt;            cache.put(id, user);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public User updateUser(User user) {&lt;br/&gt;        user.setUserName(&lt;span&gt;&quot;雪糕（new name）&quot;&lt;/span&gt;);&lt;br/&gt;        Cache cache = cacheManager.getCache(&lt;span&gt;&quot;userCache&quot;&lt;/span&gt;);&lt;br/&gt;        cache.put(user.getId(), user);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void deleteById(Long id) {&lt;br/&gt;        Cache cache = cacheManager.getCache(&lt;span&gt;&quot;userCache&quot;&lt;/span&gt;);&lt;br/&gt;        cache.evict(id);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;db 删除数据，id=&quot;&lt;/span&gt; + id);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;演示代码地址&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https://github.com/aalansehaiyang/spring-boot-bulking  &lt;br/&gt;&lt;br/&gt;模块：spring-boot-bulking-ehcache&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXJxE2KOULCAe2BQfUfcd9Lf2kqibBfdJrGWFPBdoialWJAiaG8FPicR15jW3s75tfS1hKNK9TdqdYjicAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;1&quot; data-w=&quot;258&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们热衷于收&lt;/span&gt;&lt;span&gt;集高并发、系统架构、微服务、消息中间件、 RPC框架、高性能缓存、搜索、分布式数据框架、分布式协同服务、分布式配置中心、中台架构、领域驱动设计、系统监控、系统稳定性等技术知识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;原创不易，如果感觉本文对您有帮助，请转发分享，点个“在看”！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>43e40e90aa746d773d00b5b46239b81d</guid>
<title>笔记：5 种网络 IO 模型</title>
<link>https://toutiao.io/k/v9bis1a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.19889502762430938&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/5hLBZVCyG9TSaWN1KPgU0HGEM8uPibRI0EibXsqcxPqdT32GB3s1RE0PxvZfnyzL8ZNkiaLk6h12AsZiap60ZuCtmg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;181&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;点击上方蓝色字关注我们~&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;26075&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-form=&quot;0&quot; data-num=&quot;1&quot;&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;阻塞I/O blocking i/o&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;305&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5285140562248996&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9QFX9R9FBYIEibkEtLu7zAOUZWcfylygyLONaQY4Cn8HOjnL6UYXH5MuB942kaO006RnQuQdNAdNKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1245&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;①等待数据：需要&lt;span&gt;等待数据拷贝进内核&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②需要&lt;span&gt;等内核将数据复制到用户空间&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;◇&lt;/span&gt;优点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：①能够&lt;span&gt;及时返回&lt;/span&gt;数据，&lt;span&gt;无延迟&lt;/span&gt;。②内核开发者省事。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;◇&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：对用户来说处于等待就要付出&lt;span&gt;性能的代价&lt;/span&gt;了&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;26075&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-form=&quot;0&quot; data-num=&quot;2&quot;&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;非阻塞I/O nonblocking i/o&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;341&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5907207953603977&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9QFX9R9FBYIEibkEtLu7zAOU4NEVYJKeIwXnLfr4Z3R0w9YXib5Rq6FLUKwXQoiclPoJuB8ib3IWxcgKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1207&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;用户进程需要&lt;span&gt;不断的主动询问kernel&lt;/span&gt;数据好了没有。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户进程发出read操作，由于内核还没有准备好数据，所以马上返回一个error标识，用户进程知道内核还没准备好，所以并没有block，而且还会轮询的调用read询问数据是否准备好，内核准备好后就返回给用户进程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;同步非阻塞方式相比同步阻塞方式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;◇&lt;/span&gt;&lt;strong&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：能够在&lt;span&gt;等待任务完成的时&lt;/span&gt;间里&lt;span&gt;干其他活&lt;/span&gt;了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;◇&lt;/span&gt;&lt;span&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：任务完成的&lt;span&gt;响应延迟增大&lt;/span&gt;了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据&lt;span&gt;吞吐量的降低&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;26075&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-form=&quot;0&quot; data-num=&quot;3&quot;&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;I/O多路复用 i/o multicomplexing&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;373&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6452795600366636&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9QFX9R9FBYIEibkEtLu7zAOUqKfh6icIrySmuqPYl0uRS5OGRiajoiawxib1DV5HVokTaetMlWXUKpufwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1091&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基本原理就是select，poll，epoll这个function会&lt;span&gt;不断的轮询所负责的所有socket&lt;/span&gt;，当某个socket有&lt;span&gt;数据到达&lt;/span&gt;了，就&lt;span&gt;通知用户进程&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用&lt;span&gt;read&lt;/span&gt;操作，&lt;span&gt;将数据从kernel拷贝到用户进程&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息。IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程状态为阻塞。所以，把IO多路复用归为同步阻塞模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;26075&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-form=&quot;0&quot; data-num=&quot;2&quot;&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;信号驱动式IO（signal-driven IO）&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;373&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6441774491682071&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9QFX9R9FBYIEibkEtLu7zAOU16sVVNiaQvKINKTsth5FluRpB9eQru826ZBXXILkOIPHKfFuQeb9bjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1082&quot;/&gt;、&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;26075&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-form=&quot;0&quot; data-num=&quot;2&quot;&gt;05&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;异步 IO（asynchronous IO）&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;349&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6030741410488246&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9QFX9R9FBYIEibkEtLu7zAOUD9hlU8HRHl0UDlLqicSJgnia4jADmjs958SxGzB27jEEZpO4DibJ6HzZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1106&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;用户进程进行aio_read系统调用之后，&lt;span&gt;无论内核数据是否准备&lt;/span&gt;好，都会&lt;span&gt;直接返回给用户进程&lt;/span&gt;，然后用户态进程可以去做别的事情。等到socket数据准备好了，&lt;span&gt;内核直接复制数据给进程&lt;/span&gt;，然后&lt;span&gt;从内核向进程发送通知&lt;/span&gt;。IO两个阶段，进程都是非阻塞的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;异步 IO 的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1618019958824&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1618019958824&quot;/&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;26075&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-form=&quot;0&quot; data-num=&quot;3&quot;&gt;06&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5种IO模型区别&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;372&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.643796992481203&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9QFX9R9FBYIEibkEtLu7zAOU0uo07yibKkpIphswDum01g0zbECFkich4SeQnnqOM8muDticw81Nicrt1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1064&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;◇&lt;/span&gt;blocking和non-blocking区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;调用blocking IO会&lt;span&gt;一直block住&lt;/span&gt;对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会&lt;span&gt;立刻返回&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;◇&lt;/span&gt;synchronous IO和asynchronous IO区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果喜欢视频版的，请点击左下角“查看原文”，我录的B站视频↓&lt;span&gt;↓&lt;/span&gt;&lt;span&gt;↓&lt;/span&gt;，希望对你有用。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.61328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9SRwkEkcnzlrXwmr7fSpQbHTuAKryxFUGWGfHyKCFdqkeQyQ2iaYOFlnLibibD7wux4vGmMMkMsFO5dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;【笔记系列】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454934251&amp;amp;idx=1&amp;amp;sn=77f210efd1960589975422e9000fb9e4&amp;amp;chksm=871a1853b06d9145c104c8ba9b7ef6df9e223ce227048422359be76a334c2c9adc4e822f9c29&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Java对象探秘&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;笔记 | Java对象探秘&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454934264&amp;amp;idx=1&amp;amp;sn=9c08f626d627122645c78c18563c4cf9&amp;amp;chksm=871a1840b06d9156e3bbea12e17d5fff668b4c717005be6c7462cfd746b3af1961e423faf27f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;JVM内存区域结构：一计两栈一堆一区&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;笔记 | JVM内存区域结构：一计两栈一堆一区&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454934346&amp;amp;idx=1&amp;amp;sn=4067d49c5e56f5a805a46c7e6daebd8c&amp;amp;chksm=871a19f2b06d90e4ab8f3b4d9b4a1fdabd7f4ec91493a8fbc0572334b2ef97b6f1a57f96ba5a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;笔记 | 面试官问我：TCP与UDP的区别&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454934425&amp;amp;idx=1&amp;amp;sn=7ca25eafb3098ff3e2b5f98ce323be47&amp;amp;chksm=871a1921b06d9037257e123d7646141e936b53bbba448bed35b13b288132410426e4854c36b4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;笔记 | 网络编程基础：TCP如何保证可靠性&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454934505&amp;amp;idx=1&amp;amp;sn=388f9b70b5e5a1791f79ba66de471152&amp;amp;chksm=871a1951b06d9047bc697fdd4c912fb61783a17d45dd7f409819147576573bb6493449f56869&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;笔记 | 面试又挂了，只因问了：TCP三次握手和四次挥手&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;回复公众号【&lt;/span&gt;&lt;span&gt;资料&lt;/span&gt;&lt;span&gt;】获得干货资料集锦：技术ppt、IT大会资料、架构、分布式资料等。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐好文&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454933881&amp;amp;idx=1&amp;amp;sn=4f2bdecf4596d24559ebc519363e6639&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;互联网Code Review最佳实践分享&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;互联网Code Review最佳实践分享&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454932968&amp;amp;idx=1&amp;amp;sn=f85707232789cbb41c2bebffcb67507b&amp;amp;chksm=871a0750b06d8e467e49858d7c1d64604a84d1316324e30976071fd30347813d490ef4e175b5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;dubbo面试题！会这些，说明你看懂了dubbo源码&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;dubbo面试题！会这些，说明你看懂了dubbo源码&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454933508&amp;amp;idx=1&amp;amp;sn=f993f90fd83c0eca8cd1b15a9b6db017&amp;amp;chksm=871a1abcb06d93aa36ebe2ff761193030d3f886f5b6ee894bab49eaccbc0cf30986d078e8e66&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kafka面试题！掌握它才说明你真正懂Kafka&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Kafka面试题！掌握它才说明你真正懂Kafka&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span/&gt;&lt;br/&gt;&lt;strong&gt;4、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454932288&amp;amp;idx=1&amp;amp;sn=149a790e4d3d6b2722ccdb677e54a666&amp;amp;chksm=871a01f8b06d88eeac9200e146c3d3de70351b2deb4e85339a037a6f21c06d8a7b0b299880eb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Netty 5.0为啥被舍弃？原因竟然是...&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Netty 5.0为啥被舍弃？原因竟然是...&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span/&gt;&lt;br/&gt;&lt;strong&gt;5、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454933647&amp;amp;idx=1&amp;amp;sn=7021d7c3d4a02de5178c86b7af85be52&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;中台之上——业务架构系列【汇总】&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;中台之上——业务架构系列【汇总】&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454932251&amp;amp;idx=1&amp;amp;sn=e69867ba84a8307a61ab9f2b3ceba32a&amp;amp;chksm=871a01a3b06d88b55e18267f4b243f4ce3647e4d31979d6ce7d6f34676837be405427e82df5f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;必备瑞士军刀IDEA插件，你使用了哪些&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;必备瑞士军刀IDEA插件，你使用了哪些&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454934195&amp;amp;idx=1&amp;amp;sn=62869742d0cdebcef26a0732c9bb03ec&amp;amp;chksm=871a180bb06d911d4da8ab7c3b7699f033d0f0ede1d2eab5263e273ad08c8d1837facd809ae9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;线上热更新代码只需3步 Arthas实战&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;线上热更新代码只需3步 Arthas实战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;8、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454934176&amp;amp;idx=1&amp;amp;sn=b94dd05ecff649c73a89ef191208c0f0&amp;amp;chksm=871a1818b06d910ecdee7d912abb31b3b6bb4efe7cfbc6241b517193f1c4523c075188c724c2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Eureka源码剖析之七：架构&amp;amp;面试题【总结】&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Eureka源码剖析之七：架构&amp;amp;面试题【总结】&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;9、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NTUzNTA2Mw==&amp;amp;mid=2454933958&amp;amp;idx=1&amp;amp;sn=fcb60a3e46cdff2684fef0e864eee94b&amp;amp;chksm=871a1b7eb06d92680136868aef9a35d59e6c071dda30e67bad75c9c44a0fccba2229d7536ce6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;互联网工程师应该用这种姿势打印日志&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;互联网工程师应该用这种姿势打印日志&lt;br/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5hLBZVCyG9TSaWN1KPgU0HGEM8uPibRI0xaL9KEnrpjk93rg8UeYsv7G4LVicvD8EOxfDq9rPfUSibarNsLZ5u0Vg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-关注搬运工来架构，与优秀的你一同进步-&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原创不易，如果喜欢这篇文章可以点在看哦↘&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>