<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3943f00f34fad794ad60b273b92948cb</guid>
<title>如何使用Go调用Kubernetes API？</title>
<link>https://toutiao.io/k/ctnjr3u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;官方的Kubernetes Go客户端装载了高级抽象——Clientset、Informers、Cache、Scheme、Discovery，哦，天哪！当我尝试在没有学习移动部分的情况下使用它时，我遇到了大量的新概念。这是一次不愉快的经历，但更重要的是，它削弱了我在代码中做出明智决定的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;因此，我决定通过对客户端组件的彻底研究来解开这个谜。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;但是从哪里开始呢？在剖析client-go本身之前，了解它的两个主要依赖项可能是一个好主意，k8s.io/api和k8s.io/apimachinery模块。这将简化主要任务，但这不是唯一的好处。&lt;/span&gt;&lt;span&gt;这两个模块被分离出来是有原因的——它们不仅可以被客户端使用，也可以被服务器端使用，或者被处理Kubernetes对象的任何其他软件使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzC9vlNS5jTmI3X1lJiaicP0I5xhIIhlIRZE5OVDzdJofMOvicUKCKEbt43r6XFK4wDl8H7sCBvzFgFuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4722222222222222&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;1&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;API资源、类和对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;首先，快速&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg5Mjc3MjIyMA==&amp;amp;mid=2247544647&amp;amp;idx=2&amp;amp;sn=721d6dcfc8f9eb6e5f4c95b528757375&amp;amp;chksm=c03b6554f74cec42de34bfdba9f0c2424726fbaf02b7cf8fcc98312c11a72e78072be01d4db6&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;回顾一下&lt;/a&gt;。熟悉以下概念对进一步讨论的成功至关重要：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;资源类型——一个由Kubernetes API端点服务的实体：Pod、Deployment、ConfigMap等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;API组——资源类型被组织成版本化的逻辑组：apps/v1、batch/v1、storage.k8s.io/v1beta1等等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对象——一个资源实例——每个API端点都处理特定资源类型的对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;类——API返回或接受的每个对象都必须符合一个对象模式——由其类型定义的属性的特定组合Pod、Deployment、ConfigMap等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;同样重要的是要区分广义对象和Kubernetes的“一级”对象——像Pod、Service或Secret这样的持久实体，它们作为集群的意图的记录。虽然为了序列化和反序列化，每个API对象都必须有一个API版本和类型属性，但并不是每个API对象都是“一级”Kubernetes对象。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzC9vlNS5jTmI3X1lJiaicP0I58BchNCCxpgYbJZg4tAeXLK57fdIo5zBibLOOZiaibw6aDmhvBmrADIibxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5287037037037037&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;2&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;k8s.io/api模块&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Go是一种静态类型的编程语言。那么，与Pod、ConfigMap、Secret和其他一级Kubernetes对象对应的所有结构在哪里呢？对，在k8s.io/api。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;尽管命名松散，k8.io/api模块似乎只用于API类型定义。它充满了固定结构，与我们都知道和喜爱的YAML体现的那些内容非常相似：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;  &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  appsv1 &lt;span&gt;&quot;k8s.io/api/apps/v1&quot;&lt;/span&gt;&lt;br/&gt;  corev1 &lt;span&gt;&quot;k8s.io/api/core/v1&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  deployment := appsv1.Deployment{&lt;br/&gt;    Spec: appsv1.DeploymentSpec{&lt;br/&gt;      Template: corev1.PodTemplateSpec{&lt;br/&gt;        Spec: corev1.PodSpec{&lt;br/&gt;          Containers: []corev1.Container{&lt;br/&gt;            { Name:  &lt;span&gt;&quot;web&quot;&lt;/span&gt;, Image: &lt;span&gt;&quot;nginx:1.21&quot;&lt;/span&gt; },&lt;br/&gt;          },&lt;br/&gt;        },&lt;br/&gt;      },&lt;br/&gt;    },&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  fmt.Printf(&lt;span&gt;&quot;%#v&quot;&lt;/span&gt;, &amp;amp;deployment)&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个模块不仅定义了顶层的Kubernetes对象，就像上面的部署一样，还为它们的内部属性定义了许多辅助类型：&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// PodSpec is a description of a pod.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PodSpec struct {&lt;br/&gt;  Volumes []Volume `json:&lt;span&gt;&quot;volumes,omitempty&quot;&lt;/span&gt; patchStrategy:&lt;span&gt;&quot;merge,retainKeys&quot;&lt;/span&gt; patchMergeKey:&lt;span&gt;&quot;name&quot;&lt;/span&gt; protobuf:&lt;span&gt;&quot;bytes,1,rep,name=volumes&quot;&lt;/span&gt;`&lt;br/&gt;  &lt;br/&gt;  InitContainers []Container `json:&lt;span&gt;&quot;initContainers,omitempty&quot;&lt;/span&gt; patchStrategy:&lt;span&gt;&quot;merge&quot;&lt;/span&gt; patchMergeKey:&lt;span&gt;&quot;name&quot;&lt;/span&gt; protobuf:&lt;span&gt;&quot;bytes,20,rep,name=initContainers&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;br/&gt;  Containers []Container `json:&lt;span&gt;&quot;containers&quot;&lt;/span&gt; patchStrategy:&lt;span&gt;&quot;merge&quot;&lt;/span&gt; patchMergeKey:&lt;span&gt;&quot;name&quot;&lt;/span&gt; protobuf:&lt;span&gt;&quot;bytes,2,rep,name=containers&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;  EphemeralContainers []EphemeralContainer `json:&lt;span&gt;&quot;ephemeralContainers,omitempty&quot;&lt;/span&gt; patchStrategy:&lt;span&gt;&quot;merge&quot;&lt;/span&gt; patchMergeKey:&lt;span&gt;&quot;name&quot;&lt;/span&gt; protobuf:&lt;span&gt;&quot;bytes,34,rep,name=ephemeralContainers&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;  RestartPolicy RestartPolicy `json:&lt;span&gt;&quot;restartPolicy,omitempty&quot;&lt;/span&gt; protobuf:&lt;span&gt;&quot;bytes,3,opt,name=restartPolicy,casttype=RestartPolicy&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;br/&gt;  ...&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Kubernetes中定义的所有结构k8s.io/api模块自带JSON和Protobuf注解。但要注意：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;专业提示&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：如果你去阅读源码，你会看到k8s.io/apimachery通过对提供的对象调用标准的json.marshal()来实现JSON的序列化。因此，不要害怕，只要需要转储API对象，就使用json.Marshal()。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;总结一下，k8s.io/api模块：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;3&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;k8s.io/apimachinery模块&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;不像简单的k8s.io/api模块，k8s.io/apimachery模块是相当复杂的。README[2]将其目的描述为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个库是服务器和客户端使用Kubernetes API基础设施的共享依赖项，不需要直接的类型依赖项。它的第一批消费者是k8s.io/kubernetes、k8s.io/client-go、k8s.io/apiserver。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;要在一篇文章中涵盖apimachinery模块的所有职责是很困难的。因此，我将讨论这个模块中最常见的包、类型和功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;有用的结构和接口&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;k8s.io/api模块专注于具体的高级类型，如Deployment、Secret、Pod，k8s.io/apimachery是低层但更通用的数据结构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如，Kubernetes对象的所有这些公共属性：apiVersion、kind、name、uid、ownerReferences、creationTimestamp等。如果我要构建自己的Kubernetes自定义资源，我就不需要自己为这些属性定义数据类型——这要感谢apimachery模块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;k8s.io/apimachery/pkg/apis/meta包定义了两个方便的结构体：TypeMeta和ObjectMeta，它们可以嵌入到用户定义的结构体中，使其看起来像任何其他Kubernetes对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;此外，TypeMeta和ObjectMeta结构实现了meta.Type和meta.Object接口，可用于以通用方式指向任何兼容对象。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49537037037037035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzC9vlNS5jTmI3X1lJiaicP0I5MHlxKlAA7VCpT4spaFGHVias6wI0zlxGGiaiaStOzKGYuJJ1fsk8kJD7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在apimachery模块中定义的另一个方便的类型是接口runtime.Object。由于其简单的定义，它可能看起来毫无用处：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// pkg/runtime&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Object interface {&lt;br/&gt;  GetObjectKind() schema.ObjectKind&lt;br/&gt;  DeepCopyObject() Object&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;但实际上，它被用得很多！Kubernetes的代码是在Go获得真正泛型支持之前很久编写的。因此，runtime.Object很像传统的接口——它是一个泛型接口，在代码库中广泛地进行类型断言和类型切换。而实际的类型可以通过检查底层对象的类型来获得。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;runtime.Object实例可以指向任何具有kind属性的对象——成熟的Kubernetes对象、不携带元数据的更简单的API资源，或者具有定义良好的对象方案的任何其他类型的对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意，虽然看起来相似，但meta.Object不能安全地向下转换到相应的Kubernetes对象，因为它的结构偏移量不为零。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;更有用的apimachery类型：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;PartialObjectMetadata结构——meta.TypeMeta和meta.ObjectMeta作为一种通用的方法来表示任何具有元数据的对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;APIVersions、APIGroupList、APIGroup结构体——还记得kubectl get的&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg5Mjc3MjIyMA==&amp;amp;mid=2247544676&amp;amp;idx=2&amp;amp;sn=a5584d8a3101e59a8ef2bd5878f20708&amp;amp;chksm=c03b6577f74cec61efe3303d911894c6e886e9f840ce45dd2ecc1a16f0cbbdcd5698a63fcd41&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;API探索练习吗&lt;/a&gt;？原始API这些和类似的结构用于Kubernetes，API资源的类型，但不是Kubernetes对象（例如，它们有kind和apiVersion属性，但没有真正的Object元数据）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;GetOptions、ListOptions、UpdateOptions等等——这些结构体代表了客户端对资源的相应动作的参数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;GroupKind、GroupVersionKind、GroupResource、GroupVersionResource等——简单的数据传输对象，包含组、版本、类型或资源字符串的元组。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在讨论Scheme和RESTMapper之前，请记住GroupVersionKind和GroupVersionResource——他们的知识将派上用场。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;非结构化的结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;是的，你没听错。撇开玩笑不谈，它是另一种重要且广泛使用的数据类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;使用固定k8s.io/api类型处理Kubernetes对象很方便，但如果：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;你需要以通用的方式使用Kubernetes对象？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;你不想或不能依赖于API模块？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;你需要使用API模块中没有定义的自定义资源？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;非结构化，用于救援的非结构化结构！这个结构体允许没有注册Go结构体的对象被操作为通用的JSON类对象：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;type&lt;/span&gt; Unstructured struct {&lt;br/&gt;  // Object is a JSON compatible map with&lt;br/&gt;  // string, &lt;span&gt;float&lt;/span&gt;, int, bool, []interface{}, or&lt;br/&gt;  // map[string]interface{} children.&lt;br/&gt;  Object map[string]interface{}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// And &lt;span&gt;for&lt;/span&gt; the list of objects you can &lt;br/&gt;// use the UnstructuredList struct.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; UnstructuredList struct {&lt;br/&gt;  Object map[string]interface{}&lt;br/&gt;&lt;br/&gt;  Items []Unstructured&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;实际上，这两个结构只是map[string]interface{}。不过，它们附带了一堆方便的方法，简化了嵌套属性访问和JSON序列化/反序列化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;示例：https://github.com/iximiuz/client-go-examples/blob/5b220c4572d65ea8bf0ad68e369e015902e7521c/crud-dynamic-simple/main.go#L36&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;类型转换——非结构化到类型化，反之亦然&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;自然的，需要将非结构化对象转换为具体k8s.io/api类型（反之亦然）。runtime.UnstructuredConverter接口及其默认实现DefaultUnstructuredConverter可以帮助你：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;type&lt;/span&gt; UnstructuredConverter interface {&lt;br/&gt;  ToUnstructured(obj interface{}) (map[string]interface{}, error)&lt;br/&gt;  FromUnstructured(u map[string]interface{}, obj interface{}) error&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;示例：https://github.com/iximiuz/client-go-examples/tree/main/convert-unstructured-typed&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对象序列化为JSON、YAML或Protobuf&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在处理来自静态类型语言的API时，另一项乏味的任务是将数据结构编组和解组到它们的连线表示中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;大量的apimachery代码都用于此任务‍‍：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// pkg/runtime&lt;br/&gt;&lt;br/&gt;// Encoder writes objects to a serialized form&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Encoder interface {&lt;br/&gt;  Encode(obj Object, w io.Writer) error&lt;br/&gt;  Identifier() Identifier&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Decoder attempts to load an object from data.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Decoder interface {&lt;br/&gt;  Decode(&lt;br/&gt;    data []byte,&lt;br/&gt;    defaults *schema.GroupVersionKind,&lt;br/&gt;    into Object&lt;br/&gt;  ) (Object, *schema.GroupVersionKind, error)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Serializer interface {&lt;br/&gt;  Encoder&lt;br/&gt;  Decoder&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;注意到上面的代码片段中的这些对象了吗？是的，这些是runtime.Object，也就是Kind-able接口实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例子:&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/serialize-typed-json&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/serialize-typed-yaml&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/serialize-unstructured-json&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/serialize-unstructured-yaml&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;模式和RESTMapper&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;runtime.Schema在使用client-go时，模式概念随处出现，特别是在编写处理自定义资源的控制器（或操作符）时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;我花了一段时间才明白它的目的。但是，按照正确的顺序处理事情会有所帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;考虑一下非结构化到类型化转换的潜在实现：有一个类似json的对象，以及一些具体k8s.io/api类型需要从它创建。也许，第一步就是要弄清楚如何使用kind字符串创建一个空的类型化对象实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;一个简单的方法可能看起来像一个巨大的switch语句，覆盖所有可能的类型（实际上是API组）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;import (&lt;br/&gt;  appsv1 &lt;span&gt;&quot;k8s.io/api/apps/v1&quot;&lt;/span&gt;&lt;br/&gt;  corev1 &lt;span&gt;&quot;k8s.io/api/core/v1&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func New(apiVersion, kind string) runtime.Object {&lt;br/&gt;  switch (apiVersion + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + kind) {  &lt;br/&gt;  &lt;span&gt;case&lt;/span&gt;: &lt;span&gt;&quot;v1/Pod&quot;&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;corev1.Pod{}&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt;: &lt;span&gt;&quot;apps/v1/Deployment&quot;&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;appsv1.Deployment{}&lt;br/&gt;  }&lt;br/&gt;  ...&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;更聪明的方法是使用反射。不是开关，而是映射[字符串]反射。类型可以为所有注册类型维护：&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;type&lt;/span&gt; Registry struct {&lt;br/&gt;  map[string]reflect.Type types&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (r *Registry) Register(apiVersion, kind string, typ reflect.Type) {&lt;br/&gt;  r.types[apiVersion + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + kind] = typ&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (r *Registry) New(apiVersion, kind string) runtime.Object {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; r.types[apiVersion + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + kind].New().(runtime.Object)&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这种方法的优点是不需要生成代码，并且可以在运行时添加新的类型映射。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;现在，考虑一个反序列化问题：需要将一段YAML或JSON转换为一个类型化对象。第一步——对象创建——将非常类似。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;事实证明，通过API组和类型创建空对象是一项非常频繁的任务，以至于它在apimachery模块——运行时中获得了自己的模块——runtime.Schema：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// Scheme defines methods &lt;span&gt;for&lt;/span&gt; serializing and deserializing API objects, a &lt;span&gt;type&lt;/span&gt;&lt;br/&gt;// registry &lt;span&gt;for&lt;/span&gt; converting group, version, and kind information to and from Go&lt;br/&gt;// schemas, and mappings between Go schemas of different versions. &lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Scheme struct {&lt;br/&gt;  gvkToType map[schema.GroupVersionKind]reflect.Type&lt;br/&gt;  &lt;br/&gt;  typeToGVK map[reflect.Type][]schema.GroupVersionKind&lt;br/&gt;  &lt;br/&gt;  unversionedTypes map[reflect.Type]schema.GroupVersionKind&lt;br/&gt;  &lt;br/&gt;  unversionedKinds map[string]reflect.Type&lt;br/&gt;&lt;br/&gt;  ...&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;runtime.Scheme结构就是这样一个注册表，它包含了所有Kubernetes对象的kind到type和type到kind的映射。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;记住，GroupVersionKind只是一个元组，即DTO结构，对吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;runtime.Scheme结构实际上是非常强大的，它有一大堆方法和实现一些基本的接口，如：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// ObjectTyper contains methods &lt;span&gt;for&lt;/span&gt; extracting &lt;br/&gt;// the APIVersion and Kind of objects.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ObjectTyper interface {&lt;br/&gt;  ObjectKinds(runtime.Object) ([]schema.GroupVersionKind, bool, error)&lt;br/&gt;  Recognizes(gvk schema.GroupVersionKind) bool&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// ObjectCreater contains methods &lt;span&gt;for&lt;/span&gt; instantiating&lt;br/&gt;// an object by kind and version.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ObjectCreater interface {&lt;br/&gt;  New(kind schema.GroupVersionKind) (out Object, err error)&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;然而，runtime.Schema不是万能的。它有从kind到type的映射，但是如果不是只有资源名已知而不是类型呢?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这就是RESTMapper的作用所在：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;type&lt;/span&gt; RESTMapper interface {&lt;br/&gt;  // KindFor takes a partial resource and returns the single match.  Returns an error &lt;span&gt;if&lt;/span&gt; there are multiple matches&lt;br/&gt;  KindFor(resource schema.GroupVersionResource) (schema.GroupVersionKind, error)&lt;br/&gt;&lt;br/&gt;  // KindsFor takes a partial resource and returns the list of potential kinds &lt;span&gt;in&lt;/span&gt; priority order&lt;br/&gt;  KindsFor(resource schema.GroupVersionResource) ([]schema.GroupVersionKind, error)&lt;br/&gt;&lt;br/&gt;  ...&lt;br/&gt;  &lt;br/&gt;  ResourceSingularizer(resource string) (singular string, err error)&lt;br/&gt;}&lt;/section&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;RESTMapper也是某种注册表。但是，它维护资源到种类的映射。因此，向映射器提供一个像apps/v1/Deployment这样的字符串，就会得到API Group apps/v1和部署类型。RESTMapper还可以处理资源快捷方式和奇点化: po、pod和pods可以注册为相同资源的别名。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.487962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzC9vlNS5jTmI3X1lJiaicP0I55JWfn1RIIDmulBO0000F26E6z8hppQOiaWgB2sev5ib6mHW5T4RQHLkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;通常情况下，会有一个全局的单例运行时。然而，似乎apimachery模块本身试图避免状态——它定义了RESTMapper和Scheme结构，但没有实例化它们。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;不像运行时。该方案被apimachery模块本身广泛使用，RESTMapper在内部没有使用，至少目前没有。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;字段和标签选择器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;字段和标签的类型、创建和匹配逻辑也存在于apimachery模块中。例如，这里是k8s.io/apimachinery/pkg/labels包：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;lbl := labels.Set{&lt;span&gt;&quot;foo&quot;&lt;/span&gt;: &lt;span&gt;&quot;bar&quot;&lt;/span&gt;}&lt;br/&gt;sel, _ = labels.Parse(&lt;span&gt;&quot;foo==bar&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; sel.Matches(lbl) {&lt;br/&gt;  fmt.Printf(&lt;span&gt;&quot;Selector %v matched label set %v\n&quot;&lt;/span&gt;, sel, lbl)&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例子:&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/label-selectors&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/field-selectors&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;API错误处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在代码中使用Kubernetes API是不可能的，除非正确处理它的错误。API服务器可能完全消失，请求可能未经授权，对象可能丢失，并发更新可能发生冲突。幸运的是，k8s.io/apimachery /pkg/api/errors包定义了一些方便的实用函数来处理API错误。下面是一个例子：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;_, err = client.&lt;br/&gt;  CoreV1().&lt;br/&gt;  ConfigMaps(&lt;span&gt;&quot;default&quot;&lt;/span&gt;).&lt;br/&gt;  Get(&lt;br/&gt;    context.Background(),&lt;br/&gt;    &lt;span&gt;&quot;this_name_definitely_does_not_exist&quot;&lt;/span&gt;,&lt;br/&gt;    metav1.GetOptions{},&lt;br/&gt;  )&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; !errors.IsNotFound(err) {&lt;br/&gt;  panic(err.Error())&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;示例：https://github.com/iximiuz/client-go-examples/tree/main/error-handling&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;其他&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;最后但并非最不重要的是，apimachery/pkg/util包充满了有用的东西。下面是一些例子:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;4&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;k8s.io/api和k8s.io/apimachery包是学习如何在Go中使用Kubernetes对象的一个很好的起点。如果你需要编写你的第一个控制器，直接跳到client-go，甚至跳到controller-runtime或kubebuilder可能会让你的学习经历变得太复杂——可能会有太多的知识缺口。不过，先看看API和apimachery包，然后再尝试一下，这将帮助你在接下来的旅程中保持平和的心态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;相关链接：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://github.com/kubernetes/api/tree/35d41aaac2bf55a353ccade31b852d466b2495c2#recommended-use&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://github.com/kubernetes/apimachinery/tree/3d7c63b4de4fdee1917284129969901d4777facc#purpose&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点击下方卡片关注&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分布式实验室&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;，和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;我们&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一起&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关注分布式最佳实践&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5Mjc3MjIyMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzCwsauR1olj2b0tyPJXRBicSkuNEiaBuN8AQ61xkz4dH9DBr1PypYtFlEnczVkAeQvLz7rjsjttotCg/0?wx_fmt=png&quot; data-nickname=&quot;分布式实验室&quot; data-alias=&quot;DistributedLab&quot; data-signature=&quot;关注分布式相关的开源项目和基础架构，致力于分析并报道这些新技术是如何以及将会怎样影响企业的软件构建方式。&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot; wah-hotarea=&quot;click&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;▲&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;点击上方卡片关注分布式实验室，掌握前沿分布式技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有想一起学习K8s、考CKA证书吗？来，这里有最好的学习方案，&lt;/span&gt;&lt;span&gt;线下3天封闭式培训，15人小班课，考不过免费复训&lt;/span&gt;&lt;span&gt;。Kubernetes实战班，7月22日在深圳开课，扫描下方二维码咨询详情。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDGnTiaw7Teu5bSfO5NUAibEHyvmB2iaJArRBNbhOCawDQg6x23yR12zmh5B4sFCMv8eyq5LpuNTFU2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6ad8eb69fa201af24eae03771c91af6f</guid>
<title>2022年最受欢迎的5大开源自动化和编排技术</title>
<link>https://toutiao.io/k/fj7m6x8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt;出品 | OSC开源社区（ID：oschina2013）&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;DevOps 一直是开发者的重点关注领域，外媒 openlogic 联合 OSI 统计了各行各业 2600 多名开源用户的数据，得出了一份 2022 年开源状态报告，根据统计的数据总结了 2022 年最受欢迎的 5 大开源自动化和编排技术，以及开发团队选择这些技术的标准和常见问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于&lt;strong&gt;自动化和编排技术&lt;/strong&gt;的调查范围，本次参与调查的工具主要有 Puppet、Ansible、Chef、Salt、Kubespray、Terraform、Rancher 和 Zabbix ，而 GitHub Actions、GitLab、Jenkins X、Jenkins、Spinnaker、Travis CI、Tekton、 Zuul 被视作 CI/CD 工具，不作统计。 &lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2022 年最受欢迎的 5 大开源自动化和编排技术&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;1、Puppet&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2022 年的调查发现，Puppet 是自动化和编配技术中被采用最多的技术，26.6% 的受访者使用该软件。上一次调查 Puppet 仅有 16%  的占比，可谓是迅猛增加。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;2、Ansible&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Ansible 的采用率第二，24.8% 的受访者表示使用了该软件，上次调查是 24 % 占比，较为稳定。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;3、Chef&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; 23.4% 的人使用 Chef 作为自动化和编排工具。自上次调查以来，Chef 使用量增加了 10%，也是被市场认可的工具。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;4、Salt&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Salt 的增长率位居第二，占比从 7% 提高到 21.9%，&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;5、Kubespray&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;排名第五的 Kubespray 增长百分比最高，在之前的调查中，Kubespray 占比仅 5%，2022 年增长到 21.4%。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;选择开源自动化和编排工具的原因&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45661157024793386&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRKibMkIxZD11PiaYXJBZqJiaSRcUoYeP8wph5fF55thQfUD1ZIicJWL8e5B8FZMLa6RYzicvDTFv2l4yabg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;968&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;调查结果显示，大型组织选择自动化和编排工具的主要原因是新特性和功能、安全访问和控制，而小型组织选择自动化和编排工具的关键原因是客户群的不断扩展，需要自动化工具来维持产品的安全和稳定。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开源自动化和编排技术面临的主要问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4483837330552659&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRKibMkIxZD11PiaYXJBZqJiaSRc6h8eyRrYIdyXqSNs98v5uJ8NW4T9YAMWERJYw4XAYibs5YQ0vDZ6pwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;959&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;安装、升级和配置问题是开源自动化和编排技术的最大挑战：并非每个组织都拥有熟悉自动化和编排工具的 DevOps 团队。对很多开发者来说 DevOps 其实是一项从未接触过的新工具，很容易在复杂的安装和配置过程中陷入困境，然后花费大量的时间查资料解决问题，这对小型组织来说是非常昂贵的人力资源和学习成本。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;从统计结果来看， DevOps 领域内采用开源技术变得更加普遍。openlogic 之前的调查发现 50% 的开发者从未使用过任何开源自动化和编排技术。而 2022 年的调查中这一数据仅剩 16% 。但采用并不意味着能掌握，大部分采用这些开源技术的组织在安装、配置、升级以及熟练部署方面都遇到了困难，这意味着开源自动化和编排技术的资料和教程仍需进一步完善。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;感兴趣的朋友可以查看 openlogic 的开源调查报告和开源自动化和编排技术排行博客。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;相关链接：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;开源调查报告：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;https://www.openlogic.com/resources/2022-open-source-report&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;编排技术排行博客：&lt;span&gt;https://www.openlogic.com/blog/top-open-source-automation-and-orchestration-trends-2022&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;https://www.openlogic.com/resources/2022-open-source-report&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;---END---&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI3NDA4OTk1OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/UDxcwVqYKV9IOTr5rggNKcaXwzBdaq9EG6A3Jib6YGFIWjCh0rpwGlapib9GGcr9TeSRcEqasuom6dLibqswdq1Mw/0?wx_fmt=png&quot; data-nickname=&quot;数据库开发&quot; data-alias=&quot;DataBase1024&quot; data-signature=&quot;分享数据库开发、原理和应用，涵盖MySQL、PostgreSQL、MS SQL Sever、Oracle等主流关系数据库的应用和原理，以及MongoDB、Redis、Memcached等NoSQL数据库和缓存技术。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>788f5af52a2d9dc44a67a7814e9f0b71</guid>
<title>正确复制、重写别人的代码，为什么是件很酷的事情</title>
<link>https://toutiao.io/k/li8d566</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0Mckx2q9iciaNlK44cAQ5icVeTJeTCU7HqkpFu4oRQOHSzDP7lCH4gvaOPqvbg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;
作者 | Erik Hermansen&lt;/section&gt;&lt;section&gt;
译者 | Sambodhi&lt;/section&gt;&lt;section&gt;
策划 | 闫园园&lt;/section&gt;&lt;p&gt;我最近在一篇文章提到，工程师应该怎样避免使用大量的库、包以及其他依赖关系。我建议的另一种方案是，如果你没有达到重用第三方代码的阈值时，那么你就可以自己编写代码。&lt;/p&gt;&lt;p&gt;在本文中，我将讨论一个在重用和从头开始编写之间的抉择。这些技术能为你提供良好的综合优势。你将会听到我提到的一些在不同编程语言 / 环境下的例子。但是，这篇文章的层次足够高，而且说实话，你在什么环境下工作，并不重要。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5578571428571428&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxGzexT7cibibA3W7ibQv0C8F8m9SKJhTfqNC2ibPKv3QsYXLqPuOUFKSiaEg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们一再要求她把字写得小一点。她浪费了那么多纸张。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;1&lt;/span&gt; 四种编码技术&lt;/section&gt;&lt;p&gt;设想你所处的情况是这样的，你希望你的软件能够完成当前无法完成的任务。比如，你也许想要一份 PDF 格式的报告，方便打印。但是你的软件并不会输出 PDF。作为一名工程师，你要做的工作就是解决这个问题。&lt;/p&gt;&lt;p&gt;下图展示了四种不同的技术来添加这个功能。我并没有提到“这四种技术”。当然，我肯定还有更多的技术，包括镖靶和猴子。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31285714285714283&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0Mckx7j3anMPVL2dZ1I8yYJMXCicEtTwyuoMPu9JlcmtibU7RgCZYkG81Azew/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;为什么这么多决定都要权衡利弊呢？这真的很让人恼火。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;重用&lt;/strong&gt;：根据你的环境，你可能会在 lib 中建立链接，或者在 &lt;code&gt;pom.xml&lt;/code&gt; 或 &lt;code&gt;package.json&lt;/code&gt; 中添加一个条目。不管你怎么做，“重用”就是抓取别人的代码，通过它的接口来使用，而不去关心它的内部结构。这段代码还可能会“偷渡”到一群横向的依赖关系中去，这会给你带来麻烦。最少的努力，带来的是最少的控制。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;复制&lt;/strong&gt;：从 Github repo、代码片段集或者其他地方，选择你所需要的代码。然后把它直接粘贴到你的项目中。这段代码已经存在于你的代码库中，而不再是一个依赖关系。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;重写&lt;/strong&gt;：采用一些适合你的第三方代码，通过重写，使其成为你自己的代码。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;编写&lt;/strong&gt;：你自己编写所有的代码，用自己的脑子，不借用任何人的东西。Ayn Rand 和 Casey Muratori 将尊重你的决定。最大的努力，将得到最大限度的控制。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为了确保我上面的图表给人留下正确的印象，我给了它两把斧子——一把是努力，一把是控制。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5064285714285715&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0Mckx9nuiacfib4BUyuNnobZqVlOU9YO8Wzic3UAwXlTicYC3IYhfdYEPS3JuSg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;另一方面，这家伙的两把斧子也让人印象深刻。&lt;/p&gt;&lt;p&gt;所有这四种技术都是在努力和控制之间的权衡。&lt;/p&gt;&lt;p&gt;你可以通过重用快速地获取大量的功能，然后以软件膨胀、黑盒调试、安全修补和耦合升级的形式遭受缺乏控制的痛苦。在重用的情况下，你不一定会面临这些问题，但是这样做的风险会增大。在你的项目中添加的每一行代码就好像是一张彩票，会“赢得”一个非常糟糕的问题。&lt;/p&gt;&lt;p&gt;或者在这张图的另一端，你从头开始编写所有的代码，你将会对进入项目的新代码进行完全的控制。不过，你可以花些无聊的时间去把所有的东西都按你的想法去编写，而你却成了编程的天后。&lt;/p&gt;&lt;p&gt;在我以前的一篇文章《多编写，少重用》（Write More, Reuse Less）中，我已经详细地阐述了重用和编写之间的权衡。&lt;/p&gt;&lt;p&gt;我将会深入探讨两种中间技术（复制和重写）。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;2&lt;/span&gt; 复制&lt;/section&gt;&lt;p&gt;有许多可以复制代码的好地方。如果你要完成的任务可以用一句话来完成，而且代码不超过 100 行即可实现，那么，你只需把问题输入到搜索引擎，就能轻松地找到。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6350245499181669&quot; data-type=&quot;jpeg&quot; data-w=&quot;1222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxZrnXsJ52PCBVpJ0OibB4cabOJp7dTuSOibvh8Sw3msibRud5mtsafPRGw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;与 DuckDuckGo 相比，谷歌最大的优势在于：“DuckDuckGo”作为动词，在会话中会让人感到难堪。&lt;/p&gt;&lt;p&gt;用这种方式来搜索一些简单的代码任务的问题，你将很快就能找到代码的天堂。&lt;/p&gt;&lt;p&gt;我从 StackOverflow、W3Schools、MDN、Unity Answers 和各种我懒得记住的地方复制了很多代码。我总是先从搜索引擎开始，在那里提出问题。通常情况下，我会先从我工作的语言 / 平台开始，然后再提问。在我敲代码的时候，看一下自动完成的内容往往很有帮助。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;3&lt;/span&gt; GitHub Copilot&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4635714285714286&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxLNrh62keCMgaLupcVOsqy2oWHJorPExeCADLZu8atXDZeIthIH2Q4Q/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;从复制人类答案的机器人那里复制你的答案。&lt;/p&gt;&lt;p&gt;如果你更愿意相信由复杂的人工智能为你编写的代码片段，可以试试 GitHub Copilot。这是一个集成到 IDE 中的插件。基本上，你并不需要在搜索引擎中输入你想要的东西，而是将该文本输入一个略微详细的源码注释即可。然后，实现的源代码就会自动填充在下面。&lt;/p&gt;&lt;p&gt;是真的！我不是在开玩笑。请看一些关于它的视频。&lt;/p&gt;&lt;p&gt;&lt;span&gt;视频地址：https://youtu.be/FHwnrYm0mNc&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这使我既害怕又激动。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;4&lt;/span&gt; 超越代码片段&lt;/section&gt;&lt;p&gt;如果你想要为更大的功能部分复制代码，那么只要：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;寻找包含这些功能的开源项目；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将所需的文件复制过来。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我刚才提出的一种做法，不是很傻就是很疯狂。我真心希望你能想到下面那个问题。别让我跟你扯淡。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;5&lt;/span&gt; “什么时候从第三方项目中复制会比直接导入更好？”&lt;/section&gt;&lt;p&gt;如果你仅仅想将一个依赖关系的所有未改变的文件复制到你的项目中，那么我将会发现这种复制方法的缺陷。你复制的源码不会轻易地被更新到依赖关系的新版本。这就意味着你会错过 Bug 修复、新功能和安全补丁。&lt;/p&gt;&lt;p&gt;尽管在一些情况下，对某个特定版本的代码进行快照非常有价值，但是你可以通过构建清单（例如 Java 中的 &lt;code&gt;pom.xml&lt;/code&gt;，Node 中的 &lt;code&gt;package.json&lt;/code&gt;）使用固定版本来完成同样的事情。而且如果你决定要升级的话，那么你可以轻易地更新一个固定版本。&lt;/p&gt;&lt;p&gt;另外一个潜在的复制理由是，你可能需要对项目的源码进行修改。如果你要进行增量更改，你可以最好这样做：1. 从原项目中创建一个复刻项目；或者 2. 把你的更改贡献给原项目。这样可以让你在以后更容易从原项目中收到修改。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4928571428571429&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxgPSpmezstQJYYulht2kzx3ViapSg4AWuEYypwroDFeAg7T1GQqPZCDg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;有三种不同的方式可以让你在你的项目中修改他人的代码。最上面的一种做法是不好的。&lt;/p&gt;&lt;p&gt;这也许是你大规模、全面地修改你的代码库。你准备在以后的合并项目中，把一切后路都堵死。那真是太好了。这往往是有正当理由的。但是我在本文中所提供的定义是，对源码的大规模结构性的修改属于“重写”技术，下面我会详细讨论。&lt;/p&gt;&lt;p&gt;我唯一能想到的一个很好的理由就是，将第三方项目的代码复制（而非重写）到你的项目中：你只需在这个项目中得到一些源码即可。&lt;/p&gt;&lt;p&gt;而这种理由出现的频率超出了你的想象。大型 Node 包，如 Lodash 和 TurfJS，都是非常聪明的，它们会提供子集包，这些子集包只是为了你需要的特定功能在函数级颗粒度来导入。不过，在野外中也有很多臃肿的怪物。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxLkruib1ocAO5wFVmnXib8WF746PG252qhbPgP46XARTic6sbK6KUJPoWA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;Nodelerfish 需要你的爱。但不要让它进入你的项目中。&lt;/p&gt;&lt;p&gt;你也许只需要使用 50 行代码就可以完成的库 API。但是单体导入的库，可能会拉来数十万行代码，特别是那些具有横向依赖关系。在这种情况下，将一个子集复制下来，而非将其导入到整个该死的烂摊子中，这完全是很合理的。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;6&lt;/span&gt; 开源许可证&lt;/section&gt;&lt;p&gt;我不是一个律师。既然我不是律师，我就会把我在开源许可方面的实践告诉你。你可以咨询顶级律师团队，以达成你自己的决策。&lt;/p&gt;&lt;p&gt;笔者作为非律师，是如何做的：&lt;/p&gt;&lt;p&gt;如果我把源码复制到我的项目中，我把它和导入代码一样对待，并遵循所有的许可条款。在开源软件许可的条款中，一般都是指分发源码或者从许可源码中构建的行为。如果复制的代码是我发布版本的一部分，那么它也算作分发。对于我使用的确切的开源许可证，我也非常谨慎，例如，GPL 可能会要求我使用 GPL 许可证来许可我自己的代码库，而 MIT 许可证几乎不要求我做任何事情。&lt;/p&gt;&lt;p&gt;我还喜欢将复制的代码归入“第三方”目录（例如 Github 上的例子），然后在文档的顶部添加注释，这样就可以保证所有的内容都是一致的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2757142857142857&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxianDy2PEqT2920FqJq5eNHsHbia8bbTepiagvaianYCQhrJjMcHeDHHdJA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;他们不认识我，但 Matt Daly 和 Chris Anderson 是我的代码兄弟。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;7&lt;/span&gt; 重写的优点&lt;/section&gt;&lt;p&gt;你知道你正在复制的代码里有什么吗？它是适合你的代码吗？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4542857142857143&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxxeO9NF537Yzn5NYqZ2GqdkeOeanpic8FMfM4L3952UuM697PSJxuaMA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;对于某些测试，复制别人的答案效果并不好。&lt;/p&gt;&lt;p&gt;你能够而且应当对其他人的代码进行判断。或许不要对这段代码做出无情的评论。但是，请务必为自己的利益，私下评估第三方代码。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;8&lt;/span&gt; 重写代码片段&lt;/section&gt;&lt;p&gt;如果是 200 行以内的代码片段，或者是复制的代码，我一定会逐行重写代码，这样可以了解到这些代码是如何工作的，并且做一些改动，使之更适合我的项目。这是为数不多的几次在其他方面进行毫无意义的、风格化的编辑，是有价值的。&lt;/p&gt;&lt;p&gt;我要举一个具体的例子来说明。现在，我要从互联网上某个地方随机找出一个代码片段，然后进行重写。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24928571428571428&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxG4Rv2DCC90uI7bTLX5n1ekQgZKdTjwdgs14QbJjDFoUJMKNbfiaj82w/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;左边的代码是原来的。右边的代码是我重写的。&lt;/p&gt;&lt;p&gt;我重写的 代码片段 是由 StackOverflow 上一位名叫“Mark”的人发布的。他的代码通过对每一个点与它的左右邻居进行平均，使折线图中参差不齐的高峰和低谷变得平滑。&lt;/p&gt;&lt;p&gt;概括地说，在重写代码中，我做了以下的改动：&lt;/p&gt;&lt;p&gt;我编写代码的风格并不比 Mark 的好。它只不过是碰巧以正确的方式触动了我的大脑。这并不足以让 Mark 的代码发生改变。下面是重写他的代码片段的真实益处：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;我学会了这个算法。我现在完全明白这个折线图平滑的工作原理了。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我创建的代码对我而言更易于维护，即使对 Mark 来说并不是这样。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我可以把那些和我需求无关的部分代码删除掉。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我确认了代码没有任何错误，比如，无限循环。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我已经确认了没有引入安全漏洞，比如在 DOM 中注入一个 &lt;code&gt;querystring&lt;/code&gt; 变量。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我已经确认了，这些代码没有添加任何额外的依赖关系，比如某些统计库。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我了解到另外一位工程师很享受编写代码的乐趣，并且有机会把他的实践为我自己所用。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;所以，这种浅重写是一种很好的方式，可以把别人的代码导入到你的项目中。有些问题是可以避免的。你可以根据你的用例和其他需求对代码进行调整。另外，你还可以在学习新的算法和实践中，成长为一名工程师。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;9&lt;/span&gt; 重写的许可考虑因素&lt;/section&gt;&lt;p&gt;笔者作为非律师，是如何做的：&lt;/p&gt;&lt;p&gt;我想，完全的逐行重写应该可以免除几乎所有开源软件许可的法律义务。但是我始终坚持着开源的理念，例如，在源码的注释中引用原作，或者为原项目提供帮助。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;10&lt;/span&gt; 更深入的重写和修剪&lt;/section&gt;&lt;p&gt;有时候，你希望导入多个文档或数千行的源码，并做大量的改动，以让新代码适合你的项目。尤其是，修剪掉你实际上不需要的东西，是很好的做法。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6142857142857143&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0Mckx94wMVAGv5wBG72mX6rRIfsLZGstkLBjmIceqjPBCLbyUz7EQQXEqwQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;当攀爬到一棵树上修剪时，我建议你在面向树干的那一侧坐下来进行修剪。&lt;/p&gt;&lt;p&gt;下面是一个简单的复制和修剪的方法：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;将所有的依赖源文件复制到你的项目中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;确保你所需的功能能够在实践中起作用。单元测试一般都是非常有用的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;把你不需要的部分删除。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;重复第 2 和第 3 步，直至剩余的代码能够符合你的需求。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;至少对剩余的代码进行一次浅重写，这样才能保证你能够了解并从中得到其他的益处。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;你的 IDE 的选择和配置应该能够很好地支持你完成这项任务，包括提示、语法高亮和通知功能，这些功能可以向你显示：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;哪些代码在调用函数。（修剪它们？)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;哪些函数从未被调用。（修剪它们！)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;哪些变化会破坏你的构建。（取消修剪！)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果你的 IDE 没有为你对这些进行适配，可以花点时间去做更好的设置。&lt;/p&gt;&lt;p&gt;&lt;code&gt;git commit&lt;/code&gt; 和 &lt;code&gt;git checkout&lt;/code&gt; 可以让你设定一个很好的状态，在你因过度修剪而破坏一些东西的时候，能够恢复到之前的状态。这是一张很好的安全网，可以使你的工作速度更快。&lt;/p&gt;&lt;p&gt;我都能听见你想说什么了……&lt;/p&gt;&lt;section&gt;
&lt;span&gt;11&lt;/span&gt; “可是，要重写代码的话，实在是太费事了！”&lt;/section&gt;&lt;p&gt;我不是说你一定要重写。只有在一些情况下，如果你这么做，就能得到很好的回报。我来告诉你一个真实的案例，我重写了一个第三方项目，并且从中获益良多。&lt;/p&gt;&lt;p&gt;我先从依赖树开始，如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21428571428571427&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxeibYm6yY76mUPWM7ObEDo19mocgy0yNjOEuibadDaVnyPNm3wefzfMUw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;在花了半天时间完成重写之后，我去掉了 5 个依赖关系的需求，最后得到了如下结果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21642857142857144&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxZQ6uI6HvzicOrDbzm7k6o5sy60IYrpWIPvticdcwnvhfdcwCljf4mLlQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;有一个名为“microphone-stream”的 NPM 包，我在 Web 应用中使用它来发送从麦克风捕获的样本缓冲区到语音识别包（Cieran O&#x27;Reilly 的 vosk-browser，如果你有兴趣的话）中的一个接口。&lt;/p&gt;&lt;p&gt;我最初是在“让它工作”的开发阶段使用 &lt;code&gt;microphone-stream&lt;/code&gt;。它包含在一个示例 Web 应用项目中，我已经将其复制到我的项目中。&lt;code&gt;microphone-stream&lt;/code&gt; 运行得很好，直到我升级了一个构建工具（Webpack），这破坏了 &lt;code&gt;readable-stream&lt;/code&gt; 的构建，这是一个更高级别的依赖包。我研究了对这两个第三方库中任何一个可能的 PR 修复。不过，向仓库提交一个好的修改需要花费好几天时间。我由于种种理由而拒绝了其他的变通方案。&lt;/p&gt;&lt;p&gt;通过查看 &lt;code&gt;microphone-stream&lt;/code&gt; 的代码，我意识到我并不需要该库的核心功能：一个 Node.js 风格的流接口。因此，我认真地重写了那些我真正需要的那部分代码，把那些我不想要的东西删除掉。&lt;/p&gt;&lt;p&gt;一路走来，我在源码中发现了这样的宝藏：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18571428571428572&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxszrsEOXJpuLTVTuz04tnWKjrtquRObCVBGEndBOG8C1ibgJnhicJdOqQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;还有这个：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxD582Afia9UqibhGnrPMlr0egKCXBOVxIVicbDtMiapibAibpibnTrfDylqSVg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;我很感激地将这些想法合并到我重写的代码中。&lt;/p&gt;&lt;p&gt;作者 Nathan Friedly 在这样的源码注释中阐述了他的思考过程。也许他拯救了我，可能让我以后不用再找漏洞来修复了。从这个角度来看，重写比从头开始编写要好。你可以“捕捉”到别人来之不易的知识。&lt;/p&gt;&lt;p&gt;因此，对我来说，这是一个明显的案例，重写，而非重用，可以节约我的时间，并且让我得到更好的结果。重写也比从头开始编写要好，因为这样可以让我了解其他工程师的真实经验，否则我可能会错过这些经验。&lt;/p&gt;&lt;p&gt;复制和重写——试试吧！&lt;/p&gt;&lt;p&gt;这是好东西。这算不上作弊。&lt;/p&gt;&lt;p&gt;只要遵循开源许可的条款，和你的工程师伙伴成为好邻居吧。&lt;/p&gt;&lt;p&gt;你不希望复制或重写所有的东西。但是要学习辨别哪些情况值得你这么做。&lt;/p&gt;&lt;p&gt;并享受与其他人工作中的联系。那些数以百万计的项目，都是由伟大的头脑构建的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6414285714285715&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0Mckx59cPsDu8kjWCaNSrM48vA463B0EwDRsVFHcTwY1r1c7pjUwwIwVbLw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;好吧，这个特别的孩子可能复制得太多了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;作者介绍：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Erik Hermansen，博主，撰写关于工程、技术，以及人机共同构成的系统的文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://levelup.gitconnected.com/copying-other-peoples-code-is-very-cool-717e8a72aa3b&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt; 今日文章推荐&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247526287&amp;amp;idx=1&amp;amp;sn=40ccfa506d54ac807f42ccec549f9426&amp;amp;chksm=e8d4984ddfa3115bbf70989c1bcab4f8ed1bd0e969eba46629b2157e2a94734676c317e290f5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;谷歌工作十年，我总结了这些工程师必备软技能&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;谷歌工作十年，我总结了这些工程师必备软技能&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247526174&amp;amp;idx=1&amp;amp;sn=523a1c69928eaf3d5228d124450f49cf&amp;amp;chksm=e8d498dcdfa311ca4692a85d1be0b3def9d826cbb6c8aadfcd24a435f765404dfe126703311c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;InfoQ 2022 年趋势报告：DevOps 与云计算篇&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;InfoQ 2022 年趋势报告：DevOps 与云计算篇&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt; 活动推荐&lt;/section&gt;&lt;/section&gt;&lt;p&gt;云原生环境下，混沌的微服务架构、多语言的应用、多种网络调用协议并存给可观测性带来埋点成本上升、观测数据割裂、问题定位麻烦等挑战。&lt;/p&gt;&lt;p&gt;7 月 15-16 日 ArchSummit 全球架构师峰会将落地深圳，大会设置了「可观测性技术落地探索」专题，邀请到了阿里、PingCAP、微众银行、TT 语音等公司的嘉宾向大家分享可观测性技术落地的相关实践经验，点击阅读原文查看大会更多精彩内容。&lt;/p&gt;&lt;p&gt;大会已进入倒计时，现场席位有限，了解大会详情或预订门票请咨询小助手：18514549229（微信同电话)&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9907407407407407&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfM309BBOzAe3aB7ERfdIqkRGPkc2pJIHicvQG0vsgRMatSKlbqnS1DcVouWsQYCJ8eHhribcxwahZuQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>66ce12b5c95af1042d0a7777c67da45b</guid>
<title>多线程使用不当导致的 OOM</title>
<link>https://toutiao.io/k/67rtbou</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 data-id=&quot;heading-0&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;事故描述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从 6 点 32 分开始少量用户访问 App 时会出现首页访问异常，到 7 点 20 分首页服务大规模不可用，7 点 36 分问题解决。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-id=&quot;heading-1&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-id=&quot;heading-1&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;整体经过&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6:58  发现报警，同时发现群里反馈首页出现网络繁忙，考虑到前几日晚上门店列表服务上线发布过，所以考虑回滚代码紧急处理问题。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7:07 开始先后联系 XXX 查看解决问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;7:36  代码回滚完，服务恢复正常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;事故根本原因&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事故代码模拟：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Executor executor = Executors.newFixedThreadPool(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CompletionService&amp;lt;String&amp;gt; service = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ExecutorCompletionService&amp;lt;&amp;gt;(executor);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        service.submit(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Callable&amp;lt;String&amp;gt;() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;code-snippet__title&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;HelloWorld--&quot;&lt;/span&gt; + Thread.currentThread().getName();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;根源就在于 ExecutorCompletionService 结果没调用take、poll方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正确的写法如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Executor executor = Executors.newFixedThreadPool(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CompletionService&amp;lt;String&amp;gt; service = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ExecutorCompletionService&amp;lt;&amp;gt;(executor);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    service.submit(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Callable&amp;lt;String&amp;gt;() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;code-snippet__title&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;HelloWorld--&quot;&lt;/span&gt; + Thread.currentThread().getName();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    service.take().get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一行代码引发的血案，而且不容易被发现。因为 OOM 是一个内存缓慢增长的过程，稍微粗心大意就会忽略。如果是这个代码块的调用量少的话，很可能几天甚至几个月后暴雷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;操作人回滚或者重启服务器确实是最快的方式。但是如果不是事后快速分析出 &lt;span&gt;OOM &lt;/span&gt;的代码，而且不巧回滚的版本也是带 &lt;span&gt;OOM &lt;/span&gt;代码的，就比较悲催了。如刚才所说，流量小了、回滚或者重启都可以释放内存；但是流量大的情况下，除非回滚到正常的版本，否则 GG。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 data-id=&quot;heading-3&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;探寻问题根源&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了更好的理解 ExecutorCompletionService 的 “套路”，我们用 ExecutorService 来作为对比，可以让我们更好地清楚什么场景下用 ExecutorCompletionService。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先看 ExecutorService 代码（建议下载后自己跑一跑）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test1&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;) throws Exception&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ExecutorService executorService = Executors.newCachedThreadPool();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ArrayList&amp;lt;Future&amp;lt;String&amp;gt;&amp;gt; futureArrayList = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;公司让你通知大家聚餐 你开车去接人&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Future&amp;lt;String&amp;gt; future10 = executorService.submit(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;总裁：我在家上大号 我最近拉肚子比较慢 要蹲1个小时才能出来 你等会来接我吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;总裁：1小时了 我上完大号了。你来接吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;总裁上完大号了&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    futureArrayList.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(future10);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Future&amp;lt;String&amp;gt; future3 = executorService.submit(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;研发：我在家上大号 我比较快 要蹲3分钟就可以出来 你等会来接我吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;研发：3分钟 我上完大号了。你来接吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;研发上完大号了&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    futureArrayList.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(future3);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Future&amp;lt;String&amp;gt; future6 = executorService.submit(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;中层管理：我在家上大号  要蹲10分钟就可以出来 你等会来接我吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;中层管理：10分钟 我上完大号了。你来接吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;中层管理上完大号了&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    futureArrayList.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(future6);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;都通知完了,等着接吧。&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Future&amp;lt;String&amp;gt; future : futureArrayList) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            String returnStr = future.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(returnStr + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;，你去接他&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Thread.currentThread().&lt;span class=&quot;code-snippet__keyword&quot;&gt;join&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三个任务，每个任务执行时间分别是 10s、3s、6s 。通过 JDK 线程池的 submit 提交这三个 Callable 类型的任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第一步：主线程把三个任务提交到线程池里面去，把对应返回的 Future 放到 List 里面存起来，然后执行“都通知完了,等着接吧。”这行输出语句；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第二步：在循环里面执行 future.get() 操作，阻塞等待。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后结果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7463175122749591&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zL0icanklE7x5mSD3qpMiaQSsb4JYjYKUA6D977IkVagRT76OsPvmS15A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1222&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先通知到总裁，也是先接总裁 足足等了 1 个小时，接到总裁后再去接研发和中层管理，尽管他们早就完事儿了，也得等总裁上完厕所~~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;耗时最久的-10s 异步任务最先进入 list 执行。所以在循环过程中获取这个 10 s的任务结果的时候，get 操作会一直阻塞，直到 10s 异步任务执行完毕。即使 3s、5s 的任务早就执行完了也得阻塞，等待 10s 任务执行完。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看到这里，尤其是做&lt;strong&gt;网关业务&lt;/strong&gt;的同学可能会产生共鸣。一般来说，网关 RPC 会调用下游 N 多个接口，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43148148148148147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zfzyAWezuMwgUblYT1CP2yzVgf8kzuZJxGcibyj4iaicrj5WPbLBkxicqaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果都按照 ExecutorService 这种方式，并且恰巧前几个任务调用的接口耗时比较久，同时阻塞等待，那就比较悲催了。所以 ExecutorCompletionService 应景而出。它作为任务线程的合理管控者，“任务规划师”的称号名副其实。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相同场景 ExecutorCompletionService 代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test2&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;) throws Exception&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ExecutorService executorService = Executors.newCachedThreadPool();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ExecutorCompletionService&amp;lt;String&amp;gt; completionService = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ExecutorCompletionService&amp;lt;&amp;gt;(executorService);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;公司让你通知大家聚餐 你开车去接人&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    completionService.submit(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;总裁：我在家上大号 我最近拉肚子比较慢 要蹲1个小时才能出来 你等会来接我吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;总裁：1小时了 我上完大号了。你来接吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;总裁上完大号了&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    completionService.submit(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;研发：我在家上大号 我比较快 要蹲3分钟就可以出来 你等会来接我吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;研发：3分钟 我上完大号了。你来接吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;研发上完大号了&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    completionService.submit(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;中层管理：我在家上大号  要蹲10分钟就可以出来 你等会来接我吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;中层管理：10分钟 我上完大号了。你来接吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;中层管理上完大号了&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;都通知完了,等着接吧。&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String returnStr = completionService.take().&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(returnStr + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;，你去接他&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Thread.currentThread().&lt;span class=&quot;code-snippet__keyword&quot;&gt;join&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;跑完结果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7018927444794952&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55z5icCLCTBOVgQdwXsmawDc8u7ndiaAz7w5AKZuic1vcqpUomGFsEa2uicPg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这次就相对高效了一些。虽然先通知的总裁，但是根据大家上大号的速度，谁先拉完先去接谁，不用等待上大号最久的总裁了（现实生活里建议采用第一种，不等总裁的后果 emmm 哈哈哈）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;放在一起对比下输出结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3602533650039588&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55z6oNK35cW7PibnBEHp3F6002qfahBLIagh21ruW9PIx1MrJPicTEhicHuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2526&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两段代码的差异非常小 获取结果的时候 ExecutorCompletionService 使用了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;completionService&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.take&lt;/span&gt;()&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.get&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么要用 take() 然后再 get() 呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们看看源码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CompletionService 接口以及接口的实现类&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、ExecutorCompletionService 是 CompletionService 接口的实现类&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5581967213114755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zQm6sJ3hVklvxoX0BsXX9lSdjesRn5tdqMj4PTWEbumXdgfjIN4wt9Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2440&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、接着跟一下 ExecutorCompletionService 的构造方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到入参需要传一个线程池对象，默认使用的队列是 LinkedBlockingQueue，不过还有另外一个构造方法可以指定队列类型，如下两张图，有两个构造方法。&lt;/span&gt;&lt;span&gt;默认 LinkedBlockingQueue 的构造方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48872180451127817&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zNo6jeVpsLlpfricEwzPy1enXOckzyv6jbNM5KXf469AtBDC9ibxXU7Sw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1862&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可选队列类型的构造方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3760245901639344&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zSmPbX5tVtTLRt0gICGwE2hYOJ3Tmiaq77ymoUPx6SddMo3Ugw5f9C6w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1952&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、Submit 任务提交的两种方式，都是有返回值的，我们例子中用到的就是第一种 Callable 类型的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5482717520858165&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zpvVBaicnDMZicnvqEUKI4yuA8cBT9bD2h4vfjYAYuNobiafiaBU4uCa4Gg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1678&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、对比ExecutorService 和 ExecutorCompletionService 的 submit 方法可以看出区别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5312117503059975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55z3BsaZ1kS8f9JEGC8NODLWO83wZd3iaNuLJibFnFLB8ZyXeqFrY9Hw8aw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1634&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; （1）ExecutorService&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35685752330226367&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zick3QFcBGnicygia5cSuKzxrq9gejT7wJzWEX672INbUZCYN03OoShVXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1502&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）ExecutorCompletionService&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、差异就在 &lt;strong&gt;QueueingFuture。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个到底作用是啥，我们继续跟进去看：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;QueueingFuture 继承自 FutureTask，而且红线部分标注的位置，重写了 done() 方法；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;把 task 放到 completionQueue 队列里面。当任务执行完成后，task 就会被放到队列里面去了；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;此时此刻，completionQueue 队列里面的 task 都是已经 done() 完成了的 task。而这个 task 就是我们拿到的一个个的 future 结果；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果调用 completionQueue 的 task 方法，会阻塞等待任务。等到的一定是完成了的 future，我们调用  .get() 方法 就能立马获得结果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6790393013100436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zLUkBicWNicaj0Lia4tLMibia1iaoicVkPU1nrQGPH4WnODy3gNZicbkc4IKicBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1832&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看到这里，相信大家伙都应该多少明白点了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们在使用 ExecutorService submit 提交任务后需要关注每个任务返回的 future。然而 CompletionService 对这些 future 进行了追踪，并且重写了 done 方法，让你等的 completionQueue 队列里面一定是完成了的 task；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;作为网关 RPC 层，我们不用因为某一个接口的响应慢拖累所有的请求，可以在处理最快响应的业务场景里使用 CompletionService。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是&lt;strong&gt;请注意&lt;/strong&gt;！也是本次事故的核心问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只有调用了 ExecutorCompletionService 下面的 3 个方法的任意一个时，阻塞队列中的 task 执行结果才会从队列中移除掉，释放堆内存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于该业务不需要使用任务的返回值，&lt;strong&gt;没有调用 take、poll 方法&lt;/strong&gt;，从而导致没有释放堆内存。堆内存会随着调用量的增加一直增长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4687116564417178&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zUNBaZ4O8M3TnfCjtib58TSZsPyvMyplnrRXjUofaUPB48PuUvyzKpkw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1630&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，业务场景中不需要使用任务返回值的，别没事儿使用 CompletionService。假如使用了，记得一定要从阻塞队列中移除掉 task 执行结果，避免 OOM！&lt;/span&gt;&lt;/p&gt;&lt;h1 data-id=&quot;heading-4&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-id=&quot;heading-4&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;知道事故的原因，我们来总结下方法论。毕竟孔子他老人家说过：自省吾身，常思己过，善修其身！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;上线前&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;严格的代码 review 习惯，一定要交给 back 人去看，毕竟自己写的代码自己是看不出问题的，相信每个程序猿都有这个自信；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上线记录：备注好上一个可回滚的包版本（给自己留一个后路）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上线前确认回滚后，业务是否可降级。如果不可降级，一定要严格拉长这次上线的监控周期。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;上线后&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;持续关注内存增长情况（这部分极容易被忽略，大家对内存的重视度不如 CPU 使用率）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;持续关注 &lt;span&gt;CPU &lt;/span&gt;使用率增长情况&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GC 情况、线程数是否增长、是否有频繁的 Full GC 等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关注服务性能报警，TP99、999 、MAX 是否出现明显的增高。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;45&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;转自：树洞君，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：juejin.cn/post/7064376361334358046&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651489176&amp;amp;idx=1&amp;amp;sn=372225b68021cd8e19380527dfc985c8&amp;amp;chksm=bd25efe78a5266f156f6235d221c674ad13e6c49e6133869806a283a7760bbe427a8a0273525&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;线程池运用不当的一次线上事故&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;线程池运用不当的一次线上事故&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651481184&amp;amp;idx=1&amp;amp;sn=83c6ac6b4f7743042787f22a60ecbf65&amp;amp;chksm=bd25081f8a5281094497f394d63f0597c4c0b8c52214f5afb73234456a2cb5c1a21f8b708da4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;干货！一次 kafka 卡顿事故排查过程&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;干货！一次 kafka 卡顿事故排查过程&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651481184&amp;amp;idx=1&amp;amp;sn=83c6ac6b4f7743042787f22a60ecbf65&amp;amp;chksm=bd25081f8a5281094497f394d63f0597c4c0b8c52214f5afb73234456a2cb5c1a21f8b708da4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;干货！一次 kafka 卡顿事故排查过程&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651513163&amp;amp;idx=1&amp;amp;sn=aabba4f4d206119f811550fbc0d74906&amp;amp;chksm=bd258d348a520422a17602d22f71e590d34a23822d5a499c55a7865db31cee55ba8a7089968c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Spring 官方推荐的 @Transactional 还能导致生产事故？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Spring 官方推荐的 @Transactional 还能导致生产事故？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6a4e2f208924ecc9551d5186dbcb398f</guid>
<title>应用实践 | 10 亿数据秒级关联，货拉拉基于 Apache Doris 的 OLAP 体系演进</title>
<link>https://toutiao.io/k/8y9lpg1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;关注&lt;/span&gt;&lt;span&gt;「SelectDB」&lt;/span&gt;&lt;span&gt;第一时间获取更多资讯！&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;custom_select_card mp_profile_iframe js_uneditable&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3Njc2NDAwOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSaYO6RicI4f7wJp8iamVJ655osRGXKPTyYACfNLfwp3uqv0exQg73CPVXiajkOsyuLycE1iaKN9pET87w/0?wx_fmt=png&quot; data-nickname=&quot;SelectDB&quot; data-alias=&quot;SelectDB&quot; data-signature=&quot;The enterprise-grade cloud-native distribution for Apache Doris(incubating)&quot; data-from=&quot;2&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-mpa-template-id=&quot;1159112&quot; data-mpa-category=&quot;fav&quot;&gt;&lt;section&gt;&lt;section data-tools-id=&quot;21516&quot;&gt;&lt;section powered-by=&quot;KolEditor.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;KolEditor.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;导读：&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;本文是货拉拉大数据引擎负责人杨秋吉 &amp;amp;张斌在 DataFunSummit 2022 多维分析架构峰会上的演讲分享，分享的主题是《货拉拉基于 Apache Doris 的 OLAP 体系演进及建设方法》，详细讲解了货拉拉从 OLAP1.0 到 3.0 的演进过程，其中不乏有值得借鉴的方法论以及深刻的技术思考，希望能对大家有所帮助。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;分享人&lt;/span&gt;&lt;strong&gt;&lt;span&gt;｜&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;货拉拉大数据引擎负责人 杨秋吉&amp;amp;张斌&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;业务背景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;货拉拉成立于 2013 年，成长于粤港澳大湾区，是一家从事同城、跨城货运、企业版物流服务、搬家、汽车销售及车后市场服务的互联网物流公司。&lt;/span&gt;&lt;span&gt;截至 2022 年 4 月，货拉拉的业务范围已经覆盖了国内 352 座城市，月活司机达到 58 万，月活用户达到 760 万，包含 8 条以上的业务线。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;货拉拉大数据体系为支撑公司业务，现在已经成立三个 IDC 集群、拥有上千台规模的机器数量，存储量达到了 20PB、日均任务数达到了 20k 以上，并且还处在快速增长的过程中。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;大数据体系&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;货拉拉大数据体系从下往上分为 5 层，最下面的是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;基础层和接入层&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，这两层主要会提供基础数据的存储、计算以及集群的管理功能。在基础层和接入层之上是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;平台层和数仓&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。在平台层之中包含了数据研发平台和数据治理平台，基于平台层的能力和数据仓库的数据体系，在这之上面包含了含有业务属性的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;服务层和应用层&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。整个体系自下而上相互支持，实现支持业务和赋能业务的能力。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;715&quot; data-ratio=&quot;0.5616653574234093&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFgZKJUNknD9qGLtUUjefzmXVafqXNrWDfdANCVNgX2svbatG58f7OIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1273&quot; data-width=&quot;1273&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图1.1 货拉拉大数据体系&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;数据处理流&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;货拉拉典型的数据处理流，可以分成&lt;/span&gt;&lt;span&gt;数据集成、采集、数据的存储计算、数据服务&lt;/span&gt;&lt;span&gt;四部分，同时也包含了实时、离线以及在线三大业务场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;720&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFgKmOrpRibXj4PW9JMsQpl6pd3xJqvalvEUDcrbjIZ8kgicPeNsVd9VRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图1.2 货拉拉大数据数据流&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在数据采集阶段会存在实时采集和离线采集两条路线。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;实时采集比较典型的场景为用户端上埋点会直接同步到大数据平台做存储，供后续的在线和离线计算使用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;离线的数据主要是来自于业务方的数据库，会通过天或者是小时定期采集到大数据存储中，以供后续使用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;中间是数据的存储和计算阶段。在离线场景中会通过对数据 ETL 之后转换为构造数仓的分层体系。实时比较典型的场景为数据在经过 Flink 的处理后会直接落在线存储系统，类似于 HBase 和 OLAP 等等，为后续的业务系统提供数据服务。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;OLAP 演进概览&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;货拉拉从 2021 年开始进行 OLAP 的技术研究，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;截至目前已经经历 3 个阶段：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;2021 年上半年为货拉拉的 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;OLAP1.0 阶段&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，这个阶段我们主要是支持公司的罗盘业务，我们引入的是能够提供较好的单表依据和查询能力的 Apache Druid 引擎。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;2021 年下半年为货拉拉的 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;OLAP2.0 阶段&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，我们支持了智能定位工具，这个阶段引入了够提供单表明细查询，并且还有较高的压缩率 ClickHouse。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;今年为货拉拉的 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;OLAP3.0 阶段&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，伴随着公司业务需求的不断增多，我们也会需要用到多数据源的关联分析。基于此，由于 Apache Doris 具备大表关联分析的能力，我们引入了 Apache Doris 引擎。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;717&quot; data-ratio=&quot;0.558846453624318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFv9icYnk9XdxntPIex9TY8niapVGvwgSdialZ90KxyfhPpic7GUx9ib2vD3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1283&quot; data-width=&quot;1283&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图2.1 货拉拉OLAP体系演进过程&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;OLAP1.0 孕育期&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;业务需求分析&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;先看下没有引入 OLAP 之前的业务数据流：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;722&quot; data-ratio=&quot;0.5636221701795472&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFBShrM6DOJV6UcpoWiaCpibxBxhCBX1W2SBZvlYx7nibDibhib2pNlmj34dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1281&quot; data-width=&quot;1281&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图3.1  OLAP1.0业务场景&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;根据该图可以看到业务的数据通过实时和离线处理之后会落在 MySQL，&lt;span&gt;&lt;span&gt;MyS&lt;/span&gt;&lt;span&gt;QL&lt;/span&gt; &lt;/span&gt;之中储存了维度聚合之后的结果数据，这也意味着会在 Flink 之中做大量的聚合分析，根据业务需要的相应维度所做的一系列组合都是在Flink之中做实时聚合，最后将结果储存到 &lt;span&gt;&lt;span&gt;MyS&lt;/span&gt;&lt;span&gt;QL&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;存在的问题：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;存在存储瓶颈，类似于 Kylin 之中的维度爆炸的问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;开发成本、高效率低。当业务侧需要新增维度的时候会需要对 Flink 中的所有作业都做一定的修改，然后再重新上线。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无法支持部分聚合需求。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;对于存在的这些问题，我们经过分析之后，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;总结出了 3 个背后存在的需求点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;业务侧希望能够横向扩容，解决存储瓶颈。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;希望能够自由组合维度做分析，提升业务侧开发效率。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;希望能够支持任意维度实现跨度的分析。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;根据业务需求，并通过调研，我们决定使用 OLAP 引擎来支持业务需求。那我们如何选择一款 OLAP 引擎，并把它稳定的应用到生产之中呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我们总结了如下的 4 个步骤作为解决思路：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;717&quot; data-ratio=&quot;0.5623529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFIDibd1uQTIldnZAZ4woXko28sqUD3ibFmibMj5ECMDicf17Fjj76UKQbxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1275&quot; data-width=&quot;1275&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图3.2  OLAP 1.0 解决思路&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;技术调研&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;技术调研阶段，我们对比了 Durid、ClickHouse、Kylin、Presto 和 Doris 等等引擎。结合我们上述的 3 个业务需求，&lt;/span&gt;&lt;span&gt;最终我们选择了 Druid 引擎&lt;/span&gt;&lt;span&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;原因是 &lt;span&gt;Druid &lt;/span&gt;除了能够满足我们的业务需求之外，还有一个比较重要的影响因素是 Druid 引擎是纯 Java 开发，与我们的技术栈比较吻合，可控性更高。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;716&quot; data-ratio=&quot;0.5628930817610063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFpxsMiaib8oNxMeJpFRo7yOibdz2wHZD8oLJ5CibzOhFpb4yYJYibs1ia6jpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1272&quot; data-width=&quot;1272&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图3.3  OLAP1.0技术调研&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;POC 阶段&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;POC 过程中，从以下 3 个步骤着手：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;功能验证。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在功能验证中，我们会收集业务侧的 SQL，之后提取 SQL Pattern，然后再根据 Druid 引擎的 Rollup 语义做 SQL 的改写，涉及到大量 UDF 的改写、Rollup 语义兼容以及 Count Distinct 语义兼容等等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;性能验证。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们会直接采用业务真实的数据和业务真实的 SQL 来执行。验证过程中我们会将 Cache 关闭，分别统计 P75、P90、P99 的查询耗时。在这过程中，我们会发现有部分查询的性能没有达到要求，之后我们会做性能分析。Druid 引擎本身没有比较完善的性能分析工具，不能够很好的打印出它的执行计划以及各个算子的耗时，所以我们采用了第三方的 Arthas 火焰图进行分析。定位了相应的算子后，最终我们通过优化我们建表导数的逻辑以及索引构建的逻辑，并主要通过调整 Segment 大小的同时加入物化视图的方法，进行一些参数的调整以此来优化性能。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;准确性验证。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们将业务真实数据同时写 Hive 表和 Druid，之后跑 Hive SQL和 Druid SQL，来进行数据质量的校对。在这个过程中我们会发现例如 StringLast 函数等一些函数会在特定的场景下出现计算值不稳定的问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;717&quot; data-ratio=&quot;0.5627943485086342&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkF4Q9rYjqS0CnqJwx4sMQ6ib2liaxYgPibIqibWam7iaibDfb5DXexO3ppbqjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot; data-width=&quot;1274&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图3.4 OLAP1.0 POC 验证&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;稳定性保障&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当 POC 验证完成之后，接下来我们会进行稳定性的保障。我们将&lt;strong&gt;稳定性保障分为事前、事中、事后 3 个阶段&lt;/strong&gt;：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;715&quot; data-ratio=&quot;0.5603448275862069&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkF5PCRBODEyPBytXia5YtFp1YB4iaSOtPxkhXvogZicN7RfJPXkllKWVMhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1276&quot; data-width=&quot;1276&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;图3.5 OLAP1.0 稳定性保障&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;上线阶段&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当稳定性保障建立完成之后就会进入到上线阶段。&lt;strong&gt;上线过程我们同样分成了 3 个阶段&lt;/strong&gt;：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;OLAP测试阶段。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在这个阶段中，业务的数据会接入到 Druid 之中，但是业务的真实查询还是通过原来的 &lt;span&gt;MyS&lt;/span&gt;&lt;span&gt;QL&lt;/span&gt; 库。这个阶段主要会验证 Druid 引擎的数据质量和 Druid 集群的稳定性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;上线观察阶段。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在这个阶段，业务的查询会切回到 Druid。同时旧的 &lt;span&gt;MyS&lt;/span&gt;&lt;span&gt;QL&lt;/span&gt; 链路还没有下线，业务侧能够随时切回 &lt;span&gt;MyS&lt;/span&gt;&lt;span&gt;QL&lt;/span&gt; 链路。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;OLAP运行稳定阶段。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们会把 &lt;span&gt;MyS&lt;/span&gt;&lt;span&gt;QL&lt;/span&gt; 旧的链路下线，做资源的回收。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;712&quot; data-ratio=&quot;0.5553822152886115&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFveWwoiakEKdCEOIh0t0psolQY4J9IyGiaBAzxnyXrWrzBTfnmdRrA5icQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1282&quot; data-width=&quot;1282&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图3.6 OLAP1.0 上生产&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;问题总结&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;下面总结了 1.0 阶段时遇到的问题：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据导入部分中，实时数据乱序为典型问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在数据准确性验证阶段发现 StringLast 的函数值不稳定。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Durid 没有一个高效的精准去重的函数。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;712&quot; data-ratio=&quot;0.5593087195600943&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFTyia0IJRYncUuVhIH2e4rcToRWqCs9v1VNwZZXoKEA8vAicUnmwR1mfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1273&quot; data-width=&quot;1273&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图3.7 OLAP1.0 问题总结&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;OLAP2.0 完善期&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;业务需求分析&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;在 OLAP2.0 阶段主要有以下 4 个业务需求：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;720&quot; data-ratio=&quot;0.5616224648985959&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFGraH3zGeY6KHPFC6T1YTDcg4q1J8VicRgWNytpjKYgVWh1znpvbktIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1282&quot; data-width=&quot;1282&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图4.1 OLAP2.0 业务需求分析&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下图是简单的业务工具的截图，从图中可以看到，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;OLAP2.0 需要能够支持汇总与明细，同时基于这些能力能够做一个快速的问题定位。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;702&quot; data-ratio=&quot;0.5471551052221356&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkF1YfBdrQbkEic0hnfaqVjPwR1ibqia9AVEC7ZkAP1EUqibvOmToAIuJe9mA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1283&quot; data-width=&quot;1283&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图4.2 OLAP2.0 业务需求分析骤去实现。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;716&quot; data-ratio=&quot;0.5633359559402046&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFlPfv76cwqq64cuAVickPaj15ibv3mHZom47XICWoBZiaxT4VHY3LIezvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1271&quot; data-width=&quot;1271&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图4.3 OLAP2.0 技术调研&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;OLAP2.0 我们引入了 CliclkHouse。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;ClickHouse 能够比较好地支持复杂的数据类型，同时因为业务侧是埋点数据，所以对于实时导入语义要求并没有那么高。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;没有采用 Druid 主要是有 2 个原因：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Druid 对于复杂的数据结构支持度并不是很好。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Druid 虽然能够支持明细查询，但是 Druid 的明细查询和聚合查询得分成不同的表，这样就会额外的引入一系列&lt;/span&gt;&lt;span&gt;的存储成本。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;剩下的部分就是 POC 、上生产的步骤，这两个步骤和 OLAP1.0 阶段比较类似，所以在这里就不过多展开介绍。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;OLAP3.0 成熟期&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;业务需求分析&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2022 年随着公司业务的发展，更多的产品线对于多数据源关联场景下的在线分析需求也会变得越来越迫切。比如说 AB 实验场景与实时数仓场景，这两个场景对于多表关联需求，尤其是大表的多表关联需求也变得越来越迫切。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;721&quot; data-ratio=&quot;0.5646045418950666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFPgdEOJA5ploT1lJ30icvRrHjC7y3cD8MDOt6siciaqrK7oicYrZQf5ia30A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1277&quot; data-width=&quot;1277&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图5.1 OLAP3.0 需求分析&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;举一个 AB 实验的例子。从下图可以看到，例子中是需要把 AB 实验的一个数据和后面相应的司机与用户的埋点数据关联到一起并做分析。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;在这种情况下，我们就会发现之前的两种工具都会存在一系列的弊端。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;717&quot; data-ratio=&quot;0.5579766536964981&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkF0iaJzwsEgRh8hPj2bkUBuF8hyXFdgJejictib5NCHDOPOjfubohicicQxng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1285&quot; data-width=&quot;1285&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图5.2 OLAP3.0 需求分析&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;技术调研&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在技术调研阶段我们观察了 Druid 和 ClickHouse。Druid 引擎可以支持一些维表的简单 Join，ClickHouse 则能够支持 Broadcast 这种基于内存的 Join，但是对于大数据量千万级甚至亿级的一些表的 Join 而言，ClickHouse 的性能表现不是很好。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5615141955835962&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSaiaFbY9aVQbRe6JuRNf8sur4T2LBtvahnvJxia9nDicC30ibWuH6JliblREkLaaL9kwLWc3PAQEVlJobg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5.3 OLAP3.0 技术调研&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们&lt;/span&gt;&lt;span&gt;对 Doris 进行了调研&lt;/span&gt;&lt;span&gt;，我们发现 Doris 是能够支持小表的 Join，对大表的话也同样能够支持基于 Shuffle 的 Join，&lt;/span&gt;&lt;span&gt;对于复杂数据类型（Array、JSon）的支持，经过跟 Apache Doris 社区沟通，预计将在 2022 年 7 月份的新版本中发布。&lt;/span&gt;&lt;span&gt;通过在多个维度和需求满足度上进行对比，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;我们最终选择了 Apache Doris，也是因为 Apache Doris 的 SQL 支持度非常完善。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;714&quot; data-ratio=&quot;0.5569422776911076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFg0BZpgwIL1cdtuMLyRLB2Aib5ibesgeSsuYibolajQXibCTmtKJJkVPaxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1282&quot; data-width=&quot;1282&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图5.4 OLAP3.0 技术调研&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;POC 阶段&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们除了引用业务真实的数据和场景做验证以外，还引入了 TPC-DS 的数据集做了验证。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在多表关联的场景下对单天数据进行查询，对 5 亿左右的数据量进行 Join，TP75 大概是 9 秒左右。在数据质量阶段我们也是把 TPC- DS 的数据集以及业务真实数据集，分别在 Hive 和 Doris 里面做了双跑验证，发现两者都是能够完全对得上的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;718&quot; data-ratio=&quot;0.5626959247648903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFQ7Dibc5RHYUqPZne80eicdW2aZIiapOuuqkImPTm5HyS45uWiah9aUxfnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1276&quot; data-width=&quot;1276&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图5.5 OLAP3.0 POC&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;稳定性保障&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;与之前一样依然是从事前的容量评估和压测、事中的监控和定位来进行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;709&quot; data-ratio=&quot;0.5613618368962787&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFiaPTcPAzEMdwpGyV75NmVbgE9nqp7iaeBAMGULrG0NCBcDdeYfic7GrRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1263&quot; data-width=&quot;1263&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图5.6 OLAP3.0 稳定性测试&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;下面是我们的监控图，主要是关于 Compaction 相关的一些监控，感兴趣的同学可以看看。（文末 QA 环节有部分讲解）&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;704&quot; data-ratio=&quot;0.5556432517758485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkF3PC8k7YeO7lDkIxa9d6CoGW4e6Cuj74GmMaPramV4l7y9CT7b5Chrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1267&quot; data-width=&quot;1267&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图5.7 OLAP3.0 稳定性监控&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;问题总结&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第一个问题是查询性能的优化。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;业务侧的需求为 7 天的查询 RT 需要在 5 秒内完成，在优化前，我们发现 7 天的查询 RT 是在 30 秒左右。对于这个问题，我们的主要优化策略是把小表 Join 大表改成了大表 Join 小表，主要原理是因为 Doris 默认会使用右表的数据去构建一个 Hashtable。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;还有类似下图中的情况：union all 是在子查询中，然后再和外层的另外一张大表做 &lt;span&gt;Join &lt;/span&gt;的查询方式。这种查询方式没有用到 Runtime Filter 的特性，因此我们将 union all 提到子查询外，这样就能够用到 Runtime Filter，这应该是由于这里的条件下没有推下去所导致的。同时运行时采用的 Bloom Filter 是可以将 HashKey 条件下推到大表 Scan 阶段做过滤。&lt;/span&gt;&lt;span&gt;在经过对这两者优化之后便能够满足我们的查询性能需求了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;716&quot; data-ratio=&quot;0.5651144435674822&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFCiaDsTF7AwFaYt7o63bclpvClEr17e9Vib2WA5NyjMV1Vhkgib6IhgVdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1267&quot; data-width=&quot;1267&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图5.8 OLAP3.0 问题1&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第二个问题是 UnhealthyTablet 不下降，&lt;/span&gt;&lt;span&gt;并且在查询阶段会出现 -230 的报错。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个问题的场景是我们在没有停 FIink 写任务的时候，对 BE 机器交替重启，重启完会出现很多 UnhealthyTablet。经过我们后续的分析发现，其中一个原因主要是在 Coordinator BE 在做二阶段提交的时候比较巧合，Coordinator BE 的二阶段提交 Commit 后，&lt;/span&gt;&lt;span&gt;也就是大部分的副本是已经 Commit 后且在 Publish 前&lt;/span&gt;&lt;span&gt;，在这短短的时间范围内 BE 机器被重启，这也导致会出现 Tablet 状态不一致的情况。同时由于我们当时把参数调整的过大，导致了 Compaction 压力过大。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最后的解决办法：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;与 Aapache Doris 社区的同学经过互助排查，引入了社区 1.1.0的 Patch，同时对相应的数据做了恢复。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;717&quot; data-ratio=&quot;0.5659037095501184&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFSrG9WRpqg6fH4Mw9YbMT033cEjN8EUgDciaHusJySo4sTXpIky6v2Bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1267&quot; data-width=&quot;1267&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图5.9 OLAP3.0 问题2&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;参数优化&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;打开 Profile&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。Doris 对于查询的性能分析具有非常好的 Profile 文件，这一点是非常赞的！我们可以看到各个算子在每一个阶段查询耗时以及数据处理量，这方面相比于 Druid 来说是非常便捷的！&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;调大单个查询的内存限制&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，同时把 BE 上的执行个数由 1 个调整成为 8 个，并且增加了 Compaction 在单个磁盘下的数据量。对于 Stream Load，我们把 Json 格式的最大的内存由 100 兆调整成为 150 兆，增大了 Rowset 内 Segment 的数量，并且开启了 SQL 级和 Partition 级的缓存。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;715&quot; data-ratio=&quot;0.5603448275862069&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFebTbRryckB6ib05BzCiamIFZ37jGdo1K57ISIV3OaCQsCrdZd54u078w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1276&quot; data-width=&quot;1276&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图5.10 OLAP3.0 参数优化&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;18&quot; mp-original-line-height=&quot;28.799999237060547&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;数据流&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;下图是使用 Doris 之后的数据流图：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;708&quot; data-ratio=&quot;0.5583596214511041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFNLqMuFT3WwkXdDPJicO8fOLY284zxHB94ZgH0zEPKt6qGiaLXw8C1K5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot; data-width=&quot;1268&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图5.11 OLAP3.0 数据流&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;数据流中，我们在 Flink 中做的事情已经很少了，经过数据简单的 ETL 后就可以把数据直接灌入到 Doris。经过 Doris 一系列的聚合计算、union 计算以及多表关联计算之后，业务侧就可以直接查询 Doris 来获取相关数据。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;总结与思考&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;我们 OLAP 的引进主要还是从业务需求的角度出发来匹配合适的引擎，为业务精细化运维提供技术支持。在这之后，我们也思考了一套较为完善的上线流程及稳定性保证方案，为业务的平稳运行提供能力保障。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;思考：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;我们认为很难有单个引擎能够富含各种场景。因此在技术选型时，需要针对于需求特点和引擎特点进行合理选择。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;后续规划&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们希望可以向 OLAP 平台化发展，通过实现自助化建模的同时在这方面做一些多引擎的路由，使其能够支持各类聚合、明细以及关联等场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;711&quot; data-ratio=&quot;0.5602836879432624&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFXgg2totIa4vHBKNsZkuSvojnhzakfr1snW5K2Xfu7DsxJia75ASYA4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1269&quot; data-width=&quot;1269&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图6.1 后续规划 OLAP 平台化&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除 OLAP 平台化之外，后续我们的引擎演进计划从高效、稳定和内核演进三部分来进行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;708&quot; data-ratio=&quot;0.5592417061611374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZwzUE9iakzbUfPPiaiaqAQjkFH28XFdTOuVRcOMtFkT7GuzsIR86icheYUwfz3OCJzSUBbQfjjmc0Jrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot; data-width=&quot;1266&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图6.2 后续规划 引擎演进&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;稳定性方面：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;对 Doris 还要继续深入内核理解，进行一定的二次开发。另外 Doris 社区的相关原理以及代码级别的教程数量十分丰富，这也间接性降低了我们深入 Doris 原理的难度。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;内核演进方面：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;我们发现 Doris 基本能够覆盖 Druid 所有场景，因此后续计划以 Doris 引擎为主，Clickhous 引擎为辅，逐渐将 Druid 的相关业务向 Doris 迁移。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;Q&amp;amp;A 环节&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Q：刚才讲到了后续要从 Druid 引擎迁移到 Doris，要实现迁移的成本有多大呢？&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;A：迁移成本方面和我们之前的成本是一样的。我们上线的时候也会采用以下方式：先把业务的数据同时往 Druid 和 Doris 之中写，写完之后的业务迁移会涉及一些 SQL 改造。因为 Doris 更加接近 &lt;span&gt;MyS&lt;/span&gt;&lt;span&gt;QL&lt;/span&gt; 的协议，比起 Druid SQL 会更加便捷，所以这部分的迁移成本不是很大。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Q：刚才介绍的第二个场景之中的监控图都看了哪些指标呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;A:关于监控图，我们会比较关注 Doris 的数据导入。而在数据导入部分，我们最关注的就是 Compaction 的效率，是否有 Compaction 的堆积。我们现在还是采用的默认参数，也就是 Compaction 的分数就代表它的版本号，所以我们监控的更多的是它的版本。对于这方面的监控，社区也已经有了比较完善的相应技术方案，我们也是参考了社区的技术方案来进行了监控的指标搭建。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Q：从指标上看，Doris 的实时服务在线查询性能怎么样？在数据导入情况下性能损耗可以从这些指标上看出来吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;A：实时导入方面主要是从 Compaction 的效率来看。结合到我们这边的业务场景，最多的一张表，单表一天也有 6 亿到 10 亿的数据量的导入，也是一张埋点。另外关于峰值，它的 QPS 也是能达到千到万的，所以导入这一块压力不是很大。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Q：SQL 缓存和分区缓存实际效果怎么样？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;A：SQL 缓存方面效果还好，对于很多离线场景，尤其是首页这种查询的数据量而言。比如以昨天或者是过去一个小时之前的这种情况来说，SQL 缓存命中率会非常高。分区级缓存方面，我们分区的时间还是设的是小时级，这意味着如果这个查询里面涉及到的一些分区在一个小时内没有数据更新的话，那么就会走 SQL 缓存；如果有更新的话就会走分区级缓存。总体来看效果还好，但是我们这边命中比较多的还是 SQL 级的缓存。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Q：Doris 的查询导入合并和缓存的 BE 节点的内存一般怎么分配？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;A：缓存方面我们分配的不大，还是采用的偏默认的 1G 以内。导入方面我们设计的是  parallel_fragment_exec_instance_num&lt;/span&gt; 这个参数&lt;span&gt;，大概在 8G 左右。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Q：可以解释一下 OLAP3.0 的解决思路吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;A：对于 OLAP3.0 方面来说，业务的主要诉求就是大表 &lt;span&gt;Join&lt;/span&gt;。除此之外，还有一些类似于导入的进度一致等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在大表 &lt;span&gt;Join&lt;/span&gt; 方面，我们也对比了很多的引擎。Druid 这方面就是偏维表；Clickhouse这方面还是偏基于内存方面的 Broadcast。正因如此，主要是基于大表 &lt;span&gt;Join&lt;/span&gt; 的出发点，我们选择引入了在 &lt;span&gt;Join&lt;/span&gt; 这方面能力更强的 Doris。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Q：Druid、ClickHouse 和 Doris 应该都是近实时的，就是 Near Real-time，他们的写入不是立刻可见的，是这样吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;A：是这样的。像 Doris 和 ClickHouse 之前的写入都是 Flink 直接去写，我们也没有完全做到来一条数据就写一条，都是一个微批次。一个批次最大可以达到 150 兆的数据堆积，写入一次的时间间隔也是到 10 秒左右，没有做到完全的实时写入。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Q：方便透露一下货拉拉目前 Doris 的集群的使用情况，比如机器的数量和数据量吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;A：我们的集群数量还不算很多，10 多台。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Q：对于 Doris 的运维方面，它的便捷性和 Druid、ClickHouse、Kylin、Presto 这些相比，有很好的扩展性吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;A：我们觉得是有的。第一个是在我们 Druid 方面碰到了一个比较大的痛点，就是它的角色特别多，有 6 种角色，所以需要部署的机器会非常多。另外一点是 Druid 的外部依赖也非常多，Druid 依赖于 HDFS、离线导入还需要有 Hadoop 集群。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二个是 ClickhHouse 方面，我们当时使用的版本对于 Zookeeper 也是有比较大的依赖。另外，ClickHouse 也是偏伪分布式的，有点类似于数据库的一种分表。Doris 自身就只有 FE、BE，外部依赖会非常少，所以我们从部署的角度同时考虑到 Doris 的横向扩展方面，Doris 的扩缩容也能够做到自平衡，所以相比而言 Doris 会更好一些。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Q：在实时特征场景下，分钟级的数据更新对服务性能要求比较高，可以用 Doris 吗？能达到 TP99 200 毫秒以下吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; A：TP99 能够否达到200毫秒以下主要和你查询 SQL 相关。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;例如我们这边的很多涉及到大表 Join 的查询，涉及的分区数据量大概在 10 亿量别，业务侧对于查询性能要求是 5 秒以内，通过 Doris 是可以满足我们需求的。如果是实时特征这种业务，是否能达到 200 毫秒可能需要经过一轮实际测试才能得到结果。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;资料下载&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;点击下方名片，关注&lt;/span&gt;&lt;strong&gt;&lt;span&gt;「SelectDB」&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;后台回复 “&lt;/span&gt;&lt;span&gt;&lt;strong&gt;货拉拉&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; ”！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;限时下载 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;完整版 PPT 资料！&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3Njc2NDAwOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSYAsL4vHMicGdVmylG5uibxhNhjaQ7Dw4wXfianndicIwibBqqXUEVvjicmccia3TFm0km2Oia86pQQF50ZgQ/0?wx_fmt=png&quot; data-nickname=&quot;SelectDB&quot; data-alias=&quot;SelectDB&quot; data-signature=&quot;The enterprise-grade cloud-native distribution for Apache Doris.&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0027322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSYap6EMzpzneBwO7zZ5Ub2EX6IBBXldWaI0L3XmHO9kvcJwdWHJBI8LX7Ndr0OfOxMT61bjpVlD3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;加入社区&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;欢迎热爱开源的小伙伴加入 Apache Doris 社区，除了可以在 GitHub 上提 PR 或 Issue，也欢迎大家积极参与到社区日常建设中来，比如：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;参加社区&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3Njc2NDAwOA==&amp;amp;mid=2247489095&amp;amp;idx=1&amp;amp;sn=6fb07303527038f9ed0aa89a377c2ad2&amp;amp;chksm=cf2c1840f85b915608986b71625598934fc324831b646fc69218bb2339ef0ff954ac22dbc12f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;征文活动&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;征文活动&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;进行技术解析、应用实践等文章产出；作为讲师参与 Doris 社区的线上线下活动；积极参与 Doris 社区用户群的提问与解答等。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最后，欢迎更多的开源技术爱好者加入 Apache Doris 社区，携手成长，共建社区生态。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;321&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Uecg6b8kbSaJGsyqV41aMic1nnPFCquWicS5g2w6jnpwrH3kEFNEkTIQicMwPGGKcNcANfUOfzIt8UG1HicfgH6EVA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0027322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSYap6EMzpzneBwO7zZ5Ub2EX6IBBXldWaI0L3XmHO9kvcJwdWHJBI8LX7Ndr0OfOxMT61bjpVlD3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.16666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSYAsL4vHMicGdVmylG5uibxhN3XOBT5xjTQVpyojBwHjhJgsRgD318FicEzjw0t3rK6F6HAZkDnDuq2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template-id=&quot;1159112&quot; data-mpa-category=&quot;fav&quot;&gt;&lt;section&gt;&lt;section data-tools-id=&quot;21516&quot;&gt;&lt;section powered-by=&quot;KolEditor.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;KolEditor.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;SelectDB 是一家开源技术公司，致力于为 Apache Doris 社区提供一个由全职工程师、产品经理和支持工程师组成的团队，繁荣开源社区生态，打造实时分析型数据库领域的国际工业界标准。基于 Apache Doris 研发的新一代云原生实时数仓 SelectDB，运行于多家云上，为用户和客户提供开箱即用的能力。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SelectDB 官方网站：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;https://selectdb.com (We Are Coming Soon)&lt;/p&gt;&lt;p&gt;&lt;span&gt;Apache Doris 官方网站：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;http://doris.apache.org&lt;/p&gt;&lt;p&gt;&lt;span&gt;Apache Doris Github：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;https://github.com/apache/doris&lt;/p&gt;&lt;p&gt;&lt;span&gt;Apache Doris 开发者邮件组：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;dev@doris.apache.org &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.18518518518518517&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSacCFPQEC1t42qBYRLyRAmR5GqkhSnCGEljWGfJwuQQBgPqpynV6UBt636zMtRHhlwa3nFM2UrI2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3Njc2NDAwOA==&amp;amp;mid=2247489095&amp;amp;idx=1&amp;amp;sn=6fb07303527038f9ed0aa89a377c2ad2&amp;amp;chksm=cf2c1840f85b915608986b71625598934fc324831b646fc69218bb2339ef0ff954ac22dbc12f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;93&quot; data-ratio=&quot;0.1658711217183771&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Uecg6b8kbSY0SYhPdYX7mf9wg7f57iaytRdtXs9RMmkPKLADTib4QLdlUZBzajESjJcsd0rQ55lqV2ggqTYQwLdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;838&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3Njc2NDAwOA==&amp;amp;mid=2247493182&amp;amp;idx=1&amp;amp;sn=32414441c64fac47f11c3f11a4bbb20f&amp;amp;chksm=cf2fe839f858612f73681198138c87dc3e50937b99a04f6bf52b3fb7a33d4cd047c15af7b4a4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;93&quot; data-ratio=&quot;0.1658711217183771&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Uecg6b8kbSaiaFbY9aVQbRe6JuRNf8surRWUWCuIcxQp9ooiccRLc5btXPp56dqc8vD4HSmw0zia8TosjgckIEtjg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;838&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3Njc2NDAwOA==&amp;amp;mid=2247493995&amp;amp;idx=1&amp;amp;sn=b785f0b2cec033af94491c9d9f676dff&amp;amp;chksm=cf2fe76cf8586e7a6f8017c69d3411f6ad79fe62a296082929a036f57f0bee6f7004a8fd65eb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;93&quot; data-backw=&quot;558&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;93&quot; data-ratio=&quot;0.1658711217183771&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Uecg6b8kbSaiaFbY9aVQbRe6JuRNf8surdsDHB2gPH22yEJIsJSMSRqOCibGtsKG8aDMxuWUaG3lzkJw3ImibeBIA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;838&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6aVaON9Kibf5ibKRPQgZ9XgbVNsIeQUnfKksOWF7nvlQJYqymJI2xlsp6Hr8RJf7BSgfJlBmiaWSNOiaK7culuXnEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>