<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>68301e0d3bec482c6126fb493f19b683</guid>
<title>服务调优经验总结</title>
<link>https://toutiao.io/k/av28tr1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article id=&quot;post-39608&quot; class=&quot;post-content post-39608 post type-post status-publish format-standard hentry category-6 h-entry h-as-article&quot; itemref=&quot;site-publisher&quot;&gt;
&lt;header class=&quot;entry-header&quot;&gt;
 &lt;/header&gt;

&lt;div class=&quot;entry-content e-content&quot; itemprop=&quot;description articleBody&quot;&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;版权声明 本站原创文章 由 萌叔 发表
转载请注明 萌叔 | http://vearne.cc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;萌叔工作十多年，有不少服务调优的经验，在这里整理一下思路。希望对自己和同行有所帮助。&lt;/p&gt;
&lt;h2&gt;1. 发现问题&lt;/h2&gt;
&lt;h3&gt;1.1 发现问题比解决问题难度更大&lt;/h3&gt;
&lt;p&gt;找出系统瓶颈和问题难度很大，一般只要能够找出且能够稳定复现，问题都能够被解决。&lt;/p&gt;
&lt;h3&gt;1.2 压测能够帮我们发现系统瓶颈，找出问题&lt;/h3&gt;
&lt;p&gt;压测不仅可以帮助我们发现系统瓶颈，还能用于发现死锁问题&lt;/p&gt;
&lt;h3&gt;1.3 尽可能细粒度的监控指标对发现问题帮助很大&lt;/h3&gt;
&lt;p&gt;讲几个容易忽略的细节&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Cache的场景，要留意Cache的命中率&lt;/li&gt;
&lt;li&gt;使用Channel的细节，要监控channel的长度，注意Channel是否写满，阻塞其它协程&lt;/li&gt;
&lt;li&gt;对于比较复杂的接口，如果延迟高，需要有tracing记录，关注到底是那个环节耗时过多&lt;/li&gt;
&lt;li&gt;对于MQ的场景，甚至还需要监控PageCache的命中率、磁盘IO等等&lt;/li&gt;
&lt;li&gt;GC 的耗时(特别是Java中Full GC)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2. 常见的思路&lt;/h2&gt;
&lt;h3&gt;2.1 绝大多数服务的系统瓶颈是IO&lt;/h3&gt;
&lt;p&gt;我们接触到的绝大多数服务，都是IO型服务，影响延迟的主要因素是IO，磁盘IO、网络IO，微服务的响应延迟等等&lt;/p&gt;
&lt;h3&gt;2.2 如果CPU是瓶颈，需要有火焰图，关注是哪个环节消耗的CPU过多？每个部分占比是否合理？（注意压测）&lt;/h3&gt;
&lt;p&gt;比如是否大量的CPU时间被消耗在了锁竞争、上下文切换、垃圾回收、调度等。&lt;br/&gt;
* 在Golang中，由于锁中含有自旋锁，如果对锁的竞争激烈，会有大量的CPU时间被消耗在锁上。&lt;br/&gt;
* 在Golang中，P设置不合理也会导致大量的上下文切换&lt;/p&gt;
&lt;p&gt;见文章&lt;br/&gt;
&lt;a href=&quot;http://vearne.cc/archives/39195&quot;&gt;GOMAXPROCS你设置对了吗？&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2.3 某一类型的服务，往往会有一组需要额外注意的核心指标&lt;/h3&gt;
&lt;p&gt;某些特定的服务容易受到特定因素的影响，比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于模型的分类器，压测时要特别关注它的CPU使用率是否能够跑满&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;见文章&lt;br/&gt;
&lt;a href=&quot;http://vearne.cc/archives/39300&quot;&gt;AI预测模型工程化性能调优&lt;/a&gt;&lt;br/&gt;
* 数据库服务要留意磁盘IO&lt;/p&gt;
&lt;h3&gt;2.4 GC&lt;/h3&gt;
&lt;p&gt;有GC的场景，还要特别留意GC可能带来的负面影响&lt;/p&gt;
&lt;h3&gt;2.5 日志对服务性能影响不小&lt;/h3&gt;
&lt;blockquote&gt;&lt;p&gt;
写文件和写控制台的性能差不多, 每秒钟差不多30w条。假定一个请求产生30条日志，也就是说即使处理这个请求没有任何逻辑，光是打日志，QPS也就差不多1w左右。(这也是很多服务压测的QPS无法超过1w的原因)。
&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;见文章&lt;br/&gt;
&lt;a href=&quot;http://vearne.cc/archives/39275&quot;&gt;玩转高性能日志库ZAP(5)-异步写日志&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当你不知道该怎么调优的时候，可以试试关闭所有日志看看。😄&lt;/p&gt;
&lt;h2&gt;3. 常见的优化手段&lt;/h2&gt;
&lt;h3&gt;3.1 串行变并发&lt;/h3&gt;
&lt;p&gt;在IO型服务非常常见&lt;/p&gt;
&lt;h3&gt;3.2 同步变异步&lt;/h3&gt;
&lt;p&gt;常见的场景是回写数据库&lt;/p&gt;
&lt;h3&gt;3.3 单条变批量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;比如数据需要回写数据库，可以在内存中缓存一拨，批量回写数据库，可以减少网络开销，降低数据库的开销&lt;/li&gt;
&lt;li&gt;另外像写日志文件，批量写可以减少系统调用，提高写入效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;笔者之前曾做过测试，将日志从单条同步写改为异步批量写，吞吐能力提升了1倍多。&lt;/p&gt;
&lt;p&gt;见文章&lt;br/&gt;
&lt;a href=&quot;http://vearne.cc/archives/39275&quot;&gt;玩转高性能日志库ZAP(5)-异步写日志&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3.4 善用Cache&lt;/h3&gt;
&lt;p&gt;在多读少写的服务中，Cache对提升服务的能力效果非常显著。(别忘了监控Cache)&lt;/p&gt;
&lt;h3&gt;3.5 借鉴同行的经验&lt;/h3&gt;
&lt;p&gt;毕竟同行踩过的坑，我们还是会再踩一遍的，可以多留意github中的issue记录。&lt;/p&gt;
&lt;h2&gt;4. 其它&lt;/h2&gt;
&lt;h3&gt;4.1 过早优化是万恶之源&lt;/h3&gt;
&lt;p&gt;没事别瞎折腾&lt;/p&gt;
&lt;h3&gt;4.2 越接近业务侧的优化，效果越显著&lt;/h3&gt;
&lt;h2&gt;5. 结尾&lt;/h2&gt;
&lt;p&gt;好多东西不整理一下，自己都快忘了。希望下次再排查问题或者调优的时候，我也能从中收益。&lt;/p&gt;
&lt;hr/&gt;
&lt;h4&gt;请我喝瓶饮料&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/woshiaotian/ohw8kvpn5k7hthgbuol4e4aq/WechatIMG29.jpg&quot; alt=&quot;微信支付码&quot; data-pagespeed-url-hash=&quot;2495828515&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;clear&quot;/&gt;
&lt;/div&gt;
&lt;nav class=&quot;navigation post-navigation&quot; role=&quot;navigation&quot; aria-label=&quot;文章&quot;&gt;
&lt;h2 class=&quot;screen-reader-text&quot;&gt;文章导航&lt;/h2&gt;

&lt;/nav&gt; &lt;p class=&quot;clear&quot;/&gt;

&lt;/article&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>07a3443e3a30d9e403f43cac14d86226</guid>
<title>接下来一段时间会对大家进行网络通信的魔鬼训练：理解 Socket</title>
<link>https://toutiao.io/k/1guurta</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzNjAxODg4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlic1g1jGjiaBS1uNgC9uX4jDFicf7wBxXh5ic9WicdiaDq0qtNYgXjqOWZtpXqnXVibuZlfn7gzrWPObnEDQ/0?wx_fmt=png&quot; data-nickname=&quot;编程一生&quot; data-alias=&quot;cloudrise1986&quot; data-signature=&quot;致力于写大家都能看懂的、有深度的技术文章&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;下一篇标题是《深入理解MQ生产端的底层通信过程》，建议文章读完之前、或者读完之后，再读一遍我之前写的&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485843&amp;amp;idx=1&amp;amp;sn=ae07db807669699bc4bec807aa468a5c&amp;amp;chksm=fafde33dcd8a6a2b8a34483bc61771c3cf99a49a7baf46e47e770c58372808e2053f27a203e1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《RabbitMQ设计原理解析》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《RabbitMQ设计原理解析》&lt;/a&gt;，结合理解一下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我大学时流行过一个韩剧《大长今》，大女主长今是个女厨。她升级打怪的过程中，中国明朝来了个官员，是个吃货。那时候大明八方来朝，威风凛凛。那小朝鲜国可不敢怠慢，理论上应该大鱼大肉。人家长今凭借女主光环，给官员上了一桌素餐。官员勃然大怒，要把长今拉去砍头。长今解释说：官员脾胃失和，不适合大鱼大肉，让官员给她一段时间，天天吃她做的菜，他吃着吃着就会觉得素餐好吃了。官员就和她签了对赌协议。吃了一段时间素餐之后，官员向长今道歉，说明知道自己身体不适合大鱼大肉，但是管不住嘴，长今帮了他大忙。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实要讲《深入理解MQ生产端的底层通信过程》这一篇之前我也做了很多的铺垫：&lt;/span&gt;从&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485862&amp;amp;idx=1&amp;amp;sn=414f61b537094b14dab2682a343700e9&amp;amp;chksm=fafde308cd8a6a1e993ed8774cef1c8dc1233761a17b27395b89e3d2c74b0908e0971aeedf9a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《架构师之路-https底层原理》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《架构师之路-https底层原理》&lt;/a&gt;的https协议，到&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485988&amp;amp;idx=1&amp;amp;sn=efad5a030bc0a933ac5af2ee09f3c6c4&amp;amp;chksm=fafde08acd8a699c198d0d65c413273f05f2796cfd873160c2ba81ed3f33aebfaccb62234cb7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《一个http请求进来都经过了什么(2021版)》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《一个http请求进来都经过了什么(2021版)》&lt;/a&gt;实际上经过的物理通道，然后深入理解三次握手&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486103&amp;amp;idx=1&amp;amp;sn=943c5b7f3558df78164321806f273c8f&amp;amp;chksm=fafde039cd8a692f86f0ac97b0e1e05ece075de3e4f33e6a5ec90b269c51aed1963ff3107e0e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《懂得三境界-使用dubbo时请求超过问题》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《懂得三境界-使用dubbo时请求超过问题》&lt;/a&gt;。有的文章读起来有点难度，我希望大家能像那位中国的官员一样，虽然不情愿但还是坚持一段时间，相信对于多数人来言对底层通信的理解会提升一个层次。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;接下来是网络编程的干货时间，是下一篇文章的预备知识，不用担心，浅显易懂(多读几遍的话)。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;socket编程究竟是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;socket的本质&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;socket的本质就是一种类型的文件，所以一个socket在进行读写操作时会对应一个文件描述符fd(file descriptor)。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7784090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicNVdCPHGOs2zB6FvOHyI5Y86OYjOPPScr5606EGbqbljfKGwsAR7lYgGCfsDtWQDvyBht3IXC4lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;704&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;socket的作用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41064638783269963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl8W5MBSAVicGgJ8bmicz4wgcvHYG2usia51HksBatPFTzmkXUjBdwJxmhAqZGROBJhIcficMPVVkfeeqA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1052&quot;/&gt;&lt;/p&gt;&lt;p&gt;上图是四层TCP/IP网络标准中，TCP/IP协议族的主要成员。今天只看上面两层。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最上层的应用层，涉及的协议封装的命令平时工作中也很常用，比如：ping、telnet。也有一些不是通过命令但也非常常用，比如：http。下一层的应用层有可靠的TCP协议和不可靠的UDP协议。平时工作中，常见的中间件如zookeeper、redis、dubbo这些都是使用TCP协议，因为这个内部封装完善，使用更简单。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;要注意的是传输层操作是在内核空间完成的，就是说不是靠咱们平时的应用编码可以直接介入的。咱们平时直接用的就是应用层协议。想通过应用层操作传输层怎么办呢？这就用到了socket编程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;socket的简单原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5414746543778801&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl8W5MBSAVicGgJ8bmicz4wgcvxkz8bmFxP5lnV4YxCAwk9IvV8krleveUKia29fficbdhbJtjgaXEpOxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;434&quot;/&gt;&lt;/p&gt;&lt;p&gt;Socket位于TCP/IP之上，通过Socket可以方便的进行通信连接。对外屏蔽了复杂的TCP/IP。它是一种&quot;打开—读/写—关闭&quot;模式的实现，服务器和客户端各自维护一个&quot;文件&quot;（有对应的文件描述符fd），在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.39594843462246776&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8W5MBSAVicGgJ8bmicz4wgcvTEUzKknD75KyVMxQZWAu0Ar2iaBqyhfHWYy31rpIicowEGJvS0KHb21w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;543&quot;/&gt;&lt;/p&gt;&lt;p&gt;要注意的是，想建立通信连接，需要一对socket。一个是客户端的socket，另外一个是服务端的socket。每个socket对应一个文件描述符fd。读和写都是通过这个fd完成的。但是一个socket对应两个缓冲区。一个读缓冲区，对应接收端；一个写缓冲区，对应发送端。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;再次理解三次握手和四次挥手&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1065830721003134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl8W5MBSAVicGgJ8bmicz4wgcviciaPLFGAQGggcw638lYSn0v8wJqv6icWXkaREMVl6LoyaL0leoxKKjMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;p&gt;上面是TCP下通信调用Linux Socket API流程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;服务端一启动，就要先调用socket函数建立socket，socket会调用bind函数绑定对应的IP和端口。之后listen函数的作用可能和大多数人理解都不同，它的主要作用是设置监听上限。就是允许多少个客户端进行连接。accept函数是以监听客户端请求的。调用了这个函数就相当于咱们平时的thrift服务端启动了。具备了三次握手的条件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这时候客户端也建立一个套接字，调用connect函数执行三次握手。成功后，服务端调用accept函数新建立一个socket专门用来和这个客户端进行通信。之前的老socket用来监听别的请求。这里注意：客户端套接字和服务端套接字是成对出现。但是这里一共出现了三个套接字。因为客户端和服务端正式握手时，服务端使用的是新建的socket来处理这个客户端的通信。因为老的socket还需要监听是否有其他的客户端。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;接下来的send、recv和write函数都是处理数据的，这里不过多解释。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;客户端使用close函数进行四次挥手关闭与服务端的连接。服务端使用recv函数接收到了关闭请求执行挥手。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;程序理解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Linux Socket API很多语言都有对它的实现，差不多的。这里因为我本人更熟悉Java，这里用Java做说明。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;client&lt;/span&gt;() &lt;span&gt;throws &lt;/span&gt;Exception {&lt;br/&gt;    &lt;span&gt;int &lt;/span&gt;i = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;    while &lt;/span&gt;(i &amp;lt;= &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;        Socket socket = &lt;span&gt;new &lt;/span&gt;Socket(&lt;span&gt;&quot;127.0.0.1&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;520&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向服务器端第一次发送字符串&lt;br/&gt;               &lt;/span&gt;OutputStream netOut = socket.getOutputStream()&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;InputStream io = socket.getInputStream()&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;String msg = i == &lt;span&gt;1 &lt;/span&gt;? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户端：我知道我是任性太任性，伤透了你的心。我是追梦的人，追一生的缘分。&lt;/span&gt;&lt;span&gt;&quot; &lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户端：我愿意嫁给你，你却不能答应我。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(msg)&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;netOut.write(msg.getBytes())&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;netOut.flush()&lt;span&gt;;&lt;br/&gt;        byte&lt;/span&gt;[] bytes = &lt;span&gt;new byte&lt;/span&gt;[i == &lt;span&gt;1 &lt;/span&gt;? &lt;span&gt;104 &lt;/span&gt;: &lt;span&gt;64&lt;/span&gt;]&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;io.read(bytes)&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;String response = &lt;span&gt;new &lt;/span&gt;String(bytes)&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(response)&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;netOut.close()&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;io.close()&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;socket.close()&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;i++&lt;span&gt;;&lt;br/&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;如果不开服务端，只执行客户端代码，则报异常：&lt;/p&gt;&lt;p&gt;java.net.ConnectException: Connection refused: connect&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;咱们来看这个代码做了什么：启动客户端，与服务端建立连接，理论上要调用linux的socket和connect两个函数。这个动作在new Socket实例化的时候是做了的：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;private &lt;/span&gt;&lt;span&gt;Socket&lt;/span&gt;(SocketAddress address&lt;span&gt;, &lt;/span&gt;SocketAddress localAddr&lt;span&gt;,&lt;br/&gt;               boolean &lt;/span&gt;stream) &lt;span&gt;throws &lt;/span&gt;IOException {&lt;br/&gt;    setImpl()&lt;span&gt;;&lt;br/&gt;    &lt;/span&gt;&lt;span&gt;// backward compatibility&lt;br/&gt;    &lt;/span&gt;&lt;span&gt;if &lt;/span&gt;(address == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;throw new &lt;/span&gt;NullPointerException()&lt;span&gt;;&lt;br/&gt;    try &lt;/span&gt;{&lt;br/&gt;        createImpl(stream)&lt;span&gt;;&lt;br/&gt;        if &lt;/span&gt;(localAddr != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            bind(localAddr)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;            connect(address);&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;} &lt;span&gt;catch &lt;/span&gt;(IOException | IllegalArgumentException | SecurityException e) {&lt;/p&gt;&lt;span&gt;try &lt;/span&gt;{&lt;br/&gt;            close()&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(IOException ce) {&lt;br/&gt;            e.addSuppressed(ce)&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;}&lt;br/&gt;        &lt;span&gt;throw &lt;/span&gt;e&lt;span&gt;;&lt;br/&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然后咱们看服务端代码：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;server&lt;/span&gt;() &lt;span&gt;throws &lt;/span&gt;Exception {&lt;br/&gt;    ServerSocket serverSocket = &lt;span&gt;new &lt;/span&gt;ServerSocket(&lt;span&gt;520&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;    int &lt;/span&gt;i = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;    while &lt;/span&gt;(i &amp;lt;= &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;        String msg = i == &lt;span&gt;1 &lt;/span&gt;? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务端：我知道你是任性太任性，伤透了我的心。同是追梦的人，难舍难分。&lt;/span&gt;&lt;span&gt;&quot; &lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务端：你愿意嫁给你，我却不能向你承诺。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;Socket socket = serverSocket.accept()&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;InputStream io = socket.getInputStream()&lt;span&gt;;&lt;br/&gt;        byte&lt;/span&gt;[] bytes = &lt;span&gt;new byte&lt;/span&gt;[i == &lt;span&gt;1 &lt;/span&gt;? &lt;span&gt;112 &lt;/span&gt;: &lt;span&gt;64&lt;/span&gt;]&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;io.read(bytes)&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;new &lt;/span&gt;String(bytes))&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;OutputStream os = socket.getOutputStream()&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(msg)&lt;span&gt;;&lt;br/&gt;        byte&lt;/span&gt;[] outBytes = msg.getBytes()&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;os.write(outBytes)&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;os.flush()&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;os.close()&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;io.close()&lt;span&gt;;&lt;br/&gt;        &lt;/span&gt;i++&lt;span&gt;;&lt;br/&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;如果客户端没有启动，只启动服务端。上面提到会进入监听状态，这里程序用的是最简单的阻塞式监听。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6846950517836594&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8W5MBSAVicGgJ8bmicz4wgcvcG29UPkia2TGzesWvXK80abpW4M57ahDGF0icicx1pQVViaGUhDZQlOgmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;869&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上所示，在执行accept方法时，server开始打圈圈，阻塞了。客户端启动后，server进行到了下面读取数据的阶段：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.551094890510949&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8W5MBSAVicGgJ8bmicz4wgcvLicTXPJPZibibPp6p0pNibTKDoNXR0fzuUgHznDhJkQvMBVQKn0GK6q5CQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1096&quot;/&gt;&lt;/p&gt;&lt;p&gt;执行完后客户端和服务端都正常返回结果：&lt;/p&gt;&lt;p&gt;客户端：我知道我是任性太任性，伤透了你的心。我是追梦的人，追一生的缘分。    &lt;/p&gt;&lt;p&gt;服务端：我知道你是任性太任性，伤透了我的心。同是追梦的人，难舍难分。&lt;/p&gt;&lt;p&gt;客户端：我愿意嫁给你，你却不能答应我。       &lt;/p&gt;&lt;p&gt;服务端：你愿意嫁给你，我却不能向你承诺。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;/**&lt;br/&gt; * Create a server with the specified port, listen backlog, and&lt;br/&gt; * local IP address to bind to.  The &lt;/span&gt;&lt;span&gt;&amp;lt;i&amp;gt;&lt;/span&gt;&lt;span&gt;bindAddr&lt;/span&gt;&lt;span&gt;&amp;lt;/i&amp;gt; &lt;/span&gt;&lt;span&gt;argument&lt;br/&gt; * can be used on a multi-homed host for a ServerSocket that&lt;br/&gt; * will only accept connect requests to one of its addresses.&lt;br/&gt; * If &lt;/span&gt;&lt;span&gt;&amp;lt;i&amp;gt;&lt;/span&gt;&lt;span&gt;bindAddr&lt;/span&gt;&lt;span&gt;&amp;lt;/i&amp;gt; &lt;/span&gt;&lt;span&gt;is null, it will default accepting&lt;br/&gt; * connections on any/all local addresses.&lt;br/&gt; * The port must be between 0 and 65535, inclusive.&lt;br/&gt; * A port number of {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;0} means that the port number is&lt;br/&gt; * automatically allocated, typically from an ephemeral port range.&lt;br/&gt; * This port number can then be retrieved by calling&lt;br/&gt; * {&lt;/span&gt;&lt;span&gt;@link &lt;/span&gt;&lt;span&gt;#getLocalPort getLocalPort}.&lt;br/&gt; *&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;&amp;lt;P&amp;gt;&lt;/span&gt;&lt;span&gt;If there is a security manager, this method&lt;br/&gt; * calls its {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;checkListen} method&lt;br/&gt; * with the {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;port} argument&lt;br/&gt; * as its argument to ensure the operation is allowed.&lt;br/&gt; * This could result in a SecurityException.&lt;br/&gt; *&lt;br/&gt; * The {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;backlog} argument is the requested maximum number of&lt;br/&gt; * pending connections on the socket. Its exact semantics are implementation&lt;br/&gt; * specific. In particular, an implementation may impose a maximum length&lt;br/&gt; * or may choose to ignore the parameter altogther. The value provided&lt;br/&gt; * should be greater than {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;0}. If it is less than or equal to&lt;br/&gt; * {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;0}, then an implementation specific default will be used.&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;&amp;lt;P&amp;gt;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;* &lt;/span&gt;&lt;span&gt;@param &lt;/span&gt;&lt;span&gt;port  &lt;/span&gt;&lt;span&gt;the port number, or {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;0} to use a port&lt;br/&gt; *              number that is automatically allocated.&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@param &lt;/span&gt;&lt;span&gt;backlog &lt;/span&gt;&lt;span&gt;requested maximum length of the queue of incoming&lt;br/&gt; *                connections.&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@param &lt;/span&gt;&lt;span&gt;bindAddr &lt;/span&gt;&lt;span&gt;the local InetAddress the server will bind to&lt;br/&gt; *&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@throws  &lt;/span&gt;&lt;span&gt;SecurityException if a security manager exists and&lt;br/&gt; * its {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;checkListen} method doesn&#x27;t allow the operation.&lt;br/&gt; *&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@throws  &lt;/span&gt;&lt;span&gt;IOException if an I/O error occurs when opening the socket.&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@exception  &lt;/span&gt;&lt;span&gt;IllegalArgumentException if the port parameter is outside&lt;br/&gt; *             the specified range of valid port values, which is between&lt;br/&gt; *             0 and 65535, inclusive.&lt;br/&gt; *&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@see &lt;/span&gt;&lt;span&gt;SocketOptions&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@see &lt;/span&gt;&lt;span&gt;SocketImpl&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@see &lt;/span&gt;&lt;span&gt;SecurityManager#checkListen&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@since   &lt;/span&gt;&lt;span&gt;JDK1.1&lt;br/&gt; */&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;ServerSocket&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;port&lt;span&gt;, int &lt;/span&gt;backlog&lt;span&gt;, &lt;/span&gt;InetAddress bindAddr) &lt;span&gt;throws &lt;/span&gt;IOException {&lt;br/&gt;    setImpl()&lt;span&gt;;&lt;br/&gt;    if &lt;/span&gt;(port &amp;lt; &lt;span&gt;0 &lt;/span&gt;|| port &amp;gt; &lt;span&gt;0xFFFF&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;throw new &lt;/span&gt;IllegalArgumentException(&lt;br/&gt;                   &lt;span&gt;&quot;Port value out of range: &quot; &lt;/span&gt;+ port)&lt;span&gt;;&lt;br/&gt;    if &lt;/span&gt;(backlog &amp;lt; &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;      backlog = &lt;span&gt;50&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;    try &lt;/span&gt;{&lt;br/&gt;        bind(&lt;span&gt;new &lt;/span&gt;InetSocketAddress(bindAddr&lt;span&gt;, &lt;/span&gt;port)&lt;span&gt;, &lt;/span&gt;backlog)&lt;span&gt;;&lt;br/&gt;    &lt;/span&gt;} &lt;span&gt;catch&lt;/span&gt;(SecurityException e) {&lt;br/&gt;        close()&lt;span&gt;;&lt;br/&gt;        throw &lt;/span&gt;e&lt;span&gt;;&lt;br/&gt;    &lt;/span&gt;} &lt;span&gt;catch&lt;/span&gt;(IOException e) {&lt;br/&gt;        close()&lt;span&gt;;&lt;br/&gt;        throw &lt;/span&gt;e&lt;span&gt;;&lt;br/&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;这是服务端ServerSocket的实例化过程，注意一下backlog这个参数，就是&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486103&amp;amp;idx=1&amp;amp;sn=943c5b7f3558df78164321806f273c8f&amp;amp;chksm=fafde039cd8a692f86f0ac97b0e1e05ece075de3e4f33e6a5ec90b269c51aed1963ff3107e0e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《懂得三境界-使用dubbo时请求超过问题》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《懂得三境界-使用dubbo时请求超过问题》&lt;/a&gt;里产生问题的罪魁祸首。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里注释已经说的很明白了，我就直接翻译成中文：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;创建一个指定端口的服务端，监听backlog和绑定的本地IP。bindAddr参数可以用于多个网络端口的主机。但是一个服务端Socket只能连接到其中一个地址。如果bindAddr参数为空，它会默认连接本机。端口值必须介于0到65535之间。端口号通常是从临时端口段(1024之后)动态指定的，可以通过getLocalPort方法把值取出来。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果有安全管理(在上面代码里看不到安全管理是因为这段代码在bind方法里面)，则会对端口进行权限检查，确保操作是允许的。这一步可能引发安全检查异常。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;backlog参数是这个socket等待连接的最大允许请求量。它的精确语义和实现有关。需要重点来说的是，这个实现可以选择自己指定一个上限同时选择忽略这个参数，并且这个自己指定的上线还要比这里的backlog参数值大。如果实现里是小于等于这里的backlog参数的，就会直接使用实现的默认值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;强烈建议读完本文再次读一遍&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486103&amp;amp;idx=1&amp;amp;sn=943c5b7f3558df78164321806f273c8f&amp;amp;chksm=fafde039cd8a692f86f0ac97b0e1e05ece075de3e4f33e6a5ec90b269c51aed1963ff3107e0e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《懂得三境界-使用dubbo时请求超过问题》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;《懂得三境界-使用dubbo时请求超过问题》&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;，深入理解backlog问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;历史推荐&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5b14428de9374e4e268103f376c80213</guid>
<title>Grafana 使用表格面板进行数据可视化</title>
<link>https://toutiao.io/k/bwl72c9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4MjQ0MTU4Ng==&amp;amp;mid=2247496372&amp;amp;idx=1&amp;amp;sn=4638066d1d61e08c49f912bbd62c7d71&amp;amp;chksm=fdbafda9cacd74bfc3ac35656ea5b17a1a58a37a03ac2b66d8ce37e7c246cb29707d85fa6a14&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;前面我们了解了如何使用基于时序数据的面板&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;前面我们了解了如何使用基于时序数据的面板&lt;/a&gt;，接下来我们了解另外一个&lt;strong&gt;表格面板&lt;/strong&gt;，表格面板可视化非常灵活，支持时间序列和表格和原始 JSON 数据的多种模式，此面板还提供日期格式、值格式和着色选项。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100012733&quot; data-ratio=&quot;0.3382157123834887&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6CO5Zy38zWVoZUHGoicMNZTCiaxGwibukhKN0lYJibmpkNSE35vhCUJRwC6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1502&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;添加表格面板&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们以统计服务器资源为例，对表格面板的使用进行说明。在 Dashboard 中添加添加一个空的 Panel 面板，进入面板编辑器后在右侧上方选择 &lt;code&gt;Table&lt;/code&gt; 面板：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100012734&quot; data-ratio=&quot;1.5665024630541873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6CzCuqZ3mE56EVm27DmC1GwDvE731dPJiapG8YKOsJC6dDNRj9xN7JMDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们需要展示节点信息，我们可以使用 &lt;code&gt;node_uname_info&lt;/code&gt; 指标来获取，在查询区域添加如下所示查询语句：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100012736&quot; data-ratio=&quot;0.6217798594847775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6CNEIEonkzfhNNAXmpPcpsnzbNxyfN49tcibAkQIdFyR2E6oOAoYOMCHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1708&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后再添加一个查询来获取节点运行时间的相关信息，可以使用 &lt;code&gt;node_boot_time_seconds&lt;/code&gt; 指标来进行计算，查询语句为 &lt;code&gt;sum(time() - node_boot_time_seconds{job=&quot;node-exporter&quot;})by(instance)&lt;/code&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100012735&quot; data-ratio=&quot;0.570430733410943&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6CeOvw9Vv7NXqBTLLSLajMsJ00ZYSV6MNoiafFwDZG3XcNp2VSmf6mddw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1718&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们对于节点其他资源统计也非常关心，比如节点总内存、总 CPU 数、负载、带宽等等信息，接下来分别添加如下查询：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;总内存：&lt;code&gt;node_memory_MemTotal_bytes{job=&quot;node-exporter&quot;}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU 核数：&lt;code&gt;count(node_cpu_seconds_total{job=&quot;node-exporter&quot;, mode=&#x27;system&#x27;}) by (instance)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;5 分钟负载：&lt;code&gt;node_load5{job=&quot;node-exporter&quot;}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;连接数：&lt;code&gt;node_netstat_Tcp_CurrEstab{job=&quot;node-exporter&quot;}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下载带宽：&lt;code&gt;max(rate(node_network_receive_bytes_total{job=&quot;node-exporter&quot;}[$interval])*8) by (instance)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上传带宽：&lt;code&gt;max(rate(node_network_transmit_bytes_total{job=&quot;node-exporter&quot;}[$interval])*8) by (instance)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如还有其他需要展示的也可以直接添加新的查询即可：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100012737&quot; data-ratio=&quot;0.6388888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6Cb1W8JKYe6qMDic5XChLtsC1Vj2gjRJWLbMr5SbZTk1DibaJUJ4HnJXPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1728&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;表格转换&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们将所有需要展示的信息都通过 &lt;code&gt;Table&lt;/code&gt; 形式展示出来了，但是现在有一个很大的问题，就是需要对每一个查询切换显示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100012741&quot; data-ratio=&quot;0.6347724620770129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6C4k3LcL3d4JjrZdGk8NXzHO6S3MBuwY3ia25JgVia3QliaNU1sJIloARxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1714&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这显然是非常不友好的显示方式，我们需要将这些表格内容合并成一个表格进行展示，这个时候就需要用到 Grafana 的 &lt;code&gt;Transform&lt;/code&gt; 转换功能了，在 &lt;code&gt;Transform&lt;/code&gt; 选项卡中选择 &lt;code&gt;Merge&lt;/code&gt; 选项：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100012738&quot; data-ratio=&quot;0.33993015133876603&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6CxZ8W38FyVRUxxuollia4AJ7zfXnbNULqFz8jfLgvicS5Ppznk2NPyiaibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1718&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Merge&lt;/code&gt; 转换器可以合并多个序列或者多个表格为一个表格，其中可合并的值将合并到同一行中，用于显示在表格中可视化的多个序列、表格或两者的组合。当我们选择了 &lt;code&gt;Merge&lt;/code&gt; 转换器过后就会将上面的多个查询结果合并成一个表格。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100012739&quot; data-ratio=&quot;0.43037974683544306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6CLozIpdCgkEXuXiaZBe8NR4NEgKGiaZvROnNBK5uwWTmhq7tQ5nDxiaLFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1738&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但其实合并后的表格数据有一些地方没有显示，这是因为我们查询的结果实际上是包含 &lt;code&gt;__name__&lt;/code&gt; 这个标签的，在合并的时候会造成数据丢失，我们可以将所有的查询语句后面添加上一个 &lt;code&gt;- 0&lt;/code&gt; 来去掉这个标签，这样合并的时候就不会丢失数据了。比如查询主机信息的语句变成 &lt;code&gt;node_uname_info{job=&quot;node-exporter&quot;} - 0&lt;/code&gt;，其他的语句也都加上 &lt;code&gt;- 0&lt;/code&gt; 这个操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100012740&quot; data-ratio=&quot;0.5854503464203233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6CcT0B4micB1rMAcPqvB0kjo44ejmJqsID3KbliciaBZr4ibeg9LMLbQTaeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1732&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据虽然正确了，但是表头却看不出来是表达的什么意义，有的列还是不需要的，这个时候同样也要用到 &lt;code&gt;Transform&lt;/code&gt; 转换器了，这里我们需要用到的是 &lt;code&gt;Organize fields&lt;/code&gt; 转换器，该转换器允许用户重新排序、隐藏或重命名字段或者列。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100012742&quot; data-ratio=&quot;0.6477404403244496&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6CNLibib1cSIWvuqLztYclBoYaWYZF163OM6micNs3vXzBe25GZYTVRQrsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1726&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们将不需要的一些列隐藏掉了，将表头进行了重命名。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;属性覆盖&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们将查询的数据结果用一个表格展示出来了，但是现在我们的数据都是直接的一个结果，我们需要进行转换加上我们的单位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如对于&lt;strong&gt;运行时间&lt;/strong&gt;这一列，我们需要添加覆盖，设置一个 &lt;code&gt;seconds (s)&lt;/code&gt; 类型的单位，然后会根据我们的结果进行自动转换：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012743&quot; data-ratio=&quot;0.4248878923766816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6CiclT3SXdZAC8D6x8YW3Et3We5fSqDFCRJjyOzoxkyhdkXzCHPW0fnbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1784&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样对总内存这一列的数据结果进行覆盖添加 &lt;code&gt;bytes(IEC)&lt;/code&gt; 类型的单位：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012745&quot; data-ratio=&quot;0.6506746626686657&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6CicgnuOBgufcoZXt7D2Wb9icxbEatNaaia3X8uVr9l1194hoMvrI65syow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1334&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外在定制某列数据的显示效果的时候我们还可以为其配置背景颜色，只需要设置 &lt;code&gt;Cell display mode&lt;/code&gt; 表格模式，该属性可以配置文本颜色、背景、按照 gauge 进行显示等方式：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012747&quot; data-ratio=&quot;0.5464566929133858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6CGTQ1R2j4k8jlwsibz9jmiaMdNicAH19nNxolrd4Kvf3bsR9jHMbDrTrTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2540&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们可以为 &lt;code&gt;CPU使用率&lt;/code&gt; 与 &lt;code&gt;内存使用率&lt;/code&gt; 配置显示模式为 &lt;code&gt;LCD gauge&lt;/code&gt;，显示效果如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100012744&quot; data-ratio=&quot;0.6388888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6C8mtiaNV6cWiaicnibx5pk65ZjA0MAOF3u3G6RTKWL2dNnEia9FWRLzVxtDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;添加显示行&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还可以定义一个 &lt;code&gt;total&lt;/code&gt; 参数来表示监控的主机总数，不过需要注意的是这里的参数我们不需要展示，需要选择隐藏方式为 &lt;code&gt;Variable&lt;/code&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012746&quot; data-ratio=&quot;0.5441412520064205&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6CtLONic9VDV5HzG58fCLVJFpdIysv3K8fmg7J01bU8OibiaI7aol0WDF8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2492&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再单独定义一个显示主机名的变量，这里我们使用的查询语句为 &lt;code&gt;node_uname_info{instance=~&quot;$host&quot;}&lt;/code&gt;，需要注意的是这里关联的是前面定义的 &lt;code&gt;$host&lt;/code&gt; 这个变量：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012750&quot; data-ratio=&quot;0.5187296416938111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6CwxgMpb28K4Jz6QsFnEXznHgFE529CAV7zicxROetMgNepNdTnia3qJdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2456&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们可以添加两个空的 &lt;code&gt;Row&lt;/code&gt; 行：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012749&quot; data-ratio=&quot;0.5151898734177215&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6C3U8WfjJkqibl28RJqWjRdyqJTEMKmOJDUgWxjBXxnTcqEMlhjCjvnIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1580&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把我们的面板放到不同的行中去，并为每一行定义显示标题，标题里面就可以使用前面定义的变量：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100012748&quot; data-ratio=&quot;0.5737704918032787&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6CddAvwmibF7ibpKHaOicbllv5upqloAY6gUHJTV2qtJd6cebLasRIpwE1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里我们的节点监控的完整效果如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100012751&quot; data-ratio=&quot;0.5418295543393276&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytske10LJuQSPIoy5Yu8Q6C2SYc1nPPOG3ia40jlEZmlkTCtbRpfoiaSo2n1Dps2ibzjeQZmxZfiaOPKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2558&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4MjQ0MTU4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtTw2oONBkwaiaM9hBxUj6yRLDEw8rSSxR8wWZFLjjXWpmGq5LNDlEAn4v9lSALDiaGfC4MyPZwL95g/0?wx_fmt=png&quot; data-nickname=&quot;k8s技术圈&quot; data-alias=&quot;kube100&quot; data-signature=&quot;专注容器、专注 kubernetes 技术......&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ee902199244f932a50844522590ee84</guid>
<title>尤雨溪推荐神器 ni ，能替代 npm/yarn/pnpm ？简单好用</title>
<link>https://toutiao.io/k/1whgw03</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 前言&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大家好，我是&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650756550&amp;amp;idx=1&amp;amp;sn=9acc5e30325963e455f53ec2f64c1fdd&amp;amp;chksm=8866564abf11df5c41307dba3eb84e8e14de900e1b3500aaebe802aff05b0ba2c24e4690516b&amp;amp;token=917686367&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;若川&lt;/a&gt;。最近组织了&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650756550&amp;amp;idx=1&amp;amp;sn=9acc5e30325963e455f53ec2f64c1fdd&amp;amp;chksm=8866564abf11df5c41307dba3eb84e8e14de900e1b3500aaebe802aff05b0ba2c24e4690516b&amp;amp;token=917686367&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;源码共读活动&lt;/strong&gt;&lt;/a&gt;，感兴趣的可以加我微信 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650756550&amp;amp;idx=1&amp;amp;sn=9acc5e30325963e455f53ec2f64c1fdd&amp;amp;chksm=8866564abf11df5c41307dba3eb84e8e14de900e1b3500aaebe802aff05b0ba2c24e4690516b&amp;amp;token=917686367&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;ruochuan12&lt;/a&gt; 参与，已进行两个多月，大家一起交流学习，共同进步。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想学源码，极力推荐之前我写的&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA5MjQwMzQyNw==&amp;amp;action=getalbum&amp;amp;album_id=1342211915371675650&amp;amp;scene=173&amp;amp;from_msgid=2650746362&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《学习源码整体架构系列》&lt;/a&gt; 包含&lt;code&gt;jQuery&lt;/code&gt;、&lt;code&gt;underscore&lt;/code&gt;、&lt;code&gt;lodash&lt;/code&gt;、&lt;code&gt;vuex&lt;/code&gt;、&lt;code&gt;sentry&lt;/code&gt;、&lt;code&gt;axios&lt;/code&gt;、&lt;code&gt;redux&lt;/code&gt;、&lt;code&gt;koa&lt;/code&gt;、&lt;code&gt;vue-devtools&lt;/code&gt;、&lt;code&gt;vuex4&lt;/code&gt;、&lt;code&gt;koa-compose&lt;/code&gt;、&lt;code&gt;vue-next-release&lt;/code&gt;、&lt;code&gt;vue-this&lt;/code&gt;、&lt;code&gt;create-vue&lt;/code&gt;等十余篇源码文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文仓库 ni-analysis，求个star^_^&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近组织了&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA5MjQwMzQyNw==&amp;amp;action=getalbum&amp;amp;album_id=1342211915371675650&amp;amp;scene=173&amp;amp;from_msgid=2650746362&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;源码共读活动&lt;/a&gt;，大家一起学习源码。于是搜寻各种值得我们学习，且代码行数不多的源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前写了 &lt;code&gt;Vue3&lt;/code&gt; 相关的两篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章里都是写的使用 &lt;code&gt;yarn&lt;/code&gt; 。参加源码共读的小伙伴按照我的文章，却拉取的最新仓库代码，发现 &lt;code&gt;yarn install&lt;/code&gt; 安装不了依赖，向我反馈报错。于是我去 &lt;code&gt;github仓库&lt;/code&gt; 一看，发现尤雨溪把 &lt;code&gt;Vue3仓库&lt;/code&gt; 从 &lt;code&gt;yarn&lt;/code&gt; 换成了 &lt;span&gt;`pnpm`&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;。&lt;span&gt;贡献文档&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;中有一句话。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;We also recommend installing &lt;span&gt;ni&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; to help switching between repos using different package managers. &lt;code&gt;ni&lt;/code&gt; also provides the handy &lt;code&gt;nr&lt;/code&gt; command which running npm scripts easier.&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我们还建议安装 &lt;span&gt;ni&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 以帮助使用不同的包管理器在 repos 之间切换。&lt;code&gt;ni&lt;/code&gt; 还提供了方便的 &lt;code&gt;nr&lt;/code&gt; 命令，可以更轻松地运行 npm 脚本。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 &lt;code&gt;ni&lt;/code&gt; 项目源码虽然是 &lt;code&gt;ts&lt;/code&gt;，没用过 &lt;code&gt;ts&lt;/code&gt; 小伙伴也是很好理解的，而且主文件其实不到 &lt;code&gt;100行&lt;/code&gt;，非常适合我们学习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阅读本文，你将学到：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1. 学会 ni 使用和理解其原理&lt;br/&gt;2. 学会调试学习源码&lt;br/&gt;3. 可以在日常工作中也使用 ni&lt;br/&gt;4. 等等&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;github 仓库 ni#how&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ni&lt;/strong&gt; 假设您使用锁文件（并且您应该）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在它运行之前，它会检测你的 &lt;code&gt;yarn.lock&lt;/code&gt; / &lt;code&gt;pnpm-lock.yaml&lt;/code&gt; / &lt;code&gt;package-lock.json&lt;/code&gt; 以了解当前的包管理器，并运行相应的命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单从这句话中可能有些不好理解，还是不知道它是个什么。我解释一下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;使用 `ni` 在项目中安装依赖时：&lt;br/&gt;   假设你的项目中有锁文件 `yarn.lock`，那么它最终会执行 `yarn install` 命令。&lt;br/&gt;   假设你的项目中有锁文件 `pnpm-lock.yaml`，那么它最终会执行 `pnpm i` 命令。&lt;br/&gt;   假设你的项目中有锁文件 `package-lock.json`，那么它最终会执行 `npm i` 命令。&lt;br/&gt;&lt;br/&gt;使用 `ni -g vue-cli` 安装全局依赖时&lt;br/&gt;    默认使用 `npm i -g vue-cli`&lt;br/&gt;&lt;br/&gt;当然不只有 `ni` 安装依赖。&lt;br/&gt;    还有 `nr` - run&lt;br/&gt;    `nx` - execute&lt;br/&gt;    `nu` - upgrade&lt;br/&gt;    `nci` - clean install&lt;br/&gt;    `nrm` - remove&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我看源码发现：&lt;code&gt;ni&lt;/code&gt;相关的命令，都可以在末尾追加&lt;code&gt;\?&lt;/code&gt;，表示只打印，不是真正执行&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以全局安装 &lt;code&gt;ni&lt;/code&gt; 后，可以尽情测试，比如 &lt;code&gt;ni \?&lt;/code&gt;，&lt;code&gt;nr dev --port=3000 \?&lt;/code&gt;，因为打印，所以可以在各种目录下执行，有助于理解 &lt;code&gt;ni&lt;/code&gt; 源码。我测试了如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;503274690&quot; data-ratio=&quot;0.5979073243647235&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Mpt86EGjlpt8e6Cm8ibWHkVY5yFFHtJdqY63v42aibMSibibld3OBPvu7Ny2f8bsQ4yUvZlCUosWiclib6iaEPVOtanxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1338&quot;/&gt;&lt;figcaption&gt;命令测试图示&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设项目目录下没有锁文件，默认就会让用户从&lt;code&gt;npm、yarn、pnpm&lt;/code&gt;选择，然后执行相应的命令。但如果在&lt;code&gt;~/.nirc&lt;/code&gt;文件中，设置了全局默认的配置，则使用默认配置执行对应命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Config&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;; ~/.nirc&lt;br/&gt;&lt;br/&gt;; fallback when no lock found&lt;br/&gt;defaultAgent=npm # default &quot;prompt&quot;&lt;br/&gt;&lt;br/&gt;; for global installs&lt;br/&gt;globalAgent=npm&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;因此，我们可以得知这个工具必然要做三件事&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1. 根据锁文件猜测用哪个包管理器 npm/yarn/pnpm &lt;br/&gt;2. 抹平不同的包管理器的命令差异&lt;br/&gt;3. 最终运行相应的脚本&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着继续看看 &lt;code&gt;README&lt;/code&gt; 其他命令的使用，就会好理解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 使用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看 &lt;span&gt;ni github文档&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;npm i in a yarn project, again? F**k!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;ni - use the right package manager&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全局安装。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm i -g @antfu/ni&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果全局安装遭遇冲突，我们可以加上 &lt;code&gt;--force&lt;/code&gt; 参数强制安装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举几个常用的例子。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.1 ni - install&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ni&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# npm install&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# yarn install&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# pnpm install&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ni axios&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# npm i axios&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# yarn add axios&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# pnpm i axios&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.2 nr - run&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;nr dev --port=3000&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# npm run dev -- --port=3000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# yarn run dev --port=3000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# pnpm run dev -- --port=3000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;nr&lt;br/&gt;&lt;span&gt;# 交互式选择命令去执行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# interactively select the script to run&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# supports https://www.npmjs.com/package/npm-scripts-info convention&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;nr -&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 重新执行最后一次执行的命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# rerun the last command&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.3 nx - execute&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;nx jest&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# npx jest&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# yarn dlx jest&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# pnpm dlx jest&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 阅读源码前的准备工作&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.1 克隆&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 推荐克隆我的仓库（我的保证对应文章版本）&lt;/span&gt;&lt;br/&gt;git &lt;span&gt;clone&lt;/span&gt; https://github.com/lxchuan12/ni-analysis.git&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; ni-analysis/ni&lt;br/&gt;&lt;span&gt;# npm i -g pnpm&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 安装依赖&lt;/span&gt;&lt;br/&gt;pnpm i&lt;br/&gt;&lt;span&gt;# 当然也可以直接用 ni&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 或者克隆官方仓库&lt;/span&gt;&lt;br/&gt;git &lt;span&gt;clone&lt;/span&gt; https://github.com/vuejs/ni.git&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; ni&lt;br/&gt;&lt;span&gt;# npm i -g pnpm&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 安装依赖&lt;/span&gt;&lt;br/&gt;pnpm i&lt;br/&gt;&lt;span&gt;# 当然也可以直接用 ni&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，看一个开源项目，先从 package.json 文件开始看起。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.2 package.json 文件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;@antfu/ni&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;version&quot;&lt;/span&gt;: &lt;span&gt;&quot;0.10.0&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;description&quot;&lt;/span&gt;: &lt;span&gt;&quot;Use the right package manager&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 暴露了六个命令&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;bin&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;ni&quot;&lt;/span&gt;: &lt;span&gt;&quot;bin/ni.js&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;nci&quot;&lt;/span&gt;: &lt;span&gt;&quot;bin/nci.js&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;nr&quot;&lt;/span&gt;: &lt;span&gt;&quot;bin/nr.js&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;nu&quot;&lt;/span&gt;: &lt;span&gt;&quot;bin/nu.js&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;nx&quot;&lt;/span&gt;: &lt;span&gt;&quot;bin/nx.js&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;nrm&quot;&lt;/span&gt;: &lt;span&gt;&quot;bin/nrm.js&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;scripts&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;// 省略了其他的命令 用 esno 执行 ts 文件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 可以加上 ? 便于调试，也可以不加&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 或者是终端 npm run dev \?&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;dev&quot;&lt;/span&gt;: &lt;span&gt;&quot;esno src/ni.ts ?&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 &lt;code&gt;dev&lt;/code&gt; 命令，我们找到主入口文件 &lt;code&gt;src/ni.ts&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.3 从源码主入口开始调试&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ni/src/ni.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { parseNi } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./commands&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { runCli } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./runner&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 我们可以在这里断点&lt;/span&gt;&lt;br/&gt;runCli(parseNi)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找到 &lt;code&gt;ni/package.json&lt;/code&gt; 的 &lt;code&gt;scripts&lt;/code&gt;，把鼠标移动到 &lt;code&gt;dev&lt;/code&gt; 命令上，会出现&lt;code&gt;运行脚本&lt;/code&gt;和&lt;code&gt;调试脚本&lt;/code&gt;命令。如下图所示，选择调试脚本。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;503274692&quot; data-ratio=&quot;0.5432291666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Mpt86EGjlpt8e6Cm8ibWHkVY5yFFHtJdqibPPWlkvExibVt1sLnz52j5kCUibTzP94ADJnQruDfguibWhPI4jcgNRLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;VSCode 调试&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;503274691&quot; data-ratio=&quot;0.5331040412725709&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Mpt86EGjlpt8e6Cm8ibWHkVY5yFFHtJdq8sK0nibYB3dib6B76Y7JL54azBuFQKt9qLgo7eKU6ibAZo7SpCic1SXzTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2326&quot;/&gt;&lt;figcaption&gt;VSCode 调试 Node.js 说明&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 主流程 runner - runCli 函数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个函数就是对终端传入的命令行参数做一次解析。最终还是执行的 &lt;code&gt;run&lt;/code&gt; 函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 &lt;code&gt;process&lt;/code&gt; 不了解的读者，可以看&lt;span&gt;阮一峰老师写的 process 对象&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ni/src/runner.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;runCli&lt;/span&gt;(&lt;span&gt;fn: Runner, options: DetectOptions = {}&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// process.argv：返回一个数组，成员是当前进程的所有命令行参数。&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 其中 process.argv 的第一和第二个元素是Node可执行文件和被执行JavaScript文件的完全限定的文件系统路径，无论你是否这样输入他们。&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; args = process.argv.slice(&lt;span&gt;2&lt;/span&gt;).filter(&lt;span&gt;Boolean&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; run(fn, args, options)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;catch&lt;/span&gt; (error) {&lt;br/&gt;    &lt;span&gt;// process.exit方法用来退出当前进程。它可以接受一个数值参数，如果参数大于0，表示执行失败；如果等于0表示执行成功。&lt;/span&gt;&lt;br/&gt;    process.exit(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们接着来看，&lt;code&gt;run&lt;/code&gt; 函数。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 主流程 runner - run 主函数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这个函数主要做了三件事&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1. 根据锁文件猜测用哪个包管理器 npm/yarn/pnpm - detect 函数&lt;br/&gt;2. 抹平不同的包管理器的命令差异 - parseNi 函数&lt;br/&gt;3. 最终运行相应的脚本 - execa 工具&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ni/src/runner.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 源码有删减&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; execa &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;execa&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; DEBUG_SIGN = &lt;span&gt;&#x27;?&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;(&lt;span&gt;fn: Runner, args: &lt;span&gt;string&lt;/span&gt;[], options: DetectOptions = {}&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 命令参数包含 问号? 则是调试模式，不执行脚本&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; debug = args.includes(DEBUG_SIGN)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (debug)&lt;br/&gt;    &lt;span&gt;// 调试模式下，删除这个问号&lt;/span&gt;&lt;br/&gt;    remove(args, DEBUG_SIGN)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// cwd 方法返回进程的当前目录（绝对路径）&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; cwd = process.cwd()&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; command&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 支持指定 文件目录&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// ni -C packages/foo vite&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// nr -C playground dev&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (args[&lt;span&gt;0&lt;/span&gt;] === &lt;span&gt;&#x27;-C&#x27;&lt;/span&gt;) {&lt;br/&gt;    cwd = resolve(cwd, args[&lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;    &lt;span&gt;// 删掉这两个参数 -C packages/foo&lt;/span&gt;&lt;br/&gt;    args.splice(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 如果是全局安装，那么实用全局的包管理器&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; isGlobal = args.includes(&lt;span&gt;&#x27;-g&#x27;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (isGlobal) {&lt;br/&gt;    command = &lt;span&gt;await&lt;/span&gt; fn(getGlobalAgent(), args)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; agent = &lt;span&gt;await&lt;/span&gt; detect({ ...options, cwd }) || getDefaultAgent()&lt;br/&gt;    &lt;span&gt;// 猜测使用哪个包管理器，如果没有发现锁文件，会返回 null，则调用 getDefaultAgent 函数，默认返回是让用户选择 prompt&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (agent === &lt;span&gt;&#x27;prompt&#x27;&lt;/span&gt;) {&lt;br/&gt;      agent = (&lt;span&gt;await&lt;/span&gt; prompts({&lt;br/&gt;        name: &lt;span&gt;&#x27;agent&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;select&#x27;&lt;/span&gt;,&lt;br/&gt;        message: &lt;span&gt;&#x27;Choose the agent&#x27;&lt;/span&gt;,&lt;br/&gt;        choices: agents.map(&lt;span&gt;&lt;span&gt;value&lt;/span&gt; =&amp;gt;&lt;/span&gt; ({ title: value, value })),&lt;br/&gt;      })).agent&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!agent)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 这里的 fn 是 传入解析代码的函数&lt;/span&gt;&lt;br/&gt;    command = &lt;span&gt;await&lt;/span&gt; fn(agent &lt;span&gt;as&lt;/span&gt; Agent, args, {&lt;br/&gt;      hasLock: &lt;span&gt;Boolean&lt;/span&gt;(agent),&lt;br/&gt;      cwd,&lt;br/&gt;    })&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 如果没有命令，直接返回，上一个 runCli 函数报错，退出进程&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!command)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 如果是调试模式，那么直接打印出命令。调试非常有用。&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (debug) {&lt;br/&gt;    &lt;span&gt;// eslint-disable-next-line no-console&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(command)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 最终用 execa 执行命令，比如 npm i&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// https://github.com/sindresorhus/execa&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 介绍：Process execution for humans&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; execa.command(command, { stdio: &lt;span&gt;&#x27;inherit&#x27;&lt;/span&gt;, encoding: &lt;span&gt;&#x27;utf-8&#x27;&lt;/span&gt;, cwd })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们学习完主流程，接着来看两个重要的函数：&lt;code&gt;detect&lt;/code&gt; 函数、&lt;code&gt;parseNi&lt;/code&gt; 函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据入口我们可以知道。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;runCli(parseNi)&lt;br/&gt;&lt;br/&gt;run(fn)&lt;br/&gt;&lt;br/&gt;这里 fn 则是 parseNi&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.1 根据锁文件猜测用哪个包管理器（npm/yarn/pnpm） - detect 函数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码相对不多，我就全部放出来了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;主要就做了三件事情&lt;br/&gt;&lt;br/&gt;1. 找到项目根路径下的锁文件。返回对应的包管理器 `npm/yarn/pnpm`。&lt;br/&gt;2. 如果没找到，那就返回 `null`。&lt;br/&gt;3. 如果找到了，但是用户电脑没有这个命令，则询问用户是否自动安装。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ni/src/agents.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; LOCKS: Record&amp;lt;string, Agent&amp;gt; = {&lt;br/&gt;  &lt;span&gt;&#x27;pnpm-lock.yaml&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;pnpm&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&#x27;yarn.lock&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;yarn&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&#x27;package-lock.json&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;npm&#x27;&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ni/src/detect.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;detect&lt;/span&gt;(&lt;span&gt;{ autoInstall, cwd }: DetectOptions&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; findUp(&lt;span&gt;Object&lt;/span&gt;.keys(LOCKS), { cwd })&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; agent = (result ? LOCKS[path.basename(result)] : &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (agent &amp;amp;&amp;amp; !cmdExists(agent)) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!autoInstall) {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.warn(&lt;span&gt;`Detected &lt;span&gt;${agent}&lt;/span&gt; but it doesn&#x27;t seem to be installed.\n`&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (process.env.CI)&lt;br/&gt;        process.exit(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; link = terminalLink(agent, INSTALL_PAGE[agent])&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; { tryInstall } = &lt;span&gt;await&lt;/span&gt; prompts({&lt;br/&gt;        name: &lt;span&gt;&#x27;tryInstall&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;confirm&#x27;&lt;/span&gt;,&lt;br/&gt;        message: &lt;span&gt;`Would you like to globally install &lt;span&gt;${link}&lt;/span&gt;?`&lt;/span&gt;,&lt;br/&gt;      })&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!tryInstall)&lt;br/&gt;        process.exit(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; execa.command(&lt;span&gt;`npm i -g &lt;span&gt;${agent}&lt;/span&gt;`&lt;/span&gt;, { stdio: &lt;span&gt;&#x27;inherit&#x27;&lt;/span&gt;, cwd })&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; agent&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们来看 &lt;code&gt;parseNi&lt;/code&gt; 函数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.2 抹平不同的包管理器的命令差异 - parseNi 函数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ni/src/commands.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; parseNi = &amp;lt;Runner&amp;gt;&lt;span&gt;(&lt;span&gt;(&lt;span&gt;agent, args, ctx&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;// ni -v 输出版本号&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;args.length === 1 &amp;amp;&amp;amp; args[0] === &#x27;-v&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// eslint-disable-next-line no-console&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`@antfu/ni v${version}`&lt;/span&gt;)&lt;br/&gt;    process.exit(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;args.length === 0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; getCommand(&lt;span&gt;agent, &#x27;install&#x27;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;// 省略一些代码&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 &lt;code&gt;getCommand&lt;/code&gt; 获取命令。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ni/src/agents.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 有删减&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 一份配置，写个这三种包管理器中的命令。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; AGENTS = {&lt;br/&gt;  npm: {&lt;br/&gt;    &lt;span&gt;&#x27;install&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;npm i&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  yarn: {&lt;br/&gt;    &lt;span&gt;&#x27;install&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;yarn install&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  pnpm: {&lt;br/&gt;    &lt;span&gt;&#x27;install&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;pnpm i&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ni/src/commands.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getCommand&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;  agent: Agent,&lt;br/&gt;  command: Command,&lt;br/&gt;  args: &lt;span&gt;string&lt;/span&gt;[] = [],&lt;br/&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 包管理器不在 AGENTS 中则报错&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 比如 npm 不在&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!(agent &lt;span&gt;in&lt;/span&gt; AGENTS))&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;`Unsupported agent &quot;&lt;span&gt;${agent}&lt;/span&gt;&quot;`&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 获取命令 安装则对应 npm install&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; c = AGENTS[agent][command]&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 如果是函数，则执行函数。&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; c === &lt;span&gt;&#x27;function&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; c(args)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 命令 没找到，则报错&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!c)&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;`Command &quot;&lt;span&gt;${command}&lt;/span&gt;&quot; is not support by agent &quot;&lt;span&gt;${agent}&lt;/span&gt;&quot;`&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;// 最终拼接成命令字符串&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; c.replace(&lt;span&gt;&#x27;{0}&#x27;&lt;/span&gt;, args.join(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;)).trim()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.3 最终运行相应的脚本&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;得到相应的命令，比如是 &lt;code&gt;npm i&lt;/code&gt;，最终用这个工具 &lt;span&gt;execa&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt; 执行最终得到的相应的脚本。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;await&lt;/span&gt; execa.command(command, { stdio: &lt;span&gt;&#x27;inherit&#x27;&lt;/span&gt;, encoding: &lt;span&gt;&#x27;utf-8&#x27;&lt;/span&gt;, cwd })&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我们看完源码，可以知道这个神器 &lt;code&gt;ni&lt;/code&gt; 主要做了三件事&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1. 根据锁文件猜测用哪个包管理器 npm/yarn/pnpm - detect 函数&lt;br/&gt;2. 抹平不同的包管理器的命令差异 - parseNi 函数&lt;br/&gt;3. 最终运行相应的脚本 - execa 工具&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们日常开发中，可能容易 &lt;code&gt;npm&lt;/code&gt;、&lt;code&gt;yarn&lt;/code&gt;、&lt;code&gt;pnpm&lt;/code&gt; 混用。有了 &lt;code&gt;ni&lt;/code&gt; 后，可以用于日常开发使用。&lt;code&gt;Vue&lt;/code&gt; 核心成员 &lt;span&gt;Anthony Fu&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt; 发现问题，最终开发了一个工具 &lt;span&gt;ni&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt; 解决问题。而这种发现问题、解决问题的能力正是我们前端开发工程师所需要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，我发现 &lt;code&gt;Vue&lt;/code&gt; 生态很多基本都切换成了使用 &lt;span&gt;pnpm&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为文章不宜过长，所以未全面展开讲述源码中所有细节。非常建议读者朋友按照文中方法使用&lt;code&gt;VSCode&lt;/code&gt;调试 &lt;code&gt;ni&lt;/code&gt; 源码。&lt;strong&gt;学会调试源码后，源码并没有想象中的那么难&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后可以持续关注我@若川。欢迎加我微信 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650756550&amp;amp;idx=1&amp;amp;sn=9acc5e30325963e455f53ec2f64c1fdd&amp;amp;chksm=8866564abf11df5c41307dba3eb84e8e14de900e1b3500aaebe802aff05b0ba2c24e4690516b&amp;amp;token=917686367&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;ruochuan12&lt;/a&gt; 交流，参与 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650756550&amp;amp;idx=1&amp;amp;sn=9acc5e30325963e455f53ec2f64c1fdd&amp;amp;chksm=8866564abf11df5c41307dba3eb84e8e14de900e1b3500aaebe802aff05b0ba2c24e4690516b&amp;amp;token=917686367&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;源码共读&lt;/a&gt; 活动，大家一起学习源码，共同进步。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;本文仓库 ni-analysis，求个star^_^: &lt;span&gt;https://github.com/lxchuan12/ni-analysis.git&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;&lt;code&gt;pnpm&lt;/code&gt;: &lt;span&gt;https://github.com/vuejs/vue-next/pull/4766/files&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;贡献文档: &lt;span&gt;https://github.com/vuejs/vue-next/blob/master/.github/contributing.md#development-setup&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;ni: &lt;span&gt;https://github.com/antfu/ni&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;ni: &lt;span&gt;https://github.com/antfu/ni&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;github 仓库 ni#how: &lt;span&gt;https://github.com/antfu/ni#how&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;ni github文档: &lt;span&gt;https://github.com/antfu/ni&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;阮一峰老师写的 process 对象: &lt;span&gt;http://javascript.ruanyifeng.com/nodejs/process.html&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;execa: &lt;span&gt;https://github.com/sindresorhus/execa&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;Anthony Fu: &lt;span&gt;https://antfu.me&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;ni: &lt;span&gt;https://github.com/antfu/ni&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;pnpm: &lt;span&gt;https://pnpm.io&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f537bd0981d4ecd42d43c880f199c88f</guid>
<title>性能优化：高效内存池的设计与实现</title>
<link>https://toutiao.io/k/9vo0ly6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzk0MzI4OTI1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHhKgtwWvzaYZodgfpphdA6WWKEMXTn6ImCCCuEzlPKicNBcpzBUyjK1XicWwqIwusqLGpwyyOc87JPQ/0?wx_fmt=png&quot; data-nickname=&quot;高性能架构探索&quot; data-alias=&quot;gaoxingnengjiagouts&quot; data-signature=&quot;85后程序员，现任某互联网公司高级技术专家一职。分享一些工作中的心得，杂谈。聊聊架构，扯扯算法，就酱。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;对本文有疑问的，可以&lt;span&gt;公众号留言、私信，&lt;/span&gt;&lt;span&gt;也可以&lt;/span&gt;&lt;span&gt;加笔者微信直接交流(文末留有微信二维码)&lt;/span&gt;；另外还有&lt;span&gt;批量免费计算机电子书，后台回复[&lt;/span&gt;&lt;span&gt;pdf&lt;/span&gt;&lt;span&gt;]免费获取&lt;/span&gt;。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是雨乐！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;amp;mid=2247485953&amp;amp;idx=1&amp;amp;sn=f8cd484607ab07f15247ecde773d2e1c&amp;amp;chksm=c3376cc6f440e5d047f7e648c951fd583df82ab4e3dab5767baeddef9fe7c1270f05b039d8c4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;之前的文章&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;之前的文章&lt;/a&gt;中，我们分析了glibc内存管理相关的内容，里面的是不是逻辑复杂😁，毕竟咱们用几十行代码完成的功能，glibc要用上百乃至上千行代码来实现，毕竟它的受众太多了，需要考虑跨平台，各种边界条件等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，glibc的内存分配库ptmalloc也可以看做是一个内存池，出于性能考虑，每次内存申请都是先从ptmalloc中进行分配，如果没有合适的则通过系统分配函数进行申请；在释放的时候，也是将被释放内存先方式内存池中，内存池根据一定的策略，来决定是否进行shrink以归还OS。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，现一个内存池？我们该怎么实现呢？今天，借助这篇文章，我们一起来设计和实现一个内存池(文末附有github地址)。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;背景&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先需要说明的是，该内存池是笔者在10年前完成的，下面先说下当时此项目的背景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;09年，在某所的时候，参与了某个国家级项目，该项目是防DDOS攻击相关，因此更多的是跟IP相关，所以每次分配和释放内存都是固定大小，经过测试，性能不是很满意，所以，经过代码分析以及性能攻击分析，发现里面有大量的malloc/free，所以，当时就决定是否从malloc/free入手，能否优化整个项目的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，决定实现一个Memory Pool，在做了调研以及研究了相关论文后，决定实现一个内存池，先试试水，所幸运的是，性能确实比glibc自带的malloc/free要高，所以也就应用于项目上了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;本文所讲的Memory Pool为C语言实现，旨在让大家都能看懂，看明白(至少能够完全理解本文所讲的Memory Pool的实现原理)。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;概念&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们介绍下什么是内存池？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;预先在内存中申请一定数量的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存返回，在释放的时候，将内存返回给内存池而不是OS，在下次申请的时候，重新进行分配&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么为什么要有内存池呢？这就需要从传统内存分配的特点来进行分析，传统内存分配释放的优点无非就是 &lt;span&gt;通用性强，应用广泛&lt;/span&gt;，但是传统的内存分配、释放在某些特定的项目中，其不一定是最优、效率最高的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统内存分配、释放的缺点总结如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、调用malloc/new,系统需要根据“最先匹配”、“最优匹配”或其他算法在内存空闲块表中查找一块空闲内存，调用free/delete,系统可能需要合并空闲内存块，这些会产生额外开销&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、频繁的在堆上申请和释放内存必然需要大量时间，降低了程序的运行效率。对于一个需要频繁申请和释放内存的程序来说，频繁调用new/malloc申请内存，delete/free释放内存都需要花费系统时间，频繁的调用必然会降低程序的运行效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、经常申请小块内存，会将物理内存“切”得很碎，导致内存碎片。申请内存的顺序并不是释放内存的顺序，因此频繁申请小块内存必然会导致内存碎片，造成“有内存但是申请不到大块内存”的现象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8096385542168675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8JO8D05L4aeYlws7HC3OMGpm8huUQ0eXc6acbTufVythia0GgnLSuTy5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;内存分配&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图中，可以看出，应用程序会调用glibc运行时库的malloc函数进行内存申请，而malloc函数则会根据具体申请的内存块大小，根据实际情况最终从sys_brk或者sys_mmap_pgoff系统调用申请内存，而大家都知道，跟os打交道，_性能损失_是毋庸置疑的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，glibc作为通用的运行时库，malloc/free需要满足各种场景需求，比如申请的字节大小不一，多线程访问等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5079006772009029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8J3ak8tA0ekibT7PGELibVGEcCdMcr6e5hzatx8bsLUBAgI4Gia9cFB4xfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;886&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有比传统malloc/free性能更优的方案呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是：有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在程序启动的时候，我们预分配特定数量的固定大小的块，这样每次申请的时候，就从预分配的块中获取，释放的时候，将其放入预分配块中以备下次复用，这就是所谓的_内存池技术_，每个内存池对应特定场景，这样的话，较传统的传统的malloc/free少了很多复杂逻辑，性能显然会提升不少。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49324324324324326&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8JJFQ75CllZgucDqqCBwPtiaDDMNxS3DRMLH8SP7KG7Cyw1Hy5jchoTFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合传统malloc/free的缺点，我们总结下使用内存池方案的优点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、比malloc/free进行内存申请/释放的方式快&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、不会产生或很少产生堆碎片&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、可避免内存泄漏&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分类&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据分配出去的字节大小是否固定，分为 &lt;span&gt;固定大小内存池&lt;/span&gt; 和 &lt;span&gt;可变大小内存池&lt;/span&gt; 两类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而可变大小内存池，可分配任意大小的内存池，比如ptmalloc、jemalloc以及google的tcmalloc。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3956386292834891&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8JMgOiaOiaRKZISI0N96TUKicbH2yCNdpH0mMdKA4foLjibQZRK1gynmvFmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;642&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;固定大小内存池，顾名思义，每次申请和释放的内存大小都是固定的。每次分配出去的内存块大小都是程序预先定义的值，而在释放内存块时候，则简单的挂回内存池链表即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5538057742782152&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8JWVUKWDf7b1SYwg2ibAZaGGcf0GzXPDFO9ibt540toKmTFsAtydh8lZVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;762&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;本文主要讲的是固定大小的内存池。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;原理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存池，重点在”池“字上，之所以称之为内存池，是在真正使用之前，先预分配一定数量、大小预设的块，如果有新的内存需求时候，就从内存池中根据申请的内存大小，分配一个内存块，若当前内存块已经被完全分配出去，则继续申请一大块，然后进行分配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当进行内存块释放的时候，则将其归还内存池，后面如果再有申请的话，则将其重新分配出去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5896805896805897&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8JMuGPfRHkzR8jbnJzPria73NIxyWo0qNKS7LmfNTY0m1qBQtkyOhmHpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;内存池结构图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图是本文所要设计的结构图，下面在具体的设计之前，我们先讲下本内存池的原理：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建并初始化头结点MemoryPool&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过MemoryPool进行内存分配，如果发现MemoryPool所指向的第一块MemoryBlock或者现有MemoryPool没有空闲内存块，则创建一个新的MemoryBlock初始化之后将其插入MemoryPool的头&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在内存分配的时候，遍历MemoryPool中的单链表MemoryBlock，根据地址判断所要释放的内存属于哪个MemoryBlock，然后根据偏移设置MemoryBlock的第一块空闲块索引，同时将空闲块个数+1&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述只是一个简单的逻辑讲解，比较宏观，下面我们将通过图解和代码的方式来进行讲解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，我们画出了内存池的结构图，从图中，可以看出，有两个结构变量，分别为MemoryPool和MemoryBlock。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们将从数据结构和接口两个部分出发，详细讲解内存池的设计。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;数据结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;MemoryBlock&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文中所讲述的内存块的分配和释放都是通过该结构进行操作，下面是MemoryBlock的示例图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22093023255813954&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8JtBWdSEkef8bwNjV4Is4jDB1pBNj7N4LeJ5jicbyIYiaiahntlVAVKGuzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;860&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;MemoryBlock&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，Header存储该MemoryBlock的内存块情况，比如可用的内存块索引、当前MemoryBlock中可用内存块的个数等等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.522875816993464&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8JHl30oOKXEKypXFkv58abzvvbOJiaNywkenAPcIIOoCdTQqfhfXJlGhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;306&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;MemoryBlock&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; free_size;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; first_free;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;MemoryBlock&lt;/span&gt; *&lt;span&gt;next&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;char&lt;/span&gt; a_data[&lt;span&gt;0&lt;/span&gt;]; &lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;size为MemoryBlock下内存块的个数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;free_size为MemoryBlock下空闲内存块的个数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;first_free为MemoryBlock中第一个空闲块的索引&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;next指向下一个MemoryBlock&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;a_data是一个柔性数组&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;柔性数组即数组大小待定的数组， C语言中结构体的最后一个元素可以是大小未知的数组，也就是所谓的0长度，所以我们可以用结构体来创建柔性数组。&lt;/p&gt;&lt;p&gt;它的主要用途是为了满足需要变长度的结构体，为了解决使用数组时内存的冗余和数组的越界问题。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;MemoryPool&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MemoryPool为内存池的头，里面定义了该内存池的信息，比如本内存池分配的固定对象的大小，第一个MemoryBlock等&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.24&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8Jxl23r3y9o1XRCJnNILsWDnnQvEQKG7fxhoNWlcZ32le0SUoDNLNaAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;struct MemoryPool {&lt;br/&gt; unsigned int obj_size;&lt;br/&gt; unsigned int init_size;&lt;br/&gt; unsigned int grow_size;&lt;br/&gt;&lt;br/&gt; MemoryBlock *first_block;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;obj_size为内存池分配的固定内存块的大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;init_size初始化内存池时候创建的内存块的个数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;grow_size当初始化内存块使用完后，再次申请内存块时候的个数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;first_block指向第一个MemoryBlock&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;memory_pool_create&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;MemoryPool *&lt;span&gt;memory_pool_create&lt;/span&gt;&lt;span&gt;(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; init_size, &lt;br/&gt;                               &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; grow_size, &lt;br/&gt;                               &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本函数用来创建一个MemoryPool，并对其进行初始化，下面是参数说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;init_size 表示第一个MemoryBlock中创建块的个数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;grow_size 表示当MemoryPool中没有空闲块可用，则创建一个新的MemoryBlock时其块的个数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;size 为块的大小(即每次分配相同大小的固定size)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;memory_alloc&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;memory_alloc&lt;/span&gt;&lt;span&gt;(MemoryPool *mp)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本函数用了从mp中申请一块内存返回&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mp 为MemoryPool类型指针，即内存池的头&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果内存分配失败，则返回NULL&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;memory_free&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt;* &lt;span&gt;memory_free&lt;/span&gt;&lt;span&gt;(MemoryPool *mp, &lt;span&gt;void&lt;/span&gt; *pfree)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本函数用来释放内存&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mp 为MemoryPool类型指针，即内存池的头&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pfree 为要释放的内存&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;free_memory_pool&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;free_memory_pool&lt;/span&gt;&lt;span&gt;(MemoryPool *mp)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本函数用来释放内存池&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在讲解整个实现之前，我们先看先内存池的详细结构图。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3894736842105263&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8JqTSxIEwSOkPIdwZJ3KrnEN2RibV5GqZVjic5RAEHQiciaxxxCOPA8qs8Yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;初始化内存池&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MemoryPool是整个内存池的入口结构，该函数主要是用来创建MemoryPool对象，并使用参数对其内部的成员变量进行初始化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数定义如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;MemoryPool *&lt;span&gt;memory_pool_create&lt;/span&gt;&lt;span&gt;(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; init_size, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; grow_size, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; MemoryPool *mp;&lt;br/&gt; mp = (MemoryPool*)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(MemoryPool));&lt;br/&gt; mp-&amp;gt;first_block = &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt; mp-&amp;gt;init_size = init_size;&lt;br/&gt; mp-&amp;gt;grow_size = grow_size;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt;(size &amp;lt; &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;))&lt;br/&gt;  mp-&amp;gt;obj_size = &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;);&lt;br/&gt; mp-&amp;gt;obj_size = (size + (MEMPOOL_ALIGNMENT&lt;span&gt;-1&lt;/span&gt;)) &amp;amp; ~(MEMPOOL_ALIGNMENT&lt;span&gt;-1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; mp;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;内存分配&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;memory_alloc&lt;/span&gt;&lt;span&gt;(MemoryPool *mp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; length;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt;(mp-&amp;gt;first_block == &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;  MemoryBlock *mb;&lt;br/&gt;  length = (mp-&amp;gt;init_size)*(mp-&amp;gt;obj_size) + &lt;span&gt;sizeof&lt;/span&gt;(MemoryBlock);&lt;br/&gt;  mb = &lt;span&gt;malloc&lt;/span&gt;(length);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(mb == &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;   perror(&lt;span&gt;&quot;memory allocate failed!\n&quot;&lt;/span&gt;);&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/* init the first block */&lt;/span&gt;&lt;br/&gt;  mb-&amp;gt;next = &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;  mb-&amp;gt;free_size = mp-&amp;gt;init_size - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  mb-&amp;gt;first_free = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  mb-&amp;gt;size = mp-&amp;gt;init_size*mp-&amp;gt;obj_size;&lt;br/&gt;&lt;br/&gt;  mp-&amp;gt;first_block = mb;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;char&lt;/span&gt; *data = mb-&amp;gt;a_data;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/* set the mark */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;; i&amp;lt;mp-&amp;gt;init_size; ++i) {&lt;br/&gt;   *(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; *)data = i;&lt;br/&gt;   data += mp-&amp;gt;obj_size;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;void&lt;/span&gt; *)mb-&amp;gt;a_data;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; MemoryBlock *pm_block = mp-&amp;gt;first_block;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;while&lt;/span&gt;((pm_block != &lt;span&gt;NULL&lt;/span&gt;) &amp;amp;&amp;amp; (pm_block-&amp;gt;free_size == &lt;span&gt;0&lt;/span&gt;)) {&lt;br/&gt;  pm_block = pm_block-&amp;gt;next;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt;(pm_block != &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;char&lt;/span&gt; *pfree = pm_block-&amp;gt;a_data + pm_block-&amp;gt;first_free * mp-&amp;gt;obj_size;&lt;br/&gt;&lt;br/&gt;  pm_block-&amp;gt;first_free = *((&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; *)pfree);&lt;br/&gt;  pm_block-&amp;gt;free_size--;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;void&lt;/span&gt; *)pfree;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(mp-&amp;gt;grow_size == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;  &lt;br/&gt;    MemoryBlock *new_block = (MemoryBlock *)&lt;span&gt;malloc&lt;/span&gt;((mp-&amp;gt;grow_size)*(mp-&amp;gt;obj_size) + &lt;span&gt;sizeof&lt;/span&gt;(MemoryBlock));&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(new_block == &lt;span&gt;NULL&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;char&lt;/span&gt; *data = new_block-&amp;gt;a_data;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;; i&amp;lt;mp-&amp;gt;grow_size; ++i) {&lt;br/&gt;   *(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; *)data = i;&lt;br/&gt;   data += mp-&amp;gt;obj_size;&lt;br/&gt;  }  &lt;br/&gt;&lt;br/&gt;  new_block-&amp;gt;size = mp-&amp;gt;grow_size*mp-&amp;gt;obj_size;&lt;br/&gt;  new_block-&amp;gt;free_size = mp-&amp;gt;grow_size&lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;  new_block-&amp;gt;first_free = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  new_block-&amp;gt;next = mp-&amp;gt;first_block;&lt;br/&gt;  mp-&amp;gt;first_block = new_block;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;void&lt;/span&gt; *)new_block-&amp;gt;a_data;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存块主要在MemoryBlock结构中，也就是说申请的内存，都是从MemoryBlock中进行获取，流程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取MemoryPool中的first_block指针&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果该指针为空，则创建一个MemoryBlock，first_block指向新建的MemoryBlock，并返回&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;否则，从first_block进行单链表遍历，查找第一个free_size不为0的MemoryBlock，如果找到，则对该MemoryBlock的相关参数进行设置，然后返回内存块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;否则，创建一个新的MemoryBlock，进行初始化分配之后，将其插入到链表的头部(这样做的目的是为了方便下次分配效率，即减小了链表的遍历)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述代码中，需要注意的是第30-33行或者67-70行，这两行的功能一样，都是对新申请的内存块进行初始化，这几行的意思，是要将空闲块连接起来，但是，并没有使用传统意义上的链表方式，而是通过index方式进行连接，具体如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33519553072625696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8JjOS2Heu2NuS9eT9fmal7libj8V2s4nJ5jBZjW2u8p7vAwZp514OcrBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;716&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，第0块空闲块的下一个空闲块索引为1，而第1块空闲块的索引为2，依次类推，形成了如下链表方式&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存分配流程图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2387755102040816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8JZiblxR2ibQxoUwFx0hFZyiag2Ufw8ib53cXKuXvQ3JRibRCvCbW9HcAntibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;980&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;内存释放&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt;* &lt;span&gt;memory_free&lt;/span&gt;&lt;span&gt;(MemoryPool *mp, &lt;span&gt;void&lt;/span&gt; *pfree)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;if&lt;/span&gt;(mp-&amp;gt;first_block == &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt; MemoryBlock *pm_block = mp-&amp;gt;first_block;&lt;br/&gt; MemoryBlock *pm_pre_block = mp-&amp;gt;first_block;&lt;br/&gt; &lt;br/&gt; &lt;span&gt;/* research the MemoryBlock which the pfree in */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;while&lt;/span&gt;(pm_block &amp;amp;&amp;amp; ((&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)pfree &amp;lt; (&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)pm_block-&amp;gt;a_data || &lt;br/&gt;  (&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)pfree&amp;gt;((&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)pm_block-&amp;gt;a_data+pm_block-&amp;gt;size))) {&lt;br/&gt;  &lt;span&gt;//pm_pre_block = pm_block;&lt;/span&gt;&lt;br/&gt;  pm_block = pm_block-&amp;gt;next;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(pm_block == &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; pfree;&lt;br/&gt;    }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; offset = pfree -(&lt;span&gt;void&lt;/span&gt;*) pm_block-&amp;gt;a_data;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt;((offset&amp;amp;(mp-&amp;gt;obj_size &lt;span&gt;-1&lt;/span&gt;)) &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; pfree;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt; pm_block-&amp;gt;free_size++;&lt;br/&gt; *((&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *)pfree) = pm_block-&amp;gt;first_free;&lt;br/&gt;&lt;br/&gt; pm_block-&amp;gt;first_free=(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)(offset/mp-&amp;gt;obj_size);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存释放过程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;判断当前MemoryPool的first_block指针是否为空，如果为空，则返回&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;否则，遍历MemoryBlock链表，根据所释放的指针参数判断是否在某一个MemoryBlock中&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果找到，则对MemoryBlock中的各个参数进行操作，然后返回&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;否则，没有合适的MemoryBlock，则表明该被释放的指针不在内存池中，返回&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述代码中，需要注意第20-29行。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第20行，求出被释放的内存块在MemoryBlock中的偏移&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第22行，判断是否能被整除，即是否在这个内存块中，算是个double check&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第26行，将该MemoryBlock中的空闲块个数加1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第27-29行，类似于链表的插入，将新释放的内存块的索引放入链表头，而其内部的指向下一个可用内存块&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在举个例子，以便于理解，假设在一开始有5个空闲块，其中前三个空闲块都分配出去了，那么此时，空闲块链表如下:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;4-&amp;gt;5，其中first_free = 4&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在某一个时刻，第1块释放了，那么释放归还之后，如下:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;1-&amp;gt;4-&amp;gt;5，其中first_free = 1&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存释放流程图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24267782426778242&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8J4yBIuzbEK5AjAZuHJqenicOVEJrUDPG2FuBvtAvpMLLxyAvMFCJlNgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;956&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;内存释放&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;释放内存池&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;free_memory_pool&lt;/span&gt;&lt;span&gt;(MemoryPool *mp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; MemoryBlock *mb = mp-&amp;gt;first_block;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt;(mb != &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt;(mb-&amp;gt;next != &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;   s_memory_block *delete_block = mb;&lt;br/&gt;   mb = mb-&amp;gt;next;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;free&lt;/span&gt;(delete_block);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;free&lt;/span&gt;(mb);&lt;br/&gt; }&lt;br/&gt;  &lt;br/&gt; &lt;span&gt;free&lt;/span&gt;(mp);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6286594761171033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8JQJdI2lMWZJNicSsvZjSJksaKcsTL2fSQnjcHsOiaJ6IdKEMgdK0Fyv5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1298&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图是一个完整的分配和释放示意图，下面，我结合代码来分析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;(a)步，创建了一个MemoryPool结构体&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;obj_size = 4代表本内存池分配的内存块大小为4&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;init_size = 5代表创建内存池的时候，第一块MemoryBlock的空闲内存块个数为5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;grow_size = 5代表当申请内存的时候，如果没有空闲内存，则创建的新的MemoryBlock的空闲内存块个数为5&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;(b)步，分配出去一块内存&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;此时，free_size即该MemoryBlock中可用空闲块个数为4&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;first_free = 1，代表将内存块分配出去之后，下一个可用的内存块的index为1&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;(c)步，分配出去一块内存&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;此时，free_size即该MemoryBlock中可用空闲块个数为3&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;first_free = 2，代表将内存块分配出去之后，下一个可用的内存块的index为2&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;(d)步，分配出去一块内存&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;此时，free_size即该MemoryBlock中可用空闲块个数为2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;first_free = 3，代表将内存块分配出去之后，下一个可用的内存块的index为3&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;(e)步，分配出去一块内存&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;此时，free_size即该MemoryBlock中可用空闲块个数为1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;first_free = 4，代表将内存块分配出去之后，下一个可用的内存块的index为4&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;(f)步，释放第1个内存块&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将free_size进行+1操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;fire_free值为此次释放的内存块的索引，而释放的内存块的索引里面的值则为之前first_free的值(此处释放用的前差法)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;(g)步，释放第3个内存块&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将free_size进行+1操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;fire_free值为此次释放的内存块的索引，而释放的内存块的索引里面的值则为之前first_free的值(此处释放用的前差法)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;(h)步，释放第3个内存块&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将free_size进行+1操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;fire_free值为此次释放的内存块的索引，而释放的内存块的索引里面的值则为之前first_free的值(此处释放用的前差法)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;测试&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试代码如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&quot;memory_pool.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/time.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  MemoryPool *mp = memory_pool_create(&lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;timeval&lt;/span&gt; &lt;span&gt;start&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;timeval&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; t[] = {&lt;span&gt;20000&lt;/span&gt;, &lt;span&gt;40000&lt;/span&gt;, &lt;span&gt;80000&lt;/span&gt;, &lt;span&gt;100000&lt;/span&gt;, &lt;span&gt;120000&lt;/span&gt;, &lt;span&gt;140000&lt;/span&gt;, &lt;span&gt;160000&lt;/span&gt;, &lt;span&gt;180000&lt;/span&gt;, &lt;span&gt;200000&lt;/span&gt;};&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; s = &lt;span&gt;sizeof&lt;/span&gt;(t)/&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; s; ++i) {&lt;br/&gt;    gettimeofday(&amp;amp;start, &lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; t[i]; ++j) {&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;void&lt;/span&gt; *p = memory_alloc(mp);&lt;br/&gt;      memory_free(mp, p);&lt;br/&gt;     &lt;span&gt;//&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;//void *p = malloc(8);&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;//free(p);&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    gettimeofday(&amp;amp;end, &lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; cost = &lt;span&gt;1000000&lt;/span&gt; * (end.tv_sec - start.tv_sec) +&lt;br/&gt;                  end.tv_usec - start.tv_usec;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%ld\n&quot;&lt;/span&gt;,cost);&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  free_memory_pool(mp);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据对比如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5674418604651162&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHiaA3xxTGkIcH0JjQo83fJ8JNa1CjZCCP6ENL3UIk4XRSkB6F3oYMxQsVFbWZtfM9ic4mYicicpVn9icJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;860&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看出，pool的分配效率高于传统的malloc方式，性能提高接近100%&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;本测试结果仅针对当时的项目，对其他测试case不具有普遍性&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;扩展&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文章前面，我们有提过本内存池是_单线程、固定大小的_，但是往往这种还是不能满足要求，如下几个场景&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;多固定大小，指的是提前预支需要申请的内存大小&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单线程多固定大小: 针对此场景，由于已经预知了所申请的size，所以可以针对每个size创建一个内存池&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多线程固定大小：针对此场景，有以下两个方案&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用ThreadLocalCache&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个线程创建一个内存池&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用加锁，操作全局唯一内存池(每次加锁解锁耗时100ns左右)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多线程多固定大小：针对此场景，可以结合上述两个方案，即&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用ThreadCache，每个线程内创建多固定大小的内存池&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个线程内创建一个多固定大小的内存池&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用加锁，操作全局唯一内存池(每次加锁解锁耗时100ns左右)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;上述几种方案，仅仅是在使用固定大小内存池基础上进行的扩展，具体的方案，需要根据具体情况来具体分析&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结语&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要讲了固定大小内存池的实现方式，因为实现方案的局限性，此内存池设计方案仅适用于每次申请都是特定大小的场景。虽然在扩展部分做了部分思维发散，但因为未做充分的数据对比，所以仅限于思维扩散。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，开源的内存分配库很多，比较优秀的有谷歌的tcmalloc以及微软的mimalloc，大家可以根据自己项目的需求场景，选择合适的内存分配库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的文章就到这里，下期见。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;本文所讲的内存池源码地址：&lt;/p&gt;&lt;p&gt;https://github.com/namelij/fixedsize_memorypool&lt;/p&gt;&lt;p&gt;别忘了给个star哦😁&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>