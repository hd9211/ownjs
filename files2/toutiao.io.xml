<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>91b513559ba60ceb575179669418e339</guid>
<title>腾讯 T4 一年的心血成就 17W 字操作系统、网络协议教程（附导图 + 笔记）</title>
<link>https://toutiao.io/k/kzxohh6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;article_content&quot; class=&quot;article_content clearfix&quot;&gt;
        
                &lt;div id=&quot;content_views&quot; class=&quot;htmledit_views&quot;&gt;
                    &lt;ul&gt;&lt;li&gt;《Java 核心技术总结》&lt;/li&gt;&lt;li&gt;《HTTP 总结》&lt;/li&gt;&lt;li&gt;《程序员必知的基础知识》&lt;/li&gt;&lt;li&gt;《操作系统总结》&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;这四本 PDF 可以说是一个比一个硬核。&lt;/p&gt; 
&lt;p&gt;先来说说 Java 核心技术总结&lt;/p&gt; 
&lt;h1&gt;Java 核心技术总结&lt;/h1&gt; 
&lt;p&gt;先来看一下本篇文章的思维导图吧，文章围绕下面这些内容进行讲解。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/972c835008f1bb8f20c1e539d4824b2a.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;这本 PDF 可以作为你的 Java 入门开发手册，也可以作为查漏补缺的利器&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/9c5dfcc1c3a06c599c3f3ae91c5a8d60.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/43de11080035e70fdda879e75b82ae1c.png&quot;/&gt;&lt;/p&gt; 
&lt;h1&gt;HTTP 核心总结&lt;/h1&gt; 
&lt;p&gt;第二本 PDF 的思维导图&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/5d44480ca1932b56955dd2da5c05257f.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;可以看看里面的绘图，真的是非常下功夫的。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/b85c0354729eadabd740e30dce2d7a90.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/6d26200b2b55f223a958978963dc7313.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这个 PDF 几乎涵盖了关于 HTTP 99% 的知识点了&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/7501c9df42fd1ef0df9417cd9eeb4add.png&quot;/&gt;&lt;/p&gt; 
&lt;h1&gt;程序员必知的硬核知识&lt;/h1&gt; 
&lt;p&gt;在技术不断更新迭代的今天，你学习的速度已经跟不上框架迭代的速度了，当你还在学 Spring 3 的时候，Spring 5 就已经出来了。而且，现在会使用 Spring 的人简直太多了，大家都在研究新技术怎么用，框架怎么好，却忘了为什么要这么设计，构造原理是怎么样？所以，基础是重中之重，若干年前计算机只认识 0 和 1，现在仍然只能认识 0 和 1，所以你要把有限的时间放在不会改变的技术上。基础知识是亘古不变的，改变也只是会调优，而不会推翻。所以，我自己写了一本 PDF，是程序员必知的基础知识，来为你讲述这些不变的根本。&lt;/p&gt; 
&lt;p&gt;我带你重新认识了一下 CPU 是什么，CPU 寄存器有哪些&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/f70b396fea5f56c0354ccecce1e418e8.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/0025ed1955567d019250a22624f59444.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;我和你聊聊内存是什么&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/db0e4f15538f6a2cc5cabfede4ba78c2.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;我非常认真的为你总结了计算机中二进制的计算原则&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/0f54bcf40ebbed84f4fc0310892a3b50.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;我和你聊聊磁盘是如何出现的，以及它的发展历程，为什么磁盘能够存储数据？&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/b5a3f9d51081b75b6388f97568186d2c.png&quot;/&gt;&lt;/p&gt; 
&lt;h1&gt;操作系统总结&lt;/h1&gt; 
&lt;p&gt;这是我最硬核的一本 PDF 了&lt;/p&gt; 
&lt;p&gt;目录&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/415abd2a43a6fc140d85c789db46c88e.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;操作系统确实 太重要了，可以说没有操作系统，也就没有人给你扯这么多。所以非常有必要认识一下操作系统。&lt;/p&gt; 
&lt;p&gt;这本 PDF 带你认识了一下操作系统的一些核心概念，能够让你有个全局认识。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/0070a00b56c0a216840d5455ab48711e.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这本 PDF 带你从入门到深入理解操作系统最核心的抽象：&lt;/p&gt; 
&lt;h1&gt;进程、文件、地址&lt;/h1&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d804f8efe96fc6acd28a60bc13589bfd.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/cb551521aae107442484ef1d5c98328d.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/97b7a8356577d3eb5b92a9fde769219c.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;还为你汇总了操作系统核心面试题，助你一臂之力&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/82b097e87d093dfe2aca9b887b64d01d.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这本 PDF 一共是 306 页，17w 字，我想这应该是全网第一份操作系统 PDF 了吧，希望大家能够珍藏。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/ee4acf87ee3b2a82c380cb9a7d946c2b.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;《Java 核心技术总结》《HTTP 总结》《程序员必知的基础知识》《操作系统总结》四本实战且实用的好教程你值得拥有，转发+评论，关注我添加VX：MXW5308 即可免费获取《Java 核心技术总结》《HTTP 总结》《程序员必知的基础知识》《操作系统总结》学习教程.pdf&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/20201006145432207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTEzMjIzOA==,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt;
                &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a642c6fc0d66e4671c3bb7ef6a9e1db9</guid>
<title>虚拟机系列：JVM 运行时数据区</title>
<link>https://toutiao.io/k/otkcgzi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、内存与线程&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、内存结构&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;内存是计算机的重要部件之一,它是外存与CPU进行沟通的桥梁，计算机中所有程序的运行都在内存中进行，内存性能的强弱影响计算机整体发挥的水平。JVM的内存结构规定Java程序在执行时内存的申请、划分、使用、回收的管理策略，通说来说JVM的内存管理指运行时数据区这一大块的管理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5402298850574713&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBS1pq4s6Msxgia1CKUMqTWdgtf3jWpQibAn0R2sDjFbnNdHX2a1Iia00icAEO8ooibhtia1pa6yuquNSWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;870&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、线程运行&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;JVM中一个应用是可以有多个线程并行执行，线程被一对一映射为服务所在操作系统线程，调度在可用的CPU上执行，启动时会创建一个操作系统线程；当该线程终止时，这个操作系统线程也会被回收。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.554635761589404&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uUIibyNXbAvBS1pq4s6Msxgia1CKUMqTWdMBHFVkiavMxy3YoBibAichXoOl7Mq7zC0BeWSBopibhfOhYcq8BJjlX6mA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;604&quot;/&gt;&lt;/p&gt;&lt;p&gt;在虚拟机启动运行时，会创建多个线程，数据区中有的模块是线程共享的，有的是线程私有的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.048780487804878&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBS1pq4s6Msxgia1CKUMqTWd038zciaxwKSb6GdJVx7gvbmdCzHLjIj1rWDt3sITDDvPlnqqrI6o6uQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot;/&gt;&lt;/p&gt;&lt;p&gt;线程共享：元数据区、堆Heap；&lt;/p&gt;&lt;p&gt;线程私有：虚拟机栈、本地方法栈、程序计数器；&lt;/p&gt;&lt;p&gt;单个CPU在特定时刻只能执行一个线程，所以多线程通过几块空间的使用，然后不断的争抢CPU的执行时间段。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、元数据空间&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;基本描述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;方法元空间(方法区)在JVM启动的时候被创建，是被各个线程共享的内存空间，用于存放类和方法的元数据以及常量池，比如Class和Method。&lt;/p&gt;&lt;p&gt;在实际的开发中，经常因为加载的类太多，进而导致内存溢出问题，这样可以对元空间的大小进行扩展。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;与堆的关系&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5643340857787811&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBS1pq4s6Msxgia1CKUMqTWd0NK8W3DP7Kw1O9NQ3w5ccjlQLbqQOZ7OVubUnstyb0YgSkUibnkiaqsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;886&quot;/&gt;&lt;/p&gt;&lt;p&gt;元空间存放加载的类信息，当类被实例化时，堆中存储实例化的对象信息，并且通过对象类型数据的指针找到类。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、堆空间&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;基本描述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;JVM启动时创建堆区，是内存管理的核心区，通常情况下也是最大的内存空间，是被所有线程共享的，几乎所有的对象实例都要在堆中分配内存，所以这里也是垃圾回收的重点空间。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;堆栈关系&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4810606060606061&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBS1pq4s6Msxgia1CKUMqTWdOa4jwFr4xicypwMdhUHSlZE0hWehxPapB8ROpRAcIsfsTfjIIIFk0QA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/p&gt;&lt;p&gt;栈是JVM运行时的单位，堆是存储单位，当栈中方法结束，相关对象失去所有引用后，不会马上被移除堆空间，要等到垃圾收集器运行的时候。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、虚拟机栈&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;虚拟机栈(Java栈)在每个线程创建时都会生成一个虚拟机栈，栈的内部是一个个栈帧单元，对应Java方法的调用，其生命周期和线程周期保持一致。用来存储方法的局部遍历，部分执行结果，方法的调用和返回。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5358024691358024&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBS1pq4s6Msxgia1CKUMqTWdePzvjCycphicyJHOcVsjmAqibfnl4ibJLlaHyUttEE359XgstJGFyxhPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot;/&gt;&lt;/p&gt;&lt;p&gt;栈帧是方法执行的数据集，维持执行过程中的各种数据信息，执行的方法依次入栈，栈顶存放当前要执行的方法，执行结束后出栈，对于栈没有垃圾回收问题。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、程序计数器&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;基本描述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;JVM中程序计数寄存器用来存储下一条将要执行指令的地址，执行引擎获取到指令后进行执行，是线程私有的。它可以看作是当前线程所执行的字节码的行号指示器。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5429184549356223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBS1pq4s6Msxgia1CKUMqTWdoicrbxfHfcGeYd8zOT7GRyl2KZanJudibzugjhsfY0WLkMaIyNVxSFKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;932&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;前后关系&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;线程在获取CPU的时间段内执行代码，但是线程随时可能没有执行完就被挂起，等到线程A再次获取CPU执行时，CPU 得知道执行到线程A的哪一个指令，程序计数器会存储该动作。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;六、本地方法栈&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;本地方法栈与虚拟机栈所起到的作用是类似的，虚拟机栈为虚拟机执行Java方法，本地方法栈管理虚拟机使用到的 本地方法，在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。HotSpot虚拟机直接就把本地方法栈和虚拟机栈合二为一。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;七、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/java-base-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/java-base-parent&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b6667d7499592fa75ef4edb661b5cbd6</guid>
<title>想要 4 个 9？本文告诉你监控告警如何做</title>
<link>https://toutiao.io/k/9vxbpn0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“你说说，没有仪表盘的车，你敢开吗？”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“没有仪表盘的车开在路上，你怎么知道现在是什么情况？”&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iachwhMRhBibb9pv5Kyriary5QLZsJ4I8ZQ4l32JOMBsc4T3Veg7OPUIwicDJrsF1mwPBL1Z9K9IGVtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“客户说你这车又崩了，咋知道什么时候好的？啥时候出的问题？”&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将思考转换到现实的软件系统中，可想而知没有监控系统的情况下，也就是没有 ”仪表盘“ 的情况下实在是太可怕了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的故障永远都是你的客户告诉你的，而...在什么时候发生的，你也无法确定，只能通过客户的反馈倒推时间节点，最后从错误日志中得到相对完整的日志信息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更要命的是你无法掌握主动权，错误日志有可能会有人漏记录，平均修复时间（MTTR）更不用想了，需要从 0.1 开始定位，先看 APP 是哪个模块报错，再猜测是哪个服务导致，再打开链路追踪系统，或是日志平台等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稍微复杂些的，排查来来往往基本都是半小时、一小时以上，那 4 个 9 肯定是达不到的了，以此几次 P0 几小时怕不是业务绩效也凉凉，因为故障修复的速度实在是太慢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那归根到底，想破局怎么办，核心第一步就是要把监控告警的整个生态圈给建设好。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;监控定义&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常说监控监控，监控的定义就是监测和控制，检测某些事物的变化，以便于进行控制。在常见的软件系统中，大多分为三大观察类别：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5654596100278552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iachwhMRhBibb9pv5Kyriary5a6fQgicUpP748xYQC1icwO90lEm4DwyycqO3DEC4Feibt7AWxJFreGQkQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1436&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;业务逻辑：项目所对应的服务其承担的业务逻辑，通常需要对其进行度量。例如：每秒的下单数等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;应用程序：应用程序。例如：统一的基础框架。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;硬件资源：服务器资源情况等。例如：Kubernetes 中的 Cadvisor 组件便会提供大量的资源指标。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从软件系统来讲，监控的定义就是收集、处理、汇总，显示关于某个系统的实时量化数据，例如：请求的数量和类型，错误的数量和类型，以及各类调用/处理的耗时，应用服务的存活时间等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;监控目标&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了监控的定义，了解了监控的作用和具体的实施指标后。我们需要明确的知道，做监控的目标是什么：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6142061281337048&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iachwhMRhBibb9pv5Kyriary5cAwpgsyOHPOhB8sRdMEEQsmkFKALjTkaRXIBfEoZZZlOcicHiaNic64RQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1436&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从现实层面出发，做监控的初衷，就是希望能够及时的发现线上环境的各种各样奇奇怪怪的问题，为业务的正常运转保驾护航。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此整体分为上图四项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;预测故障：故障还没出现，但存在异常。监控系统根据流量模型、数据分析、度量趋势来推算应用程序的异常趋势，推算可能出现故障的问题点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;发现故障：故障已经出现，客户还没反馈到一线人员。监控系统根据真实的度量趋势来计算既有的告警规则，发现已经出现故障的问题点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;定位故障：故障已经出现，需要监控系统协助快速定位问题，也就是根因定位（root cause）。此时是需要协调公司内生态圈的多个组件的，例如：链路追踪系统、日志平台、监控系统、治理平台（限流熔断等），根据监控系统所告警出来的问题作为起始锚点，对其进行有特定方向的分析，再形成 ”线索“ 报告，就可以大力的协助开发人员快速的定位问题，发现故障点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;故障恢复：故障已经出现，但自动恢复了，又或是通过自动化自愈了。这种情况大多出现在告警规则的阈值配置的不够妥当，又或是第三方依赖恰好恢复了的场景。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而更值得探讨的的是监控告警的后半段闭环，故障自愈，通过上述三点 “预测故障、发现故障、定位故障”，已经定位到故障了，就可以配合内部组件，实现自动化的 ”自愈“，减少人工介入，提高 MTTR。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6142061281337048&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iachwhMRhBibb9pv5Kyriary5AezX00H2MpaGqB3Utj9rL8mBASLMWGk2nLHKJO7r2P8icO6cNRtN0ww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1436&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此做监控系统的目标很明确，就是发现问题，解决问题，最好自愈，达到愉快休假，业务安心的目的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4 个黄金指标&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有定义，有目标，那指导呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上 “业务逻辑、应用程序、硬件资源” 已经成为了一个监控系统所要监控构建的首要目标，绝大部分的监控场景都可以归类进来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对这三大项，《Google SRE 运维解密》 也总结出了 4 个黄金指标，在业界广为流传和借鉴：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;延迟：服务处理某个请求所需要的时间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;区分成功和失败请求很重要，例如：某个由于数据库连接丢失或者其他后端问题造成的 HTTP 500 错误可能延迟很低。因此在计算整体延迟时，如果将 500 回复的延迟也计算在内，可能会产生误导性的结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“慢” 错误要比 “快” 错误更糟糕。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;流量：使用系统中的某个高层次的指标针对系统负载需求所进行的度量。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对 Web 服务器来讲，该指标通常是每秒 HTTP 请求数量，同时可能按请求类型分类（静态请求与动态请求）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对音频流媒体系统来说，指标可能是网络 I/O 速率，或者并发会话数量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对键值对存储系统来说，指标可能是每秒交易数量，或每秒的读者操作数量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;错误：请求失败的速率。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;显式失败（例如：HTTP 500）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;隐式失败（例如：HTTP 200 回复中包含了错误内容）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;策略原因导致的失败（例如：如果要求回复在 1s 内发出，任何超过 1s 的请求就都是失败请求）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;饱和度：服务容量有多 “满”，通常是系统中目前最为受限的某种资源的某个具体指标的度量，例如：在内存受限的系统中，即为内存；在 I/O 受限的系统中，即为 I/O。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;很多系统在达到 100% 利用率之前性能会严重下降，因此可以考虑增加一个利用率目标。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;延迟增加是饱和度的前导现象，99% 的请求延迟（在某一个小的时间范围内，例如一分钟）可以作为一个饱和度早期预警的指标。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;饱和度需要进行预测，例如 “看起来数据库会在 4 小时内填满硬盘”。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果已经成功度量了这四个黄金指标，且在某个指标出现故障时能够发出告警（或者快要发生故障），那么在服务的监控层面来讲，基本也就满足了初步的监控诉求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是可以做到知道了是什么出问题，问题出在哪里，单这一步就已经提高了不少定位问题的时间效率，是一个从 0 到 1 的起步阶段。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实践案例&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道是什么（定义），为什么要做（目标），做的时候需要什么（4 个黄金指标）后，还缺乏的是一个承载这些基础应用、业务思考的平台，让架构+运维+业务共同在上面施展拳脚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公司内部至少需要有一个监控告警管理平台。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;平台搭建&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在目前云原生火热的情况下，Kubernetes 生态中大多惯用 Prometheus，因此 Prometheus+Grafana+AlertManger 成为了一大首选，业内占比也越来越高，其基本架构如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6122448979591837&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iachwhMRhBibb9pv5Kyriary5qJNWicfLhjrDiafDn5ictrTfArvHJBErvZZmb4zzTJGK25OVmENKpmjkA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1960&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Prometheus Server：用于收集指标和存储时间序列数据，并提供一系列的查询和设置接口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Grafana：用于展示各类趋势图，通过 PromQL 从 Prometheus 服务端查询并构建图表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Alertmanager：用于处理告警事件，从 Prometheus 服务端接收到 alerts 后，会进行去重，分组，然后路由到对应的Receiver，发出报警。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这块具体的基本知识学习和搭建可详见我写的 Prometheus 系列，本文不再赘述。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;监控指标&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在平台搭建完毕后，常要做的第一步，那就是规划你整个系统的度量指标，结合 Google SRE 的 4 个黄金指标，可以初步划分出如下几种常用类型：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;系统层面：Kubernetes Node、Container 等指标，这块大多 Cadvisor 已采集上报，也可以安装 kube-state-metrics 加强，这样子就能够对 Kubernetes 和应用程序的运行情况有一个较好的观察和告警。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;系统层面：针对全链路上的所有基础组件（例如：MySQL、Redis 等）安装 exporter，进行采集，对相关基础组件进行监控和告警。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;业务服务：RPC 方法等的 QPS 记录。可以保证对业务服务的流量情况把控，且后续可以做预测/预警的一系列动作，面对突发性流量的自动化扩缩容有一定的参考意义。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;业务服务：RPC 方法等的错误情况。能够发现应用程序、业务的常见异常情况，但需要在状态/错误码规划合理的情况下，能够起到较大的作用，有一定困难，要在一开始就做对，否则后面很难扭转。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;应用程序：各类远程调用（例如：RPC、SQL、HTTP、Redis）的调用开销记录。最万金油的度量指标之一，能够在很多方面提供精确的定位和分析，Web 应用程序标配。常见于使用 P99/95/90。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;语言级别：内部分析记录，例如：Goroutines 数量、Panic 情况等，常常能发现一些意想不到的泄露情况和空指针调用。没有这类监控的话，很有可能一直都不会被发现。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;指标落地&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步完成了整个系统的度量指标规划后，第二步就是需要确确实实的把指标落地了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是统一基础框架的打点，系统组件的 exporter，大多涉及了公司级的跨多部门协作，这时候需要更多的耐心和长期主义和不断地对方向纠错，才能尝到体系建设后的果实。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;告警体系&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在完成监控指标和体系的建设后，告警如何做，成为了一大难题，再好的监控体系，闭环做不好，就无法发挥出很大的作用。因此我们给告警定义一些准则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;告警不要太多，否则会导致“狼来了”。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;告警出现时，应当要具体操作某些事情，是亟待解决的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;告警出现时，应当要进行某些智力分析，不应该是机械行为。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不需要人工响应/处理的告警规则，应当直接删除。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;告警出现时，你下意识要再观察观察的告警，要直接进行调整。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;告警应当足够的简单，直观，不需要猜。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来讲就是告警要少，事件需要解决，处理要人工介入。否则右拐自动化自愈恢复可能更香。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;告警给谁？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一个难题就是：谁诱发处理的告警，要通知给谁？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个很需要斟酌的问题，在告警的规范上，尽可能遵循最小原则，再逐级上报。也就是先告警给 on-call 人，若超出 X 分钟，再逐级上报到全业务组，再及其负责人，一级级跟踪，实现渐进式告警。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7085635359116023&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iachwhMRhBibb9pv5Kyriary5qictcSlc0nwZUNNOYxyYxC4elFolvpu9iarMO7Vnzoc84SZiaFBwzVtgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1448&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;逐级上报，响应即跟踪，明确问题点的责任人。而逐级上报的数据来源，可通过员工管理系统来获取，在员工管理系统中有完整的上下级关系（类似 OA 审批上看到的流程节点），但如果该系统没有开放 API 之类的，那可能你只能通过其他方式来获取了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如像是通过企业微信获取部门关系和人员列表，再手动设置上下级关联关系，也可以达到目的，且在现实世界中，有可能存在定制化的诉求。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;规范建立&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使所以监控体系、指标落地、告警体系都建立起来了，也不能掉以轻心。实际上在成为事实标准后，你仍然需要尽快为告警后奔跑，将整个闭环搭建起来，也就是故障管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与公司内部的流程管理的同学或 QA，一起设立研发底线的规范，进行细致的告警分级识别，告警后的汇总运营分析，形成一个真正意义上的故障管理规范。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;否则最后可能会疲于奔命，人的时间精力总是有限的，而面对整个公司的监控告警的搭建，体系上与业务组的共建，督促告警响应，极有可能最后会疲于奔命，即使真的有一定用处，在杂乱无人收敛的告警中最后流于形式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;监控告警的体系生态做来有意义吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是必然的，成熟且规范的监控告警的体系生态是具有极大意义，可以提前发现问题，定位问题，解决问题。甚至这个问题的说不定还不需要你自己处理，做多组件的闭环后，直接实施自动化的服务自愈就可以了，安心又快快乐乐的过国庆节，是很香的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而故障管理的闭环实施后，就可以分析业务服务的告警情况，结合 CI/CD 系统等基础平台，每季度自动化分析实施运营报表，帮助业务发现更多的问题，提供其特有的价值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但，想真正做到上述所说的成熟且规范，业务共建，有难度，需要多方面认同和公司规范支撑才能最佳实现。因此共同认可，求同存异，多做用户反馈分析也非常重要。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>15bcfba3187511985b37920f932a4525</guid>
<title>字节跳动踩坑记：Goroutine 泄漏</title>
<link>https://toutiao.io/k/t3z2i69</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBH1zfCzRuYLuDW4PcrN8icT95DBh8J91rSGUkdupXuH0Rmx5NibTOIDtoC8JbGPNfjicibNWKD1ABuZ8b43D8GvJQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;- 1 -&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那是一个月以前，一个令人愉快的周五晚上，我在收工前扫了一眼监控看板，看到了点不太好的迹象：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6078767123287672&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibBH1zfCzRuZ9WMJp2BibQjDFOAet15wF59e0PMcd1NicRQq4a2rJNLibvqTLNwnAX8icWLYStWjahEg6R6VulGwVicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;稍微解释一下，图中骚动的绿线表示 Goroutine 的数量，密集的红色竖线表示发布了新版的时间点。 &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为26和27号下午照常发车，所以 Goroutine 的数量下降了；而28号 &lt;span&gt;值班同学偷懒&lt;/span&gt; 没有需要发布的commit，于是 Goroutine 数量一路上涨，眼看就要冲破方框。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我心想：&lt;span&gt;这走势要是我买的510500该多好啊&lt;/span&gt; 糟了，这铁定是 Goroutine 泄漏了，那我还收不收工了？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;经过一番思考，头脑里的勤奋小人打败了懒惰小人，指挥我把问题抛给了当天值班的 H 同学，然后愉快地去健身房了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;毕竟 Goroutine 泄漏排查起来应该不会很困难，按套路用 pprof dump 两份采样数据、然后用 --base 比较一下，就该结案了吧。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;- 2 -&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然后 H 同学用 pprof 确实看到了泄漏的 2498 个 goroutine：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.15452930728241562&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBH1zfCzRub6cia1ReicDrICXGX2cvwicTL1HNia8AKs34ZnqRc7fzxmtPSAyl6lyuiahUZYUGcJC0vZL5icW7z4lwdQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1126&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（不是我没截全，是真的只有一行stack）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但问题是这些 goroutine 的 stack 过于简单了 —— 这 http.(*persisteConn).writeLoop 是个什么鬼，没有 stack 真是瞎了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5856164383561644&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBH1zfCzRub6cia1ReicDrICXGX2cvwicTL7IPv9PmyLcj3TVw1qAHlnarZLkgPSSjxCrWe5CJoICT8KdffSMnKibA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;292&quot;/&gt;&lt;/p&gt;&lt;p&gt;只好先用笨办法筛一下，往前找发现问题的时间点，然后看看当时上线了什么奇怪的东西。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibBH1zfCzRub6cia1ReicDrICXGX2cvwicTLqy3ibMhcv6qrwdfroDgUdP8EibkhGs7piaricSMpib9wZPLoA3MekloK3qA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（点击可放大）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从上图可以看到，把时间拉长了以后，问题出现的时间点应该是8月22号前后&lt;span&gt;，接着翻了翻前几天的 commit，果然什么也没发现，并没有哪些 commit 用 go 关键词新建 goroutine 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBH1zfCzRuavjmXoqLQhNbGXR9W2FaMqEnUvh5jricakBdEYev4g0Kp5ZMe1RSxQeHH3MNxG0c7QmtmbjicCiaXHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;- 3 -&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;虽说套路不得人心，那实在没办法，也还是得硬着头皮查；&lt;span&gt;还好重启大法给了我们充足的支撑和信念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在第二周的周二，尝试了各种可能以后，我们终于想到，说不定是上周开启的那个实验导致的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;负责该实验的 G 同学用前面发现的 stack 作为关键字，在 Google 上看到了别人遇到的 case&lt;/span&gt;&lt;span&gt; —— 我们竟然一直没用上 STFW 大法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6255259467040674&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBH1zfCzRub6cia1ReicDrICXGX2cvwicTLJojOV46LlUP9RKr1KrdHzsnNZTUItKF4eIYZfwMYvdpBHsKNBt9KNw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;713&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对应到我们的代码，是因为该实验相关逻辑需要发起一个 http 请求，于是有一段代码长这样：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;client := &amp;amp;http.Client{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;_, err = client.Do(req)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;问题就在这里 —— 你能想到么，这里 client.Do 会返回一个 http.Response ，而 Response.Body 这个 &quot;io.ReadCloser&quot; 是需要主动关闭的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0289389067524115&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBH1zfCzRuYmgCSSicXPSyJewc4QBFAO2boYU3HEtdoSd1CUlgB72w6d93757iaPkriaibZaia1VDYEcKXqDWYaDT1A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;622&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;- 4 -&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然文档里倒是写得很清楚：&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;158&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;The http Client and Transport guarantee that Body is always non-nil, even on responses &lt;span&gt;without a body or responses with a zero-length body. &lt;strong&gt;It is the caller&#x27;s responsibility to close Body.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但为啥会出现 goroutine 泄漏呢？&lt;span&gt;还是得从源码下手。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前面我们用 pprof 看到，goroutine 的 stack 在 &lt;span&gt;http.(*persisteConn).writeLoop，这个方法位于 src/net/http/transport.go ，而它的调用方只有一处：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(t *Transport)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;dialConn(...)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(...)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; pconn.readLoop()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; pconn.writeLoop()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; pconn, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也就是说，虽然我们没有主动用 go 启动新的 goroutine，但是在 http 库里，建立一个新的连接时会自动创建两个 goroutine ，一个用于读，一个用于写。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而 writeLoop 在做什么呢？以下是一个简化的版本：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(pc *persistConn)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;writeLoop()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;close&lt;/span&gt;(pc.writeLoopDone)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; wr := &amp;lt;-pc.writech:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      err := wr.req.Request.write(...)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      ... &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          pc.&lt;span class=&quot;code-snippet__built_in&quot;&gt;close&lt;/span&gt;(err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-pc.closech:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也就是说，要么遇到错误，要么 &quot;closech&quot; 这个 channel 返回，writeLoop 才会结束 —— &quot;closech&quot; 正是需要我们主动调用 Response.Body.Close() 后才会被 close 掉；而当 channel 被关闭后，读取该 channel 的地方会立即返回。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;于是前面踩坑的代码被改成这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;client := &amp;amp;http.Client{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;resp, err = client.Do(req)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; resp.Body.Close()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;填坑完毕。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;- 5 -&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总结起来，整个过程中实际上踩了好几个坑：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;我为大家整理了一份从入门到进阶的Go学习资料礼包（下图只是部分），同时还包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.4705882352941178&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMql12OsAtoHPdsdIbzXA90Pz2xxQUaNJhp4FLyicaC0Wc46u3SXWKthtaHzj1bon1EfNeO7HNcc3Gxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;374&quot;/&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.31875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMql12OsAtoHPdsdIbzXA90PzrclP8f0Uh0cQ2CWGLZaCrxsPmlTXOFgfQ7bAMXu86LlefeqzTGD8eA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>42a4a9047542322ebd3dc793fd94d968</guid>
<title>RocketMQ 进阶：事务消息</title>
<link>https://toutiao.io/k/ada62ci</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式消息选型的时候是否支持事务消息是一个很重要的考量点，而目前只有RocketMQ对事务消息支持的最好。今天我们来唠唠如何实现RocketMQ的事务消息！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apache RocketMQ在4.3.0版中已经支持分布式事务消息，这里RocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示。&lt;img data-ratio=&quot;0.4503464203233256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjnG5D5L80UwMEnch2lhFCU6S01vMG5DdeLS9icD5hIOXFZgmnQUzyUWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;866&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RocketMQ事务流程概要&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ实现事务消息主要分为两个阶段：正常事务的发送及提交、事务信息的补偿流程
整体流程为：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产者发送一个半消息给MQServer（半消息是指消费者暂时不能消费的消息）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端响应消息写入结果，半消息发送成功&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开始执行本地事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据本地事务的执行状态执行Commit或者Rollback操作&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果MQServer长时间没收到本地事务的执行状态会向生产者发起一个确认回查的操作请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者收到确认回查请求后，检查本地事务的执行状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据检查后的结果执行Commit或者Rollback操作
补偿阶段主要是用于解决生产者在发送Commit或者Rollback操作时发生超时或失败的情况。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RocketMQ事务流程关键&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;事务消息在一阶段对用户不可见
事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的，也就是说消费者不能直接消费。这里RocketMQ的实现方法是原消息的主题与消息消费队列，然后把主题改成 &lt;code&gt;RMQ_SYS_TRANS_HALF_TOPIC&lt;/code&gt; ，这样由于消费者没有订阅这个主题，所以不会被消费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何处理第二阶段的失败消息？在本地事务执行完成后会向MQServer发送Commit或Rollback操作，此时如果在发送消息的时候生产者出故障了，那么要保证这条消息最终被消费，MQServer会像服务端发送回查请求，确认本地事务的执行状态。当然了rocketmq并不会无休止的的信息事务状态回查，默认回查15次，如果15次回查还是无法得知事务状态，RocketMQ默认回滚该消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息状态
事务消息有三种状态：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TransactionStatus.CommitTransaction&lt;/strong&gt;：提交事务消息，消费者可以消费此消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TransactionStatus.RollbackTransaction&lt;/strong&gt;：回滚事务，它代表该消息将被删除，不允许被消费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TransactionStatus.Unknown&lt;/strong&gt; ：中间状态，它代表需要检查消息队列来确定状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先假设我们有这样一个需求：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户请求订单微服务 &lt;code&gt;order-service&lt;/code&gt; 接口删除订单（退货），删除订单后需要发送消息给用户服务 &lt;code&gt;account-service&lt;/code&gt;，用户微服务收到消息后会给用户账户增加余额。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个需求跟钱相关，肯定要保证消息的事务性，接下来我们根据上面的原理实现整个流程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基础配置&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者order-servcie和account-service都要引入RocketMQ相关依赖，增加RocketMQ的相关配置&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.rocketmq&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;rocketmq-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# within rocketmq&lt;/span&gt;&lt;br/&gt;&lt;span&gt;rocketmq:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  name-server:&lt;/span&gt; &lt;span&gt;xxx.xx.x.xx:9876;&lt;/span&gt; &lt;span&gt;xxx.xx.x.xx:9876&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  producer:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    group:&lt;/span&gt; &lt;span&gt;cloud-group&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;发送半消息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;order-service在执行删除订单操作时发送一条半消息给MQServer，发送半消息主要是使用 &lt;code&gt;rocketMQTemplate.sendMessageInTransaction()&lt;/code&gt; 方法，发送事务消息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(String orderNo)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; Order order = orderMapper.selectByNo(orderNo);&lt;br/&gt; &lt;span&gt;//如果订单存在且状态为有效，进行业务处理&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (order != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; CloudConstant.VALID_STATUS.equals(order.getStatus())) {&lt;br/&gt;  String transactionId = UUID.randomUUID().toString();&lt;br/&gt;  &lt;span&gt;//如果可以删除订单则发送消息给rocketmq，让用户中心消费消息&lt;/span&gt;&lt;br/&gt;  rocketMQTemplate.sendMessageInTransaction(&lt;span&gt;&quot;add-amount&quot;&lt;/span&gt;,&lt;br/&gt;    MessageBuilder.withPayload(&lt;br/&gt;      UserAddMoneyDTO.builder()&lt;br/&gt;        .userCode(order.getAccountCode())&lt;br/&gt;        .amount(order.getAmount())&lt;br/&gt;        .build()&lt;br/&gt;    )&lt;br/&gt;    .setHeader(RocketMQHeaders.TRANSACTION_ID, transactionId)&lt;br/&gt;    .setHeader(&lt;span&gt;&quot;order_id&quot;&lt;/span&gt;,order.getId())&lt;br/&gt;    .build()&lt;br/&gt;    ,order&lt;br/&gt;  );&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先先校验一下订单状态，然后发送消息给MQServer，这个逻辑大家都看得懂，主要是关注 &lt;code&gt;sendMessageInTransaction()&lt;/code&gt; 方法，源码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; TransactionSendResult &lt;span&gt;sendMessageInTransaction&lt;/span&gt;&lt;span&gt;(String destination, Message&amp;lt;?&amp;gt; message, Object arg)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; MessagingException &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (((TransactionMQProducer)&lt;span&gt;this&lt;/span&gt;.producer).getTransactionListener() == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;The rocketMQTemplate does not exist TransactionListener&quot;&lt;/span&gt;);&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   org.apache.rocketmq.common.message.Message rocketMsg = &lt;span&gt;this&lt;/span&gt;.createRocketMqMessage(destination, message);&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.producer.sendMessageInTransaction(rocketMsg, arg);&lt;br/&gt;  }&lt;br/&gt; } &lt;span&gt;catch&lt;/span&gt; (MQClientException var5) {&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; RocketMQUtil.convert(var5);&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法有三个参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;destination：目的地(主题)，这里发送给 &lt;code&gt;add-amount&lt;/code&gt; 这个主题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;message：发送给消费者的消息体，需要使用 &lt;code&gt;MessageBuilder.withPayload()&lt;/code&gt; 来构建消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;arg：参数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意，这里我们生成了一个transactionId，并放在header中跟消息一起发送（这里实际也可以构造成一个对象，放在arg里进行发送），作用后面再讲！&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;执行本地事务与回查&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MQServer收到半消息后会告诉生产者order-service确认收到半消息，这时候order-service需要执行本地事务，执行完本地事务后再告诉MQServer本地事务的执行状态，确认消息究竟是Commit还是Rollback。如果在告诉MQServer本地执行状态的时候出异常了还需要让MQServer能够回查到，怎么实现这一些列操作呢？&lt;img data-ratio=&quot;0.7412060301507538&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxj3QibVZ0koLBg4JckXpA1z003PvwDljjAYVC5goB6AnWOGsFrGYU2E4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;398&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ提供了 &lt;code&gt;RocketMQLocalTransactionListener&lt;/code&gt; 接口，本地事务监听器，这个接口类的实现如下：&lt;img data-ratio=&quot;0.2632135306553911&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjydfzgB9oiaicpcVWOd57ICeTJFmrDD2Mibfb1ayy81CfrBtL0D6CTdiagA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;946&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个方法 &lt;code&gt;executeLocalTransaction&lt;/code&gt; 为执行本地事务；第二个方法 &lt;code&gt;checkLocalTransaction&lt;/code&gt; 为检查本地事务的执行状态，也就是回查动作。有了这个接口类我们的执行逻辑清楚了，但是还有个问题：本地事务已经执行完成了，怎么去回查本地事务的执行结果呢？&lt;img data-ratio=&quot;0.5517241379310345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjFJCCaaZWfRiaaicmrlXd4VcJuV82icAicfjxZsELg0IXy0UNMxz65eDuyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;290&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在执行本地事务的时候同时生成一个事务日志，让本地事务与日志事务在同一个方法中，同时添加 &lt;code&gt;@Transactional&lt;/code&gt; 注解，保证两个操作事务是一个原子操作。&lt;strong&gt;这样如果事务日志表中有这个本地事务的信息，那就代表本地事务执行成功，需要Commit，相反如果没有对应的事务日志，则表示没执行成功，需要Rollback&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思路既然理顺了，咱们就开撸。&lt;img data-ratio=&quot;0.759493670886076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjicJkCics3WVeNZO6kEU5ibFnz2bbYj083lV1IVjWJnGnVqB83OqNq4rdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;395&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先创建一个日志表&lt;img data-ratio=&quot;0.26905829596412556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjrVVVoX2Nq9llpEAiaKLBKsTqQg6H9REWLuX7VicbKZqGBOfXOKtoTaRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;669&quot;/&gt;很简单的三个字段，主要是这个事务id，需要根据这个事务id回查事务，还记得我们在发送半消息时生成的事务id吗，就是干这个用的！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在生产者编写方法实现 &lt;code&gt;RocketMQLocalTransactionListener&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@RocketMQTransactionListener&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequiredArgsConstructor&lt;/span&gt;(onConstructor = @__(&lt;span&gt;@Autowired&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AddUserAmountListener&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;RocketMQLocalTransactionListener&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; OrderService orderService;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RocketMqTransactionLogMapper rocketMqTransactionLogMapper;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 执行本地事务&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RocketMQLocalTransactionState &lt;span&gt;executeLocalTransaction&lt;/span&gt;&lt;span&gt;(Message message, Object arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;执行本地事务&quot;&lt;/span&gt;);&lt;br/&gt;        MessageHeaders headers = message.getHeaders();&lt;br/&gt;        &lt;span&gt;//获取事务ID&lt;/span&gt;&lt;br/&gt;        String transactionId = (String) headers.get(RocketMQHeaders.TRANSACTION_ID);&lt;br/&gt;        Integer orderId = Integer.valueOf((String)headers.get(&lt;span&gt;&quot;order_id&quot;&lt;/span&gt;));&lt;br/&gt;        log.info(&lt;span&gt;&quot;transactionId is {}, orderId is {}&quot;&lt;/span&gt;,transactionId,orderId);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;//执行本地事务，并记录日志&lt;/span&gt;&lt;br/&gt;            orderService.changeStatuswithRocketMqLog(orderId, CloudConstant.INVALID_STATUS,transactionId);&lt;br/&gt;            &lt;span&gt;//执行成功，可以提交事务&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; RocketMQLocalTransactionState.COMMIT;&lt;br/&gt;        }&lt;span&gt;catch&lt;/span&gt; (Exception e){&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; RocketMQLocalTransactionState.ROLLBACK;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 本地事务的检查，检查本地事务是否成功&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RocketMQLocalTransactionState &lt;span&gt;checkLocalTransaction&lt;/span&gt;&lt;span&gt;(Message message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        MessageHeaders headers = message.getHeaders();&lt;br/&gt;        &lt;span&gt;//获取事务ID&lt;/span&gt;&lt;br/&gt;        String transactionId = (String) headers.get(RocketMQHeaders.TRANSACTION_ID);&lt;br/&gt;        log.info(&lt;span&gt;&quot;检查本地事务,事务ID:{}&quot;&lt;/span&gt;,transactionId);&lt;br/&gt;        &lt;span&gt;//根据事务id从日志表检索&lt;/span&gt;&lt;br/&gt;        QueryWrapper&amp;lt;RocketmqTransactionLog&amp;gt; queryWrapper = &lt;span&gt;new&lt;/span&gt; QueryWrapper&amp;lt;&amp;gt;();&lt;br/&gt;        queryWrapper.eq(&lt;span&gt;&quot;transaction_id&quot;&lt;/span&gt;,transactionId);&lt;br/&gt;        RocketmqTransactionLog rocketmqTransactionLog = rocketMqTransactionLogMapper.selectOne(queryWrapper);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; != rocketmqTransactionLog){&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; RocketMQLocalTransactionState.COMMIT;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; RocketMQLocalTransactionState.ROLLBACK;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor = RuntimeException.class)&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;changeStatuswithRocketMqLog&lt;/span&gt;&lt;span&gt;(Integer id,String status,String transactionId)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//将订单状态置位无效&lt;/span&gt;&lt;br/&gt; orderMapper.changeStatus(id,status);&lt;br/&gt;    &lt;span&gt;//插入事务表&lt;/span&gt;&lt;br/&gt; rocketMqTransactionLogMapper.insert(&lt;br/&gt;   RocketmqTransactionLog.builder()&lt;br/&gt;     .transactionId(transactionId)&lt;br/&gt;     .log(&lt;span&gt;&quot;执行删除订单操作&quot;&lt;/span&gt;)&lt;br/&gt;   .build()&lt;br/&gt; );&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这一块的代码逻辑都是在生产端，即Order-Server，大家不要搞错了&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消费消息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rollback的消息MQServer会给我们处理，我们只要关注Commit状态时消费端可以正常消费即可。在 &lt;code&gt;account-service&lt;/code&gt;监听消息，如果收到消息则给用户账户增加余额。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RocketMQMessageListener&lt;/span&gt;(topic = &lt;span&gt;&quot;add-amount&quot;&lt;/span&gt;,consumerGroup = &lt;span&gt;&quot;cloud-group&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RequiredArgsConstructor&lt;/span&gt;(onConstructor = @__(&lt;span&gt;@Autowired&lt;/span&gt;) )&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AddUserAmountListener&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;RocketMQListener&lt;/span&gt;&amp;lt;&lt;span&gt;UserAddMoneyDTO&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AccountMapper accountMapper;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 收到消息的业务逻辑&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onMessage&lt;/span&gt;&lt;span&gt;(UserAddMoneyDTO userAddMoneyDTO)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;received message: {}&quot;&lt;/span&gt;,userAddMoneyDTO);&lt;br/&gt;        accountMapper.increaseAmount(userAddMoneyDTO.getUserCode(),userAddMoneyDTO.getAmount());&lt;br/&gt;        log.info(&lt;span&gt;&quot;add money success&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;测试&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11811811811811812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjxLv8TF72nHOTTxY8xXibY4ibOo9l70USluxXHn85tKXKvMatVr4zVxsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;999&quot;/&gt;订单表有这样一条记录，用户为jianzh5，amount为200&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23542116630669546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjxvLMFAPHQZ1kJ4NdL2Seicez3K78BlcXZia75j3sWIGaCeJd33BrHNgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;463&quot;/&gt;用户表的记录，执行完成后jianzh5的账户应该变成250&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用删除订单接口，删除订单&lt;img data-ratio=&quot;0.31353919239904987&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxj6icJd3cxXCVe87TX2Cd5AAeZh1ffMEWSGNxACV9I72yHM9SKBcu9nAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;842&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送半消息&lt;img data-ratio=&quot;0.4354575163398693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjfB6mCicYDIibE05pXKtLoRhgtF0jWtoLmIib15VwjYbaPtHbQ2nNgR9rQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1224&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行本地事务，并生成事务日志&lt;img data-ratio=&quot;0.49115755627009644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjAUlYxMLGUQqLdMoCBe41Jj6wLF6icQfztf5WuP8libNvRH4Jp0sfutcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1244&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模拟异常情况
在发送Commit消息的时候我们用命令杀掉进程 &lt;code&gt;taskkill /pid 19748 -t -f&lt;/code&gt;，模拟异常！&lt;img data-ratio=&quot;0.3416757344940152&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjhNSgHw177hlb3a8Ivzl4mibjiaPmp4GvbD5Pe9Y7RguXD6oh82kDlSyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;919&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重新启动order-service，查看是否会执行回查动作&lt;img data-ratio=&quot;0.45143745143745145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjxhmJZiajFSK3E2UeyqRLgDS5UibA1qOXNLavUUHZdSef0EQBJ0FooN1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1287&quot;/&gt;MQServer进行回查，检查事务日志，判断是否可以提交事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者消费事务消息，保证事务的一致性&lt;img data-ratio=&quot;0.1837916063675832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxj3bFhlnZdPcF8qejB7zeJbOyGiaGS4GpMibth1RqzYGNJ24pUic32zAibHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用RocketMQ实现事务消息的过程还是很复杂的，需要好好理解开头的那张图，只有理解了事务消息的交互过程才能编写相应的代码！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>