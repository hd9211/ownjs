<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>88cf990ddf7695a7e786e8fa32691779</guid>
<title>[译] 50+ 有用的 DevOps 工具（四）</title>
<link>https://toutiao.io/k/xj75ci5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;blockquote&gt;&lt;p&gt;原文: https://dzone.com/articles/50-useful-devops-tools?edition=627291&amp;amp;utm_medium=email&amp;amp;utm_source=dzone&amp;amp;utm_content=50+%20useful%20DevOps%20tools&amp;amp;utm_campaign2 翻译: 祝坤荣&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;31.SolarWinds 服务与应用监控&lt;/h2&gt;&lt;p&gt;Solarwinds的服务与应用监控，提供了不错的特性列表。&lt;/p&gt;&lt;p&gt;Link: https://www.solarwinds.com/server-application-monitor&lt;/p&gt;&lt;h2&gt;测试&lt;/h2&gt;&lt;h2&gt;33.Vegeta&lt;/h2&gt;&lt;p&gt;一个可被当成命令行或类库的HTTP压力测试工具。Link: https://github.com/tsenart/vegeta&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.26953125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4Wy3wc85lBIDsnK1B3P1HPzBHcBynJZZLY1Nog2O3q9ic4LA5X9TtpgbYNat6nHCrcw4XH2qTE7ibic8wGZFklRNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;34.QuerySurge&lt;/h2&gt;&lt;p&gt;QuerySurge主要专注在如何自动化校验和测试你的数据。其值得一提的特性是其对于多平台的支持，与大多数数据集成与BI测试方案的内置支持。&lt;/p&gt;&lt;p&gt;Link: https://www.querysurge.com/&lt;/p&gt;&lt;h2&gt;安全&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.0638297872340425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4Wy3wc85lBIDsnK1B3P1HPzBHcBynJZZJ5o8Lic6Pz8fHaS4e5bhFqabupnns3I6eCKUoNmljpYGxHnpw2HBYyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;188&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;35.Krypton&lt;/h2&gt;&lt;p&gt;Krypton是一个使用了不易损坏的加密架构的U2F验证移动应用。所有的加密密钥都存储在本地驱动器，来防止不想遇到的外部攻击。&lt;/p&gt;&lt;p&gt;Link: https://krypt.co/&lt;/p&gt;&lt;h2&gt;36. Mysterium.network&lt;/h2&gt;&lt;p&gt;Mysterium为Mysterium终端用户提供隐私和安全的一种网络节点。这种节点镜像是为树莓派这种嵌入式系统硬件准备的。&lt;/p&gt;&lt;p&gt;Link: https://mysterium.network/&lt;/p&gt;&lt;h2&gt;37.Okta&lt;/h2&gt;&lt;p&gt;Okta是一种鉴定管理服务。通过Okta，你可以在一处管理所有雇员的访问，Okta的特性包括单点登录(SSO)，AD与LDAP集成，多因子验证(MFA)。所有这些都随提供了多种整合方案的Okta集成网络提供。&lt;/p&gt;&lt;p&gt;Link: https://www.okta.com/&lt;/p&gt;&lt;h2&gt;38.Palo Alto Networks&lt;/h2&gt;&lt;p&gt;一家提供云安全服务的公司。服务包括为从分支机构的移动用户提供安全接入。数据保护，治理，合规，安全监控，合规验证，云存储安全。&lt;/p&gt;&lt;p&gt;Link: https://www.paloaltonetworks.com/cloud-security&lt;/p&gt;&lt;h2&gt;39.Small step SSH&lt;/h2&gt;&lt;p&gt;Smallstep提供单点登录SSH(SSO SSH)，能让你不用每天收集，发送，处理SSH。所有SSH和sudo的访问都可以从一个管理员版面进行管理。&lt;/p&gt;&lt;p&gt;Link: https://smallstep.com/sso-ssh/&lt;/p&gt;&lt;h2&gt;有用的CLI工具&lt;/h2&gt;&lt;h2&gt;40.Awless&lt;/h2&gt;&lt;p&gt;一个目标是帮助开发者管理亚马逊web服务的命令行工具。Awless&lt;/p&gt;&lt;p&gt;Link: https://github.com/wallix/awless&lt;/p&gt;&lt;h2&gt;42.Snyk-CLI&lt;/h2&gt;&lt;p&gt;Snyl CLI能帮你找到，更重要的帮你修复依赖项的漏洞-无论是热点网络或你的CI系统。&lt;/p&gt;&lt;p&gt;Link: https://support.snyk.io/hc/en-us/categories/360000456217-Snyk-CLI&lt;/p&gt;&lt;h2&gt;43.Daytona&lt;/h2&gt;&lt;p&gt;Daytona通过提供更有效率的专注于自动化验证与密钥获取的Vault客户端版本来辅助你。&lt;/p&gt;&lt;p&gt;Link: https://github.com/cruise-automation/daytona&lt;/p&gt;&lt;h2&gt;开发&lt;/h2&gt;&lt;h2&gt;44.Bitbucket&lt;/h2&gt;&lt;p&gt;Bitbucket是为专业团队提供的，集项目计划，代码协作，测试，开发一体的产品，同时也提供订阅服务选项。&lt;/p&gt;&lt;p&gt;Link: https://bitbucket.org/product&lt;/p&gt;&lt;h2&gt;45.Confluence&lt;/h2&gt;&lt;p&gt;Confluence是一个对于项目计划，会议纪要，市场计划，博客发布很理想的工具。为你的业务提供一个开放和可存取的空间，对于团队和公司都很合适。&lt;/p&gt;&lt;p&gt;Link: https://www.atlassian.com/software/confluence&lt;/p&gt;&lt;h2&gt;46.Frame.ai&lt;/h2&gt;&lt;p&gt;Frame提供一个对于你客户关系的独特视角并通过持续监控的特性帮助你识别出客户结果背后的为什么。&lt;/p&gt;&lt;p&gt;Link: https://frame.ai/&lt;/p&gt;&lt;h2&gt;47.Grit&lt;/h2&gt;&lt;p&gt;Grit帮助程序员/开发者从原仓库存储，传送，分享和复制代码提交到目标仓库。&lt;/p&gt;&lt;p&gt;Link: https://github.com/grailbio/grit&lt;/p&gt;&lt;h2&gt;48.JIRA&lt;/h2&gt;&lt;p&gt;Jira帮助开发者在预定的任务上捕获，分配和设定优先级。它帮助开发者管理整个软件开发进程，保障所有任务都已经完成。&lt;/p&gt;&lt;p&gt;Link: https://www.atlassian.com/software/jira&lt;/p&gt;&lt;h2&gt;49.EditorConfig&lt;/h2&gt;&lt;p&gt;EditorConfig帮助在大型群组使用不同编辑器或IDE工作的开发人员维护一套一致的编码规范。&lt;/p&gt;&lt;p&gt;Link: https://editorconfig.org/&lt;/p&gt;&lt;h2&gt;50.Tilix&lt;/h2&gt;&lt;p&gt;Tilix是用来模拟符合gnome人机界面规范的linux终端模拟器。它可以创建多个可以被同步的控制面板。&lt;/p&gt;&lt;p&gt;Link: https://gnunn1.github.io/tilix-web/&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4Wy3wc85lBIDsnK1B3P1HPzBHcBynJZZC3JfTI3LrPQNggSreNxDjQsKQyUyslJjgIrscp4DLhBWwhoFQW6Ujg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;356&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;51.Jsonnet&lt;/h2&gt;&lt;p&gt;Jsonnet是一个容易理解的JSON扩展。这个工具提供了很多特性，如消除重复，与自定义/现存应用整合，并能生成包括JSON，INI，YAML格式的内容。&lt;/p&gt;&lt;p&gt;Link: https://jsonnet.org/&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.96&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4Wy3wc85lBIDsnK1B3P1HPzBHcBynJZZNKZniaRoZuRFQ8guQX7JtcU5llCT1ommWfdtnVZ4NhtL85HQdqJVMFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;200&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;52.Hazelcast&lt;/h2&gt;&lt;p&gt;Hazelcast是一个内存缓存方案，其提供创新，低延迟，以数据为中心的应用。它适合任何并行处理多线程架构的实时处理。&lt;/p&gt;&lt;p&gt;Link: https://hazelcast.com/&lt;/p&gt;&lt;h2&gt;可视化&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.26217228464419473&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4Wy3wc85lBIDsnK1B3P1HPzBHcBynJZZ2g4S5SlL2twvnj70QQ2utmTZSUhKzW2nsJhN6g0RvrXLxYYWnJOxlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;534&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;53.Cloudcraft&lt;/h2&gt;&lt;p&gt;Cloudcraft是一个用组件为开发者在几分钟快速创建AWS架构图的可视化设计器。工具让人不用编写静态手册文档与规范。&lt;/p&gt;&lt;p&gt;Link: https://cloudcraft.co/&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8658854166666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4Wy3wc85lBIDsnK1B3P1HPzBHcBynJZZ9Uq8GCibWFDp23xPBt6RN4FicTdZPrvgs0AYiaGh3kSVynyc36DGSTmyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;54.DbSchema&lt;/h2&gt;&lt;p&gt;支持SQL与NoSQL数据库，DbSchema提供了不错与方便的可视化数据库设计器帮你管理你的schema。&lt;/p&gt;&lt;p&gt;Link: https://dbschema.com/&lt;/p&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;Capgemini.com. 2020. [online] Available at: &amp;lt;https://www.capgemini.com/de-de/wp-content/uploads/sites/5/2016/03/devops-the-future-of-application-lifecycle-automation.pdf&amp;gt; [Accessed 16 July 2020].&lt;/p&gt;&lt;p&gt;Gartner. 2020. DevOps. [online] Available at: &amp;lt;https://www.gartner.com/en/information-technology/glossary/devops&amp;gt; [Accessed 16 July 2020].&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;本文来自祝坤荣(时序)的微信公众号「麦芽面包，id「darkjune_think」 转载请注明。&lt;/p&gt;&lt;p&gt;交流Email: &lt;span&gt;zhukunrong@yeah.net&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt; 微博:祝坤荣 开发者/科幻爱好者/硬核主机玩家/业余翻译&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; zhukunrong@yeah.net: &lt;em&gt;mailto:zhukunrong@yeah.net&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b399741bb02f76ca4d8b222d9adb103b</guid>
<title>数据仓库组件：HBase 集群环境搭建和应用案例</title>
<link>https://toutiao.io/k/33rd3q6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、Hbase简介&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、基础描述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Hadoop原生的特点是解决大规模数据的离线批量处理场景，HDFS具备强大存储能力，但是并没有提供很强的数据查询机制。HBase组件则是基于HDFS文件系统之上提供类似于BigTable服务。&lt;/p&gt;&lt;p&gt;HBase是一种分布式、可扩展、支持海量结构化数据存储的NoSQL数据库。HBase在Hadoop之上提供了类似于Bigtable的能力，基于列存储模式的而不是基于行的模式。存储数据特点：非结构化或者松散的半结构化数据，存储大表自然是需要具备水平扩展的能力，基于服务集群处理海量庞大数据。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、数据模型&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基于Hbase的数据结构的基本描述；&lt;/p&gt;&lt;p&gt;HBase的数据模型同关系型数据库很类似，数据存储在一张表中，有行有列。但从HBase的底层物理存储结构看更像是Map（K-V）集合。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据管理是基于列存储的特点；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;简单的数据模型，内容存储为字符串；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;没有复杂的表关系，简单的增删查操作；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;从整体上看数据模型，HBase是一个稀疏、多维度、排序的映射表，这张表的索引是行键、列族、列限定符和时间戳每个值是一个未经解释的字符串。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、搭建集群环境&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、解压文件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;tar&lt;/span&gt; &lt;span&gt;-zxvf&lt;/span&gt; &lt;span&gt;hbase-1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;span&gt;.1-bin&lt;/span&gt;&lt;span&gt;.tar&lt;/span&gt;&lt;span&gt;.gz&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2、配置环境变量&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;vim /etc/profile&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; HBASE_HOME=/opt/hbase-1.3.1&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; PATH=&lt;span&gt;$PATH&lt;/span&gt;:&lt;span&gt;$HBASE_HOME&lt;/span&gt;/bin&lt;br/&gt;&lt;br/&gt;&lt;span&gt;source&lt;/span&gt; /etc/profile&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3、配置：hbase-env&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;vim /opt/hbase&lt;span&gt;-1.3&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;/conf/hbase-env.sh&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; JAVA_HOME=&lt;span&gt;/opt/&lt;/span&gt;jdk1&lt;span&gt;.8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; HBASE_MANAGES_ZK=&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4、配置：hbase-site&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;vim /opt/hbase-1.3.1/conf/hbase-site.xml&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;!--HDFS存储--&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;hbase.rootdir&lt;span&gt;&amp;lt;/&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;hdfs://hop01:9000/HBase&lt;span&gt;&amp;lt;/&lt;span&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;!--开启集群--&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;hbase.cluster.distributed&lt;span&gt;&amp;lt;/&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;span&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;!-- 端口 --&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;hbase.master.port&lt;span&gt;&amp;lt;/&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;16000&lt;span&gt;&amp;lt;/&lt;span&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;!--ZK集群--&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;   &lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;hbase.zookeeper.quorum&lt;span&gt;&amp;lt;/&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;&amp;lt;&lt;span&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;hop01,hop02,hop03&lt;span&gt;&amp;lt;/&lt;span&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;!--ZK数据--&amp;gt;&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;   &lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;hbase.zookeeper.property.dataDir&lt;span&gt;&amp;lt;/&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;&amp;lt;&lt;span&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;/data/zookeeper/data/&lt;span&gt;&amp;lt;/&lt;span&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;5、配置：regionservers&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;vim&lt;/span&gt; /opt/hbase-&lt;span&gt;1&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;/conf/regionservers&lt;br/&gt;&lt;br/&gt;hop01&lt;br/&gt;hop02&lt;br/&gt;hop03&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;6、配置：软连接&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;软连接hadoop配置文件到HBase&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;ln&lt;/span&gt; -s /opt/hadoop2.&lt;span&gt;7&lt;/span&gt;/etc/hadoop/core-site.xml /opt/hbase-&lt;span&gt;1&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;/conf/core-site.xml&lt;br/&gt;ln -s /opt/hadoop2.&lt;span&gt;7&lt;/span&gt;/etc/hadoop/hdfs-site.xml /opt/hbase-&lt;span&gt;1&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;/conf/hdfs-site.xml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;7、同步集群服务环境&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;也可以手动配置集群，或者使用同步命令。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;xsync&lt;/span&gt; hbase/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;8、启动集群&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在hop01节点启动即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;/opt/hbase-1.3.1/bin/&lt;span&gt;start&lt;/span&gt;-hbase.sh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动日志：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;hop03: starting regionserver, logging &lt;span&gt;to&lt;/span&gt; /opt/hbase-&lt;span&gt;1.3&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;/bin/../logs/hbase-root-regionserver-hop03.&lt;span&gt;out&lt;/span&gt;&lt;br/&gt;hop02: starting regionserver, logging &lt;span&gt;to&lt;/span&gt; /opt/hbase-&lt;span&gt;1.3&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;/bin/../logs/hbase-root-regionserver-hop02.&lt;span&gt;out&lt;/span&gt;&lt;br/&gt;hop01: starting regionserver, logging &lt;span&gt;to&lt;/span&gt; /opt/hbase-&lt;span&gt;1.3&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;/bin/../logs/hbase-root-regionserver-hop01.&lt;span&gt;out&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;9、查看状态&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;jps&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;HMaster：主节点&lt;br/&gt;HRegionServer：分区节点&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;10、停止集群&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在hop01节点停止即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;/opt/hbase-1.3.1/bin/&lt;span&gt;stop&lt;/span&gt;-hbase.sh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;11、查看界面&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;http:&lt;span&gt;//hop01:16010&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.35234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvByOHmBTs7ibQbrc4SWyhY8Ysvc90PTOoacyiaj8zM56biaFLeRfejic118guueD7TNRT9EV9j1A46Mpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、基础Shell命令&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、切入客户端&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;/opt/hbase-1.3.1/bin/hbase shell&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2、查看表&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;hbase&lt;/span&gt;(&lt;span&gt;main&lt;/span&gt;)&lt;span&gt;:002&lt;/span&gt;&lt;span&gt;:0&lt;/span&gt;&amp;gt; &lt;span&gt;list&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3、创建表&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;hbase(main):003:0&amp;gt;&lt;/span&gt; create &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;info&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt; row(s) &lt;span&gt;in&lt;/span&gt; &lt;span&gt;2.7910&lt;/span&gt; seconds&lt;br/&gt;=&amp;gt; Hbase::Table - user&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4、查看表结构&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;hbase(main):010:0&amp;gt;&lt;/span&gt; describe &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;5、添加数据&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;put&lt;/span&gt; &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;id01&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;info:name&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;tom&#x27;&lt;/span&gt;&lt;br/&gt;put &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;id01&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;info:age&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;18&#x27;&lt;/span&gt;&lt;br/&gt;put &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;id01&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;info:sex&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;male&#x27;&lt;/span&gt;&lt;br/&gt;put &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;id02&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;info:name&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;jack&#x27;&lt;/span&gt;&lt;br/&gt;put &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;id02&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;info:age&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;20&#x27;&lt;/span&gt;&lt;br/&gt;put &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;id02&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;info:sex&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;female&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;6、查看表数据&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;hbase(main):&lt;span&gt;010&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&amp;gt; scan &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;&lt;br/&gt;ROW     COLUMN+CELL                                                                             &lt;br/&gt;id01    column=info:age, timestamp=&lt;span&gt;1594448524308&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;=&lt;span&gt;18&lt;/span&gt;                                      &lt;br/&gt;id01    column=info:name, timestamp=&lt;span&gt;1594448513534&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;=tom                                    &lt;br/&gt;id01    column=info:sex, timestamp=&lt;span&gt;1594448530817&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;=male                                    &lt;br/&gt;id02    column=info:age, timestamp=&lt;span&gt;1594448542631&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;=&lt;span&gt;20&lt;/span&gt;                                      &lt;br/&gt;id02    column=info:name, timestamp=&lt;span&gt;1594448536520&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;=jack                                   &lt;br/&gt;id02    column=info:sex, timestamp=&lt;span&gt;1594448548005&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;=female&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些表结构和数据会在集群之间自动同步。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;7、查询指定列&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;hbase(main):&lt;span&gt;012&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&amp;gt; &lt;span&gt;get&lt;/span&gt; &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;id01&#x27;&lt;/span&gt;&lt;br/&gt;COLUMN      CELL                                                                                    &lt;br/&gt;info:age    timestamp=&lt;span&gt;1594448524308&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;=&lt;span&gt;18&lt;/span&gt;                                                       &lt;br/&gt;info:name   timestamp=&lt;span&gt;1594448513534&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;=tom                                                       &lt;br/&gt;info:sex    timestamp=&lt;span&gt;1594448530817&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;=male&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;8、统计行数&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;hbase(main):013:0&amp;gt;&lt;/span&gt; count &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;9、删除行数据&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;hbase(main):014:0&amp;gt;&lt;/span&gt; deleteall &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;id02&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;10、清空表数据&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;hbase(main):016:0&amp;gt;&lt;/span&gt; truncate &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;11、删除表&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;hbase(main):018:0&amp;gt;&lt;/span&gt; disable &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hbase(main):019:0&amp;gt;&lt;/span&gt; drop &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;四、JDBC基础查询&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、核心依赖&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.hbase&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;hbase-client&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.3.1&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2、基础配置&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这里连接zookeeper集群地址即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;zookeeper:&lt;/span&gt;&lt;br/&gt;  address: 集群地址Url，逗号分隔&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编写HBase配置和常用工具方法。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HBaseConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String address;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object lock=&lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Configuration configuration = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService executor = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Connection connection = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取连接&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Connection &lt;span&gt;getConnection&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; == connection){&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (lock) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; == connection){&lt;br/&gt;                    configuration = &lt;span&gt;new&lt;/span&gt; Configuration();&lt;br/&gt;                    configuration.set(&lt;span&gt;&quot;hbase.zookeeper.quorum&quot;&lt;/span&gt;, address);&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        executor = Executors.newFixedThreadPool(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;                        connection = ConnectionFactory.createConnection(configuration, executor);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; connection;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取 HBaseAdmin&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HBaseAdmin &lt;span&gt;getHBaseAdmin&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        HBaseAdmin admin = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;            admin = (HBaseAdmin)getConnection().getAdmin();&lt;br/&gt;        }&lt;span&gt;catch&lt;/span&gt;(Exception e){&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; admin;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取 Table&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Table &lt;span&gt;getTable&lt;/span&gt;&lt;span&gt;(TableName tableName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Table table = &lt;span&gt;null&lt;/span&gt; ;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;            table = getConnection().getTable(tableName);&lt;br/&gt;        }&lt;span&gt;catch&lt;/span&gt;(Exception e){&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; table ;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 关闭资源&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;&lt;span&gt;(HBaseAdmin admin,Table table)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(admin!=&lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                admin.close();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(table!=&lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                table.close();&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${zookeeper.address}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setAddress&lt;/span&gt; &lt;span&gt;(String address)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        HBaseConfig.address = address;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3、查询案例&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;查询数据参考上述全表扫描结果：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HBaseController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 扫描全表&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/scanTable&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;scanTable&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        Table table = HBaseConfig.getTable(TableName.valueOf(&lt;span&gt;&quot;user&quot;&lt;/span&gt;));&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            ResultScanner resultScanner = table.getScanner(&lt;span&gt;new&lt;/span&gt; Scan());&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Result result : resultScanner) {&lt;br/&gt;                printResult(result);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            HBaseConfig.close(&lt;span&gt;null&lt;/span&gt;, table);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;success&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 根据RowKey扫描&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/scanRowKey&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;scanRowKey&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        String rowKey = &lt;span&gt;&quot;id02&quot;&lt;/span&gt;;&lt;br/&gt;        Table table = HBaseConfig.getTable(TableName.valueOf(&lt;span&gt;&quot;user&quot;&lt;/span&gt;));&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            Result result = table.get(&lt;span&gt;new&lt;/span&gt; Get(rowKey.getBytes()));&lt;br/&gt;            printResult(result);&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            HBaseConfig.close(&lt;span&gt;null&lt;/span&gt;, table);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 输出 Result&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printResult&lt;/span&gt; &lt;span&gt;(Result result)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        NavigableMap&amp;lt;&lt;span&gt;byte&lt;/span&gt;[], NavigableMap&amp;lt;&lt;span&gt;byte&lt;/span&gt;[], NavigableMap&amp;lt;Long, &lt;span&gt;byte&lt;/span&gt;[]&amp;gt;&amp;gt;&amp;gt; map = result.getMap();&lt;br/&gt;        Set&amp;lt;Map.Entry&amp;lt;&lt;span&gt;byte&lt;/span&gt;[], NavigableMap&amp;lt;&lt;span&gt;byte&lt;/span&gt;[], NavigableMap&amp;lt;Long, &lt;span&gt;byte&lt;/span&gt;[]&amp;gt;&amp;gt;&amp;gt;&amp;gt; set = map.entrySet();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;&lt;span&gt;byte&lt;/span&gt;[], NavigableMap&amp;lt;&lt;span&gt;byte&lt;/span&gt;[], NavigableMap&amp;lt;Long, &lt;span&gt;byte&lt;/span&gt;[]&amp;gt;&amp;gt;&amp;gt; entry : set) {&lt;br/&gt;            Set&amp;lt;Map.Entry&amp;lt;&lt;span&gt;byte&lt;/span&gt;[], NavigableMap&amp;lt;Long, &lt;span&gt;byte&lt;/span&gt;[]&amp;gt;&amp;gt;&amp;gt; entrySet = entry.getValue().entrySet();&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;&lt;span&gt;byte&lt;/span&gt;[], NavigableMap&amp;lt;Long, &lt;span&gt;byte&lt;/span&gt;[]&amp;gt;&amp;gt; entry2 : entrySet) {&lt;br/&gt;                System.out.print(&lt;span&gt;new&lt;/span&gt; String(result.getRow()));&lt;br/&gt;                System.out.print(&lt;span&gt;&quot;\t&quot;&lt;/span&gt;);&lt;br/&gt;                System.out.print(&lt;span&gt;new&lt;/span&gt; String(entry.getKey()));&lt;br/&gt;                System.out.print(&lt;span&gt;&quot;:&quot;&lt;/span&gt;);&lt;br/&gt;                System.out.print(&lt;span&gt;new&lt;/span&gt; String(entry2.getKey()));&lt;br/&gt;                System.out.print(&lt;span&gt;&quot; value = &quot;&lt;/span&gt;);&lt;br/&gt;                System.out.println(&lt;span&gt;new&lt;/span&gt; String(entry2.getValue().firstEntry().getValue()));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;五、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/big-data-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/big-data-parent&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7c8902c2f1fbe90fbf98aefab5304474</guid>
<title>18 张图解密新时代内存分配器 TCMalloc</title>
<link>https://toutiao.io/k/zwzin8t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h2 data-line=&quot;4&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;系列导读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code data-line=&quot;6&quot;&gt;&lt;code&gt;&lt;p&gt;&lt;span&gt;本系列基于64位平台、1Page=8KB&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-line=&quot;10&quot;&gt;&lt;span&gt;本文为&lt;/span&gt;&lt;span&gt;《Go语言轻松系列》&lt;/span&gt;第二章「&lt;strong&gt;内存与垃圾回收&lt;/strong&gt;」第二篇。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhuZuquZTuGz1icCkzeiaibsvUMJqnMRfNy72uw1NtsQUia3OFIXwbI35mSQRLy9k2VP8kxJib9zxWWJicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.4148148148148147&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-line=&quot;16&quot;&gt;关于「内存与垃圾回收」章节，大体从如下三大部分展开：&lt;/p&gt;&lt;h1 data-line=&quot;8&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;本文导读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;我们的主要目的是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;掌握Go语言的内存分配原理&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。但是呢，Go语言的内存分配主要是基于&lt;/span&gt;&lt;strong&gt;&lt;span&gt;TCMalloc内存分配器&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;实现的。所以，我们想搞懂Go语言的内存分配原理前，必须先了解&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;TCMal&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;loc&lt;/span&gt;&lt;/strong&gt;内存分配器&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，以便于我们更好的理解&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Go语言的内存分配原理&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;本文目录如下：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1 data-line=&quot;52&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;读前知识储备&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p data-line=&quot;54&quot;&gt;&lt;span&gt;本小节的内容如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内存的线性分配&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;什么是&lt;/span&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;虚拟内存&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;什么是&lt;/span&gt;&lt;code&gt;&lt;span&gt;TCMalloc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;?&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-line=&quot;61&quot;&gt;&lt;p data-line=&quot;61&quot;&gt;&lt;span&gt;目的：辅助我们更好的理解内存分配原理。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-line=&quot;63&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;内存的线性分配&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-line=&quot;65&quot;&gt;&lt;span&gt;线性分配大致就是需要使用多少分配多少，“用到哪了标识到哪”，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7SjBQCruQDzgmNRmDiaeCIUIvBdPMCicVAOicciaxWnAtUsVfk7RkblFAuiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6101851851851852&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-line=&quot;71&quot;&gt;&lt;span&gt;(图1)&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;71&quot;&gt;&lt;span&gt;线性分配有个问题：“已经分配的内存被释放了，我们如何再次分配？”。大家会想到用链表&lt;/span&gt;&lt;code&gt;&lt;span&gt;LinkedList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，是的没错，但是内存管理中一般使用的是&lt;/span&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-line=&quot;73&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;什么是&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-line=&quot;75&quot;&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;本质上还是个&lt;/span&gt;&lt;code&gt;&lt;span&gt;LinkedList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，和&lt;/span&gt;&lt;code&gt;&lt;span&gt;LinkedList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的区别：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;没有&lt;/span&gt;&lt;code&gt;&lt;span&gt;Next&lt;/span&gt;&lt;/code&gt;&lt;span&gt;属性，所以不是用&lt;/span&gt;&lt;code&gt;&lt;span&gt;Next&lt;/span&gt;&lt;/code&gt;&lt;span&gt;属性存放下一个节点的指针的值。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;“相当于使用了&lt;/span&gt;&lt;code&gt;&lt;span&gt;Value&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的前8字节”(其实就是整块内存的前8字节)存放下一个节点的指针。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分配出去的节点，节点整块内存空间可以被复写(指针的值可以被覆盖掉)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-line=&quot;81&quot;&gt;&lt;span&gt;如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7StWcn9HTHIjmbCvD7oDwqgk5Oh3V9WgG2ds5r6IK085M2ogGs3Qe6tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5296296296296297&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图2)&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-line=&quot;91&quot;&gt;&lt;p data-line=&quot;91&quot;&gt;结论：&lt;code&gt;FreeList&lt;/code&gt;里一个节点最小为8字节&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code data-line=&quot;93&quot;&gt;&lt;code&gt;&lt;p&gt;备注：因为要存指针，指针的大小为8字节，为什么？可以参考上篇文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MDEwMDYyOA==&amp;amp;mid=2454619580&amp;amp;idx=1&amp;amp;sn=66b60ef21383adf51226e5b5cc3cc267&amp;amp;chksm=87aae347b0dd6a510ec94218ead610a712bd04ae3b9c72b45acbc83e969ae3e31a8f53df385f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《64位平台下，指针自身的大小为什么是8字节？》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《64位平台下，指针自身的大小为什么是8字节？》&lt;/a&gt;&lt;/p&gt;&lt;/code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-line=&quot;89&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;虚拟内存&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-line=&quot;91&quot;&gt;&lt;span&gt;这里直说结论哈，我们的进程是运行在虚拟内存上的，图示如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7SQHwO1LqiaWn5IGbeWSAe5swyiaTxY2sSe4nMr6KRruybxwPqWUnCX3Lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6814814814814815&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图3)&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;102&quot;&gt;&lt;span&gt;所以，&lt;/span&gt;&lt;span&gt;以下文章我们所说的内存都是指&lt;span&gt;虚拟内存&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-line=&quot;104&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;什么是&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;code&gt;&lt;span&gt;TCMalloc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-line=&quot;106&quot;&gt;&lt;code&gt;&lt;span&gt;TCMalloc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;全称&lt;/span&gt;&lt;code&gt;&lt;span&gt;Thread Cache Alloc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，是Google开源的一个内存分配器，基于数据结构&lt;/span&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;实现，并引入了线程级别的缓存，性能更加优异。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-line=&quot;108&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;&lt;span&gt;TCMalloc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;中的五个基本概念&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p data-line=&quot;110&quot;&gt;&lt;span&gt;本小节&lt;span&gt;的内容&lt;/span&gt;如下：&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-line=&quot;118&quot;&gt;&lt;p data-line=&quot;118&quot;&gt;&lt;span&gt;目的：&lt;/span&gt;&lt;code&gt;&lt;span&gt;TCMalloc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;各个主要部分是基于这些基本概念组成的.&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-line=&quot;120&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;&lt;span&gt;Page&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的概念&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-line=&quot;122&quot;&gt;&lt;span&gt;操作系统是按&lt;/span&gt;&lt;code&gt;&lt;span&gt;Page&lt;/span&gt;&lt;/code&gt;&lt;span&gt;管理内存的，本文中1Page为8KB，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-line=&quot;124&quot;&gt;&lt;code&gt;&lt;p&gt;&lt;span&gt;备注：操作系统为什么按`Page`管理内存？不在本文范围。&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7SribPAsPibiaCYicKtPaFlSkQ8AQsq2MKfhnVYtLFiaAAThUicnVqX66G3H4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.2675925925925926&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图4)&lt;/span&gt;&lt;/p&gt;&lt;h2 data-line=&quot;132&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;&lt;span&gt;SpanList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的概念&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-line=&quot;134&quot;&gt;&lt;span&gt;一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是由N个&lt;/span&gt;&lt;code&gt;&lt;span&gt;Page&lt;/span&gt;&lt;/code&gt;&lt;span&gt;构成&lt;/span&gt;&lt;span&gt;的，且：&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;139&quot;&gt;&lt;span&gt;如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7ScBichcNIkzAPNTE6XROkWLXdgyapXES3AjTVLnxu17ic9W63EwiaZu6IA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5009259259259259&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图5)&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;145&quot;&gt;&lt;span&gt;从图中可以看出，有：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1个&lt;/span&gt;&lt;code&gt;&lt;span&gt;Page&lt;/span&gt;&lt;/code&gt;&lt;span&gt;构成的8KB的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2个连续&lt;/span&gt;&lt;code&gt;&lt;span&gt;Page&lt;/span&gt;&lt;/code&gt;&lt;span&gt;构成的16KB的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3个连续&lt;/span&gt;&lt;code&gt;&lt;span&gt;Page&lt;/span&gt;&lt;/code&gt;&lt;span&gt;构成的24KB的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-line=&quot;151&quot;&gt;&lt;span&gt;除此之外，&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;之间可以构成&lt;span&gt;双向链表&lt;/span&gt;我们称之为&lt;/span&gt;&lt;code&gt;&lt;span&gt;SpanList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，内存管理中通常将持有相同数量&lt;/span&gt;&lt;code&gt;&lt;span&gt;Page&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;构成一个双向链表，如下图所示(&lt;span&gt;N个持有1Page的&lt;code&gt;Span&lt;/code&gt;构成的&lt;code&gt;SpanList&lt;/code&gt;&lt;/span&gt;)：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7SDMwUEcpxruFSpR5RvpRVALjr56GZAHsOzGaJaRT1RapXXMZ2x4ibK4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5009259259259259&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图6)&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;159&quot;&gt;我们再来看&lt;code&gt;Span&lt;/code&gt;的下代码，如下：&lt;/p&gt;&lt;pre&gt;&lt;code data-line=&quot;161&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Span&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; SpanList::Elem {&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 略...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 把span拆解成object的方法&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// object的概念看下文&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;BuildFreelist&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt; &lt;span&gt;size&lt;/span&gt;, &lt;span&gt;size_t&lt;/span&gt; count)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// 略...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;union&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// object构成的freelist&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// object的概念看下文&lt;/span&gt;&lt;br/&gt;    ObjIdx cache_[kCacheSize];&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 略...&lt;/span&gt;&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  PageId first_page_;  &lt;span&gt;// 当前span是从哪个page开始的&lt;/span&gt;&lt;br/&gt;  Length num_pages_;   &lt;span&gt;// 当前page持有的page数量&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 略...&lt;/span&gt;&lt;br/&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-line=&quot;184&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;&lt;span&gt;SizeClass&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的概念&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-line=&quot;186&quot;&gt;&lt;span&gt;一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;会被按照某个大小拆分为N个&lt;/span&gt;&lt;code&gt;&lt;span&gt;Objects&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，同时这N个&lt;/span&gt;&lt;code&gt;&lt;span&gt;Objects&lt;/span&gt;&lt;/code&gt;&lt;span&gt;构成一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;(如果忘了FreeList的概念可以再返回上文重新看看)。&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;188&quot;&gt;&lt;span&gt;我们以持有&lt;/span&gt;&lt;code&gt;&lt;span&gt;1Page&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;为例，&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;Page&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;&lt;/code&gt;&lt;span&gt;关系图示如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7SbjduFyHaYz1piaMtAobFcEV9GuGhVF6Ax6VjtVXgQRicSHBLhnl9cI0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6527777777777778&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图7)&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;194&quot;&gt;&lt;span&gt;看完上面的图示，问题来了：&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-line=&quot;196&quot;&gt;&lt;p data-line=&quot;196&quot;&gt;&lt;span&gt;上图怎么知道拆分&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;为一个个24字节大小的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，这个规则是怎么知道的呢？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code data-line=&quot;198&quot;&gt;&lt;p&gt;&lt;span&gt;答案：依赖代码维护的映射列表。&lt;br/&gt;&lt;br/&gt;我们以Google开源的TCMalloc源码(commit:&lt;span&gt;9&lt;/span&gt;d274df)为例来看一下这个映射列表 https:&lt;span&gt;//github.com/google/tcmalloc/tree/master/tcmalloc&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;代码位置：tcmalloc/tcmalloc/size_classes.cc&lt;br/&gt;代码示例(摘取一部分)：&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; SizeClassInfo SizeMap::kSizeClasses[SizeMap::kSizeClassesCount] = {&lt;br/&gt;    &lt;span&gt;// 这里的每一行 称之为SizeClass&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// &amp;lt;bytes&amp;gt;, &amp;lt;pages&amp;gt;, &amp;lt;batch size&amp;gt;    &amp;lt;fixed&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Object大小列，一次申请的page数，一次移动的objects数(内存申请或回收)&lt;/span&gt;&lt;br/&gt;    {        &lt;span&gt;0&lt;/span&gt;,       &lt;span&gt;0&lt;/span&gt;,           &lt;span&gt;0&lt;/span&gt;},  &lt;span&gt;// +Inf%&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;    &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;// 所以也知道为啥最小8字节了吧？&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    &lt;/span&gt;&lt;span&gt;// Object会构成FreeList&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    &lt;/span&gt;&lt;span&gt;// FreeList的节点要存指针&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    &lt;/span&gt;&lt;span&gt;// 指针为8字节&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;    {        &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;,       &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,          &lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;},  &lt;/span&gt;&lt;span&gt;// 0.59%&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    {       &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,       &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,          &lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;},  &lt;/span&gt;&lt;span&gt;// 0.59%&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    {       &lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;,       &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,          &lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;},  &lt;/span&gt;&lt;span&gt;// 0.68%&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    {       &lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;,       &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,          &lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;},  &lt;/span&gt;&lt;span&gt;// 0.59%&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    {       &lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;,       &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,          &lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;},  &lt;/span&gt;&lt;span&gt;// 0.98%&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    {       &lt;/span&gt;&lt;span&gt;48&lt;/span&gt;&lt;span&gt;,       &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,          &lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;},  &lt;/span&gt;&lt;span&gt;// 0.98%&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    &lt;/span&gt;&lt;span&gt;// ...略...&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    {    &lt;/span&gt;&lt;span&gt;98304&lt;/span&gt;&lt;span&gt;,      &lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;,           &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;},  &lt;/span&gt;&lt;span&gt;// 0.05%&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    {   &lt;/span&gt;&lt;span&gt;114688&lt;/span&gt;&lt;span&gt;,      &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;,           &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;},  &lt;/span&gt;&lt;span&gt;// 0.04%&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    {   &lt;/span&gt;&lt;span&gt;131072&lt;/span&gt;&lt;span&gt;,      &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,           &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;},  &lt;/span&gt;&lt;span&gt;// 0.04%&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    {   &lt;/span&gt;&lt;span&gt;147456&lt;/span&gt;&lt;span&gt;,      &lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;,           &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;},  &lt;/span&gt;&lt;span&gt;// 0.03%&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    {   &lt;/span&gt;&lt;span&gt;163840&lt;/span&gt;&lt;span&gt;,      &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;,           &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;},  &lt;/span&gt;&lt;span&gt;// 0.03%&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    {   &lt;/span&gt;&lt;span&gt;180224&lt;/span&gt;&lt;span&gt;,      &lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;,           &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;},  &lt;/span&gt;&lt;span&gt;// 0.03%&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    {   &lt;/span&gt;&lt;span&gt;204800&lt;/span&gt;&lt;span&gt;,      &lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;,           &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;},  &lt;/span&gt;&lt;span&gt;// 0.02%&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    {   &lt;/span&gt;&lt;span&gt;229376&lt;/span&gt;&lt;span&gt;,      &lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt;,           &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;},  &lt;/span&gt;&lt;span&gt;// 0.02%&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    {   &lt;/span&gt;&lt;span&gt;262144&lt;/span&gt;&lt;span&gt;,      &lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;,           &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;},  &lt;/span&gt;&lt;span&gt;// 0.02%&lt;/span&gt;&lt;span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;获取拆分规则的过程(先找到行、再找到这行第一列的值)：&lt;br/&gt;&lt;/span&gt;&lt;span&gt;1.&lt;/span&gt;&lt;span&gt; 先找到对应行(如何找到这个行？是不是有人有疑惑了，&lt;br/&gt;想知道这个答案就需要了解`CentralFreeList`这个结构了，&lt;br/&gt;下文我们会讲到。)&lt;br/&gt;&lt;/span&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span&gt; 找到第一列，这个数字就是object的大小&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-line=&quot;236&quot;&gt;&lt;span&gt;同时通过上面我们知道了：&lt;/span&gt;&lt;code&gt;&lt;span&gt;SizeMap::kSizeClasses&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的每一行元素我们称之为&lt;span&gt;SizeClass&lt;/span&gt;(下文中我们直接就称之为&lt;/span&gt;&lt;code&gt;&lt;span&gt;SizeClass&lt;/span&gt;&lt;/code&gt;&lt;span&gt;).&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-line=&quot;265&quot;&gt;&lt;p data-line=&quot;265&quot;&gt;&lt;span&gt;这个5个基本概念具体干什么用的呢？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code data-line=&quot;267&quot;&gt;&lt;code&gt;&lt;p&gt;&lt;span&gt;答案：支撑了`Tcmalloc`的基本结构的实现。&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-line=&quot;271&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解密&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;code&gt;&lt;span&gt;Tcmalloc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的基本结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p data-line=&quot;273&quot;&gt;&lt;code&gt;&lt;span&gt;Tcmalloc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;主要由三部分构成：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;PageHeap&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;ThreadCache&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-line=&quot;279&quot;&gt;&lt;span&gt;图示如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7SrMe0y0dibxtAEsMOwicTibDsggMUNuJawxVUMFUG04BrkcWkAMC9p52iaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6822074215033301&quot; data-w=&quot;1051&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图8)&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;285&quot;&gt;&lt;span&gt;但是呢，实际上&lt;/span&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是被&lt;/span&gt;&lt;code&gt;&lt;span&gt;TransferCacheManager&lt;/span&gt;&lt;/code&gt;&lt;span&gt;管理的，所以&lt;/span&gt;&lt;code&gt;&lt;span&gt;Tcmalloc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的基本结构实际应该为下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7SRHRTtXnpMsn6WQcws3rwTa5ibc8NapaibakicgxicFLzpuZOfYeskLNm0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5046296296296297&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图9)&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-line=&quot;291&quot;&gt;&lt;p data-line=&quot;291&quot;&gt;&lt;span&gt;接着，&lt;/span&gt;&lt;code&gt;&lt;span&gt;ThreadCache&lt;/span&gt;&lt;/code&gt;&lt;span&gt;其实被线程持有&lt;/span&gt;&lt;span&gt;，为什么呢？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code data-line=&quot;293&quot;&gt;&lt;code&gt;&lt;p&gt;&lt;span&gt;答案：减少线程之间的竞争，分配内存时减少锁的过程。&lt;br/&gt;这也是为什么叫`Thread Cache Alloc`的原因。&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-line=&quot;298&quot;&gt;&lt;span&gt;进一步得到简易的结构图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7Sn1roTTgcUp69hp9ib8fLAcicCLE85NLxfjMxrVBUbPWYiciaiaQz4e6CcQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9361111111111111&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图10)&lt;/span&gt;&lt;/p&gt;&lt;h1 data-line=&quot;304&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解密&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;code&gt;&lt;span&gt;PageHeap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;ThreadCache&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的详细构成&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p data-line=&quot;306&quot;&gt;&lt;span&gt;本小节&lt;span&gt;的内容&lt;/span&gt;如下：&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-line=&quot;314&quot;&gt;&lt;p data-line=&quot;314&quot;&gt;&lt;span&gt;目的：详细了解&lt;/span&gt;&lt;code&gt;&lt;span&gt;TCMalloc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;各个组成部分的实现。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-line=&quot;316&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解密&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;code&gt;&lt;span&gt;PageHeap&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-line=&quot;318&quot;&gt;&lt;code&gt;&lt;span&gt;PageHeap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;主要负责管理不同规格的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，相同规格的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;构成&lt;/span&gt;&lt;code&gt;&lt;span&gt;SpanList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;(可回顾上文&lt;/span&gt;&lt;code&gt;&lt;span&gt;SpanList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的概念)。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-line=&quot;320&quot;&gt;&lt;p data-line=&quot;320&quot;&gt;&lt;span&gt;什么是相同规格的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code data-line=&quot;322&quot;&gt;&lt;code&gt;&lt;p&gt;&lt;span&gt;答：持有相同`Page`数目的`Span`。&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-line=&quot;326&quot;&gt;&lt;code&gt;&lt;span&gt;PageHeap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;对象里维护了一个属性&lt;/span&gt;&lt;code&gt;&lt;span&gt;free_&lt;/span&gt;&lt;/code&gt;&lt;span&gt;类型是个数组，&lt;span&gt;粗略看&lt;/span&gt;数组元素的类型是&lt;/span&gt;&lt;code&gt;&lt;span&gt;SpanList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，同时&lt;/span&gt;&lt;code&gt;&lt;span&gt;free_&lt;/span&gt;&lt;/code&gt;&lt;span&gt;这个数据的元素具有以下特性：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;索引值为1对应的&lt;/span&gt;&lt;code&gt;&lt;span&gt;SpanList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，该&lt;/span&gt;&lt;code&gt;&lt;span&gt;SpanList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;都持有1Pages；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;索引值为2对应的&lt;/span&gt;&lt;code&gt;&lt;span&gt;SpanList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，该&lt;/span&gt;&lt;code&gt;&lt;span&gt;SpanList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;都持有2Pages；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;以此类推，&lt;/span&gt;&lt;code&gt;&lt;span&gt;free_&lt;/span&gt;&lt;/code&gt;&lt;span&gt;索引值为MaxNumber对应的&lt;/span&gt;&lt;code&gt;&lt;span&gt;SpanList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，该&lt;/span&gt;&lt;code&gt;&lt;span&gt;SpanList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;都持有MaxNumber Pages；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MaxNumber的值由&lt;/span&gt;&lt;code&gt;&lt;span&gt;kMaxPages&lt;/span&gt;&lt;/code&gt;&lt;span&gt;决定&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;数组索引&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;SpanList里单个Span持有Page数&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1Pages&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;2Pages&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;3Pages&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;4&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;4Pages&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;5&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;5Pages&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;...&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;...&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;kMaxPages&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;kMaxPages Pages&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-line=&quot;344&quot;&gt;&lt;span&gt;图示如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7SoQNNH0vlh0R1LibC5xEAehqKzfH5j6iaDOm0blXZYtlYj2FYkfJX7oCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.8842592592592593&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图11)&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;350&quot;&gt;&lt;span&gt;但是呢，实际上从代码可知：数组元素的实际类型为&lt;/span&gt;&lt;code&gt;&lt;span&gt;SpanListPair&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，代码如下&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-line=&quot;352&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PageHeap&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; PageAllocatorInterface {&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;// 持有两个Span构成的双向链表&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;SpanListPair&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Span构成的双向链表 正常的&lt;/span&gt;&lt;br/&gt;    SpanList normal; &lt;br/&gt;    &lt;span&gt;// Span构成的双向链表 大概是 物理内存已经回收 但是虚拟内存还被持有(感兴趣可以研究)&lt;/span&gt;&lt;br/&gt;    SpanList returned;&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// kMaxPages.raw_num()这么多个，由上面SpanListPair类型构成的数组&lt;/span&gt;&lt;br/&gt;  SpanListPair free_[kMaxPages.raw_num()] ABSL_GUARDED_BY(pageheap_lock);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-line=&quot;377&quot;&gt;&lt;span&gt;结论：&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;382&quot;&gt;&lt;span&gt;根据这个结论我们修正下&lt;/span&gt;&lt;code&gt;&lt;span&gt;PageHeap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;结构图，如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7SZic1Lr0xKXcKaZ0f9ZygApHomcJDvR2S8JH44qMpusZ40DZYI3M2j9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.687962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图12)&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;388&quot;&gt;&lt;span&gt;又因为大于kMaxPages个Pages(大对象)的内存分配是从&lt;/span&gt;&lt;code&gt;&lt;span&gt;large_&lt;/span&gt;&lt;/code&gt;&lt;span&gt;中分配的，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-line=&quot;390&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PageHeap&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; PageAllocatorInterface {&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//  大对象的内存从这里分配(length &amp;gt;= kMaxPages)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;SpanListPair large_ &lt;span&gt;ABSL_GUARDED_BY&lt;/span&gt;&lt;span&gt;(pageheap_lock)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-line=&quot;404&quot;&gt;&lt;span&gt;所以我们再加上大对象的分配时的&lt;/span&gt;&lt;code&gt;&lt;span&gt;large_&lt;/span&gt;&lt;/code&gt;&lt;span&gt;属性，得到&lt;/span&gt;&lt;code&gt;&lt;span&gt;PageHeap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的结构图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7SnFTLy1ljMl2MdBfx5urn61kgbxevNoHexY2NrPNPPv3PnyNXLavw4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.087962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图13)&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;410&quot;&gt;&lt;span&gt;同时&lt;/span&gt;&lt;code&gt;&lt;span&gt;PageHeap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;核心的代码片段如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-line=&quot;412&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PageHeap&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; PageAllocatorInterface {&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;// 持有两个Span构成的双向链表&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;SpanListPair&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Span构成的双向链表&lt;/span&gt;&lt;br/&gt;    SpanList normal; &lt;br/&gt;    &lt;span&gt;// Span构成的双向链表&lt;/span&gt;&lt;br/&gt;    SpanList returned;&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//  大对象的内存从这里分配(length &amp;gt;= kMaxPages)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;SpanListPair large_ &lt;span&gt;ABSL_GUARDED_BY&lt;/span&gt;&lt;span&gt;(pageheap_lock)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// kMaxPages.raw_num()这么多个，由上面SpanListPair类型构成的数组&lt;/span&gt;&lt;br/&gt;  SpanListPair free_[kMaxPages.raw_num()] ABSL_GUARDED_BY(pageheap_lock);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-line=&quot;438&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解密&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;&lt;span&gt;TransferCacheManager&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的构成&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-line=&quot;439&quot;&gt;&lt;strong&gt;&lt;span&gt;解密&lt;/span&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-line=&quot;420&quot;&gt;&lt;span&gt;我们可以&lt;/span&gt;&lt;span&gt;称之为中央缓存，中央缓存被线程共享&lt;/span&gt;&lt;span&gt;，从中央缓存&lt;/span&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;获取缓存需要加锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;422&quot;&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;里面有个属性&lt;/span&gt;&lt;code&gt;&lt;span&gt;size_class_&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，就是&lt;/span&gt;&lt;code&gt;&lt;span&gt;SizeClass&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的值，来自于映射表&lt;/span&gt;&lt;code&gt;&lt;span&gt;SizeMap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;这个数组的索引值。&lt;/span&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;里的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;会做一件事情，按照这个&lt;/span&gt;&lt;code&gt;&lt;span&gt;size_class_&lt;/span&gt;&lt;/code&gt;&lt;span&gt;值对应的规则拆解&lt;/span&gt;&lt;code&gt;&lt;span&gt;Span&lt;/span&gt;&lt;/code&gt;&lt;span&gt;为多个&lt;/span&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，同时这些&lt;/span&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;&lt;/code&gt;&lt;span&gt;构成&lt;/span&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;424&quot;&gt;&lt;span&gt;同时，&lt;/span&gt;&lt;code&gt;&lt;span&gt;SizeMap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;里的每个&lt;/span&gt;&lt;code&gt;&lt;span&gt;SizeClass&lt;/span&gt;&lt;/code&gt;&lt;span&gt;都会对应一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，所以最多一共会有N个&lt;/span&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，N的值为&lt;/span&gt;&lt;code&gt;&lt;span&gt;kNumClasses&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。关键代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-line=&quot;426&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CentralFreeList&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 锁&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 线程从此处获取内存 需要加锁 保证并发安全&lt;/span&gt;&lt;br/&gt;  absl::base_internal::SpinLock lock_;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 对应上文提到的映射表SizeClassInfo中的某个索引值&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 目的找到Span拆解为object时，object的大小等规则&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; size_class_;  &lt;br/&gt;  &lt;span&gt;// object的总数量&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; object_size_;&lt;br/&gt;  &lt;span&gt;// 一个Span持有的object的数量&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; objects_per_span_;&lt;br/&gt;  &lt;span&gt;// 一个Span持有的page的数量&lt;/span&gt;&lt;br/&gt;  Length pages_per_span_;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...略&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-line=&quot;450&quot;&gt;&lt;span&gt;如下图就展示了&lt;/span&gt;&lt;code&gt;&lt;span&gt;kNumClasses&lt;/span&gt;&lt;/code&gt;&lt;span&gt;个&lt;/span&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，其中我们以&lt;/span&gt;&lt;code&gt;&lt;span&gt;size_class_&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的值为&lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;&lt;span&gt;3&lt;/span&gt;&lt;/code&gt;&lt;span&gt;为例来展示下&lt;/span&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的结构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7SGYRnnGBNicUS6B5quQM5xsHUeDQgO9sZAFh4uwolDplpAvJV2btYfhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.9490740740740742&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图14)&lt;/span&gt;&lt;/p&gt;&lt;h3 data-line=&quot;479&quot;&gt;&lt;strong&gt;&lt;span&gt;解密&lt;/span&gt;&lt;code&gt;&lt;span&gt;TransferCacheManager&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-line=&quot;458&quot;&gt;&lt;span&gt;因为有&lt;/span&gt;&lt;code&gt;&lt;span&gt;kNumClasses&lt;/span&gt;&lt;/code&gt;&lt;span&gt;个&lt;/span&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，这些&lt;/span&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;在哪维护的呢？&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-line=&quot;460&quot;&gt;&lt;code&gt;&lt;p&gt;&lt;span&gt;答案：就是`TransferCacheManager`这个结构里的`freelist_`属性。&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-line=&quot;464&quot;&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-line=&quot;484&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TransferCacheManager&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;// freelist_是个数组&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 元素的类型是上面的CentralFreeList&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 元素的数量与 映射表 SizeClassInfo对应&lt;/span&gt;&lt;br/&gt;  CentralFreeList freelist_[kNumClasses];&lt;br/&gt;} ABSL_CACHELINE_ALIGNED;&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7SvDuU5Ul1VSv2rSwyfpic9QKXov0ACnDvf90ibSEyoVXibI3pTwJwiaPStQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6181818181818182&quot; data-w=&quot;770&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图15)&lt;/span&gt;&lt;/p&gt;&lt;h2 data-line=&quot;502&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解密&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;code&gt;&lt;span&gt;ThreadCache&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的构成&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-line=&quot;504&quot;&gt;&lt;span&gt;我们可以&lt;/span&gt;&lt;span&gt;称之为线程缓存，&lt;/span&gt;&lt;code&gt;&lt;span&gt;TCMalloc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;内存分配器的核心所在&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;code&gt;&lt;span&gt;ThreadCache&lt;/span&gt;&lt;/code&gt;&lt;span&gt;被每个线程持有，分配内存时&lt;/span&gt;&lt;span&gt;不用加锁&lt;/span&gt;&lt;span&gt;，性能好。&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;506&quot;&gt;&lt;code&gt;&lt;span&gt;ThreadCache&lt;/span&gt;&lt;/code&gt;&lt;span&gt;对象里维护了一个属性&lt;/span&gt;&lt;code&gt;&lt;span&gt;list_&lt;/span&gt;&lt;/code&gt;&lt;span&gt;类型是个数组，数组元素的类型是&lt;/span&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-line=&quot;508&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadCache&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// list_是个数组&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 元素的类型是FreeList&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 元素的数量与 映射表 SizeClassInfo对应&lt;/span&gt;&lt;br/&gt;  FreeList list_[kNumClasses]; &lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...略&lt;/span&gt;&lt;br/&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-line=&quot;521&quot;&gt;&lt;span&gt;同时&lt;/span&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;里的元素还具有以下特性：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;索引值为1对应的&lt;/span&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，该&lt;/span&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;&lt;/code&gt;&lt;span&gt;大小为8 Bytes；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;索引值为2对应的&lt;/span&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，该&lt;/span&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;&lt;/code&gt;&lt;span&gt;大小为16 Bytes；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;以此类推，&lt;/span&gt;&lt;code&gt;&lt;span&gt;free_&lt;/span&gt;&lt;/code&gt;&lt;span&gt;索引值为MaxNumber对应的&lt;/span&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，该&lt;/span&gt;&lt;code&gt;&lt;span&gt;FreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;&lt;/code&gt;&lt;span&gt;大小为MaxNumber Bytes；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MaxNumber的值由&lt;/span&gt;&lt;code&gt;&lt;span&gt;kNumClasses&lt;/span&gt;&lt;/code&gt;&lt;span&gt;决定&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-line=&quot;528&quot;&gt;&lt;span&gt;这个规则怎么来的？&lt;/span&gt;&lt;span&gt;还是取决于映射列表，同样以Google开源的TCMalloc源码(commit:9d274df)为例，来看一下这个映射列表：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-line=&quot;530&quot;&gt;&lt;p&gt;&lt;span&gt;https:&lt;span&gt;//github.com/google/tcmalloc/tree/master/tcmalloc&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;代码位置：tcmalloc/tcmalloc/size_classes.cc&lt;br/&gt;代码示例(摘取一部分)：&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; SizeClassInfo SizeMap::kSizeClasses[SizeMap::kSizeClassesCount] = {&lt;br/&gt;    &lt;span&gt;// 这里的每一行 称之为SizeClass&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// &amp;lt;bytes&amp;gt;, &amp;lt;pages&amp;gt;, &amp;lt;batch size&amp;gt;    &amp;lt;fixed&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Object大小列，一次申请的page数，一次移动的objects数(内存申请或回收)&lt;/span&gt;&lt;br/&gt;    {        &lt;span&gt;0&lt;/span&gt;,       &lt;span&gt;0&lt;/span&gt;,           &lt;span&gt;0&lt;/span&gt;},  &lt;span&gt;// +Inf%&lt;/span&gt;&lt;br/&gt;    {        &lt;span&gt;8&lt;/span&gt;,       &lt;span&gt;1&lt;/span&gt;,          &lt;span&gt;32&lt;/span&gt;},  &lt;span&gt;// 0.59%&lt;/span&gt;&lt;br/&gt;    {       &lt;span&gt;16&lt;/span&gt;,       &lt;span&gt;1&lt;/span&gt;,          &lt;span&gt;32&lt;/span&gt;},  &lt;span&gt;// 0.59%&lt;/span&gt;&lt;br/&gt;    {       &lt;span&gt;24&lt;/span&gt;,       &lt;span&gt;1&lt;/span&gt;,          &lt;span&gt;32&lt;/span&gt;},  &lt;span&gt;// 0.68%&lt;/span&gt;&lt;br/&gt;    {       &lt;span&gt;32&lt;/span&gt;,       &lt;span&gt;1&lt;/span&gt;,          &lt;span&gt;32&lt;/span&gt;},  &lt;span&gt;// 0.59%&lt;/span&gt;&lt;br/&gt;    {       &lt;span&gt;40&lt;/span&gt;,       &lt;span&gt;1&lt;/span&gt;,          &lt;span&gt;32&lt;/span&gt;},  &lt;span&gt;// 0.98%&lt;/span&gt;&lt;br/&gt;    {       &lt;span&gt;48&lt;/span&gt;,       &lt;span&gt;1&lt;/span&gt;,          &lt;span&gt;32&lt;/span&gt;},  &lt;span&gt;// 0.98%&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...略...&lt;/span&gt;&lt;br/&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-line=&quot;559&quot;&gt;&lt;span&gt;我们可以得到：&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;数组索引&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;FreeList里单个Object的大小&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;8 Bytes&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;16 Bytes&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;24 Bytes&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;4&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;32 Bytes&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;5&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;40 Bytes&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;...&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;...&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;kNumClasses&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;kNumClasses Bytes&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-line=&quot;571&quot;&gt;&lt;span&gt;得到&lt;/span&gt;&lt;code&gt;&lt;span&gt;ThreadCache&lt;/span&gt;&lt;/code&gt;&lt;span&gt;结构图如下所示：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-line=&quot;573&quot;&gt;&lt;code&gt;&lt;p&gt;&lt;span&gt;注意：图示中索引为3的FreeList的Span尾部会浪费掉8字节。&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7ScLSt5c9fxqKMKz3FGgNy6me4OP5KP6sEFbIFA7mWvVgxsXzX7Msq1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.924074074074074&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图16)&lt;/span&gt;&lt;/p&gt;&lt;h1 data-line=&quot;581&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解密&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;code&gt;&lt;span&gt;Tcmalloc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;内存分配过程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p data-line=&quot;583&quot;&gt;本小节的内容如下：&lt;/p&gt;&lt;blockquote data-line=&quot;561&quot;&gt;&lt;p data-line=&quot;561&quot;&gt;目的：了解&lt;code&gt;Tcmalloc&lt;/code&gt;内存分配的大致过程。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-line=&quot;563&quot;&gt;&lt;span&gt;简易版&lt;/span&gt;&lt;/h2&gt;&lt;p data-line=&quot;565&quot;&gt;&lt;span&gt;我们把&lt;/span&gt;&lt;code&gt;&lt;span&gt;Tcmalloc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;中分配的对象分为两类：&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;570&quot;&gt;&lt;span&gt;小对象的大小范围就来自于&lt;/span&gt;&lt;code&gt;&lt;span&gt;SizeMap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;维护的映射表，也就是单个&lt;/span&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的大小范围，我们还是以如下代码片段为例，可知单个&lt;/span&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;&lt;/code&gt;&lt;span&gt;大小范围为：&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-line=&quot;572&quot;&gt;&lt;p data-line=&quot;572&quot;&gt;&lt;span&gt;8 Byte ~ 262144 Byte == 8 Byte ~ &lt;/span&gt;&lt;span&gt;256 KB&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code data-line=&quot;574&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;const&lt;/span&gt; SizeClassInfo SizeMap::kSizeClasses[SizeMap::kSizeClassesCount] = {&lt;br/&gt;    &lt;span&gt;// 这里的每一行 称之为SizeClass&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// &amp;lt;bytes&amp;gt;, &amp;lt;pages&amp;gt;, &amp;lt;batch size&amp;gt;    &amp;lt;fixed&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Object大小列，一次申请的page数，一次移动的objects数(内存申请或回收)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...略...&lt;/span&gt;&lt;br/&gt;    {        &lt;span&gt;8&lt;/span&gt;,       &lt;span&gt;1&lt;/span&gt;,          &lt;span&gt;32&lt;/span&gt;},  &lt;span&gt;// 0.59%&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...略...&lt;/span&gt;&lt;br/&gt;    {   &lt;span&gt;262144&lt;/span&gt;,      &lt;span&gt;32&lt;/span&gt;,           &lt;span&gt;2&lt;/span&gt;},  &lt;span&gt;// 0.02%&lt;/span&gt;&lt;br/&gt;};&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-line=&quot;586&quot;&gt;&lt;span&gt;所以：&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;大小&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;来源&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;小对象&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&amp;lt;= 256 KB&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;span&gt;ThreadCache&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;非小对象&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&amp;gt; 256 KB&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;span&gt;PageHeap.free_&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;&lt;span&gt;PageHeap.large_&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-line=&quot;593&quot;&gt;&lt;span&gt;&lt;strong&gt;当给小对象分配内存时：&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;ThreadCache&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的内存不足时，从对应&lt;/span&gt;&lt;code&gt;&lt;span&gt;SizeClass&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;获取，如果获取不到，&lt;/span&gt;&lt;code&gt;&lt;span&gt;CentralFreeList&lt;/span&gt;&lt;/code&gt;&lt;span&gt;再从&lt;/span&gt;&lt;code&gt;&lt;span&gt;PageHeap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;里获取内存。&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;595&quot;&gt;&lt;span&gt;&lt;strong&gt;当给非小对象分配内存时：&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;PageHeap.free_&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;&lt;span&gt;PageHeap.large_&lt;/span&gt;&lt;/code&gt;&lt;span&gt;里获取。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7S1oS5zfe4l9geWia0AkYhy1fcYUicnJLDTPxVay0RBicdS9Qic46k2L6YpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.8731481481481481&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图17)&lt;/span&gt;&lt;/p&gt;&lt;h1 data-line=&quot;601&quot;&gt;&lt;strong&gt;&lt;span&gt;详细版本&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p data-line=&quot;603&quot;&gt;&lt;span&gt;最后，我们以获取&lt;/span&gt;&lt;code&gt;&lt;span&gt;6&lt;/span&gt;&lt;/code&gt;&lt;span&gt;字节的小对象为例&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;code&gt;&lt;span&gt;SizeClass&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的值为&lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，看一下详细内存分配过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdhrGTc9RVWTsUghcgbhDe7SNCGEE0oFtiazJRocwiczSTUBvWmR8Rk90SN44lr1I2uTUr7pNBZE0q1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.8953703703703704&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;图18)&lt;/span&gt;&lt;/p&gt;&lt;h1 data-line=&quot;610&quot;&gt;&lt;span&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p data-line=&quot;612&quot;&gt;&lt;span&gt;简单总结下，本篇文章我们可以获取到的知识点：&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;623&quot;&gt;&lt;span&gt;通过学习以上内容，再回过头学习Go语言的内存分配，应该会变得轻松明了。&lt;/span&gt;&lt;span&gt;下次我们就来看看Go内存设计与实现。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-line=&quot;610&quot;&gt;&lt;code&gt;&lt;p&gt;&lt;span&gt;参考：&lt;br/&gt;1. tcmalloc源码(commit:9d274df) https://github.com/google/tcmalloc/tree/master/tcmalloc&lt;br/&gt;2. 可利用空间表（Free List）https://songlee24.github.io/2015/04/08/free-list/&lt;br/&gt;3. 图解 TCMalloc https://zhuanlan.zhihu.com/p/29216091&lt;br/&gt;4. TCMalloc解密 https://wallenwang.com/2018/11/tcmalloc/&lt;br/&gt;5. TCMalloc : Thread-Caching Malloc https://github.com/google/tcmalloc/blob/master/docs/design.md&lt;br/&gt;6. TCMalloc : Thread-Caching Malloc https://gperftools.github.io/gperftools/tcmalloc.html&lt;br/&gt;7. tcmalloc原理剖析(基于gperftools-2.1) http://gao-xiao-long.github.io/2017/11/25/tcmalloc/&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n591&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;关于我的常用画图软件：&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;1. Balsamiq Mockups 3&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;2. Processon&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Go轻松进阶系列&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 更多文章&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TiccVmMZ3icdgDGUicDlY5kWW5P7CL4n2Uf7xYPLAEo3zFQxsYSDeHbticPicM8eJnZia0HM6pFhFK0rVmKKX0X4CbBg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.06302521008403361&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/TiccVmMZ3icdjOmxkheVnwCeibLWia2yTSSAnu4wH1RgmdCrGrIicz5oicSN5gbZxKaiaZ3oicxDC3iaOCm92d2VjbqGMmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;714&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools-id=&quot;36694&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.375&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/TiccVmMZ3icdiazAwOwey9wAIliamDeGicTOXib4HFynOX3BUxJMO7b4Azq3fNx3JgEwKU3NMG3N2hLLfIsqCUJMd43w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;40&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5129af3c2d51bedfddb3d6b25877b715</guid>
<title>Elasticsearch 聚合性能优化六大猛招</title>
<link>https://toutiao.io/k/otz7tnk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、问题引出&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;默认情况下，Elasticsearch 已针对大多数用例进行了优化，确保在写入性能和查询性能之间取得平衡。我们将介绍一些聚合性能优化的可配置参数，其中部分改进是以牺牲写入性能为代价的。目标是将聚合优化招数汇总到一个易于消化的短文中，为大家的 Elasticsearch 集群聚合性能优化提供一些指导。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、聚合实战问题&lt;br/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;问题1：1天的数据 70W,聚合2次分桶正常查询时间是 200ms左右, 增加了一个去重条件, 就10-13秒了,有优化的地方不？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;问题2：请问在很多 terms 聚合的情况下，怎样优化检索？我的场景在无聚合时，吞吐量有 300，在加入 12 个聚合字段后，吞吐量不到20。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;问题3：哪位兄弟 帮忙发一个聚合优化的链接，我这个聚合 几千万 就好几秒了？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、认知前提&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;3.1 Elasticsearch 聚合是不严格精准的&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;原因在于：数据分散到多个分片，聚合是每个分片的取 Top X，导致结果不精准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看一下之前的文章：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDY1MTA3OQ==&amp;amp;mid=2247484963&amp;amp;idx=1&amp;amp;sn=bde824fd0d01b1deffe92c22ab717f4a&amp;amp;chksm=eaa82e0bdddfa71d26663b9ffb0a50c2a0247c72710d428f9456678e5934b23cd078680f3ce4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Elasticsearch 聚合数据结果不精确，怎么破？&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Elasticsearch 聚合数据结果不精确，怎么破？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;3.2 从业务层面规避全量聚合&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;聚合结果的精准性和响应速度之间是相对矛盾的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正常业务开发，产品经理往往要求：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第一：快速秒级或者毫秒级聚合响应。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第二：聚合结果精准。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;殊不知，二者不可兼得。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;遇到类似两者都要兼得的需求，建议从架构选型和业务层面做规避处理。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;3.3 刷新频率&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如下图所示，Elasticsearch 中的 1 个索引由一个或多个分片组成，每个分片包含多个segment（段），每一个段都是一个倒排索引。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 lucene 中，为了实现高索引速度，使用了segment 分段架构存储。一批写入数据保存在一个段中，其中每个段最终落地为磁盘中的单个文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5511551155115512&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9axLPZGcvOzRLYEHKPs18ktKCiapicu0BwTcoPGdWMkAJHSvtcq0ibHp6Bu1Q5xnDNH1nZ9IG3NAWDQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;606&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示，将文档插入 Elasticsearch 时，它们会被写入缓冲区中，然后在刷新时定期从该缓冲区刷新到段中。刷新频率由 refresh_interval 参数控制，默认每1秒发生一次。也就是说，新插入的文档在刷新到段（内存中）之前，是不能被搜索到的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4216417910447761&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9axLPZGcvOzRLYEHKPs18ktm2Y7WeybYD9ugG64IcjmHUtguAPibAWiaFXtibvciaSZWvXmotCmQNAZBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刷新的&lt;strong&gt;&lt;span&gt;本质&lt;/span&gt;&lt;/strong&gt;是：写入数据由内存 buffer 写入到内存段中，以保证搜索可见。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来看个例子，加深对 refresh_inteval  的理解，注释部分就是解读。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;PUT test_0001/_doc/1&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;title&quot;&lt;/span&gt;:&lt;span&gt;&quot;just testing&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;# 默认一秒的刷新频率，秒级可见（用户无感知）&lt;/span&gt;&lt;br/&gt;GET test_0001/_search&lt;br/&gt;&lt;br/&gt;DELETE test_0001&lt;br/&gt;&lt;span&gt;# 设置了60s的刷新频率&lt;/span&gt;&lt;br/&gt;PUT test_0001&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;settings&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;index&quot;&lt;/span&gt;:{&lt;br/&gt;      &lt;span&gt;&quot;refresh_interval&quot;&lt;/span&gt;:&lt;span&gt;&quot;60s&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;PUT test_0001/_doc/1&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;title&quot;&lt;/span&gt;:&lt;span&gt;&quot;just testing&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;# 60s后才可以被搜索到&lt;/span&gt;&lt;br/&gt;GET test_0001/_search&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;关于是否需要实时刷新：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于刷新频率对查询性能的影响：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于每刷新一次都会生成一个 Lucene 段，刷新频率越小就意味着同样时间间隔，生成的段越多。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每个段都要消耗句柄和内存。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每次查询请求都需要轮询每个段，轮询完毕后再对结果进行合并。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;也就意味着：refresh_interval 越小，产生的段越多，搜索反而会越慢；反过来说，加大 refresh_interval，会相对提升搜索性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、聚合性能优化猛招&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;4.1    启用 eager global ordinals 提升高基数聚合性能&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;高基数聚合场景中的高基数含义：一个字段包含很大比例的唯一值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;global ordinals 中文翻译成&lt;span&gt;全局序号&lt;/span&gt;，是一种数据结构，应用场景如下：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于 keyword，ip 等字段的分桶聚合，包含：terms聚合、composite 聚合等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于text 字段的分桶聚合（前提条件是：fielddata 开启）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于父子文档 Join 类型的 has_child 查询和 父聚合。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;global ordinals 使用一个数值代表字段中的字符串值，然后为每一个数值分配一个 bucket（分桶）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;global ordinals 的&lt;strong&gt;&lt;span&gt;本质&lt;/span&gt;&lt;/strong&gt;是：启用 eager_global_ordinals 时，会在刷新（refresh）分片时构建全局序号。这将构建全局序号的成本从搜索阶段转移到了数据索引化（写入）阶段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;创建索引的同时开启：eager_global_ordinals。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;PUT my-index-000001&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;mappings&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;properties&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;tags&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;keyword&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;eager_global_ordinals&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;注意&lt;/span&gt;&lt;span&gt;：开启 eager_global_ordinals 会影响写入性能，因为每次刷新时都会创建新的全局序号。为了最大程度地减少由于频繁刷新建立全局序号而导致的额外开销，请调大刷新间隔 refresh_interval。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;动态调整刷新频率的方法如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;PUT my-index-000001/_settings&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;index&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;refresh_interval&quot;&lt;/span&gt;: &lt;span&gt;&quot;30s&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;该招数的&lt;/span&gt;&lt;span&gt;本质&lt;/span&gt;&lt;span&gt;是：以空间换时间。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;4.2 插入数据时对索引进行预排序&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;Index sorting （索引排序）可用于在插入时对索引进行预排序，而不是在查询时再对索引进行排序，这将提高范围查询（range query）和排序操作的性能。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;在 Elasticsearch 中创建新索引时，可以配置如何对每个分片内的段进行排序。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;这是 Elasticsearch 6.X 之后版本才有的特性。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Index sorting 实战举例：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;PUT my-index-000001&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;settings&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;index&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;sort.field&quot;&lt;/span&gt;: &lt;span&gt;&quot;cur_time&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;sort.order&quot;&lt;/span&gt;: &lt;span&gt;&quot;desc&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;mappings&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;properties&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;cur_time&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;date&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;如上示例是在：创建索引的设置部分设置待排序的字段：cur_time 以及 排序方式：desc 降序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意&lt;/span&gt;&lt;span&gt;：预排序将增加 Elasticsearch 写入的成本。在某些用户特定场景下，开启索引预排序会导致大约 40%-50% 的写性能下降。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也就是说，如果用户场景更关注写性能的业务，开启索引预排序不是一个很好的选择。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;4.3 使用节点查询缓存&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;节点查询缓存（Node query cache）可用于有效缓存过滤器（filter）操作的结果。如果多次执行同一 filter 操作，这将很有效，但是即便更改过滤器中的某一个值，也将意味着需要计算新的过滤器结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如，由于 “now” 值一直在变化，因此无法缓存在过滤器上下文中使用 “now” 的查询。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那怎么使用缓存呢？通过在 now 字段上应用 &lt;/span&gt;&lt;span&gt;datemath &lt;/span&gt;&lt;span&gt;格式将其四舍五入到最接近的分钟/小时等，可以使此类请求更具可缓存性，以便可以对筛选结果进行缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于 datemath 格式及用法，举个例子来说明：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下的示例，无法使用缓存。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;PUT index/_doc/1&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;my_date&quot;&lt;/span&gt;: &lt;span&gt;&quot;2016-05-11T16:30:55.328Z&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;GET index/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;constant_score&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;filter&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;range&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;my_date&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;gte&quot;&lt;/span&gt;: &lt;span&gt;&quot;now-1h&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;lte&quot;&lt;/span&gt;: &lt;span&gt;&quot;now&quot;&lt;/span&gt;&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;但是，下面的示例就可以使用节点查询缓存。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;GET index/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;constant_score&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;filter&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;range&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;my_date&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;gte&quot;&lt;/span&gt;: &lt;span&gt;&quot;now-1h/m&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;lte&quot;&lt;/span&gt;: &lt;span&gt;&quot;now/m&quot;&lt;/span&gt;&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;上述示例中的“now-1h/m” 就是 datemath 的格式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更细化点说，如果当前时间 now 是：16:31:29，那么range query 将匹配 my_date 介于：15:31:00 和 15:31:59 之间的时间数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同理，聚合的前半部分 query 中如果有基于时间查询，或者后半部分 aggs 部分中有基于时间聚合的，建议都使用 datemath 方式做缓存处理以优化性能。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;4.4 使用分片请求缓存&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;聚合语句中，设置：size：0，就会使用分片请求缓存缓存结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;size = 0 的含义是：只返回聚合结果，不返回查询结果。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;GET /my_index/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 0,&lt;br/&gt;  &lt;span&gt;&quot;aggs&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;popular_colors&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;terms&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;field&quot;&lt;/span&gt;: &lt;span&gt;&quot;colors&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;4.5 拆分聚合，使聚合并行化&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;这里有个认知前提：Elasticsearch 查询条件中同时有多个条件聚合，这个时候的多个聚合&lt;/span&gt;&lt;span&gt;不是并行&lt;/span&gt;&lt;span&gt;运行的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里就有疑问：是不是可以通过 msearch 拆解多个聚合为单个子语句来改善响应时间？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么意思呢，给个 Demo，toy_demo_003 数据来源：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDY1MTA3OQ==&amp;amp;mid=2247485927&amp;amp;idx=1&amp;amp;sn=23f46f436890627523abfbc6f65cda1d&amp;amp;chksm=eaa821cfdddfa8d93cc4fe2c9a655a65e5e21367f89be93ec79d0479936ee125a97811cb9b4d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;基于儿童积木玩具图解 Elasticsearch 聚合&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下响应时间：15 ms。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;POST toy_demo_003/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 0,&lt;br/&gt;  &lt;span&gt;&quot;aggs&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;hole_terms_agg&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;terms&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;field&quot;&lt;/span&gt;: &lt;span&gt;&quot;has_hole&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;max_aggs&quot;&lt;/span&gt;:{&lt;br/&gt;      &lt;span&gt;&quot;max&quot;&lt;/span&gt;:{&lt;br/&gt;        &lt;span&gt;&quot;field&quot;&lt;/span&gt;:&lt;span&gt;&quot;size&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;如下响应时间：9 ms。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;POST _msearch&lt;br/&gt;{&lt;span&gt;&quot;index&quot;&lt;/span&gt; : &lt;span&gt;&quot;toy_demo_003&quot;&lt;/span&gt;}&lt;br/&gt;{&lt;span&gt;&quot;size&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;aggs&quot;&lt;/span&gt;:{&lt;span&gt;&quot;hole_terms_agg&quot;&lt;/span&gt;:{&lt;span&gt;&quot;terms&quot;&lt;/span&gt;:{&lt;span&gt;&quot;field&quot;&lt;/span&gt;:&lt;span&gt;&quot;has_hole&quot;&lt;/span&gt;}}}}&lt;br/&gt;{&lt;span&gt;&quot;index&quot;&lt;/span&gt; : &lt;span&gt;&quot;toy_demo_003&quot;&lt;/span&gt;}&lt;br/&gt;{&lt;span&gt;&quot;size&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;aggs&quot;&lt;/span&gt;:{&lt;span&gt;&quot;max_aggs&quot;&lt;/span&gt;:{&lt;span&gt;&quot;max&quot;&lt;/span&gt;:{&lt;span&gt;&quot;field&quot;&lt;/span&gt;:&lt;span&gt;&quot;size&quot;&lt;/span&gt;}}}}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;来个对比验证吧：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5824742268041238&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9axLPZGcvOzRLYEHKPs18ktI1gRADkFXdFMyH8VSr3aeIJWY22ibcA9wTOqXawZkVKVneL7LC73jhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;582&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;蓝色：类似示例一，单个query 中包含多个聚合，聚合数分别是：1,2,5,10。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;红色：类似示例二，multi_search 拆解多个聚合，拆分子句个数分别为：1,2,5,10。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;横轴：蓝色对应聚合个数；红色对应子句个数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;纵轴：响应时间，响应时间越短、性能越好。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;初步结论是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，在 CPU 资源不是瓶颈的前提下，如果想缩短响应时间，可以将多个聚合拆分为多个查询，借助：msearch 实现&lt;/span&gt;&lt;span&gt;并行聚合&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;4.6 将聚合中的查询条件移动到 query 子句部分&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;示例一：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;POST my_index/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 0,&lt;br/&gt;  &lt;span&gt;&quot;aggregations&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;1&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;filter&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;match&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;search_field&quot;&lt;/span&gt;: &lt;span&gt;&quot;text&quot;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;&quot;aggregations&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;items&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;top_hits&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 100,&lt;br/&gt;            &lt;span&gt;&quot;_source&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;includes&quot;&lt;/span&gt;: &lt;span&gt;&quot;field1&quot;&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;2&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;filter&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;match&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;search_field&quot;&lt;/span&gt;: &lt;span&gt;&quot;text&quot;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;&quot;aggregations&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;items&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;top_hits&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 100,&lt;br/&gt;            &lt;span&gt;&quot;_source&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;includes&quot;&lt;/span&gt;: &lt;span&gt;&quot;field2&quot;&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;示例二：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;{&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;bool&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;filter&quot;&lt;/span&gt;: [&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;&quot;match&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;search_field&quot;&lt;/span&gt;: &lt;span&gt;&quot;text&quot;&lt;/span&gt;&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      ]&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 0,&lt;br/&gt;  &lt;span&gt;&quot;aggregations&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;1&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;top_hits&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 100,&lt;br/&gt;        &lt;span&gt;&quot;_source&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;includes&quot;&lt;/span&gt;: &lt;span&gt;&quot;field1&quot;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;2&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;top_hits&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 100,&lt;br/&gt;        &lt;span&gt;&quot;_source&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;includes&quot;&lt;/span&gt;: &lt;span&gt;&quot;field2&quot;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;示例一和示例二的本质区别：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二个查询已将此过滤器提取到较高级别，这应使聚合共享结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下对比实验表明，由于 Elasticsearch 自身做了优化，示例一（蓝色）和示例二（红色）响应时间基本一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6020583190394511&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9axLPZGcvOzRLYEHKPs18ktGUjsH6k9Thb1GlcWmjJKuD9gYp01gZbictHzgPnD6IrpmsRZFHYibWNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;583&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更多验证需要结合业务场景做一下对比验证，精简起见，推荐使用第二种。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、更多优化参考&lt;/span&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;官方关于检索性能优化同样适用于聚合&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;https://www.elastic.co/guide/en/elasticsearch/reference/current/tune-for-search-speed.html&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分片数设置多少合理？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.elastic.co/cn/blog/how-many-shards-should-i-have-in-my-elasticsearch-cluster&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;堆内存大小设置？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.elastic.co/cn/blog/a-heap-of-trouble&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;禁用 swapping&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-configuration-memory.html&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6、小结&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;本文的六大猛招出自：Elastic 原厂咨询架构师 Alexander 以及 Coolblue 公司的软件开发工程师 Raoul Meyer。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;六大猛招中的 msearch 并行聚合方式，令人眼前一亮，相比我在业务实战中用的多线程方式实现并行，要“高级”了许多。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我结合自己的聚合优化实践做了翻译和扩展，希望对大家的聚合性能优化有所帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎留言写下您的聚合优化实践和思考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;和你一起，死磕 Elastic！&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h1&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://qbox.io/blog/refresh-flush-operations-elasticsearch-guide&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://alexmarquardt.com/how-to-tune-elasticsearch-for-aggregation-performance/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://www.elastic.co/cn/blog/index-sorting-elasticsearch-6-0&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;span&gt;《Elasticsearch 源码解析与优化实战》&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>01a1b6a5b0b7e042c4b8a9cb624b3330</guid>
<title>Druid 在贝壳的应用实践</title>
<link>https://toutiao.io/k/95913vp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.10625&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs4vfyIarcqibal6yAFianEqLI1zL9KxDsgjpSE63wBOibyzyynd160UIXAw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;1 背景&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;贝壳作为全国领先的房产交易和租赁在线服务平台，有很多业务场景会产出大量实时和离线数据，针对这些数据进行查询分析，对于企业发展和业务拓展至关重要。不同业务线不同查询场景下，单一技术手段很难满足业务方的需求，Druid就是我们在探索之路上发现的比较切合业务方需求的OLAP引擎之一。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3666667&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs4WPGQCbxToEWbap5ZSPaM0L5vnyId9wSUBP13VJuC7U8Nz8FeJBeyYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;表1.1 Druid与其他olap查询引擎对比&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过表格中列举的特性，我们可以大致了解每个引擎适用的查询业务场景，我们选择Druid引擎主要考虑三个方面要素：①查询灵活性②高并发能力③接入和运维成本，这些Druid都支持的比较好，可以解决之前在某些场景下使用Kylin引擎所遇到查询灵活性差、调优成本高、存储占用大等问题。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;2 Druid技术架构和关键技术介绍&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1 技术架构&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下图描述了Druid整体架构主要由四部分组成，即主服务节点(Master Servers)，查询服务节点(Query Servers)，数据服务节点(DataServers)以及外部依赖组件(ExternalDependencies)。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5631365&quot; data-w=&quot;982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs44mKTRu7tK6ia7Q6JTgGcHEnLq2DcI7zRE7s8qB5OSZZiaQicknwNzV6JA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图2.1 Druid技术架构&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Master Servers&lt;/span&gt;：运行Coordinator和Overlord进程，管理数据可用性和数据获取&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Query Servers&lt;/span&gt;：运行Broker和可选路由器Routor进程，处理来自外部客户端的查询&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Data Servers&lt;/span&gt;：运行Historical和MiddleManager，执行摄取工作负载并储存所有可查询数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;External Dependencies&lt;/span&gt;：除了内置的进程类型，Druid还有三个外部依赖，它们的目的是能够利用现有的基础设施&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Druid的三个外部依赖：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Deep Storage：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每个Druid服务器都可以访问共享文件存储。这通常是一个分布式对象存储如S3，或者是HDFS，或者是一个网络挂载的文件系统，Druid使用它来存储任何已经进入系统的数据，Druid只是使用Deep Storage作为数据备份，并且也作为Druid进程之间传输数据的一种方式。为了快速响应查询，历史进程不从Deep Storage中读取数据，而是从本地磁盘中读取预先存储好的segment，这意味意味着，您必须在Deep Storage和Historical进程中拥有足够的磁盘空间，以便加载数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Metadata Storage：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;元数据存储包含各种共享的系统元数据，如segment可用性信息和任务信息，这个通常是一个传统的RDBMS，如PostgreSQL或者MySql。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Zookeeper：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;用于内部服务发现，协调和leader选举，这个架构的作用是让Druid集群易于大规模扩展。例如将Deep Storage和Metadata Storage与集群其他部分分离，意味着Druid服务是完全容错的。即使一个Druid服务器失败了，整个集群稳定性不会受到影响。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 关键技术介绍&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Druid高性能查询依赖于自身设计合理的数据结构，包括预聚合、bitmap编码 、倒排索引等。下面简单分析一下Druid如何使用以上数据结构，提供一份样例数据 ,这是聚合后的数据，不是原始数据。有四个字段分别是house_type【房屋类型  0：商品房   1：公房 2：经济适用房】，city_name【城市名称】，look_cnt【带看量】，trade_cnt【成交量】。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4919236&quot; data-w=&quot;681&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs4aghldYUAfzTQHd1hWBHexibrpnCgic5WIw0B8fIgfBKAia9bxsK3KNcIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;表2.1 样例数据&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在Druid上生成的维度索引结构如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5004669&quot; data-w=&quot;1071&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs4ic8WUAwLwQTSMWKUQKW3tOqJtBbcdFujZ3ibbh1GMeXyt1ZDn8CPBIhA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图2.2 维度索引结构&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;以下列查询语句为例：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; city_name，&lt;span&gt;sum&lt;/span&gt;(look_cnt) &lt;span&gt;from&lt;/span&gt; table_sample &lt;span&gt;where&lt;/span&gt; house_type=&lt;span&gt;0&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; house_type=&lt;span&gt;1&lt;/span&gt; &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; city_name&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5268519&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs4xnZlqejHUzxibWT9JKqnQdnRkIgvv0Rbfvsxv5An1zdVkkI2C7DVhCA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图2.3 查询流程&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;3 实践与优化&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 离线场景&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Druid目前在我们团队中主要支撑离线指标业务，目前20+台规模的Druid集群，承载每日3000w+的查询总量，qps早高峰时段平均值400+，峰值1.2k+,  查询3s内到达率可以在99.9%以上，支撑业务线包括品牌、门店运营、店东、梅林、奥丁、数据看板、海外业务、装修等18+业务线。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.1.1 数据源构建时间优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1）数据导入&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Druid离线场景下使用的数据源主要以Hive表为主，其中Hive表按照业务分类为全量表和增量表，以时间作为分区字段。全量表每日数据量一般在年级别，表中的时间戳字段按天粒度分布。增量表为每日递增数据，表中的时间戳字段范围为一日。我们目前使用Hadoop index作业方式导入离线数据，整个数据导入步骤如下图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.237963&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs4IjUov9eoVrKoFCUwZwicJSjYH2pYlVyfKVTJ7icdGqb7UPEj37S5wEicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图3.1 离线数据导入Druid关键步骤&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在实际应用中，团队遇到每日分区数据量比较大的增量Hive表，在导入数据时候我们按照分区数据行数调整生成parquet文件的数量，从而增加数据摄入阶段map容器个数，同时指定合理的numShards数量，来增加reduce容器个数，通过这些举措提升数据源导入速度。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;例如我们针对1亿行非高基数列数据 ，repartition出20个分区，数据导入时候指定5个numShards，下图展示了近七日优化前和优化后数据导入时长对比：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4057816&quot; data-w=&quot;934&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs4VukJdWEBN1qaLItQn8zSMGgTjOFmfTrGICf1fAxckAKrLnWFvJRH1A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图3.2 近七日优化前后导入数据时长对比&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2）shards合并&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;针对指定numShards导入数据源，这种数据源主要以增量表数据为主，在导入完成后，每个Segment可能分出了若干个shard，每个shard大小，社区推荐是300-700MB左右，如果生产环境中产出每个shard大小比这个小很多，建议可以进行合并操作（compact），因为shard数量小而多的话，查询时候在历史节点上分布的很分散，浪费每个历史节点的CPU资源。相反，如果每个shard大小都比较大，不能很好分布到各个历史节点上，反而不能有效利用集群的CPU资源。说到这里，真是有点宝宝心里苦的感觉。在实际使用中，结合贝壳自身的业务特点，大部分数据源每日数据大小在300M以下，行数也在500w行以内，据此，我们针对每个Segment大小限制在500w行。如果是通过指定numShards导入数据源，每个segment中shards合并后的行数在500w行内。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3）工程实现&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们需要把这两个步骤做的更加智能，来加速不同类型数据源导入，下面完整介绍我们工程上实现思路：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5638889&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs41wYAKKgZQuoAibcSicwnCFtStDb2w3nxI3KV6Wk0KJLP5BvicQsErQ3RQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图3.3 加速离线数据导入实现思路&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.1.2 增加集群负载保护策略&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;刚才已经提到Druid集群承载每日3000w+的查询总量，qps也比较高，为了维护集群的稳定性，查询缓存/动态限流/超时控制是保护集群负载正常的必要手段。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1）查询缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;查询缓存，是降低Druid集群QPS查询量有效手段。我们对外提供的Druid服务主要由三层缓存构成，分别是指标查询缓存、 queryEngine缓存、Druid自身缓存。指标查询缓存是指我们对外提供api接口的缓存。queryEngine缓存是指上层api接口下发请求会分成若干个指标，这些指标会通过queryEngine翻译成底层引擎可理解的查询语言，queryEngine会缓存引擎的返回结果。Druid缓存是指Druid自身提供的Segment在Broker或者Historical上缓存。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3374578&quot; data-w=&quot;889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs4zDFR6kYub0jfRyqQ88ib7ibxSQF9BsHKVzLQjI3t9vqn5KhpuhibqcYPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图3.4 查询缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;使用查询缓存时，需要特别注意查询缓存清理，因为业务方数据有可能针对前一天或者上一小时的数据是有更正的。这块我们之前是通过hadoop index作业运行结束状态，来告知上次服务清理缓存，但随着数据源增多，会凸显出hadoop index作业结束时间和数据源可用于查询时间之间时差问题，当然可以通过扩充historical节点数量以及增加historical节点上druid.segmentCache.numLoadingThreads的线程数量来加速数据源从deep storage到segment cache落盘速度，但并不能从根本上解决问题。我们解决方案是：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3833333&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs44fd3ryiaA5ouZ7KFfH0OY3LYy8EBicmEchsROQwibWOKPic0mwf2dqexgw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图3.5 缓存清理&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2）动态限流&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;限流措施, 我们对Druid源码进行了改造，主要是Broker端去收集HIstorical的节点CPU负载情况, 评估近一分钟CPU SYSTEM LOAD情况，逼近限流CPU阈值，对近段查询量比较大的数据源进行评估，同时结合所属业务线的重要程度，在Broker端进行分级别的查询限流操作，降低Historical的CPU使用率。监测到CPU使用率恢复到警戒水平以下，查询限流操作会自动放开。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6562923&quot; data-w=&quot;739&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs4KjxSOSFnib4AT3gjianTN0B4CqBwxP1EhtR1GPCER4BzU8oF0KHA5VPA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图3.6 动态限流实现步骤&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;某一天早高峰时段Druid各节点CPU负载状态的统计，从下图可以看出“刺突”现象还是非常明显的，如果CPU长时间处于高负载状态【拉平状态】，会影响集群整体的查询效果，适当的资源释放，可以平衡各个业务方的查询需求。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2407407&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs4iaYppI9GeiaBCEPNDecHvicbZjdkuMFUIO6XWUrSWwHD1XnwOM8AfaVcA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图3.7 高峰期集群CPU负载监控&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3）超时控制&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;目前我们服务接收的查询语句主要集中在近一小时、近一天、近一周、近一月、近一季度、近半年、近一年甚至还会有近两年的聚合查询，时间跨度种类非常多，已经超越了近实时的查询场景。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于这些查询，查询超时控制的好与坏，直接影响集群整体性能。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Druid原生版本是支持超时控制的druid.server.http.defaultQueryTimeout【默认是5分钟】，我们实际应用中一般配置在15秒左右，但是这个配置并不能结合CPU负载状况灵活控制查询时长，所以我们针对Druid的QueryResource类进行了改进，采用异步线程结合Historical CPU在高峰和非高峰查询时段使用情况调节查询时长。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;改动点主要是针对doPost方法中调用的QueryLifecycle实例execute方法和Yielder类的each方法。execute方法用于获取可遍历的序列Sequence，each方法是返回的Yielder类自己内部已经存储好的计算结果，这两个方法在查询高峰期会是耗时的主要环节。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下图反映了我们采用超时控制之后，高峰期查询耗时情况：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3527778&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs4hzCLhUic0lMdPIGKzJRiaydeF06SaeVmpl0Qk5EponoYhStUPJxGRHHA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图3.8 高峰期查询耗时监控&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 实时场景&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;实时精确去重功能是结合贝壳在实时指标应用中有针对GMV和GSV统计，这些都会要求引擎有精确去重能力。&lt;/span&gt;&lt;span&gt;Druid原生版本精确去重能力比较弱，仅支持sql查询类型，native api不具备这项能力。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们团队借鉴社区对Druid实现的离线精确去重能力，在Druid 0.18.1版本上做了依赖Redis做存储字典实现实时精确去重功能。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;社区之前针对Redis作为存储字典也有过讨论，主要担心是Redis的并发能力，目前我们使用多套redis集群，结合公司自身实际情况，可以满足9w/s实时数据编码需求，一般在公司使用的单个Redis集群（cluster模式）160G内存，推荐QPS在5w上下，申请多个Redis集群提升并发能力，将不同数据源hash分配到不同的redis存储上。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6225989&quot; data-w=&quot;885&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs4ib74xtyup6FMzwKU6EAuIeVia77TU7JLhd7nHCDJUemOz5Y9nFs9lK6w/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图3.9 实时精确去重整体架构&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;实时精确去重功能主要分为两部分：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1) 字符串编码&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;所有类型其实都可以看作字符串类型，这里如何快速给字符串进行数值类型编码是解决问题的关键。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当时采用两种方案：一种是使用一个Redis集群提供全局自增id作为数据编码，但是对Redis qps压力会很大，所以就放弃了。另外一种使用Snowflake算法生成数值编码。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;需要特别说明的是这里我们提供SnowflakeId服务并不是一个集中式id生成服务器，因为考虑rest接口性能会影响到实时数据的摄取时延，我们采用解决办法是每个kafka index job会启动一个本地生成全局递增id服务，注意kafka index job的并发数量是受到限制的，至于为什么会收到限制，是因为snowflake算法中有10bit是用于工作机器标识，共1024个节点，每一个运行中kafka index job会占用一个节点ID。如果机器开启时间同步功能，为了防止ID出现小概率重复，kafka index job的并发数量还会进一步降低，不过没有关系，因为单个redis集群受到自身qps限制也不可能同时承载太多kafka index job并发访问储存字典编码, 如果要扩容任务并发量可以横向扩充redis存储个数，具体多少个redis合适，需要结合自身实际业务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2) 新增 CommonUnique 指标存储&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这个实现与社区实现离线精确去重Unique指标存储比较类似，唯一比较大的区别在于CommonUnique使用Roaring64NavigableMap，而社区离线版本精确去重使用的是32位的RoaringBitmap。CommonUnique使用Roaring64NavigableMap主要是因为Snowflake算法生成的是Long型数值编码，字典存储编码可以突破21亿基数（int能表示的最大基数）限制。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;主要新增类：&lt;/p&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;CommonUniqueComplexMetricSerde类继承ComplexMetricSerde基类，用于将该Serde注册到ComplexMetrics中，主要实现extractValue方法，输入行数据，根据metricName获取度量字段的value值，经过数值编码后存储到redis存储中，并返回当前bitmap编码，用于持久化到segment文件中&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;CommonUniqueAggregator类用于实现数据聚合，用于数据查询操作，这里主要实现Buffer版本 BufferAggregator，关键的方法是aggregate和get&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;CommonUniqueAggregatorFactory工厂类，继承AggregatorFactory类，用于定义具体的Aggregator&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;实时精确的使用方法：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据摄入时，定义CommonUnique类型指标：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&quot;metricsSpec&quot;&lt;/span&gt;: [&lt;br/&gt;&lt;br/&gt;  {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;count&quot;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;count&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  },&lt;br/&gt;&lt;br/&gt;  {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;commonUnique&quot;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;date_agent_ucid_unique&quot;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;fieldName&quot;&lt;/span&gt;: &lt;span&gt;&quot;date_agent_ucid&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  },&lt;br/&gt;&lt;br/&gt;  {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;commonUnique&quot;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;date_open_id_unique&quot;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;fieldName&quot;&lt;/span&gt;: &lt;span&gt;&quot;date_open_id&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  }]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据查询时，使用CommonUnique类型查询：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&quot;queryType&quot;&lt;/span&gt;: &lt;span&gt;&quot;groupBy&quot;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&quot;dataSource&quot;&lt;/span&gt;: {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;table&quot;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;user_action_sa_cube_v1&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  },&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&quot;intervals&quot;&lt;/span&gt;: {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;intervals&quot;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;intervals&quot;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;[&lt;span&gt;&quot;2020-09-04T00:00:00.000Z/2020-09-07T00:00:00.000Z&quot;&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;  },&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&quot;granularity&quot;&lt;/span&gt;: {&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;all&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;   },&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&quot;dimensions&quot;&lt;/span&gt;: [&lt;span&gt;&quot;entity_id&quot;&lt;/span&gt;],&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&quot;aggregations&quot;&lt;/span&gt;: [{&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;commonUnique&quot;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;date_open_id_unique&quot;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;&quot;fieldName&quot;&lt;/span&gt;: &lt;span&gt;&quot;date_open_id_unique&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;   }]&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;3.3 平台化建设&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;有了满足业务方查询需求的olap查询引擎，我们怎么才能更好地服务业务方，平台化是我们最好的落地方式。依托Druid作为主引擎，兼容其他引擎能力，从而在上层统一规划设计我们的olap系统，架构如下图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3888889&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs4VJnzSGzgNW278FhIgnU8S0ybqYib2FS0g5qdZqZhvVZhF7JqLm3pPFw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图4.1 OLAP系统整体架构&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;平台层vili承担着我们整个Olap系统落地实践任务，vili主要提供六方面能力：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;数仓建模&lt;/span&gt;：用于定义离线数据（以hive为主）和实时数据（用Flink加工后输出到kafka的数据），限定业务度量规范，方便各业务线统一使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cube建模&lt;/span&gt;：这里是参考Kylin Cube的设计思想，为了统一底层引擎导入数据源规范。Model用于定义事实表和维度表的join关系，指定维度字段和度量字段。Cube是在Model层上再选取，选取需要作为指标查询的维度和度量，同时指定度量规则，Model和Cube的关系可以是一对多。Cube建立完成后，平台针对离线Cube会帮助用户自动配置例行调度作业，可进行小时级、天级、周级、月级、年级周期配置。针对实时Cube配置完成后，会根据底层引擎类型采用采取不同操作，如果选择的是Druid引擎会启动Kafka index job，生成实时数据源；如果是ClickHouse引擎类型，会直接写入ClickHouse存储中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;指标定义&lt;/span&gt;：用于定义指标信息，包括指标名称、说明、计算口径、口径描述、聚合方式等内容， 同时可以切换底层查询引擎类型，引擎与引擎之间可以互备。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;指标加工&lt;/span&gt;：基于“指标定义“的指标，再进行自定义计算形成的指标。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;指标查询API&lt;/span&gt;：提供统一的OLAP引擎查询接口，屏蔽底层引擎差异。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;工具&lt;/span&gt;：提供重刷Model元数据、数据补录、不同引擎查询数据对比方便指标迁移引擎等功能。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;4 未来的规划&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.实时指标在Druid深入实践&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;目前我们使用Druid引擎主要应用在离线数据查询场景，在实时指标应用才刚进入轨道，后续我们重点在此方面发力，因为当下实时指标主要承载在ClickHouse上，Clickhouse视图构建等操作对用户来说接入门槛较高，运维起来负担也较重。Doris引擎承载实时指标也在紧罗密布测试当中，这块主要是看中Doris支持数据update功能，Druid这方面是欠缺的，后续考虑在Druid实现此功能。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.离线数据导入速度进一步加速&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;研究spark加速离线数据导入可行性，替换现有mapreduce作业导入方式，同时针对index_parallel导入数据方式，增加精确去重编码的能力，尝试利用hive作为全局字典存储，参考kylin4.0版本的实现。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.数据查询速度优化和物化视图的应用&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;特别是针对高基数列数据源查询，因为高基维度会影响 Druid 的数据预聚合效果，聚合效果差就会导致索引文件 Size 变大，进而导致查询时的读 IO 变大，整体查询性能变差。针对这种 case 的优化，我们会将低基数列常用维度分别建一个预聚合索引，然后当收到新的查询请求，系统会先分析请求里要查询维度集合，如果要查询的维度集合是刚才新建的专用的索引维度集合的一个子集，则直接访问刚才新建的索引就可以，不需要去访问原始的聚合索引，查询的性能会有一个比较明显的改善。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.平台化工作进一步深入开展&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;引擎层与业务有关功能进一步剥离到平台层 。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1）平台侧针对引擎层元数据、数据源、分片信息、任务详情和日志信息等用户关心的信息进一步整合到平台层，方便用户了解数据源和任务执行状态，同时也方便开发人员统一管理多套OLAP集群。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2）针对API限流操作在平台层控制，不同业务线根据业务实际情况设置不同quota数量，底层引擎不感知业务线类型，只关心可以提供服务的总计quota数量，使得底层引擎和业务线解耦，更加专注做好通用底层服务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4453125&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Rcon9f6LyEueHpffo1IXbEiaZIiclhVQs4kjhP2QulBnyOa6QX4EciaqtjqLKRIzibHjfibOHcHJiaqR4JZUVk04FVKA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>