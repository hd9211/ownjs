<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>71f3140ecd1900b527285437c4830154</guid>
<title>重磅发布：Redis 对象映射框架来了，操作大大简化！</title>
<link>https://toutiao.io/k/e8mej42</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7042910447761194&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfeKxvZLoK4uicwXk7v9v5gWmSxIVatXZIwLd3m9sH4Y1zJf287s1teRCKTMALZIqial0icXjCk9wnegg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1072&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近，Redis 官方博客宣布推出四个用于 Redis 的客户端工具库：Redis OM（对象映射库，Object Mapping），目标是让应用程序尽可能地容易使用 Redis 和 Redis 模块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;四个客户端工具库分别对应四种编程语言&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Redis OM for .NET：&lt;/strong&gt; .Net 平台的 Redis OM，依赖 StackExchange.Redis 实现。借助 Redis OM .NET 可以实现对象操作的方式操作 Redis 数据，脱离 key/value 的操作方式。查询支持大部分.Neter 最爱的 LINQ。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Redis OM for Node.js：&lt;/strong&gt; 为 TypeScript 和 JavaScript 提供一级支持&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Redis OM for Python：&lt;/strong&gt; 原生集成流行的 FastAPI 框架，将 FastAPI 与 Redis 结合可构建高性能 Web 服务。Redis OM Python 库还支持同步和异步使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Redis OM for Spring：&lt;/strong&gt; 原生集成 Spring，扩展了 Spring Data Redis（提供熟悉的界面），添加了对 RedisBloo 的部分支持。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换言之，在之后的开发中，开发者可以通过 Redis OM 库直观地将域对象 (domain objects) 保存在 Redis，然后使用流畅的、以语言为中心的 API 进行查询。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;推荐下自己做的 Spring Boot 的实战项目：&lt;/p&gt;&lt;p&gt;https://github.com/YunaiV/ruoyi-vue-pro&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一枚java开发，我们重点了解一下 Redis OM for Spring。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis OM for Spring提供了强大的存储库和基于强大的 Spring Data Redis (SDR) 框架构建的自定义对象映射抽象。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;@Document&lt;/code&gt; 将 Spring Data 模型映射到 Redis JSON 文档的注释&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;@RedisHash&lt;/code&gt;通过以下方式增强 SDR &lt;code&gt;@EnableRedisEnhancedRepositories&lt;/code&gt;：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 Redis 的原生搜索引擎 (RediSearch) 进行二级索引&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将ULID用于带@Id注释的字段&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;RedisDocumentRepository&lt;/code&gt; 自动实现存储库接口以实现复杂的查询功能，使用 &lt;code&gt;@EnableRedisDocumentRepositories&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;声明性搜索索引通过 &lt;code&gt;@Indexable&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;全文检索索引通过 &lt;code&gt;@Searchable&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;@Bloom&lt;/code&gt; 注释可以非常快速地确定一个值是否在集合中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过案例来了解一下Redis OM for Spring的具体用法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相关依赖&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前快照地址&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &amp;lt;repositories&amp;gt;&lt;br/&gt;    &amp;lt;repository&amp;gt;&lt;br/&gt;      &amp;lt;id&amp;gt;snapshots-repo&amp;lt;/id&amp;gt;&lt;br/&gt;      &amp;lt;url&amp;gt;https:&lt;span&gt;//s01.oss.sonatype.org/content/repositories/snapshots/&amp;lt;/url&amp;gt;&lt;/span&gt;&lt;br/&gt;    &amp;lt;/repository&amp;gt;&lt;br/&gt;  &amp;lt;/repositories&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pom文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;  &amp;lt;groupId&amp;gt;com.redis.om&amp;lt;/groupId&amp;gt;&lt;br/&gt;  &amp;lt;artifactId&amp;gt;redis-om-spring&amp;lt;/artifactId&amp;gt;&lt;br/&gt;  &amp;lt;version&amp;gt;${version}&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SpringBoot配置&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.redis.om.documents;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.Set;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.beans.factory.annotation.Autowired;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.boot.CommandLineRunner;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.boot.SpringApplication;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.context.annotation.Bean;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.context.annotation.Configuration;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.data.geo.Point;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.redis.om.documents.domain.Company;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.redis.om.documents.repositories.CompanyRepository;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@EnableRedisDocumentRepositories&lt;/span&gt;(basePackages = &lt;span&gt;&quot;com.redis.om.documents.*&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RomsDocumentsApplication&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;  CompanyRepository companyRepo;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;CommandLineRunner &lt;span&gt;loadTestData&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; args -&amp;gt; {&lt;br/&gt;      companyRepo.deleteAll();&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 创建两组实体域 redis &amp;amp; microsoft&lt;/span&gt;&lt;br/&gt;      Company redis = Company.of(&lt;br/&gt;        &lt;span&gt;&quot;Redis&quot;&lt;/span&gt;, &lt;span&gt;&quot;https://redis.com&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Point(-&lt;span&gt;122.066540&lt;/span&gt;, &lt;span&gt;37.377690&lt;/span&gt;), &lt;span&gt;526&lt;/span&gt;, &lt;span&gt;2011&lt;/span&gt; &lt;br/&gt;      );&lt;br/&gt;      redis.setTags(Set.of(&lt;span&gt;&quot;fast&quot;&lt;/span&gt;, &lt;span&gt;&quot;scalable&quot;&lt;/span&gt;, &lt;span&gt;&quot;reliable&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;      Company microsoft = Company.of(&lt;br/&gt;        &lt;span&gt;&quot;Microsoft&quot;&lt;/span&gt;, &lt;span&gt;&quot;https://microsoft.com&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Point(-&lt;span&gt;122.124500&lt;/span&gt;, &lt;span&gt;47.640160&lt;/span&gt;), &lt;span&gt;182268&lt;/span&gt;, &lt;span&gt;1975&lt;/span&gt; &lt;br/&gt;      );&lt;br/&gt;      microsoft.setTags(Set.of(&lt;span&gt;&quot;innovative&quot;&lt;/span&gt;, &lt;span&gt;&quot;reliable&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 将创建的两组实体域持久化&lt;/span&gt;&lt;br/&gt;      companyRepo.save(redis);&lt;br/&gt;      companyRepo.save(microsoft);&lt;br/&gt;    };&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    SpringApplication.run(RomsDocumentsApplication&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;args&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体使用上非常清晰，重点是类上开启&lt;code&gt;@EnableRedisDocumentRepositories&lt;/code&gt;注解，就可以注入可用于 CRUD 操作和自定义查询的&lt;code&gt;@Document&lt;/code&gt;存储库 bean。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实体对象映射&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个我们使用SpringBoot非常熟悉，Redis OM Spring 也提供&lt;code&gt;@Document&lt;/code&gt;注释来为我们将模型保存为 JSON 文档&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.redis.om.documents.domain;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.HashSet;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.Set;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.data.annotation.Id;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.data.geo.Point;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.redis.om.spring.annotations.Document;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.redis.om.spring.annotations.Searchable;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; lombok.*;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequiredArgsConstructor&lt;/span&gt;(staticName = &lt;span&gt;&quot;of&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@AllArgsConstructor&lt;/span&gt;(access = AccessLevel.PROTECTED)&lt;br/&gt;&lt;span&gt;@Document&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Company&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;@Id&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; String id;&lt;br/&gt;  &lt;span&gt;@Searchable&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;  &lt;span&gt;@Indexed&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; Point location;&lt;br/&gt;  &lt;span&gt;@Indexed&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; Set&amp;lt;String&amp;gt; tags = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;String&amp;gt;();&lt;br/&gt;  &lt;span&gt;@Indexed&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; Integer numberOfEmployees;&lt;br/&gt;  &lt;span&gt;@Indexed&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; Integer yearFounded;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; String url;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; publiclyListed;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;添加&lt;code&gt;@Document&lt;/code&gt;注释即可，定义格式省去了自己做转换，Redis OM 库直观地将域对象 (domain objects) 保存在 Redis上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;接口使用&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用流畅的、以语言为中心的 API 进行查询，更符合我们平常的编写习惯，看一组官方给的实现案例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.redis.om.documents.repositories;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.*;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.data.geo.Distance;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.data.geo.Point;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.data.repository.query.Param;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.redis.om.documents.domain.Company;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.redis.om.spring.annotations.Query;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.redis.om.spring.repository.RedisDocumentRepository;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;CompanyRepository&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;RedisDocumentRepository&lt;/span&gt;&amp;lt;&lt;span&gt;Company&lt;/span&gt;, &lt;span&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// find one by property&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;Optional&amp;lt;Company&amp;gt; &lt;span&gt;findOneByName&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// geospatial query&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;Iterable&amp;lt;Company&amp;gt; &lt;span&gt;findByLocationNear&lt;/span&gt;&lt;span&gt;(Point point, Distance distance)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// find by tag field, using JRediSearch &quot;native&quot; annotation&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@Query&lt;/span&gt;(&lt;span&gt;&quot;@tags:{$tags}&quot;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;Iterable&amp;lt;Company&amp;gt; &lt;span&gt;findByTags&lt;/span&gt;&lt;span&gt;(@Param(&lt;span&gt;&quot;tags&quot;&lt;/span&gt;)&lt;/span&gt; Set&amp;lt;String&amp;gt; tags)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// find by numeric property&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;Iterable&amp;lt;Company&amp;gt; &lt;span&gt;findByNumberOfEmployees&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; noe)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// find by numeric property range&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;Iterable&amp;lt;Company&amp;gt; &lt;span&gt;findByNumberOfEmployeesBetween&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; noeGT, &lt;span&gt;int&lt;/span&gt; noeLT)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// starting with/ending with&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;Iterable&amp;lt;Company&amp;gt; &lt;span&gt;findByNameStartingWith&lt;/span&gt;&lt;span&gt;(String prefix)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;推荐下自己做的 Spring Cloud 的实战项目：&lt;/p&gt;&lt;p&gt;https://github.com/YunaiV/onemall&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体上，Redis OM Spring为我们节省了很多项目中整合Redis的步骤，可以更好的面向对象编程，省去不少数据格式的转换，同时也提供了我们更熟悉的API接口，大大的赞，不过这轮操作下来，Redis更像一个数据库了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;注意：Redis OM Spring 目前仅适用于 Jedis，同时 Redis OM 的一些高级特性依赖于两个可用 Redis 模块的核心特性：RediSearch和RedisJSON。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你对这个Redis 对象映射库期待吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：https://github.com/redis/redis-om-spring&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>78da6ae5067e8c9dc1298f8faaf612c4</guid>
<title>从数据库评估差异，看全球化长期主义之路</title>
<link>https://toutiao.io/k/r980b51</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89204&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;&lt;span&gt;2. 从数据库评估方式看发展差异&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正如前面所讲，近些年来国内外数据库行业发展迅猛，有越来越多企业、资本、人才投入其中。那么在火热的发展浪潮中，如何对行业、企业、产品、技术有个理性的评估，就至关重要。这不仅有利于数据库厂商预判行业趋势、企业发展定位、产品演进路径、技术发力方向，也有利于广大数据库从业者做出符合自己的发展之路。在这方面，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;国内外有很多机构、组织有着自己的评估方式，而且国内外的评估差异也非常明显&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。下面就谈谈对国内外对数据库评估差异的个人理解。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1).海外评估&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;在海外对数据库的评估，已经有较为成熟的实践。有很多公司、组织或科研机构参与到数据库的评估之中。这里可大致分为三类：一是以 Gartner、Forrester、IDC 为代表的 IT 研究与评估机构，它们会定期发布数据库领域的研究报告；二是以 DB-Engines 为代表的第三方组织，会持续更新排名全球数据库发展现状。三是以卡内基梅隆大学为代表的科研机构，会收录全球数据库信息供学术分析；上述三类公司或组织，其评估角度各有不同，但其合集基本覆盖了从数据库技术、产品、生态、商业等多个侧面。下面详细展开说明下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot; hm_fix=&quot;261:273&quot;&gt;&lt;strong&gt;&lt;span&gt; IT研究与评估机构代表：Gartner&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.002439024390244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xZOm0XATx0WZ7nrYHEteSXSogm0F0ibHm5dHXOXhy9Ciafn2b8V8g4XXGkoapciaJrR8I5cSHsdSyqtNJSptqAbYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;820&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Gartner，是全球最具权威的 IT 研究与顾问咨询公司，成立于 1979 年，总部设在美国康涅狄克州斯坦福，其研究范围覆盖全部 IT 产业。其在 2006 年提出魔力象限模型，用以描述特定领域全球最权威和最具影响力的厂商综合能力评估报告，是头部厂商产品能力的对标。一般情况下，企业 IT 决策者可通过这一分析报告甄别厂商能力，为采购、招标等提供一定的依据佐证。其评选标准包括全球市场份额、产品能力、客户反馈等。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Gartner 魔力象限的评估标准，也是在与时俱进、不断调整。早前 Gartner 主要是根据产品营收选取前 20 个厂商进入年度的云数据库市场的魔力象限，2021 年的评估标准中移除了这一限制，而是采用一种 Market Momentum Index（市场动向指数）来评估，旨在让受到用户欢迎的中小数据库企业有机会入选。于是我们在 2021 年的魔力象限中看到，诸如 SingleStore、Couchbase、Exasol、MariaDB、Cockroach Labs 等数据库新势力首次上榜。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2021 年中国数据库厂商阿里云（Alibaba Cloud）再次进入领导者象限，华为云（HUAWEI CLOUD）进入特定领域者象限（NICHE PLAYERS），是国内入选的仅有两家企业。2020 年还在魔力象限的腾讯云数据库此次缺席，席位被北美的新势力独角兽占据。可见中国数据库厂商由于多数局限在中国市场还未能获得 Gartner 的足够重视，根据非正式渠道得知 Gartner，Forrester，IDC 等三大分析机构已经注意到中国数据库市场的快速发展，将在未来 3-5 年单独强化对中国数据库市场和数据库厂商的评估，包括中国新锐数据库厂商在全球市场的表现。在全球市场的表现，始终是数据库厂商证明自己技术领先性的关键战场。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我们来看 Gartner 具体在市场动向指数上，统计主要来自哪些方向：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了上述在市场动向指数方面进入 Top 20 之外，还有几个必须满足的条件：至少满足 Gartner 定义的 7 个 Use Case 中的 3 个（Traditional transactions，Traditional data warehouse，Logical data warehouse，Augmented transaction processing，Event stream processing，Data science exploration/deep learning，Operational intelligence ）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot; hm_fix=&quot;261:273&quot;&gt;&lt;strong&gt;&lt;span&gt; 第三方机构代表：DB-Engine 数据流行度评估&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;DB-Engine Overall Ranking （2022 年 1 月）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3463541666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xZOm0XATx0WZ7nrYHEteSXSogm0F0ibHm08Os28rklwg4kcLk3TYkKPUZ8ESh3EK6UA7CzInA5JiciaeGPccibPiaHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1536&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前十位的数据库，有六个是开源的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1504424778761062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xZOm0XATx0WZ7nrYHEteSXSogm0F0ibHmTVaphpPaoNGokzeXQUenRzIKUMDrKeOOGD7XWCXcZiaclvxNQRPzic0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;904&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;DB-Engines 由于主要统计海外市场的信息，可以看到，在前 100 名关系型数据库厂商里面，仅有 TiDB 和阿里云的两个产品入围。这从侧面也反映了纯海外市场中国数据库综合影响力和中国市场有很大差异。DB-Engines 是由三方机构维护的，收录全球数据库信息，并按照活跃度给予排名。其排名的数据主要来自下面五种因素：&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Google 及 Bing 搜索引擎的关键字搜索数量；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Google Trends 的搜索数量；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Indeed 网站中的职位搜索量；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LinkedIn 中提到关键字的个人资料数；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Stackoverflow 上相关的问题和关注者数。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;参考: https://db-engines.com/en/ranking&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot; hm_fix=&quot;261:273&quot;&gt;&lt;strong&gt;&lt;span&gt; 科研机构代表：dbdb.io（卡内基梅隆大学）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4829482948294829&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xZOm0XATx0WZ7nrYHEteSXSogm0F0ibHmbDk3kRKXnNDmrh1DH81eZlbYaMK8qVOtjxq6EU1fBvJibAEH6oOdnfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1818&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;dbdb.io，是卡内基梅隆大学维护的全球数据库信息库，其中收录了全球 700 多种数据库产品，其包含数据库的开发者、国家、起始年份、项目类型、开发语言、衍生来源、兼容性、适配系统、开源协议等多种信息。除上述信息外，还包括最近更新、浏览、修改等方面的统计，可以间接反映出数据库产品的活跃程度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述三类评估者，可以说覆盖从技术、产品、生态、商业多角度，可以全方位地了解。但上述这些平台，大家经常访问会有个发现，中国数据库厂商及产品非常少。以 Gartner 为例，在 2021 年的报告中，仅收录了阿里、华为两家中国厂商。其背后原因还是Gartner更加注重商业部分，而国内企业出海不多，而对国内市场的情况海外研究机构又了解有限。而从 DB-Engines 来看，前 100 名仅仅有 PingCAP，阿里两家中国公司，DB- Engine 更多信息也是来自海外的搜索、社交媒体，招聘、论坛类信息，缺少对中国境内的搜索，社交媒体，论坛等信息，三个机构都只能以中国数据库厂商的海外影响力为主，也提示中国数据库厂商应该放眼海外，避免内卷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2).国内评估&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;从国内情况来看，长期以来一直缺乏对数据库的评估体系。之前也曾有过信创目录等政策引导性评估，但其更多是作为政府采购决策参考，公众参与度、认知度不高。不过值得欣喜的是，国内已经有三方机构主动担负其这一职能，希望从更多角度对国内产品做了全面的评估。这一机构就是墨天轮，其维护的墨天轮数据库排行榜，以月为周期多角度评估国内数据库并加以排名。就在不久前，其还发布墨天轮魔力象限，仿照 Gartner 做法来做象限分析。可以说墨天轮社区填补国内这一领域空白，为其点赞。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46033057851239667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xZOm0XATx0WZ7nrYHEteSXSogm0F0ibHmpnxk0AyBaOCCCoEDHCJy95anua9nvAUIC5TEGhjcqFNKTiaFGXNIesA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1210&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从 2021 年的最终排名看，PingCAP 作为开源分布式领导者连续 24 个月领先，但其领先优势开始受到华为 openGauss 数据库的挑战，老牌国产数据库达梦稳居第三，新晋开源的 OceanBase 也进入前五。当把这个前十位的名单与前面海外三类机构的名单比较时，会发现墨天轮的排行主要还是以中国数据库厂商在本土市场的表现为主。从评估维度来看，墨天轮社区在不断改进，其评估指标已较为全面。其排名因素包括如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n64&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;搜索引擎：引入百度、必应、谷歌以及微信公众号文章（搜狗）当月搜索条目数，每个搜索引擎权重不同，如百度、公众号文章较高，最后按整体占比计算得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;趋势指数：引入百度指数、360 趋势数据，通过搜索数据库关键字得到当月指数或趋势，计算得到每个数据库的平均指数，最后按整体占比计算得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;三方评测：引入了包括信通院大数据产品能力评测、电信行业能力评测、TPC 组织评测等，旨在体现数据库产品在特定场景下的基准达标，以及性能和稳定性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;生态：引入生态体系指标，包含社区平台、高校合作、培训认证、开放文档、代码开源、介质下载共六个维度，以体现厂商对数据库产品的可持续发展战略，开放开源、人才培养和共建行业的理念。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;专利数：专利是自主可控的重要体现，这一指标指厂商在国家或国际平台上可以公开查询的专利数，以体现数据库产品的创新能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;论文数：论文指厂商在国际数据库顶会、国际论坛、国际期刊发表的论文，以体现厂商在前沿技术、学术领域的成就。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;招聘岗位数：引入 51JOB 相关招聘数据，根据数据库关键字搜索出每个数据库的岗位数量，体现企业对该数据库人才的需求热度，最后按整体占比计算得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;书籍：引入当当网相关书籍数据，根据数据库关键字搜索出每个数据库的书籍数量，最后按整体占比计算得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DB-Engines 上榜指数：指数据库产品在 DB-Engines 上榜，按排名先后依次降档得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Gartner 市场份额排行及魔力象限：根据 Gartner 发布的最新市场份额排名先后依次降档得分，最新的魔力象限统一得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;IDC 市场份额排行：根据 IDC 发布的最新市场份额排名先后依次降档得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89204&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;&lt;span&gt;3. 数据库评估体系的全球化之路&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从上述分析来看，海外与国内的数据库评估体系存在明显的割裂现象。海外评估体系，虽然较为全面，但对中国数据库厂商及产品涉及很少，了解很浅。究其原因，其一是由于海外对中国市场的重视程度不足，对中国的很多情况也不甚了解；二是由于大多数中国数据库厂商以中国市场为主，与海外评估机构在商业、技术生态上均存在较大距离；三则是语言、文化等因素，也在一定程度上妨碍了双方的了解。从国内的评估体系来看，起步较晚，发展势头不错，但同样存在类似问题。目前国内的评估体系中，均不包含海外产品，（甚至开源也不包含），其次针对国内产品受限于调查者身份，也很难深入到商业部分，甚至直达客户侧，同时也缺少对中国数据库厂商全球影响力的关注和解读。在技术趋势上，国内机构关注 OLTP，OLAP 等传统领域评估更多，而对云数据库、开源、数仓，AI 与自动化等数据库创新趋势相对较少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近些年来，国内数据库产业发展迅速，无论从技术、产品到资本层面，越来越多的厂商产品受到海外的关注。一些国际权威的评估机构已考虑为中国数据库独立评测，这也侧面验证了海外对中国数据库厂商的重视。国内数据库行业已逐渐从跟随者、参与者，向局部引领者角色转变。如何参与到全球化进程中，如何共享全球技术生态，如何发挥全球影响力，如何在全球商业布局等，未来都会成为中国数据库厂商需要面对的问题。从全球及国内来看，数据库行业各种势力正在加速洗牌。相较于海外四五十年的数据库发展来说，国内的数据库厂商还稍显稚嫩。但中国数据库厂商正赶上数据库产业变革的重大机遇期，借助开源和云计算，中国数据库有机会在全球市场占据一席之地。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;数据库评估体系同样需要与时俱进，海外评估机构会更多关注到国内的同时，国内评估机构也可以全球化技术视野和创新模式来看待数据库未来的发展。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;通过更多元的、更为创新的评估体系把握产业发展脉络，把握时代机遇，促进行业健康发展，最终也让中国的广大数据库企业用户受益。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.959375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/UpAsF3LicVxrIicia05puxLBia4Mjcs7icOXB056ZQLQpEFvQic4hBUsOQ5leb4R7qKUgag7YEKf9HpC6GMcjfGxcibNA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2aa0d8d3970d4f13536c35303c1ed0a5</guid>
<title>深度剖析 Seata TCC 模式</title>
<link>https://toutiao.io/k/usoli0i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;什么是 TCC&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCC 是分布式事务中的二阶段提交协议，它的全称为 Try-Confirm-Cancel，即资源预留（Try）、确认操作（Confirm）、取消操作（Cancel），他们的具体含义如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Try：对业务资源的检查并预留；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Confirm：对业务处理进行提交，即 commit 操作，只要 Try 成功，那么该步骤一定成功；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Cancel：对业务处理进行取消，即回滚操作，该步骤回对 Try 预留的资源进行释放。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCC 是一种侵入式的分布式事务解决方案，以上三个操作都需要业务系统自行实现，对业务系统有着非常大的入侵性，设计相对复杂，但优点是 TCC 完全不依赖数据库，能够实现跨数据库、跨应用资源管理，对这些不同数据访问通过侵入式的编码方式实现一个原子操作，更好地解决了在各种复杂业务场景下的分布式事务问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7768924302788844&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBbl9iatc1Cuh6qWgTib3aicMGFkfHFULpKNYeRjLJeqWIUiaCUv6MIge8TQXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1004&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Seata TCC 模式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata TCC 模式跟通用型 TCC 模式原理一致，我们先来使用 Seata TCC 模式实现一个分布式事务：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设现有一个业务需要同时使用服务 A 和服务 B 完成一个事务操作，我们在服务 A 定义该服务的一个 TCC 接口：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同样，在服务 B 定义该服务的一个 TCC 接口：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TccActionTwo&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@TwoPhaseBusinessAction&lt;/span&gt;(name = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;DubboTccActionTwo&quot;&lt;/span&gt;, commitMethod = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;commit&quot;&lt;/span&gt;, rollbackMethod = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;rollback&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;prepare&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(BusinessActionContext actionContext, @BusinessActionContextParameter(paramName = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;b&quot;&lt;/span&gt;)&lt;/span&gt; String b)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;commit&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(BusinessActionContext actionContext)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;rollback&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(BusinessActionContext actionContext)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在业务所在系统中开启全局事务并执行服务 A 和服务 B 的 TCC 预留资源方法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@GlobalTransactional&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; doTransactionCommit() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tccActionOne.prepare(&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;one&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tccActionTwo.prepare(&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;two&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上就是使用 Seata TCC 模式实现一个全局事务的例子，可以看出，TCC 模式同样使用 @GlobalTransactional 注解开启全局事务，而服务 A 和服务 B 的 TCC 接口为事务参与者，Seata 会把一个 TCC 接口当成一个 Resource，也叫 TCC Resource。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCC 接口可以是 RPC，也可以是 JVM 内部调用，意味着一个 TCC 接口，会有发起方和调用方两个身份，以上例子，TCC 接口在服务 A 和服务 B 中是发起方，在业务所在系统中是调用方。如果该 TCC 接口为 Dubbo RPC，那么调用方就是一个 dubbo:reference，发起方则是一个 dubbo:service。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8055555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblib91IzAYbpYyyUcn2rMdPxmxAkvYicApr9jIiaAicCPTHNw4r2pw8VKcnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata 启动时会对 TCC 接口进行扫描并解析，如果 TCC 接口是一个发布方，则在 Seata 启动时会向 TC 注册 TCC Resource，每个 TCC Resource 都有一个资源 ID；如果 TCC 接口时一个调用方，Seata 代理调用方，与 AT 模式一样，代理会拦截 TCC 接口的调用，即每次调用 Try 方法，会向 TC 注册一个分支事务，接着才执行原来的 RPC 调用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当全局事务决议提交/回滚时，TC 会通过分支注册的的资源 ID 回调到对应参与者服务中执行 TCC Resource 的 Confirm/Cancel 方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Seata 如何实现 TCC 模式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从上面的 Seata TCC 模型可以看出，TCC 模式在 Seata 中也是遵循 TC、TM、RM 三种角色模型的，如何在这三种角色模型中实现 TCC 模式呢？我将其主要实现归纳为资源解析、资源管理、事务处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;资源解析&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;资源解析即是把 TCC 接口进行解析并注册，前面说过，TCC 接口可以是 PRC，也可以是 JVM 内部调用，在 Seata TCC 模块中中一个 remoting 模块，该模块专门用于解析具有 TwoPhaseBusinessAction 注解的 TCC 接口资源：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8501742160278746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblxIvRqlftiaiacrEPl5pEpnqIokjUia87qlp43aZm2TXupVBPXvibdV38Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RemotingParser 接口主要有 isRemoting、isReference、isService、getServiceDesc 等方法，默认的实现为 DefaultRemotingParser，其余各自的 RPC 协议解析类都在 DefaultRemotingParser 中执行，Seata 目前已经实现了对 Dubbo、HSF、SofaRpc、LocalTCC 的 RPC 协议的解析，同时具备 SPI 可扩展性，未来欢迎大家为 Seata 提供更多的 RPC 协议解析类。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Seata 启动过程中，有个 GlobalTransactionScanner 注解进行扫描，会执行以下方法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;io.seata.spring.util.TCCBeanParserUtils#isTccAutoProxy&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;该方法目的是判断 bean 是否已被 TCC 代理，在过程中会先判断 bean 是否是一个 Remoting bean，如果是则调用 getServiceDesc 方法对 remoting bean 进行解析，同时判断如果是一个发起方，则对其进行资源注册：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;io.seata.rm.tcc.remoting.parser.DefaultRemotingParser#parserRemotingServiceInfo&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; RemotingDesc parserRemotingServiceInfo(Object bean, String beanName, RemotingParser remotingParser) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    RemotingDesc remotingBeanDesc = remotingParser.getServiceDesc(bean, beanName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (remotingBeanDesc == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    remotingServiceMap.put(beanName, remotingBeanDesc);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Class&amp;lt;?&amp;gt; interfaceClass = remotingBeanDesc.getInterfaceClass();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Method[] methods = interfaceClass.getMethods();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (remotingParser.isService(bean, beanName)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Object targetBean = remotingBeanDesc.getTargetBean();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Method m : methods) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                TwoPhaseBusinessAction twoPhaseBusinessAction = m.getAnnotation(TwoPhaseBusinessAction.&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (twoPhaseBusinessAction != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    TCCResource tccResource = new TCCResource();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setActionName(twoPhaseBusinessAction.name());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setTargetBean(targetBean);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setPrepareMethod(m);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setCommitMethodName(twoPhaseBusinessAction.commitMethod());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setCommitMethod(interfaceClass.getMethod(twoPhaseBusinessAction.commitMethod(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                                         twoPhaseBusinessAction.commitArgsClasses()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setRollbackMethodName(twoPhaseBusinessAction.rollbackMethod());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setRollbackMethod(interfaceClass.getMethod(twoPhaseBusinessAction.rollbackMethod(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                                           twoPhaseBusinessAction.rollbackArgsClasses()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setCommitArgsClasses(twoPhaseBusinessAction.commitArgsClasses());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setRollbackArgsClasses(twoPhaseBusinessAction.rollbackArgsClasses());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setPhaseTwoCommitKeys(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.getTwoPhaseArgs(tccResource.getCommitMethod(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                                           twoPhaseBusinessAction.commitArgsClasses()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setPhaseTwoRollbackKeys(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.getTwoPhaseArgs(tccResource.getRollbackMethod(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                                             twoPhaseBusinessAction.rollbackArgsClasses()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    DefaultResourceManager.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;().registerResource(tccResource);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; new FrameworkException(t, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;parser remoting service error&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (remotingParser.isReference(bean, beanName)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        remotingBeanDesc.setReference(&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; remotingBeanDesc;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上方法，先调用解析类 getServiceDesc 方法对 remoting bean 进行解析，并将解析后的 remotingBeanDesc 放入 本地缓存 remotingServiceMap 中，同时调用解析类 isService 方法判断是否为发起方，如果是发起方，则解析 TwoPhaseBusinessAction 注解内容生成一个 TCCResource，并对其进行资源注册。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;资源管理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1、资源注册&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata TCC 模式的资源叫 TCCResource，其资源管理器叫 TCCResourceManager，前面讲过，当解析完 TCC 接口 RPC 资源后，如果是发起方，则会对其进行资源注册：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;io.seata.rm.tcc.TCCResourceManager#registerResource&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;registerResource&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Resource resource)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TCCResource tccResource = (TCCResource)resource;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tccResourceCache.put(tccResource.getResourceId(), tccResource);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;super&lt;/span&gt;.registerResource(tccResource);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCCResource 包含了 TCC 接口的相关信息，同时会在本地进行缓存。继续调用父类 registerResource 方法（封装了通信方法）向 TC 注册，TCC 资源的 resourceId 是 actionName，actionName 就是 @TwoParseBusinessAction 注解中的 name。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2、资源提交/回滚&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;io.seata.rm.tcc.TCCResourceManager#branchCommit&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; BranchStatus branchCommit(BranchType branchType, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; xid, long branchId, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; resourceId,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                 &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; applicationData) throws TransactionException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TCCResource tccResource = (TCCResource)tccResourceCache.get(resourceId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (tccResource == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShouldNeverHappenException(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.format(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;TCC resource is not exist, resourceId: %s&quot;&lt;/span&gt;, resourceId));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; targetTCCBean = tccResource.getTargetBean();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Method commitMethod = tccResource.getCommitMethod();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (targetTCCBean == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; || commitMethod == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShouldNeverHappenException(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.format(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;TCC resource is not available, resourceId: %s&quot;&lt;/span&gt;, resourceId));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        BusinessActionContext businessActionContext = getBusinessActionContext(xid, branchId, resourceId,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                                               applicationData);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ret = commitMethod.invoke(targetTCCBean, args);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; result ? BranchStatus.PhaseTwo_Committed : BranchStatus.PhaseTwo_CommitFailed_Retryable;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; msg = &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.format(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;commit TCC resource error, resourceId: %s, xid: %s.&quot;&lt;/span&gt;, resourceId, xid);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        LOGGER.error(msg, t);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; BranchStatus.PhaseTwo_CommitFailed_Retryable;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当 TM 决议二阶段提交，TC 会通过分支注册的的资源 ID 回调到对应参与者（即 TCC 接口发起方）服务中执行 TCC Resource 的 Confirm/Cancel 方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;资源管理器中会根据 resourceId 在本地缓存找到对应的 TCCResource，同时根据 xid、branchId、resourceId、applicationData 找到对应的 BusinessActionContext 上下文，执行的参数就在上下文中。最后，执行 TCCResource 中获取 commit 的方法进行二阶段提交。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二阶段回滚同理类似。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;事务处理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面讲过，如果 TCC 接口时一个调用方，则会使用 Seata TCC 代理对调用方进行拦截处理，并在处理调用真正的 RPC 方法前对分支进行注册。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;执行方法 io.seata.spring.util.TCCBeanParserUtils#isTccAutoProxy 除了对 TCC 接口资源进行解析，还会判断 TCC 接口是否为调用方，如果是调用方则返回 true：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;io.seata.spring.annotation.GlobalTransactionScanner#wrapIfNecessary&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1905940594059406&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblNdcVQC7ZQTVyUBvWK2qQYJ2mXib19r6h7hn3ERdbkMibZOVBicMcMZhGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2424&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如图，当 GlobalTransactionalScanner 扫描到 TCC 接口调用方（Reference）时，会使 TccActionInterceptor 对其进行代理拦截处理，TccActionInterceptor 实现 MethodInterceptor。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 TccActionInterceptor 中还会调用 ActionInterceptorHandler 类型执行拦截处理逻辑，事务相关处理就在 ActionInterceptorHandler#proceed 方法中：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; proceed(Method method, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;[] &lt;span class=&quot;code-snippet__built_in&quot;&gt;arguments&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; xid, TwoPhaseBusinessAction businessAction,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      Callback&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; targetCallback) throws Throwable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    BusinessActionContext actionContext = getOrCreateActionContextAndResetToArguments(method.getParameterTypes(), &lt;span class=&quot;code-snippet__built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; branchId = doTccActionLogStore(method, &lt;span class=&quot;code-snippet__built_in&quot;&gt;arguments&lt;/span&gt;, businessAction, actionContext);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; targetCallback.execute();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            BusinessActionContextUtil.reportContext(actionContext);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上，在执行 TCC 接口一阶段之前，会调用 doTccActionLogStore 方法分支注册，同时还会将 TCC 相关信息比如参数放置在上下文，上面讲的资源提交/回滚就会用到这个上下文。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;如何控制异常&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 TCC 模型执行的过程中，还可能会出现各种异常，其中最为常见的有空回滚、幂等、悬挂等。下面我讲下 Seata 是如何处理这三种异常的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;如何处理空回滚&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是空回滚？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;空回滚指的是在一个分布式事务中，在没有调用参与方的 Try 方法的情况下，TM 驱动二阶段回滚调用了参与方的 Cancel 方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么空回滚是如何产生的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7925824175824175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblb5C8gBNTaD94MDQZanBsvUPvicnibaQ7jb9cic8ibYzsnBWeUiciaFib21HzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1456&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如上图所示，全局事务开启后，参与者 A 分支注册完成之后会执行参与者一阶段 RPC 方法，如果此时参与者 A 所在的机器发生宕机，网络异常，都会造成 RPC 调用失败，即参与者 A 一阶段方法未成功执行，但是此时全局事务已经开启，Seata 必须要推进到终态，在全局事务回滚时会调用参与者 A 的 Cancel 方法，从而造成空回滚。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要想防止空回滚，那么必须在 Cancel 方法中识别这是一个空回滚，Seata 是如何做的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata 的做法是新增一个 TCC 事务控制表，包含事务的 XID 和 BranchID 信息，在 Try 方法执行时插入一条记录，表示一阶段执行了，执行 Cancel 方法时读取这条记录，如果记录不存在，说明 Try 方法没有执行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;如何处理幂等&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;幂等问题指的是 TC 重复进行二阶段提交，因此 Confirm/Cancel 接口需要支持幂等处理，即不会产生资源重复提交或者重复释放。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么幂等问题是如何产生的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7977839335180056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBbl7JzkibThAicvzkwwShb0DkaCGBKXY4hvEF7UlwOAhVjAfkrWwvOl4xBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1444&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如上图所示，参与者 A 执行完二阶段之后，由于网络抖动或者宕机问题，会造成 TC 收不到参与者 A 执行二阶段的返回结果，TC 会重复发起调用，直到二阶段执行结果成功。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata 是如何处理幂等问题的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同样的也是在 TCC 事务控制表中增加一个记录状态的字段 status，该字段有有 3 个值，分别为：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;tried：1&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;committed：2&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;rollbacked：3&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二阶段 Confirm/Cancel 方法执行后，将状态改为 committed 或 rollbacked 状态。当重复调用二阶段 Confirm/Cancel 方法时，判断事务状态即可解决幂等问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;如何处理悬挂&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;悬挂指的是二阶段 Cancel 方法比 一阶段 Try 方法优先执行，由于允许空回滚的原因，在执行完二阶段 Cancel 方法之后直接空回滚返回成功，此时全局事务已结束，但是由于 Try 方法随后执行，这就会造成一阶段 Try 方法预留的资源永远无法提交和释放了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么悬挂是如何产生的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7988980716253443&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblFPZGKcAX6icRxb2NNicibataztZkSxDuaKywrgkWFNb8aOL6DdKEGXKQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1452&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如上图所示，在执行参与者 A 的一阶段 Try 方法时，出现网路拥堵，由于 Seata 全局事务有超时限制，执行 Try 方法超时后，TM 决议全局回滚，回滚完成后如果此时 RPC 请求才到达参与者 A，执行 Try 方法进行资源预留，从而造成悬挂。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata 是怎么处理悬挂的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 TCC 事务控制表记录状态的字段 status 中增加一个状态：&lt;/span&gt;&lt;span&gt;suspended：&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当执行二阶段 Cancel 方法时，如果发现 TCC 事务控制表有相关记录，说明二阶段 Cancel 方法优先一阶段 Try 方法执行，因此插入一条 status=4 状态的记录，当一阶段 Try 方法后面执行时，判断 status=4 ，则说明有二阶段 Cancel 已执行，并返回 false 以阻止一阶段 Try 方法执行成功。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>48b3f9829aea1075b81d28252a3ccc9c</guid>
<title>还不懂灰度吗？手把手教你搭建一个灰度发布环境</title>
<link>https://toutiao.io/k/d8ne3sr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;灰度发布，又称金丝雀发布。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;金丝雀发布这一术语源于煤矿工人把笼养的金丝雀带入矿井的传统。矿工通过金丝雀来了解矿井中一氧化碳的浓度，如果一氧化碳的浓度过高，金丝雀就会中毒，从而使矿工知道应该立刻撤离。——《DevOps实践指南》&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应到软件开中，则是指在发布新的产品特性时通过少量的用户试点确认新特性没有问题，确保无误后推广到更大的用户使用群体。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集成灰度发布的流水线在DevOps中是一个非常重要的工具和高效的实践，然而笔者在入职以前对流水线和灰度发布知之甚少。在了解一个新东西时，先从逻辑上打通所有的关键环节，然后再完成一个最简单的Demo，对于我们来说是比较有意思的学习路径，因此便有了这篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文理论内容较少，主要是从零到一的搭建流程实践，适合对工程化感兴趣的初级前端开发者。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;01 服务器准备&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;获取服务器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到，灰度发布是通过少量的用户试点来验证新功能有没有问题。所以要保证有两批用户能在同一时间体验到不同的功能。这就要求我们准备两台服务器，分别部署不同的代码版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你已经有了一台服务器，也可以通过在不同端口部署服务的方式来模拟两台服务器。如果你还一台服务器都没有，那么可以参考这个过程购买两台云服务器，如果是按需购买，完成本文的Demo，大概要花费20块钱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取云服务器教程：&lt;span&gt;github.com/TerminatorS…&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;工具安装&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Git&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，确保你的服务器上已经安装了git，如果没有的话使用以下命令进行安装，安装好了以后生成ssh 公钥，放到你的github 里，后面拉取代码的时候会用到。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;yum install git&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Nginx&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的服务器没有Nginx，先按照以下操作进行安装，Linux 下安装Nginx非常简单：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sudo yum install nginx&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完了，在终端输入nginx -t检查一下是否安装成功。如果安装成功，它会显示Nginx 配置文件的状态，以及位置。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10092807424593968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOpNEa5KGXnRpYAtibJlWCtPfJwrGUoTRM33icCDFY03AN053Cw5qq2vy1Q/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;862&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时nginx还没有启动，在终端中输入&lt;code&gt;nginx&lt;/code&gt; 或&lt;code&gt;nginx \-s reload&lt;/code&gt; 命令即可启动，此时看到的nginx相关进程如下，表明已经启动成功。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1423948220064725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOpJd6KtVCFP20icBIkkEPLXvxwfuQKXsMibM7D4hfuJXhq4YQNictVGB0zg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1236&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在浏览器里访问你的服务器公网IP，如果能看到下面的页面说明Nginx 可以正常工作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOpNibOC9vl6BwlLw01e8ZjPGjuUefLMSTnICu5F2xwb3VYfGInLMictiauQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Jenkins (耗时比较久)&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次接触Jenkins 可能会有很多疑问，Jenkins 是什么？能完成什么事情？我为什么要使用Jenkins 等诸如此类。很难讲清楚Jenkins 是什么东西，所以这里简单介绍一下Jenkins 可以做什么。简单来讲，你在任何一台服务器上进行的任何操作命令，Jenkins 都可以帮你完成，只要你提前在Jenkins上创建好任务，指定任务内容和触发时机，比如定时触发或者在特定的情况下触发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）安装&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Jenkins稳定版本list：&lt;span&gt;pkg.jenkins-ci.org/redhat-stab…&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 科学上网会快一些，记得留意网站上java和jenkins版本匹配信息，别下错了&lt;br/&gt;wget http://pkg.jenkins-ci.org/redhat-stable/jenkins-2.204.5-1.1.noarch.rpm&lt;br/&gt;rpm -ivh jenkins-2.204.5-1.1.noarch.rpm&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改Jenkins端口，不冲突可不修改&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// line 56 JENKINS_PORT&lt;br/&gt;vi /etc/sysconfig/jenkins&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）启动&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动jenkins&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;service jenkins start/stop/restart&lt;br/&gt;// 密码位置&lt;br/&gt;/var/lib/jenkins/secrets/initialAdminPassword&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）访问&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问服务器的8080端口，输入从上述位置获取的密码，点击继续&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOpBfHVkULbaA5Gic4CscQmVlHLHibVEDmZ19mub41cXR4trYsNulr1nCrQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个账户然后登录&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOpg8f92S5umSoC3fyw1mDRBcRvvrdnB7D4JqYrEAe4DHxTyicSic8lJObg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到Jenkins 已就绪的页面表示安装已经完成，服务器准备工作到此结束。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.61&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOpPHiatDyCdj4mgCgTF1icxGjWrKd1524NsMMRQh2t3PNSSfsandJoSw7g/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;02 代码准备&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;准备两份代码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为要做灰度部署，所以需要准备两份不一样的代码，以验证我们实施的灰度操作是否生效。这里选择使用Angular 的Angular-CLI 来创建代码。创建的项目并不简洁，但是胜在操作简单。我们一次性把两份代码准备好，简化开发侧工作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 安装angular-cli，前提是已经安装了node，如果没有node真的要去自行百度了...&lt;br/&gt;npm install -g @angular/cli&lt;br/&gt;// 快速创建一个新项目，一路回车&lt;br/&gt;ng new canaryDemocd canaryDemo&lt;br/&gt;// 运行完这个命令后访问http://localhost:4200 查看页面信息&lt;br/&gt;ng serve&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问localhost 的4200 端口查看页面，然后把项目根目录下src 中的index.html 的title 改成A-CanaryDemo，可以看到页面会进行实时地刷新。在这个例子中，我们用title 来标识灰度发布过程中两边不同的服务需要部署的代码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.611&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOp5iaVYdQ5Z544bZjd5Ufc3XLoIxYqCG3ibLzVQTt63gCSrWhedNNAU3Yw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们进行两次打包，两次打包的title 分别为A-CanaryDemo 和 B-CanaryDemo， 把这两个文件夹放好备用，作为一会灰度发布的新老代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ng build --prod&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOpibSko36O6SuYAmLxw5nIHA5hE7MlJb13mFyQzWH9DJvjn5ekAJTycZw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置Nginx&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述完成Nginx 的安装操作时，我们访问服务器的IP 看到的是Nginx 的页面，现在我们想访问到自己的页面，首先把上面打包得到的A-CanaryDemo 发送到两台服务器上任意位置，这里我们把它放到/var/canaryDemo。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 将A-CanaryDemo 文件夹复制到你的公网服务器上，xx部分是你的服务器公网ip&lt;br/&gt;scp -r ./dist/A-CanaryDemo root@xx.xx.xx.xx:/var/canaryDemo&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;去服务器上/var 的位置上看一下，是否已经有了这个文件，如果有了的话，接着到下一步。即修改Nginx 配置把访问该服务器IP 的请求转发到我们刚刚上传上来的页面上。上面提到过可以通过nginx -t 这个命令来查看Nginx 配置文件的位置，在这一步，我们要去编辑那个文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;vi /etc/nginx/nginx.conf&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改47-50行添加下图相关的内容，即将访问到该服务器IP 的流量转发到/var/canaryDemo 下的index.html.&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6883333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOpd0xN7WpTUXdWfpvjOrhsA9IicI3NIguAU7kgKZLB0y4FpsQKjqfLVwg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改完毕，保存退出，重启一下nginx&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;nginx -s reload&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候去访问我们服务器的IP 地址可以看到页面已经变成了刚刚我们在本地改的页面，而且title 确实是A-CanaryDemo。两台服务器都操作完成后，两边都可以访问到title 为A-CanaryDemo 的页面。此时的状态相当于生产环境已经在提供稳定服务的两台机器。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOp1bgfianwIa8evYtOUgFo9V4K2kkhUeTiaUeiaexNY9zWd1iaNduzlpgMuw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;03 定义灰度策略&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们要开始进行灰度发布的部分，在进行相关操作之前，我们需要定义一个灰度策略，即满足什么情况下的流量会走到灰度边，而其他流量走向正常边。这里为了简单起见，我们使用名字为canary 的cookie 来区分，如果检测到这个cookie 的值为devui，就访问灰度边机器，否则就访问正常边机器。按照此规则配置Nginx 结果如下，此处分别使用11.11.11.11和22.22.22.22代表两台服务器的IP地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# Canary Deployment&lt;/span&gt;&lt;br/&gt;map &lt;span&gt;$COOKIE_canary&lt;/span&gt; &lt;span&gt;$group&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;# canary account&lt;/span&gt;&lt;br/&gt;  ~*devui$ server_canary;&lt;br/&gt;  default server_default;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;upstream server_canary {&lt;br/&gt;  &lt;span&gt;# 两台机器的IP，第一台设置端口号8000是为了防止nginx转发出现死循环导致页面报错&lt;/span&gt;&lt;br/&gt;  server 11.11.11.11:8000 weight=1 max_fails=1 fail_timeout=30s;&lt;br/&gt;  server 22.22.22.22 weight=1 max_fails=1 fail_timeout=30s;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;upstream server_default {&lt;br/&gt;  server 11.11.11.11:8000 weight=2 max_fails=1 fail_timeout=30s;&lt;br/&gt;  server 22.22.22.22 weight=2 max_fails=1 fail_timeout=30s;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 相应地，要配置8000端口的转发规则，8000端口默认不开启访问，需要去云服务器控制台安全组新增8000&lt;/span&gt;&lt;br/&gt;server {&lt;br/&gt;  listen 8000;&lt;br/&gt;  server_name _;&lt;br/&gt;  root /var/canaryDemo;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;# Load configuration files for the default server block.&lt;/span&gt;&lt;br/&gt;  include /etc/nginx/default.d/*.conf;&lt;br/&gt;&lt;br/&gt;  location / {&lt;br/&gt;    root /var/canaryDemo;&lt;br/&gt;    index index.html;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;server {&lt;br/&gt;  listen 80 default_server;&lt;br/&gt;  listen [::]:80 default_server;&lt;br/&gt;  server_name _;&lt;br/&gt;  &lt;span&gt;# root /usr/share/nginx/html;&lt;/span&gt;&lt;br/&gt;  root /var/canaryDemo;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;# Load configuration files for the default server block.&lt;/span&gt;&lt;br/&gt;  include /etc/nginx/default.d/*.conf;&lt;br/&gt;&lt;br/&gt;  location / {&lt;br/&gt;    proxy_pass http://&lt;span&gt;$group&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;# root /var/canaryDemo;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# index index.html;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  error_page 404 /404.html;&lt;br/&gt;    location = /40x.html {&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  error_page 500 502 503 504 /50x.html;&lt;br/&gt;  location = /50x.h&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，灰度流量和正常流量都会随机分配到AB两边的机器。下面，我们通过建立Jenkins 任务执行Nginx 文件修改的方式实现灰度发布。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;04 实现灰度发布&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;流程梳理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建用于实现灰度发布的Jenkins任务之前我们先梳理一下要达到灰度发布的目标需要哪几个任务，以及每个任务负责完成什么事情。灰度发布一般遵循这样的流程（假设我们有AB两台服务器用于提供生产环境的服务，我们称之为AB边）：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）新代码部署到A边&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）符合灰度策略的小部分流量切到A边，剩余大部分流量仍去往B边&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）手动验证A边功能是否正常可用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）验证无误后，大部分流量转到A边，灰度流量去往B边&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）手动验证B边功能是否正常可用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）验证无误后，流量像往常一样均分到AB边&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;任务拆解&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述的拆解，我们得出灰度发布的6个步骤，其中（3）和（5）是需要手动验证的环节，所以我们以这两个任务为分割点，建立三个Jenkins 任务（Jenkins 任务建立在A 边机器上）如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）Canary_A（灰度测试A），这个任务又包含两个部分，更新A边的代码，然后修改流量分发策略使得灰度流量到达A，其他流量到达B&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）Canary_AB（上线A灰度测试B），更新B边代码，灰度流量达到B，其他流量到达A&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）Canary_B（上线B），所有流量均分到AB&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOpjCssT3Qd2WDMLxNCE0vSibNpRvGH8j5Pa1IiaVX9VblCPbDVfsKkT3lQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;创建任务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先按照任务拆解部分的设定创建三个FreeStyle 类型的Jenkins 任务，记得使用英文名字，中文名字后面建文件夹比较麻烦。任务详情信息可以不填，直接保存就好，下一步我们再来配置每个任务的具体信息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6251441753171857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOpEHCusjn952srgeFED3vPeGBfHZricOYP66YDJmsSSP7eHiaaCcL2oKEg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;867&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置任务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在已经创建好了三个任务，先点击进入每一个任务进行一次空的构建（否则后面可能导致修改后的构建任务无法启动），然后我们来对每个任务进行详细的配置。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.61&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOpQTpDKPz5BkZ4UKGd5ibXj2OfU1Ok7UFwRXCG3PQGLpL50diaMXMQicJSw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现代前端项目都要进行构建打包这一步。但是廉价的云服务器在完成构建方面有些力不从心，CPU 经常爆表。&lt;strong&gt;所以我们在这里把打包出得出的生产包纳入git 管理，每次的代码更新会同步最新的生产包到github，因此Jenkins 任务把生产包拉下来，放在指定位置即可完成一次新代码的部署。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一步操作，其实我们在之前就已经完成了，我们在上面打了两份tilte 不一样的生产包，此时可以派上用场了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先来配置灰度测试A，这个任务内容上面也基本讲清楚了，首先要关联该任务到远程的github 仓库（需要手动创建一个，存放上面打包的B-CanaryDemo，并命名为dist）让它知道可以去哪里拉取最新代码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.61&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOpZibjydXM5dhFUrJmGB5pZlwpPzlBT9mx3We2NibwdvibkslBPCgNgWxkA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行一次构建任务（在git fetch 那一步耗时不稳定，有时比较久），然后点击本次构建进去查看Console Output，可以确定执行Jenkins 任务的位置是位于服务器上的/var/lib/jenkins/workspace/Canary_A&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.61&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOpWmH7V0QBTPiaRMlUdRYTRK5AR6sciaia2nlnDiaib1mGCbDBNoDHoqFUGTA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6111757857974389&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOpZj4icxd4ray1ZJdibSRQRuMrF2myo7CGCJkQmxfqxcHGibHaquGzKm6yw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;859&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续编辑灰度测试A 任务，添加build shell，也就是每次任务执行时要执行的命令：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）先拉取最新的代码&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）把代码根目录下的dist目录复制到部署代码的位置，这里我们指定的位置是/var/canaryDemo&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）&lt;strong&gt;修改Nginx 配置&lt;/strong&gt;使灰度流量到达A边&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就步骤（3）而言，修改灰度流量的方式其实就是&lt;strong&gt;选择性注释Nginx 配置文件&lt;/strong&gt;中的内容，注释方式如下即可实现灰度测试A。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;upstream server_canary {&lt;br/&gt;  &lt;span&gt;# 灰度流量访问A 边&lt;/span&gt;&lt;br/&gt;  server 11.11.11.11:8080 weight=1 max_fails=1 fail_timeout=30s;&lt;br/&gt;  &lt;span&gt;# server 22.22.22.22 weight=1 max_fails=1 fail_timeout=30s;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;upstream server_default {&lt;br/&gt;  &lt;span&gt;# 正常流量访问B 边，为了在修改文件的时候把这段的配置和上面的server_canary 区分开，我们把这里的weight 设为2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;# server 11.11.11.11:8080 weight=2 max_fails=1 fail_timeout=30s;&lt;/span&gt;&lt;br/&gt;  server 22.22.22.22 weight=2 max_fails=1 fail_timeout=30s;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一步填写的shell 命令在使用jenkins 用户执行时可能会遇到权限问题，可以先用root 用户登录，把/var 目录的归属改为jenkins 用户，/etc/nginx/ngix.conf也需要新增可写权限。由此，最终得到的shell 命令如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;git pull&lt;br/&gt;rm -rf /var/canaryDemo&lt;br/&gt;scp -r dist /var/canaryDemo&lt;br/&gt;sed -i &lt;span&gt;&#x27;s/server 22.22.22.22 weight=1/# server 22.22.22.22 weight=1/&#x27;&lt;/span&gt; /etc/nginx/nginx.conf&lt;br/&gt;sed -i &lt;span&gt;&#x27;s/server 11.11.11.11:8000 weight=2/# server 11.11.11.11:8000 weight=2/&#x27;&lt;/span&gt; /etc/nginx/nginx.conf&lt;br/&gt;nginx -s reload&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.61&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk9icZCfEIHkdowgDAh88OOpUUoLSOYtw174dO3vzpO7CKRP2DR1zhszlOchSvBibsF3sYIQSMiaBOuQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;灰度测试A 任务内容配置完成，接下来依次配置上线A 灰度测试B 和上线B。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;灰度测试B 的要执行的任务是把最新的代码拉到A 边（因为我们的Jenkins 任务都是建立在A 边的），复制dist 下的代码到B 边Nginx 指定访问位置，然后修改A 边Nginx 配置，使灰度流量到达B 边。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;git pull&lt;br/&gt;rm -rf canaryDemo&lt;br/&gt;mv dist canaryDemo&lt;br/&gt;scp -r canaryDemo root@xx.xx.xx.xx:/var&lt;br/&gt;sed -i &lt;span&gt;&#x27;s/# server 22.22.22.22 weight=1/server 22.22.22.22 weight=1/&#x27;&lt;/span&gt; /etc/nginx/nginx.conf&lt;br/&gt;sed -i &lt;span&gt;&#x27;s/# server 11.11.11.11:8000 weight=2/server 11.11.11.11:8000 weight=2/&#x27;&lt;/span&gt; /etc/nginx/nginx.conf&lt;br/&gt;sed -i &lt;span&gt;&#x27;s/server 22.22.22.22 weight=2/# server 22.22.22.22 weight=2/&#x27;&lt;/span&gt; /etc/nginx/nginx.conf&lt;br/&gt;sed -i &lt;span&gt;&#x27;s/server 11.11.11.11:8000 weight=1/# server 11.11.11.11:8000 weight=1/&#x27;&lt;/span&gt; /etc/nginx/nginx.conf&lt;br/&gt;nginx -s reload&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一步的任务内容涉及到从A 边服务器向B 边服务器发送代码，这个过程一般来说需要输入B 边服务器的密码。我们想要做到免密发送，因此要通过把A 边机器~/.ssh/id_rsa.pub 中的内容添加到B 边服务器~/.ssh/authorized_keys 中使得A 获得免密像B 发送文件的权限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上线B 则是通过取消对A 边Nginx 配置的注释使所有流量均分到AB 边.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sed -i &lt;span&gt;&#x27;s/# server 22.22.22.22 weight=2/server 22.22.22.22 weight=2/&#x27;&lt;/span&gt; /etc/nginx/nginx.conf&lt;br/&gt;sed -i &lt;span&gt;&#x27;s/# server 11.11.11.11:8000 weight=1/server 11.11.11.11:8000 weight=1/&#x27;&lt;/span&gt; /etc/nginx/nginx.conf&lt;br/&gt;nginx -s reload&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们就从零到一搭建了一个灰度发布环境。在代码更新后，通过手动执行Jenkins 任务的方式实现灰度部署和手工测试，保证新功能平滑上线。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从服务器准备、代码准备、灰度策略制定和实现灰度发布四个方面介绍了从零搭建一个灰度发布环境的必备流程。灰度发布的核心其实就是通过对Nginx 文件的修改实现流量的定向分发。内容颇为简单，但是从零到一的整个流程操作下来还是比较繁琐，希望各位看官能够有所收获。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，这只是一个最简易的Demo，在真正的DevOps 开发过程中，还需要集成编译构建、代码检查、安全扫描和自动化测试用例等其他操作，期待后续团队的其他成员进行更多的专项扩展！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>39538a6bb8efdbdaf94656a49ac058f9</guid>
<title>虚数有物理意义：中科大潘建伟、南科大范靖云团队首次实验排除实数形式的标准量子力学</title>
<link>https://toutiao.io/k/d290ffc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;white-space: normal; max-width: 100%; letter-spacing: 0.544px; text-size-adjust: auto; background-color: rgb(255, 255, 255); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__0&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-top: 2em; padding-top: 0.5em; padding-bottom: 0.5em; max-width: 100%; border-style: solid none; text-decoration: inherit; border-top-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-top-width: 1px; border-bottom-width: 1px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__1&quot;&gt;&lt;section&gt;&lt;span&gt;机器之心报道&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;编辑：泽南、小舟&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;136&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;量子力学的理论能否只用实数构造？从理论上和实践上，研究人员都得出了否定的答案。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然在高中数学里，大家都接触过虚数这个概念，但它看起来总是那么反直觉：虚数这个名词是 17 世纪数学家笛卡尔提出的，因为当时的观念认为这不是真实存在的数字，其性质被定义为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrPuBTJQCxF7IF9RB4SsugqPs5m1WAguGGjatic1FUfMBB42ibU755a3Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是现如今，为了从根本上描述物质，虚数被证明是必不可少的。它们似乎融入了量子力学的结构，后者是描述分子、原子和亚原子粒子领域的基础理论。最近的两项新实验表明，遵循量子物理学规则的理论需要虚数来描述现实世界。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虚数由负数的平方根产生。它们经常作为数学工具出现在方程式中，以使计算更容易。但是我们可以实际测量的，关于世界的一切都是用实数来描述的，我们也习惯于正常的、非虚的数字。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在量子物理的范畴中其实也是如此。尽管虚数出现在理论的内部运作中，但所有可能的测量都会产生实数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虚数 i 是薛定谔方程必不可少的常数，由此观之，量子力学必须包含虚数。量子理论对复数（虚数和实数之和）的突出使用令其创始人，包括物理学家艾尔温 · 薛定谔（Erwin Schrödinger）感到不安。「从量子理论的早期开始，复数更多地被视为一种数学便利，而不是基本的构建模块，」南方科技大学的物理学家范靖云说道。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;部分物理学家试图仅使用实数来构建量子理论，而使用称为「实数量子力学」的版本来避免使用虚数。但是如果没有对这些理论进行实验测试，我们无法得知虚数在量子物理学中是否真的必要，或者只是一种有用的计算工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一种称为贝尔测量（Bell test）的实验解决了一个不同的量子难题，证明量子力学确实需要粒子之间的奇怪量子联系，也就是量子纠缠。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要了解标准量子理论和类似实数理论之间的区别，你可以思考限制在两个不同位置上的电子。在量子理论中，电子可以处于两个位置的「叠加」中——既不在这个位置，也不是在另一个位置，被观测到在哪只看概率。这种叠加被表示为包含两个维度的抽象空间中的一个点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但这不是普通的空间，也不容易想象。抽象空间中的每个维度都通过一个复数与现实世界中的一个位置相关联，该复数可用于计算在该位置找到电子的概率。随着电子的状态随时间变化，该点在抽象空间中移动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.563&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrBfsJ7tWN2BiaVnkRtcATwic1sxxw41lfjhskx7Tn6ATvqh0BSo39ISibQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具有两个真实维度的类比空间不足以捕捉该电子可以表现出的所有现象，因为它无法编码两个位置的所有可能叠加。然而，具有四个真实维度的空间能够完整指出电子行为的全部范围。这个事实可以概括为：任何单个量子系统的量子物理学都可以在一个真实空间中完全表示，该真实空间的维度数恰好是其抽象空间的两倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;维也纳量子光学和信息研究所的理论物理学家 Miguel Navascués 表示：「我们已开始思考这种实验是否也能反驳实数量子力学。」他和来自奥地利、西班牙和瑞士等国家的科学家在 12 月 15 日发表于《自然》杂志的论文《Quantum theory based on real numbers can be experimentally falsified》中制定了一项实验计划。该论文的一作是量子信息科学的理论物理学家 Marc-Olivier Renou。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文链接：https://www.nature.com/articles/s41586-021-04160-4&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实验计划中，研究人员将从两个不同的来源发送成对的纠缠粒子给三个不同的人，根据传统的物理术语命名为 Alice、Bob 和 Charlie。Alice 接收到一个粒子，并且可以使用她选择的各种设置对其进行测量，Charlie 也这样做。Bob 接收到两个粒子并执行一种特殊类型的测量来纠缠 Alice 和 Charlie 接收到的粒子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;没有虚数的实数量子理论将预测与标准量子物理学不同的结果，从而使实验能够区分哪个是正确的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7328699106256207&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrR7AJGpChFT5VVOfkUr9RMNFHwGuwibULwzWU0eicULTCFtUicvsmeXa1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1007&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;分离实数量子理论和复数量子理论的网络场景。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;范靖云及其同事使用光子和光粒子进行了这样的实验，他们在 1 月 24 日发表在物理学顶级期刊《物理评论快报》（Physical Review Letters，PRL）上的论文《Testing Real Quantum Theory in an Optical Quantum Network》中进行了报告。通过将 Alice、Charlie 和 Bob 的结果以多种度量方式进行比较，范靖云、Navascués 及其同事表明这些数据只能用包含复数的量子理论来描述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.259375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrpIkqt0ctGEHpCuUYzMXYJBM11bb7DwtXicn9kthnRhibyDCFVzNKNj3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文链接：https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.128.040402&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与此同时，中科大潘建伟团队基于相同的概念，使用由超导体制成的量子计算机进行了一项实验。这项研究也发现量子物理学需要复数，论文《Ruling Out Real-Valued Standard Formalism of Quantum Theory》也在近日的 PRL 上发表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.26640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrkcDXtYPOXPhYiasCTSTTlIgByjibia4DuadicNC4EK0JkdE4QCq49V6V0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文链接：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.128.040403&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;潘建伟、陆朝阳、朱晓波等和西班牙塞维利亚大学 Cabello 教授合作，利用超高精度超导量子线路实现确定性纠缠交换，以超过 43 个标准差的实验精度证明了实数无法完整描述标准量子力学，确立了复数的客观实在性。陈明城、王粲和刘丰铭是该论文的共同一作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中科大在新闻稿中介绍道：随着量子力学理论的发展，复数逐渐表现出某种直觉上的不可排除性。理论上，作为量子力学基石的薛定谔方程和海森堡对易关系其本身就是依赖于复数写出的。而在实验中，人们直接测量到了波函数的实部与虚部。这说明复数可能不是一个主观引入的计算符号，而是可以实验检测的物理实在。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.69453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrf2CEBuq8uWN9Lfdp5ic1G8Av17N2uRsBThjspuzNo0dDDgb8YGyyIibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;在理论框架下，实数形式的界限为 7.66，而实验测试结果为 8.09，超过判据 43 个标准差。实验结论支持量子物理需要使用复数。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中科大表示，该实验证明了实数无法完整描述标准量子力学，确立了复数的客观实在性。该论文的作者之一、中国科学技术大学的量子物理学家陆朝阳说：「我们很好奇为什么复数是必要的，并且在量子力学中发挥着重要作用。」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 &lt;span&gt;Navascués&lt;/span&gt; 等人的实验方案提出不久后，潘建伟等人使用超导量子电路，范靖云等人使用线性光学，分别验证了理论。但并未参与这项研究的加州劳伦斯伯克利国家实验室的理论物理学家 Jerry Finkelstein 指出：结果并未排除所有避开虚数的理论。该研究只排除了某些基于实数的理论，即那些仍然遵循量子力学惯例的理论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过使用打破标准量子规则的理论，仍然可以在没有虚数的情况下解释实验结果。然而 Jerry Finkelstein 说：「虽然这些理论遇到一些概念问题时会变得『丑陋』，但如果你愿意忍受『丑陋』，那么你就可以拥有一套实数量子理论。」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尽管存在质疑，但许多物理学家一致认为：「复数对于量子理论是必要的」这一新发现令人信服。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;诚如美国国家标准技术研究所的物理学家 Krister Shalm 所说：「当你问量子力学『为什么会这样』时，这就已经很有趣了。而询问『量子理论是否可以更简单』，或者『它是否包含任何不必要的东西』这些都是更加有趣和发人深省的问题。」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;参考链接：&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://www.sciencenews.org/article/quantum-physics-imaginary-numbers-math-reality&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://www.nature.com/articles/d41586-021-03678-x&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://news.ustc.edu.cn/info/1055/78317.htm&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1028&quot; data-ratio=&quot;1.77734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicbHHfrYKw4Mswy4xNNmhEwl19xZSzicTNt91J7hZj8O6Tcicj9HIyPydasCuDr7hC6Gq6iaJsDmWEnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;© THE END &lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转载请联系本公众号获得授权&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投稿或寻求报道：content@jiqizhixin.com&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>