<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>97d72055849a1c945d703331855d2615</guid>
<title>程序员必知的分布式容错和降级技术</title>
<link>https://toutiao.io/k/wl65hu4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1379310344827587&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XJlI2e4PlFCAo31qnIMbDbZYjZiaoMc13vKFLjK6kut61aP4k8Uxmzic3FzFMtZapG4jlyBmJMg0UOndMMRWaTLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;58&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;em data-mid=&quot;&quot;/&gt;&lt;p data-mid=&quot;&quot;&gt;可以参与抽奖&lt;/p&gt;&lt;em data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibl6u6nJ01g9icia42icDbWWvO2ObicnIUHjwQKVp30YzLS8xSInYupoEXAKjYeYDibY50CgKLz6ViaDjTjuRqUqaae0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;参与方式&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/K8beZoNWDcUm9I6ia4UU97K1XHrQx2PavruEm3xAL2W3Vd7JxrB8PLXtmT5JkwqpC9Dg9hEmtVZkY2hibnlkib0Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;关注公众号：35岁程序员那些事，后台回复关键词“参与抽奖”，获取抽奖链接，点击抽奖。 中奖之后，可以联系笔者的微信号或者公众号后台回复关键词“联系笔者”，获取联系方式。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式容错和降级是微服务架构中应对瞬时大流量的最佳解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;推荐使用Spring Cloud Alibaba+Sentinel&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Nginx&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Nginx是一块轻量级的Web服务器/反向代理服务器，目前在github上Star 13.3k Fork 4.9k Watch 951，整体关注度也非常高，最近一次更新是2020年12月5日，最新的版本为release-1.19.6。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么如何使用Nginx进行应用的分布式容错和降级呢？答案就是Nginx+Lua可以实现分布式容错和降级，利用Lua脚本可以实现限流算法，并从应用接入层做容错和降级。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Guava&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Guava是一种基于开源的Java库，其中包含谷歌内部使用的很多核心库。这个库是为了方便编码，并减少编码错误。这个库提供了用于集合、缓存、支持原语、并发性、常见注解、字符串处理、I/O等实用方法API，这些都是谷歌开发者结合自身业务场景的最佳实践，可以说是一块非常优秀的开源中间件框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Guava - RateLimiter使用的是一种叫令牌桶的流控算法，RateLimiter会按照一定的频率往桶里扔令牌，线程拿到令牌才能执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Guava目前在github上Star 40k Fork 8.9k Watch 2.5k，最近一次更新是2020年12月15日，最新版本为30.1，无论是开源的关注度和活跃度都非常高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Redis&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis是互联网技术领域使用最为广泛的存储中间件，它是“Remote Dictionary Service”（远程字典服务）的首字母缩写。Redis以其超高的性能、完美的文档、简洁易懂的源码和丰富的客户端库支持在开源中间件领域广受&lt;/span&gt;&lt;span&gt;好评。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis采用C语言开发，目前在github上Star 47k Fork 18.5k Watch 2.7k，关注度也非常高，最近一次更新是2021年1月12日，目前最新版本为6.0.10，社区更新活跃度非常高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Redis中，有5种基础数据结构，分别为：string（字符串）、list（列表）、hash（字典）、set（集合）和zset（有序集合），合理的利用这些数据结构是可以达到分布式限流的效果，比如通过zset数据结构中的score值，来构造一个时间窗口，作为限流的滑动窗口，这样就可以快速的构造一个分布式限流算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Hystrix&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hystrix是Netflix公司开源的一款容错框架，包含常用的容错方法：线程池隔离、信号量隔离、熔断和降级回退。在高并发访问下，系统所依赖的服务的稳定性对系统的影响非常大，依赖有很多不可控的因素，比如网络连接变慢、资源突然繁忙、暂时不可用、服务宕机等。我们要构建稳定、可靠的分布式系统，就必须要有一套容错的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hystrix目前在github上Star 20.9k fork 4.3k Watch 1.7k，可以说关注度非常高，但是最近一次版本更新是2018年11月17日，版本为v1.5.18，已经有两年没更新代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;Resilience4j&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Resilience4j 是一个比较轻量的熔断降级库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，Resilience4j 的模块化做的比较好，将每个功能点（如熔断、限速器、自动重试）都拆成了单独的模块，这样整体结构很清晰，用户也只需要引入相应功能的依赖即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，Resilience4jR是针对 Java 8 和函数式编程设计的，API 比较简洁优雅。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时，与 Hystrix 相比，Resilience4j 增加了简单的限速器和自动重试特性，使用场景更加丰富。Resilience4j 属于一个新兴项目，社区也在蓬勃发展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来说，Resilience4j 是比较轻量的库，在较小较新的项目中使用还是比较方便的。但是 Resilience4j 只包含限流降级的基本场景，对于非常复杂的企业级服务架构可能无法很好地 cover 住；同时 Resilience4j 缺乏生产级别的配套设施（如提供规则管理和实时监控能力的控制台）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Resilience4j目前在github上Star 6.4k Fork 857 Watch 215，最近一次版本更新是2020年10月19号，最新的release版本是v1.6.1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Sentinel&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Sentinel 一款面向分布式服务架构的轻量级流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助用户保障服务的稳定性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Sentinel 的核心思想：根据对应资源配置的规则来为资源执行相应的流控/降级/系统保护策略。在 Sentinel 中资源定义和规则配置是分离的。用户先通过 Sentinel API 给对应的业务逻辑定义资源，然后可以在需要的时候动态配置规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Sentinel 的优势和特性：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;轻&lt;/span&gt;&lt;span&gt;量级，核心库无多余依赖，性能损耗小；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;方便接入，开源生态广泛。&lt;/span&gt;&lt;span&gt;Sentine&lt;/span&gt;&lt;span&gt;l &lt;/span&gt;&lt;span&gt;对&lt;/span&gt;&lt;span&gt; Dubbo&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Spring Cloud&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Web Servlet&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;gRPC &lt;/span&gt;&lt;span&gt;等常用框架提供适配模块，只需引入相应依赖并简单配置即可快速接入；&lt;/span&gt;&lt;span&gt;同时针对自定义的场景&lt;/span&gt;&lt;span&gt; Sentinel &lt;/span&gt;&lt;span&gt;还提供低侵入性的注解资源定义方式，方便自定义接入；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;丰富的流量控制场景。&lt;/span&gt;&lt;span&gt;Sentinel &lt;/span&gt;&lt;span&gt;承接了阿里巴巴近&lt;/span&gt;&lt;span&gt; 10 &lt;/span&gt;&lt;span&gt;年的双十一大促流量的核心场景，流控维度包括流控指标、流控效果（塑形）、调用关系、热点、集群等各种维度，针对系统维度也提供自适应的保护机制；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;易用的控制台，提供实时监控、机器发现、规则管理等能力；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;完善的扩展性设计，提供多样化的 SPI 接口，方便用户根据需求给 Sentinel 添加自定义的逻辑。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;对比以上几种解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Nginx和Redis具备一定的分布式容错和降级能力，但是从功能完整性角度肯定是不如Sentinel、Hystrix和Resilience4j，Guava虽然也具备容错和降级能力，但是不具备分布式能力，它是基于单实例JVM的。基于以上原因，这里就对比下Sentinel、Hystrix和Resilience4j。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Sentinel&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Hystrix&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Resilience4j&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;隔离策略&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;信号量隔离（并发线程数限流）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;线程池隔离/信号量隔离&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;信号量隔离&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;熔断降级策略&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;基于响应时间、异常比率、异常数&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;基于异常比率&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;基于异常比率、响应时间&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;实时指标实现&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;滑动窗口（LeapArray）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;滑动窗口（基于RxJava）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Ring Bit Buffer&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;动态规则配置&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持多种数据源&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持多种数据源&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;有限支持&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;扩展性&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;多个扩展点&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;插件形式&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;SDK形式&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;基于注解的支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;限流&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;基于QPS限流和基于调用关系限流&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;有限的支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;Rate Limiter&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;流量整形&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持预热模式、匀速器模式和预热排队模式&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;不支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;简单的Rate Limiter模式&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;系统自适应保护&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;不支持&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;不支持&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;控制台&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;提供开箱即用的控制台，可配置规则、查看秒级监控、机器治理等。&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;简单的监控查看&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;不提供控制台，可对接其它监控系统。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;常见框架适配&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;Servlet、HttpClient、Dubbo、Spring Web等&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;Servlet、Spring Cloud Netflix&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;部分支持&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐使用Spring Cloud Alibaba+Sentinel，可以从服务治理和流量治理，两重维度去治理微服务，高效、简单并且符合主流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8eae0bdb98c892be0b770a8953d3b4ac</guid>
<title>如何设计API接口，实现统一格式返回？</title>
<link>https://toutiao.io/k/r07coyq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100010006&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.20575131632239774&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hs540iaTKoaKPniafc8icFWanFqBKibEfLvQvxZs99SDAKpl4Fia8r5QQAwJxJD84kuribaLFNicy4eWDiawHu9BHMiayicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2469&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源：toutiao.com/i6694404645827117572&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;在移动互联网，分布式、微服务盛行的今天，现在&lt;span&gt;项目绝大部分都采用的微服务框架，前后端分离方式&lt;/span&gt;，（题外话：&lt;span&gt;前后端的工作职责越来越明确&lt;/span&gt;，现在的前端都称之为&lt;span&gt;大前端&lt;/span&gt;，技术栈以及生态圈都已经非常成熟；以前后端人员瞧不起前端人员，&lt;span&gt;那现在后端人员要重新认识一下前端&lt;/span&gt;，前端已经很成体系了）。&lt;/section&gt;&lt;section&gt;一般系统的&lt;span&gt;大致整体架构图&lt;/span&gt;如下：&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8091715976331361&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMl7EcUPocrThs9tEibIibgax3jSZ0eib5bjo4ibDoYQ03k2ostqq3fxqyShVS10Drbh0XvsU0TnbUsJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1352&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;section&gt;需要说明的是，有些小伙伴会回复说，&lt;span&gt;这个架构太简单了吧，太low了，什么网关啊，缓存啊，消息中间件啊&lt;/span&gt;，都没有。&lt;span&gt;因为这篇主要介绍的是API接口&lt;/span&gt;，所以我们聚焦点，其他的模块小伙伴们自行去补充。&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;接口交互&lt;/span&gt;&lt;/section&gt;&lt;section&gt;前端和后端进行交互，&lt;span&gt;前端按照约定请求URL路径，并传入相关参数，后端服务器接收请求，进行业务处理，返回数据给前端。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;针对&lt;span&gt;URL路径的restful风格&lt;/span&gt;，以及传入参数的&lt;span&gt;公共请求头的要求（如：app_version,api_version,device等）&lt;/span&gt;，这里就不介绍了，小伙伴们可以自行去了解，也比较简单。&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;着重介绍一下&lt;span&gt;后端服务器如何实现把数据返回给前端？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;返回格式&lt;/span&gt;&lt;/section&gt;&lt;section&gt;后端返回给前端我们一般用JSON体方式，定义如下：&lt;/section&gt;&lt;pre&gt;&lt;section&gt;{&lt;br/&gt;#返回状态码&lt;br/&gt;code:integer,&lt;br/&gt;#返回信息描述&lt;br/&gt;message:string,&lt;br/&gt;#返回值&lt;br/&gt;data:object&lt;br/&gt;}&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;CODE状态码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;code返回状态码，一般小伙伴们是在&lt;span&gt;开发的时候需要什么，就添加什么&lt;/span&gt;。&lt;/section&gt;&lt;section&gt;如接口要返回用户权限异常，我们加一个&lt;span&gt;状态码为101吧&lt;/span&gt;，下一次又要加一个数据参数异常，就&lt;span&gt;加一个102的状态码&lt;/span&gt;。这样虽然能够&lt;span&gt;照常满足业务&lt;/span&gt;，但状态码太凌乱了&lt;/section&gt;&lt;section&gt;我们应该可以参考HTTP请求返回的状态码&lt;/section&gt;&lt;pre&gt;&lt;section&gt;：下面是常见的HTTP状态码：&lt;br/&gt;200 - 请求成功&lt;br/&gt;301 - 资源（网页等）被永久转移到其它URL&lt;br/&gt;404 - 请求的资源（网页等）不存在&lt;br/&gt;500 - 内部服务器错误&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.35619047619047617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMl7EcUPocrThs9tEibIibgaxhlP2PCE8LDgIMkUDjKWWdDRn7IKAR0MldBzCmqwNiceGKNRfHT37aiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1050&quot;/&gt;&lt;/p&gt;&lt;section&gt;我们可以参考这样的设计，这样的好处就把&lt;span&gt;错误类型归类到某个区间内&lt;/span&gt;，如果区间不够，可以设计成4位数。&lt;/section&gt;&lt;pre&gt;&lt;section&gt;#1000～1999 区间表示参数错误&lt;br/&gt;#2000～2999 区间表示用户错误&lt;br/&gt;#3000～3999 区间表示接口异常&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;这样前端开发人员在得到返回值后，&lt;span&gt;根据状态码就可以知道，大概什么错误&lt;/span&gt;，再根据message相关的信息描述，&lt;span&gt;可以快速定位。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Message&lt;/span&gt;&lt;/section&gt;&lt;section&gt;这个字段相对理解比较简单，就是发生错误时，如何友好的进行提示。一般的设计是和code状态码一起设计，如&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4275092936802974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMl7EcUPocrThs9tEibIibgaxaHxYzmCRBf7FvIwp83Orat7qgNeTyD75WXrKLAVasVGytURWbBfSBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1076&quot;/&gt;&lt;/p&gt;&lt;section&gt;再在枚举中定义，状态码&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9293628808864266&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMl7EcUPocrThs9tEibIibgax9llvoUiaGEQq0u7BbxibY7UuicW01WsNk4Vo7tD2quEZ24qWfGy1ofKZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1444&quot;/&gt;&lt;/p&gt;&lt;section&gt;状态码和信息就会一一对应，比较好维护。&lt;/section&gt;&lt;section&gt;&lt;span&gt;Data&lt;/span&gt;&lt;/section&gt;&lt;section&gt;返回数据体，JSON格式，根据不同的业务又不同的JSON体。&lt;/section&gt;&lt;section&gt;我们要设计一个返回体类Result&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5434782608695652&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMl7EcUPocrThs9tEibIibgaxn1Gx6BI0RuZDEN2Nj2smaFNBnZ0HJ9OHcR3jSUkLV3Ekpe21EmgH5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1288&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;控制层Controller&lt;/span&gt;&lt;/section&gt;&lt;section&gt;我们会在controller层处理业务请求，并返回给前端，以order订单为例&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5062761506276151&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMl7EcUPocrThs9tEibIibgaxr8n5YT17duDZ4ZncpgBiaX0uLD8CoiciaeubMdj0n3icMKsGaRDeuGAllA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1434&quot;/&gt;&lt;/p&gt;&lt;section&gt;我们看到在获得order对象之后，我们是用的&lt;span&gt;Result构造方法进行包装赋值&lt;/span&gt;，然后进行返回。小伙伴们有没有发现，&lt;span&gt;构造方法这样的包装是不是很麻烦&lt;/span&gt;，我们可以优化一下。&lt;/section&gt;&lt;section&gt;&lt;span&gt;美观优化&lt;/span&gt;&lt;/section&gt;&lt;section&gt;我们可以在Result类中，加入静态方法，一看就懂&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8737745098039216&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMl7EcUPocrThs9tEibIibgaxy7Ho8yoSFiatG4AhbAxBO6sPiaR2ypt0bkAOWv8Zd20umibvSqUCYicdtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1632&quot;/&gt;&lt;/p&gt;&lt;section&gt;那我们来改造一下Controller&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5068870523415978&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMl7EcUPocrThs9tEibIibgax4DgfLjyGDEWC8XyAXSIgiaSUXApT6WES2ZzKecoQ8J4moALibgpjJosQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1452&quot;/&gt;&lt;/p&gt;&lt;section&gt;代码是不是比较简洁了，也美观了。&lt;/section&gt;&lt;section&gt;&lt;span&gt;优雅优化&lt;/span&gt;&lt;/section&gt;&lt;section&gt;上面我们看到在&lt;span&gt;Result类中增加了静态方法&lt;/span&gt;，使得业务处理&lt;span&gt;代码简洁&lt;/span&gt;了。但小伙伴们有没有发现这样有&lt;span&gt;几个问题：&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;1、每个方法的返回都是Result封装对象，没有业务含义&lt;/section&gt;&lt;section&gt;2、在业务代码中，成功的时候我们调用Result.success，异常错误调用Result.failure。是不是很多余&lt;/section&gt;&lt;section&gt;3、上面的代码，判断id是否为null，其实我们可以使用hibernate validate做校验，没有必要在方法体中做判断。&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;我们最好的方式直接返回真实业务对象，最好不要改变之前的业务方式，如下图&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.45203488372093026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMl7EcUPocrThs9tEibIibgaxLNGCBl2NU4JVaBI2eq4IZ2l7iaL4c4n4pc42dSBIzd0aHMVZzRo6YdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1376&quot;/&gt;&lt;/p&gt;&lt;section&gt;这个和我们平时的代码是一样的，非常直观，直接返回order对象，这样是不是很完美。&lt;span&gt;那实现方案是什么呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实现方案&lt;/span&gt;&lt;/section&gt;&lt;section&gt;小伙伴们怎么去实现是不是有点思路，在这个过程中，我们需要做几个事情&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;1、定义一个注解@ResponseResult，表示这个接口返回的值需要包装一下&lt;/section&gt;&lt;section&gt;2、拦截请求，判断此请求是否需要被@ResponseResult注解&lt;/section&gt;&lt;section&gt;3、核心步骤就是实现接口ResponseBodyAdvice和@ControllerAdvice，判断是否需要包装返回值，如果需要，就把Controller接口的返回值进行重写。&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;注解类&lt;/span&gt;&lt;/section&gt;&lt;section&gt;用来标记方法的返回值，是否需要包装&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.361244019138756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMl7EcUPocrThs9tEibIibgaxyvSIIAZSqKE43URzs0hfeAN97leFJlegCNqibTo05Ch7KpT00kDRWlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;836&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;拦截器&lt;/span&gt;&lt;/section&gt;&lt;section&gt;拦截请求，是否此请求返回的值需要包装，其实就是运行的时候，解析@ResponseResult注解&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5302083333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMl7EcUPocrThs9tEibIibgaxviaedSCaq4ZDPU3ZPhDABraUcnibhicQ9m6Zra8pXQ2VHnBMQyxZtz8icg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;此代码核心思想，就是获取此请求，是否需要返回值包装，设置一个属性标记。&lt;/section&gt;&lt;section&gt;&lt;span&gt;重写返回体&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4557291666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMl7EcUPocrThs9tEibIibgaxVECEIrbUEed3KCEaHStxEMdPtg1YGlZ9DLr8yJaKBCticjeAZ6GeiapA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;上面代码就是&lt;span&gt;判断是否需要返回值包装&lt;/span&gt;，如果&lt;span&gt;需要就直接包装&lt;/span&gt;。这里我们只处理了正常成功的包装，&lt;span&gt;如果方法体报异常怎么办&lt;/span&gt;？处理异常也比较简单，只要判断body是否为异常类。&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.26875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMl7EcUPocrThs9tEibIibgax4qaicNUr1HdLBibxm7Yj9mCglauhxUUQRfdLF9ice0l1Tqicl0fhUyDxiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;怎么做全局的异常处理，篇幅原因，这里就不做介绍了，只要思路理清楚了，自行改造就行。&lt;/section&gt;&lt;section&gt;&lt;span&gt;重写Controller&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.46677740863787376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/QCu849YTaIMl7EcUPocrThs9tEibIibgaxRuO1svos7icYh1UwtIKniamCNs7FOWXWPYHGU6wjksuOou63hB1EsicAA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1204&quot;/&gt;&lt;/p&gt;&lt;section&gt;在控制器类上或者方法体上&lt;span&gt;加上@ResponseResult注解&lt;/span&gt;，这样就ok了，简单吧。到此返回的设计思路完成，是不是又简洁，又优雅。&lt;/section&gt;&lt;section&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/section&gt;&lt;section&gt;这个方案&lt;span&gt;还有没有别的优化空间&lt;/span&gt;，当然是有的。如：&lt;span&gt;每次请求都要反射一下，获取请求的方法是否需要包装，其实可以做个缓存，不需要每次都需要解析&lt;/span&gt;。当然整体思路了解，小伙伴们就可以在此基础上面自行扩展。谢谢！！&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;逆锋起笔&lt;/code&gt;是一个专注于程序员圈子的技术平台，你可以收获&lt;code&gt;最新技术动态&lt;/code&gt;、&lt;code&gt;最新内测资格&lt;/code&gt;、&lt;code&gt;BAT等大厂的经验&lt;/code&gt;、&lt;code&gt;精品学习资料&lt;/code&gt;、&lt;code&gt;职业路线&lt;/code&gt;、&lt;code&gt;副业思维&lt;/code&gt;，微信搜索&lt;code&gt;逆锋起笔&lt;/code&gt;关注！&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247494493&amp;amp;idx=2&amp;amp;sn=0a8c5777a83b3a8e258fbc87cf99a5a1&amp;amp;chksm=fa3f0a06cd488310cc0d0f14d9ba2c67b676a2869bed0df3c1c5c32dfeda2c0b973c1d7f46df&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;API 快速开发平台设计思考&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247493202&amp;amp;idx=2&amp;amp;sn=07dd50f2cf3dee4fb8de9b96453bf09e&amp;amp;chksm=fa3f0709cd488e1feb6389d0e4f9316f9ce6c95e4e9af456ef52ec2e1ea57e0dea5f09810765&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;老旧的 API，该如何处理？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247494317&amp;amp;idx=2&amp;amp;sn=5cfeda6a7de51e99d85140651d3f3836&amp;amp;chksm=fa3f0bf6cd4882e028099ed1caef5b232f2e35b4e3d560ced3c4b59718cac93b85ab155e57b7&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;微服务 API 设计的实践与思考总结&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247489902&amp;amp;idx=2&amp;amp;sn=10f106a73e6d616d14df529ed9019db7&amp;amp;chksm=fa3cf835cd4b7123c05b83ef73b55ed431b7d3261c081f9b21e8dff69c8fa898be06bf2c381b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;瞧瞧，人家那后端 API 接口写得多优雅！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247488906&amp;amp;idx=1&amp;amp;sn=c22fea8abd837697e90a5e8a61973c01&amp;amp;chksm=fa3cf4d1cd4b7dc7871804ce1ab68772415077c18a8f8a7355ebab8e773f62a7a9ccdaca12c9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;卧槽！我随便写的一个 API 竟获得 2.5 亿的访问量&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;PS：如果觉得我的分享不错，欢迎大家随手点赞、在看。&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>71f55c8a2335c845900e30be0385c0b8</guid>
<title>行业实践-Apache Flink 在移动云实时计算的实践</title>
<link>https://toutiao.io/k/4zaegp9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;span&gt;&lt;span&gt;▼ 关注「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Apache Flink&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」，获取更多技术干货 &lt;span&gt;▼&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU3Mzg4OTMyNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/8AsYBicEePu6FJHxaI14AsXuzeg4SybT0hiaCSohrIY75oiaOMzhQU7RouiafjNa76k2CtD6xxB2JqnawqFqV3zg3A/0?wx_fmt=png&quot; data-nickname=&quot;Apache Flink&quot; data-alias=&quot;apacheflinkcc&quot; data-signature=&quot;Flink 中文社区官微，Flink PMC 维护&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;本文整理自移动软件开发工程师谢磊在 Flink Forward Asia 2021 平台建设专场的演讲。本篇内容主要分为四个部分：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;实时计算平台建设&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;中移信令业务优化&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;稳定性实践&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;未来方向的探索&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Tips：&lt;/strong&gt;点击&lt;/span&gt;&lt;span&gt;&lt;strong&gt;「阅读原&lt;/strong&gt;&lt;strong&gt;文」&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;查看原文视频 &amp;amp; 演讲PDF～&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n105&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaicTdI1oDK7yFxKWpKX6KICTskSFfHERMZqrTk90NRyzwLbib9ica3Lo3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;中移（苏州）软件技术有限公司是中国移动通信有限公司的全资子公司，公司定位为中国移动云设施的构建者、云服务的提供者、云生态的绘制者。公司以移动云为运营中心，产品和服务在电信、政务、金融、交通等领域都有广泛应用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p cid=&quot;n107&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;一、实时计算平台介绍&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 cid=&quot;n107&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p cid=&quot;n12&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaSibEYHjILFpDKQT1KM5RkiaflpeO6GyWicMgaLb4tIwGedEbGSblKcedg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;实时计算引擎在移动云的演进分为几个阶段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;2015 年到 16 年，我们使用的是第一代实时计算引擎 Apache Storm；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;17 年我们开始调研 Apache Spark Streaming，它可以与自研框架进行整合，降低了运维压力和维护成本；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;18 年，用户对云计算的需求越来越多，Storm 和 Spark已经无法很好地满足业务。同时我们研究了流计算比较出名的几篇文章，发现 Apache Flink 已经比较完整地具备了文中提到的一些语义；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;19 年 - 20 年，我们开始实现云服务，并把实时计算平台上线至公有云和私有云；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;20 年 - 21 年，我们开始调研实时数仓，并将 LakeHouse 上线移动云。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n14&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaMVSQzAbcOIgflHM6gQTiaibTrgwtPuKEKOiaaLGIy8CKZ106ibrFIoLtVg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前 Flink 主要用于中移信令数字的处理、实时用户画像和埋点、实时数仓、实时运维监控、实时推荐以及移动云的数据管道服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n16&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaHhTiayHjeG7X5OctEfMCs8ltTQ99ib5So6bupIYAiaBfwWxBRiaB1Ob7Iw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中移的实时计算平台功能分为三大部分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一部分是服务管理，支持了任务生命周期的托管、Flink 和 SQL 作业、Spark Streaming 作业以及引擎多版本的支持；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二部分是 SQL 的支持，提供了在线 Notebook 编写、SQL 语法检测、UDF 管理和元数据管理；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三部分是任务运维，支持实时任务的日志检索、实时性能指标采集以及消息延迟报警和任务反压报警等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文主要分享两个核心设计：引擎多版本的设计和实时任务日志检索。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n19&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaBeTWgzLibT5uxOhndeqCwib368lNHvz5d5kfyvOX8qYziblnktm0Eicuhg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在日常有任务场景中，我们发现用户程序调试成本比较高，用户尝试新版本引擎的周期也比较长，此外无法规避用户 hack 引擎的功能以及有些任务运行失败但是没有异常信息，因此我们引入了引擎多版本设计。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;多版本提交的流程如下：用户的任务首先会提交到 rtp 服务，rtp 服务将用户程序上传到 HDFS 保存，需要提交的时候再从 HDFS 拉回来提交到 Yarn 集群。此类任务存在一个共性——作业中包含 Apache Flink 的核心包，这会导致很多问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n22&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiabxg1sZtwFovEYXFlp2n3Cjm4iaeIFiaJ4L01gGrQticvQ2sBJPTb31Nfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;因此，首先我们会与业务沟通，使作业包里面不包含 Flink 的 core 包，但是这样的收益比较小，所以我们在平台侧做了一次检测，在用户在上传 jar 包的过程中主动检测用户包里是否包含 core 包。如果发现作业包含了非法核心包，则会阻止用户提交。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如此简单的操作，却为公司带来了很大的收益：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一，极大降低了一些低价值 bug 的定位成本；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二，作业升级和回退版本更加方便；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三，提高了作业的稳定性和安全性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n25&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaya9EMV5Bj5KaV1JVic8hjhVA5hcGkpxibpuGcUBerBwTE64P3RqL3KFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在日常业务场景中，我们需要通过日志检索来验证流程的复杂逻辑。此外，原生 TM 的 UI 日志打不开，容易卡死。以及 TM UI 不支持检索，如上图所示，当业务逻辑非常复杂的时候，Flink UI 无法提供以上功能。因此我们设计了实时任务日志检索功能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n27&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaickibr1hK5bR6icJLafcuH0r3ne04d1wMt2FRma6bKG9G2FEraUncJMGQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时任务日志检索的设计上需要考虑以下几个问题：如何采集作业程序日志，并将 TM 分布在不同的机器上？如何不侵入作业进行采集日志？如何限制作业打印大量无用日志？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;针对第一个问题，我们采用的push模式来降低采集日志的压力；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;针对第二个问题，参考 spring 中的 AOP 机制，我们使用 AspectJWeaver，切入点是 log4j 的 input 或 event，之后把日志发送到 Sender；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;针对第三个问题，我们采用的是 RateLimiter 来进行限流。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n32&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaytr52sy9yhZoYlhia3lkO2ibr55MKy2MINxhibGWIEoUdFFcvSfVrUENw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图是实时任务日志检索的整体设计。我们在原生的 TaskManager 下面加了 AOP 层，日志会先通过 TaskManager 发送 task，再发送到 AOP。整个 AOP 对用户无感知，因为采用了切面的方式。之后再发送到 RateLimiter，再到 Sender，由 RateLimiter 进行限流的操作。接着日志继续发送到 Kafka，做检索的时候日志会被发送到 Elestic Search。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n34&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiagXbrCWxdnic9qV2QibjNdiaic2iceI7UR3FvxicLY6EeXKRh456SQhjWmc3Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有了实时任务日志检索之后，业务程序不需要做任何改动就可以支持日志的检索。同时，开发人员可以便捷地验证业务逻辑。得益于限流措施，也不会存在日志存储瓶颈。此外，也减轻了平台管理的压力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p cid=&quot;n211&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;二、中移信令业务优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 cid=&quot;n211&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p cid=&quot;n37&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCia2EibDopppjGYWs9D0fIG36icEVUdVp46wBlKSea2bA4icZywL7zKwGW0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;中国移动信令业务的出现是为了解决各级政府部门有关于移动用户资源数据的需求，包括旅游部门、应急部门、交通行业等，如交通规划、交通调查、旅游景区等重点区域的人口流量监测、流动人口监测管理等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;依赖于中国移动手机用户的高覆盖率，利用移动通信网络区域服务技术以及 GIS 技术，通过对移动用户信令数据的统计，对城市人口数量、流动性等要素进行分析预测，为城市规划、交通规划、管理、资源配置、外来人口管理、政策制定等政府管理行为提供决策数据支持。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaF1IIW1fXEMibKURLIqHV2grQyQ8VXB5jrUTTQgZ0gNV4mE6GEUfTIxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;业务日均数据大概是 10PB，20 万亿/天，单条数据大小 0.5KB，包含了 2345G 上网数据、位置信令、省份城市、网络类型、接口类型等等。数据处理也比较复杂，要做数据加密、压缩以及版本的统一等。上图是处理信令数字时的条件和业务逻辑等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n42&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaDoy9dwFSVYQ7OcexrCQd33aPHZ8Rlw1z2Aw2doMvichz7WIf2ibWHEOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;将需求化繁为简，应对到集群上，就是一个上报网关。它会将各地的信令数据进行上传，由 Flume 集群进行数据接收，再传输到 Hadoop 集群。上图可以看到，Flume 与 Hadoop 之间存在一面物理墙。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p cid=&quot;n44&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaQS3DqfmYNVs8NO9XN6qZtcKDppz7nbYicjRZL8ia3hu7BGj9mTUkYHog/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着数据量增大，我们也遇到了很多问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一，Flume 集群会一直报警提示 Flume channel full；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二，防火墙超限，也会进行报警；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三，Flume 在写 Kafka 的时候，Kafka 发送端会发送超时报警；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第四，下游处理信令数据的时候，Spark Streaming 处理是不稳定的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n46&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiauvBeLQTssCxO4WvFbW4rQ89RoAMjzLxPRaRricA4iauLibGc5AHBaLxMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述问题总结起来可以分为两大类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一类是写入性能问题。Kafka 在写入的时候频繁超时，生产性能存在瓶颈。以及 Flume 在发送数据时无法达到网卡的上限速度；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二类是架构设计问题。&lt;span&gt;架构涉及的组件比较多导致维护的成本比较高；此外，组件职责不清晰，比如 Flume 中存在数据清洗的逻辑；还有 Spark 逻辑和处理逻辑复杂，存在多处 shuffle，处理性能不稳定。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n50&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaPJu8VeibGtwpkRKHBtRscyrkib0u9naG9rLN2u0Qry4mQicoPkkUaDXOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先要解决的是 PRO 写入 Kafka 超时的问题。为了解决这个问题，我们进行了以下优化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优化了防火墙端口；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优化了 Kafka 服务器的一些性能参数；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在 Kafka 服务器端进行了一些性能参数调优。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是这并不能彻底解决 Flume 写入 Kafka 超时的问题，于是我们把重点聚焦到客户端。首先是客户端的参数如何优化，尤其是 batch.size、buffer.memory 和 request.time.out 如何调优。其次是如何达到单机网络最大数网速，即单机情况下设置多少客户端并发合适。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n56&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiavwz4q01BkNIOFnT21LCnYAiaC5xf5ICCUcBuxUqibQhQfdLcBYmpUS2g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过实践我们发现，当 batch.size 为 256 兆，buffer.memory 为 128 兆时，性能会达到最优，但此时并没有达到网卡的最大速度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n58&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaQoGFtRq2nicFicJlPSHCOqodD1K8WcVOL4GN3sb406zfY3XElk2fVNYA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;于是我们进行了第二轮测试，增加了 compression.type，期望通过压缩发送的数据来提高发送带宽，但是结果并不符合我们的期望。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是由于 Kafka 在低版本的时候存在一个问题，参数在它的验证脚本里的每个值都是一样的，所以它的压缩比会比较大。但是实际的生产环境中每条数字都是不一样的，所以压缩比非常小。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n61&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaOCmZxB6T79UT5pvMLWAPy4mQqPJJwsiauc2ThibzOdmaHLB9sCErzANA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外一个问题是如何达到网卡的最大速度？最简单的方式是增加并行度，但是并行度并不是越大越好。经过实践发现，并发度为 4 的时候能达到网卡的最大速度，超过 4 以后平均耗时会明显增加，也会导致 Kafka 写入超时。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n63&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiazcymdg4fe6ZsNL62ibgHZfHqmORXfUDlTPibRI71uEMmhiaGLUwOCt7fQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二点是 Flume channel full 的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;扩展服务的时候，服务的事务 API 处理是比较底层的，需要手动进行处理。此外服务的事务处理数据的时候，需要将数据进行拷贝。如上图所示，当数据从 source 发送到 channel 的时候，会把一份数据先 copy 到内存里，从 channel 再发送到 sink 的时候，又会从 channel 再 copy 到内存。这个过程中的两次 copy 浪费了资源。而 Flink 做事务的时候是借助于状态管理，因而它的处理性能是比较稳定的。另外，Flink 拥有丰富的 source 和 sink，扩展性比较强。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n66&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaickpibjGKJDASLQ2ssQf27BXLlBINe6UibLFaGFmqzO48YddHKjDB2Vrg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此，我们决定使用 Flink 代替 Flume 来解决问题。替换成 Flink 以后，提升了采集性能，解决了海量数据发送性能瓶颈，稳定性显著提高。同时，明确了组件职责，我们将原有的服务中存在的逻辑全部转移至后端实时数据分解，让采集层专注于数据汇聚，处理层专注于数据分拣。另外，我们统一了技术栈，端到端采用了 Flink 框架，获得了更高的性能，也降低了开发和运维成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最终整体性能提升了 1/3 且降低了维护成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p cid=&quot;n294&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;三、稳定性实践&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 cid=&quot;n294&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p cid=&quot;n70&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaGxswW4dBbkRuhM6VryIRPsHicicj3YKicqXS2R31mz1zAPiaiaibuANzDXrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作业稳定性主要指服务故障以及处理方案，服务故障主要包括作业运行失败、作业消费延迟、作业出现 OOM 以及作业异常重启。对应的处理方案是可以将作业进行物理隔离，服务进行降级，加强资源监控以及对服务进行拆分。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而平台维护人员最关心的是整体性的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n73&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaS78pZkA1ib4E2Xg54N5UkAdUTH7mS85JLibxnvzbeia65JSeoR23v8vOQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果 ZooKeeper 集群中有一台服务器出现了网络服务瞬断，它也会引起大批量的任务重启。Flink JobManager 会通过 ZooKeeper 来进行 leader 的选举和发现 CheckpointID 的计数器管理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n75&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaiaOasARggkxiaxldQQro51xJ9313eNcbIaicoRRBsleKiafLyAZo1o7WGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;于是我们分析了 ZooKeeper 网络状态的转换。客户端在连接 ZooKeeper 集群的时候，它的状态先是 connected 状态，网络瞬断后它会变成 Suspended 状态，Suspended 状态会转换为 lost 状态，还会继续转换为 reconnected 状态。Flink 在使用 ZooKeeper 的时候会依赖一个 curator2.0 组件，然而这个组件存在一个缺陷，遇到 Suspended 状态就会直接将 leader 丢弃，这会导致大部分作业进行重启，这对于我们的业务来说是不可接受的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p cid=&quot;n77&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaV1dr19kNh7kElyMaXsVcPVu3zvuh7nDXJI4tgahbibNDa3FfruicD9oA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;官方直到 Flink 1.14 版本才对此问题进行修复。在之前的版本下，需要重新写 LeaderLatch，同时如果使用的是 Flink 1.8 版本，还需要同时修改 ZooKeeperCheckpointIDCounter。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p cid=&quot;n316&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;四、未来方向的探索&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 cid=&quot;n316&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p cid=&quot;n80&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCianrVq2cX16AiccaVduIs3wHldwAeq3Daic63HU5iaRKotHGPiccwq0ZdZMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;未来，我们主要会在这两个方向进行持续探索：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一，资源利用方向。包括 Elastic Scaling 调研和 K8s Yunikorn 资源队列调研。我们发现 Flink 上云之后存在着资源队列的问题，所以需要将用户的资源进行分队列管理；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二，数据湖方向。&lt;span&gt;首先是统一流批服务网关，做实时数仓的时候可能会采用不同的引擎，比如 Flink 和 Spark，它们属于两套不同的服务，所以需要做统一流批的服务网关。其次是数据血缘、数据资产和数据质量服务化。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;往期精选&lt;/p&gt;&lt;/section&gt;&lt;img data-ratio=&quot;2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8AsYBicEePu618icsCRqdhl723vSPl4FCiavs1wZVIo7nOPuhVkV0Kicx3blfX3YMugVCXiabaR0K1XZAiaD0Ca05GHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;50&quot;/&gt; &lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzg4OTMyNQ==&amp;amp;mid=2247495939&amp;amp;idx=1&amp;amp;sn=bf8ce5292bc685425a829831355cd558&amp;amp;chksm=fd387f41ca4ff657c57c77aca6bdc99de9aec00c1a40bc9c3e533be1ffdfa5cf6d7ee3de3516&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;联通实时计算平台演进与实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4255556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaVI3TPMGC3avOMpELzOH1ppdzkXAk6xz6Xs6vpo59K4hNatdPP25oAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzg4OTMyNQ==&amp;amp;mid=2247495906&amp;amp;idx=1&amp;amp;sn=8806069228df05ec3633de7a1e305227&amp;amp;chksm=fd387ea0ca4ff7b61fcde0d8b7b051b2ce91fa3bbda96789d9dc62fe1fb08077eb5a2d16e626&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4255556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiaukXBfgnr0IgInXqXKyafGHj3hEFhysHCkibM13AznToSHzLrMkIrBcA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzg4OTMyNQ==&amp;amp;mid=2247495878&amp;amp;idx=1&amp;amp;sn=d63bdeb4c790faf999bc038cd19131d5&amp;amp;chksm=fd387e84ca4ff792a0931917d19bbe6c28026f9ea09e0f1097b3626a84c851cb9afeaf763c0f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4255556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8AsYBicEePu618icsCRqdhl723vSPl4FCiakGvjYd3oOm6Y1diaUtPamXVhIBtGpvmwsibRYGzXurPWpKELEZzagquA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更多 Flink 相关技术问题，可扫码加入社区钉钉交流群～&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100010716&quot; data-ratio=&quot;1.2078189300411524&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8AsYBicEePu6PUTQaA1BP3Fb8uViccQpspmTibIYEfM7Wv6VACia9CDQfcN8huMVCafZ5s36wThUmbYRTOzMu4hd8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-fileid=&quot;100010714&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z6bicxIx5naLWBBEcl44aIic1Mthe1nZiaramW5s4e8WwyCYYbTzu6uPBpgI6sxNXNymEnOYKpJpcrItUia7lS64mA/640?wx_fmt=gif&quot;/&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;戳我，查看原文视频&amp;amp;演讲PDF～&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b56bb29d58b53a1f089c088b27afaade</guid>
<title>91.6K 的 Axios 项目有哪些值得借鉴的地方</title>
<link>https://toutiao.io/k/z9a31ne</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 是一个基于 Promise 的 HTTP 客户端，同时支持浏览器和 Node.js 环境。它是一个优秀的 HTTP 客户端，被广泛地应用在大量的 Web 项目中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阅读完本文，你将了解以下内容：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HTTP 拦截器的设计与实现；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HTTP 适配器的设计与实现；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何防御 CSRF 攻击。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们从简单的开始，先来了解一下 Axios。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;一、Axios 简介&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 是一个基于 Promise 的 HTTP 客户端，拥有以下特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持 Promise API；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够拦截请求和响应；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够转换请求和响应数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端支持防御 CSRF 攻击；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时支持浏览器和 Node.js 环境；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够取消请求及自动转换 JSON 数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在浏览器端 Axios 支持大多数主流的浏览器，比如 Chrome、Firefox、Safari 和 IE 11。此外，Axios 还拥有自己的生态：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22685185185185186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8RrZlXlKCGTZqlmNMEia7MFJvWsJVq6gzaaTOyTKDxGfXIrhNcY8icO33Ww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（数据来源 —— https://github.com/axios/axios/blob/master/ECOSYSTEM.md）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单介绍完 Axios，我们来分析一下它提供的一个核心功能 —— 拦截器。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;二、HTTP 拦截器的设计与实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.1 拦截器简介&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大多数 SPA 应用程序来说， 通常会使用 token 进行用户的身份认证。这就要求在认证通过后，我们需要在每个请求上都携带认证信息。针对这个需求，为了避免为每个请求单独处理，我们可以通过封装统一的 &lt;code&gt;request&lt;/code&gt; 函数来为每个请求统一添加 token 信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但后期如果需要为某些 GET 请求设置缓存时间或者控制某些请求的调用频率的话，我们就需要不断修改 &lt;code&gt;request&lt;/code&gt; 函数来扩展对应的功能。此时，如果在考虑对响应进行统一处理的话，我们的 &lt;code&gt;request&lt;/code&gt; 函数将变得越来越庞大，也越来越难维护。那么对于这个问题，该如何解决呢？Axios 为我们提供了解决方案 —— 拦截器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 是一个基于 Promise 的 HTTP 客户端，而 HTTP 协议是基于请求和响应：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8RrV5Em4ECwHynNEKTibfKiceMTGLfoXfpIuIkR67S4NdHX8YE1BQXFJP0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 Axios 提供了请求拦截器和响应拦截器来分别处理请求和响应，它们的作用如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;请求拦截器：该类拦截器的作用是在请求发送前统一执行某些操作，比如在请求头中添加 token 字段。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;响应拦截器：该类拦截器的作用是在接收到服务器响应后统一执行某些操作，比如发现响应状态码为 401 时，自动跳转到登录页。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Axios 中设置拦截器很简单，通过 &lt;code&gt;axios.interceptors.request&lt;/code&gt; 和 &lt;code&gt;axios.interceptors.response&lt;/code&gt; 对象提供的 &lt;code&gt;use&lt;/code&gt; 方法，就可以分别设置请求拦截器和响应拦截器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 添加请求拦截器&lt;/span&gt;&lt;br/&gt;axios.interceptors.request.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  config.headers.token = &lt;span&gt;&#x27;added by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; config;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 添加响应拦截器&lt;/span&gt;&lt;br/&gt;axios.interceptors.response.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;data&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  data.data = data.data + &lt;span&gt;&#x27; - modified by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; data;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么拦截器是如何工作的呢？在看具体的代码之前，我们先来分析一下它的设计思路。Axios 的作用是用于发送 HTTP 请求，而请求拦截器和响应拦截器的本质都是一个实现特定功能的函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以按照功能把发送 HTTP 请求拆解成不同类型的子任务，比如有用于处理请求配置对象的子任务，用于发送 HTTP 请求的子任务和用于处理响应对象的子任务。当我们按照指定的顺序来执行这些子任务时，就可以完成一次完整的 HTTP 请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解完这些，接下来我们将从 &lt;strong&gt;「任务注册、任务编排和任务调度」&lt;/strong&gt; 三个方面来分析 Axios 拦截器的实现。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.2 任务注册&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面拦截器的使用示例，我们已经知道如何注册请求拦截器和响应拦截器，其中请求拦截器用于处理请求配置对象的子任务，而响应拦截器用于处理响应对象的子任务。要搞清楚任务是如何注册的，就需要了解 &lt;code&gt;axios&lt;/code&gt; 和 &lt;code&gt;axios.interceptors&lt;/code&gt; 对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/axios.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createInstance&lt;/span&gt;(&lt;span&gt;defaultConfig&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt; Axios(defaultConfig);&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; instance = bind(Axios.prototype.request, context);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Copy axios.prototype to instance&lt;/span&gt;&lt;br/&gt;  utils.extend(instance, Axios.prototype, context);&lt;br/&gt;  &lt;span&gt;// Copy context to instance&lt;/span&gt;&lt;br/&gt;  utils.extend(instance, context);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; instance;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Create the default instance to be exported&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; axios = createInstance(defaults);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Axios 的源码中，我们找到了 &lt;code&gt;axios&lt;/code&gt; 对象的定义，很明显默认的 &lt;code&gt;axios&lt;/code&gt; 实例是通过 &lt;code&gt;createInstance&lt;/code&gt; 方法创建的，该方法最终返回的是 &lt;code&gt;Axios.prototype.request&lt;/code&gt; 函数对象。同时，我们发现了 &lt;code&gt;Axios&lt;/code&gt; 的构造函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/core/Axios.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Axios&lt;/span&gt;(&lt;span&gt;instanceConfig&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.defaults = instanceConfig;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.interceptors = {&lt;br/&gt;    &lt;span&gt;request&lt;/span&gt;: &lt;span&gt;new&lt;/span&gt; InterceptorManager(),&lt;br/&gt;    &lt;span&gt;response&lt;/span&gt;: &lt;span&gt;new&lt;/span&gt; InterceptorManager()&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在构造函数中，我们找到了 &lt;code&gt;axios.interceptors&lt;/code&gt; 对象的定义，也知道了 &lt;code&gt;interceptors.request&lt;/code&gt; 和 &lt;code&gt;interceptors.response&lt;/code&gt; 对象都是 &lt;code&gt;InterceptorManager&lt;/code&gt; 类的实例。因此接下来，进一步分析 &lt;code&gt;InterceptorManager&lt;/code&gt; 构造函数及相关的 &lt;code&gt;use&lt;/code&gt; 方法就可以知道任务是如何注册的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/core/InterceptorManager.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;InterceptorManager&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.handlers = [];&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;InterceptorManager.prototype.use = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;use&lt;/span&gt;(&lt;span&gt;fulfilled, rejected&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.handlers.push({&lt;br/&gt;    &lt;span&gt;fulfilled&lt;/span&gt;: fulfilled,&lt;br/&gt;    &lt;span&gt;rejected&lt;/span&gt;: rejected&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;// 返回当前的索引，用于移除已注册的拦截器&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.handlers.length - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过观察 &lt;code&gt;use&lt;/code&gt; 方法，我们可知注册的拦截器都会被保存到 &lt;code&gt;InterceptorManager&lt;/code&gt; 对象的 &lt;code&gt;handlers&lt;/code&gt; 属性中。下面我们用一张图来总结一下 &lt;code&gt;Axios&lt;/code&gt; 对象与 &lt;code&gt;InterceptorManager&lt;/code&gt; 对象的内部结构与关系：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36944444444444446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8Rr6X41s2fQrIMwmnvc2eGgtMgTOYPKcq4Ljibt4hPMZKpgPFHfKYSib4Sg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.3 任务编排&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经知道如何注册拦截器任务，但仅仅注册任务是不够，我们还需要对已注册的任务进行编排，这样才能确保任务的执行顺序。这里我们把完成一次完整的 HTTP 请求分为处理请求配置对象、发起 HTTP 请求和处理响应对象 3 个阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来看一下 Axios 如何发请求的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;axios({&lt;br/&gt;  &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;/hello&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;method&lt;/span&gt;: &lt;span&gt;&#x27;get&#x27;&lt;/span&gt;,&lt;br/&gt;}).then(&lt;span&gt;&lt;span&gt;res&lt;/span&gt; =&amp;gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;axios res: &#x27;&lt;/span&gt;, res)&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;axios res.data: &#x27;&lt;/span&gt;, res.data)&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面的分析，我们已经知道 &lt;code&gt;axios&lt;/code&gt; 对象对应的是 &lt;code&gt;Axios.prototype.request&lt;/code&gt; 函数对象，该函数的具体实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/core/Axios.js&lt;/span&gt;&lt;br/&gt;Axios.prototype.request = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;request&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  config = mergeConfig(&lt;span&gt;this&lt;/span&gt;.defaults, config);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; chain = [dispatchRequest, &lt;span&gt;undefined&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; promise = &lt;span&gt;Promise&lt;/span&gt;.resolve(config);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 任务编排&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.interceptors.request.forEach(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;unshiftRequestInterceptors&lt;/span&gt;(&lt;span&gt;interceptor&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    chain.unshift(interceptor.fulfilled, interceptor.rejected);&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.interceptors.response.forEach(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;pushResponseInterceptors&lt;/span&gt;(&lt;span&gt;interceptor&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    chain.push(interceptor.fulfilled, interceptor.rejected);&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 任务调度&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (chain.length) {&lt;br/&gt;    promise = promise.then(chain.shift(), chain.shift());&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; promise;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任务编排的代码比较简单，我们来看一下任务编排前和任务编排后的对比图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5194805194805194&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8Rrbbd0KNQHAppniblnic3LV8tY3HNr34y3cjVNCiaribABHttdsutYh0fYnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1078&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.4 任务调度&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任务编排完成后，要发起 HTTP 请求，我们还需要按编排后的顺序执行任务调度。在 Axios 中具体的调度方式很简单，具体如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &lt;span&gt;// lib/core/Axios.js&lt;/span&gt;&lt;br/&gt;Axios.prototype.request = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;request&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; promise = &lt;span&gt;Promise&lt;/span&gt;.resolve(config);&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (chain.length) {&lt;br/&gt;    promise = promise.then(chain.shift(), chain.shift());&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 chain 是数组，所以通过 while 语句我们就可以不断地取出设置的任务，然后组装成 Promise 调用链从而实现任务调度，对应的处理流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4064272211720227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8RrGEhJn06UYia59qWyW9WahD8KZ6t4ibshrPKcgg5aia1TO8yHibPJDAxveQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1058&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来回顾一下 Axios 拦截器完整的使用流程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 添加请求拦截器 —— 处理请求配置对象&lt;/span&gt;&lt;br/&gt;axios.interceptors.request.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  config.headers.token = &lt;span&gt;&#x27;added by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; config;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 添加响应拦截器 —— 处理响应对象&lt;/span&gt;&lt;br/&gt;axios.interceptors.response.use(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;data&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  data.data = data.data + &lt;span&gt;&#x27; - modified by interceptor&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; data;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;axios({&lt;br/&gt;  &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;/hello&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;method&lt;/span&gt;: &lt;span&gt;&#x27;get&#x27;&lt;/span&gt;,&lt;br/&gt;}).then(&lt;span&gt;&lt;span&gt;res&lt;/span&gt; =&amp;gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;axios res.data: &#x27;&lt;/span&gt;, res.data)&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍完 Axios 的拦截器，我们来总结一下它的优点。Axios 通过提供拦截器机制，让开发者可以很容易在请求的生命周期中自定义不同的处理逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，也可以通过拦截器机制来灵活地扩展 Axios 的功能，比如 Axios 生态中列举的 axios-response-logger 和 axios-debug-log 这两个库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考 Axios 拦截器的设计模型，我们就可以抽出以下通用的任务处理模型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3054945054945055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8Rroqic2FNRDU5ZGvq9jQ47sxYjCnQ658mM93CSTTc8sfjteQNNoAQqaHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;910&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;三、HTTP 适配器的设计与实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;3.1 默认 HTTP 适配器&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 同时支持浏览器和 Node.js 环境，对于浏览器环境来说，我们可以通过 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 或 &lt;code&gt;fetch&lt;/code&gt; API 来发送 HTTP 请求，而对于 Node.js 环境来说，我们可以通过 Node.js 内置的 &lt;code&gt;http&lt;/code&gt; 或 &lt;code&gt;https&lt;/code&gt; 模块来发送 HTTP 请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了支持不同的环境，Axios 引入了适配器。在 HTTP 拦截器设计部分，我们看到了一个 &lt;code&gt;dispatchRequest&lt;/code&gt; 方法，该方法用于发送 HTTP 请求，它的具体实现如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/core/dispatchRequest.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;dispatchRequest&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; adapter = config.adapter || defaults.adapter;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; adapter(config).then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;onAdapterResolution&lt;/span&gt;(&lt;span&gt;response&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; response;&lt;br/&gt;  }, &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;onAdapterRejection&lt;/span&gt;(&lt;span&gt;reason&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.reject(reason);&lt;br/&gt;  });&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过查看以上的 &lt;code&gt;dispatchRequest&lt;/code&gt; 方法，我们可知 Axios 支持自定义适配器，同时也提供了默认的适配器。对于大多数场景，我们并不需要自定义适配器，而是直接使用默认的适配器。因此，默认的适配器就会包含浏览器和 Node.js 环境的适配代码，其具体的适配逻辑如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/defaults.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; defaults = {&lt;br/&gt;  &lt;span&gt;adapter&lt;/span&gt;: getDefaultAdapter(),&lt;br/&gt;  &lt;span&gt;xsrfCookieName&lt;/span&gt;: &lt;span&gt;&#x27;XSRF-TOKEN&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;xsrfHeaderName&lt;/span&gt;: &lt;span&gt;&#x27;X-XSRF-TOKEN&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getDefaultAdapter&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; adapter;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; XMLHttpRequest !== &lt;span&gt;&#x27;undefined&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// For browsers use XHR adapter&lt;/span&gt;&lt;br/&gt;    adapter = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./adapters/xhr&#x27;&lt;/span&gt;);&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; process !== &lt;span&gt;&#x27;undefined&#x27;&lt;/span&gt; &amp;amp;&amp;amp; &lt;br/&gt;    &lt;span&gt;Object&lt;/span&gt;.prototype.toString.call(process) === &lt;span&gt;&#x27;[object process]&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// For node use HTTP adapter&lt;/span&gt;&lt;br/&gt;    adapter = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./adapters/http&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; adapter;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;getDefaultAdapter&lt;/code&gt; 方法中，首先通过平台中特定的对象来区分不同的平台，然后再导入不同的适配器，具体的代码比较简单，这里就不展开介绍。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;3.2 自定义适配器&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实除了默认的适配器外，我们还可以自定义适配器。那么如何自定义适配器呢？这里我们可以参考 Axios 提供的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; settle = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./../core/settle&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;myAdapter&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 当前时机点：&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//  - config配置对象已经与默认的请求配置合并&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//  - 请求转换器已经运行&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//  - 请求拦截器已经运行&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// 使用提供的config配置对象发起请求&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 根据响应对象处理Promise的状态&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; response = {&lt;br/&gt;      &lt;span&gt;data&lt;/span&gt;: responseData,&lt;br/&gt;      &lt;span&gt;status&lt;/span&gt;: request.status,&lt;br/&gt;      &lt;span&gt;statusText&lt;/span&gt;: request.statusText,&lt;br/&gt;      &lt;span&gt;headers&lt;/span&gt;: responseHeaders,&lt;br/&gt;      &lt;span&gt;config&lt;/span&gt;: config,&lt;br/&gt;      &lt;span&gt;request&lt;/span&gt;: request&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;    settle(resolve, reject, response);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 此后:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//  - 响应转换器将会运行&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//  - 响应拦截器将会运行&lt;/span&gt;&lt;br/&gt;  });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上示例中，我们主要关注转换器、拦截器的运行时机点和适配器的基本要求。比如当调用自定义适配器之后，需要返回 Promise 对象。这是因为 Axios 内部是通过 Promise 链式调用来完成请求调度，不清楚的小伙伴可以重新阅读 “拦截器的设计与实现” 部分的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经知道如何自定义适配器了，那么自定义适配器有什么用呢？在 Axios 生态中，阿宝哥发现了 axios-mock-adapter 这个库，该库通过自定义适配器，让开发者可以轻松地模拟请求。对应的使用示例如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; axios = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;axios&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; MockAdapter = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;axios-mock-adapter&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 在默认的Axios实例上设置mock适配器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; mock = &lt;span&gt;new&lt;/span&gt; MockAdapter(axios);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 模拟 GET /users 请求&lt;/span&gt;&lt;br/&gt;mock.onGet(&lt;span&gt;&quot;/users&quot;&lt;/span&gt;).reply(&lt;span&gt;200&lt;/span&gt;, {&lt;br/&gt;  &lt;span&gt;users&lt;/span&gt;: [{ &lt;span&gt;id&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&quot;John Smith&quot;&lt;/span&gt; }],&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;axios.get(&lt;span&gt;&quot;/users&quot;&lt;/span&gt;).then(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;response&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(response.data);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 MockAdapter 感兴趣的小伙伴，可以自行了解一下 &lt;strong&gt;axios-mock-adapter&lt;/strong&gt; 这个库。到这里我们已经介绍了 Axios 的拦截器与适配器，下面阿宝哥用一张图来总结一下 Axios 使用请求拦截器和响应拦截器后，请求的处理流程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8Rr1maSvPU0SEtQ3Zfic9MFuiaSRx6n9G7obyic6fLh5MibuQ1TvENWriarQ1w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;四、CSRF 防御&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;4.1 CSRF 简介&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「跨站请求伪造」&lt;/strong&gt;（Cross-site request forgery），通常缩写为 &lt;strong&gt;「CSRF」&lt;/strong&gt; 或者 &lt;strong&gt;「XSRF」&lt;/strong&gt;， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了让小伙伴更好地理解上述的内容，阿宝哥画了一张跨站请求攻击示例图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;277&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V05hkPsHIMuu0u4t7PXe8RrPibSnhKic2Jj4nIV2utblUK6JU3dJ1ZSkKTXWsEJJwwG8OyWRoUJJKtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中攻击者利用了 Web 中用户身份验证的一个漏洞：&lt;strong&gt;「简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的」&lt;/strong&gt;。既然存在以上的漏洞，那么我们应该怎么进行防御呢？接下来我们来介绍一些常见的 CSRF 防御措施。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;4.2 CSRF 防御措施&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.1 检查 Referer 字段&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 头中有一个 Referer 字段，这个字段用以标明请求来源于哪个地址。&lt;strong&gt;「在处理敏感数据请求时，通常来说，Referer 字段应和请求的地址位于同一域名下」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以示例中商城操作为例，Referer 字段地址通常应该是商城所在的网页地址，应该也位于 www.semlinker.com 之下。而如果是 CSRF 攻击传来的请求，Referer 字段会是包含恶意网址的地址，不会位于 www.semlinker.com 之下，这时候服务器就能识别出恶意的访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种办法简单易行，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.2 同步表单 CSRF 校验&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CSRF 攻击之所以能够成功，是因为服务器无法区分正常请求和攻击请求。针对这个问题我们可以要求所有的用户请求都携带一个 CSRF 攻击者无法获取到的 token。对于 CSRF 示例图中的表单攻击，我们可以使用 &lt;strong&gt;「同步表单 CSRF 校验」&lt;/strong&gt; 的防御措施。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「同步表单 CSRF 校验」&lt;/strong&gt; 就是在返回页面时将 token 渲染到页面上，在 form 表单提交的时候通过隐藏域或者作为查询参数把 CSRF token 提交到服务器。比如，在同步渲染页面时，在表单请求中增加一个 &lt;code&gt;_csrf&lt;/code&gt; 的查询参数，这样当用户在提交这个表单的时候就会将 CSRF token 提交上来：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;form&lt;/span&gt; &lt;span&gt;method&lt;/span&gt;=&lt;span&gt;&quot;POST&quot;&lt;/span&gt; &lt;span&gt;action&lt;/span&gt;=&lt;span&gt;&quot;/upload?_csrf={{由服务端生成}}&quot;&lt;/span&gt; &lt;span&gt;enctype&lt;/span&gt;=&lt;span&gt;&quot;multipart/form-data&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  用户名: &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;name&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;  选择头像: &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;submit&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;form&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2.3 双重 Cookie 防御&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「双重 Cookie 防御」&lt;/strong&gt; 就是将 token 设置在 Cookie 中，在提交（POST、PUT、PATCH、DELETE）等请求时提交 Cookie，并通过请求头或请求体带上 Cookie 中已设置的 token，服务端接收到请求后，再进行对比校验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们以 jQuery 为例，来看一下如何设置 CSRF token：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; csrfToken = Cookies.get(&lt;span&gt;&#x27;csrfToken&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;csrfSafeMethod&lt;/span&gt;(&lt;span&gt;method&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 以下HTTP方法不需要进行CSRF防护&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;/^(GET|HEAD|OPTIONS|TRACE)$/&lt;/span&gt;.test(method));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;$.ajaxSetup({&lt;br/&gt;  &lt;span&gt;beforeSend&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;xhr, settings&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!csrfSafeMethod(settings.type) &amp;amp;&amp;amp; !&lt;span&gt;this&lt;/span&gt;.crossDomain) {&lt;br/&gt;      xhr.setRequestHeader(&lt;span&gt;&#x27;x-csrf-token&#x27;&lt;/span&gt;, csrfToken);&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍完 CSRF 攻击的方式和防御手段，最后我们来看一下 Axios 是如何防御 CSRF 攻击的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;4.3 Axios CSRF 防御&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Axios 提供了 &lt;code&gt;xsrfCookieName&lt;/code&gt; 和 &lt;code&gt;xsrfHeaderName&lt;/code&gt; 两个属性来分别设置 CSRF 的 Cookie 名称和 HTTP 请求头的名称，它们的默认值如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/defaults.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; defaults = {&lt;br/&gt;  &lt;span&gt;adapter&lt;/span&gt;: getDefaultAdapter(),&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;xsrfCookieName&lt;/span&gt;: &lt;span&gt;&#x27;XSRF-TOKEN&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;xsrfHeaderName&lt;/span&gt;: &lt;span&gt;&#x27;X-XSRF-TOKEN&#x27;&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们已经知道在不同的平台中，Axios 使用不同的适配器来发送 HTTP 请求，这里我们以浏览器平台为例，来看一下 Axios 如何防御 CSRF 攻击：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// lib/adapters/xhr.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;xhrAdapter&lt;/span&gt;(&lt;span&gt;config&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;dispatchXhrRequest&lt;/span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; requestHeaders = config.headers;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; request = &lt;span&gt;new&lt;/span&gt; XMLHttpRequest();&lt;br/&gt;    &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 添加xsrf头部&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (utils.isStandardBrowserEnv()) {&lt;br/&gt;      &lt;span&gt;var&lt;/span&gt; xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) &amp;amp;&amp;amp; config.xsrfCookieName ?&lt;br/&gt;        cookies.read(config.xsrfCookieName) :&lt;br/&gt;        &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (xsrfValue) {&lt;br/&gt;        requestHeaders[config.xsrfHeaderName] = xsrfValue;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    request.send(requestData);&lt;br/&gt;  });&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完以上的代码，相信小伙伴们就已经知道答案了，原来 Axios 内部是使用 &lt;strong&gt;「双重 Cookie 防御」&lt;/strong&gt; 的方案来防御 CSRF 攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的，到这里本文的主要内容都已经介绍完了，其实 Axios 项目还有一些值得我们借鉴的地方，比如 CancelToken 的设计、异常处理机制等，感兴趣的小伙伴可以自行学习一下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;五、参考资源&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Github - axios&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;维基百科 - 跨站请求伪造&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Egg - 安全威胁 CSRF 的防范&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3913677&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.006666666666666667&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot; data-width=&quot;100%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCu1rRLicXibOB6jq4wpe7W4Ioibu7XTJR1ABzARKoLxyWEWeIV6HJRII2GK1ntnCkVIqjY852gntBd5Q/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;敬请关注「Nodejs技术栈」微信公众号，&lt;span&gt;期望与志同道合的你一起打造优质 “Nodejs技术栈” 交流群，一起互相学习进步！&lt;/span&gt;&lt;span&gt;可长按下方二维码&lt;/span&gt;&lt;span&gt;添加【五月君】个人微信备注 “Node” 邀请入群。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zPkNS9m6iatLmT5coKbicuqENgoc3Pz4QWwtrEoP2RU2thicCJHaKNmJ23Hh9jYvicpVgiauY6NxNaZ59D6svw1Qskg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cbbad999d81566a4bdadc0d7d99f0cc9</guid>
<title>为什么不建议用try catch处理异常？</title>
<link>https://toutiao.io/k/3qb54h6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h3 data-tool=&quot;mdnice编辑器&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;软件开发过程中，不可避免的是需要处理各种异常，就我自己来说，至少有一半以上的时间都是在处理各种异常情况，所以代码中就会出现大量的 try {...} catch {...} finally {...} 代码块，不仅有大量的冗余代码，而且还影响代码的可读性。&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比较下面两张图，看看您现在编写的代码属于哪一种风格？然后哪种编码风格您更喜欢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;丑陋的 try catch 代码块：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.839835728952772&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVlS9qFM760JakC7zpHIWibMk0Smme9ema5dicM4RC3SMlXcO1SThnKwAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;974&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优雅的 Controller：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49129989764585463&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVQVaeQT0xB13D781Iocl6tMH1LK4Zyc4pBdgC6XRzTUo6CfcfVwHexg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;977&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上面的示例，还只是在 Controller 层，如果是在 Service 层，可能会有更多的 try catch 代码块。这将会严重影响代码的可读性、“美观性”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以如果是我的话，我肯定偏向于第二种，我可以把更多的精力放在业务代码的开发，同时代码也会变得更加简洁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然业务代码不显式地对异常进行捕获、处理，而异常肯定还是处理的，不然系统岂不是动不动就崩溃了，所以必须得有其他地方捕获并处理这些异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;那么问题来了，如何优雅的处理各种异常？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;什么是统一异常处理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Spring 在 3.2 版本增加了一个注解 @ControllerAdvice，可以与 @ExceptionHandler、@InitBinder、@ModelAttribute 等注解注解配套使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于这几个注解的作用，这里不做过多赘述，若有不了解的，可以参考 Spring 3.2 新注解 @ControllerAdvice，先大概有个了解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不过跟异常处理相关的只有注解 @ExceptionHandler，从字面上看，就是异常处理器的意思。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;其实际作用也是：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;若在某个 Controller 类定义一个异常处理方法，并在方法上添加该注解，那么当出现指定的异常时，会执行该处理异常的方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其可以使用 SpringMVC 提供的数据绑定，比如注入 HttpServletRequest 等，还可以接受一个当前抛出的 Throwable 对象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，这样一来，就必须在每一个 Controller 类都定义一套这样的异常处理方法，因为异常可以是各种各样。这样一来，就会造成大量的冗余代码，而且若需要新增一种异常的处理逻辑，就必须修改所有 Controller 类了，很不优雅。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当然你可能会说，那就定义个类似 BaseController 的基类，这样总行了吧。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种做法虽然没错，但仍不尽善尽美，因为这样的代码有一定的侵入性和耦合性。简简单单的 Controller，我为啥非得继承这样一个类呢，万一已经继承其他基类了呢。大家都知道 Java 只能继承一个类。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那有没有一种方案，既不需要跟 Controller 耦合，也可以将定义的异常处理器应用到所有控制器呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以注解 @ControllerAdvice 出现了，简单的说，该注解可以把异常处理器应用到所有控制器，而不是单个控制器。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;借助该注解，我们可以实现：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在独立的某个地方，比如单独一个类，定义一套对各种异常的处理机制，然后在类的签名加上注解 @ControllerAdvice，统一对不同阶段的、不同异常进行处理。这就是统一异常处理的原理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;注意到上面对异常按阶段进行分类，大体可以分成：进入 Controller 前的异常和 Service 层异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体可以参考下图：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4504310344827586&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVQQvAmsAZELXo0tLkxluXgFzRmGgw90pic939e7xHz64Dw24qgvdmdGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;928&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;不同阶段的异常&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消灭 95% 以上的 try catch 代码块，以优雅的 Assert（断言）方式来校验业务的异常情况，只关注业务逻辑，而不用花费大量精力写冗余的 try catch 代码块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;统一异常处理实战&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在定义统一异常处理类之前，先来介绍一下如何优雅的判定异常情况并抛异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 用 Assert（断言）替换 throw exception&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;想必 Assert（断言）大家都很熟悉，比如 Spring 家族的 org.springframework.util.Assert，在我们写测试用例的时候经常会用到。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;使用断言能让我们编码的时候有一种非一般丝滑的感觉，比如：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ...&lt;br/&gt;        User user = userDao.selectById(userId);&lt;br/&gt;        Assert.notNull(user, &lt;span&gt;&quot;用户不存在.&quot;&lt;/span&gt;);&lt;br/&gt;        ...&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 另一种写法&lt;/span&gt;&lt;br/&gt;        User user = userDao.selectById(userId);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;用户不存在.&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有没有感觉第一种判定非空的写法很优雅，第二种写法则是相对丑陋的 if {...} 代码块。那么神奇的 Assert.notNull() 背后到底做了什么呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;下面是 Assert 的部分源码：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Assert&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Assert&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;notNull&lt;/span&gt;(&lt;span&gt;@Nullable Object &lt;span&gt;object&lt;/span&gt;, String message&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;object&lt;/span&gt; == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(message);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看到，Assert 其实就是帮我们把 if {...} 封装了一下，是不是很神奇？虽然很简单，但不可否认的是编码体验至少提升了一个档次。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么我们能不能模仿 org.springframework.util.Assert，也写一个断言类，不过断言失败后抛出的异常不是 IllegalArgumentException 这些内置异常，而是我们自己定义的异常。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;下面让我们来尝试一下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;Assert&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Assert&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 创建异常&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; args&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;BaseException &lt;span&gt;newException&lt;/span&gt;&lt;span&gt;(Object... args)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 创建异常&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; t&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; args&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;BaseException &lt;span&gt;newException&lt;/span&gt;&lt;span&gt;(Throwable t, Object... args)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * &amp;lt;p&amp;gt;断言对象&amp;lt;code&amp;gt;obj&amp;lt;/code&amp;gt;非空。如果对象&amp;lt;code&amp;gt;obj&amp;lt;/code&amp;gt;为空，则抛出异常&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; obj 待判断对象&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;assertNotNull&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; newException(obj);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * &amp;lt;p&amp;gt;断言对象&amp;lt;code&amp;gt;obj&amp;lt;/code&amp;gt;非空。如果对象&amp;lt;code&amp;gt;obj&amp;lt;/code&amp;gt;为空，则抛出异常&lt;br/&gt;     * &amp;lt;p&amp;gt;异常信息&amp;lt;code&amp;gt;message&amp;lt;/code&amp;gt;支持传递参数方式，避免在判断之前进行字符串拼接操作&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; obj 待判断对象&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; args message占位符对应的参数列表&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;assertNotNull&lt;/span&gt;&lt;span&gt;(Object obj, Object... args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; newException(args);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上面的 Assert 断言方法是使用接口的默认方法定义的，然后有没有发现当断言失败后，抛出的异常不是具体的某个异常，而是交由 2 个 newException 接口方法提供。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为业务逻辑中出现的异常基本都是对应特定的场景，比如根据用户 id 获取用户信息，查询结果为 null，此时抛出的异常可能为 UserNotFoundException，并且有特定的异常码（比如 7001）和异常信息“用户不存在”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以具体抛出什么异常，由 Assert 的实现类决定。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;看到这里，您可能会有这样的疑问，按照上面的说法，那岂不是有多少异常情况，就得有定义等量的断言类和异常类，这显然是反人类的，这也没想象中高明嘛。别急，且听我细细道来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 善解人意的 Enum&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;自定义异常 BaseException 有 2 个属性，即 code、message，这样一对属性，有没有想到什么类一般也会定义这 2 个属性？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;没错，就是枚举类。且看我如何将 Enum 和 Assert 结合起来，相信我一定会让你眼前一亮。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IResponseEnum&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;getCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;getMessage&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &amp;lt;p&amp;gt;业务异常&amp;lt;/p&amp;gt;&lt;br/&gt; * &amp;lt;p&amp;gt;业务处理时，出现异常，可以抛出该异常&amp;lt;/p&amp;gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BusinessException&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt;  &lt;span&gt;BaseException&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = &lt;span&gt;1L&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;BusinessException&lt;/span&gt;&lt;span&gt;(IResponseEnum responseEnum, Object[] args, String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(responseEnum, args, message);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;BusinessException&lt;/span&gt;&lt;span&gt;(IResponseEnum responseEnum, Object[] args, String message, Throwable cause)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(responseEnum, args, message, cause);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;BusinessExceptionAssert&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;IResponseEnum&lt;/span&gt;, &lt;span&gt;Assert&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;default&lt;/span&gt; BaseException &lt;span&gt;newException&lt;/span&gt;&lt;span&gt;(Object... args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String msg = MessageFormat.format(&lt;span&gt;this&lt;/span&gt;.getMessage(), args);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BusinessException(&lt;span&gt;this&lt;/span&gt;, args, msg);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;default&lt;/span&gt; BaseException &lt;span&gt;newException&lt;/span&gt;&lt;span&gt;(Throwable t, Object... args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String msg = MessageFormat.format(&lt;span&gt;this&lt;/span&gt;.getMessage(), args);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BusinessException(&lt;span&gt;this&lt;/span&gt;, args, msg, t);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;@Getter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@AllArgsConstructor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; ResponseEnum implements BusinessExceptionAssert {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Bad licence type&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    BAD_LICENCE_TYPE(&lt;span&gt;7001&lt;/span&gt;, &lt;span&gt;&quot;Bad licence type.&quot;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Licence not found&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    LICENCE_NOT_FOUND(&lt;span&gt;7002&lt;/span&gt;, &lt;span&gt;&quot;Licence not found.&quot;&lt;/span&gt;)&lt;br/&gt;    ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 返回码&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; code;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 返回消息&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String message;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;看到这里，有没有眼前一亮的感觉，代码示例中定义了两个枚举实例：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BAD_LICENCE_TYPE&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;LICENCE_NOT_FOUND&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;他们分别对应了 BadLicenceTypeException、LicenceNotFoundException 两种异常。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以后每增加一种异常情况，只需增加一个枚举实例即可，再也不用每一种异常都定义一个异常类了。然后再来看下如何使用，假设 LicenceService 有校验 Licence 是否存在的方法，如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt;     * 校验{&lt;span&gt;@link&lt;/span&gt; Licence}存在&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; licence&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;checkNotNull&lt;/span&gt;&lt;span&gt;(Licence licence)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ResponseEnum.LICENCE_NOT_FOUND.assertNotNull(licence);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;若不使用断言，代码可能如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;checkNotNull&lt;/span&gt;(&lt;span&gt;Licence licence&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (licence == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LicenceNotFoundException();&lt;br/&gt;            &lt;span&gt;// 或者这样&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BusinessException(&lt;span&gt;7001&lt;/span&gt;, &lt;span&gt;&quot;Bad licence type.&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用枚举类结合（继承）Assert，只需根据特定的异常情况定义不同的枚举实例，如上面的 BAD_LICENCE_TYPE、LICENCE_NOT_FOUND，就能够针对不同情况抛出特定的异常（这里指携带特定的异常码和异常消息）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样既不用定义大量的异常类，同时还具备了断言的良好可读性，当然这种方案的好处远不止这些，请继续阅读后文，慢慢体会。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：上面举的例子是针对特定的业务，而有部分异常情况是通用的，比如：服务器繁忙、网络异常、服务器异常、参数校验异常、404 等，所以有CommonResponseEnum、ArgumentResponseEnum、ServletResponseEnum，其中 ServletResponseEnum 会在后文详细说明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 定义统一异常处理器类&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@ControllerAdvice&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@ConditionalOnWebApplication&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@ConditionalOnMissingBean&lt;/span&gt;(UnifiedExceptionHandler.class)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UnifiedExceptionHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 生产环境&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String ENV_PROD = &lt;span&gt;&quot;prod&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UnifiedMessageSource unifiedMessageSource;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 当前环境&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${spring.profiles.active}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String profile;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取国际化消息&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; e 异常&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getMessage&lt;/span&gt;&lt;span&gt;(BaseException e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String code = &lt;span&gt;&quot;response.&quot;&lt;/span&gt; + e.getResponseEnum().toString();&lt;br/&gt;        String message = unifiedMessageSource.getMessage(code, e.getArgs());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (message == &lt;span&gt;null&lt;/span&gt; || message.isEmpty()) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; e.getMessage();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; message;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 业务异常&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; e 异常&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; 异常结果&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(value = BusinessException.class)&lt;br/&gt;    &lt;span&gt;@ResponseBody&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ErrorResponse &lt;span&gt;handleBusinessException&lt;/span&gt;&lt;span&gt;(BaseException e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.error(e.getMessage(), e);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ErrorResponse(e.getResponseEnum().getCode(), getMessage(e));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 自定义异常&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; e 异常&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; 异常结果&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(value = BaseException.class)&lt;br/&gt;    &lt;span&gt;@ResponseBody&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ErrorResponse &lt;span&gt;handleBaseException&lt;/span&gt;&lt;span&gt;(BaseException e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.error(e.getMessage(), e);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ErrorResponse(e.getResponseEnum().getCode(), getMessage(e));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Controller上一层相关异常&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; e 异常&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; 异常结果&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;({&lt;br/&gt;            NoHandlerFoundException.class,&lt;br/&gt;            HttpRequestMethodNotSupportedException.class,&lt;br/&gt;            HttpMediaTypeNotSupportedException.class,&lt;br/&gt;            MissingPathVariableException.class,&lt;br/&gt;            MissingServletRequestParameterException.class,&lt;br/&gt;            TypeMismatchException.class,&lt;br/&gt;            HttpMessageNotReadableException.class,&lt;br/&gt;            HttpMessageNotWritableException.class,&lt;br/&gt;            &lt;span&gt;// BindException.class,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// MethodArgumentNotValidException.class&lt;/span&gt;&lt;br/&gt;            HttpMediaTypeNotAcceptableException.class,&lt;br/&gt;            ServletRequestBindingException.class,&lt;br/&gt;            ConversionNotSupportedException.class,&lt;br/&gt;            MissingServletRequestPartException.class,&lt;br/&gt;            AsyncRequestTimeoutException.class&lt;br/&gt;    })&lt;br/&gt;    &lt;span&gt;@ResponseBody&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ErrorResponse &lt;span&gt;handleServletException&lt;/span&gt;&lt;span&gt;(Exception e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.error(e.getMessage(), e);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; code = CommonResponseEnum.SERVER_ERROR.getCode();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            ServletResponseEnum servletExceptionEnum = ServletResponseEnum.valueOf(e.getClass().getSimpleName());&lt;br/&gt;            code = servletExceptionEnum.getCode();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IllegalArgumentException e1) {&lt;br/&gt;            log.error(&lt;span&gt;&quot;class [{}] not defined in enum {}&quot;&lt;/span&gt;, e.getClass().getName(), ServletResponseEnum.class.getName());&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (ENV_PROD.equals(profile)) {&lt;br/&gt;            &lt;span&gt;// 当为生产环境, 不适合把具体的异常信息展示给用户, 比如404.&lt;/span&gt;&lt;br/&gt;            code = CommonResponseEnum.SERVER_ERROR.getCode();&lt;br/&gt;            BaseException baseException = &lt;span&gt;new&lt;/span&gt; BaseException(CommonResponseEnum.SERVER_ERROR);&lt;br/&gt;            String message = getMessage(baseException);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ErrorResponse(code, message);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ErrorResponse(code, e.getMessage());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 参数绑定异常&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; e 异常&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; 异常结果&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(value = BindException.class)&lt;br/&gt;    &lt;span&gt;@ResponseBody&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ErrorResponse &lt;span&gt;handleBindException&lt;/span&gt;&lt;span&gt;(BindException e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.error(&lt;span&gt;&quot;参数绑定校验异常&quot;&lt;/span&gt;, e);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; wrapperBindingResult(e.getBindingResult());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 参数校验异常，将校验失败的所有异常组合成一条错误信息&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; e 异常&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; 异常结果&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(value = MethodArgumentNotValidException.class)&lt;br/&gt;    &lt;span&gt;@ResponseBody&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ErrorResponse &lt;span&gt;handleValidException&lt;/span&gt;&lt;span&gt;(MethodArgumentNotValidException e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.error(&lt;span&gt;&quot;参数绑定校验异常&quot;&lt;/span&gt;, e);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; wrapperBindingResult(e.getBindingResult());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 包装绑定异常结果&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; bindingResult 绑定结果&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; 异常结果&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; ErrorResponse &lt;span&gt;wrapperBindingResult&lt;/span&gt;&lt;span&gt;(BindingResult bindingResult)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        StringBuilder msg = &lt;span&gt;new&lt;/span&gt; StringBuilder();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (ObjectError error : bindingResult.getAllErrors()) {&lt;br/&gt;            msg.append(&lt;span&gt;&quot;, &quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (error &lt;span&gt;instanceof&lt;/span&gt; FieldError) {&lt;br/&gt;                msg.append(((FieldError) error).getField()).append(&lt;span&gt;&quot;: &quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            msg.append(error.getDefaultMessage() == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : error.getDefaultMessage());&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ErrorResponse(ArgumentResponseEnum.VALID_ERROR.getCode(), msg.substring(&lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 未定义异常&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; e 异常&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; 异常结果&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(value = Exception.class)&lt;br/&gt;    &lt;span&gt;@ResponseBody&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ErrorResponse &lt;span&gt;handleException&lt;/span&gt;&lt;span&gt;(Exception e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.error(e.getMessage(), e);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (ENV_PROD.equals(profile)) {&lt;br/&gt;            &lt;span&gt;// 当为生产环境, 不适合把具体的异常信息展示给用户, 比如数据库异常信息.&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; code = CommonResponseEnum.SERVER_ERROR.getCode();&lt;br/&gt;            BaseException baseException = &lt;span&gt;new&lt;/span&gt; BaseException(CommonResponseEnum.SERVER_ERROR);&lt;br/&gt;            String message = getMessage(baseException);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ErrorResponse(code, message);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ErrorResponse(CommonResponseEnum.SERVER_ERROR.getCode(), e.getMessage());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，上面将异常分成几类，实际上只有两大类，一类是 ServletException、ServiceException。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还记得上文提到的按阶段分类吗，即对应进入 Controller 前的异常 和 Service 层异常；然后 ServiceException 再分成自定义异常、未知异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对应关系如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来分别对这几种异常处理器做详细说明。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;异常处理器说明&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| handleServletException&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;一个 http 请求，在到达 Controller 前，会对该请求的请求信息与目标控制器信息做一系列校验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里简单说一下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;NoHandlerFoundException：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;首先根据请求 Url 查找有没有对应的控制器，若没有则会抛该异常，也就是大家非常熟悉的 404 异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;HttpRequestMethodNotSupportedException：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;若匹配到了（匹配结果是一个列表，不同的是 http 方法不同，如：Get、Post 等），则尝试将请求的 http 方法与列表的控制器做匹配，若没有对应 http 方法的控制器，则抛该异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;HttpMediaTypeNotSupportedException：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;然后再对请求头与控制器支持的做比较。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如 content-type 请求头，若控制器的参数签名包含注解 @RequestBody，但是请求的 content-type 请求头的值没有包含 application/json，那么会抛该异常（当然，不止这种情况会抛这个异常）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;MissingPathVariableException：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;未检测到路径参数。比如 url 为：/licence/{licenceId}，参数签名包含 @PathVariable(&quot;licenceId&quot;)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当请求的 url 为 /licence，在没有明确定义 url 为 /licence 的情况下，会被判定为：缺少路径参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;MissingServletRequestParameterException：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;缺少请求参数。比如定义了参数 @RequestParam(&quot;licenceId&quot;) String licenceId，但发起请求时，未携带该参数，则会抛该异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;TypeMismatchException：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;参数类型匹配失败。比如：接收参数为 Long 型，但传入的值确是一个字符串，那么将会出现类型转换失败的情况，这时会抛该异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;HttpMessageNotReadableException：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;与上面的 HttpMediaTypeNotSupportedException 举的例子完全相反。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即请求头携带了&quot;content-type: application/json;charset=UTF-8&quot;，但接收参数却没有添加注解 @RequestBody，或者请求体携带的 json 串反序列化成 pojo 的过程中失败了，也会抛该异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;HttpMessageNotWritableException：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;返回的 pojo 在序列化成 json 过程失败了，那么抛该异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| handleBindException&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;参数校验异常，后文详细说明。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| handleValidException&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;参数校验异常，后文详细说明。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| handleBusinessException、handleBaseException&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;处理自定义的业务异常，只是 handleBaseException 处理的是除了 BusinessException 意外的所有业务异常。就目前来看，这 2 个是可以合并成一个的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| handleException&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;处理所有未知的异常，比如操作数据库失败的异常。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;注：上面的 handleServletException、handleException 这两个处理器，返回的异常信息，不同环境返回的可能不一样，以为这些异常信息都是框架自带的异常信息，一般都是英文的，不太好直接展示给用户看，所以统一返回 SERVER_ERROR 代表的异常信息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;异于常人的404&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上文提到，当请求没有匹配到控制器的情况下，会抛出 NoHandlerFoundException 异常，但其实默认情况下不是这样，默认情况下会出现类似如下页面：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.25125628140703515&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;995&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVNicHkYlibn9GfkordYMClmpD68BXt4IUkltiasyibnlj4eribHzya1DGINQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;Whitelabel Error Page&lt;/em&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个页面是如何出现的呢？实际上，当出现 404 的时候，默认是不抛异常的，而是 forward 跳转到 /error 控制器。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Spring 也提供了默认的 error 控制器，如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6213197969543147&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;985&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVgkSibj4k6Ecn63Jw1RgjNEGOibcx3oicqiabc9ia3kqzbvufRLibkhHqXe0A/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么，如何让 404 也抛出异常呢，只需在 properties 文件中加入如下配置即可：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;spring.mvc.&lt;span&gt;throw&lt;/span&gt;-exception-&lt;span&gt;if&lt;/span&gt;-&lt;span&gt;no&lt;/span&gt;-handler-found=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;spring.resources.add-mappings=&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如此，就可以异常处理器中捕获它了，然后前端只要捕获到特定的状态码，立即跳转到 404 页面即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;捕获404对应的异常&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 统一返回结果&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在验证统一异常处理器之前，顺便说一下统一返回结果。说白了，其实是统一一下返回结果的数据结构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;code、message 是所有返回结果中必有的字段，而当需要返回数据时，则需要另一个字段 data 来表示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以首先定义一个 BaseResponse 来作为所有返回结果的基类；&lt;/span&gt;&lt;span&gt;然后定义一个通用返回结果类 CommonResponse，继承 BaseResponse，而且多了字段 data。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了区分成功和失败返回结果，于是再定义一个 ErrorResponse。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后还有一种常见的返回结果，即返回的数据带有分页信息，因为这种接口比较常见，所以有必要单独定义一个返回结果类 QueryDataResponse。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该类继承自 CommonResponse，只是把 data 字段的类型限制为 QueryDdata，QueryDdata中定义了分页信息相应的字段，即 totalCount、pageNo、 pageSize、records。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中比较常用的只有 CommonResponse 和 QueryDataResponse，但是名字又贼鬼死长，何不定义 2 个名字超简单的类来替代呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是 R 和 QR 诞生了，以后返回结果的时候只需这样写：new R&amp;lt;&amp;gt;(data)、new QR&amp;lt;&amp;gt;(queryData)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所有的返回结果类的定义这里就不贴出来了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 验证统一异常处理&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;因为这一套统一异常处理可以说是通用的，所有可以设计成一个 common包，以后每一个新项目/模块只需引入该包即可。所以为了验证，需要新建一个项目，并引入该 common 包。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;下面是用于验证的主要源码：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LicenceService&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ServiceImpl&lt;/span&gt;&amp;lt;&lt;span&gt;LicenceMapper&lt;/span&gt;, &lt;span&gt;Licence&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; OrganizationClient organizationClient;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 查询{&lt;span&gt;@link&lt;/span&gt; Licence} 详情&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; licenceId&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; LicenceDTO &lt;span&gt;queryDetail&lt;/span&gt;&lt;span&gt;(Long licenceId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Licence licence = &lt;span&gt;this&lt;/span&gt;.getById(licenceId);&lt;br/&gt;        checkNotNull(licence);&lt;br/&gt;&lt;br/&gt;        OrganizationDTO org = ClientUtil.execute(() -&amp;gt; organizationClient.getOrganization(licence.getOrganizationId()));&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; toLicenceDTO(licence, org);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 分页获取&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; licenceParam 分页查询参数&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; QueryData&amp;lt;SimpleLicenceDTO&amp;gt; &lt;span&gt;getLicences&lt;/span&gt;&lt;span&gt;(LicenceParam licenceParam)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String licenceType = licenceParam.getLicenceType();&lt;br/&gt;        LicenceTypeEnum licenceTypeEnum = LicenceTypeEnum.parseOfNullable(licenceType);&lt;br/&gt;        &lt;span&gt;// 断言, 非空&lt;/span&gt;&lt;br/&gt;        ResponseEnum.BAD_LICENCE_TYPE.assertNotNull(licenceTypeEnum);&lt;br/&gt;&lt;br/&gt;        LambdaQueryWrapper&amp;lt;Licence&amp;gt; wrapper = &lt;span&gt;new&lt;/span&gt; LambdaQueryWrapper&amp;lt;&amp;gt;();&lt;br/&gt;        wrapper.eq(Licence::getLicenceType, licenceType);&lt;br/&gt;        IPage&amp;lt;Licence&amp;gt; page = &lt;span&gt;this&lt;/span&gt;.page(&lt;span&gt;new&lt;/span&gt; QueryPage&amp;lt;&amp;gt;(licenceParam), wrapper);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; QueryData&amp;lt;&amp;gt;(page, &lt;span&gt;this&lt;/span&gt;::toSimpleLicenceDTO);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 新增{&lt;span&gt;@link&lt;/span&gt; Licence}&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; request 请求体&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor = Throwable.class)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; LicenceAddRespData &lt;span&gt;addLicence&lt;/span&gt;&lt;span&gt;(LicenceAddRequest request)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Licence licence = &lt;span&gt;new&lt;/span&gt; Licence();&lt;br/&gt;        licence.setOrganizationId(request.getOrganizationId());&lt;br/&gt;        licence.setLicenceType(request.getLicenceType());&lt;br/&gt;        licence.setProductName(request.getProductName());&lt;br/&gt;        licence.setLicenceMax(request.getLicenceMax());&lt;br/&gt;        licence.setLicenceAllocated(request.getLicenceAllocated());&lt;br/&gt;        licence.setComment(request.getComment());&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.save(licence);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LicenceAddRespData(licence.getLicenceId());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * entity -&amp;gt; simple dto&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; licence {&lt;span&gt;@link&lt;/span&gt; Licence} entity&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; {&lt;span&gt;@link&lt;/span&gt; SimpleLicenceDTO}&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; SimpleLicenceDTO &lt;span&gt;toSimpleLicenceDTO&lt;/span&gt;&lt;span&gt;(Licence licence)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 省略&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * entity -&amp;gt; dto&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; licence {&lt;span&gt;@link&lt;/span&gt; Licence} entity&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; org {&lt;span&gt;@link&lt;/span&gt; OrganizationDTO}&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; {&lt;span&gt;@link&lt;/span&gt; LicenceDTO}&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; LicenceDTO &lt;span&gt;toLicenceDTO&lt;/span&gt;&lt;span&gt;(Licence licence, OrganizationDTO org)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 省略&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 校验{&lt;span&gt;@link&lt;/span&gt; Licence}存在&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; licence&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;checkNotNull&lt;/span&gt;&lt;span&gt;(Licence licence)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ResponseEnum.LICENCE_NOT_FOUND.assertNotNull(licence);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;PS：这里使用的 DAO 框架是 mybatis-plus。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;启动时，自动插入的数据为：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;-- licence&lt;/span&gt;&lt;br/&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; licence (licence_id, organization_id, licence_type, product_name, licence_max, licence_allocated)&lt;br/&gt;&lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;CustomerPro&#x27;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; licence (licence_id, organization_id, licence_type, product_name, licence_max, licence_allocated)&lt;br/&gt;&lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;suitability-plus&#x27;&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;,&lt;span&gt;189&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; licence (licence_id, organization_id, licence_type, product_name, licence_max, licence_allocated)&lt;br/&gt;&lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;HR-PowerSuite&#x27;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; licence (licence_id, organization_id, licence_type, product_name, licence_max, licence_allocated)&lt;br/&gt;&lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&#x27;core-prod&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;WildCat Application Gateway&#x27;&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;,&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;-- organizations&lt;/span&gt;&lt;br/&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;organization&lt;/span&gt; (&lt;span&gt;id&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt;, contact_name, contact_email, contact_phone)&lt;br/&gt;&lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&#x27;customer-crm-co&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Mark Balster&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;mark.balster@custcrmco.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;823-555-1212&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;organization&lt;/span&gt; (&lt;span&gt;id&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt;, contact_name, contact_email, contact_phone)&lt;br/&gt;&lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&#x27;HR-PowerSuite&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Doug Drewry&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;doug.drewry@hr.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;920-555-1212&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;开始验证&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 捕获自定义异常&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;①&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;获取不存在的 licence 详情：&lt;/span&gt;&lt;span&gt;http://localhost:10000/licence/5&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;成功响应的请求：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;licenceId&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;检验非空：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.20854526958290945&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zV8LAj46ibDUiaZeNPgWvXT7KiaIRd9wKIrickoWE5WHEwVUlyiciapmKMRZAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;983&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;捕获 Licence not found 异常：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3323170731707317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVcVD7ALbblmjFXthoApf3r6tX9U4V12MR8UvsMmgxzn3PoY7mjkzD7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Licence not found：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2690246516613076&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVIlS1WURgp8MKhwmSuxNV0DYYXpngWyP8uBCJHarPGMJr6TJicAJTLhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;933&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;②&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;根据不存在的 licence type 获取 licence 列表：http://localhost:10000/licence/list?licenceType=ddd。可选的 licence type 为：user、core-prod 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;校验非空：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.22764227642276422&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVfcMYos4pvz4VQDedpG9TjwLMNwrjJdJ1Dq0ZbcPzT32Gmrria3HB2pA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;捕获 Bad licence type 异常：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3323170731707317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVj9iaKgicccLKicVwJ1Td8doia8JlBAlN5AfXx80gGv3zSZ2ftud082uicNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Bad licence type：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2679738562091503&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVLumTVOYe4MO5XibywxJXRd9FbXEkOYIx1xAXDTpOKC2RykQibjFZr9dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;918&quot;/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 捕获进入 Controller 前的异常&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;①&lt;/span&gt;&lt;span&gt;访问不存在的接口：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;http://localhost:10000/licence/list/ddd&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;捕获 404 异常：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5786802030456852&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVvrtnk2RMdia27HYH7LHkibCU5Fd8wR0qdCOyunlqwbQ9FxGeNKWCfaicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;985&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;②&lt;/span&gt;&lt;span&gt;http 方法不支持：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;http://localhost:10000/licence&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;PostMapping：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35192697768762676&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVeVicMnaFVOamX3UBB7M8jxXl8iatM143DKP4Rbhyia5bgl4eJRTB21Zrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;986&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;捕获 Request method not supported 异常：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7019328585961343&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zV7iaQMBCQ0533ePmibCkK1SiarubtNws3DSMjGVRkia5Cp9bgUKqR7eIBGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;983&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Request method not supported：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1836734693877551&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVlUbg4ibMjG73lJr5lB0uwicBfswWibR2bicdGeVuAp4skSfF16clQOIqCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;980&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;③&lt;/span&gt;&lt;span&gt;校验异常 1：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;http://localhost:10000/licence/list?licenceType=&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;getLicences：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.11359026369168357&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zV1vWCQZSDRXWHH7W2gicKKJLtaFH7cczgwhRd0FDd1RQC06RgrxD0nkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;986&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;LicenceParam：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2604698672114402&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zV2DmDJqC8iaRhpViarRhVsxA8BrF769Z3sdB8JSaXFp8wQ60JoEUpVJPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;979&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;捕获参数绑定校验异常：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5451776649746193&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVGCH3HSZTgOhibiaRm2Fs6IIODXmEPeRnaBDCEH4D3fjj6XXia1a52ubsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;985&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;licence type cannot be empty：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1536113936927772&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVibqiawkXg4aCIr72l4AQibS99iaLg748gy7vznqOJ9NSSvJD96micicqOmEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;983&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;④&lt;/span&gt;&lt;span&gt;校验异常 2：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;post 请求，这里使用 postman 模拟&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;addLicence：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.09182643794147326&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVNEZTd6CgTdsvPuvzNBuU8ORACxXXr6vyaA5ibA6hrSggJOpFXiavdMyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;991&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;LicenceAddRequest：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8175257731958763&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVqSibcp74LiaO5KarrOpH03icy6lpWe0coFL68KWsW9ClbPGU4Ovgkz9Xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;请求 url 即结果：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.599388379204893&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVehKwc2OIG3XjdXLky6hvWY3sR245fTlJJd2bqhV07EFQnxYB8aAHjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;981&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;捕获参数绑定校验异常：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.568089430894309&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVEu3cqGRpueDpXRfR9AHkJpmcaLZ9OUMRGvHXyJ7TwNmLRYdj3rRqJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;因为参数绑定校验异常的异常信息的获取方式与其它异常不一样，所以才把这 2 种情况的异常从进入 Controller 前的异常单独拆出来，下面是异常信息的收集逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;异常信息的收集：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3470225872689938&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVaz1B80VcfMF7U2IKYETYlJTTWK7fiblUkHCZFfmsP3icnQPH3ic3B7Tkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;974&quot;/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 捕获未知异常&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;假设我们现在随便对 Licence 新增一个字段 test，但不修改数据库表结构，然后访问：http://localhost:10000/licence/1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;增加 test 字段：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40429887410440124&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zV6ywk4D9kxfYeeGtpj9BnZoGhhaOJs4wF2KvwCnOahs1J88gBPUJJcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;977&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;捕获数据库异常：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.43756345177664974&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVkWjLNytTMjOtveFo4O3tkCTSsWjlDaefEphiarGGKtFrNDazYlKNWqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;985&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Error querying database：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.10815822002472188&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVNAO3WiajIoRYMiawwqqN1KMDwMmTWta0iaQNdcYlMVfe8pia6Rbk0w22aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1618&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，测试的异常都能够被捕获，然后以 code、message 的形式返回。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每一个项目/模块，在定义业务异常的时候，只需定义一个枚举类，然后实现接口 BusinessExceptionAssert，最后为每一种业务异常定义对应的枚举实例即可，而不用定义许多异常类。使用的时候也很方便，用法类似断言。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;扩展&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在生产环境，若捕获到未知异常或者 ServletException，因为都是一长串的异常信息，若直接展示给用户看，显得不够专业，于是，我们可以这样做：当检测到当前环境是生产环境，那么直接返回 &quot;网络异常&quot;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;生产环境返回“网络异常”：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3340270551508845&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVZfJ3iczfBhEiaico3tjktyCIliahLaxKLeic3lOgm4qdicvzCM0hzVA6spIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;961&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;可以通过以下方式修改当前环境：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4166666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zV2ulrsyoQOJYdCXMJPsibYyYficktKkiaTnGjzucONAn69meRfCXuVjkPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;使用断言和枚举类相结合的方式，再配合统一异常处理，基本大部分的异常都能够被捕获。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么说大部分异常，因为当引入 spring cloud security 后，还会有认证/授权异常，网关的服务降级异常、跨模块调用异常、远程调用第三方服务异常等，这些异常的捕获方式与本文介绍的不太一样，不过限于篇幅，这里不做详细说明，以后会有单独的文章介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;另外，当需要考虑国际化的时候，捕获异常后的异常信息一般不能直接返回，需要转换成对应的语言，不过本文已考虑到了这个，获取消息的时候已经做了国际化映射，逻辑如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4306122448979592&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZHD49tqdHpiaZ7ZU6PPic1zVtspDzwtWhQbK5qrrAJArNEo6PWyxmk1oRib1RO7Lu6UJcLPKc7jfvjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;980&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;获取国际化消息&lt;/em&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最后总结，全局异常属于老生长谈的话题，希望这次通过手机的项目对大家有点指导性的学习，大家根据实际情况自行修改。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;也可以采用以下的 jsonResult 对象的方式进行处理，也贴出来代码：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@RestControllerAdvice&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GlobalExceptionHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 没有登录&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; request&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; response&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; e&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(NoLoginException.class)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;noLoginExceptionHandler&lt;/span&gt;&lt;span&gt;(HttpServletRequest request,HttpServletResponse response,Exception e)&lt;/span&gt;&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        log.error(&lt;span&gt;&quot;[GlobalExceptionHandler][noLoginExceptionHandler] exception&quot;&lt;/span&gt;,e);&lt;br/&gt;        JsonResult jsonResult = &lt;span&gt;new&lt;/span&gt; JsonResult();&lt;br/&gt;        jsonResult.setCode(JsonResultCode.NO_LOGIN);&lt;br/&gt;        jsonResult.setMessage(&lt;span&gt;&quot;用户登录失效或者登录超时,请先登录&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; jsonResult;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 业务异常&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; request&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; response&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; e&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(ServiceException.class)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;businessExceptionHandler&lt;/span&gt;&lt;span&gt;(HttpServletRequest request,HttpServletResponse response,Exception e)&lt;/span&gt;&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        log.error(&lt;span&gt;&quot;[GlobalExceptionHandler][businessExceptionHandler] exception&quot;&lt;/span&gt;,e);&lt;br/&gt;        JsonResult jsonResult = &lt;span&gt;new&lt;/span&gt; JsonResult();&lt;br/&gt;        jsonResult.setCode(JsonResultCode.FAILURE);&lt;br/&gt;        jsonResult.setMessage(&lt;span&gt;&quot;业务异常,请联系管理员&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; jsonResult;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 全局异常处理&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; request&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; response&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; e&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(Exception.class)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;exceptionHandler&lt;/span&gt;&lt;span&gt;(HttpServletRequest request,HttpServletResponse response,Exception e)&lt;/span&gt;&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        log.error(&lt;span&gt;&quot;[GlobalExceptionHandler][exceptionHandler] exception&quot;&lt;/span&gt;,e);&lt;br/&gt;        JsonResult jsonResult = &lt;span&gt;new&lt;/span&gt; JsonResult();&lt;br/&gt;        jsonResult.setCode(JsonResultCode.FAILURE);&lt;br/&gt;        jsonResult.setMessage(&lt;span&gt;&quot;系统错误,请联系管理员&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; jsonResult;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;转自：sprinkle_liz&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://www.jianshu.com/p/3f3d9e8d1efa&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508510&amp;amp;idx=1&amp;amp;sn=d88c3206cbcdad9c2120dcab15e6280e&amp;amp;chksm=bd25a3618a522a773c8d83fec087fcb56d3a30dcf46fb84691c320546b81f9768b6d747dad43&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Java8中谨慎使用实数作为HashMap的key!&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;Java8中谨慎使用实数作为HashMap的key!&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651507050&amp;amp;idx=2&amp;amp;sn=c3e4fb7916091fe780abd25c20e0833d&amp;amp;chksm=bd25a5158a522c0336dd036b96de6b60c2ea6c90702f2abb9567ac5dfbfafecca4a141876919&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;精妙绝伦的并发艺术品 — ConcurrentHashMap是如何保证线程安全的&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;精妙绝伦的并发艺术品 — ConcurrentHashMap是如何保证线程安全的&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651503297&amp;amp;idx=2&amp;amp;sn=5f19e03d6b86789b3b28af5cee97d1e9&amp;amp;chksm=bd25d6be8a525fa8b8d16745d3454ddc4aa562571964d88eb9fd4e2cb274f8a9ae806bf0b3d5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一个 HashMap 跟面试官扯了半个小时&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;一个 HashMap 跟面试官扯了半个小时&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>