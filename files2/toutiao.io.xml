<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3d118c2e31438a47014e34138dfd3c44</guid>
<title>精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期</title>
<link>https://toutiao.io/k/3ininot</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第324期（2020-11-11）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;双十一，买它买它买它！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_324.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;基于 Kubernetes 的云原生批量计算平台&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;对以 Transformer 为基础的序列特征提取器 (Encoder) 和自回归的序列解码器 (Decoder) 做了深度优化&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;技术雷达是 ThoughtWorks 每半年发布一次的技术趋势报告&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;这是德勤第 11 年发布技术趋势年度报告&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;你知道吗？&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验总结&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;适合入门&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;基于 Swift 推出的函数响应框架&lt;/p&gt;
        
        &lt;p&gt;使用 JavaScript 来自动化 iOS&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;实践总结&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;细致讲解&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;7年工作经验，技术总监&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451915 即可&lt;/p&gt;
        
        &lt;p&gt;坚持原创，持续分享技术，包括但不限于：分布式、微服务架构，spring cloud、Dubbo微服务框架，Java核心技术，Redis缓存、Kafka消息队列中间件等。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 450130 即可&lt;/p&gt;
        
        &lt;p&gt;一个工作10年的程序猿，分享技术干货及内心的声音。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 413084 即可&lt;/p&gt;
        
        &lt;p&gt;详解数据结构与算法&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 142771 即可&lt;/p&gt;
        
        &lt;p&gt;Web前端、服务端、小程序、App、学习资料、工具、资讯&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 125297 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=20115&amp;amp;url=http%3A%2F%2Fproduct.dangdang.com%2F29132383.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_324.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一个技术总监的忠告&lt;/p&gt;
        
        &lt;p&gt;写作不易&lt;/p&gt;
        
        &lt;p&gt;同理心&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f2aeeebad9674e92e91b58254d21afe8</guid>
<title>独立开发者因为广告拦截被优酷索赔 100 万</title>
<link>https://toutiao.io/k/z19oawm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;我是一名独立开发者，目前全职维护&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.xbext.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;X浏览器&lt;/a&gt;的这款产品，可能有的小伙伴使用或听说过这款小众浏览器产品。X浏览器刚刚上线的时候，就遭遇到一次灭顶之灾，参见文章&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/d222ea914f14&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《猎豹清理大师值得我们信任吗?》&lt;/a&gt;。作为无助的独立开发者，我只能再次通过写文章为自己发声，希望得到大家的支持。&lt;/p&gt;&lt;p&gt;事情是这样的，经过几年的迭代X浏览器这款小众浏览器在圈内还算有些小口碑，作为作者我也是一直保持初心，希望能够做一款干净整洁的良心产品。却不曾想兢兢业业的维护一款良心产品却也能给自己招来巨大的麻烦。去年11月份左右，突然接到了来自海淀法院的传票和一大堆所谓X浏览器侵权的证据材料以及索赔100万的诉求。平生第一次接到法院传票，面对足厚厚的证据材料，以为经历了很多可以从容面对很多事情了，面临这样的阵式还是毫无悬念的进入了懵逼状态。（其实现在才想起来，这其实是律师代理人的一种策略，他们的目的就是提供一大堆材料抛给你，先不管有用没有但是足够吓唬人，让你失去方寸，乱了阵脚。足有一尺多厚的材料要是每页都看的话足够你啃一星期的）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1033c8a65e5f2890d5e13c3fc8af6032_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1512&quot; data-rawheight=&quot;2016&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-1033c8a65e5f2890d5e13c3fc8af6032_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1512&quot; data-rawheight=&quot;2016&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-1033c8a65e5f2890d5e13c3fc8af6032_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1033c8a65e5f2890d5e13c3fc8af6032_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;毕竟无论是创业还是作为独立开发者，这几年也经历了这样那样的奇葩事件。我很快从懵逼状态中冷静了过来，俗话说不做亏心事不怕鬼敲门。我在慌什么？做产品这么几年，保持初心，没有做过有损用户利益的事情，也没有说踩着其他产品上位的行为，甚至没有说过一次竞争对手不好。安安静静的做一款好产品会有错吗？最重要的我依然相信这个世界的美好，我笃定法官和法院会做到公平公正。 &lt;/p&gt;&lt;p&gt;优酷起诉我的理由是因为浏览器的广告拦截功能，拦截了优酷视频的片前广告。违反了《反不正当竞争》法。 说实话，我是在接到来自优酷的起诉书后才知道，X浏览器竟然可以拦截优酷视频的片前广告。查明原因后才知道由于X浏览器使用了著名的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//adblockplus.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ABP&lt;/a&gt;规则源，规则中存在对优酷视频片前广告进行拦截的规则。&lt;/p&gt;&lt;p&gt;=======================  分割线 ============================&lt;/p&gt;&lt;p&gt;您现在看的的这段是经过修改过的文字，移除了对优酷本身体验上的一些看法和主观评价。我承认一开始写文章的时候带有很多的情绪化和主观判断的语言，感谢广大网友指出我的问题，经过了一夜。我觉得确实需要理性一些，宣泄个人情绪确毫无意义。优酷无论怎样我是没有权利拦截对方的广告的。这里对优酷本身的评价和主观判断，我已经删除，并抱歉对其造成的不良影响。&lt;/p&gt;&lt;p&gt;下面是我需要澄清的一些事实以及我的想法，希望能够在这些问题上听听大家的看法和建议。以及如何把损失降到最小。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;针对广告拦截，确实X浏览器的重要功能之一，但X浏览器的定位只是要做好一个浏览器工具，尽可能的兼容网络上的一些拦截规则，并未对某个网站有针对性，所以能够拦截优酷的广告，作者事先是不知情的，直到被起诉的哪天才知道。查明原因后发现拦截优酷视频片前广告的规则来自于ABP规则源，我目前已经把优酷加入了白名单。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;2. 不同于PC浏览器作为视频网站的主要入口，X浏览器只是一个单独的移动浏览器，而在移动端优酷最大的入口是其自身的客户端产品。两个产品几乎不存在交集，能否造成不正当竞争我个人感觉还是有待商榷的。&lt;/p&gt;&lt;p&gt;3. X浏览器是一个非常小众的浏览器产品，用户数量也不多，对方代理律师在没有任何证据有用户通过X浏览器访问优酷视频服务，并对其造成了损失。这100万的诉讼请求从而来？对方代理律师仅仅通过X浏览器的下载量就可以计算这个损失吗？ X浏览器访问网站是有自身的标识的，本着谁主张谁举证的原则，优酷方本来是有能力提供X浏览器的访问证据的，不通过确凿的证据而只是一个不太能说明问题的下载量就可以索要赔款了吗？&lt;/p&gt;&lt;p&gt;4.  广告拦截几乎是所以浏览器的标配，并且很多浏览器是默认开启广告拦截的。而X浏览器是默认关闭了广告拦截功能，用户需要自行开启。  宣传广告拦截这个卖点会被定义为恶意诱导用户开启广告拦截吗？意思说可以存在这个功能，但是你宣传这个功能卖点就不对了？&lt;/p&gt;&lt;p&gt;作为被告身份，我也是大姑娘出嫁人生头一遭啊，自己也完全不知道是啥流程。于是咨询了几个律师朋友，说明情况后，律师朋友的反馈却让刚刚平静的心情些的心情又起波澜。因为参考了几个由于广告拦截导致不正当竞争的案例，浏览器方均为败诉方，胜算的可能性很小。&lt;/p&gt;&lt;p&gt;也许是来自性格的偏执，也许因为未做亏心事坦然，也许是相信法律的公正公平。我决定不委托律师亲自直面这个事情，毕竟作为浏览器作者最直接的当事人，我认为自己是可以把事实表述清楚的。&lt;/p&gt;&lt;p&gt;疫情原因，案子一直拖到最近才开始审理，事实证明，我还是把事情想的过于简单了，在法官面前无论是表达方式和讲话技巧都是有讲究的，很明显我的表现并不够好，第一次置身于法庭之上未免有些紧张，一些关键的点未能表达清楚(讲的东西过于专业，法官根本听不懂)。而对方代理律师似乎深谙此道，故意给我安了一些莫须有的行为，使用“主观恶意”，“行为恶劣”，“诱导用户开启广告拦截”等明显不属实的表述成功激怒了我。最悲催的是，在案件的审理过程中，我也明显感受到了法官针对这类案件存在明显的倾向性，因为参照过去浏览器拦截广告的案例都是以浏览器方败诉告终。&lt;/p&gt;&lt;p&gt;下午3点开庭，确认完笔录已经6点钟了。可能是由于辩论过程中情绪有些激动，导致腹部隐隐作痛。离开审判庭的时候，法院已经几乎没有人了，最尴尬的是下楼的时候电梯间只有优酷代理律师和我两个人。不知出于什么心理，律师说道，这种案件的结果可能会和你想象的完全不一样，似乎是笃定我完全没有胜诉的希望，这一刻我突然明白，律师针对这类案件是已经有了固定模式套路，人家就是要靠抓住你的漏洞来挣钱的，没有胜算的官司人家也不会打啊。最可怕的是他们一天到晚泡在法院，法官也难免不受思维定式的影响。可是 保持初心，做一款良心产品我又做错什么了呢？我依然不能相信给我的回报是这样一个结果。我收敛了一下郁闷的表情，平静而坚定的说：没有关系，我已经做好了最坏的打算，败诉了我也要继续上诉  。。。&lt;/p&gt;&lt;p&gt;接下来的过程就是等待最终的判决书，我已经做好了最坏的打算，希望您在这里留下自己的看法和建议，欢迎大家参与讨论，是非对错由大家评判。只希望我的发声能引起法官和相关从业者的更多思考，感谢您的阅读和关注，后继的进展我会继续更新。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;========================  第二次更新  ===============================&lt;/p&gt;&lt;p&gt;首先感谢，大家的支持。很多网友私信我给我这里出谋划策，还给我转发一些参考资料，在这里表示感谢，还有很多网友开始给我捐助，搞的我怪不好意思的。大家放心，不至于经过这么一个案子就我就倾家荡产了，况且即使败诉，也不至于要赔偿100万。我维护这个软件还是有收益的，纯粹靠爱发电也不可能维护这么长时间，所以我宁愿是因为软件好用捐助，而不是因为这件事情。&lt;/p&gt;&lt;p&gt;另外，看到评论中有很多骂优酷的网友，我目前倒是比较理性了，刚开始确实因为情绪的问题，写了一些不太妥当的文字（已经删除）。所以大家最好还是讨论对待此事的看法和见解吧。 有一个问题我需要说明的是，通过我的亲身经历，我发现被优酷起诉这件事未必可能是优酷本身主导。面对我的律师并非优酷内部法务团队，代理律师和优酷签订的是分成模式的合作。换句话说，就是优酷不必事先支付律师费用，而是官司打赢以后从赔款中扣除即可，剩下的钱由律师和优酷分成。从这里也就不奇怪，为啥不是先给我递送律师函要求停止拦截优酷广告，而是直接递送法院传票要求赔偿损失了。因为赔偿才是重点，我不知道这是法律圈内的行规还是什么，这样看来这个官司貌似也并非是纯粹为了维护商业秩序作为出发点。&lt;/p&gt;&lt;p&gt;广告拦截这个事情，确实是很有争议性。作者本身并不鼓励拦截所有广告，毕竟广告是互联网中最直接的变现模式，也是站长赖以生存的手段。但是哪些广告可以拦哪些广告不能栏，我也无法很好的界定，所以开发拦截功能的时候始终是围绕如何做到性能更好，更好的兼容拦截规则来进行，没有想到竟然会招惹这样的大麻烦。 优酷代理律师抓住我在官方网站上宣传”广告拦截“这个功能，说是我存在明显的主观故意诱导用户使用”广告拦截“功能。 那么问题来了，“广告拦截”这个功能到底是不是合法功能呢？说不合法，每个浏览器都存在此功能，说合法，你又无法在你的产品描述中宣传。&lt;/p&gt;&lt;p/&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>eb906a13ef6140018cdc4ebd5769dad4</guid>
<title>Java 中 9 种常见的 CMS GC 问题分析与解决</title>
<link>https://toutiao.io/k/mlyha8z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;了解大概什么原因后，如何定位和解决就很简单了，可以 dump 快照之后通过 JProfiler 或 MAT 观察 Classes 的 Histogram（&lt;/span&gt;&lt;span&gt;直方图&lt;/span&gt;&lt;span&gt;） 即可，或者直接通过命令即可定位， jcmd 打几次 Histogram 的图，看一下具体是哪个包下的 Class 增加较多就可以定位了。不过有时候也要结合InstBytes、KlassBytes、Bytecodes、MethodAll 等几项指标综合来看下。如下图便是笔者使用 jcmd 排查到一个 Orika 的问题。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;jcmd &amp;lt;PID&amp;gt; GC.class_stats|awk &#x27;{print$13}&#x27;|sed  &#x27;s/\(.*\)\.\(.*\)/\1/g&#x27;|sort |uniq -c|sort -nrk1&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.17981072555205047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFayJzpZjA0ibzYr9NCJMgrsx3e5tLicASAjLLflmImMgTfcmtfOicAsnAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;如果无法从整体的角度定位，可以添加 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:+TraceClassLoading&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:+TraceClassUnLoading&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 参数观察详细的类加载和卸载信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.3.4 小结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原理理解比较复杂，但定位和解决问题会比较简单，经常会出问题的几个点有 Orika 的 classMap、JSON 的 ASMSerializer、Groovy 动态加载类等，基本都集中在反射、Javasisit 字节码增强、CGLIB 动态代理、OSGi 自定义类加载器等的技术点上。另外就是及时给 MetaSpace 区的使用率加一个监控，如果指标有波动提前发现并解决问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.4 场景四：过早晋升 * &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.4.1 现象&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种场景主要发生在分代的收集器上面，专业的术语称为“Premature Promotion”。90% 的对象朝生夕死，只有在 Young 区经历过几次 GC 的洗礼后才会晋升到 Old 区，每经历一次 GC 对象的 GC Age 就会增长 1，最大通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:MaxTenuringThreshold&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来控制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;过早晋升一般不会直接影响 GC，总会伴随着浮动垃圾、大对象担保失败等问题，但这些问题不是立刻发生的，我们可以观察以下几种现象来判断是否发生了过早晋升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分配速率接近于晋升速率&lt;/strong&gt;，对象晋升年龄较小。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GC 日志中出现“Desired survivor size 107347968 bytes, &lt;strong&gt;new threshold 1(max 6)&lt;/strong&gt;”等信息，说明此时经历过一次 GC 就会放到 Old 区。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Full GC 比较频繁&lt;/strong&gt;，且经历过一次 GC 之后 Old 区的&lt;strong&gt;变化比例非常大&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如说 Old 区触发的回收阈值是 80%，经历过一次 GC 之后下降到了 10%，这就说明 Old 区的 70% 的对象存活时间其实很短，如下图所示，Old 区大小每次 GC 后从 2.1G 回收到 300M，也就是说回收掉了 1.8G 的垃圾，只有 &lt;strong&gt;300M 的活跃对象&lt;/strong&gt;。整个 Heap 目前是 4G，活跃对象只占了不到十分之一。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3925845147219193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFHDZHUjKX9Dtz7VrxC55B3ao4SJian1pe8yf0xptDICJEzMaXYz4Ewmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;917&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;过早晋升的危害：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Young GC 频繁，总的吞吐量下降。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Full GC 频繁，可能会有较大停顿。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4.4.2 原因&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要的原因有以下两点：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Young/Eden 区过小：&lt;/strong&gt;过小的直接后果就是 Eden 被装满的时间变短，本应该回收的对象参与了 GC 并晋升，Young GC 采用的是复制算法，由基础篇我们知道 copying 耗时远大于 mark，也就是 Young GC 耗时本质上就是 copy 的时间（&lt;/span&gt;&lt;span&gt;CMS 扫描 Card Table 或 G1 扫描 Remember Set 出问题的情况另说&lt;/span&gt;&lt;span&gt;），没来及回收的对象增大了回收的代价，所以 Young GC  时间增加，同时又无法快速释放空间，Young GC 次数也跟着增加。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分配速率过大：&lt;/strong&gt;可以观察出问题前后 Mutator 的分配速率，如果有明显波动可以尝试观察网卡流量、存储类中间件慢查询日志等信息，看是否有大量数据被加载到内存中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;同时无法 GC 掉对象还会带来另外一个问题，引发动态年龄计算：JVM 通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:MaxTenuringThreshold&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 参数来控制晋升年龄，每经过一次 GC，年龄就会加一，达到最大年龄就可以进入 Old 区，最大值为 15（&lt;/span&gt;&lt;span&gt;因为 JVM 中使用 4 个比特来表示对象的年龄&lt;/span&gt;&lt;span&gt;）。设定固定的 MaxTenuringThreshold 值作为晋升条件：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MaxTenuringThreshold 如果设置得过大，原本应该晋升的对象一直停留在 Survivor 区，直到 Survivor 区溢出，一旦溢出发生，Eden + Survivor 中对象将不再依据年龄全部提升到 Old 区，这样对象老化的机制就失效了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MaxTenuringThreshold 如果设置得过小，过早晋升即对象不能在 Young 区充分被回收，大量短期对象被晋升到 Old 区，Old 区空间迅速增长，引起频繁的 Major GC，分代回收失去了意义，严重影响 GC 性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;相同应用在不同时间的表现不同，特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面问题，所以 Hotspot 会使用动态计算的方式来调整晋升的阈值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体动态计算可以看一下 Hotspot 源码，具体在 /src/hotspot/share/gc/shared/ageTable.cpp 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;compute_tenuring_threshold&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法中：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;compute_tenuring_threshold&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {&lt;br/&gt;  &lt;span&gt;//TargetSurvivorRatio默认50，意思是：在回收之后希望survivor区的占用率达到这个比例&lt;/span&gt;&lt;br/&gt;  size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;  size_t total = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  uint age = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  assert(sizes[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;no objects with age zero should be recorded&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (age &amp;lt; table_size) {&lt;span&gt;//table_size=16&lt;/span&gt;&lt;br/&gt;    total += sizes[age];&lt;br/&gt;    &lt;span&gt;//如果加上这个年龄的所有对象的大小之后，占用量&amp;gt;期望的大小，就设置age为新的晋升阈值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (total &amp;gt; desired_survivor_size) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    age++;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  uint result = age &amp;lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (PrintTenuringDistribution || UsePerfData) {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//打印期望的survivor的大小以及新计算出来的阈值，和设置的最大阈值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (PrintTenuringDistribution) {&lt;br/&gt;      gclog_or_tty-&amp;gt;cr();&lt;br/&gt;      gclog_or_tty-&amp;gt;print_cr(&lt;span&gt;&quot;Desired survivor size &quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot; bytes, new threshold %u (max %u)&quot;&lt;/span&gt;,&lt;br/&gt;        desired_survivor_size*oopSize, result, (int) MaxTenuringThreshold);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    total = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    age = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (age &amp;lt; table_size) {&lt;br/&gt;      total += sizes[age];&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (sizes[age] &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (PrintTenuringDistribution) {&lt;br/&gt;          gclog_or_tty-&amp;gt;print_cr(&lt;span&gt;&quot;- age %3u: &quot;&lt;/span&gt; SIZE_FORMAT_W(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;&quot; bytes, &quot;&lt;/span&gt; SIZE_FORMAT_W(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;&quot; total&quot;&lt;/span&gt;,&lt;br/&gt;                                        age,    sizes[age]*oopSize,          total*oopSize);&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (UsePerfData) {&lt;br/&gt;        _perf_sizes[age]-&amp;gt;set_value(sizes[age]*oopSize);&lt;br/&gt;      }&lt;br/&gt;      age++;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (UsePerfData) {&lt;br/&gt;      SharedHeap* sh = SharedHeap::heap();&lt;br/&gt;      CollectorPolicy* policy = sh-&amp;gt;collector_policy();&lt;br/&gt;      GCPolicyCounters* gc_counters = policy-&amp;gt;counters();&lt;br/&gt;      gc_counters-&amp;gt;tenuring_threshold()-&amp;gt;set_value(result);&lt;br/&gt;      gc_counters-&amp;gt;desired_survivor_size()-&amp;gt;set_value(&lt;br/&gt;        desired_survivor_size*oopSize);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;可以看到 Hotspot 遍历所有对象时，从所有年龄为 0 的对象占用的空间开始累加，如果加上年龄等于 n 的所有对象的空间之后，使用 Survivor 区的条件值（&lt;/span&gt;&lt;span&gt;TargetSurvivorRatio / 100，TargetSurvivorRatio 默认值为 50&lt;/span&gt;&lt;span&gt;）进行判断，若大于这个值则结束循环，将 n 和 MaxTenuringThreshold 比较，若 n 小，则阈值为 n，若 n 大，则只能去设置最大阈值为 MaxTenuringThreshold。&lt;strong&gt;动态年龄触发后导致更多的对象进入了 Old 区，造成资源浪费&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;4.4.3 策略&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;知道问题原因后我们就有解决的方向，如果是 &lt;strong&gt;Young/Eden 区过小&lt;/strong&gt;，我们可以在总的 Heap 内存不变的情况下适当增大 Young 区，具体怎么增加？一般情况下 Old 的大小应当为活跃对象的 2~3 倍左右，考虑到浮动垃圾问题最好在 3 倍左右，剩下的都可以分给 Young 区。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;拿笔者的一次典型过早晋升优化来看，原配置为 Young 1.2G + Old 2.8G，通过观察 CMS GC 的情况找到存活对象大概为 300~400M，于是调整 Old 1.5G 左右，剩下 2.5G 分给 Young 区。仅仅调了一个 Young 区大小参数（&lt;/span&gt;&lt;code&gt;&lt;span&gt;-Xmn&lt;/span&gt;&lt;/code&gt;&lt;span&gt;），整个 JVM 一分钟 Young GC 从 26 次降低到了 11 次，单次时间也没有增加，总的 GC 时间从 1100ms 降低到了 500ms，CMS GC 次数也从 40 分钟左右一次降低到了 7 小时 30 分钟一次。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.34178610804851156&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFnxFGw7OcJ1BZEyRZ4Ax4fZrJ6pPejxEpWTp64IVvOWKVeO7H0OOc9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;br/&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3404255319148936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFxUApAYSu0ymUGRoFbgTg7ibvTDQcjzXJrtdp43F4iav07MnTIT5hy6gA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;893&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;br/&gt;&lt;span&gt;如果是分配速率过大：&lt;/span&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.4.4 小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;过早晋升问题一般不会特别明显，但日积月累之后可能会爆发一波收集器退化之类的问题，所以我们还是要提前避免掉的，可以看看自己系统里面是否有这些现象，如果比较匹配的话，可以尝试优化一下。一行代码优化的 ROI 还是很高的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果在观察 Old 区前后比例变化的过程中，发现可以回收的比例非常小，如从 80% 只回收到了 60%，说明我们大部分对象都是存活的，Old 区的空间可以适当调大些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.4.5 加餐&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于在调整 Young 与 Old 的比例时，如何选取具体的 NewRatio 值，这里将问题抽象成为一个蓄水池模型，找到以下关键衡量指标，大家可以根据自己场景进行推算。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4410726887791108&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFibiaDbSnXafbyDCLsKbFtSdrq9sHia3DPdw9Xes7QAH09YsfBd0znO8cw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;5668&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.1702857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFariatlGZPAYYT7OzuzwlVjMFk5KWCxX5QiadqyjfOS7jMzdh5Sic5Y71Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1750&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;NewRatio 的值 r 与 v&lt;sub&gt;a&lt;/sub&gt;、v&lt;sub&gt;p&lt;/sub&gt;、v&lt;sub&gt;yc&lt;/sub&gt;、v&lt;sub&gt;oc&lt;/sub&gt;、r&lt;sub&gt;s&lt;/sub&gt; 等值存在一定函数相关性（&lt;/span&gt;&lt;span&gt;r&lt;sub&gt;s&lt;/sub&gt; 越小 r 越大、r 越小 v&lt;sub&gt;p&lt;/sub&gt; 越小，…，之前尝试使用 NN 来辅助建模，但目前还没有完全算出具体的公式，有想法的同学可以在评论区给出你的答案 &lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;总停顿时间 T  为 Young GC 总时间 T&lt;sub&gt;yc&lt;/sub&gt; 和 Old GC 总时间 T&lt;sub&gt;oc&lt;/sub&gt; 之和，其中 T&lt;sub&gt;yc&lt;/sub&gt; 与 v&lt;sub&gt;yc&lt;/sub&gt; 和 v&lt;sub&gt;p&lt;/sub&gt; 相关，T&lt;sub&gt;oc&lt;/sub&gt; 与 v&lt;sub&gt;oc&lt;/sub&gt;相关。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;忽略掉 GC 时间后，两次 Young GC 的时间间隔要大于 TP9999 时间，这样尽量让对象在 Eden 区就被回收，可以减少很多停顿。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.5 场景五：CMS Old GC 频繁 *&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.5.1 现象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Old 区频繁的做 CMS GC，但是每次耗时不是特别长，整体最大 STW 也在可接受范围内，但由于 GC 太频繁导致吞吐下降比较多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.5.2 原因&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况比较常见，基本都是一次 Young GC 完成后，负责处理 CMS GC 的一个后台线程 concurrentMarkSweepThread 会不断地轮询，使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;shouldConcurrentCollect()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法做一次检测，判断是否达到了回收条件。如果达到条件，使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;collect_in_background()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 启动一次 Background 模式 GC。轮询的判断是使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;sleepBeforeNextCycle()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，间隔周期为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:CMSWaitDuration&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 决定，默认为2s。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体代码在：src/hotspot/share/gc/cms/concurrentMarkSweepThread.cpp。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;run_service()&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;void ConcurrentMarkSweepThread::run_service() {&lt;br/&gt;  assert(this == cmst(), &lt;span&gt;&quot;just checking&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (BindCMSThreadToCPU &amp;amp;&amp;amp; !os::bind_to_processor(CPUForCMSThread)) {&lt;br/&gt;    log_warning(gc)(&lt;span&gt;&quot;Couldn&#x27;t bind CMS thread to processor &quot;&lt;/span&gt; UINTX_FORMAT, CPUForCMSThread);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (!should_terminate()) {&lt;br/&gt;    sleepBeforeNextCycle();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (should_terminate()) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    GCIdMark gc_id_mark;&lt;br/&gt;    GCCause::Cause cause = _collector-&amp;gt;_full_gc_requested ?&lt;br/&gt;      _collector-&amp;gt;_full_gc_cause : GCCause::_cms_concurrent_mark;&lt;br/&gt;    _collector-&amp;gt;collect_in_background(cause);&lt;br/&gt;  }&lt;br/&gt;  verify_ok_to_terminate();&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;sleepBeforeNextCycle()&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; ConcurrentMarkSweepThread::sleepBeforeNextCycle() {&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (!should_terminate()) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;CMSWaitDuration&lt;/span&gt; &amp;gt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// Wait until the next synchronous GC, a concurrent full gc&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// request or a timeout, whichever is earlier.&lt;/span&gt;&lt;br/&gt;      wait_on_cms_lock_for_scavenge(&lt;span&gt;CMSWaitDuration&lt;/span&gt;);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// Wait until any cms_lock event or check interval not to call shouldConcurrentCollect permanently&lt;/span&gt;&lt;br/&gt;      wait_on_cms_lock(&lt;span&gt;CMSCheckInterval&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// Check if we should start a CMS collection cycle&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (_collector-&amp;gt;shouldConcurrentCollect()) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// .. collection criterion not yet met, let&#x27;s go back&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// and wait some more&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;判断是否进行回收的代码在：/src/hotspot/share/gc/cms/concurrentMarkSweepGeneration.cpp。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;shouldConcurrentCollect()&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;bool CMSCollector::shouldConcurrentCollect() {&lt;br/&gt;  LogTarget(Trace, gc) log;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (_full_gc_requested) {&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;CMSCollector: collect because of explicit  gc request (or GCLocker)&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  FreelistLocker x(this);&lt;br/&gt;  &lt;span&gt;// ------------------------------------------------------------------&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Print out lots of information which affects the initiation of&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// a collection.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (log.is_enabled() &amp;amp;&amp;amp; stats().valid()) {&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;CMSCollector shouldConcurrentCollect: &quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    LogStream out(log);&lt;br/&gt;    stats().print_on(&amp;amp;out);&lt;br/&gt;&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;time_until_cms_gen_full %3.7f&quot;&lt;/span&gt;, stats().time_until_cms_gen_full());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;free=&quot;&lt;/span&gt; SIZE_FORMAT, _cmsGen-&amp;gt;free());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;contiguous_available=&quot;&lt;/span&gt; SIZE_FORMAT, _cmsGen-&amp;gt;contiguous_available());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;promotion_rate=%g&quot;&lt;/span&gt;, stats().promotion_rate());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;cms_allocation_rate=%g&quot;&lt;/span&gt;, stats().cms_allocation_rate());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;occupancy=%3.7f&quot;&lt;/span&gt;, _cmsGen-&amp;gt;occupancy());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;initiatingOccupancy=%3.7f&quot;&lt;/span&gt;, _cmsGen-&amp;gt;initiating_occupancy());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;cms_time_since_begin=%3.7f&quot;&lt;/span&gt;, stats().cms_time_since_begin());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;cms_time_since_end=%3.7f&quot;&lt;/span&gt;, stats().cms_time_since_end());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;metadata initialized %d&quot;&lt;/span&gt;, MetaspaceGC::should_concurrent_collect());&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// ------------------------------------------------------------------&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!UseCMSInitiatingOccupancyOnly) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (stats().valid()) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (stats().time_until_cms_start() == &lt;span&gt;0.0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (_cmsGen-&amp;gt;occupancy() &amp;gt;= _bootstrap_occupancy) {&lt;br/&gt;        log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot; CMSCollector: collect for bootstrapping statistics: occupancy = %f, boot occupancy = %f&quot;&lt;/span&gt;,&lt;br/&gt;                  _cmsGen-&amp;gt;occupancy(), _bootstrap_occupancy);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (_cmsGen-&amp;gt;should_concurrent_collect()) {&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;CMS old gen initiated&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// We start a collection if we believe an incremental collection may fail;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// this is not likely to be productive in practice because it&#x27;s probably too&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// late anyway.&lt;/span&gt;&lt;br/&gt;  CMSHeap* heap = CMSHeap::heap();&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (heap-&amp;gt;incremental_collection_will_fail(&lt;span&gt;true&lt;/span&gt; &lt;span&gt;/* consult_young */&lt;/span&gt;)) {&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;CMSCollector: collect because incremental collection will fail &quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (MetaspaceGC::should_concurrent_collect()) {&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;CMSCollector: collect for metadata allocation &quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// CMSTriggerInterval starts a CMS cycle if enough time has passed.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (CMSTriggerInterval &amp;gt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (CMSTriggerInterval == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// Trigger always&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Check the CMS time since begin (we do not check the stats validity&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// as we want to be able to trigger the first CMS cycle as well)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (stats().cms_time_since_begin() &amp;gt;= (CMSTriggerInterval / ((double) MILLIUNITS))) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (stats().valid()) {&lt;br/&gt;        log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;CMSCollector: collect because of trigger interval (time since last begin %3.7f secs)&quot;&lt;/span&gt;,&lt;br/&gt;                  stats().cms_time_since_begin());&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;CMSCollector: collect because of trigger interval (first collection)&quot;&lt;/span&gt;);&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;分析其中逻辑判断是否触发 GC，分为以下几种情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家可以看一下源码中的日志打印，通过日志我们就可以比较清楚地知道具体的原因，然后就可以着手分析了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.5.3 策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们这里还是拿最常见的达到回收比例这个场景来说，与过早晋升不同的是这些对象确实存活了一段时间，Survival Time 超过了 TP9999 时间，但是又达不到长期存活，如各种数据库、网络链接，带有失效时间的缓存等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;处理这种常规内存泄漏问题基本是一个思路，主要步骤如下：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.30910543130990414&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFLmnSudH7SxmugG2SKjAHfdtLxx3ibZh6sGAaqHnLebOVNECUBU9jKicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;7512&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;Dump Diff 和 Leak Suspects 比较直观就不介绍了，这里说下其它几个关键点：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;内存 Dump：&lt;/strong&gt;使用 jmap、arthas 等 dump 堆进行快照时记得摘掉流量，同时&lt;strong&gt;分别在 CMS GC 的发生前后分别 dump 一次&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分析 Top Component：&lt;/strong&gt;要记得按照对象、类、类加载器、包等多个维度观察 Histogram，同时使用 outgoing 和 incoming 分析关联的对象，另外就是 Soft Reference 和 Weak Reference、Finalizer 等也要看一下。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;分析 Unreachable：&lt;/strong&gt;重点看一下这个，关注下 Shallow 和 Retained 的大小。如下图所示，笔者之前一次 GC 优化，就根据 Unreachable Objects 发现了 Hystrix 的滑动窗口问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5316901408450704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyF5HBmxianlAngaW2SwUwgkNp1PUWAkia3HX9IxIdVG7YD8zUyBEzBRSPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;852&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.5.4 小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过整个流程下来基本就能定位问题了，不过在优化的过程中记得使用&lt;strong&gt;控制变量&lt;/strong&gt;的方法来优化，防止一些会加剧问题的改动被掩盖。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.6 场景六：单次 CMS Old GC 耗时长 *&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.6.1 现象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CMS GC 单次 STW 最大超过 1000ms，不会频繁发生，如下图所示最长达到了 8000ms。某些场景下会引起“雪崩效应”，这种场景非常危险，我们应该尽量避免出现。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3243953732912723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFMs1zibSgpvbLOX8UOKzykYavKgurJSkFAO17CZsLg5uWCDWKPw4SgAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1902&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.6.2 原因&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CMS 在回收的过程中，STW 的阶段主要是 Init Mark 和 Final Remark 这两个阶段，也是导致 CMS Old GC 最多的原因，另外有些情况就是在 STW 前等待 Mutator 的线程到达 SafePoint 也会导致时间过长，但这种情况较少，我们在此处主要讨论前者。发生收集器退化或者碎片压缩的场景请看场景七。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想要知道这两个阶段为什么会耗时，我们需要先看一下这两个阶段都会干什么。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;核心代码都在 /src/hotspot/share/gc/cms/concurrentMarkSweepGeneration.cpp 中，内部有个线程 ConcurrentMarkSweepThread 轮询来校验，Old 区的垃圾回收相关细节被完全封装在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CMSCollector&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中，调用入口就是 ConcurrentMarkSweepThread 调用的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CMSCollector::collect_in_background&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ConcurrentMarkSweepGeneration&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 调用的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CMSCollector::collect&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，此处我们讨论大多数场景的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;collect_in_background&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。整个过程中会 STW 的主要是 initial Mark 和 Final Remark，核心代码在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;VM_CMS_Initial_Mark&lt;/span&gt;&lt;/code&gt;&lt;span&gt; / &lt;/span&gt;&lt;code&gt;&lt;span&gt;VM_CMS_Final_Remark&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中，执行时需要将执行权交由 VMThread 来执行。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;CMSCollector::checkpointRootsInitialWork()&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;void CMSCollector::checkpointRootsInitialWork() {&lt;br/&gt;  assert(SafepointSynchronize::is_at_safepoint(), &lt;span&gt;&quot;world should be stopped&quot;&lt;/span&gt;);&lt;br/&gt;  assert(_collectorState == InitialMarking, &lt;span&gt;&quot;just checking&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Already have locks.&lt;/span&gt;&lt;br/&gt;  assert_lock_strong(bitMapLock());&lt;br/&gt;  assert(_markBitMap.isAllClear(), &lt;span&gt;&quot;was reset at end of previous cycle&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Setup the verification and class unloading state for this&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// CMS collection cycle.&lt;/span&gt;&lt;br/&gt;  setup_cms_unloading_and_verification_state();&lt;br/&gt;&lt;br/&gt;  GCTraceTime(Trace, gc, phases) ts(&lt;span&gt;&quot;checkpointRootsInitialWork&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Reset all the PLAB chunk arrays if necessary.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (_survivor_plab_array != &lt;span&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp; !CMSPLABRecordAlways) {&lt;br/&gt;    reset_survivor_plab_arrays();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  ResourceMark rm;&lt;br/&gt;  HandleMark  hm;&lt;br/&gt;&lt;br/&gt;  MarkRefsIntoClosure notOlder(_span, &amp;amp;_markBitMap);&lt;br/&gt;  CMSHeap* heap = CMSHeap::heap();&lt;br/&gt;&lt;br/&gt;  verify_work_stacks_empty();&lt;br/&gt;  verify_overflow_empty();&lt;br/&gt;&lt;br/&gt;  heap-&amp;gt;ensure_parsability(&lt;span&gt;false&lt;/span&gt;);  &lt;span&gt;// fill TLABs, but no need to retire them&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Update the saved marks which may affect the root scans.&lt;/span&gt;&lt;br/&gt;  heap-&amp;gt;save_marks();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// weak reference processing has not started yet.&lt;/span&gt;&lt;br/&gt;  ref_processor()-&amp;gt;set_enqueuing_is_done(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Need to remember all newly created CLDs,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// so that we can guarantee that the remark finds them.&lt;/span&gt;&lt;br/&gt;  ClassLoaderDataGraph::remember_new_clds(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Whenever a CLD is found, it will be claimed before proceeding to mark&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// the klasses. The claimed marks need to be cleared before marking starts.&lt;/span&gt;&lt;br/&gt;  ClassLoaderDataGraph::clear_claimed_marks();&lt;br/&gt;&lt;br/&gt;  print_eden_and_survivor_chunk_arrays();&lt;br/&gt;&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (CMSParallelInitialMarkEnabled) {&lt;br/&gt;      &lt;span&gt;// The parallel version.&lt;/span&gt;&lt;br/&gt;      WorkGang* workers = heap-&amp;gt;workers();&lt;br/&gt;      assert(workers != &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;&quot;Need parallel worker threads.&quot;&lt;/span&gt;);&lt;br/&gt;      uint n_workers = workers-&amp;gt;active_workers();&lt;br/&gt;&lt;br/&gt;      StrongRootsScope srs(n_workers);&lt;br/&gt;&lt;br/&gt;      CMSParInitialMarkTask tsk(this, &amp;amp;srs, n_workers);&lt;br/&gt;      initialize_sequential_subtasks_for_young_gen_rescan(n_workers);&lt;br/&gt;      &lt;span&gt;// If the total workers is greater than 1, then multiple workers&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// may be used at some time and the initialization has been set&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// such that the single threaded path cannot be used.&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (workers-&amp;gt;total_workers() &amp;gt; &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        workers-&amp;gt;run_task(&amp;amp;tsk);&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        tsk.work(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;      }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// The serial version.&lt;/span&gt;&lt;br/&gt;      CLDToOopClosure cld_closure(&amp;amp;notOlder, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;      heap-&amp;gt;rem_set()-&amp;gt;prepare_for_younger_refs_iterate(&lt;span&gt;false&lt;/span&gt;); &lt;span&gt;// Not parallel.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;      StrongRootsScope srs(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;      heap-&amp;gt;cms_process_roots(&amp;amp;srs,&lt;br/&gt;                             &lt;span&gt;true&lt;/span&gt;,   &lt;span&gt;// young gen as roots&lt;/span&gt;&lt;br/&gt;                             GenCollectedHeap::ScanningOption(roots_scanning_options()),&lt;br/&gt;                             should_unload_classes(),&lt;br/&gt;                             &amp;amp;notOlder,&lt;br/&gt;                             &amp;amp;cld_closure);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Clear mod-union table; it will be dirtied in the prologue of&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// CMS generation per each young generation collection.&lt;/span&gt;&lt;br/&gt;  assert(_modUnionTable.isAllClear(),&lt;br/&gt;       &lt;span&gt;&quot;Was cleared in most recent final checkpoint phase&quot;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;&quot; or no bits are set in the gc_prologue before the start of the next &quot;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;&quot;subsequent marking phase.&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  assert(_ct-&amp;gt;cld_rem_set()-&amp;gt;mod_union_is_clear(), &lt;span&gt;&quot;Must be&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;// Save the end of the used_region of the constituent generations&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// to be used to limit the extent of sweep in each generation.&lt;/span&gt;&lt;br/&gt;  save_sweep_limits();&lt;br/&gt;  verify_overflow_empty();&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;CMSParInitialMarkTask::work&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;void CMSParInitialMarkTask::work(uint worker_id) {&lt;br/&gt;  elapsedTimer _timer;&lt;br/&gt;  ResourceMark rm;&lt;br/&gt;  HandleMark   hm;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ---------- scan from roots --------------&lt;/span&gt;&lt;br/&gt;  _timer.start();&lt;br/&gt;  CMSHeap* heap = CMSHeap::heap();&lt;br/&gt;  ParMarkRefsIntoClosure par_mri_cl(_collector-&amp;gt;_span, &amp;amp;(_collector-&amp;gt;_markBitMap));&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ---------- young gen roots --------------&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    work_on_young_gen_roots(&amp;amp;par_mri_cl);&lt;br/&gt;    _timer.stop();&lt;br/&gt;    log_trace(gc, task)(&lt;span&gt;&quot;Finished young gen initial mark scan work in %dth thread: %3.3f sec&quot;&lt;/span&gt;, worker_id, _timer.seconds());&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ---------- remaining roots --------------&lt;/span&gt;&lt;br/&gt;  _timer.reset();&lt;br/&gt;  _timer.start();&lt;br/&gt;&lt;br/&gt;  CLDToOopClosure cld_closure(&amp;amp;par_mri_cl, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  heap-&amp;gt;cms_process_roots(_strong_roots_scope,&lt;br/&gt;                          &lt;span&gt;false&lt;/span&gt;,     &lt;span&gt;// yg was scanned above&lt;/span&gt;&lt;br/&gt;                          GenCollectedHeap::ScanningOption(_collector-&amp;gt;CMSCollector::roots_scanning_options()),&lt;br/&gt;                          _collector-&amp;gt;should_unload_classes(),&lt;br/&gt;                          &amp;amp;par_mri_cl,&lt;br/&gt;                          &amp;amp;cld_closure,&lt;br/&gt;                          &amp;amp;_par_state_string);&lt;br/&gt;&lt;br/&gt;  assert(_collector-&amp;gt;should_unload_classes()&lt;br/&gt;         || (_collector-&amp;gt;CMSCollector::roots_scanning_options() &amp;amp; GenCollectedHeap::SO_AllCodeCache),&lt;br/&gt;         &lt;span&gt;&quot;if we didn&#x27;t scan the code cache, we have to be ready to drop nmethods with expired weak oops&quot;&lt;/span&gt;);&lt;br/&gt;  _timer.stop();&lt;br/&gt;  log_trace(gc, task)(&lt;span&gt;&quot;Finished remaining root initial mark scan work in %dth thread: %3.3f sec&quot;&lt;/span&gt;, worker_id, _timer.seconds());&lt;br/&gt;}&lt;/span&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;figure&gt;&lt;br/&gt;&lt;img data-ratio=&quot;0.0594059405940594&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFv4rUSNPUSNSp2Q9IEg8EZOON11moGRwucbkEXicWYHB0ZkynuQDYEPg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;7272&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;整个过程比较简单，从 GC Root 出发标记 Old 中的对象，处理完成后借助 BitMap 处理下 Young 区对 Old 区的引用，整个过程基本都比较快，很少会有较大的停顿。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;CMSCollector::checkpointRootsFinalWork()&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;void CMSCollector::checkpointRootsFinalWork() {&lt;br/&gt;  GCTraceTime(Trace, gc, phases) tm(&lt;span&gt;&quot;checkpointRootsFinalWork&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;&lt;br/&gt;  assert(haveFreelistLocks(), &lt;span&gt;&quot;must have free list locks&quot;&lt;/span&gt;);&lt;br/&gt;  assert_lock_strong(bitMapLock());&lt;br/&gt;&lt;br/&gt;  ResourceMark rm;&lt;br/&gt;  HandleMark   hm;&lt;br/&gt;&lt;br/&gt;  CMSHeap* heap = CMSHeap::heap();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (should_unload_classes()) {&lt;br/&gt;    CodeCache::gc_prologue();&lt;br/&gt;  }&lt;br/&gt;  assert(haveFreelistLocks(), &lt;span&gt;&quot;must have free list locks&quot;&lt;/span&gt;);&lt;br/&gt;  assert_lock_strong(bitMapLock());&lt;br/&gt;&lt;br/&gt;  heap-&amp;gt;ensure_parsability(&lt;span&gt;false&lt;/span&gt;);  &lt;span&gt;// fill TLAB&#x27;s, but no need to retire them&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Update the saved marks which may affect the root scans.&lt;/span&gt;&lt;br/&gt;  heap-&amp;gt;save_marks();&lt;br/&gt;&lt;br/&gt;  print_eden_and_survivor_chunk_arrays();&lt;br/&gt;&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (CMSParallelRemarkEnabled) {&lt;br/&gt;      GCTraceTime(Debug, gc, phases) t(&lt;span&gt;&quot;Rescan (parallel)&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;      do_remark_parallel();&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      GCTraceTime(Debug, gc, phases) t(&lt;span&gt;&quot;Rescan (non-parallel)&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;      do_remark_non_parallel();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  verify_work_stacks_empty();&lt;br/&gt;  verify_overflow_empty();&lt;br/&gt;&lt;br/&gt;  {&lt;br/&gt;    GCTraceTime(Trace, gc, phases) ts(&lt;span&gt;&quot;refProcessingWork&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;    refProcessingWork();&lt;br/&gt;  }&lt;br/&gt;  verify_work_stacks_empty();&lt;br/&gt;  verify_overflow_empty();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (should_unload_classes()) {&lt;br/&gt;    CodeCache::gc_epilogue();&lt;br/&gt;  }&lt;br/&gt;  JvmtiExport::gc_epilogue();&lt;br/&gt;  assert(_markStack.isEmpty(), &lt;span&gt;&quot;No grey objects&quot;&lt;/span&gt;);&lt;br/&gt;  size_t ser_ovflw = _ser_pmc_remark_ovflw + _ser_pmc_preclean_ovflw +&lt;br/&gt;                     _ser_kac_ovflw        + _ser_kac_preclean_ovflw;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (ser_ovflw &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    log_trace(gc)(&lt;span&gt;&quot;Marking stack overflow (benign) (pmc_pc=&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;, pmc_rm=&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;, kac=&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;, kac_preclean=&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;)&quot;&lt;/span&gt;,&lt;br/&gt;                         _ser_pmc_preclean_ovflw, _ser_pmc_remark_ovflw, _ser_kac_ovflw, _ser_kac_preclean_ovflw);&lt;br/&gt;    _markStack.expand();&lt;br/&gt;    _ser_pmc_remark_ovflw = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    _ser_pmc_preclean_ovflw = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    _ser_kac_preclean_ovflw = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    _ser_kac_ovflw = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (_par_pmc_remark_ovflw &amp;gt; &lt;span&gt;0&lt;/span&gt; || _par_kac_ovflw &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;     log_trace(gc)(&lt;span&gt;&quot;Work queue overflow (benign) (pmc_rm=&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;, kac=&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;)&quot;&lt;/span&gt;,&lt;br/&gt;                          _par_pmc_remark_ovflw, _par_kac_ovflw);&lt;br/&gt;     _par_pmc_remark_ovflw = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    _par_kac_ovflw = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (_markStack._hit_limit &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;     log_trace(gc)(&lt;span&gt;&quot; (benign) Hit max stack size limit (&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;)&quot;&lt;/span&gt;,&lt;br/&gt;                          _markStack._hit_limit);&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (_markStack._failed_double &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;     log_trace(gc)(&lt;span&gt;&quot; (benign) Failed stack doubling (&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;), current capacity &quot;&lt;/span&gt; SIZE_FORMAT,&lt;br/&gt;                          _markStack._failed_double, _markStack.capacity());&lt;br/&gt;   }&lt;br/&gt;  _markStack._hit_limit = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  _markStack._failed_double = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ((VerifyAfterGC || VerifyDuringGC) &amp;amp;&amp;amp;&lt;br/&gt;      CMSHeap::heap()-&amp;gt;total_collections() &amp;gt;= VerifyGCStartAt) {&lt;br/&gt;    verify_after_remark();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  _gc_tracer_cm-&amp;gt;report_object_count_after_gc(&amp;amp;_is_alive_closure);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Change under the freelistLocks.&lt;/span&gt;&lt;br/&gt;  _collectorState = Sweeping;&lt;br/&gt;  &lt;span&gt;// Call isAllClear() under bitMapLock&lt;/span&gt;&lt;br/&gt;  assert(_modUnionTable.isAllClear(),&lt;br/&gt;      &lt;span&gt;&quot;Should be clear by end of the final marking&quot;&lt;/span&gt;);&lt;br/&gt;  assert(_ct-&amp;gt;cld_rem_set()-&amp;gt;mod_union_is_clear(),&lt;br/&gt;      &lt;span&gt;&quot;Should be clear by end of the final marking&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;figure&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.04205607476635514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFI780KrHWsqJaWv13HdIoE5ZY2Nzr2Q0Jvtw6pIAcc9YgGg322Mib64w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;10272&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;Final Remark 是最终的第二次标记，这种情况只有在 Background GC 执行了 InitialMarking 步骤的情形下才会执行，如果是 Foreground GC 执行的 InitialMarking 步骤则不需要再次执行 FinalRemark。Final Remark 的开始阶段与 Init Mark 处理的流程相同，但是后续多了 Card Table 遍历、Reference 实例的清理并将其加入到 Reference 维护的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;pend_list&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中，如果要收集元数据信息，还要清理 SystemDictionary、CodeCache、SymbolTable、StringTable 等组件中不再使用的资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.6.3 策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;知道了两个 STW 过程执行流程，我们分析解决就比较简单了，由于大部分问题都出在 Final Remark 过程，这里我们也拿这个场景来举例，主要步骤：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;2019-02-27T19:55:37.920+0800: 516952.915: [GC (CMS Final Remark) 516952.915: [ParNew516952.939: [SoftReference, 0 refs, 0.0003857 secs]516952.939: [WeakReference, 1362 refs, 0.0002415 secs]516952.940: [FinalReference, 146 refs, 0.0001233 secs]516952.940: [PhantomReference, 0 refs, 57 refs, 0.0002369 secs]516952.940: [JNI Weak Reference, 0.0000662 secs]&lt;br/&gt;[&lt;span&gt;class unloading, 0.1770490 secs&lt;/span&gt;]516953.329: [&lt;span&gt;scrub symbol table, 0.0442567 secs&lt;/span&gt;]516953.373: [&lt;span&gt;scrub string table, 0.0036072 secs&lt;/span&gt;][&lt;span&gt;1 CMS-remark: 1638504K(2048000K)&lt;/span&gt;] 1667558K(4352000K), 0.5269311 secs] [Times: user=1.20 sys=0.03, real=0.53 secs]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;CMSCollector::refProcessingWork()&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; (should_unload_classes()) {&lt;br/&gt;    {&lt;br/&gt;      GCTraceTime(Debug, gc, phases) t(&lt;span&gt;&quot;Class Unloading&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;//&lt;/span&gt; Unload classes &lt;span&gt;and&lt;/span&gt; purge the SystemDictionary.&lt;br/&gt;      bool purged_class = SystemDictionary::do_unloading(_gc_timer_cm);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;//&lt;/span&gt; Unload nmethods.&lt;br/&gt;      CodeCache::do_unloading(&amp;amp;_is_alive_closure, purged_class);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;//&lt;/span&gt; Prune dead klasses from subklass/sibling/implementor lists.&lt;br/&gt;      Klass::clean_weak_klass_links(purged_class);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    {&lt;br/&gt;      GCTraceTime(Debug, gc, phases) t(&lt;span&gt;&quot;Scrub Symbol Table&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;      &lt;span&gt;//&lt;/span&gt; Clean up unreferenced symbols &lt;span&gt;in&lt;/span&gt; symbol table.&lt;br/&gt;      SymbolTable::unlink();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    {&lt;br/&gt;      GCTraceTime(Debug, gc, phases) t(&lt;span&gt;&quot;Scrub String Table&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;      &lt;span&gt;//&lt;/span&gt; Delete entries &lt;span&gt;for&lt;/span&gt; dead interned strings.&lt;br/&gt;      StringTable::unlink(&amp;amp;_is_alive_closure);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4.6.4 小结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正常情况进行的 Background CMS GC，出现问题基本都集中在 Reference 和 Class 等元数据处理上，在 Reference 类的问题处理方面，不管是 FinalReference，还是 SoftReference、WeakReference 核心的手段就是找准时机 dump 快照，然后用内存分析工具来分析。Class 处理方面目前除了关闭类卸载开关，没有太好的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 G1 中同样有 Reference 的问题，可以观察日志中的 Ref Proc，处理方法与 CMS 类似。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.7 场景七：内存碎片&amp;amp;收集器退化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.7.1 现象&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并发的 CMS GC 算法，退化为 Foreground 单线程串行 GC 模式，STW 时间超长，有时会长达十几秒。其中 CMS 收集器退化后单线程串行 GC 算法有两种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.7.2 原因&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CMS 发生收集器退化主要有以下几种情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;晋升失败（Promotion Failed）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;顾名思义，晋升失败就是指在进行 Young GC 时，Survivor 放不下，对象只能放入 Old，但此时 Old 也放不下。直觉上乍一看这种情况可能会经常发生，但其实因为有 concurrentMarkSweepThread 和担保机制的存在，发生的条件是很苛刻的，除非是短时间将 Old 区的剩余空间迅速填满，例如上文中说的动态年龄判断导致的过早晋升（&lt;/span&gt;&lt;span&gt;见下文的增量收集担保失败&lt;/span&gt;&lt;span&gt;）。另外还有一种情况就是内存碎片导致的 Promotion Failed，Young GC 以为 Old 有足够的空间，结果到分配时，晋级的大对象找不到连续的空间存放。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用 CMS 作为 GC 收集器时，运行过一段时间的 Old 区如下图所示，清除算法导致内存出现多段的不连续，出现大量的内存碎片。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.30515759312320917&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFG5mFRX6WWV6XQQUetlIykPfbyXGcib33ewvQ7x2La7w6Dr91NeicwaWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;碎片带来了两个问题：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;空间分配效率较低&lt;/strong&gt;：上文已经提到过，如果是连续的空间 JVM 可以通过使用 pointer bumping 的方式来分配，而对于这种有大量碎片的空闲链表则需要逐个访问 freelist 中的项来访问，查找可以存放新建对象的地址。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;空间利用效率变低&lt;/strong&gt;：Young 区晋升的对象大小大于了连续空间的大小，那么将会触发 Promotion Failed ，即使整个 Old 区的容量是足够的，但由于其不连续，也无法存放新对象，也就是本文所说的问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;增量收集担保失败&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分配内存失败后，会判断统计得到的 Young GC 晋升到 Old 的平均大小，以及当前 Young 区已使用的大小也就是最大可能晋升的对象大小，是否大于 Old 区的剩余空间。只要 CMS 的剩余空间比前两者的任意一者大，CMS 就认为晋升还是安全的，反之，则代表不安全，不进行Young GC，直接触发Full GC。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;显式 GC&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况参见场景二。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;并发模式失败（Concurrent Mode Failure）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后一种情况，也是发生概率较高的一种，在 GC 日志中经常能看到 Concurrent Mode Failure 关键字。这种是由于并发 Background CMS GC 正在执行，同时又有 Young GC 晋升的对象要放入到了 Old 区中，而此时 Old 区空间不足造成的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么 CMS GC 正在执行还会导致收集器退化呢？主要是由于 CMS 无法处理浮动垃圾（&lt;/span&gt;&lt;span&gt;Floating Garbage&lt;/span&gt;&lt;span&gt;）引起的。CMS 的并发清理阶段，Mutator 还在运行，因此不断有新的垃圾产生，而这些垃圾不在这次清理标记的范畴里，无法在本次 GC 被清除掉，这些就是浮动垃圾，除此之外在 Remark 之前那些断开引用脱离了读写屏障控制的对象也算浮动垃圾。所以 Old 区回收的阈值不能太高，否则预留的内存空间很可能不够，从而导致 Concurrent Mode Failure 发生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.7.3 策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分析到具体原因后，我们就可以针对性解决了，具体思路还是从根因出发，具体解决策略：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;内存碎片：&lt;/strong&gt;通过配置 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:UseCMSCompactAtFullCollection=true&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来控制 Full GC的过程中是否进行空间的整理（&lt;/span&gt;&lt;span&gt;默认开启，注意是Full GC，不是普通CMS GC&lt;/span&gt;&lt;span&gt;），以及 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX: CMSFullGCsBeforeCompaction=n&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来控制多少次 Full GC 后进行一次压缩。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;增量收集：&lt;/strong&gt;降低触发 CMS GC 的阈值，即参数 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:CMSInitiatingOccupancyFraction&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的值，让 CMS GC 尽早执行，以保证有足够的连续空间，也减少 Old 区空间的使用大小，另外需要使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:+UseCMSInitiatingOccupancyOnly&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来配合使用，不然 JVM 仅在第一次使用设定值，后续则自动调整。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;浮动垃圾：&lt;/strong&gt;视情况控制每次晋升对象的大小，或者缩短每次 CMS GC 的时间，必要时可调节 NewRatio 的值。另外就是使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:+CMSScavengeBeforeRemark&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 在过程中提前触发一次 Young GC，防止后续晋升过多对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4.7.4 小结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正常情况下触发并发模式的 CMS GC，停顿非常短，对业务影响很小，但 CMS GC 退化后，影响会非常大，建议发现一次后就彻底根治。只要能定位到内存碎片、浮动垃圾、增量收集相关等具体产生原因，还是比较好解决的，关于内存碎片这块，如果 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:CMSFullGCsBeforeCompaction&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的值不好选取的话，可以使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:PrintFLSStatistics&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来观察内存碎片率情况，然后再设置具体的值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后就是在编码的时候也要避免需要连续地址空间的大对象的产生，如过长的字符串，用于存放附件、序列化或反序列化的 byte 数组等，还有就是过早晋升问题尽量在爆发问题前就避免掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.8 场景八：堆外内存 OOM&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.8.1 现象&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内存使用率不断上升，甚至开始使用 SWAP 内存，同时可能出现 GC 时间飙升，线程被 Block 等现象，&lt;strong&gt;通过 top 命令发现 Java 进程的 RES 甚至超过了 &lt;/strong&gt;&lt;strong&gt;&lt;code&gt;-Xmx&lt;/code&gt; 的大小&lt;/strong&gt;。出现这些现象时，基本可以确定是出现了堆外内存泄漏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.8.2 原因&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JVM 的堆外内存泄漏，主要有两种的原因：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.8.3 策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哪种原因造成的堆外内存泄漏？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，我们需要确定是哪种原因导致的堆外内存泄漏。这里可以使用 NMT（&lt;/span&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;NativeMemoryTracking&lt;/span&gt;&lt;/a&gt;&lt;span&gt;） 进行分析。在项目中添加 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:NativeMemoryTracking=detail&lt;/span&gt;&lt;/code&gt;&lt;span&gt; JVM参数后重启项目（&lt;/span&gt;&lt;span&gt;需要注意的是，打开 NMT 会带来 5%~10% 的性能损耗&lt;/span&gt;&lt;span&gt;）。使用命令 &lt;/span&gt;&lt;code&gt;&lt;span&gt;jcmd pid VM.native_memory detail&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查看内存分布。重点观察 total 中的 committed，因为 jcmd 命令显示的内存包含堆内内存、Code 区域、通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Unsafe.allocateMemory&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;DirectByteBuffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 申请的内存，但是不包含其他 Native Code（&lt;/span&gt;&lt;span&gt;C 代码&lt;/span&gt;&lt;span&gt;）申请的堆外内存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果 total 中的 committed 和 top 中的 RES 相差不大，则应为主动申请的堆外内存未释放造成的，如果相差较大，则基本可以确定是 JNI 调用造成的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;原因一：主动申请未释放&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JVM 使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:MaxDirectMemorySize=size&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 参数来控制可申请的堆外内存的最大值。在 Java 8 中，如果未配置该参数，默认和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-Xmx&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 相等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;NIO 和 Netty 都会取 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:MaxDirectMemorySize&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 配置的值，来限制申请的堆外内存的大小。NIO 和 Netty 中还有一个计数器字段，用来计算当前已申请的堆外内存大小，NIO 中是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;java.nio.Bits#totalCapacity&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、Netty 中 &lt;/span&gt;&lt;code&gt;&lt;span&gt;io.netty.util.internal.PlatformDependent#DIRECT_MEMORY_COUNTER&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当申请堆外内存时，NIO 和 Netty 会比较计数器字段和最大值的大小，如果计数器的值超过了最大值的限制，会抛出 OOM 的异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;NIO 中是：&lt;/span&gt;&lt;code&gt;&lt;span&gt;OutOfMemoryError: Direct buffer memory&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Netty 中是：&lt;/span&gt;&lt;code&gt;&lt;span&gt;OutOfDirectMemoryError: failed to allocate  capacity  byte(s) of direct memory (used: usedMemory , max: DIRECT_MEMORY_LIMIT )&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以检查代码中是如何使用堆外内存的，NIO 或者是 Netty，通过反射，获取到对应组件中的计数器字段，并在项目中对该字段的数值进行打点，即可准确地监控到这部分堆外内存的使用情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时，可以通过 Debug 的方式确定使用堆外内存的地方是否正确执行了释放内存的代码。另外，需要检查 JVM 的参数是否有 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:+DisableExplicitGC&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 选项，如果有就去掉，因为该参数会使 System.gc 失效。（&lt;/span&gt;&lt;span&gt;场景二：显式 GC 的去与留&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;原因二：通过 JNI 调用的 Native Code 申请的内存未释放&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况排查起来比较困难，我们可以通过 Google perftools + Btrace 等工具，帮助我们分析出问题的代码在哪里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gperftools 是 Google 开发的一款非常实用的工具集，它的原理是在 Java 应用程序运行时，当调用 malloc 时换用它的 libtcmalloc.so，这样就能对内存分配情况做一些统计。我们使用 gperftools 来追踪分配内存的命令。如下图所示，通过 gperftools 发现 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Java_java_util_zip_Inflater_init&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 比较可疑。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.42979002624671914&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFC0gawic22114sP8s5ATTBGCSbqDVRoBmM5VoXdPjibqRWy2XCeJaZhGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1524&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;接下来可以使用 Btrace，尝试定位具体的调用栈。Btrace 是 Sun 推出的一款 Java 追踪、监控工具，可以在不停机的情况下对线上的 Java 程序进行监控。如下图所示，通过 Btrace 定位出项目中的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ZipHelper&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 在频繁调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;GZIPInputStream&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，在堆外内存分配对象。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.43343465045592705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFo2v6fzLUrRJfvZ3iao7PTpfY3R5jFdc0yicq5icktmV5CjVP786rJqsLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1645&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;最终定位到是，项目中对 &lt;/span&gt;&lt;code&gt;&lt;span&gt;GIPInputStream&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的使用错误，没有正确的 close()。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2718720602069614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFmFJoNUa6jLlVCfl1sibEciaKnN7jRx5Tt6ibjkzdqDNthRh0icUXNwpToQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2126&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;除了项目本身的原因，还可能有外部依赖导致的泄漏，如 Netty 和 Spring Boot，详细情况可以学习下这两篇文章：&lt;/span&gt;&lt;span&gt;《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651750037&amp;amp;idx=2&amp;amp;sn=847fb15d4413354355c33a46a7bccf55&amp;amp;chksm=bd12a7d88a652ecea5789073973abb9545e76a8972c843968a6efd1fb3a918ef07eed8abb37e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;疑案追踪：Spring Boot内存泄露排查记&lt;/a&gt;》、《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651749037&amp;amp;idx=2&amp;amp;sn=d1d6b0348eea5cd80e2c7a56c8a61fa9&amp;amp;chksm=bd12a3e08a652af684fd8d96e81fc0e0fded69dd847051e6b0f791f3726da0415c9552ee2615&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Netty堆外内存泄露排查盛宴&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Netty堆外内存泄露排查盛宴&lt;/a&gt;》&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.8.4 小结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先可以使用 NMT + jcmd 分析泄漏的堆外内存是哪里申请，确定原因后，使用不同的手段，进行原因定位。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3456913827655311&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFGGEWTylxLuu32uLTKCCE5uOSFJCbRxibJPDCDtNn68riasyJIGnH9nzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;998&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.9 场景九：JNI 引发的 GC 问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;4.9.1 现象&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 GC 日志中，出现 GC Cause 为 GCLocker Initiated GC。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;2020&lt;span&gt;-09-23T16&lt;/span&gt;&lt;span&gt;:49:09.727+0800&lt;/span&gt;: 504426&lt;span&gt;.742&lt;/span&gt;: &lt;span&gt;[GC (GCLocker Initiated GC) 504426.742: [ParNew (promotion failed): 209716K-&amp;gt;6042K(1887488K), 0.0843330 secs]&lt;/span&gt; 1449487&lt;span&gt;K-&lt;/span&gt;&amp;gt;1347626&lt;span&gt;K&lt;/span&gt;(3984640&lt;span&gt;K&lt;/span&gt;), 0&lt;span&gt;.0848963&lt;/span&gt; &lt;span&gt;secs&lt;/span&gt;] &lt;span&gt;[Times: user=0.19 sys=0.00, real=0.09 secs]&lt;/span&gt;&lt;br/&gt;2020&lt;span&gt;-09-23T16&lt;/span&gt;&lt;span&gt;:49:09.812+0800&lt;/span&gt;: 504426&lt;span&gt;.827&lt;/span&gt;: &lt;span&gt;[Full GC (GCLocker Initiated GC) 504426.827: [CMS: 1341583K-&amp;gt;419699K(2097152K), 1.8482275 secs]&lt;/span&gt; 1347626&lt;span&gt;K-&lt;/span&gt;&amp;gt;419699&lt;span&gt;K&lt;/span&gt;(3984640&lt;span&gt;K&lt;/span&gt;), &lt;span&gt;[Metaspace: 297780K-&amp;gt;297780K(1329152K)]&lt;/span&gt;, 1&lt;span&gt;.8490564&lt;/span&gt; &lt;span&gt;secs&lt;/span&gt;] &lt;span&gt;[Times: user=1.62 sys=0.20, real=1.85 secs]&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4.9.2 原因&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JNI（&lt;/span&gt;&lt;span&gt;Java Native Interface&lt;/span&gt;&lt;span&gt;）意为 Java 本地调用，它允许 Java 代码和其他语言写的 Native 代码进行交互。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JNI 如果需要获取 JVM 中的 String 或者数组，有两种方式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于 Native 代码直接使用了 JVM 堆区的指针，如果这时发生 GC，就会导致数据错误。因此，在发生此类 JNI 调用时，禁止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GC Locker 实验：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GCLockerTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ITERS = &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ARR_SIZE =  &lt;span&gt;10000&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; WINDOW = &lt;span&gt;10000000&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;acquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] arr)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;release&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] arr)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object[] window = &lt;span&gt;new&lt;/span&gt; Object[WINDOW];&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String... args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;    System.loadLibrary(&lt;span&gt;&quot;GCLockerTest&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt;[] arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[ARR_SIZE];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; ITERS; i++) {&lt;br/&gt;      acquire(arr);&lt;br/&gt;      System.out.println(&lt;span&gt;&quot;Acquired&quot;&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;; c &amp;lt; WINDOW; c++) {&lt;br/&gt;          window[c] = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;        }&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;        &lt;span&gt;// omit&lt;/span&gt;&lt;br/&gt;      } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Releasing&quot;&lt;/span&gt;);&lt;br/&gt;        release(arr);&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr/&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;jni.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&quot;GCLockerTest.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; jbyte* sink;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;JNIEXPORT &lt;span&gt;void&lt;/span&gt; JNICALL &lt;span&gt;Java_GCLockerTest_acquire&lt;/span&gt;&lt;span&gt;(JNIEnv* env, jclass klass, jintArray arr)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;sink = (*env)-&amp;gt;GetPrimitiveArrayCritical(env, arr, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;JNIEXPORT &lt;span&gt;void&lt;/span&gt; JNICALL &lt;span&gt;Java_GCLockerTest_release&lt;/span&gt;&lt;span&gt;(JNIEnv* env, jclass klass, jintArray arr)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;(*env)-&amp;gt;ReleasePrimitiveArrayCritical(env, arr, sink, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;运行该 JNI 程序，可以看到发生的 GC 都是 GCLocker Initiated GC，并且注意在 “Acquired” 和 “Released” 时不可能发生 GC。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.42289719626168226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFFeTUBhRYXPkib6QyGBwDSAANkTPQ2vpxVkMialIDHtkWiacZvb5Sytvbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1712&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;GC Locker 可能导致的不良后果有：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果此时是 Young 区不够 Allocation Failure 导致的 GC，由于无法进行 Young GC，会将对象直接分配至 Old 区。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果 Old 区也没有空间了，则会等待锁释放，导致线程阻塞。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可能触发额外不必要的 Young GC，JDK 有一个 Bug，有一定的几率，本来只该触发一次 GCLocker Initiated GC 的 Young GC，实际发生了一次 Allocation Failure GC 又紧接着一次 GCLocker Initiated GC。是因为 GCLocker Initiated GC 的属性被设为 full，导致两次 GC 不能收敛。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4.9.3 策略&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;添加 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX+PrintJNIGCStalls&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 参数，可以打印出发生 JNI 调用时的线程，进一步分析，找到引发问题的 JNI 调用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;JNI 调用需要谨慎，不一定可以提升性能，反而可能造成 GC 问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;升级 JDK 版本到 14，避免 &lt;/span&gt;&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8048556&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;JDK-8048556&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 导致的重复 GC。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.36304062909567497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyF5cJichumdiaic5tm9H34IeT4YBmWbxEm19ibaQlfb1cWkNDf3BjagrwMcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1526&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;4.9.4 小结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JNI 产生的 GC 问题较难排查，需要谨慎使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5. 总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这里，我们把整个文章内容总结一下，方便大家整体地理解回顾。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.1 处理流程（SOP）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图为整体 GC 问题普适的处理流程，重点的地方下面会单独标注，其他的基本都是标准处理流程，此处不再赘述，最后在整个问题都处理完之后有条件的话建议做一下复盘。&lt;/span&gt;&lt;/p&gt;&lt;img data-ratio=&quot;0.33172302737520126&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFMExlddOJ3WaM5BWEESfKsfpPhiczKk9KJ4wJ6XNmrKDTLd9YDJkFYQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;7452&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;制定标准：&lt;/strong&gt;这块内容其实非常重要，但大部分系统都是缺失的，笔者过往面试的同学中只有不到一成的同学能给出自己的系统 GC 标准到底什么样，其他的都是用的统一指标模板，缺少预见性，具体指标制定可以参考 3.1 中的内容，需要结合应用系统的 TP9999 时间和延迟、吞吐量等设定具体的指标，而不是被问题驱动。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;保留现场：&lt;/strong&gt;目前线上服务基本都是分布式服务，某个节点发生问题后，如果条件允许一定不要直接操作重启、回滚等动作恢复，优先通过摘掉流量的方式来恢复，这样我们可以将堆、栈、GC 日志等关键信息保留下来，不然错过了定位根因的时机，后续解决难度将大大增加。当然除了这些，应用日志、中间件日志、内核日志、各种 Metrics 指标等对问题分析也有很大帮助。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;因果分析：&lt;/strong&gt;判断 GC 异常与其他系统指标异常的因果关系，可以参考笔者在 3.2 中介绍的时序分析、概率分析、实验分析、反证分析等 4 种因果分析法，避免在排查过程中走入误区。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;根因分析：&lt;/strong&gt;确实是 GC 的问题后，可以借助上文提到的工具并通过 5 Why 根因分析法以及跟第三节中的九种常见的场景进行逐一匹配，或者直接参考下文的根因鱼骨图，找出问题发生根因，最后再选择优化手段。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.2 根因鱼骨图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;送上一张问题根因鱼骨图，一般情况下我们在处理一个 GC 问题时，只要能定位到问题的“病灶”，有的放矢，其实就相当于解决了 80%，如果在某些场景下不太好定位，大家可以借助这种根因分析图通过&lt;strong&gt;排除法&lt;/strong&gt;去定位。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6692708333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFoVoSrZIyVnyoFyle8ZugSPicZ5lnSojiaaooxIXA6DibDjiaYK8pyLDQSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.3 调优建议&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Trade Off：&lt;/strong&gt;与 CAP 注定要缺一角一样，GC 优化要在延迟（&lt;/span&gt;&lt;span&gt;Latency&lt;/span&gt;&lt;span&gt;）、吞吐量（&lt;/span&gt;&lt;span&gt;Throughput&lt;/span&gt;&lt;span&gt;）、容量（&lt;/span&gt;&lt;span&gt;Capacity&lt;/span&gt;&lt;span&gt;）三者之间进行权衡。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;最终手段：&lt;/strong&gt;GC 发生问题不是一定要对 JVM 的 GC 参数进行调优，大部分情况下是通过 GC 的情况找出一些业务问题，切记上来就对 GC 参数进行调整，当然有明确配置错误的场景除外。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;控制变量：&lt;/strong&gt;控制变量法是在蒙特卡洛（&lt;/span&gt;&lt;span&gt;Monte Carlo&lt;/span&gt;&lt;span&gt;）方法中用于减少方差的一种技术方法，我们调优的时候尽量也要使用，每次调优过程尽可能只调整一个变量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;善用搜索：&lt;/strong&gt;理论上 99.99% 的 GC 问题基本都被遇到了，我们要学会使用搜索引擎的高级技巧，重点关注 StackOverFlow、Github 上的 Issue、以及各种论坛博客，先看看其他人是怎么解决的，会让解决问题事半功倍。能看到这篇文章，你的搜索能力基本过关了~&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;调优重点：&lt;/strong&gt;总体上来讲，我们开发的过程中遇到的问题类型也基本都符合正态分布，太简单或太复杂的基本遇到的概率很低，笔者这里将中间最重要的三个场景添加了“*”标识，希望阅读完本文之后可以观察下自己负责的系统，是否存在上述问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;GC 参数：&lt;/strong&gt;如果堆、栈确实无法第一时间保留，一定要保留 GC 日志，这样我们最起码可以看到 GC Cause，有一个大概的排查方向。关于 GC 日志相关参数，最基本的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 等一些参数就不再提了，笔者建议添加以下参数，可以提高我们分析问题的效率。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.43371757925072046&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFKhoF4nxicMez1ic1UJqkaZ2YRtzqO5oZXdWHSYGpaCfRkhDn9wyenibag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1388&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6. 写在最后&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，再说笔者个人的一些小建议，遇到一些 GC 问题，如果有精力，一定要探本穷源，找出最深层次的原因。另外，在这个信息泛滥的时代，有一些被“奉为圭臬”的经验可能都是错误的，尽量养成看源码的习惯，有一句话说到“源码面前，了无秘密”，也就意味着遇到搞不懂的问题，我们可以从源码中一窥究竟，某些场景下确有奇效。但也不是只靠读源码来学习，如果硬啃源码但不理会其背后可能蕴含的理论基础，那很容易“捡芝麻丢西瓜”，“只见树木，不见森林”，让“了无秘密”变成了一句空话，我们还是要结合一些实际的业务场景去针对性地学习。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;你的时间在哪里，你的成就就会在哪里&lt;/strong&gt;。笔者也是在前两年才开始逐步地在 GC 方向上不断深入，查问题、看源码、做总结，每个 Case 形成一个小的闭环，目前初步摸到了 GC 问题处理的一些门道，同时将经验总结应用于生产环境实践，慢慢地形成一个良性循环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本篇文章主要是介绍了 CMS GC 的一些常见场景分析，另外一些，如 CodeCache 问题导致 JIT 失效、SafePoint 就绪时间长、Card Table 扫描耗时等问题不太常见就没有花太多篇幅去讲解。Java GC 是在“分代”的思想下内卷了很多年才突破到了“分区”，目前在美团也已经开始使用 G1 来替换使用了多年的 CMS，虽然在小的堆方面 G1 还略逊色于 CMS，但这是一个趋势，短时间无法升级到 ZGC，所以未来遇到的 G1 的问题可能会逐渐增多。目前已经收集到 Remember Set 粗化、Humongous 分配、Ergonomics 异常、Mixed GC 中 Evacuation Failure 等问题，除此之外也会给出 CMS 升级到 G1 的一些建议，接下来笔者将继续完成这部分文章整理，敬请期待。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“防火”永远要胜于“救火”，&lt;strong&gt;不放过任何一个异常的小指标&lt;/strong&gt;（&lt;/span&gt;&lt;span&gt;一般来说，任何&lt;strong&gt;不平滑的曲线&lt;/strong&gt;都是值得怀疑的&lt;/span&gt;&lt;span&gt;） ，就有可能避免一次故障的发生。作为 Java 程序员基本都会遇到一些 GC 的问题，独立解决 GC 问题是我们必须迈过的一道坎。开篇中也提到过 GC 作为经典的技术，非常值得我们学习，一些 GC 的学习材料，如《The Garbage Collection Handbook》、《深入理解Java虚拟机》等也是常读常新，赶紧动起来，苦练 GC 基本功吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后的最后，再多啰嗦一句，目前所有 GC 调优相关的文章，第一句讲的就是“不要过早优化”，使得很多同学对 GC 优化望而却步。在这里笔者提出不一样的观点，熵增定律（&lt;/span&gt;&lt;span&gt;在一个孤立系统里，如果没有外力做功，其总混乱度（即熵）会不断增大&lt;/span&gt;&lt;span&gt;）在计算机系统同样适用，&lt;strong&gt;如果不主动做功使熵减，系统终究会脱离你的掌控&lt;/strong&gt;，在我们对业务系统和 GC 原理掌握得足够深的时候，可以放心大胆地做优化，因为我们基本可以预测到每一个操作的结果，放手一搏吧，少年！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;7. 参考资料&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1]《&lt;/span&gt;&lt;a href=&quot;https://book.douban.com/subject/4881935/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;ガベージコレクションのアルゴリズムと実装&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》中村 成洋 / 相川 光&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2]《&lt;/span&gt;&lt;a href=&quot;https://book.douban.com/subject/6809987/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;The Garbage Collection Handbook&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》 Richard Jones/ Antony Hosking / Eliot Moss&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[3]《&lt;/span&gt;&lt;a href=&quot;https://book.douban.com/subject/34907497/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;深入理解Java虚拟机（第3版）&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》 周志明&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[4]《&lt;/span&gt;&lt;a href=&quot;https://docs.oracle.com/javase/9/gctuning/JSGCT.pdf&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[5]《&lt;/span&gt;&lt;a href=&quot;https://shipilev.net/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Shipilev One Page Blog&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》 Shipilëv&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[6] &lt;/span&gt;&lt;a href=&quot;https://openjdk.java.net/projects/jdk/15/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;https://openjdk.java.net/projects/jdk/15/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[7] &lt;/span&gt;&lt;a href=&quot;https://jcp.org/en/home/index&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;https://jcp.org/en/home/index&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[8]《&lt;/span&gt;&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.8915&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;A Generational Mostly-concurrent Garbage Collector&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》 Tony Printezis / David Detlefs&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[9]《&lt;/span&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java Memory Management White Paper&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[10]《&lt;/span&gt;&lt;a href=&quot;https://go.gale.com/ps/anonymous?id=GALE%7CA563359212&amp;amp;sid=googleScholar&amp;amp;v=2.1&amp;amp;it=r&amp;amp;linkaccess=abs&amp;amp;issn=00311723&amp;amp;p=AONE&amp;amp;sw=w&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Stuff Happens：Understanding Causation in Policy and Strategy&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》AA Hill&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;8. 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;新宇，2015 年加入美团，到店住宿门票业务开发工程师。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;湘铭，2018 年加入美团，到店客户平台开发工程师。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;祥璞，2018 年加入美团，到店客户平台开发工程师。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a60eb2676df1ca13fbba0b3b67307ab7</guid>
<title>前端如何突破技术与业务的瓶颈：Shopee 一年半记</title>
<link>https://toutiao.io/k/0cgbfwn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p/&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5c52552c10c2e16d13920a484b92ec7b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-5c52552c10c2e16d13920a484b92ec7b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-5c52552c10c2e16d13920a484b92ec7b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-5c52552c10c2e16d13920a484b92ec7b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;blockquote&gt; 作者：李成熙，Shopee金融商家前端团队负责人。2014年度毕业加入腾讯AlloyTeam，先后负责过QQ群、花样直播、腾讯文档等项目。2018年加入腾讯云云开发团队。2019年加入Shopee金融前端团队任一线前端Leader。专注于性能优化、工程化和小程序服务。未经许可不能转载&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;上次写总结文章，是来 Shopee 刚好半年后，那时刚刚适应从个人贡献者到技术架构师和管理者的身份转变，有一些感悟与心得，拿出来与大家分享。 又一年过去了，来 Shopee 已经一年半，团队从刚开始时的 4 个人，到现在 18 人，公司股价，也从当初的 20 美金，到 180 美金。很有幸，公司在进步，我也在进步。&lt;/p&gt;&lt;p&gt;今天主要想分享三个作为前端，可能经历的瓶颈，然后讲讲我为了突破这些瓶颈，所做的一些思考与努力。这三个突破，分别是&lt;/p&gt;&lt;ul&gt;&lt;li&gt;从个人贡献者到技术架构师与管理者转变的突破&lt;/li&gt;&lt;li&gt;从带领单项技术到带领多项技术的突破&lt;/li&gt;&lt;li&gt;从带技术到带业务的突破&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;瓶颈一：从个人贡献者到技术架构师与管理者转变的突破&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;其实这个可以从架构能力与管理能力两个层面讲。咱们先来讲一下架构能力。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;架构师&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;所谓架构能力，简单地说就是将不同的模块、组件、系统组装起来，联动发挥作用，解决业务或技术需求的一个过程，网上可能有更详尽的解释，大家可以自行去了解。开发者在个人贡献者阶段，更多只是接受架构师指派的任务，完成自己一个小模块的设计与代码。而在架构师的阶段，要担负起的责任与工作则更多，而且既要兼顾全局，有时也要 Review 细节的落实，有时候是又当建筑设计师，又当工地监工。&lt;/p&gt;&lt;p&gt;作为架构师，首先要对需求的把握非常清晰，一个是需求要落实的功能点，另一个是要考虑一些特性，譬如性能，未来的扩展性等等。以最近我们计划要做的一个产品的官网为例，这个官网比较核心的特性，一个是发布新闻、一些推广活动还有常见问答，另一个是可以提供这些内容的相关搜索，还有对个别商家做一些排行榜。&lt;/p&gt;&lt;p&gt;由于后台的人力不足，我们是计划由前端完成大部份的前端与后台开发工作，这里就需要由一位既懂前端，又懂后台的架构师去设计把关这里的架构（当然分开架构也可以）。这里你可能会有疑问，为什么前端的架构师，有能力在这个需求里，对前后台做架构设计呢？前端的同事是何德何能可以承担这里的前后台开发呢？这里就涉及到技术管理的梯队建设与才能储备，咱们讲管理的时候再详聊。&lt;/p&gt;&lt;p&gt;基于该&lt;b&gt;需求的特性&lt;/b&gt;，我们在做设计之前，还需要收集一下这个站点未来可能的访问量（&lt;b&gt;数据&lt;/b&gt;），这些数据对我们的技术选型非常关键！没错，我们点出了架构第一个重要的环节，&lt;b&gt;技术选型&lt;/b&gt;。据了解，该站点每天访问量，每秒的并发都不大，基本不需要上到一些应对高并发的手段。另外，由于要做内容的全文搜索，如果通过数据库的全文检索，尽管使用量不大，但随着内容越来越多（运营人员更新内容的频率还是很高的），查询性能会越来越慢。而且我们的数据库暂时跟一些核心交易数据放在同一个数据库集群里，这种耗时操作可能会加大对数据库集群的压力，因此我们可能需要用到&lt;code&gt;ElasticSearch&lt;/code&gt;帮我们做切词与搜索。而对商家数据做排行榜，这个由于涉及到核心数据，我计划是让后台的微服务出一个 &lt;code&gt;API&lt;/code&gt;，再由咱们 &lt;code&gt;Node.js&lt;/code&gt;(由于是前端来实现后台能力，基于&lt;b&gt;熟悉度&lt;/b&gt;的考量，用&lt;code&gt;Node.js&lt;/code&gt;对于前端来说，开发与维护都相当方便) 服务层去调用。&lt;/p&gt;&lt;p&gt;在技术选型的基础上，架构师平时积累的一些&lt;b&gt;经验&lt;/b&gt;、&lt;b&gt;方法论&lt;/b&gt;、&lt;b&gt;指标关注面&lt;/b&gt;，在架构设计中，也起到比较重要的作用。这里以团队做的热更新服务、配置中心、运营搭建页面这几个平台为例。刚组建团队的时候，我们亟需热更新平台来给&lt;code&gt;React Native&lt;/code&gt;提供动态更新的能力。这里当时是采用了&lt;code&gt;MySQL + Redis + Node.js + Serverless Function(做代码差分)&lt;/code&gt;的架构。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-126c4196ddbc59fb0c9841d6bb9a57a4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;571&quot; data-rawheight=&quot;565&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-126c4196ddbc59fb0c9841d6bb9a57a4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;571&quot; data-rawheight=&quot;565&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-126c4196ddbc59fb0c9841d6bb9a57a4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-126c4196ddbc59fb0c9841d6bb9a57a4_b.jpg&quot;/&gt;&lt;figcaption&gt;热更新平台的架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;有了热更新服务的经验，后面在做配置中心和运营搭建页面的时候，也从中吸取了经验，用了类似的架构做数据的存储与缓存。但随着业务的发展，我们发现为了让系统的&lt;b&gt;可用性&lt;/b&gt;更高、&lt;b&gt;性能&lt;/b&gt;更好，在一些场景里，对数据量比较大的读取，经常会将数据放到内存里（Redis 读取大数据也会有瓶颈）；另外在做差分的时候，为了保证准确性，设计了一个任务队列，保证任务不会被重复运行，也安排了一些失败重试、人工处理等的机制。在设计任务队列的时候，我们有考虑过引入 &lt;code&gt;Kafka&lt;/code&gt; 这类中间件，但实质上用&lt;code&gt;MySQL&lt;/code&gt;也能满足到诉求，那考虑到&lt;b&gt;可移植性&lt;/b&gt;，因此咱们直接就用&lt;code&gt;MySQL&lt;/code&gt;顶上。上面讲的这些例子，都是在业务发展过程中，架构的演进，并且在这种迭代的过程中，自己的架构经验与方法论也不断丰富，日后遇到类似的问题，就像砌积木那样子，搬出曾经用过、思考过、验证过的种种方案，构建成心目中的模样。你可能会说，架构师的工作难度蛮大的，时刻会遇到自己无知的领域，比如自己之前没有用过的一些中间件，在真正面临需求的时候，怎么会想得到？这里感觉并没有捷径，只有在日常工作中不断涉猎，打开自己的眼界，才能在不断变化的需求世界里更为从容。&lt;/p&gt;&lt;p&gt;小结一下，成为架构师需要做到的事情：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;根据需求特性、指标数据、团队熟悉度，做好&lt;b&gt;技术选型&lt;/b&gt;。&lt;/li&gt;&lt;li&gt;根据经验、方法论、指标数据，不断丰富与完善自己的&lt;b&gt;架构方案与套件&lt;/b&gt;&lt;/li&gt;&lt;li&gt;不断学习，没有捷径&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;管理者&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;技术管理这个话题，可能讲几天几夜也讲不完，这里我只摘取我认为最为重要与关键的一些做法与理念。在理念上，我认为要让大家&lt;b&gt;高效工作&lt;/b&gt;、&lt;b&gt;快乐工作&lt;/b&gt;，在实施上，要想尽办法给团队、给成员&lt;b&gt;赋能&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;从业界的趋势来看，许多业务、技术领域也已经走到了深水区、国际比较前沿的阶段，不是简单的拼人力、拼时间就可以将事情做对、做漂亮的，让大家抱着快乐的心情，发挥自己的创造力地去做事情，比让大家拼尽一切时间，还时不时在工位摸鱼，更能可能将事情做好。毕竟我们是将要在国际舞台上跟巨头拼刺刀的公司，在找对方向后，跟时间赛跑是没问题的，但在找对方向之前盲目地虚耗大家的精力与创造力，可能会引发一将无能，累死三军的局面。&lt;/p&gt;&lt;p&gt;&lt;b&gt;高效工作&lt;/b&gt;，可以从个人与团队两个角度进行赋能。&lt;/p&gt;&lt;p&gt;个人层面上，本质就是希望个人的能力不断提升，大家能够找到自己发展的目标，技能上做到一专多长，并且最终达成为一位自带“体系”的技术人。譬如今年我们团队来了一位 &lt;code&gt;React Native&lt;/code&gt; 的大牛，自己的曾经的创业项目也是整体用 &lt;code&gt;React Native&lt;/code&gt; 搭建 &lt;code&gt;iOS&lt;/code&gt;和 &lt;code&gt;Android&lt;/code&gt; 的 &lt;code&gt;APP&lt;/code&gt;。但 &lt;code&gt;React Native&lt;/code&gt;，有一个很重要的特性就是热更新，在他之前的项目里还没用到过，更别说自研了。来我们团队后，有契机让他参与热更新项目的研发，并且也让他多了解客户端实现这套体系的一些基本的逻辑。后续如果公司有新的业务有需要到 &lt;code&gt;React Native&lt;/code&gt;，那这位同事就可以作为自带“体系”的架构师，去帮忙搭建业务的架构，促进业务的发展。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-caf4f50d0bac97b42517d135014f0593_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1270&quot; data-rawheight=&quot;1410&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-caf4f50d0bac97b42517d135014f0593_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1270&quot; data-rawheight=&quot;1410&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-caf4f50d0bac97b42517d135014f0593_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-caf4f50d0bac97b42517d135014f0593_b.jpg&quot;/&gt;&lt;figcaption&gt;这是自带体系的一位同学，在公司做热更新平台的技术分享&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;团队层面上，做好&lt;b&gt;模块划分&lt;/b&gt;、&lt;b&gt;流程优化&lt;/b&gt;、&lt;b&gt;技术规划&lt;/b&gt;与&lt;b&gt;梯队建设&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;所谓&lt;b&gt;模块划分&lt;/b&gt;，就是大家在相对稳定的模块中工作，当你比较熟悉业务逻辑的话，工作都相对容易。当然对相似工作内容产生倦怠人皆有之，这个又是可以开另一个专题阐述了。早期我在这里也踩过一些坑，也是由于团队早期的业务比较紧，尽管同事还是会尽量做他们熟悉的模块，奈何不同的版本，不同模块的业务压力大小不尽相同，会经常抽调同事去负责全新的模块，这样其实对工作的效率与质量都是不利的，花的时间长，产生的 BUG 也多。所以后续也尽量让人员相对更加固定，即使后续某个模块非常忙，也尽量由负责该模块的同事主导业务开发的工作，支援的同事需要在良好的指引下（文档一定要完备）开展工作。&lt;/p&gt;&lt;p&gt;&lt;b&gt;流程优化&lt;/b&gt;，即使减少工作中的流程对研发人员带来的桎梏。工作流程有许多，创建新项目的流程，如Git 工作流、任务工作单管理流程等等。如何优化流程我认为主要是&lt;b&gt;识别反人性的流程，然后用工具优化之&lt;/b&gt;。这里以团队中的任务工作单流程优化为例，在 Shopee，研发团队有采用一款任务工作建单平台做研发流程的管理的，大家都会在这个建单平台上面记录工作量以及扭转状态。团队刚开始的时候人比较少，谁忙谁闲一目了然，但随着团队人员不断增加，单纯通过肉眼、心算去看看大家的忙闲程度，分配工作就变得极具挑战性了，在没有工作的帮助下，管理半径就会限制在 5 - 8 个人左右，而且为了分配工作会把自己忙死——要做大量的手动统计工作。于是为了提供管理的效率，我决定写了一个脚本，帮我通过建单平台的开放 API，将团队内成员的工作量，全部都拉下来放到 Excel 里被自动将工作量总量统计出来。这样分配工作，只需要跑一个脚本，就可以轻松统计出每个人的已经排的工作量。当然，如果能统计出甘特图是最完美的，但受限于个别数据团队没有要求填（比如工作开始时间），因此就无法画出来。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-dd71b45153cf6cde58e953bae141c16e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2312&quot; data-rawheight=&quot;542&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-dd71b45153cf6cde58e953bae141c16e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2312&quot; data-rawheight=&quot;542&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-dd71b45153cf6cde58e953bae141c16e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-dd71b45153cf6cde58e953bae141c16e_b.jpg&quot;/&gt;&lt;figcaption&gt;这位同事本周已经排满了，再排就超负荷了&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;除此以外，由于项目经理一些研发统计的需要，对每个同事建工作单的要求、填字段的数量都越来越多。将心比己，即使是我本人作为 member，都可能会疏忽未能填写完成准确。这些措施对管理上可能会更加方便，但对每个研发来说都会增加负担与困扰。于是我们也计划做一些工具与平台，一方面方便管理者做统计，另一方面也减少研发人员在一些行政、流程上的事情浪费过多的时间。&lt;/p&gt;&lt;p&gt;&lt;b&gt;技术规划&lt;/b&gt;，主要就是引领整个团队的技术方向，并努力将之落地，这个是技术管理者体现价值的非常重要的环节。因为模块划分、流程优化，有做导师带过小项目之后，都能得心应手，但技术规划，怎么顺应着业务的发展变化，提前做一些技术的储备与布局，怎么将团队的技术水平带到业界一流水平，这个是当上技术管理者之后才能得到的体会。&lt;/p&gt;&lt;p&gt;所谓的规划，不能是单点的突破，而是需要多点，并且点连成线面；不能只着重于一个个工具与平台的建设，而更要关注这些工具与平台如何有机地结合在一起，协同发挥作用，形成&lt;b&gt;体系&lt;/b&gt;。当然，也需要这些技术与时俱进，在技术的规划前路上，也逐步识别并摘除一些&lt;b&gt;技术债务&lt;/b&gt;。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-de8e36399cc01a5ee7d74a1319796610_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1984&quot; data-rawheight=&quot;1010&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-de8e36399cc01a5ee7d74a1319796610_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1984&quot; data-rawheight=&quot;1010&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-de8e36399cc01a5ee7d74a1319796610_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-de8e36399cc01a5ee7d74a1319796610_b.jpg&quot;/&gt;&lt;figcaption&gt;Shopee金融商家前端团队的体系规划&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fe4d31cb914b018cf829ae39b10797a4_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1994&quot; data-rawheight=&quot;1016&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-fe4d31cb914b018cf829ae39b10797a4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1994&quot; data-rawheight=&quot;1016&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-fe4d31cb914b018cf829ae39b10797a4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fe4d31cb914b018cf829ae39b10797a4_b.jpg&quot;/&gt;&lt;figcaption&gt;Shopee金融商家前端团队的一些体系落地的里程碑与展望&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d0812abf8f1bb7850c089177c74a8df0_b.png&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2748&quot; data-rawheight=&quot;386&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-d0812abf8f1bb7850c089177c74a8df0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2748&quot; data-rawheight=&quot;386&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-d0812abf8f1bb7850c089177c74a8df0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d0812abf8f1bb7850c089177c74a8df0_b.png&quot;/&gt;&lt;figcaption&gt;用表格记录每个业务模块的技术债务与问题，并安排清理&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;梯队建设&lt;/b&gt;也是我认为非常重要的一环。能否规划与组建你的团队，是技术管理者与架构师非常重要的区别之一。梯队建设为什么重要，那是因为良好的梯队建设，一方面能让你的团队人员更稳固，毕竟大家都有成长的诉求，无论是当技术管理还是架构师，都或多或少需要带人完成更具挑战性的项目，单打独斗能成事者寥寥无几。今年年中的时候，大批校招生准备进场。当时分析自己的团队，有 5 - 6 个高级或者准高级工程师了，这些高级的工程师工作经验都比较丰富了，但一直没有带人的机会，同时也由于业务比较繁忙，于是我就趁机会要了足够数量的毕业生，让他们带带人。我是希望通过手把手带人，可以更好地激发他们的责任心，也可以让毕业生跟着他们去做一些技术规划里的项目，让这些高级工程师也多锻炼架构与管理能力。虽然早期难免会有阵痛，比如毕业生对流程不熟悉，研发质量可能会有下降，但经过三个月的试用期后，毕业生的工作都步入正规，有充足人力的情况下，许多的技术规划落地都比较顺利。&lt;/p&gt;&lt;p&gt;其次，梯队建设的好坏，能决定你之前的技术规划能否顺利落地。除了前面提到的不同职级与经验的人的比例要均衡，还需要在各个技术方向有技术储备，最好是有技术领头人，甚至能有技术小组，毕竟孤身一人去探索某个技术方案还是挺孤独寂寞的，也没有人一起做技术讨论。另外有这样的一个技术小组，也可以有备份人。在团队中，因应着定下的技术规划，基本上每个体系的建设都会成立一个技术小组，这些人可能在公司组织上并不是同一个组，但只要他们对这块感兴趣，或者在这块有建树，就可以参与到这块的建设中。比如在 Web 体系建设小组里面，有三位同事，这块需要负责的项目比较多，包括 Web 发布的自动化、精细化，Web 组件建设，Figma 组件生成自动化，同构渲染研究等都归属到这里，每个人都有自己主攻的方向，但每一个时期侧重点可能有不同，有可能会有有几个人共同参与到某一个项目的建设当中，快速将该项目先做成。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9a316627c73efed10b89ee697e8379ef_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1302&quot; data-rawheight=&quot;982&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-9a316627c73efed10b89ee697e8379ef_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1302&quot; data-rawheight=&quot;982&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-9a316627c73efed10b89ee697e8379ef_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9a316627c73efed10b89ee697e8379ef_b.jpg&quot;/&gt;&lt;figcaption&gt;我在跟Web体系建的同事讨论技术方案&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;高效工作&lt;/b&gt; 如果落实得好，&lt;b&gt;快乐工作&lt;/b&gt;其实也就达成一半以上了，因为高效工作可以让工作效率提高，加班减少，也能让大家有成长的快感，再加之以打造良好的技术氛围（技术分享、外出参与技术会议、内部开放的技术讨论），相信员工的工作满意度会相对较高。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6b4593fdd50bf02352add4f8732a373f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1915&quot; data-rawheight=&quot;1079&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-6b4593fdd50bf02352add4f8732a373f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1915&quot; data-rawheight=&quot;1079&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-6b4593fdd50bf02352add4f8732a373f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-6b4593fdd50bf02352add4f8732a373f_b.jpg&quot;/&gt;&lt;figcaption&gt;从Facebook回国的前端大神，给我们徒手白板讲解端到端加密&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;小结一下，成为好的管理者，需要通过&lt;b&gt;赋能&lt;/b&gt;做到：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;高效工作&lt;br/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;模块划分，让职责明确，业务熟练&lt;/li&gt;&lt;li&gt;流程优化，减少行政工作，提高代码时间&lt;/li&gt;&lt;li&gt;技术规划，指明方向，甩掉债务，提升个人技能与团队效益&lt;/li&gt;&lt;li&gt;梯队建设，储备技术与落地规划&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;快乐工作&lt;br/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;瓶颈二：从带领单项技术到带领多项技术的突破&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;随着职级的提升，要跟跨团队的技术合作、甚至带跨技术的项目、同时带其它的技术组的情况会越来越多。如果倒推几年，前端要进入后台、客户端的领域，难度还是比较大的，这个是整个业界都存在的问题。但随着一些重要的技术的诞生与成熟，比如 Node.js，React Native, Electron 进入前端人的视野，前端有更多的机会可以参与到这些。所以从大局上、宏观上讲，我们要多支持这些技术的成长，无论是给这些开源项目贡献源码、布道、贡献最佳实践，最终都能让我们自己受益。所以我在团队里也比较鼓励大家贡献开源项目，或者通过造开源项目的周边小轮子练练手。&lt;/p&gt;&lt;p&gt;但从自己团队的业务与技术发展，这个微观的层面来看更着重看的是自己团队在某块跨领域技术的知识储备、人才储备与项目历练。举个例子，如果前端要能够承接个别的中后台业务，必需要团队里面的 Node.js 基建设施比较完善，并且要有相关的人才能够 Hold 得住，否则哪里报了 Node.js 的错误，哪里产生的性能瓶颈，哪里出现疑难杂症，没有人有思路解决，这就很可能会阻塞到业务的进展。&lt;/p&gt;&lt;p&gt;我个人的建议是，首先要让基建设施完备，譬如将 Node.js 部署到 K8S 的设施搭建起来，包括进程管理器、上报埋点的工具库、Node.js 的基础 Docker 镜像等等。基建完备后，我们先用一些技术项目练手，尤其是在许多跟客户端一起合作的项目里，由于有前端能写 Node.js 的缘故，一些大前端的公共平台，比如热更新发布平台、配置中心等的一些项目，都可以由前端来做主要推手，通过这些项目来积累一些高并发、高可用的后台开发与运维经验，从而获取后台开发的经验。如果不想如此的激进，也可以从一些偏管理后台的项目开始，这些老板们是比较放心让 Node.js 来实现的。当拥有了基础的 Node.js 开发与运维经验后，可以开始在业务中做一些尝试，尤其是那些中台的接口转发项目、或者是同构渲染提升性能的项目。只有跨越出来，能做一些用户侧业务的 Node.js 服务，这样才能更进一步通过解决用户侧的服务挑战来提升团队的实力。我们当时是选择了一个非常适合前端 Node.js 来实现的服务，就是用户购买商品后的订单详情页。这个页面，产品要求的动态化非常高，不同产品的字段不尽相同，而且可能时不时调整顺序或者添加字段。而且后台提供的定的接口，又不太好表现一些字段的分类、字段的排序、字段展示的格式等。于是我们就提出，用 Node.js 做一个中间服务，将这些商品的详情字段全部做成可配置化，并在 React Native 侧做了一个基础的展示引擎，基于后台返回的字段动态渲染。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-80d419670b7fee43a1ed3af78b66f720_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;774&quot; data-rawheight=&quot;1524&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-80d419670b7fee43a1ed3af78b66f720_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;774&quot; data-rawheight=&quot;1524&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-80d419670b7fee43a1ed3af78b66f720_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-80d419670b7fee43a1ed3af78b66f720_b.jpg&quot;/&gt;&lt;figcaption&gt;不同商品的字段的交易详情页字段不尽相同&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a95079e9976d67c0b5d1a7a12006ecfe_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1332&quot; data-rawheight=&quot;1070&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-a95079e9976d67c0b5d1a7a12006ecfe_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1332&quot; data-rawheight=&quot;1070&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-a95079e9976d67c0b5d1a7a12006ecfe_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-a95079e9976d67c0b5d1a7a12006ecfe_b.jpg&quot;/&gt;&lt;figcaption&gt;将交易详情字段全数在Node.js服务中实现可配置化&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;有了不少的技术项目还有这次业务项目的实践成功，大大增强了前端的信心，等到后续后台由于人力原因无法投入太多精力到产品官网的开发，前端就顺其自然地接受了这个挑战，会去做全站的前后台开发任务，在业务中更深层次地使用 Node.js。&lt;/p&gt;&lt;p&gt;做一下小结，想突破目前单一技术的管理，如果以中后台为例的话，可以尝试走以下的步骤：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;搭好基础设施，以小项目练手&lt;/li&gt;&lt;li&gt;在大前端中主导一些相关的后台项目建设，赢得高可用、高性能的经验&lt;/li&gt;&lt;li&gt;切入中台业务，尝试后台服务的中间层&lt;/li&gt;&lt;li&gt;往“后”拓展，可尝试非核心业务的全栈落地&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;瓶颈三：从带技术到带业务的突破&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;前端，乃至大部份的研发，被作为工具人，长久只是需求的实现机器，能真正突破从做技术到带业务的人少之又少。这个突破有两个层次，一个是成为这个业务模块的整体技术负责人，另一个层次是直接成为这个业务的总负责人。遗憾的是，本人都未能达到这些层次，目前只是粗略地谈一下我自己做的一些尝试，而且主要是第一个层次的尝试。&lt;/p&gt;&lt;p&gt;一个研发是不是关注业务，其实只要你问一下他，是否知道这个产品面向的用户，用户规模、活跃用户有多少，GMV 有多少等等的一些关键业务数据，如果他能答出一些，而不是完全不知道，那证明这位研发还是比较关心业务的。有这样良好的关心业务数据的习惯，相信更进一步，让这位研发不仅只了解自己模块的业务逻辑，可以将后台、客户端跟某个模块相关的业务逻辑都了解一遍还是比较容易的。并且老板、产品、测试人员来问的时候，都能比较清楚地做出解释，那这位研发熟悉业务的名声就已经远播了。&lt;/p&gt;&lt;p&gt;但是，有的时候尽管你可能对这些业务有所了解，但由于在前端这个岗位上，天然可能就比后台有一定的劣势——毕竟业务的最主要的流程是在后台实施的。这些对于金融、电商的行业尤其如此，可能相比之下，社交、内容、工具等平台，前端的话语权可能反倒更大一些。加上如果你做了大量的技术项目，尽管你对业务其实也了解，也可能会给别人留下过于关注技术，而忽略业务的印象——毕竟每次项目会上，需要解决的后台的问题，比前端和客户端高出一大截，我们也不太好去插话。因此，在重视技术建设的同时，也可以多对业务的流程提出一些优化，比如后续我就吸取一些经验教训，希望在一些商品上新的流程上做一些简化，减少每次上新投入的人力，使整个项目组的人力规划可以向其它更重要的事情上倾斜。&lt;/p&gt;&lt;p&gt;此外，我们也可以尝试针对业务当下或者未来的诉求做一些产品的孵化。比如作为金融电商平台，比较容易想到的就是一些常规运营页面的搭建工具，毕竟前端在产品做用户增长这块，还是可以发挥比较大的作用。于是断断续续，我们团队就搭建了一个可以跨多个 APP 运行的运营页面搭建工具。在做这些项目的孵化过程中，并不是一帆风顺的，比方说这些产品要从策略、设计到落地都需要团队的人从头做起，推动运营人员的使用也并非一帆风顺，也成就也有挫败。但经过这些历练之后，让自己对业务、产品的把握也会有另一番的见解。虽然目前的这些努力未有很明显的成效，但团队人员在产品设计、打磨、落地方面的能力得到了储备，正所谓养兵千日，用在一时，相信未来可能将会有这些产品、人员发挥的地方。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a52b61953fa7806b5ec8ea955687806d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3340&quot; data-rawheight=&quot;1684&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-a52b61953fa7806b5ec8ea955687806d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3340&quot; data-rawheight=&quot;1684&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-a52b61953fa7806b5ec8ea955687806d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a52b61953fa7806b5ec8ea955687806d_b.jpg&quot;/&gt;&lt;figcaption&gt;可拖拽式运营页面搭建工具&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;小结一下，从带技术到带业务的一些努力：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;关注业务，从关注业务的数据、逻辑开始，并且多端的逻辑都需要熟悉&lt;/li&gt;&lt;li&gt;技术项目与业务项目都要两手抓，并且需要有自己团队主推落地的一些核心业务需求与优化&lt;/li&gt;&lt;li&gt;尝试孵化与业务相关或者与公司发展战略一致的产品&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;来 Shopee 一年半，变化翻天覆地，从来不敢想象自己会有机会去突破这些职业的界限，或者摸到这些职业界限的天花板。希望这些粗浅的经验能够对后来都有些启发，也希望一些同行、前辈可以多多指点，不吝赐教。同时感谢我团队的同事与老板，这一年多以来对我不遗余力的支持！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bba8739af7a9b1ae96f5e2c1a79506cb</guid>
<title>刨根问底，Kafka 消息中间件到底会不会丢消息</title>
<link>https://toutiao.io/k/17q9ijl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为避免上面类似情况的发生，除了做好补偿措施，更应该在系设计的时候充分考虑各种异常，设计一个稳定、高可用的消息系统。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;认识Kafka&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下维基百科的定义&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Kafka是分布式发布-订阅消息系统。它最初由LinkedIn公司开发，之后成为Apache项目的一部分。&lt;/p&gt;&lt;p&gt;Kafka是一个分布式的，可划分的，冗余备份的持久性的日志服务。它主要用于处理活跃的流式数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;kafka架构&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka的整体架构非常简单，是显式分布式架构，主要由producer、broker（kafka）和consumer组成。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41169590643274856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7CcicjWevmX0FVRXZwexWyd4xPeEyiaSpXCVlqvyOhTF2lrCZmvTQd6DVicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;figcaption&gt;Kafka架构（精简版）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Producer&lt;/strong&gt;（生产者）可以将数据发布到所选择的topic（主题）中。生产者负责将记录分配到topic的哪一个 partition（分区）中。可以使用循环的方式来简单地实现负载均衡，也可以根据某些语义分区函数(如记录中的key)来完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Consumer&lt;/strong&gt;（消费者）使用一个consumer group（消费组）名称来进行标识，发布到topic中的每条记录被分配给订阅消费组中的一个消费者实例。消费者实例可以分布在多个进程中或者多个机器上。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kafka到底会不会丢失消息？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在讨论kafka是否丢消息前先来了解一下什么是&lt;strong&gt;消息传递语义&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.311614730878187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7Cc4Rr3ibFmXY650cR6zyfKKSP5ey95z4cVvj8CkABrB3Ua4SdTOzDhJbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1412&quot;/&gt;&lt;figcaption&gt;消息传递语义&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;message delivery semantic 也就是消息传递语义，简单说就是消息传递过程中消息传递的保证性。主要分为三种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;at most once&lt;/strong&gt;：最多一次。消息可能丢失也可能被处理，但最多只会被处理一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;at least once&lt;/strong&gt;：至少一次。消息不会丢失，但可能被处理多次。可能重复，不会丢失。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;exactly once&lt;/strong&gt;：精确传递一次。消息被处理且只会被处理一次。不丢失不重复就一次。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想情况下肯定是希望系统的消息传递是严格exactly once，也就是保证不丢失、只会被处理一次，但是很难做到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到主角Kafka，Kafka有三次消息传递的过程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产者发消息给Kafka Broker。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kafka Broker 消息同步和持久化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kafka Broker 将消息传递给消费者。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这三步中每一步都有可能会丢失消息，下面详细分析为什么会丢消息，如何最大限度避免丢失消息。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;生产者丢失消息&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先介绍一下生产者发送消息的一般流程（部分流程与具体配置项强相关，这里先忽略）：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产者是与leader直接交互，所以先从集群获取topic对应分区的leader元数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取到leader分区元数据后直接将消息发给过去；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kafka Broker对应的leader分区收到消息后写入文件持久化；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Follower拉取Leader消息与Leader的数据保持一致；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Follower消息拉取完毕需要给Leader回复ACK确认消息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kafka Leader和Follower分区同步完，Leader分区会给生产者回复ACK确认消息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3728813559322034&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7CceLDlQ1mY0LcoiakHWrS2icgKncMSb465JlMMDS2sYWJFf7HbNjBGnWfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1534&quot;/&gt;&lt;figcaption&gt;生产者发送数据流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘。消息写入Leader后，Follower是主动与Leader进行同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka消息发送有两种方式：同步（sync）和异步（async），默认是同步方式，可通过producer.type属性进行配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka通过配置request.required.acks属性来确认消息的生产：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;0表示不进行消息接收是否成功的确认；不能保证消息是否发送成功，生成环境基本不会用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;1表示当Leader接收成功时确认；只要Leader存活就可以保证不丢失，保证了吞吐量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-1或者all表示Leader和Follower都接收成功时确认；可以最大限度保证消息不丢失，但是吞吐量低。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka producer 的参数acks 的默认值为1，所以默认的producer级别是at least once，并不能exactly once。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;敲黑板了，这里可能会丢消息的！&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果acks配置为0，发生网络抖动消息丢了，生产者不校验ACK自然就不知道丢了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果acks配置为1保证leader不丢，但是如果leader挂了，恰好选了一个没有ACK的follower，那也丢了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;all：保证leader和follower不丢，但是如果网络拥塞，没有收到ACK，会有重复发的问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kafka Broker丢失消息&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka Broker 接收到数据后会将数据进行持久化存储，你以为是下面这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5754189944134078&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7Cc3R8l6vVib3crFZ6tY36BAx45VEdHwQmoB7MicQLPqw9A8gaia40Zt0xXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1074&quot;/&gt;&lt;figcaption&gt;消息持久化，无cache&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没想到是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7117750439367311&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7CcLTpX0ctRRzTX5eVWeh89ic9Vgx2DwQJLcIiafe4vZ9C2JPUKGgWNLMQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1138&quot;/&gt;&lt;figcaption&gt;消息持久化，有cache&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统本身有一层缓存，叫做 Page Cache，当往磁盘文件写入的时候，系统会先将数据流写入缓存中，至于什么时候将缓存的数据写入文件中是由操作系统自行决定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka提供了一个参数 producer.type 来控制是不是主动flush，如果Kafka写入到mmap之后就立即 flush 然后再返回 Producer 叫同步 (sync)；写入mmap之后立即返回 Producer 不调用 flush 叫异步 (async)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;敲黑板了，这里可能会丢消息的！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka通过多分区多副本机制中已经能最大限度保证数据不会丢失，如果数据已经写入系统 cache 中但是还没来得及刷入磁盘，此时突然机器宕机或者掉电那就丢了，当然这种情况很极端。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;消费者丢失消息&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者通过pull模式主动的去 kafka 集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是找leader分区去拉取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多个消费者可以组成一个消费者组（consumer group），每个消费者组都有一个组id。同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会出现多个消费者消费同一分区的数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4226950354609929&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7Ccd3ZE38bwHmgdr7Ih3xqFrpjuC5THTZWgZiaB0picutRgLNb3v0LO6vNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1410&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;消费者群组消费消息&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者消费的进度通过offset保存在kafka集群的__consumer_offsets这个topic中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费消息的时候主要分为两个阶段：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、标识消息已被消费，commit offset坐标；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、处理消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;敲黑板了，这里可能会丢消息的！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景一：先commit再处理消息。如果在处理消息的时候异常了，但是offset 已经提交了，这条消息对于该消费者来说就是丢失了，再也不会消费到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景二：先处理消息再commit。如果在commit之前发生异常，下次还会消费到该消息，重复消费的问题可以通过业务保证消息幂等性来解决。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，kafka到底会不会丢消息？答案是：会！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka可能会在三个阶段丢失消息：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）生产者发送数据；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）Kafka Broker 存储数据；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）消费者消费数据；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在生产环境中严格做到exactly once其实是难的，同时也会牺牲效率和吞吐量，最佳实践是业务侧做好补偿机制，万一出现消息丢失可以兜底。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>