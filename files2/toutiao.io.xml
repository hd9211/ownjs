<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a7afa944065c2fb07e0467b359684e63</guid>
<title>2022，值得学习系列之：函数式编程</title>
<link>https://toutiao.io/k/8bwye9l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;pos-relative js-post-content&quot;&gt;
              
              &lt;p&gt;在诞生近 70 年之后， 函数式编程（Functional Programming）开始获得越来越多的关注。并且随着时间推移、技术演变，它与前端开发，结合的也越发紧密；前些日子，读了些文章，对函数式编程有了粗浅的了解，并在代码上做了些实践，发现这种思想非常有趣，喜之不已。近日我女神对它突感好奇，于是乎，便结合业界已有之分享，结合自己理解与实践，梳理成文，以便解释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lovejade.oss-cn-shenzhen.aliyuncs.com/Function.png&quot; alt=&quot;函数式编程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%8E%E9%9D%9E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB&quot;&gt;与非函数式的区别&lt;/h2&gt;
&lt;p&gt;非函数式的示例代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;let counter = 0
const increment = () =&amp;gt; {
    counter++
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const increment = (counter) =&amp;gt; {
    return counter + 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你可能会觉得这个例子太过普通。但，这就是函数式编程的准则：&lt;strong&gt;不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;再看一段复杂一点，却较为 &lt;a href=&quot;https://github.com/nicejade/blog.nicelinks.site/blob/master/src/components/search/index.js&quot;&gt;实用的代码示例&lt;/a&gt; ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const handleSearch = (_keywords) =&amp;gt; {
  let queryResultArr;
  if (!_keywords) {
    queryResultArr = []
  } else {
    queryResultArr = getQueryResult(_keywords)
  }
  setQueryResultArr(queryResultArr)
  setIsShowResults(queryResultArr.length &amp;gt; 0)
}

const throttle = (fn, wait) =&amp;gt; {
  let pre = Date.now();
  return function () {
    const context = this;
    const args = arguments;
    const now = Date.now();
    if (now - pre &amp;gt;= wait) {
      fn.apply(context, args)
      pre = Date.now()
    }
  }
}

const requestSearchFunc = throttle(handleSearch, 200)

const handleInputChange = (event) =&amp;gt; {
  const value = event.target.value;
  setKeywords(value)
  requestSearchFunc(value)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用 &lt;code&gt;throttle&lt;/code&gt; 来&lt;strong&gt;节流函数&lt;/strong&gt;，如：requestSearchFunc；这个技术其实就是 Currying 技术（把一个函数的多个参数分解成多个函数， 然后把函数多层封装起来，每层函数都返回一个函数去接收下一个参数这样，可以简化函数的多个参数）。从这个技术上，你可能体会到函数式编程的理念：&lt;strong&gt;把函数当成变量来用，关注于描述问题而不是怎么实现&lt;/strong&gt;，这样可以让代码更易读。&lt;/p&gt;
&lt;h2 id=&quot;%E8%BF%87%E7%A8%8B%E5%BC%8F-vs-%E5%87%BD%E6%95%B0%E5%BC%8F&quot;&gt;过程式 vs 函数式&lt;/h2&gt;
&lt;p&gt;过程式编程，主要要采取过程调用，或函数调用的方式来进行流程控制；它主要关注：一步一步地解决问题。这是完全有效的编码方式，但当您希望应用程序扩展时，它存在许多缺点。而函数式编程（ Functional Programming）关注的是：&lt;strong&gt;描述要做什么，而不是如何做&lt;/strong&gt;（describe what to do, rather than how to do it）。&lt;/p&gt;
&lt;p&gt;举例来说，对于一个英文名数组，需要将其中短横线命名，转化为大驼峰格式。基于传统过程式编程，可能你不会想太多，直接将想法用代码来表达出来，临时变量、循环语句，用的飞起：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const nameArr = [&#x27;nice-jade&#x27;, &#x27;rayso-lee&#x27;, &#x27;jon-snow&#x27;, &#x27;arya-stark&#x27;];
const newArr = [];
for (let i = 0, len = nameArr.length; i &amp;lt; len ; i++) {
  let name = nameArr[i];
  let tempNameArr = name.split(&#x27;-&#x27;);
  let newNameArr = [];
  for (let j = 0, nameLen = tempNameArr.length; j &amp;lt; nameLen; j++) {
    let newFormatName = tempNameArr[j][0].toUpperCase() + tempNameArr[j].slice(1);
    newNameArr.push(newFormatName);
  }
  newArr.push(newNameArr.join(&#x27; &#x27;));
}
console.log(newArr)
// [ &#x27;Nice Jade&#x27;, &#x27;Rayso Lee&#x27;, &#x27;Jon Snow&#x27;, &#x27;Arya Stark&#x27; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是可以达成目标的答案，它完全&lt;strong&gt;面向过程&lt;/strong&gt;；虽然在编码时候，能够将想法淋漓尽致表现出来。但对于阅读的人，十分不够友好。因为这中间夹杂了复杂的逻辑，充斥了大量临时变量、循环、状态变化等等；通常您需要：&lt;strong&gt;从头读到尾才知道它具体做了什么&lt;/strong&gt;，而且一旦出问题，很难定位。当然，你也可以将如上代码，拆分成几个函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const nameArr = [&#x27;nice-jade&#x27;, &#x27;rayso-lee&#x27;, &#x27;jon-snow&#x27;, &#x27;arya-stark&#x27;]
const capitalize = (str) =&amp;gt; str[0].toUpperCase() + str.slice(1).toLowerCase()

const convertName = (name) =&amp;gt; {
  let tempNameArr = name.split(&#x27;-&#x27;)
  let newNameArr = []
  for (let j = 0, nameLen = tempNameArr.length; j &amp;lt; nameLen; j++) {
    let newFormatName = capitalize(tempNameArr[j])
    newNameArr.push(newFormatName)
  }
  return newNameArr.join(&#x27; &#x27;)
}

const getNewArr = (nameArr) =&amp;gt; {
    const newArr = []
    for (let i = 0, len = nameArr.length; i &amp;lt; len; i++) {
      let name = nameArr[i]
      const newName = convertName(name)
      newArr.push(newName)
    }
    return newArr
}

const newNameArr = getNewArr(nameArr)
console.log(newNameArr)
// [ &#x27;Nice Jade&#x27;, &#x27;Rayso Lee&#x27;, &#x27;Jon Snow&#x27;, &#x27;Arya Stark&#x27; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如此一来，阅读代码时，需要考虑的上下文少了许多，也就更容易。不像第一个示例，如果没有合理的注释说明，你还需要花些时间来理解。&lt;strong&gt;而把代码逻辑封装成了函数后，就相当于：给每个相对独立的程序逻辑取了个名字，于是代码成了自解释的&lt;/strong&gt;。幸好，在这份代码中，函数间调用，没有&lt;strong&gt;依赖共享的变量&lt;/strong&gt;，否则将会更加复杂。但，仍是充斥了临时变量、循环，增加代码量的同时，也加大了理解之难度。&lt;/p&gt;
&lt;p&gt;如果基于&lt;strong&gt;函数式编程&lt;/strong&gt;思想，那会是怎样的代码呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const { compose, map, join, split } = require(&#x27;ramda&#x27;)

const nameArr = [&#x27;nice-jade&#x27;, &#x27;rayso-lee&#x27;, &#x27;jon-snow&#x27;, &#x27;arya-stark&#x27;]
const capitalize = (str) =&amp;gt; str[0].toUpperCase() + str.slice(1).toLowerCase()
const convertName = compose(join(&#x27; &#x27;), map(capitalize), split(&#x27;-&#x27;))
const newNameArr = nameArr.map((item) =&amp;gt; convertName(item))

console.log(newNameArr)
// [ &#x27;Nice Jade&#x27;, &#x27;Rayso Lee&#x27;, &#x27;Jon Snow&#x27;, &#x27;Arya Stark&#x27; ]&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上代码（有借助 &lt;a href=&quot;https://github.com/ramda/ramda&quot;&gt;ramda&lt;/a&gt; ——「实用的函数式 JavaScript 工具库」来实现），虽依然把程序的逻辑分成了函数，不过这些函数都是 Functional 的。因为它们有三个症状：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它们之间没有共享的变量。&lt;/li&gt;
&lt;li&gt;函数间通过参数和返回值来传递数据。&lt;/li&gt;
&lt;li&gt;在函数里没有临时变量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从这个编程思路，可以清晰看出，&lt;strong&gt;函数式编程&lt;/strong&gt;的思维过程是完全不同的，它的着眼点是&lt;strong&gt;函数&lt;/strong&gt;，而不是&lt;strong&gt;过程&lt;/strong&gt;，它强调的是：通过函数的组合、变换去解决问题，而不是通过写什么样的语句去解决问题；当你的代码越来越多的时候，这种函数的拆分和组合，就会产生出更加强大的力量。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9F&quot;&gt;什么函数式编程？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B&quot;&gt;&lt;strong&gt;函数式编程&lt;/strong&gt;&lt;/a&gt; ，或称函数程序设计、泛函编程（英语：Functional Programming），是一种编程范式，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。比起指令式编程，函数式编程更加强调程序执行的结果，而非执行的过程；倡导利用若干简单的执行单元，让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。&lt;/p&gt;
&lt;p&gt;在函数式编程中，函数是头等对象，意思是说一个函数，既可以作为其它函数的输入参数值，也可以从函数中返回值，被修改或者被分配给一个变量。&lt;/p&gt;
&lt;p&gt;诞生 50 多年之后，函数式编程，开始获得越来越多的关注。不仅最古老的函数式语言 Lisp 重获青春，而且新的函数式语言层出不穷，比如 Erlang、clojure、Scala、F#等等。目前最当红的 Python、Ruby、Javascript，对函数式编程的支持都很强，就连老牌的面向对象的 Java、面向过程的 PHP，都忙不迭地加入对匿名函数的支持。越来越多的迹象表明，函数式编程已经不再是学术界的最爱，开始大踏步地在业界投入实用。&lt;/p&gt;
&lt;p&gt;也许继&quot;面向对象编程&quot;之后，&quot;函数式编程&quot;会成为下一个编程的主流范式（paradigm）。未来的程序员恐怕或多或少都必须懂一点。—— &lt;a href=&quot;https://www.ruanyifeng.com/blog/2012/04/functional_programming.html&quot;&gt;函数式编程初探 @阮一峰&lt;/a&gt; （2012 年）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数，即是一种描述集合和集合之间的&lt;strong&gt;转换关系&lt;/strong&gt;，输入通过函数，都会返回&lt;strong&gt;有且只有一个&lt;/strong&gt;输出值。&lt;strong&gt;函数&lt;/strong&gt;实际上是一个&lt;strong&gt;关系&lt;/strong&gt;，或者说成一种映射，而这种映射关系是可 &lt;code&gt;组合&lt;/code&gt; 的，当知道一个函数的输出类型，可以匹配另一个函数的输入，那他们就可以进行组合。如上述代码中提及的 &lt;code&gt;convertName&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;在编程世界中，需要处理的逻辑，其实只有“数据”和“关系”，而关系就是 &lt;code&gt;函数&lt;/code&gt;。一旦映射关系（函数）找到了，问题即能迎刃而解；剩下的事情，就是让数据通过这种关系，然后转换成另一个数据而已。&lt;/p&gt;
&lt;h2 id=&quot;%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9&quot;&gt;函数式编程的特点&lt;/h2&gt;
&lt;h3 id=&quot;%E5%87%BD%E6%95%B0%E6%98%AF%E7%AC%AC%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91&quot;&gt;&lt;strong&gt;函数是&quot;第一等公民&quot;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;所谓 &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&quot;第一等公民&quot;&lt;/a&gt; （First Class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。如上文中代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const convertName = compose(join(&#x27; &#x27;), map(capitalize), split(&#x27;-&#x27;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;%E6%97%A0%E7%8A%B6%E6%80%81%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E5%8F%98&quot;&gt;无状态和数据不可变&lt;/h3&gt;
&lt;p&gt;无状态（Statelessness）和数据不可变（Immutable data），这是函数式编程的核心概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据不可变&lt;/strong&gt;：它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无状态&lt;/strong&gt;：主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了实现这个目标，函数式编程提出函数应该具备的特性：没有副作用和纯函数。&lt;/p&gt;
&lt;h3 id=&quot;%E6%B2%A1%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8&quot;&gt;没有&quot;副作用&quot;&lt;/h3&gt;
&lt;p&gt;所谓&quot;副作用&quot;（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。&lt;/p&gt;
&lt;p&gt;函数式编程强调没有&quot;副作用&quot;，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。&lt;/p&gt;
&lt;h3 id=&quot;%E5%BC%95%E7%94%A8%E9%80%8F%E6%98%8E&quot;&gt;&lt;strong&gt;引用透明&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或&quot;状态&quot;，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。&lt;/p&gt;
&lt;p&gt;有了前面的第三点和第四点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫&quot;引用不透明&quot;，很不利于观察和理解程序的行为。&lt;/p&gt;
&lt;h3 id=&quot;%E6%83%B0%E6%80%A7%E6%89%A7%E8%A1%8C&quot;&gt;惰性执行&lt;/h3&gt;
&lt;p&gt;所谓惰性执行（Lazy Evaluation），指的是函数只在需要的时候执行，即：不产生无意义的中间变量。像上面👆的例子，函数式编程跟命令式编程最大的区别就在于：几乎没有中间变量，它从头到尾都在写函数，只有在最后的时候才通过调用  &lt;code&gt;convertName&lt;/code&gt;  产生实际的结果。&lt;/p&gt;
&lt;h3 id=&quot;%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96&quot;&gt;尾递归优化&lt;/h3&gt;
&lt;p&gt;迭代在函数式语言中常用&lt;strong&gt;递归&lt;/strong&gt;来完成，用递归来实现控制流程的机制，是函数式编程的一个非常重要的特点。我想您当然知道 &lt;code&gt;递归&lt;/code&gt; 的害处，那就是如果递归很深的话，stack 受不了，并会导致性能大幅度下降。所以，我们使用尾递归优化技术——每次递归时都会重用 stack，这样一来能够提升性能。尾递归的实现，其实是基于编译器的识别和优化的，编译器发现一个函数是尾递归，就会把它实现为与命令式编程中的迭代差不多的汇编码。&lt;/p&gt;
&lt;h3 id=&quot;%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF&quot;&gt;函数式编程相关技术&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;map &amp;amp; reduce&lt;/strong&gt; ：这个技术不用多说了，函数式编程最常见的技术，就是对一个集合做 Map 和 Reduce 操作。这比起过程式的语言来说，在代码上要更容易阅读。（传统过程式的语言需要使用 for/while 循环，然后在各种变量中把数据倒过来倒过去的）这个很像 C++中的 STL 中的 foreach，find_if，count_if 之流的函数的玩法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pipeline&lt;/strong&gt;：这个技术的意思是，把函数实例成一个一个的 action，然后，把一组 action 放到一个数组或是列表中，然后把数据传给这个 action list，数据就像一个 pipeline 一样顺序地被各个函数所操作，最终得到我们想要的结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;compose&lt;/strong&gt;：它可以接收多个独立的函数作为参数，然后将这些函数进行组合串联，最终返回一个“组合函数”。&lt;code&gt;pipe&lt;/code&gt; 与 &lt;code&gt;compose&lt;/code&gt; 的共同点是：都返回“组合函数”，区别则是执行的顺序不同，前者是从左向右执行，后者则是从右向左执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;recursing 递归&lt;/strong&gt; ：递归最大的好处就简化代码，他可以把一个复杂的问题用很简单的代码描述出来。注意：递归的精髓是描述问题，而这正是函数式编程的精髓。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;currying&lt;/strong&gt;：把一个函数的多个参数分解成多个函数， 然后把函数多层封装起来，每层函数都返回一个函数去接收下一个参数这样，可以简化函数的多个参数。在 C++中，这个很像 STL 中的 bind_1st 或是 bind2nd。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;higher order function 高阶函数&lt;/strong&gt;：所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。现象上就是函数传进传出，就像面向对象对象满天飞一样。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%84%8F%E4%B9%89&quot;&gt;函数式编程的意义&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代码简洁，开发快速&lt;/strong&gt;：大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接近自然语言，易于理解&lt;/strong&gt;：函数式编程的自由度很高，可以写出很接近自然语言的代码；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更方便的代码管理&lt;/strong&gt;：不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更少的出错概率&lt;/strong&gt;：因为每个函数都很小，而且相同输入，永远可以得到相同的输出，测试也很简单；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;易于&quot;并发编程&quot;&lt;/strong&gt;：因为它不修改变量，所以根本不存在&quot;锁&quot;线程的问题；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代码的热升级&lt;/strong&gt;：基于没有副作用特点，只要保证接口不变，内部实现是外部无关的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%8C%E7%BB%93%E8%AF%AD&quot;&gt;函数式编程，结语&lt;/h2&gt;
&lt;p&gt;正如您在函数式编程中看到的，它希望使用小的（理想情况下是&lt;strong&gt;纯函数&lt;/strong&gt;）函数来解决问题。这种方法也非常具有可 &lt;code&gt;扩展性&lt;/code&gt;，并且函数可以 &lt;code&gt;重用&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;没有更好和更坏的范式。有经验的开发人员，可以看到每种范式的优点，并为给定的问题选择相对更合适的。过程式编程，并不是说你不能使用函数；函数式编程也不会阻止你使用“类”。这些范式，只是以一种随代码增长而有益的方式，来帮助解决问题。&lt;/p&gt;
&lt;p&gt;原文首发于：&lt;a href=&quot;https://forum.lovejade.cn/d/182&quot;&gt;浅谈关于「函数式编程」的理解 ｜ 宜想悠然亭&lt;/a&gt;，@2022 年 05 月 30 日。&lt;/p&gt;
&lt;h2 id=&quot;%E6%89%80%E5%8F%82%E8%80%83%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0&quot;&gt;所参考系列文章&lt;/h2&gt;

&lt;h2 id=&quot;%E7%8C%9C%E6%82%A8%E5%8F%AF%E8%83%BD%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0&quot;&gt;猜您可能感兴趣的文章&lt;/h2&gt;


                &lt;section class=&quot;m-tags in-post&quot;&gt;
                  &lt;h3 class=&quot;m-submenu-title&quot;&gt;Tags&lt;/h3&gt;
                  
                &lt;/section&gt;
            &lt;/div&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>56eab0a132537e77293b86afcb80ad1a</guid>
<title>我，35岁程序员，千万资产3天归零；Twitter架构决策；在荷兰做程序员的体验｜码农周刊VIP会员专属邮件周报 Vol.093</title>
<link>https://toutiao.io/k/jr55rv0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>33931400e3481179b5bf029205cc40b2</guid>
<title>图文结合！Redis延迟队列golang高效实践</title>
<link>https://toutiao.io/k/rc9xqyk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe977Xa5zfy5iaV3agpS11Cqm4psjPOibic6BZSicnBFh6uWzCFp3uqN5R114Fq85DmuCzdL3eESlQ37bFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;导语 | &lt;/span&gt;&lt;span/&gt;&lt;span&gt;本文主要讲述如何使用golang基于Redis实现延迟消息队列组件。&lt;span&gt;希望对有需求的同学有所帮助。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务中经常会有这样的场景：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多时候我们会直接通过一个本地定时器来帮我们完成这个任务。如果我们的系统是多实例分布式的，本地定时器就会面临很多问题，如：怎么保证重复处理的问题；统一管控的问题等&lt;/span&gt;&lt;span&gt;等。面对本地定时器遇到的问题，我们可以使用分布式延迟队列来实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里介绍一种使用golang基于redis实现延迟队列的具体实践。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、实现原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;1、使用redis可以通过List类型来实现队列的功能，通过LPOP，RPUSH来保证先进先出的特性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.21015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97YZ1n3ibOnfqrveNaLwG1TdX7m8cprnRkKkUlQic6GtGpWBSNGAvzezmJBjXBCiazSuaVZclWSuHm4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、针对需要延迟处理的消息可以通过SortedSet有序集合类型来存储, 消息到期时期使用时间戳，作为member score的值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.38984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97YZ1n3ibOnfqrveNaLwG1Tdic1iatZlQtoxAQrqlzBSmvcibZQshGUJWMlexJMPYonqLNzib1zAe8CHHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、定时轮训sortedset，使用到期时间戳作为score，通过ZRANGEBYSCORE排序获取到期的消息，将到期的消息迁移到List队列中即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.52734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97YZ1n3ibOnfqrveNaLwG1Td3Iw65J4pmZeDgoiahP45E7WJGajichKk4HRSyM9LK1wDAhTgmyZxN9lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;三、消息迁移的原子性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对到期消息的往list的迁移需要三个动作：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;查询到期消息；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从sortedset取出到期消息；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将到期消息push到list队列中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那如何保证这个三个操作的&lt;/span&gt;&lt;span&gt;原子性&lt;/span&gt;&lt;span&gt;（要么都成功，要么都失败）。在redis中有两种处理方式可以保证多操作间的原子性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（一）Transaction&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（二）LuaScript&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis使用单个Lua解释器去运行所有脚本，并且，Redis也保证脚本会以原子性(atomic)的方式执行：当某个脚本正在运行的时候，不会有其他脚本或Redis命令被执行。这和使用MULTI/EXEC包围的事务很类似。在其他别的客户端看来，脚本的效果(effect)要么是不可见的(not visible)，要么就是已完成的(already completed)。注意：编写的script不能很慢，因为会阻塞其他命令的执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Transaction能够保证多个操作的原子性。LuaScript不仅保证了多操作间的原子性，可以处理更复杂的逻辑，如保障get、set操作的原子性。这里针对到期消息的迁移是先查询到期的消息，然后两个写操作完成。所以这里使用LuaScript实现更为简单方便。否则还需要加一个锁来避免同一个到期消息多次处理的问题。如果迁移到期消息的模块是单实例（非并发）处理的，不需要加锁处理。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;四、List，SortedSet性能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网上针对redis的压测很多，这里我们使用memtier_benchmark将与延迟队列使用到相关的操作进行压测。使用redis6.0，8核16Glinux服务器。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（一）List读写性能 LPOP，RPUSH时间复杂度为O(1)&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.184375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97YZ1n3ibOnfqrveNaLwG1TdOIJz4K8PCaUS6UItKNib7LXjGlaXjib3RUxC1vFIdHZxRw5qicX2hkE6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.184375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97YZ1n3ibOnfqrveNaLwG1TdOIJz4K8PCaUS6UItKNib7LXjGlaXjib3RUxC1vFIdHZxRw5qicX2hkE6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（二）sortedset 相关操作的读写性能&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.19140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97YZ1n3ibOnfqrveNaLwG1TdSzEwLcUREwLC8ck6d5uMuWiafmVjBiaMh0Bia7xqpqLjPkolpxpgOSFfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.184375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97YZ1n3ibOnfqrveNaLwG1TdnrWl6A1Qdp4qibshd0NZVeibficvjrK1ZHsbDfBeVEhdBicAcjibbScTEIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在熟悉了基于redis实现的延迟队列的基本方法后，接下来看下使用golang具体的实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;五、消息协议定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定义一个消息结构来保存消息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; Job &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Id        &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`msgpack:&quot;1&quot;`&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Topic     &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`msgpack:&quot;2&quot;`&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Delay     &lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`msgpack:&quot;3&quot;`&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Playload  []&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`msgpack:&quot;4&quot;`&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Timestamp &lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`msgpack:&quot;5&quot;`&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里使用msgpack实现消息的序列化。messagepack是一个高效的二进制序列化协议。相比json编码后的数据的体积更小，编解码的速度更快。redis script也支持messagepack。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;benchmark性能测试:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.95234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97YZ1n3ibOnfqrveNaLwG1TdAzwhGAoMbHpmeC7BEtKwhWibmiaOwQaZPIzngOnw6Lo1YsGgZJI0icUIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其他编解码性能对比参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;https://github.com/alecthomas/go_serialization_benchmarks&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;六、延迟队列的核心-redis&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于redis实现分布式延迟队列，其核心是使用List类型实现队列功能；使用sortedset实现延迟消息的管理，并且轮询sortedset将到期的消息迁移到List队列中，再启用consumer实例处理List队列中的消息，就完成了整个延迟队列的核心处理流程。先来看下针对redis操作的相关实现，这里操作redis的库使用的是go-redis库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（一）获取延时消息数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;zcard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(rdb *redis.Client, key &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;redis&lt;/span&gt;.&lt;span class=&quot;code-snippet__title&quot;&gt;IntCmd&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; rdb.ZCard(context.Background(), key)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（二）获取等待执行的消息数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;llen&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(rdb *redis.Client, key &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;redis&lt;/span&gt;.&lt;span class=&quot;code-snippet__title&quot;&gt;IntCmd&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; rdb.LLen(context.Background(), key)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这两个方法属于metric方法，可以帮助我们了解当前延时队列的消息积压情况，为我们对consumer实例的水平扩展提供参考指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（三）发送可执行消息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;func &lt;span class=&quot;code-snippet__title&quot;&gt;lpush&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;rdb *redis.Client, key &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}&lt;/span&gt;) error&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; rdb.LPush(context.Background(), key, &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;).Err()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（四）发送延时消息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;zadd&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(rdb *redis.Client, key &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;, value &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, delay &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; rdb.ZAdd(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    context.Background(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    key,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;amp;redis.Z{Score: &lt;span class=&quot;code-snippet__keyword&quot;&gt;float64&lt;/span&gt;(delay), Member: value}).Err()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（五）获取可执行消息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;rpop&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(rdb *redis.Client, key &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;redis&lt;/span&gt;.&lt;span class=&quot;code-snippet__title&quot;&gt;StringCmd&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; rdb.RPop(context.Background(), key)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（六）到期消息迁移到待执行队列&lt;/span&gt;&lt;span&gt;，这里使用redis script实现。每次都取指定数量（limit 0 num）的到期消息，时间花费相对稳定。也不至于在到期消息突增时，导致redis内存占用突增。每次执行仅对客户端返回消息数，从而降低网络传输。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func migrateExpiredJobs(rdb *redis.Client, delaykey, readyKey string) error {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  script := redis.NewScript(`&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  local &lt;span class=&quot;code-snippet__keyword&quot;&gt;val&lt;/span&gt; = redis.call(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;zrangebyscore&#x27;&lt;/span&gt;, KEYS[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;-inf&#x27;&lt;/span&gt;, ARGV[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;limit&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;20&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(next(&lt;span class=&quot;code-snippet__keyword&quot;&gt;val&lt;/span&gt;) ~= nil) then&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    redis.call(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;zremrangebyrank&#x27;&lt;/span&gt;, KEYS[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, #&lt;span class=&quot;code-snippet__keyword&quot;&gt;val&lt;/span&gt; - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    redis.call(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;rpush&#x27;&lt;/span&gt;, KEYS[&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;], unpack(&lt;span class=&quot;code-snippet__keyword&quot;&gt;val&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, #&lt;span class=&quot;code-snippet__keyword&quot;&gt;val&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  end&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; #&lt;span class=&quot;code-snippet__keyword&quot;&gt;val&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  `)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; script.Run(context.Background(), rdb, []string{delaykey, readyKey}, time.Now().Unix()).Err()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;七、Product实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;product功能比较单一，仅实现消息的投递。这里是对Redis两个方法RPUSH、ZADD的的封装。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type QueueClient &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;queue&lt;/span&gt; *&lt;span class=&quot;code-snippet__built_in&quot;&gt;queue&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;QueueClient提供了&lt;/span&gt;&lt;span&gt;两个操作方法&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(c *QueueClient)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Dispatch&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(topic &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;, payload []&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; c.queue.Push(&amp;amp;Job{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Topic:     topic,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Playload:  payload,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Delay:     &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Timestamp: time.Now().Unix(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(c *QueueClient)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;DispatchDelaySecond&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(topic &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;, payload []&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;, delaySec &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; c.queue.DelayJob(&amp;amp;Job{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Topic:     topic,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Playload:  payload,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Delay:     &lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;(delaySec),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Timestamp: time.Now().Unix(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;八、consumer实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在完成消息投递的相关方法的实现后，我们来看下如何实现一个稳定高效的消息处理框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;consumer完成&lt;/span&gt;&lt;span&gt;两个核心操作&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来看下consumer queueserver的实现的主要方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.77421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97YZ1n3ibOnfqrveNaLwG1TdpraXJRHAIdvOzmeic7nPkhJJaH7OXFyd5ibo4fA0b5wcLuX9IW5BjScw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、QueueServer开始执行的topic worker处理消息。一个topic一个协程的处理方式，保证不同的topic之间不相互影响；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; QueueServer &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  queueOption *QueueOption&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  topicwokers []*TopicWorker&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  queue       *queue&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  stopCh      &lt;span class=&quot;code-snippet__keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;close&lt;/span&gt;       &lt;span class=&quot;code-snippet__keyword&quot;&gt;uint32&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(s *QueueServer)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; _, topicWorker := &lt;span class=&quot;code-snippet__keyword&quot;&gt;range&lt;/span&gt; s.topicwokers {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; s.processJob(ctx, topicWorker)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; s.watchSystemSignal(ctx)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &amp;lt;-s.stopCh&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ctxTimeOut, cancalFunc := context.WithTimeout(ctx, time.Second*time.Duration(s.queueOption.CloseWaitTime))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; cancalFunc()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; s.Close(ctxTimeOut)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、定义统一消息处理接口JobHandler，定义了两个方法：Topic返回队列名；Execute完成消息的处理，可以实现业务处理逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type JobHandler &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Topic() &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Execute(context.Context, []&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;) error &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过topic worker来管理每个消息队列的处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type TopicWorker &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  TopicName   &lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Handler     JobHandler &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  WorkerCount &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  WorkerPool  *semaphore.Weighted &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过信号量semaphore库实现协程的并发数控制。如果消息间有顺序要求，可以设置workerCount为1。当server退出的时候，获取与workerCount相等数量的信号量等待所有处理消息的协程执行完成。s.queue.GetReadyJob(topic.TopicName) 这个方法的内部出了获取可执行消息外，还执行了到期消息迁移的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(q *queue)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;GetReadyJob&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(topic &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(*Job, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  migrateExpiredJobs(q.rdb, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                           fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%s:%s&quot;&lt;/span&gt;, topic, DelayJobType),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                           fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%s:%s&quot;&lt;/span&gt;, topic, ReadyJobType))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; q.Pop(topic)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(s *QueueServer)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processJob&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context, topic *TopicWorker)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; atomic.LoadUint32(&amp;amp;s.&lt;span class=&quot;code-snippet__built_in&quot;&gt;close&lt;/span&gt;) == closed {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err := topic.WorkerPool.Acquire(ctx, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;); err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    job, err := s.queue.GetReadyJob(topic.TopicName)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; err != redis.Nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      topic.WorkerPool.Release(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; job == &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      topic.WorkerPool.Release(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      time.Sleep(time.Second * time.Duration(s.queueOption.WaitTime))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      topic.Handler.Execute(ctx, job.Playload)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      topic.WorkerPool.Release(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err := topic.WorkerPool.Acquire(ctx, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;(topic.WorkerCount)); err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;九、扩展&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;（一）Job错误重试&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果想要给上面的Job处理加上错误重试的机制。我们给Job struct加上TryCount字段，当JobHandler 执行返回error时，把job放入可执行队列或是延迟集合（等待指定时候后重试）。通过TryCount来限定重试的次数。超过指定次数后丢弃消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;（二）Job超时重试&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果想要给上面的Job处理加上超时重试的机制。我们给Job struct加上TryTimeOut字段，当读取消息的同时把job放入延迟集合（等待到达超时时间后重试）。通过TryCount来限定重试的次数。超过指定次数后丢弃消息。执行成功时需要从set集合删除。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;十、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用golang基于redis实现延迟队列的方法如上所述，实现方式很多，但核心基本相同，可能在某些实现细节上略有差异。比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;熟悉php laravel框架的应该觉得这个方案相似，本文的实现方案跟laravel里的queue库实现方案类似，它支持更多的消息驱动：本地、文件、mysql、redis等。但我们借助golang可以实现的更高效消息处理框架。使用这种方式需要考虑消息丢失时的补偿机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 data-lines=&quot;1&quot; data-sign=&quot;381759e8570981ca8c2525ac43ac6e29&quot;&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/h1&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;1.&lt;/span&gt;&lt;span&gt;redis操作：&lt;/span&gt;&lt;span&gt;http://doc.redisfans.com/index.html&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.go-redis：&lt;/span&gt;&lt;span&gt;https://github.com/go-redis/redis&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;105&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;105&quot; data-fileid=&quot;100043716&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97YZ1n3ibOnfqrveNaLwG1TdficxibicUn2ragAcupYXIMnwY0Yia3cnXAXmQZK4FDzHjxiazlpfR3ibTueQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;王晓林&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;腾讯应用开发工程师&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯应用开发工程师，目前负责游可爱平台（yka.qq.com）的后台开发工作。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;37b42a3b6ddcc414e6e32be4a161956e&quot;&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247537945&amp;amp;idx=1&amp;amp;sn=d51d07540f96441cd96ee708480c4646&amp;amp;chksm=eaa84f49dddfc65f817c15fe9885414cb6b305dd71dbe0f939a7d46134aee03201fa406b64c7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;开箱即用！深入浅出Prometheus监控神器&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;开箱即用！深入浅出Prometheus监控神器&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247537758&amp;amp;idx=1&amp;amp;sn=06cce9029d32f224c0e0225be6b42f80&amp;amp;chksm=eaa84e0edddfc718104daecd7fe4f012790dc4fff7732e8ba7fa994616401d5263a0e8b2c7cf&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;C++17在业务代码中最好用的10个特性！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;C++17在业务代码中最好用的10个特性！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247537712&amp;amp;idx=1&amp;amp;sn=229dd98665f20adb94c97f0a0b05105b&amp;amp;chksm=eaa84e60dddfc776d0b1a77303d2e6e8dbe48c4ad8cbdf2e97019efbc70b202ada62646299da&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;必撸系列！Go另外几个黑魔法技巧汇总&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;必撸系列！Go另外几个黑魔法技巧汇总&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247535783&amp;amp;idx=1&amp;amp;sn=e9736107bfb467fedb5cbcd4bcfa6f01&amp;amp;chksm=eaa856f7dddfdfe1cba3fa86754926632aaabf63870cd129ff3dbf11385199f4413bf9fe4240&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;来了！Go的2个黑魔法技巧&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;来了！Go的2个黑魔法技巧&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI2NDU4OTExOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96FK2eEg86vUicOR3n6kAHk1PHvTb8VBicYk0RmNQYsQyibgg8iaZqT0bCEU9VKo3Z3iceoQfgycyMpKWQ/0?wx_fmt=png&quot; data-nickname=&quot;云加社区&quot; data-alias=&quot;QcloudCommunity&quot; data-signature=&quot;腾讯云官方社区公众号，汇聚技术开发者群体，分享技术干货，打造技术影响力交流社区。&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot; wah-hotarea=&quot;click&quot;/&gt;&lt;/section&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;37b42a3b6ddcc414e6e32be4a161956e&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.59375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe977Xa5zfy5iaV3agpS11Cqm4xV7ckfbmtFLyUjFID2k7yO4q8hvB4OqYoNkARZ2xuvzKvMtnmVN2BQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3e8e8bac3bafcb1291c147920e40a734</guid>
<title>深入理解 ELK 中 Logstash 的底层原理 + 填坑指南</title>
<link>https://toutiao.io/k/gjx29io</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是悟空呀，我被憧憬小哥催更了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;儿童节、端午节前发一篇，祝大家双节快乐&lt;/span&gt;~&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMjI0ODk0NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JicQpKzblLHz64qoibVa3ATNA4rH8mIYXAF3OErAzxFKHzf5qiaiblb4rAMuAXXMJHEcKcvaHv4ia9rA/0?wx_fmt=png&quot; data-nickname=&quot;悟空聊架构&quot; data-alias=&quot;PassJava666&quot; data-signature=&quot;用故事讲解分布式、架构。 《 JVM 性能调优实战》专栏作者， 《Spring Cloud 实战 PassJava》开源作者， 自主开发了 PMP 刷题小程序。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文目录如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;前言&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一、部署架构图&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;二、Logstash 用来做什么？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;三、Logstash 的原理&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;3.1 从 Logstash 自带的配置说起&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3.2 Input 插件&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3.3 Filter 插件&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3.4 Output 插件&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3.5 完整配置&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;四、Logstash 怎么跑起来的&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;4.1 Logstash 如何运行的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.2 Logstash 的架构原理&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;五、Logstash 宕机风险&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;5.1 Logstash 单点部署的风险&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;5.2 开机启动 Logstash&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;六、总结&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过本篇内容，你可以学到如何解决 Logstash 的常见问题、理解 Logstash 的运行机制、集群环境下如何部署 ELK Stack。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用 Logstash 遇到了很多坑，本篇也会讲解解决方案。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;日志记录的格式复杂，正则表达式非常磨人。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务日志有多种格式，如何匹配。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;错误日志打印了堆栈信息，包含很多行，如何合并。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;日志记录行数过多（100多行），被拆分到了其他的日志记录中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;输出到 ES 的日志包含很多无意义字段。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;输出到 ES 的日志时间和本来的日志时间相差 8 小时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何优化 Logstash 的性能&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Logstash 单点故障如何处理。&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、部署架构图&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上次我们聊到了 ELK Stack 的搭建：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451962693&amp;amp;idx=1&amp;amp;sn=96530613aaadd8240d8a5c2ab7dff49d&amp;amp;chksm=8d1c02daba6b8bcc2499861fd37aac5cfa88d616fc839cb6a7a3c003118457ac325c3dcbeb62&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;一文带你搭建一套 ELK Stack 日志平台&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近悟空正在我们的测试环境部署这一套 ELK，发现还是有很多内容需要再单独拎几篇出来详细讲讲的，这次我会带着大家一起来看下 ELK 中的 Logstash 组件的落地玩法和踩坑之路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试环境目前有 &lt;span&gt;12&lt;/span&gt; 台机器，其中 有 &lt;span&gt;4&lt;/span&gt; 台给后端微服务、Filebeat、Logstash 使用，&lt;span&gt;3&lt;/span&gt; 台给 ES 集群和 Kibana 使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;部署拓扑图如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46386946386946387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8RMYK466oGtbQNnpUgEvWO3oR7uhu8ibXS27cTz0KjpZMUangvDm3sticA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2574&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;部署说明&lt;/span&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;4 台服务器给业务微服务服务使用，微服务的日志会存放本机上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;4 台服务器都安装 Filebeat 日志采集器，采集本机的微服务日志，&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;其中一台服务器安装 Logstash ，Filebeat 发送日志给 Logstash。Logstash 将日志输出到 Elasticsearch 集群中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3 台服务器都安装有 Elasticsearch 服务，组成 ES 集群。其中一台安装 Kibana 服务，查询 ES 集群中的日志信息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、Logstash 用来做什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你是否还在苦恼每次生产环境出现问题都需要远程到服务器查看日志文件？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你是否还在为了没有统一的日志搜索入口而烦心？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你是否还在为从几十万条日志中搜索关键信息而苦恼？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，Logstash 它来啦，带着所有的日志记录来啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Logstash 它是帮助我们收集、解析和转换日志的。作为 ELK 中的一员，发挥着很大的作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然 Logstash 不仅仅用在收集日志方面，还可以收集其他内容，我们最熟悉的还是用在日志方面。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、Logstash 的原理&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 从 Logstash 自带的配置说起&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Logstash 的原理其实还比较简单，一个输入，一个输出，中间有个管道（不是必须的），这个管道用来收集、解析和转换日志的。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4413793103448276&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8RHJ66ZUWtIeib49wSb1BPCAYOoD3MPfxAXKFYXnuaQlyicDMibf6rPkoNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;870&quot;/&gt;&lt;figcaption&gt;Logstash 组件&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Logstash 运行时，会读取 Logstash 的配置文件，配置文件可以配置输入源、输出源、以及如何解析和转换的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Logstash 配置项中有两个必需元素，输入（inputs）和输出（ouputs），以及一个可选元素 filters 过滤器插件。input 可以配置来源数据，过滤器插件在你指定时修改数据，output 将数据写入目标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下 Logstash 软件自带的一个示例配置，文件路径：\logstash-7.6.2\config\logstash-sample.conf&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4735169491525424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8RzxAdegoef5B8l9QrabEKAEejobIqIgXa1V2CLs1ThicOCicAHUbBAEpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;944&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是很简单，一个 input 和 一个 output 就搞定了。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3762057877813505&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8RZFonQD0deJmnlvicrMWCNXuycfoyAtp6gsn6kZY53VXhs8Qh0Yxsdtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1244&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这种配置其实意义不大，没有对日志进行解析，传到 ES 中的数据是原始数据，也就是一个 message 字段包含一整条日志信息，不便于根据字段搜索。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 Input 插件&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置文件中 input 输入源指定了 beats，而 beats 是一个大家族，Filebeat 只是其中之一。对应的端口 port = 5044，表示 beats 插件可以往 5044 端口发送日志，logstash 可以接收到通过这个端口和 beats 插件通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在部署架构图中，input 输入源是 Filebeat，它专门监控日志的变化，然后将日志传给 Logstash。在早期，Logstash 是自己来采集的日志文件的。所以早期的日志检索方案才叫做 ELK，Elasticsearch + Logstash + Kibana，而现在加入了 Filebeat 后，这套日志检索方案属于 ELK Stack，不是 ELKF，摒弃了用首字母缩写来命名。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外 input 其实有很多组件可以作为输入源，不限于 Filebeat，比如我们可以用 Kafka 作为输入源，将消息传给 Logstash。具体有哪些插件列表，可以参考这个 &lt;span&gt;input 插件列表&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 Filter 插件&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对于 Logstash 的 Filter，这个才是 Logstash 最强大的地方。Filter 插件也非常多，我们常用到的 grok、date、mutate、mutiline 四个插件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 filter 的各个插件执行流程，可以看下面这张图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4929906542056075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8Rj7wlhzy2JCF4UKNkwvRrSL6F14YRTriaSJb72OZOkevLZOibLS2ObYbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;856&quot;/&gt;&lt;figcaption&gt;图片来自 Elasticsearch 官网&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.3.1 日志示例&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我以我们后端服务打印的日志为例，看是如何用 filter 插件来解析和转换日志的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;logback.xml 配置的日志格式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;encoder&amp;gt;&lt;br/&gt;    &amp;lt;pattern&amp;gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&amp;lt;/pattern&amp;gt;&lt;br/&gt;&amp;lt;/encoder&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志格式解释如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;记录日志时间：%d{yyyy-MM-dd HH:mm:ss.SSS}&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;记录是哪个线程打印的日志：[%thread]&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;记录日志等级：%-5level&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;打印日志的类：%logger&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;记录具体日志信息：%msg%n，这个 msg 的内容就是 log.info(&quot;abc&quot;) 中的 abc。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过执行代码 log.info(&quot;xxx&quot;) 后，就会在本地的日志文件中追加一条日志。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.3.2 打印的日志内容&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从服务器拷贝出了一条日志，看下长什么样，有部分敏感信息我已经去掉了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;2022-06-16 15:50:00.070 [XNIO-1 task-1] INFO  com.passjava.config - 方法名为:MemberController-,请求参数:{省略}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 Logstash 如何针对上面的信息解析出对应的字段呢？比如如何解析出打印日志的时间、日志等级、日志信息？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.3.3 grok 插件&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就要用到 logstash 的 filter 中的 grok 插件。filebeat 发送给 logstash 的日志内容会放到message 字段里面，logstash 匹配这个 message 字段就可以了。配置项如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;filter {&lt;br/&gt; grok {&lt;br/&gt;      match =&amp;gt; [ &lt;span&gt;&quot;message&quot;&lt;/span&gt;, &lt;span&gt;&quot;(?&amp;lt;logTime&amp;gt;\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}.\d{3})\s+\[(?&amp;lt;thread&amp;gt;.*)\]\s+(?&amp;lt;level&amp;gt;\w*)\s{1,2}+(?&amp;lt;class&amp;gt;\S*)\s+-\s+(?&amp;lt;content&amp;gt;.*)\s*&quot;&lt;/span&gt;]&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;坑&lt;/span&gt;：日志记录的格式复杂，正则表达式非常磨人。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家发现没，上面的 匹配 message 的正则表达式还是挺复杂的，这个是我一点一点试出来的。Kibana 自带 grok 的正则匹配的工具，路径如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;http://&amp;lt;your kibana IP&amp;gt;:5601/app/kibana&lt;span&gt;#/dev_tools/grokdebugger&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把日志和正则表达式分别粘贴到上面的输入框，点击 Simulate 就可以测试是否能正确匹配和解析出日志字段。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6238993710691824&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8R9m9VKdfJTmiaonQDGRrLNA3kjTqz7kvibvuPcNjQ5W9iaaN1PnT8bYwzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1590&quot;/&gt;&lt;figcaption&gt;Grok Debugger 工具&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有常用的正则表达式呢？有的，logstash 官方也给了一些常用的&lt;code&gt;常量&lt;/code&gt;来表达那些正则表达式，可以到这个 Github 地址查看有哪些常用的常量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;https://github.com/logstash-plugins/logstash-patterns-core/blob/main/patterns/ecs-v1/grok-patterns&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如可以用 IP 常量来代替正则表达式 &lt;code&gt;IP (?:%{IPV6}|%{IPV4})&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，经过正则表达式的匹配之后，grok 插件会将日志解析成多个字段，然后将多个字段存到了 ES 中，这样我们可以在 ES 通过字段来搜索，也可以在 kibana 的 Discover 界面添加列表展示的字段。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5024390243902439&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8RKj8wzEnhPOctKoCqc7icN8JkdACp4qbCRqCicbbux4pfwribK2OANU6kA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;615&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;坑&lt;/span&gt;：我们后端项目的不同服务打印了两种不同格式的日志，那这种如何匹配？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再加一个 match 就可以了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;filter {&lt;br/&gt; grok {&lt;br/&gt;      match =&amp;gt; [ &lt;span&gt;&quot;message&quot;&lt;/span&gt;, &lt;span&gt;&quot;(?&amp;lt;logTime&amp;gt;\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}.\d{3})\s+\[(?&amp;lt;thread&amp;gt;.*)\]\s+(?&amp;lt;level&amp;gt;\w*)\s{1,2}+(?&amp;lt;class&amp;gt;\S*)\s+-\s+(?&amp;lt;content&amp;gt;.*)\s*&quot;&lt;/span&gt;]&lt;br/&gt;      match =&amp;gt; [ &lt;span&gt;&quot;message&quot;&lt;/span&gt;, &lt;span&gt;&quot;(?&amp;lt;logTime&amp;gt;\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}.\d{3})\s{1,2}+(?&amp;lt;level&amp;gt;\w*)\s{1,2}+.\s---+\s\[(?&amp;lt;thread&amp;gt;.*)\]+\s(?&amp;lt;class&amp;gt;\S*)\s*:+\s(?&amp;lt;content&amp;gt;.*)\s*&quot;&lt;/span&gt;]&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当任意一个 message 匹配上了这个正则，则 grok 执行完毕。假如还有第三种格式的 message，那么虽然 grok 没有匹配上，但是 message 也会输出到 ES，只是这条日志在 ES 中不会展示 logTime、level 等字段。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.3.4 multiline 插件&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;还有一个坑的地方&lt;/span&gt;是错误日志一般都是很多行的，会把堆栈信息打印出来，当经过 logstash 解析后，每一行都会当做一条记录存放到 ES，那这种情况肯定是需要处理的。这里就需要使用 multiline 插件，对属于同一个条日志的记录进行拼接。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.3.4.1 安装 multiline 插件&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;multiline 不是 logstash 自带的，需要单独进行安装。我们的环境是没有外网的，所以需要进行离线安装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍在线和离线安装 multiline 的方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 logstash 根目录执行以下命令进行安装。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;bin/logstash-plugin install logstash-filter-multiline&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10892586989409984&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8R5A3GI4wMKoYzPQNNVR8SdAgrzBQu7Xzj2ZB8K92E6Q4FFBjJGicMcVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在有网的机器上在线安装插件，然后打包。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;bin/logstash-plugin install logstash-filter-multiline&lt;br/&gt;bin/logstash-plugin prepare-offline-pack logstash-filter-multiline&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拷贝到服务器，执行安装命令。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;bin/logstash-plugin install file:///home/software/logstash-offline-plugins-7.6.2.zip&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装插件需要等待 5 分钟左右的时间，控制台界面会被 hang 住，当出现 &lt;code&gt;Install successful&lt;/code&gt; 表示安装成功。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08308004052684904&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8RR0HUZu1BrIn4RQlJjmiclvBEkXdfX59E9hz25nR9IF9nEibbDKFsVUoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;987&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;检查下插件是否安装成功，可以执行以下命令查看插件列表。当出现 multiline 插件时则表示安装成功。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;bin/logstash-plugin list&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.3.4.2 使用 multiline 插件&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要对同一条日志的多行进行合并，你的思路是怎么样的？比如下面这两条异常日志，如何把文件中的 8 行日志合并成两条日志？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8RXsHmZE5K7I5uicRbJBDxptopdaaUGhxx6c684xDibLW7nHwVibwuUcZGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1482&quot;/&gt;&lt;figcaption&gt;多行日志示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思路是这样的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一步：每一条日志的第一行开头都是一个时间，可以用时间的正则表达式匹配到第一行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二步：然后将后面每一行的日志与第一行合并。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三步：当遇到某一行的开头是可以匹配正则表达式的时间的，就停止第一条日志的合并，开始合并第二条日志。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第四步：重复第二步和第三步&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照这个思路，multiline 的配置如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;filter {&lt;br/&gt;  multiline {&lt;br/&gt;    pattern =&amp;gt; &lt;span&gt;&quot;^\d{4}-\d{1,2}-\d{1,2}\s\d{1,2}:\d{1,2}:\d{1,2}.\d{3}&quot;&lt;/span&gt;&lt;br/&gt;    negate =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    what =&amp;gt; &lt;span&gt;&quot;previous&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间的正则表达式就是这个 pattern 字段，大家可以根据自己项目中的日志的时间来定义正则表达式。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;pattern&lt;/span&gt;: 这个是用来匹配文本的表达式，也可以是&lt;code&gt;grok&lt;/code&gt;表达式&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;what&lt;/span&gt;: 如果&lt;code&gt;pattern&lt;/code&gt;匹配成功的话，那么匹配行是归属于上一个事件，还是归属于下一个事件。&lt;/p&gt;&lt;p&gt;previous: 归属于上一个事件，向上合并。&lt;/p&gt;&lt;p&gt;next: 归属于下一个事件，向下合并&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;negate&lt;/span&gt;:是否对 pattern 的结果取反&lt;/p&gt;&lt;p&gt;false: 不取反，&lt;span&gt;是默认值&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;true: 取反。将多行事件扫描过程中的行匹配逻辑取反（如果pattern匹配失败，则认为当前行是多行事件的组成部分）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考 &lt;span&gt;multiline 官方文档&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.3.5 多行被拆分&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;坑：Java 堆栈日志太长了，有 100 多行，被拆分了两部分，一部分被合并到了原来的那一条日志中，另外一部分被合并到了不相关的日志中。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，第二条日志有 100 多行，其中最后一行被错误地合并到了第三条日志中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2454798331015299&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8RNMEiaJVqpYcYQDDurSiaQIFiavJgpsshgeMibwvz7riaLTVsdjO6xBMNZLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1438&quot;/&gt;&lt;figcaption&gt;日志合并错乱&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，我是通过配置 filebeat 的 multiline 插件来截断日志的。为什么不用 logstash 的 multiline 插件呢？因为在 filter 中使用 multiline 没有截断的配置项。filebeat 的 multiline 配置项如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;multiline.type: pattern&lt;br/&gt;multiline.pattern: &lt;span&gt;&#x27;^\d{4}-\d{1,2}-\d{1,2}\s\d{1,2}:\d{1,2}:\d{1,2}.\d{3}&#x27;&lt;/span&gt;&lt;br/&gt;multiline.negate: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;multiline.match: after&lt;br/&gt;multiline.max_lines: 50&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置项说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;multiline.pattern：希望匹配到的结果（正则表达式）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;multiline.negate：值为 true 或 false。使用 false 代表匹配到的行合并到上一行；使用 true 代表不匹配的行合并到上一行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;multiline.match：值为 after 或 before。after 代表合并到上一行的末尾；before 代表合并到下一行的开头&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;multiline.max_lines：合并的最大行数，默认 500&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;multiline.timeout：一次合并事件的超时时间，默认为 5s，防止合并消耗太多时间导致 filebeat 进程卡死&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们重点关注 max_lines 属性，表示最多保留多少行后执行截断，这里配置 50 行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：filebeat 和 logstash 我都配置了 multiline，没有验证过只配置 filebeat 的情况。参考 &lt;span&gt;Filebeat 官方文档&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.3.6 mutate 插件&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们将日志解析出来后，Logstash 自身会传一些不相关的字段到 ES 中，这些字段对我们排查线上问题帮助不大。可以直接剔除掉。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;坑：输出到 ES 的日志包含很多无意义字段。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们就要用到 mutate 插件了。它可以对字段进行转换，剔除等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我的配置是这样的，对很多字段进行了剔除。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;mutate {&lt;br/&gt;    remove_field =&amp;gt; [&lt;span&gt;&quot;agent&quot;&lt;/span&gt;,&lt;span&gt;&quot;message&quot;&lt;/span&gt;,&lt;span&gt;&quot;@version&quot;&lt;/span&gt;, &lt;span&gt;&quot;tags&quot;&lt;/span&gt;, &lt;span&gt;&quot;ecs&quot;&lt;/span&gt;, &lt;span&gt;&quot;input&quot;&lt;/span&gt;, &lt;span&gt;&quot;[log][offset]&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：一定要把 log.offset 字段去掉，这个字段可能会包含很多无意义内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 Mutate 过滤器它有很多配置项可供选择，如下表格所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0253583241455346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8RRDRb0ianIXSDl6IYSzVicY3ic4RyvbVlyg91VpZfaTicBibQ8hHbG9Alw7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;figcaption&gt;Mutate  过滤器配置选项&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考 &lt;span&gt;Mutate 参考文章&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.3.7 date 插件&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到 kibana 查询日志时，发现排序和过滤字段 &lt;code&gt;@timestamp&lt;/code&gt; 是 ES 插入日志的时间，而不是打印日志的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们就要用到 &lt;code&gt;date&lt;/code&gt; 插件了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的 grok 插件已经成功解析出了打印日志的时间，赋值到了 &lt;code&gt;logTime&lt;/code&gt; 变量中，现在用 date 插件将 &lt;code&gt;logTime&lt;/code&gt; 匹配下，如果能匹配，则会赋值到 &lt;code&gt;@timestamp &lt;/code&gt; 字段，写入到 ES 中的 &lt;code&gt;@timestamp &lt;/code&gt;字段就会和日志时间一致了。配置如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;date {&lt;br/&gt;    match =&amp;gt; [&lt;span&gt;&quot;logTime&quot;&lt;/span&gt;, &lt;span&gt;&quot;MMM d HH:mm:ss&quot;&lt;/span&gt;, &lt;span&gt;&quot;MMM dd HH:mm:ss&quot;&lt;/span&gt;, &lt;span&gt;&quot;ISO8601&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是经过测试写入到 ES 的 &lt;code&gt;@timestamp&lt;/code&gt; 日志时间和打印的日志时间相差 8 小时。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37032418952618457&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8R22icawtZjzA98qb0b1TS2712xoNERP9KWzbAXULtOjRYs13UMasQwGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们到 ES 中查询记录后，发现 &lt;code&gt;@timestamp&lt;/code&gt; 字段时间多了一个字母 &lt;code&gt;Z&lt;/code&gt;，代表 &lt;code&gt;UTC&lt;/code&gt; 时间，也就是说 ES 中存的时间比日志记录的时间晚 8 个小时。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22786647314949202&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8RcXCuGYicq1NCVUSpaHA1xt1IUEasJVVRqo9XdUd3EDibdBLvn7XZ6NBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;689&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过增加配置  timezone =&amp;gt; &quot;Asia/Shanghai&quot; 来解决这个问题。修改后的配置如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;date {&lt;br/&gt;    match =&amp;gt; [&lt;span&gt;&quot;logTime&quot;&lt;/span&gt;, &lt;span&gt;&quot;MMM d HH:mm:ss&quot;&lt;/span&gt;, &lt;span&gt;&quot;MMM dd HH:mm:ss&quot;&lt;/span&gt;, &lt;span&gt;&quot;ISO8601&quot;&lt;/span&gt;]&lt;br/&gt;    timezone =&amp;gt; &lt;span&gt;&quot;Asia/Shanghai&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调整后，再加一条日志后查看结果，Kibana 显示 @timestamp 字段和日志的记录时间一致了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24351851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8RcTapCZ31Gs4lKOnDBmj1FMrtqlzwtgQRNEsnibL66he5gvqicbZdlL5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4 Output 插件&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Logstash 解析和转换后的日志最后输出到了 Elasticsearch 中，由于我们 ES 是集群部署的，所以需要配置多个  ES 节点地址。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;output {&lt;br/&gt;  stdout { }&lt;br/&gt;&lt;br/&gt;  elasticsearch {&lt;br/&gt;    hosts =&amp;gt; [&lt;span&gt;&quot;10.2.1.64:9200&quot;&lt;/span&gt;,&lt;span&gt;&quot;10.2.1.65:9200&quot;&lt;/span&gt;,&lt;span&gt;&quot;10.27.2.1:9200&quot;&lt;/span&gt;]&lt;br/&gt;    index =&amp;gt; &lt;span&gt;&quot;qa_log&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意这里的 index 名称 qa_log 必须是小写，不然写入 es 时会报错。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.5 完整配置&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;logstah 配置文件内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;input {&lt;br/&gt;  beats {&lt;br/&gt;    port =&amp;gt; 9900&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;filter {&lt;br/&gt;&lt;br/&gt;  multiline {&lt;br/&gt;    pattern =&amp;gt; &lt;span&gt;&quot;^\d{4}-\d{1,2}-\d{1,2}\s\d{1,2}:\d{1,2}:\d{1,2}.\d{3}&quot;&lt;/span&gt;&lt;br/&gt;    negate =&amp;gt; true&lt;br/&gt;    what =&amp;gt; &lt;span&gt;&quot;previous&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  grok {&lt;br/&gt;      match =&amp;gt; [ &lt;span&gt;&quot;message&quot;&lt;/span&gt;, &lt;span&gt;&quot;(?&amp;lt;logTime&amp;gt;\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}.\d{3})\s+\[(?&amp;lt;thread&amp;gt;.*)\]\s+(?&amp;lt;level&amp;gt;\w*)\s{1,2}+(?&amp;lt;class&amp;gt;\S*)\s+-\s+(?&amp;lt;content&amp;gt;.*)\s*&quot;&lt;/span&gt;]&lt;br/&gt;      match =&amp;gt; [ &lt;span&gt;&quot;message&quot;&lt;/span&gt;, &lt;span&gt;&quot;(?&amp;lt;logTime&amp;gt;\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}.\d{3})\s{1,2}+(?&amp;lt;level&amp;gt;\w*)\s{1,2}+.\s---+\s\[(?&amp;lt;thread&amp;gt;.*)\]+\s(?&amp;lt;class&amp;gt;\S*)\s*:+\s(?&amp;lt;content&amp;gt;.*)\s*&quot;&lt;/span&gt;]&lt;br/&gt;      match =&amp;gt; [&lt;br/&gt;           &lt;span&gt;&quot;source&quot;&lt;/span&gt;, &lt;span&gt;&quot;/home/passjava/logs/(?&amp;lt;logName&amp;gt;\w+)/.*.log&quot;&lt;/span&gt;&lt;br/&gt;       ]&lt;br/&gt;      overwrite =&amp;gt; [ &lt;span&gt;&quot;source&quot;&lt;/span&gt;]&lt;br/&gt;      break_on_match =&amp;gt; false&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  mutate {&lt;br/&gt;    convert =&amp;gt; {&lt;br/&gt;      &lt;span&gt;&quot;bytes&quot;&lt;/span&gt; =&amp;gt; &lt;span&gt;&quot;integer&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    remove_field =&amp;gt; [&lt;span&gt;&quot;agent&quot;&lt;/span&gt;,&lt;span&gt;&quot;message&quot;&lt;/span&gt;,&lt;span&gt;&quot;@version&quot;&lt;/span&gt;, &lt;span&gt;&quot;tags&quot;&lt;/span&gt;, &lt;span&gt;&quot;ecs&quot;&lt;/span&gt;, &lt;span&gt;&quot;_score&quot;&lt;/span&gt;, &lt;span&gt;&quot;input&quot;&lt;/span&gt;, &lt;span&gt;&quot;[log][offset]&quot;&lt;/span&gt;]&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  useragent {&lt;br/&gt;    source =&amp;gt; &lt;span&gt;&quot;user_agent&quot;&lt;/span&gt;&lt;br/&gt;    target =&amp;gt; &lt;span&gt;&quot;useragent&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  date {&lt;br/&gt;    match =&amp;gt; [&lt;span&gt;&quot;logTime&quot;&lt;/span&gt;, &lt;span&gt;&quot;MMM d HH:mm:ss&quot;&lt;/span&gt;, &lt;span&gt;&quot;MMM dd HH:mm:ss&quot;&lt;/span&gt;, &lt;span&gt;&quot;ISO8601&quot;&lt;/span&gt;]&lt;br/&gt;    timezone =&amp;gt; &lt;span&gt;&quot;Asia/Shanghai&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;output {&lt;br/&gt;  stdout { }&lt;br/&gt;&lt;br/&gt;  elasticsearch {&lt;br/&gt;    hosts =&amp;gt; [&lt;span&gt;&quot;10.2.1.64:9200&quot;&lt;/span&gt;,&lt;span&gt;&quot;10.2.1.65:9200&quot;&lt;/span&gt;,&lt;span&gt;&quot;10.2.1.66:9200&quot;&lt;/span&gt;]&lt;br/&gt;    index =&amp;gt; &lt;span&gt;&quot;qa_log&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四、Logstash 怎么跑起来的&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 Logstash 如何运行的&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你会好奇 Logstash 是怎么运行起来的吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方提供的启动方式是执行 logstash -f weblog.conf 命令来启动，当执行这个命令的时候其实会调用 Java 命令，以及设置 java 启动参数，然后传入了一个配置文件 weblog.conf 来启动 Logstash。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;cd&lt;/span&gt; /home/logstash-7.6.2&lt;br/&gt;sudo ./bin/logstash -f weblog.conf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当启动完之后，我们通过命令来看下 Logstash 的运行状态&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ps -ef | grep logstash&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果如下图所示，可以看到用到了 Java 命令，设置了 JVM 参数，用到了 Logstash 的JAR 包，传入了参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2588495575221239&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8Rqbgw9kbXFXia6I2q1nMHgkLJ3NSjBL4zdcBLibwSWibkQmgBCwKdVnqiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1356&quot;/&gt;&lt;span&gt;&lt;strong&gt;所以建议 Logstash 单独部署到一台服务器上，避免服务器的资源被 Logstash 占用。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Logstash 默认的 JVM 配置是 -Xms1g -Xmx1g，表示分配的最小和最大堆内存大小为 1 G。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个参数是在哪里配置的呢？全局搜索下 Xms1g，找到是在这个文件里面配置的，config\jvm.options，我们可以修改这里面的 JVM 配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以调整 Logstash 的 JVM 启动参数，来&lt;span&gt;优化 Logstash 的性能&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外 Kibana 上面还可以监控 Logstash 的运行状态（不在本篇讨论范围）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 Logstash 的架构原理&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5406360424028268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8Ruicgw7Uq1baGSNICSFaadF1JyKuiarh1N2bibS3piczo1F57IoC56rNMcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1415&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本内容参考这篇 &lt;span&gt;Logstash 架构&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Logstash 有多个 input，每个 input 都会有自己的 codec。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据会先存放到 Queue 中，Logstash 会把 Queue 中的数据分发到不同的 pipeline 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后每一个 pipeline 由 Batcher、filter、output 组成&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Batcher 的作用是批量地从Queue中取数据。Batcher 可以配置为一次取一百个数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;五、Logstash 宕机风险&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.1 Logstash 单点部署的风险&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 Logstash 是单点部署到一台服务器上，所以会存在两个风险：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;logstash 突然崩了怎么办？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;logstash 所在的机器宕机了怎么办？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Logstash 所在的机器重启了怎么办？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于第一个问题，可以安装 Keepalived 软件来保证高可用。另外即使没有安装，当手动启动 Logstash 后，Logstash 也能将未及时同步的日志写入到 ES。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于第二个问题，所在的机器宕机了，那可以通过安装两套 Logstash，通过 keepalived 提供的虚拟 IP 功能，切换流量到另外一个 Logstash。关于如何使用 Keepalived，可以参考之前的 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451963004&amp;amp;idx=1&amp;amp;sn=2667d0e6e9142939e3645de680a4533f&amp;amp;chksm=8d1c05e3ba6b8cf5a6a0ab2ecb66af10496838e25814cbefcd45907dd652a5ec6ef3917b6ada&amp;amp;token=1170452569&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;实战 MySQL 高可用架构&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于第三个问题，就是把启动 Logstash 的命令放到开机启动脚本中就可以了，但是存在以下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Ubuntu 18.04 版本是没有开机启动文件的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Logstash 无法找到 Java 运行环境&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来看下怎么进行配置开机自启动 Logstash。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.2 开机启动 Logstash&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;5.2.1 创建自动启动脚本&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建立rc-local.service文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sudo vim /etc/systemd/system/rc-local.service&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将下列内容复制进 rc-local.service 文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[Unit]&lt;br/&gt;Description=/etc/rc.local Compatibility&lt;br/&gt;ConditionPathExists=/etc/rc.local&lt;br/&gt; &lt;br/&gt;[Service]&lt;br/&gt;Type=forking&lt;br/&gt;ExecStart=/etc/rc.local start&lt;br/&gt;TimeoutSec=0&lt;br/&gt;StandardOutput=tty&lt;br/&gt;RemainAfterExit=yes&lt;br/&gt;SysVStartPriority=99&lt;br/&gt; &lt;br/&gt;[Install]&lt;br/&gt;WantedBy=multi-user.target&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建文件 rc.local&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sudo vim /etc/rc.local&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;添加启动脚本到启动文件中&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#!/bin/sh -e&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 启动 logstash&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#nohup /home/software/logstash-7.6.2/bin/logstash -f /home/software/logstash-7.6.2/weblog.conf &amp;amp;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 启动 filebeat&lt;/span&gt;&lt;br/&gt;nohup /home/software/filebeat-7.6.2-linux-x86_64/filebeat -e -c /home/software/filebeat-7.6.2-linux-x86_64/config.yml &amp;amp;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;exit&lt;/span&gt; 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;5.2.2 修改 Java 运行环境&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因在开机启动中，logstash 找不到 java 的运行环境，所以需要手动配置下 logstash。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;cd&lt;/span&gt; /home/software/logstash-7.6.2/bin/&lt;br/&gt;sudo vim logstash.lib.sh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 setup_java() 方法的第一行加入 JAVA_HOME 变量，JAVA_HOME 的路径需要根据自己的 java 安装目录来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;JAVA_HOME=&lt;span&gt;&quot;/opt/java/jdk1.8.0_181&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3776785714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8RxGbcCZf4yLB7LegUBibo2Q76vEU725NibJOwiawl5NvlaCK1DJeGOibf3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1120&quot;/&gt;&lt;figcaption&gt;修改 Java 运行环境&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;5.2.3 权限问题&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给 rc.local 加上权限,启用服务&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sudo chmod +x /etc/rc.local&lt;br/&gt;sudo systemctl &lt;span&gt;enable&lt;/span&gt; rc-local&lt;br/&gt;sudo systemctl stop rc-local.service&lt;br/&gt;sudo systemctl start rc-local.service&lt;br/&gt;sudo systemctl status rc-local.service&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36149732620320857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3rkKtSViaCQ9wn78YkTRH8RcFvhogsArRqznZc5yTGUlSU5O5LUOJcbLSicuuUeyh9iadI7qdLfSBUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;935&quot;/&gt;&lt;figcaption&gt;Logstash 启动成功&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后重启机器，查看 logstash进程是否正在运行，看到一大串 java 运行的命令则表示 logstash 正在运行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ps -ef | grep logstash&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;六、总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇讲解了 Logstash 在集群环境下的部署架构图、Logstash 遇到的几大坑、以及 Logstash 的运行机制和架构原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Logstash 还是非常强大的，有很多功能未在本篇进行讲解，本篇也是抛砖引玉，感兴趣的读者朋友们可以加我好友 passjava 共同探索。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多好文请查看：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451963004&amp;amp;idx=1&amp;amp;sn=2667d0e6e9142939e3645de680a4533f&amp;amp;chksm=8d1c05e3ba6b8cf5a6a0ab2ecb66af10496838e25814cbefcd45907dd652a5ec6ef3917b6ada&amp;amp;token=1170452569&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;实战 MySQL 高可用架构&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451962693&amp;amp;idx=1&amp;amp;sn=96530613aaadd8240d8a5c2ab7dff49d&amp;amp;chksm=8d1c02daba6b8bcc2499861fd37aac5cfa88d616fc839cb6a7a3c003118457ac325c3dcbeb62&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;一文带你搭建一套 ELK Stack 日志平台&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;巨人的肩膀&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;https://blog.csdn.net/xzk9381/article/details/109571087&lt;br/&gt;https://www.elastic.co/guide/en/beats/filebeat/current/multiline-examples.html&lt;br/&gt;https://github.com/logstash-plugins/logstash-patterns-core/blob/main/patterns/ecs-v1/grok-patterns&lt;br/&gt;https://www.runoob.com/regexp/regexp-syntax.html&lt;br/&gt;https://www.elastic.co/guide/en/beats/libbeat/current/config-file-permissions.html&lt;br/&gt;https://www.tutorialspoint.com/logstash/logstash_supported_outputs.htm&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6568d51407faf1a71eb1ad2b425aab93</guid>
<title>一文概览 NLP 算法（Python）</title>
<link>https://toutiao.io/k/jbwk2nr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4OTQ1MTA4OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Iefry9dPrYJ1LbaTxqd4VPOibfZ1tf0fXDUqFOLlPcRPvv4W4Cro4YnhRx2Xib5MId5rECtVMBkmvJk8nSNnsekw/0?wx_fmt=png&quot; data-nickname=&quot;数据挖掘工程师&quot; data-alias=&quot;DataMinings&quot; data-signature=&quot;数万名数据挖掘爱好者的聚集地，致力于前沿数据技术研究。公众号以数据为核心，分享大数据、数据分析、机器学习、深度学习等干货，想学数据我等你来。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;NLP&lt;/span&gt;，自然语言处理就是用计算机来分析和生成自然语言（文本、语音），目的是让人类可以用自然语言形式跟计算机系统进行人机交互，从而更便捷、有效地进行信息管理。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;NLP是人工智能领域历史较为悠久的领域，但由于语言的复杂性（语言表达多样性/歧义/模糊等等），如今的发展及收效相对缓慢。比尔·盖茨曾说过，&quot;NLP是 AI 皇冠上的明珠。&quot; 在光鲜绚丽的同时，却可望而不可及（...）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFPUicaMwPQh5L2pQ4GJ6WBb33fU9TKvJRrmypjonjQuh5A59oTiaic4F7kQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了揭开NLP的神秘面纱，本文接下来会梳理下NLP流程、主要任务及算法，并最终落到实际NLP项目（经典的文本分类任务的实战）。&lt;/span&gt;&lt;code&gt;&lt;span&gt;顺便说一句，个人水平有限，不足之处还请留言指出~~&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、NLP主要任务及技术&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;NLP任务可以大致分为词法分析、句法分析、语义分析三个层面。具体的，本文按照单词-》句子-》文本做顺序展开，并介绍各个层面的任务及对应技术。本节上半部分的分词、命名实体识别、词向量等等可以视为NLP基础的任务。下半部分的句子关系、文本生成及分类任务可以看做NLP主要的应用任务。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8193548387096774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFPfWQ9LL3quh012HngTsRFmOPKCP9UfHEX0AQTyqY9p3dxRLUjeAXWLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里，贴一张自然语言处理的技术路线图，介绍了NLP任务及主流模型的分支：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7153225806451613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFPlCibHgLZYibVPfib4GIHgia3oIse5RdnPX7hl1hob6kgNYr3ibVo2GOlzzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;高清图可如下路径下载（原作者graykode）：https://github.com/aialgorithm/AiPy/tree/master/Ai%E7%9F%A5%E8%AF%86%E5%9B%BE%E5%86%8C/Ai_Roadmap&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.1 数据清洗 + 分词（系列标注任务）&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;数据语料清洗。我们拿到文本的数据语料(Corpus)后，通常首先要做的是，分析并清洗下文本，主要用正则匹配删除掉数字及标点符号（一般这些都是噪音，对于实际任务没有帮助），做下分词后，删掉一些无关的词（停用词），对于英文还需要统一下复数、语态、时态等不同形态的单词形式，也就是词干/词形还原。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;分词。即划分为词单元（token），是一个常见的序列标注任务。对于英文等拉丁语系的语句分词，天然可以通过空格做分词，&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10259301014656144&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFPo45Nqrm9xR1N4DtPGlQFzxyPg4S2lbG5kDfQvcg1vFp7wSvSO9d7uQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;887&quot;/&gt;&lt;span&gt;对于中文语句，由于中文词语是连续的，可以用结巴分词（基于trie tree+维特比等算法实现最大概率的词语切分）等工具实现。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import jieba&lt;br/&gt;jieba.lcut(&lt;span&gt;&quot;我的地址是上海市松江区中山街道华光药房&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; [&lt;span&gt;&#x27;我&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;的&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;地址&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;是&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;上海市&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;松江区&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;中山&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;街道&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;华光&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;药房&#x27;&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;英文分词后的词干/词形等还原(去除时态 语态及复数等信息，统一为一个“单词”形态)。这并不是必须的，还是根据实际任务是否需要保留时态、语态等信息，有WordNetLemmatizer、 SnowballStemmer等方法。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;分词及清洗文本后，还需要对照前后的效果差异，在做些微调。这里可以统计下个单词的频率、句长等指标，还可以通过像词云等工具做下可视化~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;from wordcloud import WordCloud&lt;br/&gt;ham_msg_cloud = WordCloud(width =520, height =260,max_font_size=50, background_color =&lt;span&gt;&quot;black&quot;&lt;/span&gt;, colormap=&lt;span&gt;&#x27;Blues&#x27;&lt;/span&gt;).generate(原文本语料)&lt;br/&gt;plt.figure(figsize=(16,10))&lt;br/&gt;plt.imshow(ham_msg_cloud, interpolation=&lt;span&gt;&#x27;bilinear&#x27;&lt;/span&gt;)&lt;br/&gt;plt.axis(&lt;span&gt;&#x27;off&#x27;&lt;/span&gt;) &lt;span&gt;# turn off axis&lt;/span&gt;&lt;br/&gt;plt.show()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5730659025787965&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFPCnhctribqHI47GRtDHjxZb7gtLysgfL0vcWgt3DS2wN1q15WJibuMWbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;698&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.2 词性标注（系列标注任务）&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;词性标注是对句子中的成分做简单分析，区分出分名词、动词、形容词之类。对于句法分析、信息抽取的任务，经过词性标注后的文本会带来很大的便利性（其他方面的应用好像比较少）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;常用的词性标注有基于规则、统计以及深度学习的方法，像HanLP、结巴分词等工具都有这个功能。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5171428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFPI3o6V01WfyAEzKIoPuGYRwaPet51XtImunzNudmia7h8WQWCXppGcibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.3 命名实体识别（系列标注任务）&lt;/h3&gt;&lt;section&gt;&lt;span&gt;命名实体识别（Named Entity Recognition，简称NER）是一个有监督的系列标注任务，又称作“专名识别”，是指识别文本中具有特定意义的实体，主要包括人名、地名、机构名、时间、专有名词等关键信息。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26490984743411927&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFPVjibTzQT2ZIJZtvBzAj1ZXgibEESUAj6PuxNELLmE3B3mfzqiaYskAnxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;721&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过NER识别出一些关键的人名、地名就可以很方便地提取出“某人去哪里，做什么事的信息”，很方便信息提取、问答系统等任务。NER主流的模型实现有BiLSTM-CRF、Bert-CRF，如下一个简单的中文ner项目：https://github.com/Determined22/zh-NER-TF&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.4 词向量（表示学习）&lt;/h3&gt;&lt;section&gt;&lt;span&gt;对于自然语言文本，计算机无法理解词后面的含义。输入模型前，首先要做的就是词的数值化表示，常用的转化方式有2种：One-hot编码、词嵌入分布式方法。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;## 词袋表示&lt;/span&gt;&lt;br/&gt;from sklearn.feature_extraction.text import CountVectorizer&lt;br/&gt;bow = CountVectorizer(&lt;br/&gt;                analyzer = &lt;span&gt;&#x27;word&#x27;&lt;/span&gt;,&lt;br/&gt;                strip_accents = &lt;span&gt;&#x27;ascii&#x27;&lt;/span&gt;,&lt;br/&gt;                tokenizer = [],&lt;br/&gt;                lowercase = True,&lt;br/&gt;                max_features = 100, &lt;br/&gt;                )&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22401847575057737&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFPnYsicxIydyMCLjj4TpiaibQIAbomgnBLloIkf5TVAcvGxEpCwXVqLfL7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;866&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7467741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFP0D1tmfUtHpwDOt0U5EXfw2jNsmZlT21iaQlRibe5rsShjcVZPibIPCdLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# Fasttext embed模型&lt;/span&gt;&lt;br/&gt;from gensim.models import FastText,word2vec&lt;br/&gt;&lt;br/&gt;model = FastText(text,  size=100,sg=1, window=3, min_count=1, iter=10, min_n=3, max_n=6,word_ngrams=1,workers=12)&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(model.wv[&lt;span&gt;&#x27;hello&#x27;&lt;/span&gt;]) &lt;span&gt;# 词向量&lt;/span&gt;&lt;br/&gt;model.save(&lt;span&gt;&#x27;./data/fasttext100dim&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;特别地，正因为Bert等大规模自监督预训练方法，又为NLP带来了春天~&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6074074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFPFgiaLkWpcJvo9PNCj8OHjmu2ibxVdVEMkTML9QcRzsXmNmUMDAYBJsRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12145110410094637&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFPjgiar4OichM0aBibm88UpHQpfiamgialOYmv6uVhRCjChJiawrosb4hvza8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;634&quot;/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# TF-IDF可以直接调用sklearn&lt;/span&gt;&lt;br/&gt;from sklearn.feature_extraction.text import TfidfTransformer&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.5 句法、语义依存分析&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;句法、语义依存分析是传统自然语言的基础句子级的任务，语义依存分析是指在句子结构中分析实词和实词之间的语义关系，这种关系是一种事实上或逻辑上的关系，且只有当词语进入到句子时才会存在。语义依存分析的目的即回答句子的”Who did what to whom when and where”的问题。例如句子“张三昨天告诉李四一个秘密”，语义依存分析可以回答四个问题，即谁告诉了李四一个秘密，张三告诉谁一个秘密，张三什么时候告诉李四一个秘密，张三告诉李四什么。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38303341902313626&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFPIic5ppjiaUR7ZxwpoyiaUghkYqlUZVNibCjiagzXflXjubPglYbficPSiciaAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;389&quot;/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;传统的自然语言处理多是参照了语言学家对于自然语言的归纳总结，通过句法、语义分析可以挖掘出词语间的联系（主谓宾、施事受事等关系），用于制定文本规则、信息抽取（如正则匹配叠加语义规则应用于知识抽取或者构造特征）。可以参考spacy库、哈工大NLP的示例：http://ltp.ai/demo.html&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;随着深度学习技术RNN/LSTM等强大的时序模型（sequential modeling）和词嵌入方法的普及，能够在一定程度上刻画句子的隐含语法结构，学习到上下文信息，已经逐渐取代了词法、句法等传统自然语言处理流程。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.6 相似度算法（句子关系的任务）&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;自然语言处理任务中，我们经常需要判断两篇文档的相似程度（句子关系），比如检索系统输出最相关的文本，推荐系统推荐相似的文章。文本相似度匹配常用到的方法有：文本编辑距离、WMD、 BM2.5、词向量相似度 、Approximate Nearest Neighbor以及一些有监督的(神经网络)模型判断文本间相似度。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48563218390804597&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFP376LgYvQ9l4YbP29uzB0NzgFO8OlxB6kQ9ygD1TvyOeboOnvmCZmWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.7 文本分类任务&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;文本分类是经典的NLP任务，就是将文本系列对应预测到类别。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;分类任务使用预训练+(神经网络)分类模型的端对端学习是主流，深度学习学习特征的表达然后进行分类，大大减少人工的特征。但以实际项目中的经验来看，对于一些困难任务（任务的噪声大），加入些人工的特征工程还是很有必要的。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9222520107238605&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFP8dm5lCiag6QibLzkYT6iaorxGQJexfZU6nqgqo7nRvia0ZQanUhSt1X2Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.8 文本生成任务&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;文本生成也就是由类别生成序列 或者 由序列到序列的预测任务。按照不同的输入划分，文本自动生成可包括文本到文本的生成(text-to-text  generation)、意义到文本的生成(meaning-to-text  generation)、数据到文本的生成(data-to-text  generation)以及图像到文本的生成(image-to-text generation)等。具体应用如机器翻译、文本摘要理解、阅读理解、闲聊对话、写作、看图说话。常用的模型如RNN、CNN、seq2seq、Transformer。&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4689189189189189&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFP82qbJZn3937QYzU4SgAsy23mNhYA8V2th9YVPv55ayeTUPMVt6Y7nw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;740&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同样的，基于大规模预训练模型的文本生成也是一大热门，可见《A Survey of Pretrained Language Models Based Text Generation》&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、垃圾短信文本分类实战&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1 读取短信文本数据并展示&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本项目是通过有监督的短信文本，学习一个垃圾短信文本分类模型。数据样本总的有5572条，label有spam（垃圾短信）和ham两种，是一个典型类别不均衡的二分类问题。&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8300970873786407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFP7eeAO753uhH2YtQO5HUKAEKORVickZZrXfKt500USTicNXH9xR32hY0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;618&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 源码可见https://github.com/aialgorithm/Blog&lt;/span&gt;&lt;br/&gt;import pandas as pd&lt;br/&gt;import numpy as np&lt;br/&gt;import  matplotlib.pyplot as plt&lt;br/&gt;&lt;br/&gt;spam_df = pd.read_csv(&lt;span&gt;&#x27;./data/spam.csv&#x27;&lt;/span&gt;, header=0, encoding=&lt;span&gt;&quot;ISO-8859-1&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 数据展示&lt;/span&gt;&lt;br/&gt;_, ax = plt.subplots(1,2,figsize=(10,5))&lt;br/&gt;spam_df[&lt;span&gt;&#x27;label&#x27;&lt;/span&gt;].value_counts().plot(ax=ax[0], kind=&lt;span&gt;&quot;bar&quot;&lt;/span&gt;, rot=90, title=&lt;span&gt;&#x27;label&#x27;&lt;/span&gt;);&lt;br/&gt;spam_df[&lt;span&gt;&#x27;label&#x27;&lt;/span&gt;].value_counts().plot(ax=ax[1], kind=&lt;span&gt;&quot;pie&quot;&lt;/span&gt;, rot=90, title=&lt;span&gt;&#x27;label&#x27;&lt;/span&gt;, ylabel=&lt;span&gt;&#x27;&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;Dataset size: &quot;&lt;/span&gt;, spam_df.shape)&lt;br/&gt;&lt;br/&gt;spam_df.head(5)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.2 数据清洗预处理&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据清洗在于去除一些噪声信息，这里对短信文本做按空格分词，统一大小写，清洗非英文字符，去掉停用词并做了词干还原。考虑到短信文本里面的数字位数可能有一定的含义，这里将数字替换为‘x’的处理。最后，将标签统一为数值（0、1）是否垃圾短信。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 导入相关的库&lt;/span&gt;&lt;br/&gt;import nltk&lt;br/&gt;from nltk import word_tokenize&lt;br/&gt;from nltk.corpus import stopwords&lt;br/&gt;from nltk.data import load&lt;br/&gt;from nltk.stem import SnowballStemmer&lt;br/&gt;from string import punctuation&lt;br/&gt;&lt;br/&gt;import re  &lt;span&gt;# 正则匹配&lt;/span&gt;&lt;br/&gt;stop_words = &lt;span&gt;set&lt;/span&gt;(stopwords.words(&lt;span&gt;&#x27;english&#x27;&lt;/span&gt;))&lt;br/&gt;non_words = list(punctuation)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 词形、词干还原&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# from nltk.stem import WordNetLemmatizer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# wnl = WordNetLemmatizer()&lt;/span&gt;&lt;br/&gt;stemmer = SnowballStemmer(&lt;span&gt;&#x27;english&#x27;&lt;/span&gt;)&lt;br/&gt;def stem_tokens(tokens, stemmer):&lt;br/&gt;    stems = []&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; token &lt;span&gt;in&lt;/span&gt; tokens:&lt;br/&gt;        stems.append(stemmer.stem(token))&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; stems&lt;br/&gt;&lt;br/&gt;&lt;span&gt;### 清除非英文词汇并替换数值x&lt;/span&gt;&lt;br/&gt;def clean_non_english_xdig(txt,isstem=True, gettok=True):&lt;br/&gt;    txt = re.sub(&lt;span&gt;&#x27;[0-9]&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;x&#x27;&lt;/span&gt;, txt) &lt;span&gt;# 去数字替换为x&lt;/span&gt;&lt;br/&gt;    txt = txt.lower() &lt;span&gt;# 统一小写&lt;/span&gt;&lt;br/&gt;    txt = re.sub(&lt;span&gt;&#x27;[^a-zA-Z]&#x27;&lt;/span&gt;, &lt;span&gt;&#x27; &#x27;&lt;/span&gt;, txt) &lt;span&gt;#去除非英文字符并替换为空格&lt;/span&gt;&lt;br/&gt;    word_tokens = word_tokenize(txt) &lt;span&gt;# 分词&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; not isstem: &lt;span&gt;#是否做词干还原&lt;/span&gt;&lt;br/&gt;        filtered_word = [w &lt;span&gt;for&lt;/span&gt; w &lt;span&gt;in&lt;/span&gt; word_tokens &lt;span&gt;if&lt;/span&gt; not w &lt;span&gt;in&lt;/span&gt; stop_words]  &lt;span&gt;# 删除停用词&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;        filtered_word = [stemmer.stem(w) &lt;span&gt;for&lt;/span&gt; w &lt;span&gt;in&lt;/span&gt; word_tokens &lt;span&gt;if&lt;/span&gt; not w &lt;span&gt;in&lt;/span&gt; stop_words]   &lt;span&gt;# 删除停用词及词干还原&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; gettok:   &lt;span&gt;#返回为字符串或分词列表&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; filtered_word&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;.join(filtered_word)&lt;br/&gt;&lt;br/&gt;spam_df[&lt;span&gt;&#x27;token&#x27;&lt;/span&gt;] = spam_df.message.apply(lambda x:clean_non_english_xdig(x))&lt;br/&gt;spam_df.head(3)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 数据清洗&lt;/span&gt;&lt;br/&gt;spam_df[&lt;span&gt;&#x27;token&#x27;&lt;/span&gt;] = spam_df.message.apply(lambda x:clean_non_english_xdig(x))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 标签整数编码&lt;/span&gt;&lt;br/&gt;spam_df[&lt;span&gt;&#x27;label&#x27;&lt;/span&gt;] = (spam_df.label==&lt;span&gt;&#x27;spam&#x27;&lt;/span&gt;).astype(int)&lt;br/&gt;&lt;br/&gt;spam_df.head(3)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1811965811965812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFP3zhRVU4fsZyCxcNBgB9sVFyl9DhFcHW029iaOHloGDiap1a9FnGqzUSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;585&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.3 fasttext词向量表示学习&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们需要将单词文本转化为数值的词向量才能输入模型。词向量表示常用的词袋、fasttext、bert等方法，这里训练的是fasttext，模型的主要输入参数是，输入分词后的语料（通常训练语料越多越好，当现有语料有限时候，直接拿github上合适的大规模预训练模型来做词向量也是不错的选择），词向量的维度size（一个经验的词向量维度设定是，dim &amp;gt; 8.33 logN, N为词汇表的大小，当维度dim足够大才能表达好这N规模的词汇表的含义。可参考《# 最小熵原理（六）：词向量的维度应该怎么选择？By 苏剑林》）。语料太大的时候可以使用workers开启多进程训练（其他参数及词表示学习原理后续会专题介绍，也可以自行了解）。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 训练词向量 Fasttext embed模型&lt;/span&gt;&lt;br/&gt;from gensim.models import FastText,word2vec&lt;br/&gt;&lt;br/&gt;fmodel = FastText(spam_df.token,  size=100,sg=1, window=3, min_count=1, iter=10, min_n=3, max_n=6,word_ngrams=1,workers=12)&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(fmodel.wv[&lt;span&gt;&#x27;hello&#x27;&lt;/span&gt;]) &lt;span&gt;# 输出hello的词向量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# fmodel.save(&#x27;./data/fasttext100dim&#x27;)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4583333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFPv9FN92I06P9v9wtRNaUiaCaarGvxZhyNd2icL2pnAnibL69522IxXrpUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;648&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;按照句子所有的词向量取平均，为每一句子生成句向量。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fmodel = FastText.load(&lt;span&gt;&#x27;./data/fasttext100dim&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#对每个句子的所有词向量取均值，来生成一个句子的vector&lt;/span&gt;&lt;br/&gt;def build_sentence_vector(sentence,w2v_model,size=100):&lt;br/&gt;    sen_vec=np.zeros((size,))&lt;br/&gt;    count=0&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt; sentence:&lt;br/&gt;        try:&lt;br/&gt;            sen_vec+=w2v_model[word]&lt;span&gt;#.reshape((1,size))&lt;/span&gt;&lt;br/&gt;            count+=1&lt;br/&gt;        except KeyError:&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; count!=0:&lt;br/&gt;        sen_vec/=count&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; sen_vec&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 句向量&lt;/span&gt;&lt;br/&gt;sents_vec = []&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; sent &lt;span&gt;in&lt;/span&gt; spam_df[&lt;span&gt;&#x27;token&#x27;&lt;/span&gt;]:&lt;br/&gt;    sents_vec.append(build_sentence_vector(sent,fmodel,size=100))&lt;br/&gt;        &lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(len(sents_vec))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.4 训练文本分类模型&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;示例采用的fasttext embedding + lightgbm的二分类模型，类别不均衡使用lgb代价敏感学习解决（即class_weight=&#x27;balanced&#x27;），超参数是手动简单配置的，可以自行搜索下较优超参数。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;### 训练文本分类模型&lt;/span&gt;&lt;br/&gt;from sklearn.model_selection import train_test_split&lt;br/&gt;from lightgbm import LGBMClassifier&lt;br/&gt;from sklearn.linear_model import LogisticRegression&lt;br/&gt;&lt;br/&gt;train_x, test_x, train_y, test_y = train_test_split(sents_vec, spam_df.label,test_size=0.2,shuffle=True,random_state=42)&lt;br/&gt;result = []&lt;br/&gt;clf = LGBMClassifier(class_weight=&lt;span&gt;&#x27;balanced&#x27;&lt;/span&gt;,n_estimators=300, num_leaves=64, reg_alpha= 1,reg_lambda= 1,random_state=42)&lt;br/&gt;&lt;span&gt;#clf = LogisticRegression(class_weight=&#x27;balanced&#x27;,random_state=42)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;clf.fit(train_x,train_y)&lt;br/&gt;&lt;br/&gt;import pickle&lt;br/&gt;&lt;span&gt;# 保存模型&lt;/span&gt;&lt;br/&gt;pickle.dump(clf, open(&lt;span&gt;&#x27;./saved_models/spam_clf.pkl&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;wb&#x27;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 加载模型&lt;/span&gt;&lt;br/&gt;model = pickle.load(open(&lt;span&gt;&#x27;./saved_models/spam_clf.pkl&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;rb&#x27;&lt;/span&gt;))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.5 模型评估&lt;/h3&gt;&lt;p&gt;&lt;span&gt;训练集测试集按0.2划分，分布验证训练集测试集的AUC、F1score等指标，均有不错的表现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3773148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eyibF6kJBjTtASicPiczBT5iboIV1e2tjkFPezMLia0ocXWRWvYZHClgnFhm5F0vhalaOs92cOBD9Z2EmhLD7qa0Jiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;from sklearn.metrics import auc,roc_curve,f1_score,precision_score,recall_score&lt;br/&gt;def model_metrics(model, x, y,tp=&lt;span&gt;&#x27;auc&#x27;&lt;/span&gt;):&lt;br/&gt;    &lt;span&gt;&quot;&quot;&quot; 评估 &quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;    yhat = model.predict(x)&lt;br/&gt;    yprob = model.predict_proba(x)[:,1]&lt;br/&gt;    fpr,tpr,_ = roc_curve(y, yprob,pos_label=1)&lt;br/&gt;    metrics = {&lt;span&gt;&#x27;AUC&#x27;&lt;/span&gt;:auc(fpr, tpr),&lt;span&gt;&#x27;KS&#x27;&lt;/span&gt;:max(tpr-fpr),&lt;br/&gt;               &lt;span&gt;&#x27;f1&#x27;&lt;/span&gt;:f1_score(y,yhat),&lt;span&gt;&#x27;P&#x27;&lt;/span&gt;:precision_score(y,yhat),&lt;span&gt;&#x27;R&#x27;&lt;/span&gt;:recall_score(y,yhat)}&lt;br/&gt;    &lt;br/&gt;    roc_auc = auc(fpr, tpr)&lt;br/&gt;&lt;br/&gt;    plt.plot(fpr, tpr, &lt;span&gt;&#x27;k--&#x27;&lt;/span&gt;, label=&lt;span&gt;&#x27;ROC (area = {0:.2f})&#x27;&lt;/span&gt;.format(roc_auc), lw=2)&lt;br/&gt;&lt;br/&gt;    plt.xlim([-0.05, 1.05])  &lt;span&gt;# 设置x、y轴的上下限，以免和边缘重合，更好的观察图像的整体&lt;/span&gt;&lt;br/&gt;    plt.ylim([-0.05, 1.05])&lt;br/&gt;    plt.xlabel(&lt;span&gt;&#x27;False Positive Rate&#x27;&lt;/span&gt;)&lt;br/&gt;    plt.ylabel(&lt;span&gt;&#x27;True Positive Rate&#x27;&lt;/span&gt;)  &lt;span&gt;# 可以使用中文，但需要导入一些库即字体&lt;/span&gt;&lt;br/&gt;    plt.title(&lt;span&gt;&#x27;ROC Curve&#x27;&lt;/span&gt;)&lt;br/&gt;    plt.legend(loc=&lt;span&gt;&quot;lower right&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; metrics&lt;br/&gt;&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;train &#x27;&lt;/span&gt;,model_metrics(clf,  train_x, train_y,tp=&lt;span&gt;&#x27;ks&#x27;&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;test &#x27;&lt;/span&gt;,model_metrics(clf, test_x,test_y,tp=&lt;span&gt;&#x27;ks&#x27;&lt;/span&gt;))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4OTQ1MTA4OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Iefry9dPrYJ1LbaTxqd4VPOibfZ1tf0fXDUqFOLlPcRPvv4W4Cro4YnhRx2Xib5MId5rECtVMBkmvJk8nSNnsekw/0?wx_fmt=png&quot; data-nickname=&quot;数据挖掘工程师&quot; data-alias=&quot;DataMinings&quot; data-signature=&quot;数万名数据挖掘爱好者的聚集地，致力于前沿数据技术研究。公众号以数据为核心，分享大数据、数据分析、机器学习、深度学习等干货，想学数据我等你来。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4OTQ1MTA4OQ==&amp;amp;mid=2247500946&amp;amp;idx=1&amp;amp;sn=35d33828ff50f373709086a636eb4964&amp;amp;chksm=fdcfdeaccab857babe6ce58dfc0444ffc58cac52a28c23774e14a6126a685103e492d1e2e395&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2021科大讯飞-车辆贷款违约预测赛事 Top1方案（Python代码）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;2021科大讯飞-车辆贷款违约预测赛事 Top1方案（Python代码）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4OTQ1MTA4OQ==&amp;amp;mid=2247500459&amp;amp;idx=1&amp;amp;sn=8e15c48bc67abdc03caa649689479140&amp;amp;chksm=fdcfd895cab85183fb6a03ac22f9804b973ebea2e96a5d153a062067a6fe6c1e241b2aeb7b0a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;10 种聚类算法的完整 Python 操作示例&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;10 种聚类算法的完整 Python 操作示例&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4OTQ1MTA4OQ==&amp;amp;mid=2247500259&amp;amp;idx=2&amp;amp;sn=e52aa3206765ab55d7ebc89d8ba4a29c&amp;amp;chksm=fdcfdbddcab852cbb2a9763745871ed2a266b1f997f1e37b52d2db244dbc6faa1f61f5aa1548&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;为什么回归问题用MSE？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;为什么回归问题用MSE？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4OTQ1MTA4OQ==&amp;amp;mid=2247500237&amp;amp;idx=1&amp;amp;sn=c15c8ef92403c01730a5ee3a28c487d0&amp;amp;chksm=fdcfdbf3cab852e5f17b75b8a0ac72cb0b9754c609dc3ea91fc45617b067e8be5f5657709a17&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;时序特征相关系数的稳定性分析(附代码)&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;时序特征相关系数的稳定性分析(附代码)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4OTQ1MTA4OQ==&amp;amp;mid=2247499891&amp;amp;idx=1&amp;amp;sn=53f97dd57de38f9e27bf3f5c18180e36&amp;amp;chksm=fdcfda4dcab8535b8cd129d90dd40927f2f33c6039d2dbe921fc1daae45f84fb3bf9f80bdc99&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;时间序列预测方法汇总：从理论到实践（附Kaggle经典比赛方案）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;时间序列预测方法汇总：从理论到实践（附Kaggle经典比赛方案）&lt;/a&gt;&lt;/p&gt;&lt;/pre&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>