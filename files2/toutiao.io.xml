<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8983495f420775dba53d3c4e7b8eeaec</guid>
<title>用 Go + WebSocket 快速实现一个 chat 服务</title>
<link>https://toutiao.io/k/b594ozj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;go-zero&lt;/code&gt; 开源之后，非常多的用户询问是否可以支持以及什么时候支持 &lt;code&gt;websocket&lt;/code&gt;，终于在 &lt;code&gt;v1.1.6&lt;/code&gt; 里面我们从框架层面让 &lt;code&gt;websocket&lt;/code&gt; 的支持落地了，下面我们就以 &lt;code&gt;chat&lt;/code&gt; 作为一个示例来讲解如何用 &lt;code&gt;go-zero&lt;/code&gt; 来实现一个 &lt;code&gt;websocket&lt;/code&gt; 服务。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;整体设计&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以 &lt;code&gt;zero-example&lt;/code&gt; 中的 &lt;code&gt;chat&lt;/code&gt; 聊天室为例来一步步一讲解 &lt;code&gt;websocket&lt;/code&gt; 的实现，分为如下几个部分：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;多客户端接入&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息广播&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端的及时上线下线&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全双工通信【客户端本身是发送端，也是接收端】&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先放一张图，大致的数据传输：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5599393019726859&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg3qOlg7URdzLpW8LmEMN30w45nQic8woU8Bne3ficVLTheOB8lfeUR60em6rgFGwMMhHbCCb44BC1cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;659&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中间有个 &lt;code&gt;select loop&lt;/code&gt; 就是整个 &lt;code&gt;chat&lt;/code&gt; 的 &lt;code&gt;engine&lt;/code&gt;。首先要支撑双方通信：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;得有一个交流数据的管道。客户端只管从 &lt;em&gt;管道&lt;/em&gt; 读取/输送数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端在线情况。不能说你下线了，还往你那传输数据；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据流&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据流是 &lt;code&gt;engine&lt;/code&gt; 的主要功能，先不急着看代码，我们先想 &lt;code&gt;client&lt;/code&gt; 怎么接入并被 &lt;code&gt;engine&lt;/code&gt; 感知：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先是从前端发 &lt;code&gt;websocket&lt;/code&gt; 请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;建立连接；准备接收/发送通道；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注册到 &lt;code&gt;engine&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.181992337164751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg3qOlg7URdzLpW8LmEMN30wDPKY8MvYxBnKGTVwEhzn4uBL90OmibwesrVeFFAgvG1E8vFPqe2UTFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;522&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// HTML 操作 {js}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (window[&lt;span&gt;&quot;WebSocket&quot;&lt;/span&gt;]) {&lt;br/&gt;  conn = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;&quot;ws://&quot;&lt;/span&gt; + document.location.host + &lt;span&gt;&quot;/ws&quot;&lt;/span&gt;);&lt;br/&gt;  conn.onclose = function (evt) {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; item = document.createElement(&lt;span&gt;&quot;div&quot;&lt;/span&gt;);&lt;br/&gt;    item.innerHTML = &lt;span&gt;&quot;&amp;lt;b&amp;gt;Connection closed.&amp;lt;/b&amp;gt;&quot;&lt;/span&gt;;&lt;br/&gt;    appendLog(item);&lt;br/&gt;  };&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 路由&lt;/span&gt;&lt;br/&gt;engine.AddRoute(rest.Route{&lt;br/&gt;  Method: http.MethodGet,&lt;br/&gt;  Path:   &lt;span&gt;&quot;/ws&quot;&lt;/span&gt;,&lt;br/&gt;  Handler: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    internal.ServeWs(hub, w, r)&lt;br/&gt;  },&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 接入逻辑&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ServeWs&lt;/span&gt;&lt;span&gt;(hub *Hub, w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 将http请求升级为websocket&lt;/span&gt;&lt;br/&gt; conn, err := upgrader.Upgrade(w, r, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt; ...&lt;br/&gt;  &lt;span&gt;// 构建client：hub{engine}, con{websocker conn}, send{channel buff}&lt;/span&gt;&lt;br/&gt; client := &amp;amp;Client{&lt;br/&gt;  hub:  hub,&lt;br/&gt;  conn: conn,&lt;br/&gt;  send: &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;, bufSize),&lt;br/&gt; }&lt;br/&gt; client.hub.register &amp;lt;- client&lt;br/&gt;  &lt;span&gt;// 开始客户端双工的通信，接收和写入数据&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; client.writePump()&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; client.readPump()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，新接入的 &lt;code&gt;client&lt;/code&gt; 就被加入到 &lt;em&gt;注册&lt;/em&gt; 通道中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;hub engine&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发出了 &lt;em&gt;注册&lt;/em&gt; 的动作，&lt;code&gt;engine&lt;/code&gt; 会怎么处理呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Hub &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; clients &lt;span&gt;map&lt;/span&gt;[*Client]&lt;span&gt;bool&lt;/span&gt;  &lt;span&gt;// 上线clients&lt;/span&gt;&lt;br/&gt; broadcast &lt;span&gt;chan&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;    &lt;span&gt;// 客户端发送的消息 -&amp;gt;广播给其他的客户端&lt;/span&gt;&lt;br/&gt; register &lt;span&gt;chan&lt;/span&gt; *Client     &lt;span&gt;// 注册channel，接收注册msg&lt;/span&gt;&lt;br/&gt; unregister &lt;span&gt;chan&lt;/span&gt; *Client   &lt;span&gt;// 下线channel&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(h *Hub)&lt;/span&gt; &lt;span&gt;Run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 注册channel：存放到注册表中，数据流也就在这些client中发生&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; client := &amp;lt;-h.register:&lt;br/&gt;   h.clients[client] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 下线channel：从注册表里面删除&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; client := &amp;lt;-h.unregister:&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; _, ok := h.clients[client]; ok {&lt;br/&gt;    &lt;span&gt;delete&lt;/span&gt;(h.clients, client)&lt;br/&gt;    &lt;span&gt;close&lt;/span&gt;(client.send)&lt;br/&gt;   }&lt;br/&gt;    &lt;span&gt;// 广播消息：发送给注册表中的client中，send接收到并显示到client上&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; message := &amp;lt;-h.broadcast:&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; client := &lt;span&gt;range&lt;/span&gt; h.clients {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; client.send &amp;lt;- message:&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;     &lt;span&gt;close&lt;/span&gt;(client.send)&lt;br/&gt;     &lt;span&gt;delete&lt;/span&gt;(h.clients, client)&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;接收注册消息 -&amp;gt; 加入全局注册表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;engine.broadcast&lt;/code&gt; 接收到，会将 &lt;code&gt;msg&lt;/code&gt; 传递给 &lt;em&gt;注册表&lt;/em&gt; 的 &lt;code&gt;client.sendChan&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样从 &lt;strong&gt;HTML -&amp;gt; client -&amp;gt; hub -&amp;gt; other client&lt;/strong&gt; 的整个数据流就清晰了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;广播数据&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说到 &lt;code&gt;engine.broadcast&lt;/code&gt; 接收到数据，那从页面开始，数据是怎么发送到这？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;readPump&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;  _, message, err := c.conn.ReadMessage()&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;error: %v&quot;&lt;/span&gt;, err)&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  message = bytes.TrimSpace(bytes.Replace(message, newline, space, &lt;span&gt;-1&lt;/span&gt;))&lt;br/&gt;    &lt;span&gt;// 2.&lt;/span&gt;&lt;br/&gt;  c.hub.broadcast &amp;lt;- message&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从 &lt;code&gt;conn&lt;/code&gt; 中不断读取 &lt;code&gt;msg&lt;/code&gt;【页面点击后传递】&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 &lt;code&gt;msg&lt;/code&gt; 传入 &lt;code&gt;engine.broadcast&lt;/code&gt;，从而广播到其他的 &lt;code&gt;client&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当出现发送异常或者是超时，异常退出时，会触发下线 &lt;code&gt;client&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时要知道，此时发送消息的 &lt;code&gt;client&lt;/code&gt; 不止有一个，可能会有很多个。发送到其它 client，client 从自己的 &lt;code&gt;send channel&lt;/code&gt; 中读取消息即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;writePump&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 写超时控制&lt;/span&gt;&lt;br/&gt; ticker := time.NewTicker(pingPeriod)&lt;br/&gt;  ...&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; message, ok := &amp;lt;-c.send:&lt;br/&gt;      &lt;span&gt;// 当接收消息写入时，延长写超时时间。&lt;/span&gt;&lt;br/&gt;   c.conn.SetWriteDeadline(time.Now().Add(writeWait))&lt;br/&gt;   ...&lt;br/&gt;   w, err := c.conn.NextWriter(websocket.TextMessage)&lt;br/&gt;   ...&lt;br/&gt;   w.Write(message)&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// 依次读取 send 中消息，并write&lt;/span&gt;&lt;br/&gt;   n := &lt;span&gt;len&lt;/span&gt;(c.send)&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++ {&lt;br/&gt;    w.Write(newline)&lt;br/&gt;    w.Write(&amp;lt;-c.send)&lt;br/&gt;   }&lt;br/&gt;      ...&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &amp;lt;-ticker.C:&lt;br/&gt;   c.conn.SetWriteDeadline(time.Now().Add(writeWait))&lt;br/&gt;   ...&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面也说了，&lt;code&gt;send&lt;/code&gt; 有来自各自客户端中发送的msg：所以当检测到 &lt;code&gt;send&lt;/code&gt; 有数据，就不断接收消息并写入当前 client；同时当写超时，会检测websocket长连接是否还存活，存活则继续读 &lt;code&gt;send chan&lt;/code&gt;，断开则直接返回。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;完整示例代码&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/zeromicro/zero-examples/tree/main/chat&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章从使用上介绍如何结合 &lt;code&gt;go-zero&lt;/code&gt; 开始你的 &lt;code&gt;websocket&lt;/code&gt; 项目，开发者可以按照自己的需求改造。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 &lt;code&gt;go-zero&lt;/code&gt; 更多的设计和实现文章，可以持续关注我们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/tal-tech/go-zero&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎使用 go-zero 并 &lt;strong&gt;star&lt;/strong&gt; 支持我们！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;微信交流&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3be7f50dc08405e6217847edd219b0fd</guid>
<title>使用 Git 丢失代码的 N 种操作，您中招了吗？</title>
<link>https://toutiao.io/k/oa4amzb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;摘要：无意翻出这篇写于两年前的手稿，当时交付的几家私有云大客户以及公有云客户均频繁遇到此问题，虽然现象千奇百怪，但是无非是错误的操作导致的代码丢失，秉承着开放、自由、分享的开源精神，把相关的错误操作整理出来并加以说明，对于新老用户都是一种引导，不仅可以避免给团队带来麻烦，也使自己能够更好的理解 Git 的一些运作方式，所以整理成文，希望能够帮助到有需要的人，尤其是公司内部研发流程的培训上，更应该关注这一类误操作的普及和说明，避免「不了解」给团队带来的麻烦。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt; “我们丢了好多天的代码，你们靠不靠谱啊？！？！？？”&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt; “你们平台怎么搞的！我们代码莫名其妙丢了！”&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt; “我们公司的一些文件莫名其妙被回退了，能帮我们看看吗？”&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt; “本来这些文件夹里面都有代码的，现在没了，你告诉我不是你们平台的问题？”&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt; “昨天本来还好好的，今天代码就都没了”&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每当收到这些反馈，我都非常紧张，紧张并不是因为 Gitee 平台真的有什么问题，而是在想该怎么向用户去解释，怎么帮用户复盘问题，怎么帮用户处理这种问题。紧张的同时也在深深的埋怨 Linus 先生，为什么不把 Git 的这些操作设计的更简单一些（虽然已经很简单了）…&lt;/p&gt;&lt;p&gt;Gitee 上线近八年，接收到的类似的反馈数不胜数，但是归根究底，造成这些现象的根源在于对 Git 的不熟悉，对自己操作后的结果没有预期，于是饮了一口浓茶，望着窗外陷入了深深的沉思，复盘这些各种各样的情况，其实无外乎「4」种操作导致的：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;使用 Git 进行推送的时候进行了强推操作&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不正确的 Merge 操作造成的文件版本回退&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将某些目录意外搞成了子模块，也就是 Git SubModule&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一不小心删除了远程某些分支甚至仓库，刚好本地都没备份，造成丢失&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;突然我心里一阵激动：作为国内用户最多的速度最快的企业最认可的大家最满意的代码托管和研发协作平台，不能再低调了，我们有义务有责任将这些不正确的操作整理成文，剖析每一种操作，让大家能够了解并且避免这些情况，尤其是对于刚接触 Git 的朋友们，更应该注意和清楚这些操作，避免自己给团队带来不必要的麻烦，好，既然这样，那维护代码世界的和平就靠我了。&lt;/p&gt;&lt;p&gt;于是，抄起电脑，开始了我的复盘之路…&lt;/p&gt;&lt;p&gt;复盘过程中的截图会同时有命令行以及图形化界面，尽可能的符合大部分读者的场景。&lt;/p&gt;&lt;h3&gt;No.1 强推操作&lt;/h3&gt;&lt;h4&gt;• 问题背景&lt;/h4&gt;&lt;p&gt;在推送的时候往往会遇到远程仓库的版本领先于自己本地的版本，这个时候如果我们执行推送操作，就会看到 Git 给到我们的提示：&lt;/p&gt;&lt;p&gt;命令行： &lt;img data-ratio=&quot;0.25444596443228457&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5ycM1UGcbkeC1IumL9ILrficD29QPTbHFiaYSteibQ5CHViaFZzRDjVgV1vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;GUI 界面： &lt;img data-ratio=&quot;0.33288948069241014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yibMCFP2hAThKzxvjIPNreWSNbCsEfck0m4foma6kUbHLepKbQeLmiaYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1502&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;这个时候很多刚接触Git的新手看到&lt;code&gt;error&lt;/code&gt;就会懵掉，甚至根本都不会去看提示，就会去网上搜&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;hint: Updates were rejected because the tip &lt;span class=&quot;code-snippet__keyword&quot;&gt;of&lt;/span&gt; your current...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;于是很兴奋的发现找到了解决方案&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.20634920634920634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yw3e8fNaLNniaZQ8SicjEXaPic5LqAUKyOtjPQmom4O2MxhnqicOMHPgRAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1512&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;跟着答案在命令行加上了 -f 参数，或者图形化界面选中了 Force&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;git&lt;/span&gt; push origin master -f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2727272727272727&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yseORJla1oKiaocDNOJMM7bPb2nkiaTXt8r5XP4C2UZTzP5aCibt0euFKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1320&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;然后执行命令或者点击 Push 按钮，发现居然成功了，开心！&lt;/p&gt;&lt;p&gt;命令行：&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.27734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yawew9iabrt0PkC1MKDrdoAjbL1YxAOkkaGXJ4XvWhjbl97pYnrs3Nlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;图形界面： &lt;img data-ratio=&quot;0.3940345368916798&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yBbiaxA9qC8iaiaVmCAZiaXLQElr8uRCcLgOCWuWjq3qnqlVs4Koz9CzC7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;但是，人生大起大落是非常刺激的，还没开心多久，发现工作群已经炸锅了&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt; “刚刚谁做了操作，我代码呢？”&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt; “我发现我的也没有了”&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt; “什么情况”&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt; “我*！谁把代码覆盖了”&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt; “咋回事？？？”&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt; “@新手，Gitee 上的动态显示是你强推的，为什么啊！？！？”&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.16798732171156894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5y4OPIUPAG2zNmuJ4XA69nsiashfXfobOI10H3C7MialWXGpYD6HqDwwnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1262&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;h4&gt;• 原因剖析&lt;/h4&gt;&lt;p&gt;看到自己名字被@的那一瞬间，是不是并没有初恋般的心动，而是小时候打碎玻璃被发现的心慌？&lt;/p&gt;&lt;p&gt;没错，就是&lt;code&gt;-f&lt;/code&gt;的问题，加了这个参数就是强制推送，如果在命令行推送的时候加了 -f 的参数，或者在图形化界面选择了强制推送的选项，就会把远程的版本强制替换为自己本地的版本，而别人之前推送的提交如果不在自己本地的那个版本里，就会造成丢失的现象。&lt;/p&gt;&lt;p&gt;可以观察下强制推送的结果是有&lt;code&gt;(forced update)&lt;/code&gt;提示的，并且搜索的结果里注意看的话，别人已经说了&lt;code&gt;with -f tag you will override Remote Branch code.&lt;/code&gt;，加上这个参数将会覆盖掉远程分支的代码。&lt;/p&gt;&lt;h4&gt;• 解决方式&lt;/h4&gt;&lt;p&gt;怎么解决这种问题呢，其实Git在操作的时候已经给出了提示：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;Integrate&lt;/span&gt; the remote changes (e.g.&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;git pull ...&#x27;&lt;/span&gt;) before pushing again.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;再次尝试推送之前，请合并远程的变更到你本地（使用 git pull）&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;我们在发现有冲突的时候可以尝试合并远端的变更到本地，合并之后即可正常推送到远端，合并的方式也非常简单，就如正常拉取代码一样，执行&lt;code&gt;git pull origin master&lt;/code&gt;命令即可，唯一不同的就是需要进行一次合并操作，或者如果出现冲突需要解决完冲突再行进行合并，这里假设无冲突，来执行一下&lt;code&gt;git pull origin master&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2777017783857729&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yBmmiaicia76uZsYhLdELFziaNANupURJ9NJw8bic3xl5oZGdUAGH3aEWwWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;终端弹出了合并的提示，这是为当前的一次合并提交填写 Commit 信息的，我们默认即可，保存退出即可完成一次合并操作。&lt;/p&gt;&lt;p&gt;与终端不一样的是，GUI 界面在可以自动合并的情况下，默认是自动合并的：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2937853107344633&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yk7NHoggnCiau5C1Dv4ibuCibd8aS23ibwoKUIde1ZS37S0Mny8rAAjQfKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1062&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;合并之后我们就可以正常推送了，图形界面也一样的操作，这里不再赘述&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3009575923392613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yVqibjOEVdbwicQlnr91b80sbwjPPxlQ7S4DcuMtP4vBFRibIibpvpI3Jsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;当然，这种合并方式会产生一次额外的合并提交，如果你不想有多余的合并提交的话，可以参见 rebase 命令：https://git-scm.com/docs/git-rebase&lt;/p&gt;&lt;h4&gt;• 更好的方式&lt;/h4&gt;&lt;p&gt;更好的方式当然是禁止强推，目前 Gitee 平台支持设置仓库禁止强推，从源头避免强推导致的各种问题。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.29454022988505746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yj03FpQ4HaP4ibRYPqZzT8JNkZ96FUs5rdiaSI1Mfiatvh2AuNfs55y0SQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1392&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果您是自建的 Git 服务的话，可以使用 &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; 设置项进行单仓库或者全局的设置，如果要全局禁用强推，可以在服务端执行：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;git&lt;/span&gt; config --system receive.denyN&lt;span&gt;on&lt;/span&gt;FastForwards &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不过，工具只是辅助，最主要的还是要提升团队每个开发者对 Git 的认识，才能更好的协作。&lt;/p&gt;&lt;h3&gt;No.2 错误的 Merge 方式&lt;/h3&gt;&lt;h4&gt;• 问题背景&lt;/h4&gt;&lt;p&gt;上面我们有说到，当遇到冲突的时候需要合并远端到本地，才能继续进行推送的操作，但是上面的例子是并没有任何冲突的理想情况下，但事实经常事与愿违，在开发过程中，文件之间的冲突是不可避免的，所以经常会遇到 Git 不能够自动合并的情况，所以我们需要自己进行代码的合并，通过对代码上下文以及业务的理解，合并出团队所「期望」的代码。&lt;/p&gt;&lt;p&gt;命令行： &lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.48046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yNFvT1sneib7WM1EF1VicNkwOYU26x1KmMgKERNeHHwnw3UU3pHRHCu3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;图形界面： &lt;img data-ratio=&quot;0.2468265162200282&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5ylUXQqMtKiaMXgfDkl6jnNSluFf0BrUpjWcwwksjiav3VgySK9cadHADg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1418&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;正常情况下，我们会对冲突的文件进行内容上的修复，并且在确认修复完成后提交到暂存区，通过提交合并的方式创建一个合并的提交，完成本次合并即可，过程如下图：&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.365625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5y6udAmbwXKRsMP7UAze0vEdZcrUklHQnYz6gUiakDGlIydcPosKDqfXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;稍微对上图做些说明：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;从第4个提交开始，我们衍生出了&lt;code&gt;dev&lt;/code&gt;分支进行分支开发&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;同时&lt;code&gt;master&lt;/code&gt;分支也有相应的提交&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;dev&lt;/code&gt;分支上做了7、8两次提交，分别在&lt;code&gt;b.txt&lt;/code&gt;文件新增了第六行&lt;code&gt;L6&lt;/code&gt;和第七行&lt;code&gt;L7&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;同时&lt;code&gt;master&lt;/code&gt;分支上也做了5、6两次提交，在&lt;code&gt;a.txt&lt;/code&gt;新增了第九行&lt;code&gt;L9&lt;/code&gt;，分别在&lt;code&gt;b.txt&lt;/code&gt;文件新增了第六行&lt;code&gt;L5&lt;/code&gt;和第七行&lt;code&gt;L6&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;然后&lt;code&gt;dev&lt;/code&gt;分支合并到&lt;code&gt;master&lt;/code&gt;分支，由于两个分支都新增了&lt;code&gt;b.txt&lt;/code&gt;文件的第六行&lt;code&gt;L6&lt;/code&gt;，所以需要进行冲突合并，得出合并后的&lt;code&gt;b.txt&lt;/code&gt;文件的第六行&lt;code&gt;L6&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最后，执行 &lt;code&gt;git add . &amp;amp;&amp;amp; git commit -m &quot;merge dev into master&quot;&lt;/code&gt; 等操作完成本次合并，生成第9次提交&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;推送到远端的&lt;code&gt;master&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;整个过程是常规的合并操作，是一种标准实践了，但是上线的那天晚上，当团队复核代码的时候发现，最新版本的&lt;code&gt;a.txt&lt;/code&gt;的&lt;code&gt;L9&lt;/code&gt;变更不见了！&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt; “有人覆盖了 &lt;span&gt;a&lt;/span&gt;&lt;span&gt;.txt&lt;/span&gt; 代码？”&lt;br/&gt;&amp;gt; “喂，你在线？之前提交的 &lt;span&gt;a&lt;/span&gt;&lt;span&gt;.txt&lt;/span&gt; 代码呢？”&lt;br/&gt;&amp;gt; “Zoker，帮忙看看我们团队投产的时候，发现有一些代码不见了，紧急！”&lt;br/&gt;....&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现场看起来是这样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yWLoicKATibfcrF9uIRrFaJdYU9sbDicd2hibibicVT2hkbiaJgaeUdUU0jpuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;• 原因剖析&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我记得当年排查这个问题的时候也觉得非常诡异，后来才发现这种问题的复现方式，还是通过现场反向推断出来的，因为后来发现做合并提交&lt;code&gt;9&lt;/code&gt;的这位同事使用的是图形化工具，于是在模拟了他的一系列操作之后，终于发现了端倪，原因是因为：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在处理完冲突进行合并的时候，并未选中所有的文件，这些未选中的文件就被回退到被合并的分支的版本，而命令行没问题是因为默认无冲突的文件都被添加进暂存区了&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;不好理解？我们来看看命令行执行完&lt;code&gt;git pull&lt;/code&gt;之后的状态：&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.48046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yNFvT1sneib7WM1EF1VicNkwOYU26x1KmMgKERNeHHwnw3UU3pHRHCu3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;其中&lt;code&gt;a.txt&lt;/code&gt;由于无冲突，默认添加进暂存区等待提交了，当我们处理完&lt;code&gt;b.txt&lt;/code&gt;冲突之后，只需要执行&lt;code&gt;git add b.txt&lt;/code&gt;或者&lt;code&gt;git add .&lt;/code&gt;就可以进行下一步提交了。但是，如果我们把暂存区的&lt;code&gt;a.txt&lt;/code&gt;移除掉呢？比如恢复到工作区&lt;code&gt;git restore --staged a.txt&lt;/code&gt;:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5ynicNDUCRLa4AchKjOqtFWjqROqhtHdyUaDh37PCEqtejOH4tIQPgJog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果是这个状态，我们最终的合并提交的化，&lt;code&gt;a.txt&lt;/code&gt;就会被回退到&lt;code&gt;dev&lt;/code&gt;分支上的版本，换句话说就是，在&lt;code&gt;dev&lt;/code&gt;分支衍生出来之后的&lt;code&gt;master&lt;/code&gt;分支上的&lt;code&gt;a.txt&lt;/code&gt;改动会丢失。&lt;/p&gt;&lt;p&gt;但是，在命令行合并的时候我们关注的都是冲突的文件，并不会人为的去变更默认加入暂存区的文件，所以一般情况下不会出问题，那么图形化工具在合并的时候是如何造成这种问题呢？看看下面这张图：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9315068493150684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yjjiaBkSUYbicLo82IzqVOiaib7ZlN6NMaYvPEfeefibN6iaj3QDYlPjdFn4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1314&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;在合并完&lt;code&gt;b.txt&lt;/code&gt;准备提交的时候，把默认选中的&lt;code&gt;a.txt&lt;/code&gt;取消掉了，再进行提交就会导致&lt;code&gt;a.txt&lt;/code&gt;所增加的那一行被回退，而且使用&lt;code&gt;git log a.txt&lt;/code&gt;去查看还看不到那次提交，一次小小的点击，换来一次大大的教训。&lt;/p&gt;&lt;p&gt;再深一层的理解的话，由于合并的时候暂存区的&lt;code&gt;tree&lt;/code&gt;对象指向的是最新版本的&lt;code&gt;a.txt^Blob 对象&lt;/code&gt;，把它从暂存区移除，就相当于暂存区的&lt;code&gt;tree&lt;/code&gt;对象指回了老版本的&lt;code&gt;a.txt^Blob 对象&lt;/code&gt;，理解起来的话就如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yoMrh9ZYTO1GbPH2LibPNwkJTBIlI6lA0twth2zspqLvjxG0sa3SQMJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h4&gt;• 解决方式&lt;/h4&gt;&lt;p&gt;解决方式就比较简单了，在进行合并的时候，无论是使用命令行还是图形化界面，一定注意不要对暂存区的文件进行操作，除非你非常清楚的知道你在做什么，否则在处理完冲突之后，请确保添加了所有未冲突的文件以及解决了冲突的文件到暂存区！&lt;/p&gt;&lt;h3&gt;No.3 误触子模块&lt;/h3&gt;&lt;h4&gt;• 问题背景&lt;/h4&gt;&lt;p&gt;经常会收到用户说：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt; 为什么我的这个目录在 Gitee 上打不开？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt; 为什么我本地这个目录明明有代码，在服务器上拉取的时候这个目录是空的？&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;他们在 Gitee 上看到的是这样的：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2644444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yeNLvhxbYdI8sYm6cRD0kqv9HebBZPEOdR4w7Zj8Gm80CyEvAuLFNOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里的&lt;code&gt;lib&lt;/code&gt;目录是无法点击的，而且当我们克隆这个仓库的时候，这个目录也是空的，但明明我本地提交的时候是有东西的啊，为什么呢？&lt;/p&gt;&lt;h4&gt;• 原因剖析&lt;/h4&gt;&lt;p&gt;所有上述的现象都是因为有&lt;code&gt;Git Submodule&lt;/code&gt;的存在，因为在往仓库添加&lt;code&gt;lib&lt;/code&gt;文件夹的时候，&lt;code&gt;lib&lt;/code&gt;文件夹本身就是一个 Git 仓库，当我们直接复制到仓库里面去提交的时候，Git 其实是会有提示的，只不过可惜的是大部分人都不会关注这些警告：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4223013048635824&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yoFABc2TpqLBXYw4dVxhWjcylvdG6ZY7P7YykG38j8ygnmyhOW6XuRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1686&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;虽然依旧可以提交成功，但是就会造成网页上无法打开，克隆下来的时空目录的问题。&lt;/p&gt;&lt;h4&gt;• 解决方式&lt;/h4&gt;&lt;p&gt;仔细查看上图 Git 给的提示，可以知道&lt;code&gt;lib&lt;/code&gt;本身就是一个 Git 仓库了。&lt;/p&gt;&lt;p&gt;方法一：如果我们本意并不是要以一个单独的 Git 仓库管理&lt;code&gt;lib&lt;/code&gt;目录的话，我们可以单纯的删除掉&lt;code&gt;lib&lt;/code&gt;目录下的&lt;code&gt;.git&lt;/code&gt;文件夹，让&lt;code&gt;lib&lt;/code&gt;成为一个单纯的目录，再行提交就不会有问题了。&lt;/p&gt;&lt;p&gt;方法二：如果确实需要单独以一个子模块的形式进行&lt;code&gt;lib&lt;/code&gt;目录的管理，那么我们可以按照提示给&lt;code&gt;lib&lt;/code&gt;目录配置上子模块：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.38125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yVFiawIkjP9Qwoml0IJiaSY7w8wxzXwcoNEbSBhLuO1DfaLFh95VFIYcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;然后按照常规的提交操作进行提交推送即可，这个时候我们再看看 Gitee 网页上是如何展示的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.30703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5y9IIKkXoxYG9V35lslKg3oJG4SRQBiaLpH1KzId5OM20vJzxThQyibA5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;克隆的时候，如果需要&lt;code&gt;lib&lt;/code&gt;目录的话，只需要在克隆之后执行&lt;code&gt;git submodule update --init&lt;/code&gt;即可&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.13997627520759193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yZl0oHNy2lpYm3uBUl58e4eviabnpKYSMCeJFEF5FVITibUJLqTArDt1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1686&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里需要注意的是&lt;code&gt;lib&lt;/code&gt;算是一个独立的仓库，它的权限也是独立的，所以说如果有一些目录并不是所有开发都需要，并且是比较核心的库之类的话，试试使用子模块来管理权限也是个不错的选择。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Git Submodule 手册: https://git-scm.com/book/en/v2/Git-Tools-Submodules&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;No.4 意外删除&lt;/h3&gt;&lt;h4&gt;• 问题背景&lt;/h4&gt;&lt;p&gt;有时候难免会脑子抽风，一不小心删除了某个分支或者删除了某个仓库，那该怎么办呢？&lt;/p&gt;&lt;h4&gt;• 解决方式&lt;/h4&gt;&lt;p&gt;1、分支误删除&lt;/p&gt;&lt;p&gt;在 Gitee 上如果一不小心删除了某个分支，不要慌，只需要找到对应分支的&lt;code&gt;Commit ID&lt;/code&gt;即可，Gitee 在动态里给出了这个信息，为的就是给操作一点空间，在相关的游离对象没有被 GC 之前，赶紧去找回来吧！&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.10465116279069768&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yB9jib4IlYtla0NZOy81WW0icNJRXXEWKK5gYoSRIT6WStXZ5iarTpA1Sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1548&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;拿到这个&lt;code&gt;Commit ID&lt;/code&gt;，我们就可以在本地或者网页上重建一个基于此&lt;code&gt;Commit ID&lt;/code&gt;的分支，这样分支就找回来了。&lt;/p&gt;&lt;p&gt;2、仓库误删除（这是广告）&lt;/p&gt;&lt;p&gt;把 Gitee 上的仓库删除了，刚好本地有没有保存，还有没有办法？&lt;/p&gt;&lt;p&gt;答案是：如果你使用了 Gitee 企业版，那么你是可以找回的，Gitee 企业版提供了仓库快照的功能，能够定期的对仓库打快照，并且能够恢复任一快照的完整的仓库，快照的创建时间为最近三周的周末以及最近半年的每月第一个周末，就算误删，也能找回。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.971830985915493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrIdcTeXodb58ZQkNTsOTK5yu1hebbuyAvGIr2l3U5nhVWP63td2jRibiajCD0Nh8ePJ2Uf9lWCriclEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;p&gt;赶快来体验 Gitee 企业版：https://gitee.com/enterprises&lt;/p&gt;&lt;h3&gt;最后&lt;/h3&gt;&lt;p&gt;其实防止代码出问题的最好的办法，就是每个团队成员都能够了解 Git，了解自己在每一次操作之后发生了什么，自己是否能够知道预期的结果，所以最好是能够在前期就进行充分的培训以及注意事项的引导，团队的开发出现代码版本问题的现象将会大大降低。&lt;/p&gt;&lt;p&gt;那么，除了以上常见的几种方式，你还遇到过哪些丢代码的骚操作？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.33046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bcma1ubkXrJ3rMw1ABEbfDpJiaicxNRUB0mdn1lp8zTia1JaicLrZS0uQrD0zkvcfJib91l0WGmxHwTIkD6yCL6hyFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;转载请保留出处：微信公众号「Zoker 随笔」（zokersay）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c3865d3842291b7f520639e4de0c5da5</guid>
<title>喝口可乐聊聊可扩展性设计</title>
<link>https://toutiao.io/k/jrcl0sb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot;&gt;      可扩展性要达到的目的就是在扩展软件功能、增加项目运行时性能的时候，能尽量少的去改动原有的代码，架构等，基于这个目的，我们在架构设计的时候，需要做到下面的标准。&lt;/p&gt;&lt;p data-lake-id=&quot;d6eca464f68f630b330ecbba1d3596b2&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;d48ab1d15ac05e90a95fa88fdbbc0aff&quot;&gt;0x1 可扩展性设计标准&lt;/h3&gt;&lt;ol data-lake-id=&quot;d6ef9ac4f2441ff69cca002686072d94&quot; start=&quot;1&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;代码功能模块之间耦合度尽量低，比如插件化设计&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;源码结构性好，层次，目录分明&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;遵守正向性设计，纵向切割功能模块，封装成单独的服务&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-lake-id=&quot;d5e1ec577e08b60616a43dc48c59722a&quot;&gt;上面是标准，那可以用什么手段去达到上面的标准呢？&lt;/p&gt;&lt;p data-lake-id=&quot;876ffaf47fef27a7dfc8a345d8220388&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;00205f7991bfa86e26cdb5843cca10b1&quot;&gt;0x2 可扩展性设计的手段&lt;/h3&gt;&lt;ol data-lake-id=&quot;7a98056a5844300c2bcab9cd703cd4b0&quot; start=&quot;1&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;面向源码接口编程，每一个功能模块都有固定的调用接口，模块之间只要按照规范调用接口就可以了，不用关心实现。类似interface，implement的设计，如依赖注入，代理模式等设计模式，一些著名的开源项目往往会应用上多种设计模式，就是这个目的。不过我相信不少coder用设计模式主是为了“优雅”，”扩展性设计“只是一个附带的效果，毕竟这样才显得逼格比较高，“优雅”是玄学，等于是“我不喜欢钱，但是钱自然就赚了”,  &lt;span&gt;&lt;strong&gt;就问你&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;牛不牛 strings.Sprintf(&quot;A%sC&quot;, ?)   // 牛*好像是敏感词，请自行格式化这个字符串&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-lake-id=&quot;3ad06f6ab2647ae8e95dd0888f098ecb&quot;&gt;&lt;/p&gt;&lt;ol data-lake-id=&quot;0f4cc3d924af0ccdb23d82a13d7dae8b&quot; start=&quot;2&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;源码结构这个要视不同的项目而定，例如我们web开发在前后端分离之前的主流架构MVC（现在还有很多web项目是采用MVC架构的），就是按照M-V-C三层去组织代码，通常实现了MVC架构的框架源码架构如下：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9314285714285714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yetTcGWJiakPWbSAcLtuxCg23icn66vASgasKq0b02cfAe0kzKKWGUbicK4Y2XwcMobHxrHbMlBxU8qHCOuE7ibyoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p data-lake-id=&quot;c61e7f508da3932051d4fce6ac920370&quot;&gt;在这样架构分明的源码之下，随着业务需求的发展，想扩展哪块功能都能明确指向源码的哪个模块，利好项目的扩展性。&lt;/p&gt;&lt;p data-lake-id=&quot;7e6083c45d875299db30a705b5497def&quot;&gt;&lt;/p&gt;&lt;ol data-lake-id=&quot;6fc3644c147d185205978d3954b336cf&quot; start=&quot;3&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;第三点基本上就是微服务的味道了，我们都知道微服务的初衷就是为了让服务隔离，使不同的服务之间减少耦合度，单独为本身的功能负责，通过标准的调用方式供其他服务调用。从利于扩展性设计的角度来看，服务要纵向切割，纵向就表现深度自治，各自管理自己独立的某一类型的功能模块，比如一个电商系统，订单、商品、用户可以单独分为三个不同的服务，当只需要修改订单功能时，我们只需要动订单的服务代码仓库就好。项目运行时，当商品服务的并发比较大的时候，我们可以只增加商品服务的服务节点资源就好（当然由此而带来的其他架构设计、代码复杂度等问题不在此讨论范围内）。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-lake-id=&quot;df7cf5dc2661cf13fa3cadf87d3c0203&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;bef26a6622d12a399b248e5d8f664765&quot;&gt;0x3 总结&lt;/h3&gt;&lt;p data-lake-id=&quot;cd6bafdc13e89b358c190f3fd2c2a474&quot;&gt;可扩展性设计本人觉得总结来说，基本的标准是有的，不过具体也要看具体的项目而具体分析，需要根据项目本身的业务需求而去权衡这个“可扩展性设计”的&lt;span&gt;&lt;strong&gt;度&lt;/strong&gt;&lt;/span&gt;究竟在哪里，毕竟凡事都得有个度，你写个“hello world&quot;你也扯什么“扩展性设计”那就没啥意思了，本文只是抛砖引玉，是自己的一些总结，不足之处多多包涵，期盼指导共同进步，打完收工。&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;1&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yetTcGWJiakOuzNDpuiajaFfeqefR9vjOZNfFH0ibJ33aqnVyBUkvcZ7VQC3Aao8ZtodM864qOC9dnic4uIRic2wiaYA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;分享科学人文随笔&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;感谢您「观看」、「点赞」和「关注」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点个在看你最好看~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1fb585560be961aec00f16cd81802a97</guid>
<title>什么是 API 文档工具？附带 6 款好用的 API 文档工具介绍</title>
<link>https://toutiao.io/k/9khbqbw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;blog-content&quot;&gt;&lt;p&gt;从零编写API文档既耗时又复杂，因此大多数企业都依赖API文档工具来简化这些工作。 API文档工具有助于自动化创建和管理文档，并以易于阅读和理解的方式帮助用户去格式化和显示信息，即使对于没有技术背景的用户也能轻松使用。&lt;/p&gt;
&lt;p&gt;但是，哪种工具更适合用来撰写和存放您业务相关的API文档？ 在本文中，我们探讨了API文档存在的意义，并列举了当前可用的五个最佳API文档工具，以及它们是如何符合您的业务要求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.pexels.com/photos/285814/pexels-photo-285814.jpeg?auto=compress&amp;amp;cs=tinysrgb&amp;amp;h=750&amp;amp;w=1260&quot; alt=&quot;API电脑图片&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;为什么API文档很重要&lt;/h2&gt;
&lt;p&gt;API文档是人类和计算机可读的技术内容，解释了特定API的工作方式和功能。其目的有两个，它首先是详细描述API的准确参考资料。其次，它可以充当指导和教学工具，帮助用户入门和使用它。&lt;/p&gt;
&lt;p&gt;如果使用得当，API文档将成为API工作原理的唯一真实信息来源。它应以结构化的格式包含有关函数，参数，类等的详细信息，以使开发人员和非技术用户都易于理解。通常，它将包括教程和示例，这将帮助用户更好地了解不同部分如何协同工作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.投入时间和资源来创建高质量的API文档会带来很多好处：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.缩短培训指导过程–客户和内部用户可以访问这些API文档并使用API所需的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.减少对技术支持的依赖–好的文档可以减轻API技术人员的压力，并帮助其他用户找到自己的答案。无论您的API是仅供内部使用还是被成千上万的客户使用，API均适用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4.鼓励非技术员工–通过提高对非编程同事的理解，API文档可以帮助开发人员们更好地讨论如何使用API工具和数据实现业务目标。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5.提高采用率–易于使用的API文档将提高新用户开始使用您的API的速度和粘性。通过提供更好的用户体验，企业将受益于越来越多的好评和用户积极反馈，从而加快了用户对产品的采用速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;6.更高的用户满意度–满意的客户和同事可以帮助您的企业提高声誉。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;什么是构成了顶级API文档工具的元素？&lt;/h2&gt;
&lt;p&gt;创建出色的API文档是在提供详细的技术信息与以易于使用的方式显示信息之间的保持一种微妙的平衡。了解如何做到最好的方法是看一些业绩良好企业的API示例-值得庆幸的是，这些企业并不难找到。&lt;/p&gt;
&lt;p&gt;许多流行的工具都会在线上发布其API文档，以便第三方开发人员可以轻松访问和使用它们。 Stripe和Twilio是正确完成文档的两个很好的例子。尽管他们的解决方案是内部开发的，但是它们显示的最佳实践对于希望创建自己的API文档的企业仍然有用。以下是这些文档如此有效的一些原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.他们在文档中提供了示例代码，以便用户可以看到它在实践中的工作方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.通过它们，可以轻松找到常见问题的解决方案，以便繁忙的开发人员可以快速获得所需的东西。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.他们没有提供理解API及其工作原理所不需要的不必要信息。当用户忙于工作并遇到问题时，他们需要可用的文档，而不是多余的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4.他们不具备一定的知识水平-最简单的概念与最困难的概念一样得到充分的解释。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5.它们格式正确。内容井井有条，一致且易于阅读。这为希望学习或解决问题的用户减少了摩擦。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;哪种编写规范最佳？&lt;/h2&gt;
&lt;p&gt;编写API文档的方法不只一种，而且不同的软件使用不同的规范。这些规范各自提供了描述API的不同标准和样式。最受欢迎的是以下三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.OpenAPI（以前称为Swagger）–最受欢迎的规范。开源，并得到Microsoft和Google等公司的支持。使用具有特定架构的JSON对象来描述API元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.RAML–基于YAML的RAML（或RESTful API建模语言）采用自上而下的方法来创建清晰，一致和精确的文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.API Blueprint–另一个开放源代码规范，API蓝图旨在提供高度可访问性。它使用类似于Markdown的描述语言，并且在API创建过程中遵循设计优先原则的情况下表现出色。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管所有这些选项都能正常工作，但OpenAPI格式在过去几年中获得了最大的发展。在拥有大品牌的支持下，它迅速发展了一个庞大的社区，随后拥有了最广泛的工具。对于不确定要遵循哪种规范的企业，这是一个不错的选择，因为如果您遇到困难，可以选择的范围更广，获得社区支持的机会也更大。&lt;/p&gt;
&lt;h2&gt;5种最佳API文档工具&lt;/h2&gt;
&lt;p&gt;市场上不乏API文档工具。以下是我们筛选出的最佳API文档工具：&lt;/p&gt;
&lt;h3&gt;Swagger UI&lt;/h3&gt;
&lt;p&gt;Swagger UI是一款用于创建交互式API文档的流行工具。用户输入OpenAPI规范（OAS）文档后，Swagger UI会使用HTML，JavaScript和CSS对其进行格式设置，以创建美观易读性强的文档。&lt;/p&gt;
&lt;p&gt;Swagger UI是Swagger生态系统的一部分，其中包括各种各样的工具，其中许多是开源的（包括Swagger UI）以及高级版本（SwaggerHub）。&lt;/p&gt;
&lt;p&gt;它的优势在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.完全自定义定制–用户可以访问完整的源代码，并且可以调整Swagger UI以适合其使用，或者利用其他用户的调整。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.支持OAS 3.0 –与OpenAPI规范版本3.0以及旧版Swagger 2.0一起使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.非常受用户喜欢–如果遇到问题，很容易从其他用户那里获得支持。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Swagger还提供了其他开源工具，通过帮助创建它使用的OpenAPI规范（OAS）文档来补充Swagger UI的不足。 Swagger编辑器使用户可以创建自己的OAS定义，然后可以使用Swagger UI对其进行可视化，而Swagger Inspector则使用户可以从API端点自动生成OAS定义。&lt;/p&gt;
&lt;h3&gt;SwaggerHub&lt;/h3&gt;
&lt;p&gt;SwaggerHub是一个付费API文档工具，结合了Swagger UI，Swagger编辑器以及Swagger生态系统的许多其他功能。它面向企业和企业用户，并包含旨在优化文档工作流程的许多其他功能。&lt;/p&gt;
&lt;p&gt;它的优势在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.一次性打包安装–与Swagger UI不同，SwaggerHub提供了完整的API文档工具集，而无需查找其他软件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.自动生成API文档– SwaggerHub使用户可以在设计过程中自动生成交互式API文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.优化协作流程–权限和用户角色，实时评论，问题跟踪和团队管理工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与Swagger UI和此列表中的许多其他选项不同，SwaggerHub是付费解决方案。但是，对于严重依赖API的大型企业来说，这可能是值得的投资。&lt;/p&gt;
&lt;h3&gt;ReDoc&lt;/h3&gt;
&lt;p&gt;ReDoc是一个免费的开源文档工具，支持OAS 2.0和OAS 3.0。使用ReDoc，企业可以快速在线发布美观的交互式API文档。&lt;/p&gt;
&lt;p&gt;它的优势在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.灵活性强– ReDoc可以在您的浏览器中运行，但也可以作为Docker映像，React组件或命令行工具使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.反应灵敏–美观的主题具有完全灵敏的效果，并且可以在任何屏幕尺寸或浏览器上很好地工作。此外，您可以自定义字体，更改颜色并轻松添加徽标。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.轻松导航–可自定义的导航栏和搜索框使用户可以快速找到所需的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;DapperDox&lt;/h3&gt;
&lt;p&gt;DapperDox是可与OAS 2.0和OAS 3.0一起使用的开源OpenAPI渲染器。&lt;/p&gt;
&lt;p&gt;它的优势在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.集成Markdown内容– DapperDox使用户能够将其OpenAPI规范与使用GFM（GitHub Flavored Markdown）创建的图表结合起来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.文档排版清晰– DapperDox文档写得很清楚，对新用户很有帮助。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.API资源管理器– DapperDox的API资源管理器使用户可以从API文档中进行实验。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;OpenAPI生成器&lt;/h3&gt;
&lt;p&gt;OpenAPI Generator是一个易于使用的工具，用于生成OAS 2.0和OAS 3.0文档以及服务器存根和库的文档。它以相对简单易用（不牺牲功能）和高度可扩展（例如，它支持50多个客户端生成器）而闻名。&lt;/p&gt;
&lt;p&gt;它的优势在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.社区支持– OpenAPI Generator拥有大量经验丰富的用户，他们可以讨论和使用它，并且在创建文档时可以成为宝贵的资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.服务器存根– OpenAPI Generator使用户可以为40多种不同的语言（包括PHP，Java和GO）创建服务器存根。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.文档格式优化–将OAS文档转换为HTML或Cwiki格式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;使用DreamFactory更好地管理API文档&lt;/h2&gt;
&lt;p&gt;DreamFactory使用Swagger为您创建的每个API生成实时API文档。将DreamFactory用于API文档有以下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.自动化更新–您的团队可以确信您的文档始终是最新的并且是正确的。无需等待繁忙的开发人员来更新您的文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.支持第三方导入–使用第三方API？没问题。您可以将其OAS文档导入DreamFactory，以便您的用户可以像访问您自己的文档一样对其进行访问和查看。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.管理人员特权– DreamFactory通过确保只有具有DreamFactory管理员特权的开发人员才能修改它们，从而防止了您的文档编制。其他用户只能查看它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4.智能互动-您的团队可以在启动API的几秒钟内访问实时互动文档。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文档只是使DreamFactory成为最终的API即服务平台的众多企业级功能之一。使用DreamFactory，可以轻松创建，管理和记录数十甚至数百个REST API。DreamFactory使企业可以在几秒钟内创建专业的功能齐全的REST API，具有高度的安全性，并可以从一个平台集中管理每个API。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://api.kuaidi100.com/blog/detail/APIWoRLDLTsTlD5DAPIJsQs.html&quot;&gt;1.如果你想要了解关于API发展的前景，可以阅读这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://api.kuaidi100.com/blog/detail/SMSdsAPIzSTnjSjdl12ZyYhC.html&quot;&gt;2.如果你想要的了解电商支持类的API，如快递物流，仓储管理，用户精细化运营等等，这篇文章更适合你阅读&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aa48a3401b17eff821fabe610f465c35</guid>
<title>从低代码到无代码：可视化逻辑编排</title>
<link>https://toutiao.io/k/or08588</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                                    


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;近年来，关于低代码（LowCode）和无代码（NoCode）的讨论在前端社区内越来越火，简单的说低代码就是通过编写少量代码的方式完成应用的开发及上线，而无代码则更进一步，不需要编写代码通过配置的方式即可完成整个应用的开发。目前集团内部的低代码平台已经有很多，比如iceluna，宜搭，乐高，云凤蝶等等，而通用的无代码搭建平台还处在探索阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;低代码和无代码&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先不管是低代码还是无代码，都是针对特定场景或者细分领域的，比如运营的活动页，中后台的表单，表格页面等，因为只有在这些场景下，前端交互相对收敛，能够沉淀出足够多的组件物料，从而通过可视化的方式拖拽组件就能够直接搭建出页面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前我所在的团队正在研究面向营销域的中后台前端解决方案。通常来说，中后台解决方案的核心目标是提效，提效包括两个方面，一方面是对研发人员的提效，另一方面是对用户的提效，提效的核心抓手在于生产关系的变更，由前端开发向后端，视觉，产品各方面参与发展，从而降低前端研发的门槛，提高生产效率。提效解决的不是20%的个性化增量需求，而是解决让“非前端”参与进来，解决80%的通用需求。中后台的提效路径大部分走的都是ProCode-&amp;gt;LowCode-&amp;gt;NoCode方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表面上看，从ProCode-&amp;gt;LowCode-&amp;gt;NoCode看起来好像只有很小的差别，好像只有代码量多少的问题，但整个过程已经从量变发生了质变。ProCode和LowCode主要面向的还是一些需要有前端编程能力的人，而NoCode则代表“非前端”也能够参与的前端的页面搭建中来，这里面不是说完全不需要代码，因为今天哪些算“代码”其实比较难界定，比如用户编写一个配置文件，这个文件是json格式的，那到底能不能算“代码”？所以，NoCode的意思不是说没有代码，而是说在于用户学习门槛和学习成本的降低，普通用户不需要经过艰难的学习就可以做到以前程序要编码才能实现的事情。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;iceluna 低代码平台的痛点问题&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;iceluna作为集团内优秀的低代码搭建平台，主要解决中后台页面快速搭建的场景，经过几年的探索，基本能够实现页面UI的可视化搭建，但是针对业务逻辑还是需要手动编码来实现。这对非前端开发人员的上手门槛还是比较高的。下面这张图是最近针对iceluna的用户（前端，后端和测试）做的一个调研分析，可以看到逻辑代码和数据绑定的学习成本也是用户在问卷中提的最多的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3036053130929791&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QTNzZR6KeD9sEHfhsSYCW1erqhQSUhUEu0xd8eWsqr4MAFSMPiah6afexHwFZet2SG2DNicf6Q0gpwu0iam77NDoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1054&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此在这个财年，我们尝试去用可视化逻辑编排的方式解决逻辑相关的问题，解决低代码中最后一点需要编码的部分，实现无代码化的研发模式，从而进一步降低用户的学习和使用门槛。&lt;/span&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;可视化逻辑编排&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来通过一个逻辑编排的示例来看一下如果一段代码通过编排的方式呈现出来之后会带来怎么样的体感：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.3950892857142858&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QTNzZR6KeD9sEHfhsSYCW1erqhQSUhUEh9yXsD5QesDds5GB8xLHr1WjNqaHlsAticia6RNPPfd9THNrwichgc9bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;448&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;如上图所示，原本晦涩难懂的代码逻辑通过流程图的形式表达出来以后，产品的逻辑变得非常直观。可读性和可维护性也变得非常高。再也不用担心在接手其他人的项目时，注释不规范，文档不全的问题，逻辑编排生成的逻辑图谱就是天然的产品文档。&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;逻辑节点抽象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，要形成这样的逻辑图谱，本质上就是需要对不同逻辑节点进行组合和串联，真正的逻辑由封装在节点中的函数完成。那么这里就产生了两个问题，首先是如何抽象逻辑节点，抽象出的逻辑节点能不能被复用直接决定了用户编排的成本，如果需要不断的定制个性化逻辑节点可能就失去了编排的意义；其次是逻辑节点的的颗粒度大小也非常关键，如果封装的逻辑颗粒度太大，大到一个功能服务，那么可能就变成了业务流程编排；如果颗粒度太小，小到一个表达式级别，那么对于有编程基础的同学来说，可能直接写代码效率反而更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过对中后台营销域的部分业务代码进行梳理，发现中后台的页面大都是以表单、列表，详情为主，而其中90%的业务逻辑基本上都围绕在表单(校验，取值，赋值，提交)，对话框（显隐、提示），发送请求，消息提示，数据处理，路由跳转，条件判断等，相对比较收敛。同时iceluna作为集团内优秀的低代码搭建平台，在上层封装了很多非常好用的api，屏蔽了大部分前端语法层面的差异，比如状态赋值，页面刷新，接口调用，一些常用的工具函数（时间处理）等，为逻辑节点的抽象提供了极大的便利性。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0985915492957747&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QTNzZR6KeD9sEHfhsSYCW1erqhQSUhUEr8ZLJGLf1zbJic9WzofYibDaRyCK4DCiaxUZBxW8sYRia1nKFJicD1lOkOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1136&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;通过分析归类，最后沉淀了10个左右的逻辑节点，如下图所示，同时每一个逻辑节点最终本质上都是对应一段执行函数，并接收一个参数作为入参，返回一个参数作为出参。&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.66953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QTNzZR6KeD9sEHfhsSYCW1erqhQSUhUEF8D9onk3mdsxhfg7qfTiaWVyMzWvBslHHsa1DbrRw8QaXmicWl3iahDSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;编排协议&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于是可视化编排，自然也避免不了编排的协议，为了避免重复建设最大程度的复用集团内已有的编排方案，最终计划采用LF通用可视化逻辑编排的协议来实现iceluna中的逻辑编排。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.08125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QTNzZR6KeD9sEHfhsSYCW1erqhQSUhUEvgGW1EYWHr61WH6fAsfcsXgYqZaY91jLFkvv335YNHLH1ZcGLI3dug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;技术架构图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7914951989026063&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QTNzZR6KeD9sEHfhsSYCW1erqhQSUhUEic3zpQu46BsibbMfa9z9MS8UHibIicoALggD1vlhHo0RasNfwibHP93QQ2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;729&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;技术难点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;自动化布局&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从一开始调研我们就发现大部分的编排产品，都是让用户自己进行拖拽，连线等操作去完成，但是通过前面对逻辑代码的分析，如果我们将异步回调操作使用async/await的方式转换成同步的写法，那么逻辑代码大部分都可以看作是一种串行式的执行过程，偶尔叠加一些if/else的分支判断，这样也非常符合人们常用的思维模式，理解起来非常直观。所以从编排的角度说，就是将不同的逻辑节点和分支判断节点串联起来，布局上不需要太多的灵活性，同时连线操作也显得比较多余，因此我们将拖拽连线全部改成添加节点的方式，然后自动连线即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用这种自动布局的方式会大大简化用户的操作，用户只需关注核心的业务逻辑流程，按顺序添加节点即可，但同时也带来一个问题，由于分支类型的节点会产生两个分支流，如果遇到嵌套分支的情况下，需要自动将上层分支的横坐标的位置统一向右偏移一个单位，否则处在上下层不同分支上的节点位置可能会产生重叠。为此，我设计了一自动布局算法，最终实现的效果图如下：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.322&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QTNzZR6KeD9sEHfhsSYCW1erqhQSUhUEKUiaiaPdNKNSGl050R0icEshnJQh0DXKu5LA8XT2oicDD4S4VABUzBDDQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;算法过程比较简单，采用的是DFS深度优先遍历算法，详细过程这里就不再赘述。&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码与schema互转&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;逻辑图编排完成之后，紧接着面临的问题是如何保证编排后的逻辑正确的运行，产生和源码一样的效果。一开始讨论的有两种方案，第一种方案把整个逻辑看成一个事件流，按照前面设计的逻辑编排schema，通过事件注册监听的方式完成逻辑节点的上下游串联，最后设计一套事件执行器，依次触发事件即可。这种方式实现起来比较简单，但是对原有开发流程的侵入性比较强。因为原有保存事件函数的地方都要被替换成逻辑schema，同时负责code review的前端同学看到的不再是代码diff，而是schema的diff，这无疑会大大增加了CR的风险。因此经过一番讨论之后，我们决定采用第二种方案，将逻辑编排后的schema自动转成代码，同时生成后的代码也要能够自动转回schema。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于schema转成代码是比较容易的，因为每个逻辑节点本身就映射了一段函数片段，而将代码转回schema则稍微有些复杂。这里主要利用了Babel先对代码进行解析，得到抽象语法树AST，然后遍历AST中类型为statement的节点，最后通过正则匹配找到对应的逻辑节点，并串联好连线即可。下图就是生成好的一份代码示例：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7053872053872053&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QTNzZR6KeD9sEHfhsSYCW1erqhQSUhUEAVexGtz9Lv1ibibBMk4ThUZh4aDWwURLgyhCyf0h0d52BbeOS8xy2uiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;可以看出，通过schema生成后的代码与源码编写还是有一点区别，带有一些逻辑编排的特征，但是可读性更强，从代码基本也能直观的反推出逻辑流程图，反而从一定程度上降低了code review的成本。整个AST解析的过程如下：&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2955223880597015&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QTNzZR6KeD9sEHfhsSYCW1erqhQSUhUEJg5x8quY0NJkYcTkHDt0sn0LZc7ia0HSpVXQjSgMtbyyA9KLUGia5fog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1005&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;断点调试&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于写业务逻辑来说，不可避免的需要调试功能，这对有编程能力的同学来说是件很自然的事情，但是当逻辑变成通过可视化的编排之后，如何让这些”非前端“用户也能方便的通过调试定位错误，变得也尤为关键。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调试其实本质上对用户来说，就是需要一个能够让编排后的逻辑模拟运行起来的过程，因此我们对逻辑节点的各个环节做了埋点，用户在模拟运行的过程中就能查看每个节点的数据状态、上下文参数、报错类型等，同时根据逻辑流程图的状态（绿色代表执行成功，红色代表执行失败）也能非常快速的定位问题所在，如下图所示：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.626890756302521&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QTNzZR6KeD9sEHfhsSYCW1erqhQSUhUEV4qZW36b5bm6llJrOovhoxwUFtqCFia1DzmwUyGbqjYBd9nWHfr3iaIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1190&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;目前调试功能还处在初级阶段，后面还会持续迭代优化，比如调试时增加单步执行功能，像浏览器的单步调试工具一样进行断点。&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，可视化逻辑编排已经搭载集团内的iceluna低代码搭建平台正式上线，并已经在营销工具业务中正式使用。从低代码向无代码的研发模式升级仍处在探索阶段，过程中避免不了会遇到很多问题，但也算迈出了关键性的一步，值得期待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-id=&quot;2988&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;展望&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面提到，从ProCode-&amp;gt;LowCode-&amp;gt;NoCode，通过降低研发门槛，让非技术人员参与到应用开发中来，可以大大提高生产效率，但理想很丰满，现实也很骨感，NoCode搭建平台我认为目前还只能在比较垂直的场景中才能适用，并且由于不像LowCode一样仍然能够写代码的逃离机制，通过NoCode的方式可能只能完成一个70分左右的产品。但是换一个角度去看，如果可以让一个非技术人员，只用很低的门槛就完成一个70分左右的产品(最小可用产品MVP)，并能直接推广到市场去试错，如果验证可行，再通过转成LowCode或者ProCode的方式继续迭代优化。光这一点我认为就是很有价值的，是推动商业创新的核心驱动力。因此我认为未来的产品研发节奏可能是从NoCode-&amp;gt;LowCode-&amp;gt;ProCode，每一流程都要有对应的解决方案，并且互相之间能够相互打通，只有这样才能在竞争日益激烈的市场环境下更好的生存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/QRibyjewM1IDyNjH7utBYKcx4rU8TibvibUllx1z6XWibibibcZK1wPnoEQydCrlPhCl1IRpJrAGRxWEyUcIMToV4Afg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;344&quot;/&gt;       &lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.01&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/QRibyjewM1IDSqFg3R8M2jd1UZLoGxQASDUt80ATXQI1XfUnLjRXyvhy9AuLtHKdrJMr6R2CkSpKyHhVlesPzTw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注&lt;/span&gt;&lt;span&gt;「Alibaba F2E」&lt;/span&gt;&lt;span&gt;微信公众号（左）微信视频号（右）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;把握阿里巴巴前端新动向&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>