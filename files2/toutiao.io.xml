<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bf652b1538fb2a1761fd8849181223ba</guid>
<title>21 张图详解网络基础知识</title>
<link>https://toutiao.io/k/9uox6mg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.4753974261922786&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1G6rOatCLfq8CbTD8FkyCvCm9n7RSRiboYr2Js6euG5N8Vc74uC4LpFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1321&quot; title=&quot;目录&quot;/&gt;&lt;figcaption&gt;目录&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;网络协议&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;我们用手机连接上网的时候，会用到许多网络协议。从手机连接 WiFi 开始，使用的是 &lt;strong&gt;802.11&lt;/strong&gt; （即 WLAN ）协议；手机自动获取网络配置，使用的是 &lt;strong&gt;DHCP&lt;/strong&gt; 协议。这时手机已经连入局域网了，可以访问局域网内的主机和资源，但还不能使用互联网应用，例如：微信、抖音等。想要访问互联网，还需要在手机的上联网络设备上进行配置，即在无线路由器上配置 &lt;strong&gt;NAT&lt;/strong&gt;、 &lt;strong&gt;PPPOE&lt;/strong&gt; 等功能，才能把局域网接入到互联网中，手机就可以上网玩微信、刷抖音了。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.26864244741873805&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D10e7PWjWiaEpvASQC8KAfI59XfNzbPVlw2PSsS2bwUpUkQ6LTMtlRgFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot; title=&quot;网络协议示意图&quot;/&gt;&lt;figcaption&gt;网络协议示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;局域网&lt;/strong&gt; ：小范围内的私有网络，一个家庭内的网络、一个公司内的网络、一个校园内的网络都属于局域网。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;广域网&lt;/strong&gt;：把不同地域的局域网互相连接起来的网络。运营商搭建连接远距离区域的广域网。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;互联网&lt;/strong&gt;：由世界各地的局域网和广域网连接起来的网络。互联网是一个开放、互联的网络，不属于任何个人和任何机构。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;简单来说，就是手机、无线路由器等设备通过网络协议实现通信。网络协议又是谁规定的呢？ISO 制定了一个 OSI 参考模型，被用于网络协议的制定。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;OSI 参考模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;OSI 参考模型将网络协议提供的服务分成 &lt;strong&gt;7&lt;/strong&gt; 层，并定义每一层的&lt;strong&gt;服务&lt;/strong&gt;内容，实现每一层服务的是&lt;strong&gt;协议&lt;/strong&gt;，协议的具体内容是&lt;strong&gt;规范&lt;/strong&gt;。上下层之间通过&lt;strong&gt;接口&lt;/strong&gt;进行交互，同一层之间通过&lt;strong&gt;协议&lt;/strong&gt;进行交互。OSI 参考模型只对各层的服务做了粗略的界定，并没有对协议进行详细的定义。但是许多协议都对应了 7 个分层的某一层。所以要了解网络，首先要了解 OSI 参考模型。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;2.3259668508287294&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D114AW1F8qCexUJ9gYAuR8jO5Vc4o5FyEEk1nDPFZkKrwTca8ahAGFLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;181&quot; title=&quot;OSI 参考模型图&quot;/&gt;&lt;figcaption&gt;OSI 参考模型图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;应用层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 7 层（最高层）。应用程序和网络之间的接口，直接向用户提供服务。应用层协议有电子邮件、远程登录等协议。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8047808764940239&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1UNicWpBIBHWPMibdXbtm6mowSiaalG1bKUHI24bkIWaFno7LEicYjgH2RA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;502&quot; title=&quot;应用层示例图&quot;/&gt;&lt;figcaption&gt;应用层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;表示层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 6 层。负责数据格式的互相转换，如编码、数据格式转换和加密解密等。保证一个系统应用层发出的信息可被另一系统的应用层读出。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3237518910741301&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1vP8snkyVtoka7US7uaDMiboDUg2LeSOfQIBPd6kticecpA3AjibIGkrpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot; title=&quot;表示层示例图&quot;/&gt;&lt;figcaption&gt;表示层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;会话层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 5 层。主要是管理和协调不同主机上各种进程之间的通信（对话），即负责建立、管理和终止应用程序之间的会话。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.1760797342192691&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1mibpAMaHkMYyl0AA8v2SSsXFyoWgmvsdsCZFrW4ibtlZicFBB0g5NeQLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; title=&quot;会话层示例图&quot;/&gt;&lt;figcaption&gt;会话层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;传输层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 4 层。为上层协议提供通信主机间的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2591362126245847&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1gXw9mXYONCk8APaME2PVINpeSv1yichL54VWJdImOWial2rcodY1nqwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; title=&quot;传输层示例图&quot;/&gt;&lt;figcaption&gt;传输层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;网络层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 3 层。将数据传输到目的地址，主要负责寻址和路由选择。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3687707641196013&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1vmCtF7fwx7T0lIlUB1jpjIKGFgdXiacPz1QuHc4I8ruqyHqb18yjruQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; title=&quot;网络层示例图&quot;/&gt;&lt;figcaption&gt;网络层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;数据链路层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 2 层。负责两个相邻主机间的通信传输，即数据帧的生成与接收。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.18635607321131448&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D10AxCN87AWXvIYRiaPF8wt5Z0LN9KVsMWzN6jtBwBs57G4uAVfBxBEyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot; title=&quot;数据链路层示例图&quot;/&gt;&lt;figcaption&gt;数据链路层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;物理层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 1 层（最底层）。负责逻辑信号（比特流）与物理信号（电信号、光信号）之间的互相转换，利用传输介质为数据链路层提供物理连接。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.23688663282571912&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1j7z5Pkv7qMl6oCEPNxneoZRRiaDicekX6O3M8YnysFAMDicYYPuWCr2Zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;591&quot; title=&quot;物理层示例图&quot;/&gt;&lt;figcaption&gt;物理层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;TCP/IP 参考模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;由于 OSI 参考模型把服务划得过于琐碎，先定义参考模型再定义协议，有点理想化。TCP/IP 模型则正好相反，通过已有的协议归纳总结出来的模型，成为实际的主流网络协议标准。&lt;/p&gt;&lt;p&gt;先介绍下 TCP/IP 与 OSI 分层之间的对应关系，以及 TCP/IP 每层的主要协议。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.751188589540412&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1rnLewYtp5IgcpkCWruDWIax5xeAUhev3Q44ZOBea4IVb8d1OEY9VibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;631&quot; title=&quot;TCP/IP 参考模型&quot;/&gt;&lt;figcaption&gt;TCP/IP 参考模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;网络接入层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;在 TCP/IP 分层中，有把物理层和数据链路层合并称为网络接入层，有把物理层和数据链路层分别称为硬件、网络接口层。网络接入层是对网络介质的管理，定义如何使用网络来传送数据，但是对物理层和数据链路层在通信过程中起到了不一样的作用。所以 TCP/IP 分为四层或者五层都可以，只要能理解其中的原理就行。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;网络层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;相当于 OSI 模型中的第 3 层网络层，使用的是IP协议，作用是将数据包从源地址发送到目的地址。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.31893687707641194&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1twJpicanJHsuZnw5XOBDsKQHyNpTMWWuIicFYiaqfPQrfWaBzjVejTblw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; title=&quot;网络层&quot;/&gt;&lt;figcaption&gt;网络层&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;IP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;IP 是跨越网络传送数据包， 使整个互联网都能收到数据的协议，它使用 IP 地址作为主机的标识。IP 协议独立于底层介质，&lt;br/&gt;实现从源到目的的数据转发。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;ICMP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;用于在 IP 主机、路由器之间传递控制消息。被用来诊断网络的健康状况。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;ARP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从数据包的 IP 地址中解析出 MAC 地址的一种协议。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;传输层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;相当于 OSI 模型中的第 4 层传输层，主要功能就是让应用程序之间互相通信，通过端口号识别应用程序，使用的协议有面向连接的 TCP 协议和面向无连接的 UDP 协议。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3768472906403941&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1O3icbiceEWFuD03IqJibChH48IiahCNsrAJedjiaFXrZUX45CW2KicunZdgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot; title=&quot;传输层&quot;/&gt;&lt;figcaption&gt;传输层&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;应用层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;相当于 OSI 模型中的第 5 - 7 层的集合，不仅要实现 OSI 模型应用层的功能，还要实现会话层和表示层的功能。HTTP 、 POP3 、 TELNET 、 SSH 、 FTP 、 SNMP都是应用层协议。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3768472906403941&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1R45sbU7CiayymAZEudSHQVJmPM25ibmHHoenSiaaM6icYODBJ832vTHBEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot; title=&quot;应用层&quot;/&gt;&lt;figcaption&gt;应用层&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;HTTP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;是 WWW 浏览器和服务器之间的应用层通信协议。HTTP 定义高级命令或者方法供浏览器用来与Web服务器通信。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;POP3&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;简单邮件传输协议，邮件客户端和邮件服务器使用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;TELNET&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;远程终端协议，用于远程管理网络设备。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;SSH&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;安全外壳协议。通过使用SSH，可以把所有传输的数据进行加密。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;SNMP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;简单网络管理协议，用于网管软件进行网络设备的监控和管理。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;封装与解封装&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;数据发送前，按照参考模型从上到下，在数据经过每一层时，添加协议头部信息，这个过程叫&lt;strong&gt;封装&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2861378799110452&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1OCmFZGLDOxsSfJbJdibcLyTsLx8PgL1KTfQLcxuIs7zj0b6Q14wKkQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1349&quot; title=&quot;封装&quot;/&gt;&lt;figcaption&gt;封装&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;数据接收后，按照参考模型从下到上，在数据经过每一层时，去掉协议头部信息，这个过程叫&lt;strong&gt;解封装&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2861378799110452&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1U6a9X3WqF9mfo3T5B3fIWiaPxojQ7RMSdiaZyghX9iaDy3RJOIyyjwrtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1349&quot; title=&quot;解封装&quot;/&gt;&lt;figcaption&gt;解封装&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;经过传输层协议封装后的数据称为&lt;strong&gt;段&lt;/strong&gt;，经过网络层协议封装后的数据称为&lt;strong&gt;包&lt;/strong&gt;，经过数据链路层协议封装后的数据称为&lt;strong&gt;帧&lt;/strong&gt;，物理层传输的数据为&lt;strong&gt;比特&lt;/strong&gt;。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;实际数据传输举例&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;实际生活中，互联网是使用的 TCP/IP 协议进行网络连接的。我们以访问网站为例，看看网络是如何进行通信的。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4305750350631136&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1VIro7rYwibZq3gxsiapN04H9WCg0f21x7Lw6uBFs9vDmCXne8TAlWrJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1426&quot; title=&quot;数据传输举例&quot;/&gt;&lt;figcaption&gt;数据传输举例&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5&gt;&lt;span&gt;发送数据包&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;访问 HTTP 网站页面时，打开浏览器，输入网址，敲下回车键就开始进行 TCP/IP 通信了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;应用程序处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;首先，应用程序中会进行 HTML 格式&lt;strong&gt;编码&lt;/strong&gt;处理，相当于 OSI 的表示层功能。编码转化后，不一定会马上发送出去，相当于会话层的功能。在请求发送的那一刻，建立 TCP 连接，然后在 TCP 连接上发送数据。接下来就是将数据发送给下一层的 TCP 进行处理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;TCP 模块处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;TCP 会将应用层发来的数据顺利的发送至目的地，实现可靠传输的功能，需要给数据封装 TCP 头部信息。TCP 头部信息包括源端口号和目的端口号（识别主机上应用）、序号（确认哪部分是数据）以及校验和（判断数据是否被损坏）。随后&lt;strong&gt;封装&lt;/strong&gt;了 TCP 头部信息的段再发送给 IP 。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;IP  模块处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;IP 将 TCP 传过来的数据段当做自己的数据，并封装 IP 头部信息。IP 头部信息中包含目的 IP 地址和源 IP 地址，以及上层协议类型信息。&lt;/p&gt;&lt;p&gt;IP 包生成后，根据主机&lt;strong&gt;路由表&lt;/strong&gt;进行数据发送。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;网络接口处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;网络接口对传过来的 IP 包封装上以太网头部信息并进行发送处理。以太网头部信息包含目的 MAC 地址、源 MAC 地址，以及上层协议类型信息。然后将以太网数据&lt;strong&gt;帧&lt;/strong&gt;通过物理层传输给接收端。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;接收数据包&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;包的接收流程是发送流程的&lt;strong&gt;反向&lt;/strong&gt;过程。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;网络接口处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;收到以太网帧后，首先查看头部信息的目的 MAC 地址是否是发给自己的帧。如果不是发送给自己的帧就丢弃。如果是发送给自己的帧，查看上层协议类型是 IP 包，以太网帧&lt;strong&gt;解封装&lt;/strong&gt;成 IP 包，传给 IP 模块进行处理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;IP  模块处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;收到 IP 包后，进行类似处理。根据头部信息的目的 IP 地址判断是否是发送给自己包，如果是发送给自己的包，则查看上一层的协议类型，并把 IP 包解封装发送给 TCP 协议处理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;TCP 模块处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;收到 TCP 段后，首先查看校验和，判断数据是否被破坏。然后检查是否按照序号接收数据。最后检查端口号，确定具体的应用程序。&lt;/p&gt;&lt;p&gt;数据接收完毕后，发送一个 “ &lt;strong&gt;确认回执&lt;/strong&gt; ” 给发送端。&lt;/p&gt;&lt;p&gt;数据被完整接收后，会把 TCP 段解封装发送给由端口号识别的应用程序。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;应用程序处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;应用程序收到数据后，通过解析数据知道了发送端请求的网页内容，然后按照 HTTP 协议进行后续数据交互。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;网络构成&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;搭建一套网络涉及各种线缆和网络设备。下面介绍一些常见的&lt;strong&gt;硬件设备&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7861507128309573&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1k7ZJY6CIPW9Mt4eqz1eNz6r1RLM11D4VdD1xFG7QicgXhUQKzlwt7BQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;982&quot; title=&quot;网络构成要素&quot;/&gt;&lt;figcaption&gt;网络构成要素&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.446693657219973&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1shs7hZ4Z59ZlSibFDn4JiaHBibiaB8KWsNia8icqsG1MlyFo7O2daSSf7mSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;741&quot; title=&quot;主要设备及作用表&quot;/&gt;&lt;figcaption&gt;主要设备及作用表&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;通信介质&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;主机可以通过有线线缆进行连接。有线线缆有双绞线、光纤、串口线等。根据网络接口选择对应的线缆。传输介质还可以被分为电波、微波等不同类型的电磁波。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;网卡&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;主机连接网络时，必须要使用网卡。可以是有线网卡，用来连接有线网络，也可以是无线网卡连接 WiFi 网络。每块网卡都有一个唯一的 &lt;strong&gt;MAC 地址&lt;/strong&gt;，也叫做硬件地址或物理地址。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;二层交换机&lt;/span&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4560530679933665&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1FFaOXbwwtq8wV7PNNXvF0h9g2znGMQIPCDsr2919YTicVFSUR9r6wYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;603&quot; title=&quot;二层交换机&quot;/&gt;&lt;figcaption&gt;二层交换机&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;二层交换机位于 OSI 模型的第 2 层（数据链路层）。它能够识别数据链路层中的数据帧，并将帧转发给相连的另一个端口。&lt;/p&gt;&lt;p&gt;数据帧中有一个数据位叫做 &lt;strong&gt;FCS&lt;/strong&gt; ，用以校验数据是否正确送达目的地。二层交换机通过检查这个值，将损坏的数据丢弃。&lt;/p&gt;&lt;p&gt;二层交换机根据 MAC 地址&lt;strong&gt;自学机制&lt;/strong&gt;判断是否需要转发数据帧。这类功能也是数据链路层所具有的功能。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;路由器 / 三层交换机&lt;/span&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2341897233201581&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1icBhnNIWbib1S4icjI0OrAeSpAVraXvb3uBKicpLypd7Uh0fJCbS5fFeMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1012&quot; title=&quot;路由器&quot;/&gt;&lt;figcaption&gt;路由器&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;路由器是在 OSI 模型的第 3 层（网络层）上连接两个网络、并对报文进行转发的设备。二层交换机是根据 MAC 地址进行处理，而路由器 / 三层交换机则是根据 &lt;strong&gt;IP 地址&lt;/strong&gt;进行处理的。因此 TCP/IP 中网络层的地址就成为了 IP 地址。&lt;/p&gt;&lt;p&gt;路由器可以连接不同的数据链路。比如连接两个以太网，或者连接一个以太网与一个无线网。家庭里面常见的无线路由器也是路由器的一种。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;四层及以上交换机&lt;/span&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.36585365853658536&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXfNuB7hRicBrZNdSicjc6O1D1icXwKIhtbR8PFZUdsQ5UWpgT43rn6aNjwqke9ffrtvTyL7dzGNBbLMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot; title=&quot;负载均衡设备&quot;/&gt;&lt;figcaption&gt;负载均衡设备&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;四层及以上交换机负责处理OSI模型中从传输层至应用层的数据。例如，下载和视频网站的服务器会用到的&lt;strong&gt;负载均衡设备&lt;/strong&gt;，就是四层及以上交换机的一种。还有广域网加速器、防火墙等。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>57f1c6668cae598576ac6353f4c48a48</guid>
<title>图文详解 Java 对象内存布局</title>
<link>https://toutiao.io/k/romtfff</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一名Java程序员，我们在日常工作中使用这款面向对象的编程语言时，做的最频繁的操作大概就是去创建一个个的对象了。对象的创建方式虽然有很多，可以通过&lt;code&gt;new&lt;/code&gt;、反射、&lt;code&gt;clone&lt;/code&gt;、反序列化等不同方式来创建，但最终使用时对象都要被放到内存中，那么你知道在内存中的java对象是由哪些部分组成、又是怎么存储的吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将基于代码进行实例测试，详细探讨对象在内存中的组成结构。全文目录结构如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;1、对象内存结构概述&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2、JOL 工具简介&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3、对象头&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4、实例数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;5、对齐填充字节&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6、总结&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;文中代码基于 JDK 1.8.0_261，64-Bit HotSpot 运行&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1、对象内存结构概述&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍对象在内存中的组成结构前，我们先简要回顾一个对象的创建过程：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、jvm将对象所在的&lt;code&gt;class&lt;/code&gt;文件加载到方法区中&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、jvm读取&lt;code&gt;main&lt;/code&gt;方法入口，将&lt;code&gt;main&lt;/code&gt;方法入栈，执行创建对象代码&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、在&lt;code&gt;main&lt;/code&gt;方法的栈内存中分配对象的引用，在堆中分配内存放入创建的对象，并将栈中的引用指向堆中的对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以当对象在实例化完成之后，是被存放在堆内存中的，这里的对象由3部分组成，如下图所示：&lt;/p&gt;&lt;img data-ratio=&quot;1.1689655172413793&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvUkl39tnbPgicrdfNzSp4wC498ibR0ZbtU1LBDLPXcDwn4PTemyLnicVzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;290&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对各个组成部分的功能简要进行说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对象头：对象头存储的是对象在运行时状态的相关信息、指向该对象所属类的元数据的指针，如果对象是数组对象那么还会额外存储对象的数组长度&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实例数据：实例数据存储的是对象的真正有效数据，也就是各个属性字段的值，如果在拥有父类的情况下，还会包含父类的字段。字段的存储顺序会受到数据类型长度、以及虚拟机的分配策略的影响&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对齐填充字节：在java对象中，需要对齐填充字节的原因是，64位的jvm中对象的大小被要求向8字节对齐，因此当对象的长度不足8字节的整数倍时，需要在对象中进行填充操作。注意图中对齐填充部分使用了虚线，这是因为填充字节并不是固定存在的部分，这点在后面计算对象大小时具体进行说明&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2、JOL 工具简介&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在具体开始研究对象的内存结构之前，先介绍一下我们要用到的工具，&lt;code&gt;openjdk&lt;/code&gt;官网提供了查看对象内存布局的工具&lt;code&gt;jol (java object layout)&lt;/code&gt;，可在&lt;code&gt;maven&lt;/code&gt;中引入坐标：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.openjdk.jol&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;jol-core&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;0.14&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在代码中使用&lt;code&gt;jol&lt;/code&gt;提供的方法查看jvm信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;System.out.println(VM.current().details());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;img data-ratio=&quot;0.36333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3Dvb9VdUc4azp5gqbtJHRbicZ6tBPfDfV6kWCvzzLtpR0FoOugBu9IUzaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过打印出来的信息，可以看到我们使用的是64位 jvm，并开启了指针压缩，对象默认使用8字节对齐方式。通过&lt;code&gt;jol&lt;/code&gt;查看对象内存布局的方法，将在后面的例子中具体展示，下面开始对象内存布局的正式学习。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3、对象头&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先看一下对象头（&lt;code&gt;Object header&lt;/code&gt;）的组成部分，根据普通对象和数组对象的不同，结构将会有所不同。只有当对象是数组对象才会有数组长度部分，普通对象没有该部分，如下图所示：&lt;/p&gt;&lt;img data-ratio=&quot;0.4887459807073955&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvgUkeKjX7INhPc69ZCx0yZGdAuGicW4iaW8BJe6WkH7OILq3cpElghsxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;622&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在对象头中&lt;code&gt;mark word&lt;/code&gt; 占8字节，默认开启指针压缩的情况下&lt;code&gt;klass pointer&lt;/code&gt; 占4字节，数组对象的数组长度占4字节。在了解了对象头的基础结构后，现在以一个不包含任何属性的空对象为例，查看一下它的内存布局，创建&lt;code&gt;User&lt;/code&gt;类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;jol&lt;/code&gt;查看对象头的内存布局：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    User user=&lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    &lt;span&gt;//查看对象的内存布局&lt;/span&gt;&lt;br/&gt;    System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行代码，查看打印信息：&lt;/p&gt;&lt;img data-ratio=&quot;0.19162640901771336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvicFpkF7A4Pwbdm9ZYkhyXgZicfTrax8ibWtDbTwwpOnYDktK6DN9uUB1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1242&quot;/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;OFFSET&lt;/code&gt;：偏移地址，单位为字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SIZE&lt;/code&gt;：占用内存大小，单位为字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;TYPE&lt;/code&gt;：&lt;code&gt;Class&lt;/code&gt;中定义的类型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;DESCRIPTION&lt;/code&gt;：类型描述，&lt;code&gt;Obejct header&lt;/code&gt; 表示对象头，&lt;code&gt;alignment&lt;/code&gt;表示对齐填充&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;VALUE&lt;/code&gt;：对应内存中存储的值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前对象共占用16字节，因为8字节标记字加4字节的类型指针，不满足向8字节对齐，因此需要填充4个字节：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;8B (mark word) + 4B (klass pointer) + 0B (instance data) + 4B (padding)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样我们就通过直观的方式，了解了一个不包含属性的最简单的空对象，在内存中的基本组成是怎样的。在此基础上，我们来深入学习对象头中各个组成部分。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.1 Mark Word 标记字&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在对象头中，&lt;code&gt;mark word&lt;/code&gt; 一共有64个bit，用于存储对象自身的运行时数据，标记对象处于以下5种状态中的某一种：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24578790882061446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvoxI1em2KLX6oP65L6DBcNPice8EMDuRxQbdkoYOichibBVeAZJSf7wKug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1009&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.1 基于mark word的锁升级&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在jdk6 之前，通过&lt;code&gt;synchronized&lt;/code&gt;关键字加锁时使用无差别的的重量级锁，重量级锁会造成线程的串行执行，并且使cpu在用户态和核心态之间频繁切换。随着对&lt;code&gt;synchronized&lt;/code&gt;的不断优化，提出了锁升级的概念，并引入了偏向锁、轻量级锁、重量级锁。在&lt;code&gt;mark word&lt;/code&gt;中，锁（&lt;code&gt;lock&lt;/code&gt;）标志位占用2个bit，结合1个bit偏向锁（&lt;code&gt;biased_lock&lt;/code&gt;）标志位，这样通过倒数的3位，就能用来标识当前对象持有的锁的状态，并判断出其余位存储的是什么信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于&lt;code&gt;mark word&lt;/code&gt;的锁升级的流程如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、锁对象刚创建时，没有任何线程竞争，对象处于无锁状态。在上面打印的空对象的内存布局中，根据大小端，得到最后8位是&lt;code&gt;00000001&lt;/code&gt;，表示处于无锁态，并且处于不可偏向状态。这是因为在jdk中偏向锁存在延迟4秒启动，也就是说在jvm启动后4秒后创建的对象才会开启偏向锁，我们通过jvm参数取消这个延迟时间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-XX:BiasedLockingStartupDelay=0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18785425101214576&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvjN3AxAnwicibmxfyibiaaenBSIaU2W63xO9n9trCsdOjiaxPDslEeEZGSjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1235&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时最后3位为&lt;code&gt;101&lt;/code&gt;，表示当前对象的锁没有被持有，并且处于可被偏向状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、在没有线程竞争的条件下，第一个获取锁的线程通过&lt;code&gt;CAS&lt;/code&gt;将自己的&lt;code&gt;threadId&lt;/code&gt;写入到该对象的&lt;code&gt;mark word&lt;/code&gt;中，若后续该线程再次获取锁，需要比较当前线程&lt;code&gt;threadId&lt;/code&gt;和对象&lt;code&gt;mark word&lt;/code&gt;中的&lt;code&gt;threadId&lt;/code&gt;是否一致，如果一致那么可以直接获取，并且锁对象始终保持对该线程的偏向，也就是说偏向锁不会主动释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用代码进行测试同一个线程重复获取锁的过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    User user=&lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt; (user){&lt;br/&gt;        System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;    }&lt;br/&gt;    System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt; (user){&lt;br/&gt;        System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5809748427672956&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvzpxRL1GbH0X2NJqevibjEqVHs8HAOj6dO4oaxFu2Rgbpp40mY2Jb2sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1272&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到一个线程对一个对象加锁、解锁、重新获取对象的锁时，&lt;code&gt;mark word&lt;/code&gt;都没有发生变化，偏向锁中的当前线程指针始终指向同一个线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、当两个或以上线程交替获取锁，但并没有在对象上并发的获取锁时，偏向锁升级为轻量级锁。在此阶段，线程采取&lt;code&gt;CAS&lt;/code&gt;的自旋方式尝试获取锁，避免阻塞线程造成的cpu在用户态和内核态间转换的消耗。测试代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    User user=&lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt; (user){&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;--MAIN--:&quot;&lt;/span&gt;+ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (user) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;--THREAD--:&quot;&lt;/span&gt;+ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;    thread.start();&lt;br/&gt;    thread.join();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;--END--:&quot;&lt;/span&gt;+ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先直接看一下结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5886075949367089&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DveS3DiceLHbx7xw1BlcDgvNsIrtPNQjj6wyGcfghqzDagF86XNYmz0TQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1264&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个加锁状态的变化流程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主线程首先对user对象加锁，首次加锁为&lt;code&gt;101&lt;/code&gt;偏向锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子线程等待主线程释放锁后，对user对象加锁，这时将偏向锁升级为&lt;code&gt;00&lt;/code&gt;轻量级锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;轻量级锁解锁后，user对象无线程竞争，恢复为&lt;code&gt;001&lt;/code&gt;无锁态，并且处于不可偏向状态。如果之后有线程再尝试获取user对象的锁，会直接加轻量级锁，而不是偏向锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、当两个或以上线程并发的在同一个对象上进行同步时，为了避免无用自旋消耗cpu，轻量级锁会升级成重量级锁。这时&lt;code&gt;mark word&lt;/code&gt;中的指针指向的是&lt;code&gt;monitor&lt;/code&gt;对象（也被称为管程或监视器锁）的起始地址。测试代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    User user = &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (user) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;--THREAD1--:&quot;&lt;/span&gt; + ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                TimeUnit.SECONDS.sleep(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }).start();&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (user) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;--THREAD2--:&quot;&lt;/span&gt; + ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                TimeUnit.SECONDS.sleep(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }).start();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3813291139240506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvsgtzicvzCjibsD9vqPnEvyEiaIrBUico5fFTwvOiaBuhtvlFwajuoibBlGsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1264&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在两个线程同时竞争user对象的锁时，会升级为&lt;code&gt;10&lt;/code&gt;重量级锁。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.2 其他信息&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对&lt;code&gt;mark word&lt;/code&gt; 中其他重要信息进行说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;hashcode&lt;/code&gt;：无锁态下的&lt;code&gt;hashcode&lt;/code&gt;采用了延迟加载技术，在第一次调用&lt;code&gt;hashCode()&lt;/code&gt;方法时才会计算写入。对这一过程进行验证：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    User user=&lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    &lt;span&gt;//打印内存布局&lt;/span&gt;&lt;br/&gt;    System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;    &lt;span&gt;//计算hashCode&lt;/span&gt;&lt;br/&gt;    System.out.println(user.hashCode());&lt;br/&gt;    &lt;span&gt;//再次打印内存布局&lt;/span&gt;&lt;br/&gt;    System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;img data-ratio=&quot;0.4112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3Dvfd7icGsSJLOzXXSr8vC2zWzYU7o27NS2L8JYOnFK0Entu5kC1Vrp7tQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在没有调用&lt;code&gt;hashCode()&lt;/code&gt;方法前，31位的哈希值不存在，全部填充为0。在调用方法后，根据大小端，被填充的数据为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1011001001101100011010010101101&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将2进制转换为10进制，对应哈希值&lt;code&gt;1496724653&lt;/code&gt;。需要注意，只有在调用没有被重写的&lt;code&gt;Object.hashCode()&lt;/code&gt;方法或&lt;code&gt;System.identityHashCode(Object)&lt;/code&gt;方法才会写入&lt;code&gt;mark word&lt;/code&gt;，执行用户自定义的&lt;code&gt;hashCode()&lt;/code&gt;方法不会被写入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可能会注意到，当对象被加锁后，&lt;code&gt;mark word&lt;/code&gt;中就没有足够空间来保存&lt;code&gt;hashCode&lt;/code&gt;了，这时&lt;code&gt;hashcode&lt;/code&gt;会被移动到重量级锁的&lt;code&gt;Object Monitor&lt;/code&gt;中。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;epoch&lt;/code&gt;：偏向锁的时间戳&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;分代年龄（&lt;code&gt;age&lt;/code&gt;）：在&lt;code&gt;jvm&lt;/code&gt;的垃圾回收过程中，每当对象经过一次&lt;code&gt;Young GC&lt;/code&gt;，年龄都会加1，这里4位来表示分代年龄最大值为15，这也就是为什么对象的年龄超过15后会被移到老年代的原因。在启动时可以通过添加参数来改变年龄阈值：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-XX:MaxTenuringThreshold&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当设置的阈值超过15时，启动时会报错：&lt;/p&gt;&lt;img data-ratio=&quot;0.22043795620437956&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvbdDdia3odMhKXpthCSt1icNIySLOyx4oCqwxricicCmIGy7O8yVE6Sj5Tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;685&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.2 Klass Pointer 类型指针&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Klass Pointer&lt;/code&gt;是一个指向方法区中&lt;code&gt;Class&lt;/code&gt;信息的指针，虚拟机通过这个指针确定该对象属于哪个类的实例。在64位的JVM中，支持指针压缩功能，根据是否开启指针压缩，&lt;code&gt;Klass Pointer&lt;/code&gt;占用的大小将会不同：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;未开启指针压缩时，类型指针占用8B (64bit)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开启指针压缩情况下，类型指针占用4B (32bit)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;jdk6&lt;/code&gt;之后的版本中，指针压缩是被默认开启的，可通过启动参数开启或关闭该功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;开启指针压缩：&lt;/span&gt;&lt;br/&gt;-XX:+UseCompressedOops&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭指针压缩：&lt;/span&gt;&lt;br/&gt;-XX:-UseCompressedOops&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是以刚才的&lt;code&gt;User&lt;/code&gt;类为例，关闭指针压缩后再次查看对象的内存布局：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18606492478226444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvkUqqXRVOFKHP7Q48yMhd5wyCWfNMYIlaFLkubbricupuuMIFp2FEeOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1263&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象大小虽然还是16字节，但是组成发生了改变，8字节标记字加8字节类型指针，已经能满足对齐条件，因此不需要填充。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;8B (mark word) + 8B (klass pointer) + 0B (instance data) + 0B (padding)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.2.1 指针压缩原理&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解了指针压缩的作用后，我们来看一下指针压缩是如何实现的。首先在不开启指针压缩的情况下，一个对象的内存地址使用64位表示，这时能描述的内存地址范围是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;0 ~ 2^64-1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开启指针压缩后，使用4个字节也就是32位，可以表示&lt;code&gt;2^32&lt;/code&gt; 个内存地址，如果这个地址是真实地址的话，由于CPU寻址的最小单位是&lt;code&gt;Byte&lt;/code&gt;，那么就是4GB内存。这对于我们来说是远远不够的，但是之前我们说过，java中对象默认使用了8字节对齐，也就是说1个对象占用的空间必须是8字节的整数倍，这样就创造了一个条件，使jvm在定位一个对象时不需要使用真正的内存地址，而是定位到由java进行了8字节映射后的地址（可以说是一个映射地址的编号）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;映射过程也非常简单，由于使用了8字节对齐后每个对象的地址偏移量后3位必定为0（使用16进制表示时），所以在存储的时候可以将后3位0抹除（转化为&lt;code&gt;bit&lt;/code&gt;是抹除了最后24位），在此基础上再去掉最高位，就完成了指针从8字节到4字节的压缩。而在实际使用时，在压缩后的指针后加3位0（16进制），就能够实现向真实地址的映射。&lt;/p&gt;&lt;img data-ratio=&quot;0.5263761467889908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3Dv7Zpfic7P4nHpRsy8ibpOnTGWGslricArMFfP1uMBia1g6tW1hUsCojDe7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;872&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完成压缩后，现在指针的32位中的每一个&lt;code&gt;bit&lt;/code&gt;，都可以代表8个字节，这样就相当于使原有的内存地址得到了8倍的扩容。所以在8字节对齐的情况下，32位最大能表示&lt;code&gt;2^32*8=32GB&lt;/code&gt;内存，内存地址范围是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;0 ~ (2^32-1)*8&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于能够表示的最大内存是32GB，所以如果配置的最大的堆内存超过这个数值时，那么指针压缩将会失效。配置jvm启动参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-Xmx32g&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看对象内存布局：&lt;/p&gt;&lt;img data-ratio=&quot;0.4722222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvsK62icwnkCkA8d3mhR6N4MIflkI7gD5ibDveQtx7EG8jjdmyevtGJK2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;504&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，指针压缩失效，指针长度恢复到8字节。那么如果业务场景内存超过32GB怎么办呢，可以通过修改默认对齐长度进行再次扩展，我们将对齐长度修改为16字节：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-XX:ObjectAlignmentInBytes=16 -Xmx32g&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;img data-ratio=&quot;0.4590690208667737&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvHXbC9RIicCGdo2rjJu6Szh6o1lxK7ib1oBjzMODKNGwLZlHLVUryiccUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;623&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到指针压缩后占4字节，同时对象向16字节进行了填充对齐，按照上面的计算，这时配置最大堆内存为64GB时指针压缩才会失效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对指针压缩做一下简单总结：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过指针压缩，利用对齐填充的特性，通过映射方式达到了内存地址扩展的效果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指针压缩能够节省内存空间，同时提高了程序的寻址效率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;堆内存设置时最好不要超过32GB，这时指针压缩将会失效，造成空间的浪费&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此外，指针压缩不仅可以作用于对象头的类型指针，还可以作用于引用类型的字段指针，以及引用类型数组指针&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.3 数组长度&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果当对象是一个数组对象时，那么在对象头中有一个保存数组长度的空间，占用4字节（32bit）空间。通过下面代码进行测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    User[] user=&lt;span&gt;new&lt;/span&gt; User[&lt;span&gt;2&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;//查看对象的内存布局&lt;/span&gt;&lt;br/&gt;    System.out.println(ClassLayout.parseInstance(user).toPrintable());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行代码，结果如下：&lt;/p&gt;&lt;img data-ratio=&quot;0.39203675344563554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3Dva14UWhTW4Qe4CkLYh0CibwdeIzjNo68DOFVibj8qofgFKQVbtBMfzoMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;653&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存结构从上到下分别为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;8字节&lt;code&gt;mark word&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4字节&lt;code&gt;klass pointer&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4字节数组长度，值为2，表示数组中有两个元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开启指针压缩后每个引用类型占4字节，数组中两个元素共占8字节&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，在未开启指针压缩的情况下，在数组长度后会有一段对齐填充字节：&lt;/p&gt;&lt;img data-ratio=&quot;0.47938931297709925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvxL2wIpAx9ibFb6OwibgJgnRF8W1XWltTQpz0LtgNN8K5q4thQicORsIOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过计算：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;8B (mark word) + 8B (klass pointer) + 4B (array length) + 16B (instance data)=36B&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要向8字节进行对齐，这里选择将对齐的4字节添加在了数组长度和实例数据之间。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4、实例数据&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例数据（&lt;code&gt;Instance Data&lt;/code&gt;）保存的是对象真正存储的有效信息，保存了代码中定义的各种数据类型的字段内容，并且如果有继承关系存在，子类还会包含从父类继承过来的字段。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Bytes&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;byte，boolean&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;char，short&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;int，float&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;long，double&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启指针压缩情况下占8字节，开启指针压缩后占4字节。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.1 字段重排序&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给User类添加基本数据类型的属性字段：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; id,age,weight;&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt; sex;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; phone;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; local;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看内存布局：&lt;/p&gt;&lt;img data-ratio=&quot;0.5981873111782477&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3Dvfr2weUoEH9kibSw6DufVqlj4Ydh8XsDSTnXYshGwicUJXUD5TTXO49xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在内存中，属性的排列顺序与在类中定义的顺序不同，这是因为jvm会采用&lt;strong&gt;字段重排序&lt;/strong&gt;技术，对原始类型进行重新排序，以达到内存对齐的目的。具体规则遵循如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;按照数据类型的长度大小，从大到小排列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;具有相同长度的字段，会被分配在相邻位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果一个字段的长度是L个字节，那么这个字段的偏移量（&lt;code&gt;OFFSET&lt;/code&gt;）需要对齐至&lt;code&gt;nL&lt;/code&gt;（n为整数）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的前两条规则相对容易理解，这里通过举例对第3条进行解释：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为&lt;code&gt;long&lt;/code&gt;类型占8字节，所以它的偏移量必定是8n，再加上前面对象头占12字节，所以&lt;code&gt;long&lt;/code&gt;类型变量的最小偏移量是16。通过打印对象内存布局可以发现，当对象头不是8字节的整数倍时（只存在&lt;code&gt;8n+4&lt;/code&gt;字节情况），会按从大到小的顺序，使用4、2、1字节长度的属性进行补位。为了和对齐填充进行区分，可以称其为前置补位，如果在补位后仍然不满足8字节整数倍，会进行对齐填充。在存在前置补位的情况下，字段的排序会打破上面的第一条规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此在上面的内存布局中，先使用4字节的&lt;code&gt;int&lt;/code&gt;进行前置补位，再按第一条规则从大到小顺序进行排列。如果我们删除3个&lt;code&gt;int&lt;/code&gt;类型的字段，再查看内存布局：&lt;/p&gt;&lt;img data-ratio=&quot;0.5291181364392679&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvFFhkXjKbwHric9yNJbh7ndGyVrrYTEv6HCvkQ3f3aIvZ0ZLCBzM4pUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;char&lt;/code&gt;和&lt;code&gt;byte&lt;/code&gt;类型的变量被提到前面进行前置补位，并在&lt;code&gt;long&lt;/code&gt;类型前进行了1字节的对齐填充。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.2 拥有父类情况&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当一个类拥有父类时，整体遵循在父类中定义的变量出现在子类中定义的变量之前的原则&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i1,i2;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; l1,l2;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; c1,c2;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;A&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; b1;&lt;br/&gt;    &lt;span&gt;double&lt;/span&gt; d1,d2;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看内存结构：&lt;/p&gt;&lt;img data-ratio=&quot;0.6996904024767802&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvkbDk1sKD2CGeJOwPLjH8GR18GcC8gOicjtwRbMbDOuT2dbVaw39oYSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;646&quot;/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果父类需要后置补位的情况，可能会将子类中类型长度较短的变量提前，但是整体还是遵循子类在父类之后的原则&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i1,i2;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; l1;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i1,i2;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; l1;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看内存结构：&lt;/p&gt;&lt;img data-ratio=&quot;0.606312292358804&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvMw8K72fBuhFGbibOksuKFLPFDr8tUDibO4poT5AIalEHoXhNg4pvQw6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，子类中较短长度的变量被提前到父类后进行了后置补位。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; l;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;A&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; l2;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i1;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看内存结构：&lt;/p&gt;&lt;img data-ratio=&quot;0.5551894563426688&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3Dvoc6dICSDmchOB537YOPibFWQibaYOdGL03ibaicOMxrWXZZQCxjv9yz6icA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;607&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当B类没有继承A类时，正好满足8字节对齐，不需要进行对齐填充。当B类继承A类后，会继承A类的前置补位填充，因此在B类的末尾也需要对齐填充。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.3 引用数据类型&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的例子中，仅探讨了基本数据类型的排序情况，那么如果存在引用数据类型时，排序情况是怎样的呢？在&lt;code&gt;User&lt;/code&gt;类中添加引用类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;     String firstName;&lt;br/&gt;     String lastName;&lt;br/&gt;     &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看内存布局：&lt;/p&gt;&lt;img data-ratio=&quot;0.4820936639118457&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvzyFHj8zG3mWKehicicmERewLF1m6vibic7J7oNkS9qtRMxFGxhvv9hYCtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到默认情况下，基本数据类型的变量排在引用数据类型前。这个顺序可以在&lt;code&gt;jvm&lt;/code&gt;启动参数中进行修改：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-XX:FieldsAllocationStyle=0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重新运行，可以看到引用数据类型的排列顺序被放在了前面：&lt;/p&gt;&lt;img data-ratio=&quot;0.45879120879120877&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvbavKwgI2icUqC91Haq5YlHqhloA186Q1CiaCwflYicPbtYAO9TgtiaG3bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对&lt;code&gt;FieldsAllocationStyle&lt;/code&gt;的不同取值简要说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;0：先放入普通对象的引用指针，再放入基本数据类型变量&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1：默认情况，表示先放入基本数据类型变量，再放入普通对象的引用指针&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.4 静态变量&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的基础上，在类中加入静态变量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; local;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看内存布局：&lt;/p&gt;&lt;img data-ratio=&quot;0.3785594639865997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3DvPqnLvormQJV64QhJXiasVUaCrvo75MVO0fZjvhdgrPMbfvn85CLBKkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;597&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过结果可以看到，静态变量并不在对象的内存布局中，它的大小是不计算在对象中的，因为静态变量属于类而不是属于某一个对象的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;5、对齐填充字节&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Hotspot&lt;/code&gt;的自动内存管理系统中，要求对象的起始地址必须是8字节的整数倍，也就是说对象的大小必须满足8字节的整数倍。因此如果实例数据没有对齐，那么需要进行对齐补全空缺，补全的&lt;code&gt;bit&lt;/code&gt;位仅起占位符作用，不具有特殊含义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面的例子中，我们已经对对齐填充有了充分的认识，下面再做一些补充：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在开启指针压缩的情况下，如果类中有&lt;code&gt;long/double&lt;/code&gt;类型的变量时，会在对象头和实例数据间形成间隙（&lt;code&gt;gap&lt;/code&gt;），为了节省空间，会默认把较短长度的变量放在前边，这一功能可以通过jvm参数进行开启或关闭：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开启&lt;/span&gt;&lt;br/&gt;-XX:+CompactFields&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭&lt;/span&gt;&lt;br/&gt;-XX:-CompactFields&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试关闭情况，可以看到较短长度的变量没有前移填充：&lt;/p&gt;&lt;img data-ratio=&quot;0.5608628659476117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3Dvd8WUGcQoJogPUKkUut6KpNC6PjicGWWURqpT2fFia2mV4dGdaiaHEGD3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在前面指针压缩中，我们提到了可以改变对齐宽度，这也是通过修改下面的jvm参数配置实现的：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-XX:ObjectAlignmentInBytes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下对齐宽度为8，这个值可以修改为2~256以内2的整数幂，一般情况下都以8字节对齐或16字节对齐。测试修改为16字节对齐：&lt;/p&gt;&lt;img data-ratio=&quot;0.5850234009360374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicb5ibGTTW3N6YAxcTErEd3Dv4fH0icCeAxlunWkEmjFtnMibsmdLbqu98aicNG7Vic3vsIpDkErWNIrX4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子中，在调整为16字节对齐的情况下，最后一行的属性字段只占了6字节，因此会添加10字节进行对齐填充。当然普通情况下不建议修改对齐长度参数，如果对齐宽度过长，可能会导致内存空间的浪费。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;6、总结&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文通过使用&lt;code&gt;jol&lt;/code&gt; 对java对象的结构进行调试，学习了对象内存布局的基本知识。通过学习，能够帮助我们：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;掌握对象内存布局，基于此基础进行jvm参数调优&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;了解对象头在&lt;code&gt;synchronize&lt;/code&gt; 的锁升级过程中的作用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;熟悉 jvm 中对象的寻址过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过计算对象大小，可以在评估业务量的基础上在项目上线前预估需要使用多少内存，防止服务器频繁gc&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a0096037308e287c1d4a3a85e444df13</guid>
<title>漫画 Go 语言中函数 new 与 make 的使用和区别</title>
<link>https://toutiao.io/k/jky5ja4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;赖思与甜甜，有趣有料有温度，技术学习有思路！&lt;/p&gt;&lt;p&gt;看看赖思怎么给甜甜讲解Go语言中的new与make吧！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/pafDRXbWF0Qm7Ziak8d3Jqg28qia9iaHibjtibhp9QQqS5Hs7tmhQyQb5CGbz5zDOIOVGTPbCribJ1TjthYLOib59X4Wg/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;84.15224913494811&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.496875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/pafDRXbWF0Qm7Ziak8d3Jqg28qia9iaHibjtShkzY4mPRNSsZBUYTWUZ6mmU8xPnEm7beLuJZ0RBL4WFRdMtlVw2VA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/pafDRXbWF0Qm7Ziak8d3Jqg28qia9iaHibjtBaciaRpAAiaN3WTyHfeeR8QRIJotAc5icKWjQJ0WXhct9IW1E1m1hjvmw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/pafDRXbWF0Qm7Ziak8d3Jqg28qia9iaHibjtMN8NQlfKerKFNibc99ibFw4qScYFSUnCmPfpwGjJ7zBHJOtlNwhGFvIw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;对于值类型的变量，我们通过var 声明，系统会默认为他分配内存空间，并赋该类型的零值。如下，我们声明一个int类型变量i，输出为0。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; i int&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fmt.Println(i)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;而如果我们声明一个指针类型的变量，系统不会为他分配内存，改变量默认就是nil。此时如果你想直接使用，那么系统会抛异常。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; j *&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fmt.Println(j)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;*j = &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;也就是说，空指针还没有内存分配，是不能使用的。那么要想使用，此时就需要new出场啦。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; j *&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;j = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fmt.Println(j)   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fmt.Println(*j)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;*j = &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fmt.Println(*j)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.14516129032258066&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pafDRXbWF0Qm7Ziak8d3Jqg28qia9iaHibjthLHdNySL2MYkKicbpwLCsKZ6jU98MLX3pogtSV9vKz0I6iaV8WSucoJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1736&quot;/&gt;&lt;/p&gt;&lt;p&gt;声明指针类型变量后，通过new为他分配内存，有了内存空间，这个变量就可以自由的使用啦。&lt;/p&gt;&lt;p&gt;我们来看一下new函数&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.14012738853503184&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pafDRXbWF0Qm7Ziak8d3Jqg28qia9iaHibjtEYBdmwVuBOmHuVdHaqMMQCQzCibefMtrGVoONyp3t6jvRQzUVRZwOSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1256&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它只接受一个参数，这个参数是一个类型，分配好内存后，返回一个指向该类型内存地址的指针。&lt;/span&gt;&lt;span&gt;同时把分配的内存置为零，也就是类型的零值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/pafDRXbWF0Qm7Ziak8d3Jqg28qia9iaHibjt6TPicprshhtTpxuMvsTcvjB2melazwiaZ6XwAnToJkTpVHNfgmNIHoJQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/pafDRXbWF0Qm7Ziak8d3Jqg28qia9iaHibjtqp4MObj1BKFqGJLllpQeu8sV4mia6AlpJznQyL6sq6lddxPAo2ZmN9Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.59296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pafDRXbWF0Qm7Ziak8d3Jqg28qia9iaHibjth3LC23c1Hc7GzEyZ9aeiaChnfGygPkPCIPmL1yQBGia0xpuibv1MJJdCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;    &lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; c &lt;span class=&quot;code-snippet__keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fmt.Printf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%#v \n&quot;&lt;/span&gt;,c) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;c = &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fmt.Printf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%#v&quot;&lt;/span&gt;, c) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;声明管道类型变量c，此时c还是nil，不可用；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;通过make来分配内存并初始化，c就获得了内存可以使用了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/pafDRXbWF0Qm7Ziak8d3Jqg28qia9iaHibjtgx2BPokmuUyHMx8Zgkva2ibh8ILHACDPzBMHIMBKqM14pkVHjrOYnibw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;有趣有料有温度，和我一起学技术！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎关注公众号 &lt;strong&gt;来思Go&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，收看更多赖思与甜甜的技术学习日常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/pafDRXbWF0Qm7Ziak8d3Jqg28qia9iaHibjtKQJZmM4je8fXiaJeyoxBY1icqul5nWHO06Rr3amUicfHY887r4G4R7TXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>77b5135a1fbc2321a47ed4eb5431719c</guid>
<title>Java 基础：函数式编程概念和 API 应用</title>
<link>https://toutiao.io/k/dt8maz4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、函数式概念&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;函数式编程是一种结构化编程的范式，主要思想是把运算过程尽量写成系列嵌套的函数调用。函数编程的概念表述带有很抽象的感觉，可以基于案例看：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Function01&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 运算：（x+y）* c&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; x1 = &lt;span&gt;2&lt;/span&gt; ;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; y1 = &lt;span&gt;3&lt;/span&gt; ;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; c1 = &lt;span&gt;4&lt;/span&gt; ;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; sum1 = x1 + y1 ;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; res1 = sum1 * c1 ;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;res1 = &quot;&lt;/span&gt;+res1);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里基于过程的方式做计算，上面的代码块着重在描述程序执行过程。&lt;/p&gt;&lt;p&gt;在看基于函数的方式解决方法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Function02&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 函数式计算&lt;/span&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;func01 = &quot;&lt;/span&gt;+func01(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;func01&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; y,&lt;span&gt;int&lt;/span&gt; c)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (x+y)*c;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数式编程的核心要素：传入参数，执行逻辑，返回值，也可以没有返回值。&lt;/p&gt;&lt;p&gt;函数式的编程风格侧重描述程序的执行逻辑，不是执行过程。&lt;/p&gt;&lt;p&gt;同上面计算过程相比，函数式编程也减少很多临时变量的创建，代码风格也变的简洁清楚。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、函数与方法&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在Java语言中有函数式编程风格，但是Java代码中没有函数的说法，而是称为：方法；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Function03&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Func03 func03 = &lt;span&gt;new&lt;/span&gt; Func03();&lt;br/&gt;        func03.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        System.out.println(func03.res1);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Func03&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; res1 = &lt;span&gt;0&lt;/span&gt; ;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a1)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.res1 = a1 +&lt;span&gt;1&lt;/span&gt; ;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类定义引用数据类型，类实例化后的对象可以调用类内部的方法和数据，这是最直观的感觉。&lt;/p&gt;&lt;p&gt;但是方法又有静态和非静态的区别，静态方法属于类所有，类实例化前即可使用。&lt;/p&gt;&lt;p&gt;非静态方法可以访问类中的任何成员变量和方法，并且必须是类实例化后的对象才可以调用。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、JDK函数基础&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、Lambda表达式&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Lambda表达式也可称为闭包，是推动Java8发布的最重要新特性，允许把函数作为一个方法的参数（函数作为参数传递进方法中）。&lt;/p&gt;&lt;p&gt;这里就很鲜明的对比Lambda表达式语法和传统用法。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Lambda01&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;LambdaOpera&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;operation&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;(&lt;span&gt;String[] args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        LambdaOpera lambdaOpera = &lt;span&gt;new&lt;/span&gt; LambdaOpera(){&lt;br/&gt;            @&lt;span&gt;Override&lt;br/&gt;            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;operation&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; a * b ;&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(lambdaOpera.operation(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;        LambdaOpera lambdaOpera01 = (&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b) -&amp;gt; a + b;&lt;br/&gt;        LambdaOpera lambdaOpera02 = (&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b) -&amp;gt; a - b;&lt;br/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(lambdaOpera01.operation(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(lambdaOpera02.operation(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在看一个直观的应用案例，基于Lambda的方式创建线程，可以使代码变的更加简洁紧凑:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Lambda02&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;2&lt;/span&gt;; i++) {&lt;br/&gt;                    System.out.println(i);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }).start();&lt;br/&gt;        &lt;span&gt;// 对比 Lambda 方式&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;2&lt;/span&gt;; i++) {&lt;br/&gt;                System.out.println(i);&lt;br/&gt;            }&lt;br/&gt;        }).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在看一下Runnable接口的结构：&lt;/p&gt;&lt;p&gt;FunctionalInterface标记在接口上，表示该接口是函数式接口，并且该接口只包含一个抽象方法，&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@FunctionalInterface&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Lambda表达式本身可以理解为就是一个接口的实现过程，这里runnable就是完整的Lambda表达式声明：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Lambda04&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Runnable runnable = () -&amp;gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;run one...&quot;&lt;/span&gt;);&lt;br/&gt;        };&lt;br/&gt;        Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(runnable);&lt;br/&gt;        thread.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Lambda表达式最直观的作用就是使得代码变得异常简洁，并且可以作为参数传递。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、函数式接口&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Lambda表达式虽然有很多优点，但是使用的时候需要定义一些接口用来完成编码，这样又使得表达式又变得重量级，Java8自身已经提供几个常见的函数式接口。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Lambda05&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Function&amp;lt;Integer, Integer&amp;gt; function01 = x -&amp;gt; x * &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;        System.out.println(function01.apply(&lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;        BiFunction&amp;lt;Integer, Integer, Integer&amp;gt; function02 = (x, y) -&amp;gt; x * y;&lt;br/&gt;        System.out.println(function02.apply(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;        Consumer&amp;lt;String&amp;gt; consumer01 = msg -&amp;gt; System.out.println(&lt;span&gt;&quot;msg:&quot;&lt;/span&gt;+msg);&lt;br/&gt;        consumer01.accept(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        BiConsumer&amp;lt;String,Integer&amp;gt; consumer02 = (msg,i)&lt;br/&gt;                -&amp;gt; System.out.println(msg+&lt;span&gt;&quot;:&quot;&lt;/span&gt;+i);&lt;br/&gt;        consumer02.accept(&lt;span&gt;&quot;world&quot;&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果面对更复杂的业务需求，可以自定义函数式接口去解决。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、Optional类&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、Null判断&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Optional类是Java函数式编程的应用，主要用来解决常见的空指针异常问题。&lt;/p&gt;&lt;p&gt;在Java编程的开发中，很多地方都能常见空指针异常的抛出，如果想避免这个问题就要加入很多判断：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Optional01&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        User user = &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;hello&quot;&lt;/span&gt;) ;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (user != &lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (user.getName() != &lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;                System.out.println(user.getName());&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了确保程序不抛出空指针这种低级的错误，在程序中随处可以null的判断，代码显然冗余和繁杂。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、Optional应用&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;基于Optional类创建的对象可能包含空值和null值，也同样会抛出对应的异常：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Optional02&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// NoSuchElementException&lt;/span&gt;&lt;br/&gt;        Optional&amp;lt;User&amp;gt; optionalUser = Optional.empty();&lt;br/&gt;        optionalUser.get();&lt;br/&gt;        &lt;span&gt;// NullPointerException&lt;/span&gt;&lt;br/&gt;        Optional&amp;lt;User&amp;gt; nullOpt = Optional.of(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;        nullOpt.get();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以在不明确对象的具体情况下，使用ofNullable()方法:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Optional03&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        User user = &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;say&quot;&lt;/span&gt;);&lt;br/&gt;        Optional&amp;lt;User&amp;gt; optionalUser = Optional.ofNullable(user);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (optionalUser.isPresent()){&lt;br/&gt;            System.out.println(optionalUser.get().getName());&lt;br/&gt;        }&lt;br/&gt;        User user1 = &lt;span&gt;null&lt;/span&gt; ;&lt;br/&gt;        User createUser = Optional.ofNullable(user1).orElse(createUser());&lt;br/&gt;        System.out.println(createUser.getName());&lt;br/&gt;        User user2 = &lt;span&gt;null&lt;/span&gt; ;&lt;br/&gt;        Optional.ofNullable(user2).orElseThrow( ()&lt;br/&gt;                -&amp;gt; &lt;span&gt;new&lt;/span&gt; RuntimeException());;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; User &lt;span&gt;createUser&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;&quot;hello&quot;&lt;/span&gt;) ;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样看下来Optional结合链式方法和Lambda表达式就很大程度上简化了应用的代码量：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Optional04&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 1、map转换方法&lt;/span&gt;&lt;br/&gt;        User user = &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;99&lt;/span&gt;, &lt;span&gt;&quot;Java&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// user = null ;&lt;/span&gt;&lt;br/&gt;        String name = Optional.ofNullable(user)&lt;br/&gt;                .map(u -&amp;gt; u.getName()).orElse(&lt;span&gt;&quot;c++&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(name);&lt;br/&gt;        &lt;span&gt;// 2、过滤方法&lt;/span&gt;&lt;br/&gt;        Optional&amp;lt;User&amp;gt; optUser01 = Optional.ofNullable(user)&lt;br/&gt;                .filter(u -&amp;gt; u.getName() != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; u.getName().contains(&lt;span&gt;&quot;c++&quot;&lt;/span&gt;));&lt;br/&gt;        &lt;span&gt;// NoSuchElementException&lt;/span&gt;&lt;br/&gt;        System.out.println(optUser01.get().getName());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Optional提供null处理的各种方法，可以简洁很多代码判断，但是在使用风格上和之前变化很大。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、Stream流&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;如果Optional简化很多Null的判断，那Stream流的API则简化了很多集合的遍历判断，同样也是基于函数式编程。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5345528455284553&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCVgDZJ6MGaxK38uJKThYuj0J8XXwkBHkP6IhJvOQAicibzicCEExCjn6mZO6eC1TSTB6hatayoicddcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/p&gt;&lt;p&gt;上述为Stream接口继承关系如图，同样提供一些特定接口和较大的包装接口，通过源码查看，可以看到和函数编程也是密切相关。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Stream01&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Stream&amp;lt;String&amp;gt; stream = Stream.of(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;, &lt;span&gt;&quot;java&quot;&lt;/span&gt;);&lt;br/&gt;        stream.forEach(str -&amp;gt; System.out.print(str+&lt;span&gt;&quot;;&quot;&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Stream与函数接口结合使用，函数接口又可以使用Lambda表达式进行简化代码。在Java8通过Stream可以大量简化集合使用的代码复杂度。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Stream02&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 1、转换Stream&lt;/span&gt;&lt;br/&gt;        List&amp;lt;String&amp;gt; list = Arrays.asList(&lt;span&gt;&quot;java+；&quot;&lt;/span&gt;, &lt;span&gt;&quot;c++；&quot;&lt;/span&gt;, &lt;span&gt;&quot;net；&quot;&lt;/span&gt;);&lt;br/&gt;        list.stream();&lt;br/&gt;        &lt;span&gt;// 2、forEach操作&lt;/span&gt;&lt;br/&gt;        list.stream().forEach(System.out::print);&lt;br/&gt;        &lt;span&gt;// 3、map映射，输出 3，4&lt;/span&gt;&lt;br/&gt;        IntStream.rangeClosed(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;).map(x-&amp;gt;x+&lt;span&gt;1&lt;/span&gt;).forEach(System.out::println);&lt;br/&gt;        &lt;span&gt;// 4、filter过滤&lt;/span&gt;&lt;br/&gt;        list.stream().filter(str -&amp;gt; str.contains(&lt;span&gt;&quot;+&quot;&lt;/span&gt;)).forEach(System.out::print);&lt;br/&gt;        &lt;span&gt;// 5、distinct去重&lt;/span&gt;&lt;br/&gt;        Integer[] arr = &lt;span&gt;new&lt;/span&gt; Integer[]{&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;};&lt;br/&gt;        Stream.of(arr).distinct().forEach(System.out::println);&lt;br/&gt;        &lt;span&gt;// 6、sorted排序&lt;/span&gt;&lt;br/&gt;        Stream.of(arr).sorted().forEach(System.out::println);&lt;br/&gt;        &lt;span&gt;// 7、collect转换&lt;/span&gt;&lt;br/&gt;        List&amp;lt;String&amp;gt; newList = list.stream().filter(str -&amp;gt; str.contains(&lt;span&gt;&quot;+&quot;&lt;/span&gt;))&lt;br/&gt;                .collect(Collectors.toList());&lt;br/&gt;        newList.stream().forEach(System.out::print);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在没有Stream相关API之前，对于集合的操作和遍历都会产生大量的代码，通过Stream相关API集合的函数式编程和Lambda表达式的风格，简化集合很多操作。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;六、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/java-base-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/java-base-parent&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d0d3239c53574695facc3139390fbb9e</guid>
<title>Tyk API Gateway 反向代理设计</title>
<link>https://toutiao.io/k/fzt2lff</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h3 data-lake-id=&quot;e6efdbb854e5a99b17b434662a28ef8a&quot; data-wording=&quot;true&quot;&gt;0x1 什么是反向代理？&lt;/h3&gt;&lt;p data-lake-id=&quot;22ac722b0d990e461d69437d2a4a7d74&quot; data-wording=&quot;true&quot;&gt;&lt;strong&gt;          上一篇介绍了Tyk的限流设计&lt;/strong&gt;，这篇记录分析下它的反代设计，反代这个词相信做后端的同学基本都听说过（nginx的常用姿势），代理分为&lt;span&gt;正向代理&lt;/span&gt;和&lt;span&gt;反向代理&lt;/span&gt;，因为我们这里不是专门介绍代理的，我就简单说下他们的区别，记住一个区分他们的要点就是&lt;strong&gt;“正向代理就是访问要出去”， “反向代理就是访问要进来”，&lt;/strong&gt;正向代理多用于一些需要做互联网访问跳板机的场景，这里就不多说了。而反向代理呢，微服务场景是用得比较多的，一个API Gateway支持反代是核心功能，Tyk作为这领域的翘楚当然也得支持。GW的反代可用于负载均衡、访问中间人处理、认证等功能的实现上。&lt;/p&gt;&lt;p data-lake-id=&quot;03e992113ce08a3e9f17633310ac9dbb&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;10e56eb965fe0df2b4d727bff0df5d47&quot; data-wording=&quot;true&quot;&gt;0x2 流程分析&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.302746148693905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yetTcGWJiakOuzNDpuiajaFfeqefR9vjOZI7oA0Vxg14iavhdXuibp9HzenXWSSt3JglQDZmTNY08DcUpetR2B2Z1g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1493&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f9e634a354e310b050fa23b1a3974a4f&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;09eec8f5162fe0063b5bcb9559fafe17&quot; data-wording=&quot;true&quot;&gt;0x3 关键代码&lt;/h3&gt;&lt;p data-lake-id=&quot;2b83c3d3b2ab3b2b573e6bd3652f4d5a&quot; data-wording=&quot;true&quot;&gt;&lt;strong&gt;反代数据处理：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.434375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yetTcGWJiakOuzNDpuiajaFfeqefR9vjOZsicZ7bObSiaMel8sLKcAVYLOBRX2musqwsULV9UibQh8H3pu6le2WMvWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p data-lake-id=&quot;441224c8af525c4004f79346b858ddd9&quot; data-wording=&quot;true&quot;&gt;&lt;strong&gt;拷贝数据：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1077943615257049&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yetTcGWJiakOuzNDpuiajaFfeqefR9vjOZEMLNh8OjsCSsaCr7sw5OR6h6GMqaThIQxE0z8wAuQ3k1S9mYrmCLAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1206&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p data-lake-id=&quot;c3a41c410e2e510f565ff7b1627cbe4a&quot; data-wording=&quot;true&quot;&gt;当然还有一些细节的处理，值的注意的是，为了保持高性能，处理数据都是采用[]byte，多处用到*[]byte的引用，复用数据结构，减少内存申请销毁。当然真正的处理逻辑比我这边分析的流程要复杂得多，比如会话状态、授权这些的处理，这里还没列出来。&lt;/p&gt;&lt;p data-lake-id=&quot;0f0feded13e672c32f16a3899bc281a1&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;4195c1b7a215520b03bf69b559e65d49&quot; data-wording=&quot;true&quot;&gt;0x4 展开Tyk代码架构模式&lt;/h3&gt;&lt;p data-lake-id=&quot;39f02fe9f9c8d3bc91a77c050c3929de&quot; data-wording=&quot;true&quot;&gt;通过上一篇的限流和本篇反向的分析，细心点其实可以发现限流是扩展于Tyk的&lt;strong&gt;中间人&lt;/strong&gt;（TykMiddleware）设计，遵循了&lt;strong&gt;装饰器设计模式&lt;/strong&gt;，继承于TykMiddleware抽象interface（java很熟悉的Component接口类），扩展并重写相关的方法。&lt;/p&gt;&lt;p data-lake-id=&quot;36f3d65f4d0383b80de26f7fa0737caf&quot; data-wording=&quot;true&quot;&gt;&lt;strong&gt;中间人抽象:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yetTcGWJiakOuzNDpuiajaFfeqefR9vjOZibROhDibPRGHJ8J4lFLwhGEXa7zDFuRlqXnw144O4OUZCb2QJia7y1nWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;7ecf59fb1f4ff7bac63ed9ec1826b023&quot; data-wording=&quot;true&quot;&gt;每一个具体的中间人主体的入口方法为ProcessRequest，例如我们上一篇的RateLimit。&lt;/p&gt;&lt;p data-lake-id=&quot;4e0cae6a1007843064b6e5b330fabc36&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;56ee667d595e0eb9da762ea35e565001&quot; data-wording=&quot;true&quot;&gt;而本篇的反代却是在限流设计的上一层，api_loader模块，所有处理都会通过api_loader的processSpec，GW的一些预先处理（Prepare）都会放在这里，例如会话、CORS配置、反代等、值得注意的是这里有一个统一的自定义中间件装载的封装（loadCustomMiddleware)，api_loader就是通过这个封装去注册TykMiddleware的中间件，而它们之间的中间件注册数据结构就是 chainArray，一个储存链元素的列表&lt;/p&gt;&lt;p data-lake-id=&quot;e827f2e7423f2d6d2a7ac42bf67288b6&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5194751947519475&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yetTcGWJiakOuzNDpuiajaFfeqefR9vjOZDrW3HdZUx6ib7Ra1JetX28icMP1G1mVtBoBT2UnkJ2vR263UFXh33FOA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2439&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;e71fee1d64b77cc4c0832d534d155650&quot; data-wording=&quot;true&quot;&gt;&lt;strong&gt;中间人链数据：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yetTcGWJiakOuzNDpuiajaFfeqefR9vjOZC1jnzYxcAIURwFAD3Rs1kTwFjAG9jow0hIA90qibyAJGO0cLX2XxjwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;b09aa83cf3785cd54dd4f1f1b11413f8&quot; data-wording=&quot;true&quot;&gt;中间人的ProcessRequest 统一返回error, errorCode， middleware根据这两个值来进行数据流下一步的处理&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.44765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yetTcGWJiakOuzNDpuiajaFfeqefR9vjOZ9gPrZTQUTLAh19F5qpAQCvf1QHiasSicKe0oMvGPyQLvUlO2DH8YadSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p data-lake-id=&quot;57f155a17798a2e3cbd9924afce8717e&quot; data-wording=&quot;true&quot;&gt;&lt;strong&gt;有意思的彩蛋， &lt;/strong&gt;middleware有一种情况就是无错误返回，但是仍然需要返回一个状态码去匹配一些特殊情况，这个状态码就是 &lt;strong&gt;const mwStatusRespond = 666&lt;/strong&gt;，不禁让我想起难道Tyk的coder也是一位老铁？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5645933014354066&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yetTcGWJiakOuzNDpuiajaFfeqefR9vjOZWwcYt83uV7dnEB6eqt85KAcp3QReZeZ5q8fuT4iaRfibjB4Pf4BB08LA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;836&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;h3 data-lake-id=&quot;ea426ac72cfea145ab4689a55c400c35&quot; data-wording=&quot;true&quot;&gt;0x5 为什么这样设计？&lt;/h3&gt;&lt;p data-lake-id=&quot;1986ca613fbf58abd3a409667ca13e9c&quot; data-wording=&quot;true&quot;&gt;又回到这个为什么设计的环节，其实关于http server/容器/框架的设计， middleware（中间人）这个词应该是在很多著名的web框架里面都有出现过的，比如springboot，gin，php的Laravel框架，中间人这种模式特别适合处理由上到下数据流的场景，相当于是一个数据库的filter。&lt;/p&gt;&lt;ul data-lake-id=&quot;a744f4302a5065c83fd2c6d232c2920f&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;middleware支持可插拔(装饰器模式），可随时启用/禁用中间件而整体服务不受影响&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;符合正向性设计，功能模块都是独立的，每一个中间件从处理、日志都是根据中间人本身的需求而定制&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;装饰go原生的 net.http的方法ServeHTTP（http.Handler抽象），其实从这个角度来看，可以套用其他go的web框架来处理http/ws请求，比如gin，httprouter等都是装饰ServeHTTP，方便扩展&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GW load配置时统一注册中间人，不使用的中间人不会有逻辑数据交集，gw运行时的功能设计不涉及多个中间人交互，整体数据流处理是Filter Chain&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yetTcGWJiakOuzNDpuiajaFfeqefR9vjOZNfFH0ibJ33aqnVyBUkvcZ7VQC3Aao8ZtodM864qOC9dnic4uIRic2wiaYA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;1&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;分享科学人文随笔&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;感谢您「观看」、「点赞」和「关注」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点个在看你最好看~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>