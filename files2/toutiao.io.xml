<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>49614090cabbf8c9f4f9e9a7bea43a81</guid>
<title>Go中的HTTP debug技能 了解一下</title>
<link>https://toutiao.io/k/44dmmcz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;HTTP trace的介绍&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Go官方于&lt;em&gt;2016 年 10 月 4 日&lt;/em&gt;发的一篇博文&lt;span&gt;Introducing HTTP Tracing&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。翻译见 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzk0NTI4MTQ4MA==&amp;amp;mid=2247484462&amp;amp;idx=1&amp;amp;sn=7c13727b26280b7171c308e4310d6000&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Go的HTTP tracing&lt;/a&gt;。文中主要举了两个案例：&lt;/p&gt;&lt;p&gt;1.将包含钩子函数的 &lt;strong&gt;httptrace.ClientTrace&lt;/strong&gt; 放入request的context中进行跟踪；&lt;/p&gt;&lt;p&gt;2.对http.Client进行跟踪，使用 &lt;em&gt;http.RoundTripper wrapper&lt;/em&gt; 来标识当前的请求。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go1.7 引入了HTTP trace，可以在HTTP客户端请求过程中收集一些更细粒度的信息，&lt;span&gt;httptrace包&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;提供了HTTP trace的支持，收集的信息可用于调试延迟问题，服务监控，编写自适应系统等。httptrace包提供了许多钩子，在HTTP往返期间收集各种事件的信息，包括连接的创建、复用、DNS解析查询、写入请求和读取响应。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;httptrace包&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;httptrace包提供了追踪HTTP Client请求事件的机制，主要就是trace.go这个文件。&lt;code&gt;trace_test.go&lt;/code&gt; 是对&lt;code&gt;trace.go&lt;/code&gt;中的函数的单元测试。&lt;code&gt;example_test.go&lt;/code&gt;是对httptrace的例子测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以从这里查看&lt;span&gt;trace.go 源码&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;├── example_test.go&lt;br/&gt;├── trace.go&lt;br/&gt;└── trace_test.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从官网博文例子中也可以看出使用了ClientTrace这个struct中的一些钩子函数。下面罗列了ClientTrace中的函数列表。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; ClientTrace &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; GetConn              &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(hostPort &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;                             // 在创建连接之前调用&lt;/span&gt;&lt;br/&gt; GotConn              &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(GotConnInfo)&lt;/span&gt;                                 // 连接成功后调用&lt;/span&gt;&lt;br/&gt; PutIdleConn          &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt;                                   // 当连接用完时需要放回池子调用&lt;/span&gt;&lt;br/&gt; GotFirstResponseByte &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;                                            // 当读到响应的第一个字节时&lt;/span&gt;&lt;br/&gt; Got100Continue       &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;                                            // 当收到的状态码是&quot;100&quot;，则会调用&lt;span&gt;Got100Continue&lt;/span&gt;继续响应&lt;/span&gt;&lt;br/&gt; Got1xxResponse       &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(code &lt;span&gt;int&lt;/span&gt;, header textproto.MIMEHeader)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt; // 为每个 1&lt;span&gt;xx&lt;/span&gt; 信息响应头调用，&lt;span&gt;Got1xxResponse&lt;/span&gt;在最终的非 1&lt;span&gt;xx&lt;/span&gt; 响应之前返回。&lt;/span&gt;&lt;br/&gt; DNSStart             &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(DNSStartInfo)&lt;/span&gt;                                // 当&lt;span&gt;DNS&lt;/span&gt;查询开始时调用&lt;/span&gt;&lt;br/&gt; DNSDone              &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(DNSDoneInfo)&lt;/span&gt;                                 // 当&lt;span&gt;DNS&lt;/span&gt;查询结束时调用&lt;/span&gt;&lt;br/&gt; ConnectStart         &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(network, addr &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;                        // 当一个新连接 &lt;span&gt;Dial&lt;/span&gt;开始时&lt;/span&gt;&lt;br/&gt; ConnectDone          &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(network, addr &lt;span&gt;string&lt;/span&gt;, err error)&lt;/span&gt;             // 当一个新的连接的&lt;span&gt;Dial&lt;/span&gt;完成时&lt;/span&gt;&lt;br/&gt; TLSHandshakeStart    &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;                                            // &lt;span&gt;TLS&lt;/span&gt; 握手开始时调用，当通过&lt;span&gt;HTTP&lt;/span&gt;代理连接到一个&lt;span&gt;HTTPS&lt;/span&gt;站点时，握手发生在代理处理完&lt;span&gt;CONNECT&lt;/span&gt;请求之后。&lt;/span&gt;&lt;br/&gt; TLSHandshakeDone     &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(tls.ConnectionState, error)&lt;/span&gt;                  // 在&lt;span&gt;TLS&lt;/span&gt;握手后被调用，其中包括握手成功的连接状态，或者握手失败的非零错误。&lt;/span&gt;&lt;br/&gt; WroteHeaderField     &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;, value []&lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;                  // 在传输时&lt;span&gt;write&lt;/span&gt;完每个请求头后被调用。&lt;/span&gt;&lt;br/&gt; WroteHeaders         &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;                                            // 在传输时&lt;span&gt;write&lt;/span&gt;完所有请求头后调用的。&lt;/span&gt;&lt;br/&gt; Wait100Continue      &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;                                            // 如果请求时指定了&quot;&lt;span&gt;Expect&lt;/span&gt;: 100-&lt;span&gt;continue&lt;/span&gt;&quot;，且在传输过程中已经写入，但是在写请求正文之前还在等待 &quot;100 &lt;span&gt;Continue&lt;/span&gt;&quot;。&lt;/span&gt;&lt;br/&gt; WroteRequest         &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(WroteRequestInfo)&lt;/span&gt;                            // 在写入请求后调用。在重试请求的情况下，它可以被多次调用。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多同学也应该不是很清楚100状态码的含义，这里科普一下&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;100状态码 ：HTTP100状态码代表的意思是请继续请求，即HTTP 100 Continue 响应状态。HTTP 100 (Http Status Code 100) 状态是HTTP协议的一种响应码，是我们请求访问网站时，服务器端返回的1xx 请求信息系列响应码之一。状态详细说明：&lt;strong&gt;HTTP 100 表示客户端应当继续进行请求&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;引用自&lt;span&gt;HTTP状态码 100 (Continue) 含义详解&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;问题定位破案&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后是如何定位到问题的呢？想必大家看了上面的一系列介绍，也应该猜到了。主要在内部封装的httpclient中加入了clienttrace，并在请求结束后打印了trace的result，通过重新打包部署到k8s开发环境，等待问题复现并查看日志，最后通过观察traceresult发现是域名解析的时候出现了问题，内网域名解析道是空的ip信息，便把域名解析的问题同步报告给k8s部署平台负责的同事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是工程中的一些代码实现。借此机会小土也准备把httptrace工具集成到公共库中，并可以通过apollo平台配置httptrace开关来开启debug定位具体问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *HTTPClient)&lt;/span&gt; &lt;span&gt;Do&lt;/span&gt; &lt;span&gt;(request *http.Request,traceId &lt;span&gt;string&lt;/span&gt;, debug &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(*Response, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// ... define&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; debug {&lt;br/&gt;  clientTrace, traceResult = clientTrace(traceId)&lt;br/&gt;  request = request.WithContext(httptrace.WithClientTrace(request.Context(), clientTrace))&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// ... retry&lt;/span&gt;&lt;br/&gt;  res,err := c.client.Do(request)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; debug {&lt;br/&gt;  data, _ := json.Marshal(traceResult)&lt;br/&gt;  log.Debugf(&lt;span&gt;&quot;[%v] trace info: %s&quot;&lt;/span&gt;, traceId,&lt;span&gt;string&lt;/span&gt;(data))&lt;br/&gt; }&lt;br/&gt;  &lt;span&gt;// ... parse&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;clientTrace&lt;/span&gt;&lt;span&gt;(traceId &lt;span&gt;string&lt;/span&gt; )&lt;/span&gt; &lt;span&gt;(clientTrace *httptrace.ClientTrace,traceResult *TraceResult)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; traceResult = &amp;amp;TraceResult{&lt;br/&gt;    TraceId:traceId,&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt; clientTrace := &amp;amp;httptrace.ClientTrace{&lt;br/&gt;  DNSStart: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(info httptrace.DNSStartInfo)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   currentTime := time.Now().Local().String()&lt;br/&gt;   traceResult.DNS.Start = currentTime&lt;br/&gt;   traceResult.DNS.Host = info.Host&lt;br/&gt;  },&lt;br/&gt;  DNSDone: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(info httptrace.DNSDoneInfo)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      currentTime := time.Now().Local().String()&lt;br/&gt;   traceResult.DNS.End = currentTime&lt;br/&gt;   traceResult.DNS.Addrs = info.Addrs&lt;br/&gt;   traceResult.DNS.Err = info.Err&lt;br/&gt;  },&lt;br/&gt;    &lt;span&gt;// ... 省略一些代码&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; clientTrace, traceResult&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里对httptrace的一些介绍，相信大家也多了一项debug技能，也会对http从请求到响应有了更深的了解。每一个问题都是发现未知的机会，希望gopher们在遇到问题时不要害怕，迎难而上，追根到底。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后希望这篇短文，能给你带来一些帮助。如有问题可以下方留言讨论。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Introducing HTTP Tracing: &lt;span&gt;https://go.dev/blog/http-tracing&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;httptrace包: &lt;span&gt;https://pkg.go.dev/net/http/httptrace&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;trace.go 源码: &lt;span&gt;https://github1s.com/golang/go/blob/HEAD/src/net/http/httptrace/trace.go&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;HTTP状态码 100 (Continue) 含义详解: &lt;span&gt;https://seo.juziseo.com/doc/http_code/100&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/qbln5t9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>13be1dd4906dfee9a06e20864a6835b2</guid>
<title>京东到家App端精准埋点实践</title>
<link>https://toutiao.io/k/przkgk5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;背景与目标&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;埋点系统架构&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新精准曝光系统&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;埋点验证可视化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;成果与展望&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;1&quot; data-textnode-index-1654844906426=&quot;23&quot; data-index-1654844906426=&quot;578&quot; class=&quot;character&quot;&gt;1&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1654844906426=&quot;23&quot; data-index-1654844906426=&quot;579&quot; class=&quot;character&quot;&gt; 背景与目标&lt;/span&gt;&lt;span data-raw-text=&quot;0&quot; data-textnode-index-1654844906426=&quot;23&quot; data-index-1654844906426=&quot;588&quot; class=&quot;character&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1586998087954111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJXKXFtjibXPo9NZQop2IJo3qP7heO1eoCzG3q2o8tZ5NBuqGqyv64HDqgYDObI6VcEBRMjmjeLJrgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2092&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图所示，京东到家埋点的研发链路可以大致分为四步：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开发和验证阶段是对埋点数据准确性影响最大的两个节点。从到家埋点落地以来，准确性一直不高。目前的App端埋点系统已经不足以支撑越来越复杂的业务需求，冗余埋点参数一直得不到有效的清理，埋点系统对业务的侵入性也越来越大，开发过程中要写很多与业务无关的代码来适配埋点的需求，清晰的模块化结构因此产生了不少的耦合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对埋点链路的各个节点的痛点进行了总结：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;无效埋点数据&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：露出上报并没有反映真实用户行为，由于精准曝光规则的缺失，在页面滑动过程中，用户没看见的元素也被当成曝光行为进行上报，产生了大量&lt;span&gt;无效&lt;/span&gt;埋点数据&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;曝光局限性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：由于埋点规则不可调整的局限性，可视区域的规则区分粒度比较粗，所以导致埋点不准确&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;开发效率低&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：埋点需求占用了大量的开发时间，同时埋点与业务模块间耦合严重&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;准确性不高&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：依靠人工验证埋点，很难对已上线的埋点进行二次校验。而埋点的需求迭代又有可能影响到已有埋点，导致线上埋点数据使用的过程中，大约有10%的埋点数据不准确，不能有效对产品需求进行支撑&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;通过原链路各个节点的痛点分析，我们对需要解决的问题进行了合并和归纳，总结出来项目核心目标。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;核心目标&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;到家精准埋点系统旨在实现三个业务上的目标：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;统一&lt;strong&gt;埋点规则&lt;/strong&gt;设计&lt;/strong&gt;，将埋点的各种行为进行区分和细化。（埋点数据的业务定义，通过整理所有历史的埋点，将不规则的埋点进行优化调整，以达到埋点规则的统一）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提升埋点&lt;strong&gt;准确率达到99%&lt;/strong&gt;以上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;过滤埋点无效数据&lt;/strong&gt;，更加精准进行上报，降低埋点数据成本（硬件成本和网络成本）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;技术实现将围绕三个目标：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;降低&lt;/strong&gt;&lt;strong&gt;埋点&lt;/strong&gt;&lt;strong&gt;开发成本&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;曝光规则可配置，&lt;strong&gt;不同埋点规则灵活可变&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;埋点可以进行&lt;strong&gt;有效的机器校验以及可视化校验&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;1&quot; data-textnode-index-1654844906426=&quot;23&quot; data-index-1654844906426=&quot;578&quot; class=&quot;character&quot;&gt;2&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1654844906426=&quot;23&quot; data-index-1654844906426=&quot;579&quot; class=&quot;character&quot;&gt; 埋点系统架构&lt;/span&gt;&lt;span data-raw-text=&quot;0&quot; data-textnode-index-1654844906426=&quot;23&quot; data-index-1654844906426=&quot;588&quot; class=&quot;character&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h4&gt;&lt;span&gt;埋点规则与新系统架构设计&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;目前，&lt;span&gt;App端埋点&lt;/span&gt;采集策略分为&lt;span&gt;点击、&lt;/span&gt;页面以及曝光埋点三种：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;点击埋点&lt;/strong&gt;与业务耦合性最高，但是触发条件以及使用上是最简单的一个，可优化的地方并不多。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;页面埋点&lt;/strong&gt;主要负责记录页面的生命周期，用以还原&lt;span&gt;页面&lt;/span&gt;使用的完整轨迹。功能实现由基础模块统一处理，这块业务耦合性最低，对业务的侵入性也最低，在业务开发的时候对于此类埋点几乎无感知。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;曝光埋点&lt;/strong&gt;则较为复杂，各种业务的埋点规则各不相同，有的重复露出不需要埋点上报，而有的重复露出就需要多次上报，对业务代码的侵入较大，也是占用开发时间最多的埋点种类。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;原先的曝光系统以控件的露出作为上报时机，以全局唯一标识id对相同曝光埋点进行聚合，当App端收集满十条，切页或切后台时，将收集的埋点文件上报，最终将数据上传到埋点数据库。由于对控件露出判断以及各种埋点参数的传递，影响到正常业务模块的逻辑实现，所以解决埋点露出判断和埋点参数的传递就成为架构设计中的重要考量。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9632063074901446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJVxMR6ybTYwMDhpxcEj5a752KOYE47N25IBw5hqVTJ6JDABBUchaiaYlnORYQog0ia6p45b33wWC7wA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;761&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，我们将整个埋点系统架构拆分为了埋点适配层，埋点验证层，埋点服务层三个层级。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;埋点适配层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;埋点适配层（埋点上层服务层）主要用以消除不同应用之间的差距，&lt;span&gt;针对不同业务进行&lt;/span&gt;参数的传递适配。结合客户端自身业务，提供曝光、PV和Click的埋点服务协议声明，不负责具体埋点服务的实现。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;埋点验证层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;埋点验证层与埋点需求平台进行联动，通过埋点需求平台提供的埋点模板数据，与客户端上传的真实数据进行数据正确性校验。实现方式上我们选择以AOP形式切入，降低埋点验证与业务的影响，将验证与埋点系统隔离。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;埋点服务层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;埋点服务层（埋点底层服务层）包括精准曝光系统、曝光聚合系统以及埋点数据文件上传等服务功能。&lt;/p&gt;&lt;p&gt;精准曝光系统将所需要的服务进行封装，接入App配置系统下发的曝光规则来进行曝光规则的调整，然后通过埋点适配层的调用以及容器的传入来监听客户端曝光容器（EPView）的曝光事件，触发曝光埋点上传，最终流向到家埋点数据库，进行数据归档。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;1&quot; data-textnode-index-1654844906426=&quot;23&quot; data-index-1654844906426=&quot;578&quot; class=&quot;character&quot;&gt;3&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1654844906426=&quot;23&quot; data-index-1654844906426=&quot;579&quot; class=&quot;character&quot;&gt; 新精准曝光系统&lt;/span&gt;&lt;span data-raw-text=&quot;0&quot; data-textnode-index-1654844906426=&quot;23&quot; data-index-1654844906426=&quot;588&quot; class=&quot;character&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;以曝光举例，之前的埋点流程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2369565217391305&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJVxMR6ybTYwMDhpxcEj5a75F3b9wz0JK0QJCB0aw9icicNXtkc7xpTjPUlTb0PEw1rcUwDiaWDVI3O7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;460&quot;/&gt;&lt;/p&gt;&lt;p&gt;原先的曝光系统痛点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;开发成本大&lt;/strong&gt;，业务方需要编写大量的代码来添加埋点，往往添加一个埋点成本就需要至少50行代码，并且同一容器的不同埋点代码中存在许多重复的代码逻辑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;精准曝光的缺失&lt;/strong&gt;，不支持对露出比例以及时长的判断&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不支持对可见区域不同的判断，如有的页面带导航栏，有的没有导航栏，一律按照没有导航栏处理，&lt;strong&gt;埋点不够精确&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对部分埋点计算没有优化，将传入的所有追踪实例遍历计算，&lt;strong&gt;计算效率低&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不支持云端配置下发，&lt;strong&gt;曝光规则单一&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果可以将大量的重复性的代码收口统一管理，开发只需要一行代码搞定，那么埋点开发测的效率就提高了许多。但是中间有比较多的问题需要解决。App端控件容器种类较多，想要收口统一管理，需要适配&lt;span&gt;不同类型的容器控件&lt;/span&gt;。原系统之所以没能收口，就是因为无法在&lt;span&gt;黑盒的情况下适配&lt;/span&gt;&lt;span&gt;各种业务场景&lt;/span&gt;。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;新精准曝光系统&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.550122249388753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJVxMR6ybTYwMDhpxcEj5a75vtU0vozxCarRa0BVp5vVLo1re3ia5oLTVBLic491lCYfbyNZEuyJB6Ew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;409&quot;/&gt;&lt;/p&gt;&lt;p&gt;新精准曝光系统在原有的系统上进行优化，新增功能点支撑：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;过滤掉业务端的重复添加曝光&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将跟踪加入的业务视图滑动/拖动/动画/隐藏等，与UE相关行动因子内置进曝光系统内部&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据可配置，露出比例/时长/云端配置等功能内置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;埋点聚合/文件写入/文件上传&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;该系统最初的核心设计目标就是将大量业务重复逻辑植入到系统内部，针对不同的滑动控件进行匹配判断，实现容器的自动追踪；针对不同的刷新模式，自动进行是否重复上报逻辑判断；提供不同的接口以适应不同业务；对容器的展开和收起的自动判断等。&lt;/p&gt;&lt;p&gt;而将业务的大量代码，通过无痕方式切入，存在许多需要攻克的&lt;strong&gt;技术难点&lt;/strong&gt;：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;滑动控件并不是统一的，有滑动的控件，也有非滑动控件。如何适配并且无痕自动追踪滑动/切页而产生的控件露出事件？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;我们的方案是针对不同的容器的种类进行判断匹配，通过KVO的方式追踪容器本身属性的变化作为露出的触发点，而计时器作为页面无滑动时的补充手段，从而达到无痕追踪的效果。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;作&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;黑&lt;/span&gt;&lt;span&gt;盒&lt;/span&gt;&lt;span&gt;系&lt;/span&gt;&lt;span&gt;统&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;需要追踪所有埋点业务视图的露出&lt;/span&gt;&lt;span&gt;事件，&lt;/span&gt;&lt;span&gt;所以要保存埋点业务视&lt;/span&gt;&lt;span&gt;图与埋点行为的&lt;/span&gt;&lt;span&gt;对应关&lt;/span&gt;&lt;span&gt;系&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;如何保证埋点业务视图与埋点数据的对应？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;在前期系统适配模型中建立输入口，通过传入系统初始化模型，来进行业务视图埋点数据key的传入。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;为了避免造成控件生命周期混乱的问题，如何管理对象强弱引用，保证内部引用与外部生命周期一致？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;通过对关系的梳理，确定从滑动容器/滑动容器模型 --&amp;gt; 事件模型的绑定关系，将内部模型生命周期与外部视图进行绑定，来实现外部视图销毁后，事件追踪模型也会销毁。下面会进行详细展开说明。&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;在计算追踪的时候，因为需要调用UIKit的frame进行位置获取，这一步必须在主线程完成，为了不影响性能，需要进行计算量的优化。为了尽量减少需要计算的数量，我们设计了两层漏斗进行过滤：第一层过滤是通过递归判断容器及其父容器是否隐藏，排除掉不活跃的容器；第二层过滤是在活跃的容器中，排除掉其内部不活跃的子容器。最后剩余的容器才进行frame的计算，这样每次滑动的时候，计算量均值大约在10个左右，对性能影响降到最低。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;上述技术难点的实现细节受限于篇幅不再一一展开。下面列举iOS端，来说明如何通过&lt;span&gt;管理&lt;/span&gt;引用机制来&lt;span&gt;&lt;span&gt;解决&lt;/span&gt;&lt;/span&gt;&lt;span&gt;生命周期混乱的问题&lt;/span&gt;。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;iOS端追踪与引用机制&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;通过分析整体埋点机制可知，&lt;span&gt;埋点视图(EPView)&lt;/span&gt;存在从数据模型(Model)到埋点数据&lt;span&gt;(EPModel)&lt;/span&gt;的对应关系，所以建立埋点控件到埋点数据的映射关系是可行的，顺着这个切入点来进行整个生命周期管理的设计。&lt;/p&gt;&lt;p&gt;新版埋点系统提供了两种埋点追踪方式：埋点视图(EPView)或者埋点数据(EPModel)来与埋点行为进行一一对应，通过建立内部EPView/EPModel → UUID → 埋点行为模型(TrackerObj)的映射对所有埋点状态进行追踪。业务方将需要追踪的容器传入，通过容器类型判断进行滑动/拖动/动画/隐藏等行为的监听。&lt;/p&gt;&lt;p&gt;系统为了不影响外部生命周期，对外部引用重新做了梳理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4320685434516524&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJVxMR6ybTYwMDhpxcEj5a75LwvysnvK6icZfpeOyTFSKpPiaLE0ictUNuGM8KWqOiafqrGvHEibxnp4XTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;817&quot;/&gt;&lt;/p&gt;&lt;p&gt;图中绿色代表弱引用，红线代表强引用。如图所示，系统内部使用两个弱引用map表来储存所需的信息，而每个子容器的滑动容器则通过追踪模型来追踪。这样建立起从EPView --&amp;gt; 追踪模型 --&amp;gt; 滑动容器的绑定关系。当外部业务视图(EPView)或者业务模型(EPModel)被释放的时候，业务不需要回调曝光系统进行相应的销毁，该键值会被自动释放，这样极大地缩减了接入的成本。&lt;/p&gt;&lt;p&gt;对外收口的部分，通过精准曝光埋点提供的API&lt;span&gt;来明确埋点追踪的绑定关系&lt;/span&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/// 添加ep进入追踪 需要传入该资源位唯一识别码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// 适用场景：刷新之后，刷了模型，但是资源位没变化，不需要重新报的场景&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// @param epView 需要追踪的epView&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// @param epUID epUID为该资源位唯一识别码，只要这个码不变，并且在屏幕内，即使多次添加不会再次回调&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// @param userAction 与此epview绑定的数据model的userAction&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// @param containers 底部需要追踪的滚动容器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// @param visibleRect 需要曝光的可视区域 坐标系相对于UIWindow&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// @param callback 埋点回调，此处需要手动去处理数据拼接以及埋点&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)addEPView:(&lt;span&gt;UIView&lt;/span&gt; *)epView&lt;br/&gt;       epUniqueID:(&lt;span&gt;NSString&lt;/span&gt; *)epUID&lt;br/&gt;       userAction:(&lt;span&gt;NSString&lt;/span&gt; *)userAction&lt;br/&gt;       containers:(&lt;span&gt;NSArray&lt;/span&gt;&amp;lt;&lt;span&gt;UIView&lt;/span&gt; *&amp;gt; *)containers&lt;br/&gt;      visibleRect:(&lt;span&gt;CGRect&lt;/span&gt;)visibleRect&lt;br/&gt;  epEventCallback:(&lt;span&gt;void&lt;/span&gt; (^)(&lt;span&gt;UIView&lt;/span&gt; * _Nonnull epView))callback;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/// 添加ep进入追踪 需要传入数据Model&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// 适用场景：刷新之后，模型发生了改变并且需要重新曝光的场景&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// @param epView 需要追踪的epView&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// @param model 与此epview绑定的数据model，模型一旦发生改变（对同一个资源位来说模型地址发生变化），则会再次触发回调&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// @param userAction 与此epview绑定的数据model的userAction&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// @param containers 底部需要追踪的滚动容器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// @param visibleRect 需要曝光的可视区域 坐标系相对于UIWindow&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// @param callback 埋点回调，此处需要手动去处理数据拼接以及埋点&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)addEPView:(&lt;span&gt;UIView&lt;/span&gt; *)epView&lt;br/&gt;            model:(&lt;span&gt;NSObject&lt;/span&gt; *)model&lt;br/&gt;       userAction:(&lt;span&gt;NSString&lt;/span&gt; *)userAction&lt;br/&gt;       containers:(&lt;span&gt;NSArray&lt;/span&gt;&amp;lt;&lt;span&gt;UIView&lt;/span&gt; *&amp;gt; *)containers&lt;br/&gt;      visibleRect:(&lt;span&gt;CGRect&lt;/span&gt;)visibleRect&lt;br/&gt; epEventCallback:(&lt;span&gt;void&lt;/span&gt; (^)(&lt;span&gt;UIView&lt;/span&gt; * _Nonnull epView))callback;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;OS使用系统的KVO机制，&lt;/span&gt;&lt;span&gt;辅助针对视图的动画/隐藏等监听来实现。&lt;/span&gt;系统KVO机制虽然好用，但是存在一个致命的缺陷，就是监听实体释放的时候，需要监听者手动释放，不然就会导致崩溃。而代理KVO机制则很好地&lt;/span&gt;&lt;span&gt;解决了这个问题，使用代理代替原先的监听者进行监听，而代理者与被监听的控件生命周期保持一致。&lt;/span&gt;&lt;span&gt;这样便&lt;/span&gt;&lt;span&gt;无需主动解除监听，&lt;/span&gt;&lt;span&gt;弥补了被监听的实体释放而无法通知监听实体释放问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;业务方传入的无论是&lt;span&gt;业务视图(EPView)或者业务模型(EPModel)，都采取统一转换为UUID的形式&lt;/span&gt;，保证了KV键值的统一，提升排查问题的便捷性。&lt;/p&gt;&lt;p&gt;接口层上，区分了曝光的追踪服务、曝光节点的回调服务以及底层上报服务三个接口，分别由三个不同的实例实现，保证不同业务服务之间的隔离。&lt;/p&gt;&lt;p&gt;针对曝光埋点设计了两个追踪的节点，目的是判断是否需要上报曝光埋点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一个是每0.5秒钟触发定时timer，此timer会轮询所有的已添加进来的需要曝光的视图进行计算&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二个是追踪节点为容器滑动回调（KVO机制实现），此回调仅会将滑动容器所绑定的EPView进行计算&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在节点触发的时候，会从两个EPMap中直接获取所需数据，不需要额外的过滤操作，降低了计算的次数，提高整体计算效率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1654844906426=&quot;23&quot; data-index-1654844906426=&quot;579&quot; class=&quot;character&quot;&gt;4 埋点验证可视化&lt;/span&gt;&lt;span data-raw-text=&quot;0&quot; data-textnode-index-1654844906426=&quot;23&quot; data-index-1654844906426=&quot;588&quot; class=&quot;character&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;业务侧痛点收集和分析&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;埋点测试效率&lt;/span&gt;较低&lt;/strong&gt;&lt;span&gt;：一次滑动产生大量埋点数据。之前的验证方式是通过打日志方式、抓包或者数据展示平台直接查看来进行验证，数据无直观关联，需要人眼主动进行关联，验证效率非常低&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;多次上报的曝光次数验证困难&lt;/strong&gt;：有很多其他数据干扰，直接抓包或者数据展示平台无法区分不同的session，只能通过时间节点方式进行人工关联，容易出错&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;相关数据难以查找&lt;/strong&gt;：在数据展示平台上只提供了一级信息的搜索，没办法更加详细的相关信息的筛选&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;技术侧痛点&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;缺乏验测模型数据&lt;/strong&gt;：要做数据验证，没有相关的数据模型进行支撑，无法对本次埋点结果进行自动化的机器校验&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;很难做数据挂钩&lt;/strong&gt;：通过AOP切面方式接入埋点验证，最大化不干扰业务端，带来的弊端就是很难做数据挂钩，捕捉到的埋点视图也很难与埋点数据进行匹配识别。&lt;span&gt;数据平台上的数据密集且难寻，用肉眼验证相当复杂&lt;/span&gt;&lt;span&gt;且容易出错&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1945945945945946&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJVxMR6ybTYwMDhpxcEj5a756XyRfCGdibD1wT4dAet7hS2pjFThEMCrYY8Mj4k0a561wTwR7ohciafw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;740&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;埋点验证功能设计&lt;/span&gt;&lt;/p&gt;&lt;p&gt;埋点验证主要包含以下功能点：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;曝光埋点状态、数据以及上报次数可视化验证&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;埋点数据列表展示以及埋点搜索筛选&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;天河模板下发以及数据自动校验 曝光埋点状态、数据以及上报次数可视化验证&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;为了尽可能追踪埋点状态，根据曝光埋点链条的不同节点，将曝光埋点行为状态化分拆成三种状态：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3358070500927644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJVxMR6ybTYwMDhpxcEj5a75kSNicItWBXGdDEm3650MYSGzXnIGsRAxiczI42OSLgF1BarAoI2duQKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;539&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;追踪中【红色】：埋点已经添加进来，还未判断为露出状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;控件露出【黄色】：控件根据精准曝光条件判断为露出，但未上报状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;已上报【绿色】：曝光时长满足延迟时间，已经回调并且上报&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在业务端这三种状态以不同颜色来表示，通过给埋点控件染色，以达到状态可视化效果。验测的时候，&lt;strong&gt;只需要判断颜色的变化是否符合预期，则可以判定埋点节点的准确性&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;通过对控件的上报埋点回溯绑定当前控件的埋点数据，可以实现使用过程中，&lt;strong&gt;长按控件即显示该控件目前的埋点数据&lt;/strong&gt;。这样快速追踪控件的埋点数据，极大地缩短在海量数据中寻找控件数据的时间。并且&lt;strong&gt;在控件最上层添加信息label，展示当前已经上报过埋点的次数，方便进行上报次数的正确性校验&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1392405063291138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PNm6V9cebJVxMR6ybTYwMDhpxcEj5a755r4vy2NgZhrZCvMJ3usLLeuZAvHckEdWrmC6VGSTLTQ4l7jvI3SUuQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;316&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;埋点可视化验证&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;埋点数据列表展示以及埋点搜索筛选&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;开发过程中，上报的埋点数据列表，以时间为单位进行排序，并且提供搜索功能。搜索的加入能够方便进行埋点数据的归类查找。而筛选功能可以方便验测人员直接进行埋点日志的过滤。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.036363636363636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJVxMR6ybTYwMDhpxcEj5a755gzqUwSI2ibuvOb9ibsWxRia2k285KPfJSiaW4v98zZzicRftXssicibkH86A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;App端内部埋点日志展示与筛选查询&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;天河模板下发以及数据自动校验&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;前端系统与天河系统打通，通过下载天河系统的数据模板和上报数据进行比对，提前发现埋点问题。App端拿到天河系统提供的Key值进行校验，最终验证该埋点数据的准确性，如果key值缺失，进行toast提示提醒，这样在开发验测阶段就可以轻易发现有问题的埋点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;1&quot; data-textnode-index-1654844906426=&quot;23&quot; data-index-1654844906426=&quot;578&quot; class=&quot;character&quot;&gt;5&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1654844906426=&quot;23&quot; data-index-1654844906426=&quot;579&quot; class=&quot;character&quot;&gt; 成果与展望&lt;/span&gt;&lt;span data-raw-text=&quot;0&quot; data-textnode-index-1654844906426=&quot;23&quot; data-index-1654844906426=&quot;588&quot; class=&quot;character&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h4&gt;&lt;span&gt;业务渗透&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;目前在App端，已完成&lt;strong&gt;80%&lt;/strong&gt;相关页面的切换&lt;/p&gt;&lt;h4&gt;&lt;span&gt;成本节约&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;统计近5期的版本，清理&lt;strong&gt;15.08%&lt;/strong&gt;的冗余埋点数据，节约了成本&lt;/p&gt;&lt;h4&gt;&lt;span&gt;埋点准确率提升&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;准确率从原先的90%提升至&lt;strong&gt;98%&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;开发提效&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;代码行数极大得缩减，从原先的平均50行到1行，代码缩减比例达到98%。从而将3天/期/人的埋点开发时间缩短至&lt;strong&gt;0.5天/期/人&lt;/strong&gt;的埋点开发时间。目前到家3个ToC端App已经全面接入使用，针对不同app环境均作了适配，实现&lt;strong&gt;系统的复用&lt;/strong&gt;。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;验测提效&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;验测时间缩短了60%，效率&lt;strong&gt;提升了两倍&lt;/strong&gt;以上&lt;/p&gt;&lt;h4&gt;&lt;span&gt;展望&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;到家新版埋点系统已经稳定运作多版本，目前已经初步达到技术侧以及业务侧定的目标。当然，在埋点链路的优化建设上还有许多不足的地方，如：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;埋点实践只在App端进行了落地，而针对H5、RN的两端的落地，现在还在改造中，很快就会实现三端的对齐&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结合已有能力进行拓宽，借助数据模型到数据下发的闭环，提升至100%的埋点准确率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在效率方面，针对标准化后的埋点进行基类统一处理的方案，将最后的一行代码也优化掉&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;到家App团队接下来会在这几个方面继续深耕，探索并落地更加完善的埋点系统实践。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1053333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJVazRBmASEPHvnx7DYeD65cg5NFrGNgTSciaPTyajHZWMFXgFuKeWImsebL1EN0Lb2e3g90X9EDA9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>44ccc4e203bff48085cb5b2078a0f1cc</guid>
<title>C++异步从理论到实践总览篇</title>
<link>https://toutiao.io/k/1hpd84k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者：&lt;/span&gt;&lt;span&gt;fangshen，腾讯 IEG 客户端开发工程师&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;C++20带来了coroutine特性, 同时新的execution也在提案过程中, 这两者都给我们在C++中解决异步问题带来了新的思路. 但对比其他语言的实现, C++的协程和后续的execution都存在一定的理解和封装成本, 本系列的分享我们将围绕基本的原理, 相应的封装, 以及剥析优秀的第三方实现, 最终结合笔者framework落地的情况来展开.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 纠结的开篇&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前设计我们游戏用的c++框架的时候, 刚好c++20的coroutine已经发布, 又因为是专门 给game server用的c++ framework, 对多线程的诉求相对有限, 或者本着少并发少奇怪的错误的原则, 除网络和IO和日志等少量模块外, 大部分模块主要还是工作在主线程上的, 所以当时设计的重点也就放在了c++20 coroutine的包装和使用上, 更多的使用coroutine来完善异步的支持. 但如果考虑到framework作为前后端公用框架的话, 原来主要针对主线程使用的包装的coroutine调度器就显得有些不够用, 以此作为基础, 我们开始了尝试结合比较新的c++异步思路, 来重新思考应该如何实现一个尽量利用c++新特性, 业务层简单易用的异步框架了.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本系列的主要内容也是围绕这条主线来铺开, 过程中我们 主要以:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;自有的framework异步实现&lt;/strong&gt; - 主要落地尝试利用c++20的coroutine实现一个业务级的调度器.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;asio&lt;/strong&gt; - 这个应该不用多说了, 近年来一直高频迭代, 业界广泛使用的开源第三方库, 中间的异步任务调度, 网络部分的代码实现都非常优质.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;libunifex&lt;/strong&gt; - 最接近当前sender/receiver版 execution提案的可实操版本, c++17/20兼容, 但不推荐使用c++17的版本进行任何尝试, 原因后续文件会展开.&lt;br/&gt;这几个库作为基础, 逐步展开我们对c++异步的探索, 然后再回到落地实践这条主线上, 探讨一个业务侧使用简单, 内部高效的异步库应该如何来实现并落地.  当然, 我们的侧重点主要还是c++异步的调度和处理上, 网络相关的有部分内容可能会简单提到, 但不会进行深入的展开.
  其实整个尝试的过程只能说非常不顺利了, 当然, 随着对相关实现的深入理解和细节的深挖, 收益也是颇多的. 闲话不多说了, 我们直接切入主题, 以对异步的思考来展开这篇总览的内容.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 前尘往事 - rstudio framework实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rstudio framework的异步框架由两块比较独立的部分组成:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一部分是源自asio几年前版本的post和strand部分实现, 另外附加了一些业务侧较常用的像Fence等对象;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另外一部分是主线程的协程调度器实现, 这部分最早是基于c++17实现的一版stackless 协程; 另外一版则是gcc11.1正式发布后, 直接用c++20重构了整个实现, 直接使用c++20的coroutine的一个版本.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 asio 部分&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;  这一部分的内容因为后续有asio scheduler实现具体的分析篇章, 这个地方主要以业务侧使用进行展开了.&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.1 executor概述&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;来源于1.6X boost同期的asio standalone版本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;去除了各平台网络处理相关的代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;仅保留了post和相关的功能(新版本有executor实现)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;早期c++11兼容, 无coroutine支持&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;除网络库外, asio非常有使用价值的一部分代码&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.2  一个简单的使用示例&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  GJobSystem-&amp;gt;Post([]() {&lt;br/&gt;        &lt;span&gt;//some calculate task here&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;        GJobSystem-&amp;gt;Post(&lt;br/&gt;            []() {&lt;br/&gt;                &lt;span&gt;//task notify code here&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;            },&lt;br/&gt;            rstudio::JobSystemType::kLogicJob);&lt;br/&gt;      }, rstudio::JobSystemType::kWorkJob);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相关的时序图:&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2801678908709339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4l6jiaWwnw868fiaEK3qYELYicEGic4ENDOSjDItwAOgHatRBSkwsutkSJKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1906&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.3  当前框架使用的线程结构&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6405693950177936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lnQWicBuPxTCHqCWPOGnWGZlpWGcSZHWsHVO66yKzk2u5OZj9xYhjqdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1686&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;预定义的枚举值:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JobSystemType&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; {&lt;br/&gt;  kLogicJob = &lt;span&gt;0&lt;/span&gt;,       &lt;span&gt;// logic thread(main thread)&lt;/span&gt;&lt;br/&gt;  kWorkJob,            &lt;span&gt;// work thread&lt;/span&gt;&lt;br/&gt;  kSlowJob,            &lt;span&gt;// slow work thread(run io or other slow job)&lt;/span&gt;&lt;br/&gt;  kNetworkJob,         &lt;span&gt;// add a separate thread for network&lt;/span&gt;&lt;br/&gt;  kNetworkConnectJob,  &lt;span&gt;// extra connect thread for network&lt;/span&gt;&lt;br/&gt;  kLogJob,             &lt;span&gt;// log thread&lt;/span&gt;&lt;br/&gt;  kNotifyExternalJob,  &lt;span&gt;// use external process to report something, 1 thread only~~&lt;/span&gt;&lt;br/&gt;  kTotalJobTypes,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不同Job说明:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kLogicJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kWorkJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Work Thread线程池执行任务(多个), 一般是计算量可控的小任务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kSlowJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kNetworkJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kNetworkConnectJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kLogJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;日志专用线程, 目前日志模块是自己起的线程, 可以归并到此处管理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kNotifyExternalJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;专用的通知线程, 如lua error的上报, 使用该类型&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.4  Timer任务相关&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相关接口:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//NoIgnore version&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;uint64_t&lt;/span&gt; &lt;span&gt;JobSystemModule::AddAlwaysRunJob&lt;/span&gt;&lt;span&gt;(JobSystemType jobType,&lt;br/&gt;      threads::ThreadJobFunction&amp;amp;&amp;amp; periodJob, &lt;br/&gt;      &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; periodTimeMs)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;uint64_t&lt;/span&gt; &lt;span&gt;JobSystemModule::AddTimesRunJob&lt;/span&gt;&lt;span&gt;(JobSystemType jobType, &lt;br/&gt;      threads::ThreadJobFunction&amp;amp;&amp;amp; periodJob, &lt;br/&gt;      &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; periodTimeMs, &lt;br/&gt;      &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; runCount)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;      &lt;br/&gt;&lt;span&gt;&lt;span&gt;uint64_t&lt;/span&gt; &lt;span&gt;JobSystemModule::AddDelayRunJob&lt;/span&gt;&lt;span&gt;(JobSystemType jobType,  &lt;br/&gt;      threads::ThreadJobFunction&amp;amp;&amp;amp; periodJob,&lt;br/&gt;      &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; delayTimeMs)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;      &lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;JobSystemModule::KillTimerJob&lt;/span&gt;&lt;span&gt;(&lt;span&gt;uint64_t&lt;/span&gt; tid)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本部分并未直接使用asio原始的basic_waitable_timer实现, 而是自己实现的定时任务.&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.5 在线程池上关联执行任务 - Strand&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;特定的情况下, 被派发到Work线程池的任务存在依赖关系&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;需要串联执行的时候, 这个时候我们需要额外的设施 JobStrand&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;来保证任务是按先后依赖关系来串行执行的&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如下图中part1, part2, part3, part4串行执行的情况所示&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lCGIGIQqZmiback9qKNkaTib2rPpXrCTNCoWqW8lRM5AMV5h22ZEbaXrg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例代码:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;auto&lt;/span&gt; strand = GJobSystem-&amp;gt;RequestStrand(rstudio::JobSystemType::kWorkJob);&lt;br/&gt;starnd.Post([](){ &lt;br/&gt;    &lt;span&gt;//part1~&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;starnd.Post([](){ &lt;br/&gt;    &lt;span&gt;//part2~&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;starnd.Post([](){ &lt;br/&gt;    &lt;span&gt;//part3~ &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;starnd.Post([](){ &lt;br/&gt;    &lt;span&gt;//part4~ &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;starnd.Post([](){ &lt;br/&gt;    GJobSystem-&amp;gt;Post([](){&lt;br/&gt;        &lt;span&gt;//return code here&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }, rstudio::JobSystemType::kLogicJob); &lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.6 其他辅助设施&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JobFence&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;jobs::JobFencePtr &lt;span&gt;JobSystemModule::RequestFence&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;字面义, 栅栏, 起到拦截执行的作用.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一般多用于模块的初始化和结束&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如tbuspp在kNetworkJob上的初始化和结束.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3619246861924686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lqTs7fklVPtWiczxGu3OvFuia3Rs4OjglNM3sCicicIGopJQZwBQQL6Xa8w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1912&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例代码(TcpService的初始化)&lt;/strong&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;job_system_module_-&amp;gt;Post(&lt;br/&gt;    [&lt;span&gt;this&lt;/span&gt;, workTicket]() {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!workTicket || workTicket-&amp;gt;IsExpired()) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        InitInNetworkThread();&lt;br/&gt;    },&lt;br/&gt;    JobSystemType::kNetworkJob);&lt;br/&gt;&lt;br/&gt;period_task_ptr = job_system_module_-&amp;gt;AddAlwaysRunJob(&lt;br/&gt;    JobSystemType::kNetworkJob,&lt;br/&gt;    [&lt;span&gt;this&lt;/span&gt;, workTicket]() {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!workTicket || workTicket-&amp;gt;IsExpired()) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        LoopInNetworkThread();&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;fence_-&amp;gt;FenceTo((&lt;span&gt;int&lt;/span&gt;)JobSystemType::kNetworkJob);&lt;br/&gt;fence_-&amp;gt;Wait();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JobNotify &amp;amp;&amp;amp; JobWaiter&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;jobs::JobWaiterPtr &lt;span&gt;JobSystemModule::RequestWaiter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;jobs::JobNotifyPtr &lt;span&gt;JobSystemModule::RequestNotify&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;批量任务管理使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等待的方式的区别&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;JobNotify&lt;/strong&gt;: 执行完成调用额外指定的回调.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;JobWaiter&lt;/strong&gt;: 以Wait的方式在特定线程等待所有Job执行完成.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JobTicket&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;jobs::JobTicketPtr &lt;span&gt;JobSystemModule::RequestTicket&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;令牌对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一般用来处理跨线程的生命周期控制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回调之前先通过IsExpired()来判断对应对象是否已经释放&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例代码:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GJobSystem-&amp;gt;Post(&lt;br/&gt;  [&lt;span&gt;this&lt;/span&gt;, workTicket]() {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!workTicket || workTicket-&amp;gt;IsExpired()) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; InitInNetworkThread();&lt;br/&gt;  },&lt;br/&gt;  JobSystemType::kNetworkJob);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 asio 与其他实现的对比&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;  正好今年的GDC上有一个&amp;lt;&amp;lt;One Frame In Halo Infinite&amp;gt;&amp;gt;的分享, 里面主要讲述的是对Halo Infinite的引擎升级, 提供新的JobSystem和新的动态帧的机制来支撑项目的, 我们直接以它为例子来对比一下framework和Halo的实现, 并且也借用Halo Infinite的例子, 来更好的了解这种lambda post模式的缺陷, 以及可以改进的点.
  Halo引入新的JobSystem主要是为了将老的Tetris结构的并发模式:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5618055555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lzJm0V4Ww8UxzPVO2j0ib0Te7n2W1oL3NMKjAABpdZSiblLucQ92P8ibcw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;向新的基于Dependency的图状结构迁移:&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lHC1a2xnia1VHGmpMictbJTMp3sqtyAxCq0kWqOFXapLmnpGfMsK4ibSicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他使用的JobSystem的业务Api其实很简单, 我们直接来看一下相关的代码:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;JobSystem&amp;amp; jobSsytem = JobSystem::Get();&lt;br/&gt;JobGraphHandle graphHandle = jobSystem.CreateJobGraph();&lt;br/&gt;&lt;br/&gt;JobHandle jobA = jobSystem.AddJob( &lt;br/&gt; graphHandle, &lt;br/&gt; &lt;span&gt;&quot;JobA&quot;&lt;/span&gt;,&lt;br/&gt; [](){...} );&lt;br/&gt;&lt;br/&gt;JobHandle jobB = jobSystem.AddJob(&lt;br/&gt; graphHandle,&lt;br/&gt; &lt;span&gt;&quot;JobB&quot;&lt;/span&gt;,&lt;br/&gt; [](){...} );&lt;br/&gt;&lt;br/&gt;jobSystem.AddJobToJobDependency(jobA, jobB);&lt;br/&gt;&lt;br/&gt;jobSystem.SubmitJobGraph(graphHandle);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这样的机制, 就很容易形成如:&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5454545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lv1iamtUVNDHCWunZBJibDREpNrcIcy5hMrK9AnicTHq9Dibic2TlDg05Bfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;913&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外还有一个用于同步的SyncPoint:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;JobSystem&amp;amp; jobSystem = JobSystem::Get();&lt;br/&gt;JobGraphHandle graphHandle = jobSystem.CreateJobGraph();&lt;br/&gt;&lt;br/&gt;SyncPointHandle syncPointX = jobSystem.CreateSyncPoint(graphHandle, &lt;span&gt;&quot;SyncPointX&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;JobHandle jobA = jobSystem.AddJob(graphHandle, &lt;span&gt;&quot;JobA&quot;&lt;/span&gt;, [](){...});&lt;br/&gt;JobHandle jobB = jobSystem.AddJob(graphHandle, &lt;span&gt;&quot;JobB&quot;&lt;/span&gt;, [](){...});&lt;br/&gt;&lt;br/&gt;jobSystem.AddJobToSyncPointDependency(jobA, syncPointX);&lt;br/&gt;jobSystem.AddSyncPointToJobDependency(syncPointX, jobB);&lt;br/&gt;&lt;br/&gt;jobSystem.SubmitJobGraph(graphHandle);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致的作用如下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5675487465181058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lTo3UDOjLg9SN8kVUAzPsAc44fUTcZe2mYqzF2F6MuMd9d9m5JljYrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1436&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在workload主动触发SyncPoint后, 整体执行才会继续往下推进, 这样就能方便的加入一些主动的同步点对整个Graph的执行做相关的控制了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到asio, 我们前面也介绍了, 使用strand和post(), 我们也能很方便的构造出Graph形的执行情况 , 而SyncPoint其实类型framework中提供的Event, 表达上会略有差异, 但很容易看出两套实现其实是相当类同的. 这样的话, Halo 的JobSystem有的所有优缺点, framework基本也同样存在了, 这里简单搬运一下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5634588563458857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4libdSFcjs02k1Oic6LkU4FEdfqMAJFgoZ0BpRPAf87cXhYH5ziamYstfTg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1434&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于复杂并发业务的表达以lambda内嵌为主, 虽然这种方式尽可能保证所有代码上下文是比较集中的, 对比纯粹使用callback的模式有所进步, 但这种自由度过高的方式本身也会存在一些问题, 纯粹靠编码者来维系并发上下文的正确性,  这种情况下状态值在lambda之间的传递也需要特别的小心,  容易出错, 并且难以调试。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 coroutine实现部分&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;coroutine部分之前的帖子里已经写得比较详细了, 这里仅给出链接以及简单的代码示例:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如何在C++17中实现stackless coroutine以及相关的任务调度器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C++20 Coroutine实例教学&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另外还有一个purecpp大会的演讲视频,  主要内容与上述的两篇文章相关度比较高, 这里也给出相关的链接, 感兴趣的同学可以自行观看:C++20 coroutine原理与应用&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码示例:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//C++ 20 coroutine&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; clientProxy = mRpcClient-&amp;gt;CreateServiceProxy(&lt;span&gt;&quot;mmo.HeartBeat&quot;&lt;/span&gt;);&lt;br/&gt;mScheduler.CreateTask20([clientProxy]() &lt;br/&gt;                        -&amp;gt; rstudio::logic::CoResumingTaskCpp20 {&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt;* task = rco_self_task();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;step1: task is %llu\n&quot;&lt;/span&gt;, task-&amp;gt;GetId());&lt;br/&gt;    &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::NextFrame{};&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;step2 after yield!\n&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (c &amp;lt; &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;in while loop c=%d\n&quot;&lt;/span&gt;, c);&lt;br/&gt;        &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::Sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        c++;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (c = &lt;span&gt;0&lt;/span&gt;; c &amp;lt; &lt;span&gt;5&lt;/span&gt;; c++) {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;in for loop c=%d\n&quot;&lt;/span&gt;, c);&lt;br/&gt;        &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::NextFrame{};&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;step3 %d\n&quot;&lt;/span&gt;, c);&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; newTaskId = &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::CreateTask(&lt;span&gt;false&lt;/span&gt;, &lt;br/&gt;                                    []()-&amp;gt; logic::CoResumingTaskCpp20 {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;from child coroutine!\n&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::Sleep(&lt;span&gt;2000&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;after child coroutine sleep\n&quot;&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;new task create in coroutine: %llu\n&quot;&lt;/span&gt;, newTaskId);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Begin wait for task!\n&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::WaitTaskFinish{ newTaskId, &lt;span&gt;10000&lt;/span&gt; };&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;After wait for task!\n&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    rstudio::logic::cotasks::RpcRequest &lt;br/&gt;        rpcReq{clientProxy, &lt;span&gt;&quot;DoHeartBeat&quot;&lt;/span&gt;, rstudio::reflection::Args{ &lt;span&gt;3&lt;/span&gt; }, &lt;span&gt;5000&lt;/span&gt;};&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt;* rpcret = &lt;span&gt;co_await&lt;/span&gt; rpcReq;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (rpcret-&amp;gt;rpcResultType == rstudio::network::RpcResponseResultType::RequestSuc) {&lt;br/&gt;        assert(rpcret-&amp;gt;totalRet == &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;auto&lt;/span&gt; retval = rpcret-&amp;gt;retValue.to&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;();&lt;br/&gt;        assert(retval == &lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;rpc coroutine run suc, val = %d!\n&quot;&lt;/span&gt;, retval);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;rpc coroutine run failed! result = %d \n&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;)rpcret-&amp;gt;rpcResultType);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::Sleep(&lt;span&gt;5000&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;step4, after 5s sleep\n&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;co_return&lt;/span&gt; rstudio::logic::CoNil;&lt;br/&gt;} );&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;执行结果:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;step1: task is 1&lt;br/&gt;step2 after yield!&lt;br/&gt;in while loop c=0&lt;br/&gt;in while loop c=1&lt;br/&gt;in while loop c=2&lt;br/&gt;in while loop c=3&lt;br/&gt;in while loop c=4&lt;br/&gt;in for loop c=0&lt;br/&gt;in for loop c=1&lt;br/&gt;in for loop c=2&lt;br/&gt;in for loop c=3&lt;br/&gt;in for loop c=4&lt;br/&gt;step3 5&lt;br/&gt;new task create in coroutine: 2&lt;br/&gt;Begin wait for task!&lt;br/&gt;from child coroutine!&lt;br/&gt;after child coroutine sleep&lt;br/&gt;After wait for task!&lt;br/&gt;service yield call finish!&lt;br/&gt;rpc coroutine run suc, val = 4!&lt;br/&gt;step4, after 5s sleep&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体来看, 协程的使用还是给异步编程带来了很多便利, 但框架本身的实现其实还是有比较多迭代优化的空间的:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;asio的调度部分与coroutine部分的实现是分离的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;coroutine暂时只支持主线程&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 小结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面也结合halo的实例说到了一些限制, 那么这些问题有没有好的解决办法了, 答案是肯定的, 虽然execution并未完全通过提案, 但整体而言, execution新的sender/reciever模型, 对于解决上面提到的一些缺陷, 应该是提供了非常好的思路, 我们下一章节中继续展开.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. so easy - execution就是解?&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最开始的想法其实比较简单, 结合原来的framework, 适当引入提案中的execution一些比较可取的思路, 让framework的异步编程能更多的吸取c++新特性和execution比较高级的框架抽象能力, 提升整个异步库的实现质量. 所以最开始定的主线思路其实是更多的向execution倾斜, 怎么了解掌握execution, 怎么与现在的framework结合成了主线思路.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们选择的基础参考库是来自冲元宇宙这波改名的Meta公司的libunifex, 客观来说, Meta公司的folly库, 以及libunifex库的实现质量, 肯定都是业界前沿的, 对c++新特性的使用和探索, 也是相当给力的. 这些我们后续在分析libunifex具体实现的篇章中也能实际感受到.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但深入了解libunifex后, 我们会发现, 它的优点有不少:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;尝试为c++提供表达异步的框架性结构.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;泛型用得出神入化, ponder在它前面基本是小弟级别的, 一系列泛用性特别强的template 编程示例, 比如隐含在sender/receiver思路内的lazy evaluate表达, 如何在大量使用泛型的情况下提供业务定制点等等.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结构化的表达并发和异步, 相关代码的编写从自由发挥自主把控走向框架化, 约束化, 能够更有序更可靠的表达复杂异步逻辑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;整个执行pipeline的组织, 所有信息是compile time和runtime完备的, dependencies不会丢失.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点之间的值类型是强制检查的, 有问题的情况 , 大多时候compiler time就会报错.
有不少优点的同时, 也有很多缺点:&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;整个库的实现严重依赖了c++20 ranges采用的一种定制手段 cpo, 并且也使用了类似ranges的pipe表达方法, 理解相关代码存在一定的门坎.(后续会有具体的篇章展开相关的内容)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;库同时向下兼容了c++17, 但由于c++17本身特性的限制, 引入了大量的宏, 以及X Macros展开的方式, 导致相关的代码阅读难度进一步提升. 但实际上c++17版本并不具备可维护的价值, 依赖SIFINAE的实现, 如果中间任何一环报错, 必然需要在N屏的报错中寻找有效信息.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;libunifex对coroutine的支持存疑, 虽然让coroutine可以作为一种reciever存在, 但本质上来说, coroutine其实更适合拿来做流程控制的胶水, 而不是作为异步中的某个节点存在.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认的scheduler实现质量离工业级还存在一定的距离, 这一点后续的代码分析中也会具体提到.
诸多问题的存在, 可能也是execution提案没有短时间内获得通过的原因吧, 但整体来说, execution本身的理念还是很有参考价值的, 但以它的现状来说, 离最终的解肯定还是有比较大的距离的.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 尝试重新思考 - 要什么, 用什么&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事情到这个点就有点尴尬了, 原有的asio, 架构层面来说, 跟新的execution是存在落差的. 而项目实践上来说, asio相当稳扎稳打, 而以libunifex当前的状态来说, 离工业化使用其实是有一定距离的. 但asio作者在21年时候的两篇演讲(更像coding show):&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Talking Async Ep1: Why C++20 is the Awesomest Language for Network Programming&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Talking Async Ep2: Cancellation in depth第一篇基本整个演示了asio从最开始的callback, 到融入c++20 coroutine后的优雅异步表达, 我们可以通过下面的代码片断感受一下:&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;asio相关示例代码1&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;awaitable&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt; &lt;span&gt;listen&lt;/span&gt;&lt;span&gt;(tcp::acceptor&amp;amp; acceptor, tcp::endpoint target)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (;;)&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; [e, client] = &lt;span&gt;co_await&lt;/span&gt; acceptor.async_accept(use_nothrow_awaitable);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (e)&lt;br/&gt;      &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; ex = client.get_executor();&lt;br/&gt;    co_spawn(ex, proxy(&lt;span&gt;std&lt;/span&gt;::move(client), target), detached);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;asio相关示例代码2&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;auto&lt;/span&gt; [e] = &lt;span&gt;co_await&lt;/span&gt; server.async_connect(target, use_nothrow_awaitable);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!e)&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;co_await&lt;/span&gt; (&lt;br/&gt;        (&lt;br/&gt;          transfer(client, server, client_to_server_deadline) ||&lt;br/&gt;          watchdog(client_to_server_deadline)&lt;br/&gt;        )&lt;br/&gt;        &amp;amp;&amp;amp;&lt;br/&gt;        (&lt;br/&gt;          transfer(server, client, server_to_client_deadline) ||&lt;br/&gt;          watchdog(server_to_client_deadline)&lt;br/&gt;        )&lt;br/&gt;      );&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对比原来每个async_xxx()函数后接callback的模式, 整个实现可以说是相当的优雅了, 代码的可读性也得到了极大的提高, 这两段代码都来自于上面的演讲中, 想深入了解的可以直接打开相关的链接观看视频, 很推荐大家去看一下.
  能够把复杂的事情用更简洁易懂的方法表达, 这肯定是让人振奋的, 当然, 深入了解相关实现后, 也会发现存在一些问题, 但我们的本意是参考学习, 得出最终想要的可以比较好的支撑并发和异步业务的基础框架, 有这些, 其实已经可以理出一条比较清晰的思路了:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;execution部分主要使用它的sender/receiver概念, 和它提供的一些通用的算法. 移除掉所有因为fallback c++17引入的大量代码噪声. 抛弃它并不完备的各种scheduler实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协程借鉴部分asio的思路, 首先让协程可以基于context上下文, 在跨线程的情况下使用, 另外更多还是使用原有框架有明确的scheduler的方式对所有协程进行管理和定制的模式.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用asio的scheduler部分作为execution的底层scheduler实现, 同时也使用asio的timer表达, 去除原始libunifex依赖不同scheduler提供schedule_at()方法来执行定时器相关逻辑的实现.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据业务需要, 定制一些必要的sender adapter等简化业务的使用.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尝试用execution框架对接ISPC等特殊的并发库, 能够以一个清晰的方式来表达这种混合环境上执行的逻辑.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本系列涉及的基础知识和相关内容比较多, 先给出一个临时的大纲, 后续可能会有调整. 目前的思路是先介绍大家相对熟悉度不那么高的execution基础知识和libunifex, 后面再介绍asio相关的scheduler以及coroutine实现, 最后再回归笔者正在迭代的framework, 这样一个顺序来展开.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;One Frame in Halo Infinite&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;asio官网&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;libunifex源码库&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1eaa456a8a6479a0a8730d63186a22d4</guid>
<title>PHP 面试经常被问到的知识点汇总，对你非常有用</title>
<link>https://toutiao.io/k/njpkhk5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;PHP开发者&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;phpDevs&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;「PHP开发者」专注分享 PHP 开发相关的技术文章和工具资源。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>