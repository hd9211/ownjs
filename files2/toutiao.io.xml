<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>21e4403514d8aa09e119ec0c1c1bdf2d</guid>
<title>Java泛型详解，史上最全图文详解！</title>
<link>https://toutiao.io/k/chtkqxo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mid=&quot;&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;点击蓝字&lt;/span&gt;&lt;span&gt;&lt;span&gt;关注&lt;/span&gt;&lt;span&gt;&lt;span&gt;△&lt;/span&gt;&lt;/span&gt;&lt;span&gt;回复&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;【&lt;/span&gt;&lt;span&gt;架构&lt;/span&gt;&lt;span&gt;】&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong&gt;&lt;span&gt;领取300期+BAT架构技术系列文章与1000+大厂面试题答案合集&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.400352733686067&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVeCmXchLLhiaOatUyyjibibUOBhicSy4nRUFHCyd8XxWrqDUA8GrAg9mFLuVEJgIDrrZDP7rLAicAmOTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1134&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;泛型在java中有很重要的地位，无论是开源框架还是JDK源码都能看到它。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;毫不夸张的说，泛型是通用设计上必不可少的元素，所以真正理解与正确使用泛型，是一门必修课。&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;一：泛型本质&lt;/h2&gt;&lt;p&gt;Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;泛型的本质是参数化类型&lt;/strong&gt;，即给类型指定一个参数，然后在使用时再指定此参数具体的值，那样这个类型就可以在使用时决定了。这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31556195965417866&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVeCmXchLLhiaOatUyyjibibUOl5XJkFmkCVJsbKbicoiaEswa3SIePT9TPLGK2DP4KgbjjDKuzahIvqCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot; title=&quot;Java泛型详解，史上最强图文详解！-mikechen的互联网架构&quot;/&gt;&lt;/p&gt;&lt;h2&gt;二：为什么使用泛型&lt;/h2&gt;&lt;p&gt;泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6034782608695652&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVeCmXchLLhiaOatUyyjibibUOLfzBBUk2EjBD0bH7mJogf19tKtvRIlKICj3uqtOiaMzagMTf1iaVahDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;575&quot; title=&quot;Java泛型详解，史上最强图文详解！-mikechen的互联网架构&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（1）保证了类型的安全性。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换，如果不小心插入了错误的类型对象，在运行时的转换处理就会出错。&lt;/p&gt;&lt;p&gt;比如：没有泛型的情况下使用集合：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; noGeneric&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ArrayList&lt;/span&gt;&lt;span&gt; names &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ArrayList&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;mikechen的互联网架构&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;//编译正常&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;有泛型的情况下使用集合：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; useGeneric&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ArrayList&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; names &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ArrayList&lt;/span&gt;&lt;span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;mikechen的互联网架构&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;//编译不通过&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;有了泛型后，定义好的集合names在编译的时候add(123)就会编译不通过。&lt;/p&gt;&lt;p&gt;相当于告诉编译器每个集合接收的对象类型是什么，编译器在编译期就会做类型检查，告知是否插入了错误类型的对象，使得程序更加安全，增强了程序的健壮性。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2） 消除强制转换&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;泛型的一个附带好处是，消除源代码中的许多强制类型转换，这使得代码更加可读，并且减少了出错机会。&lt;br/&gt;还是举例说明，以下没有泛型的代码段需要强制转换：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;List&lt;/span&gt;&lt;span&gt; list &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ArrayList&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; list&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;当重写为使用泛型时，代码不需要强制转换：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;List&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; list &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ArrayList&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; list&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;// no cast&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;（3）避免了不必要的装箱、拆箱操作，提高程序的性能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在非泛型编程中，将筒单类型作为Object传递时会引起Boxing（装箱）和Unboxing（拆箱）操作，这两个过程都是具有很大开销的。引入泛型后，就不必进行Boxing和Unboxing操作了，所以运行效率相对较高，特别在对集合操作非常频繁的系统中，这个特点带来的性能提升更加明显。&lt;/p&gt;&lt;p&gt;泛型变量固定了类型，使用的时候就已经知道是值类型还是引用类型，避免了不必要的装箱、拆箱操作。&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; a&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//由于是object类型，会自动进行装箱操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b&lt;/span&gt;&lt;span&gt;=(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//强制转换，拆箱操作。这样一去一来，当次数多了以后会影响程序的运行效率。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;使用泛型之后&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; T &lt;/span&gt;&lt;span&gt;GetValue&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;(&lt;/span&gt;&lt;span&gt;T a&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;GetValue&lt;/span&gt;&lt;span&gt;&amp;lt;int&amp;gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt;//使用这个方法的时候已经指定了类型是int，所以不会有装箱和拆箱的操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;（4）提高了代码的重用性。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;h2&gt;三：如何使用泛型&lt;/h2&gt;&lt;p&gt;泛型有三种使用方式，分别为：泛型类、泛型接口和泛型方法。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5742574257425742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVeCmXchLLhiaOatUyyjibibUOgYd350a7gzc2ib4QEQu1pfLLxO2DsuqZfnPZUpzvK9qZkias6oBiaiay2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;606&quot; title=&quot;Java泛型详解，史上最强图文详解！-mikechen的互联网架构&quot;/&gt;&lt;/p&gt;&lt;h3&gt;1、泛型类&lt;/h3&gt;&lt;p&gt;泛型类：把泛型定义在类上&lt;/p&gt;&lt;p&gt;定义格式：&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2514484356894554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVeCmXchLLhiaOatUyyjibibUOywZOupcZo43VumpgHY7m2ZH19HKOwyXy3iaPS086MuWOb8ibqEgRRTOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;863&quot; title=&quot;Java泛型详解，史上最强图文详解！-mikechen的互联网架构&quot;/&gt;&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;类名&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;lt;泛型类型&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,...&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;注意事项：泛型类型必须是引用类型（非基本数据类型）&lt;/p&gt;&lt;p&gt;定义泛型类，在类名后添加一对尖括号，并在尖括号中填写类型参数，参数可以有多个，多个参数使用逗号分隔：&lt;/p&gt;&lt;p&gt;public class GenericClass&amp;lt;ab,a,c&amp;gt; {}&lt;/p&gt;&lt;p&gt;当然，这个后面的参数类型也是有规范的，不能像上面一样随意，通常类型参数我们都使用大写的单个字母表示：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;T：任意类型 type&lt;br/&gt;E：集合中元素的类型 element&lt;br/&gt;K：key-value形式 key&lt;br/&gt;V：key-value形式 value&lt;br/&gt;示例代码：&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;泛型类：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GenericClass&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; T value&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GenericClass&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;T value&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;value &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T getValue&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; setValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;T value&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;value &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;测试类：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;//TODO 1:泛型类&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GenericClass&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GenericClass&lt;/span&gt;&lt;span&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span&gt;&quot;mikechen的互联网架构&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;span&gt;());&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GenericClass&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Integer&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; number &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GenericClass&lt;/span&gt;&lt;span&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;span&gt;());&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;运行结果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16765578635014836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVeCmXchLLhiaOatUyyjibibUOB8ErqUjvPDc2yE1hRlE3AhwO9c5gvz8CCZsoEqdJnLiar1wiaVianLcoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;674&quot; title=&quot;Java泛型详解，史上最强图文详解！-mikechen的互联网架构&quot;/&gt;&lt;/p&gt;&lt;h3&gt;2、泛型接口&lt;/h3&gt;&lt;p&gt;泛型方法概述：把泛型定义在方法上&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2564102564102564&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVeCmXchLLhiaOatUyyjibibUOzBNuwukQxwRbX2jSkVvG4Lcc7Jic38aBKiagiafuEeMtZDL3H5JKYEiaSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;858&quot; title=&quot;Java泛型详解，史上最强图文详解！-mikechen的互联网架构&quot;/&gt;&lt;br/&gt;定义格式：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;lt;泛型类型&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;返回类型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;方法名（泛型类型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;变量名）&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GenericInterface&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; show&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;T value&lt;/span&gt;&lt;span&gt;);}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;StringShowImpl&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GenericInterface&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; show&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;NumberShowImpl&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GenericInterface&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Integer&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; show&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Integer&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;注意：使用泛型的时候，前后定义的泛型类型必须保持一致，否则会出现编译异常：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GenericInterface&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; genericInterface &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;NumberShowImpl&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;span&gt;//编译异常&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;或者干脆不指定类型，那么 new 什么类型都是可以的：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GenericInterface&lt;/span&gt;&lt;span&gt; g1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;NumberShowImpl&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GenericInterface&lt;/span&gt;&lt;span&gt; g2 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;StringShowImpl&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;h3&gt;3、泛型方法&lt;/h3&gt;&lt;p&gt;泛型方法，是在调用方法的时候指明泛型的具体类型 。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2537485582468281&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVeCmXchLLhiaOatUyyjibibUOaTt73tI74hM4H93HmHMfOHviaHW0GYkPVZNIvT6504PhEFKQ7bbwOeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;867&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;修饰符 &amp;lt;代表泛型的变量&amp;gt; 返回值类型 方法名(参数){ }&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;/**&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;     *&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;     * @param t 传入泛型的参数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;     * @param &amp;lt;T&amp;gt; 泛型的类型&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;     * @return T 返回值为T类型&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;     * 说明：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;     *   1）public 与 返回值中间&amp;lt;T&amp;gt;非常重要，可以理解为声明此方法为泛型方法。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;     *   2）只有声明了&amp;lt;T&amp;gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;     *   3）&amp;lt;T&amp;gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;     *   4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E等形式的参数常用于表示泛型。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;     */&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; T genercMethod&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;T t&lt;/span&gt;&lt;span&gt;){&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getClass&lt;/span&gt;&lt;span&gt;());&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;span&gt; args&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;GenericsClassDemo&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; genericString  &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GenericsClassDemo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;helloGeneric&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;//这里的泛型跟下面调用的泛型方法可以不一样。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; str &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; genericString&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;genercMethod&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt;//传入的是String类型,返回的也是String类型&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;Integer&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; genericString&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;genercMethod&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt;//传入的是Integer类型,返回的也是Integer类型&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; java&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; java&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Integer&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;123&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;这里可以看出，泛型方法随着我们的传入参数类型不同，他得到的类型也不同。泛型方法能使方法独立于类而产生变化。&lt;/p&gt;&lt;h2&gt;四：泛型通配符&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Java泛型的通配符是用于解决泛型之间引用传递问题的特殊语法, 主要有以下三类:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3939393939393939&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVeCmXchLLhiaOatUyyjibibUOZKGuZbjz0l89soQ3eYvcKZErs7tEHMWYLFcXQ0d6wKK9W4SDtT1VLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;891&quot; title=&quot;Java泛型详解，史上最强图文详解！-mikechen的互联网架构&quot;/&gt;&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;// 1：表示类型参数可以是任何类型&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Apple&lt;/span&gt;&lt;span&gt;&amp;lt;?&amp;gt;{}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;// 2：表示类型参数必须是A或者是A的子类&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Apple&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T &lt;/span&gt;&lt;span&gt;extends&lt;/span&gt;&lt;span&gt; A&lt;/span&gt;&lt;span&gt;&amp;gt;{}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;// 3: 表示类型参数必须是A或者是A的超类型&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Apple&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T supers A&lt;/span&gt;&lt;span&gt;&amp;gt;{}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;1. 无边界的通配符(Unbounded Wildcards), 就是&amp;lt;?&amp;gt;, 比如List&amp;lt;?&amp;gt;&lt;/strong&gt;&lt;br/&gt;无边界的通配符的主要作用就是让泛型能够接受未知类型的数据.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. 固定上边界的通配符(Upper Bounded Wildcards)，采用&amp;lt;? extends E&amp;gt;的形式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;使用固定上边界的通配符的泛型, 就能够接受指定类及其子类类型的数据。&lt;/p&gt;&lt;p&gt;要声明使用该类通配符, 采用&amp;lt;? extends E&amp;gt;的形式, 这里的E就是该泛型的上边界。&lt;/p&gt;&lt;p&gt;注意: 这里虽然用的是extends关键字, 却不仅限于继承了父类E的子类, 也可以代指显现了接口E的类&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3. 固定下边界的通配符(Lower Bounded Wildcards)，采用&amp;lt;? super E&amp;gt;的形式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;使用固定下边界的通配符的泛型, 就能够接受指定类及其父类类型的数据.。&lt;/p&gt;&lt;p&gt;要声明使用该类通配符, 采用&amp;lt;? super E&amp;gt;的形式, 这里的E就是该泛型的下边界.。&lt;/p&gt;&lt;p&gt;注意: 你可以为一个泛型指定上边界或下边界, 但是不能同时指定上下边界。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;五：泛型中KTVE的含义&lt;/h2&gt;&lt;p&gt;果点开JDK中一些泛型类的源码，我们会看到下面这些代码：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ArrayList&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;extends&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;AbstractList&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;List&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;RandomAccess&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Cloneable&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; java&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Serializable&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;extends&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;AbstractMap&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Map&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Cloneable&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Serializable&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;上面这些泛型类定义中的泛型参数E、K和V都是什么意思呢？&lt;/p&gt;&lt;p&gt;其实这些参数名称是可以任意指定，就想方法的参数名一样可以任意指定，但是我们通常会起一个有意义的名称，让别人一看就知道是什么意思。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;常见泛型参数名称有如下：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;E：Element (在集合中使用，因为集合中存放的是元素)&lt;br/&gt;T：Type（Java 类）&lt;br/&gt;K：Key（键）&lt;br/&gt;V：Value（值）&lt;br/&gt;N：Number（数值类型）&lt;br/&gt;？：表示不确定的java类型&lt;/p&gt;&lt;h2&gt;六：泛型的实现原理&lt;/h2&gt;&lt;p&gt;泛型本质是将数据类型参数化，它通过擦除的方式来实现，即编译器会在编译期间「擦除」泛型语法并相应的做出一些类型转换动作。&lt;/p&gt;&lt;p&gt;看一个例子就应该清楚了，例如：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Caculate&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; T num&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;我们定义了一个泛型类，定义了一个属性成员，该成员的类型是一个泛型类型，这个 T 具体是什么类型，我们也不知道，它只是用于限定类型的。&lt;/p&gt;&lt;p&gt;反编译一下这个 Caculate 类：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Caculate&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Caculate&lt;/span&gt;&lt;span&gt;(){}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt; num&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;发现编译器擦除 Caculate 类后面的两个尖括号，并且将 num 的类型定义为 Object 类型。&lt;/p&gt;&lt;p&gt;那么是不是所有的泛型类型都以 Object 进行擦除呢？大部分情况下，泛型类型都会以 Object 进行替换，而有一种情况则不是。那就是使用到了extends和super语法的有界类型，如：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Caculate&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T &lt;/span&gt;&lt;span&gt;extends&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; T num&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;这种情况的泛型类型，num 会被替换为 String 而不再是 Object。&lt;/p&gt;&lt;p&gt;这是一个类型限定的语法，它限定 T 是 String 或者 String 的子类，也就是你构建 Caculate 实例的时候只能限定 T 为 String 或者 String 的子类，所以无论你限定 T 为什么类型，String 都是父类，不会出现类型不匹配的问题，于是可以使用 String 进行类型擦除。&lt;/p&gt;&lt;p&gt;实际上编译器会正常的将使用泛型的地方编译并进行类型擦除，然后返回实例。但是除此之外的是，如果构建泛型实例时使用了泛型语法，那么编译器将标记该实例并关注该实例后续所有方法的调用，每次调用前都进行安全检查，非指定类型的方法都不能调用成功。&lt;/p&gt;&lt;p&gt;实际上编译器不仅关注一个泛型方法的调用，它还会为某些返回值为限定的泛型类型的方法进行强制类型转换，由于类型擦除，返回值为泛型类型的方法都会擦除成 Object 类型，当这些方法被调用后，编译器会额外插入一行 checkcast 指令用于强制类型转换，这一个过程就叫做『泛型翻译』。&lt;/p&gt;&lt;h2&gt;七：最后&lt;/h2&gt;&lt;p&gt;以上我就分别从Java泛型的本质，再到泛型的使用，以及泛型的实现原理等六个方面进行了完整详解，希望对你有所用！&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;必看●文章干货&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MDAxNDEwMA==&amp;amp;mid=2247488808&amp;amp;idx=1&amp;amp;sn=258331df45fc236b0650e3e1b197398a&amp;amp;chksm=fcf4b5d3cb833cc555733775e15df0075e56cef9e8cbce6034927b7dcd79b633e5437e998bcc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;史上最强消息队列MQ万字图文总结！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/8280.html&quot; textvalue=&quot;JVM(Java虚拟机)从0到1全部合集，强烈建议收藏！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;JVM(Java虚拟机)从0到1全部合集，强烈建议收藏！&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/8225.html&quot; textvalue=&quot;Java多线程与并发系列从0到1全部合集，强烈建议收藏！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Java多线程与并发系列从0到1全部合集，强烈建议收藏！&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/7161.html&quot; textvalue=&quot;单点登录SSO的实现原理与方案详解&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;单点登录SSO的实现原理与方案详解&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/7319.html&quot; textvalue=&quot;史上最强消息队列MQ万字图文总结！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;史上最强消息队列MQ万字图文总结！&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;必看●视频干货&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/779.html&quot; textvalue=&quot;如何快速达到50W+年薪？我的独家经验分享！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;如何快速达到50W+年薪？我的独家经验分享！&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/779.html&quot; textvalue=&quot;如何快速达到50W+年薪？我的独家经验分享！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;如何高效进阶架构师？我的独家三部曲！必看&lt;/a&gt;！&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/779.html&quot; textvalue=&quot;阿里P6-&amp;gt;P7-&amp;gt;P8有哪些技能要求？哪些技术栈需要精通？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;阿里P6-&amp;gt;P7-&amp;gt;P8的技能要求？独家完整揭秘！&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/779.html&quot; textvalue=&quot;如何快速达到50W+年薪？我的独家经验分享！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;2022金三银四最新一线大厂Java必考题解析！进大厂必看！&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;关注「mikechen的互联网架构」公众号，回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;【&lt;/span&gt;&lt;span&gt;&lt;strong&gt;架构&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;】&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，领取我&lt;/span&gt;原创的300期+BAT架构技术系列文章与1000+大厂面试题答案合集&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如果你对大厂架构、大厂项目、进阶架构师等感兴趣或者遇到职业发展瓶颈想交流，&lt;span&gt;关注「mikechen的互联网架构」公众号，&lt;/span&gt;回复&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;【交流】&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，即可加我微信，一起交流学习。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVeCmXchLLhiaOatUyyjibibUOMaT2IXKy4LugIbJCmwe90rvtjQRl1DMABWl11jPQvuPdrmibVia3ppOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1350&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>29b77fe718063058936efb21272033ff</guid>
<title>外部接口大量超时，把整个系统拖垮，引发雪崩！如何解决？</title>
<link>https://toutiao.io/k/w133tux</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;互联网+ 时代，业务数字化已经蔓延到你能想到的各个行业。&lt;/span&gt;&lt;span&gt;各种业务功能、营销玩法越来越多，系统也越来越复杂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面对不断复杂的业务系统，脑子越来越不够用了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9067796610169492&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwcNhClj0XcdlERS9kWhERsrf9uTGexU7kUqCgeTcpwsjJrhdQPmZ8TsXNcr50ZyLeXDlXrtOLiarbg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;236&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;于是聪明的人们提出了微服务的设计思想。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本着复杂的事情简单化的原则，我们将一个大的系统拆分成若干个子系统，每个子系统职责单一。按 DDD 的设计理念，承载一个子域的业务建设。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;于是，人们可以将精力聚焦，专心完成某一个业务点的深度建设。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多个微服务系统之间通过 RPC 框架（如 Dubbo、Spring Cloud、gRPC 等）完成了串联，但随着调用量越来越大，人们发现服务与服务之间的稳定性变得越来越重要。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5569620253164557&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwcNhClj0XcdlERS9kWhERsrPEB0DXEEBxsWrdz9ZnOGjr7Zl8ofEq7xKGsUmoUVWRss4vfPbR3Obw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;869&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;举个例子：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Service D 挂了，响应很慢；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Service G 和 Service F 都依赖 Service D 也会受到牵连，对外响应也会变慢；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;影响层层向上传递，Service A 和 Service B 也会被拖垮；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;最后引发雪崩效应，系统的故障影响面会越来越大。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决这种问题，我们需要引入熔断机制。“&lt;/span&gt;&lt;span&gt;当断则断，不受其乱。当断不断，必受其难&lt;/span&gt;&lt;span&gt;”。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;什么是熔断？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;熔断，其实是对调用链路中某个资源出现不稳定状态时（如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败。避免影响到其它的资源而导致级联错误。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当资源被降级后，在接下来的降级时间窗口内，对该资源的调用都自动熔断（默认是抛出 BlockException）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前市面上的熔断框架很多，如 Sentinel、Hystrix、Resilience4j 等，这些框架的设计理念都差不多。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文重点讲下 Sentinel 是如何在项目中使用的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Sentinel （分布式系统的流量防卫兵）是阿里开源的一套用于服务容错的综合性解决方案。它以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来保护服务的稳定性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;核心分为两部分：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;entinel 熔断种类：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Sentinel 安装&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，官网下载 Sentinel 控制台安装包。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下载地址：https://github.com/alibaba/Sentinel/releases&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下载 jar 包后，打开终端运行命令：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;java&lt;/span&gt; -Dserver.port=&lt;span class=&quot;code-snippet__number&quot;&gt;8180&lt;/span&gt; -Dcsp.sentinel.dashboard.server=localhost:&lt;span class=&quot;code-snippet__number&quot;&gt;8180&lt;/span&gt; -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;.jar&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;登录 Sentinal 控制台。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6229260935143288&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwcNhClj0XcdlERS9kWhERsrl4OFibGhuMLACUZdXgR4bMJqDIM9pibRb9STG5z3Y7gNqMIaRVbSGaHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;663&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;默认用户和密码都是 Sentinel。登录成功后的界面如下，先来个直观感受。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.40370370370370373&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwcNhClj0XcdlERS9kWhERsrh8D8gibMe8CNickuN4mDW9XtduJkJqufbqXIrxBbR01oWMebbWURqrpw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;控制台配置熔断规则：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5821064552661381&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwcNhClj0XcdlERS9kWhERsrm61CsyIv6UyZj03NUSiaic0joDewz8v8iaibqIVEdb5srQibNfmSB4LMgxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;883&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里表示熔断策略选择 慢调用比例，响应时间超过 200 毫秒则标记为慢请求。如果在一个 1000ms 的统计周期内（可自行调整）。慢请求比例超过 30% 且数量超过 3 个，则对后续请求进行熔断，熔断时长为 10 秒钟。10 秒以后恢复正常。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;注解式接入&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接入非常简单，只需要提前在控制台配置好资源规则，然后在代码中添加 @SentinelResource 注解即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/handle1&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@SentinelResource&lt;/span&gt;(value = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;handle1&quot;&lt;/span&gt;, blockHandler = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;blockHandlerTestHandler&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; handle1(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; params) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;success&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; blockHandlerTestHandler(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; params, BlockException blockException) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;兜底返回&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;达到阈值后，系统的默认提示是一段英文，很不友好，我们可以自定义兜底方法。在 @SentinelResource 注解中进一步配置 blockHandler、fallback 属性字段。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过上面两层兜底，可以让 Sentinel 框架更加人性化，体验更好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意&lt;/strong&gt;：注解式开发，需要添加在方法上，作用域范围相对固定。下面的项目实战中，我们也可以采用显式形式，可以灵活圈定代码块范围。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;项目实战&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们这边有个项目，考虑到客户的部署成本，想做一个轻量级方案，需求如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;既想引入框架的熔断功能，又不想部署控制台。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;拦截点相对收拢，类似 Dubbo 消费端远程访问一样，在代理类的远程通讯位置做拦截处理。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;概要方案—流程图&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9052132701421801&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwcNhClj0XcdlERS9kWhERsrQnpUuWXSBwtB6j5zMYCQ6bVsQLc9z4tQDliaJP7lGO6neywYxF62CuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;844&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1) 通过 Proxy.newProxyInstance 为所有的接口创建了代理子类。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2) 所有对代理子类的方法调用全部收拢到 InvocationHandler。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3) 将类名和方法名做一个拼接，然后去熔断规则表查询，看是否配置了规则。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4) 如果没有，那么走常规则远程调用逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5) 如果有，将远程调用逻辑纳入 Sentinel 的监控管辖。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6) 如果触发了 熔断机制，则直接抛出 BlockException ，上层业务拦截异常，做特殊处理，比如：修饰下给用户更合适的文案提示。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;熔断状态机&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.60390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwcNhClj0XcdlERS9kWhERsr7aj35DIfZnlD0olbeZjFeD2hia86tHJRPXOlWTsm6VjtOBerPHNL6rw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;核心的代码逻辑，请继续往下看。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，引入 Sentinel 的依赖包：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba.csp&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;sentinel-core&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.8.3&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;熔断规则表设计：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`degrade_rule`&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; AUTO_INCREMENT &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;主键&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`resource_name`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;256&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;资源名称&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`count`&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;慢调用时长，单位 毫秒&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`slow_ratio_threshold`&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;慢调用比例阈值&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`min_request_amount`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;熔断触发的最小请求数&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`stat_interval`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;统计时长，单位 毫秒&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`time_window`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;熔断时长，单位为 s&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`created_time`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;timestamp&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;创建时间&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`updated_time`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;timestamp&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;修改时间&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  PRIMARY &lt;span class=&quot;code-snippet__keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;`id`&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;USING&lt;/span&gt; BTREE,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;UNIQUE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`uk_resource_name`&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;`resource_name`&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;ENGINE&lt;/span&gt;=&lt;span class=&quot;code-snippet__keyword&quot;&gt;InnoDB&lt;/span&gt; AUTO_INCREMENT=&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;CHARSET&lt;/span&gt;=utf8mb3 &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;熔断规则表&#x27;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于放弃了部署控制台，我们只能自己管理熔断规则的各个属性值。&lt;/span&gt;&lt;span&gt;可以按企业内部管理后台风格，开发页面管理这些规则。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然，早期可以采用更简单粗暴方式，在数据库表手动初始化数据。如果要调整规则，走 SQL 订正。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了尽可能实时感知规则表数据变更开发了定时任务，每 10 秒运行一次。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Scheduled&lt;/span&gt;(cron = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;0/10 * * * * ? &quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; loadDegradeRule() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    List&amp;lt;DegradeRuleDO&amp;gt; degradeRuleDOList = degradeRuleDao.queryAllRule();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (CollectionUtils.isEmpty(degradeRuleDOList)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; newMd5Hex = DigestUtils.md5Hex(&lt;span class=&quot;code-snippet__built_in&quot;&gt;JSON&lt;/span&gt;.toJSONString(degradeRuleDOList));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (StringUtils.isBlank(newMd5Hex) || StringUtils.equals(lastMd5Hex, newMd5Hex)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    List&amp;lt;DegradeRule&amp;gt; rules = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    List&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;&amp;gt; resourceNameList = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    rules = degradeRuleDOList.stream().map(degradeRuleDO -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        DegradeRule rule = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; DegradeRule(degradeRuleDO.getResourceName()) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                .setGrade(CircuitBreakerStrategy.SLOW_REQUEST_RATIO.getType())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                .setCount(degradeRuleDO.getCount())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                .setTimeWindow(degradeRuleDO.getTimeWindow())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                .setSlowRatioThreshold(degradeRuleDO.getSlowRatioThreshold())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                .setMinRequestAmount(degradeRuleDO.getMinRequestAmount())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                .setStatIntervalMs(degradeRuleDO.getStatInterval());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        resourceNameList.add(degradeRuleDO.getResourceName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; rule;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }).collect(Collectors.toList());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (CollectionUtils.isNotEmpty(rules)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        DegradeRuleManager.loadRules(rules);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ConsumerProxyFactory.resourceNameList = resourceNameList;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        lastMd5Hex = newMd5Hex;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    log.error(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;[DegradeRuleConfig] 熔断规则加载: &quot;&lt;/span&gt; + rules);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;考虑到规则变更频率不会很高，没有必要每次都 &lt;/span&gt;&lt;span&gt;DegradeRuleManager.loadRules &lt;/span&gt;&lt;span&gt;重新加载规则。&lt;/span&gt;&lt;span&gt;这里设计了个小窍门。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;DigestUtils&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.md5Hex&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.toJSONString&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;degradeRuleDOList&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对查询的规则内容 JSON 序列化，然后计算其 MD5 摘要，如果跟上一次的结果一致，说明这期间没有变更，直接 return 不做处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;定义子类，实现了 InvocationHandler 接口。通过 Proxy.newProxyInstance 为目标接口创建一个代理子类。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样，每次调用接口方法，实际都是在调用 invoke 方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; invoke(&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; proxy, Method method, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;[] args) throws Throwable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Class&amp;lt;?&amp;gt; clazz = proxy.getClass().getInterfaces()[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; urlCode = clazz.getName() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;#&quot;&lt;/span&gt; + method.getName();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (resourceNameList.contains(urlCode)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Entry entry = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            entry = SphU.entry(urlCode);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            responseString = HttpClientUtil.postJsonRequest(url, header, body);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (BlockException blockException) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            log.error(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;degrade trigger !  remote url :{} &quot;&lt;/span&gt;, urlCode);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; DegradeBlockExcetion(urlCode);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (entry != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                entry.exit();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实验结果：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.32977850697292865&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwcNhClj0XcdlERS9kWhERsrQZRJtYicxcBeGj56cicLbcCoAkl3Y7TGZVDZ43dhictN9Of3lrClqts0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1219&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651497536&amp;amp;idx=2&amp;amp;sn=137421433520f18c0fa79d1b89e2065c&amp;amp;chksm=bd25c83f8a5241293433ed7a02106bc17f7601e60d5d0a9adae626064d2a6c00db81d7956507&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;面试官：熔断降级原理是什么？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;面试官：熔断降级原理是什么？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651485978&amp;amp;idx=2&amp;amp;sn=0b9392dd0c6157bd6331d0c1e1c6d5f2&amp;amp;chksm=bd251b658a5292738aaccd485ae9e99aedc16bbd673e43de0d02a4979797301254120b372075&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;HttpClient 连接池设置引发的一次雪崩&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;HttpClient 连接池设置引发的一次雪崩&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651490869&amp;amp;idx=1&amp;amp;sn=26a94ee7beedb11af2bebc4f0635ddc0&amp;amp;chksm=bd25e64a8a526f5ce513e05f33e9832f94a337b2c632bff9742fb8385792766cd1ac1e495464&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;东汉末年，他们把「服务雪崩」玩到了极致（干货）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;东汉末年，他们把「服务雪崩」玩到了极致（干货）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4e8d775f22572301394e0d4dc2a6415c</guid>
<title>快看我在Redis分布式锁上，栽的8个跟头！</title>
<link>https://toutiao.io/k/pshtt8d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需要捕获业务代码的异常，然后在 finally 中释放锁。换句话说就是：无论代码执行成功或失败了，都需要释放锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时，有些朋友可能会问：假如刚好在释放锁的时候，系统被重启了，或者网络断线了，或者机房断点了，不也会导致释放锁失败？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是一个好问题，因为这种小概率问题确实存在。但还记得前面我们给锁设置过超时时间吗？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;即使出现异常情况造成释放锁失败，但到了我们设定的超时时间，锁还是会被 redis 自动释放。但只在 finally 中释放锁，就够了吗？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;释放了别人的锁&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;做人要厚道，先回答上面的问题：只在 finally 中释放锁，当然是不够的，因为释放锁的姿势，还是不对。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哪里不对？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;答：&lt;/strong&gt;在多线程场景中，可能会出现释放了别人的锁的情况。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有些朋友可能会反驳：假设在多线程场景中，线程 A 获取到了锁，但如果线程 A 没有释放锁，此时，线程 B 是获取不到锁的，何来释放了别人锁之说？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;假如线程 A 和线程B，都使用 lockKey 加锁。线程 A 加锁成功了，但是由于业务功能耗时时间很长，超过了设置的超时时间。这时候，redis 会自动释放 lockKey 锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时，线程 B 就能给 lockKey 加锁成功了，接下来执行它的业务操作。恰好这个时候，线程 A 执行完了业务功能，接下来，在 finally 方法中释放了锁 lockKey。这不就出问题了，线程 B 的锁，被线程 A 释放了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我想这个时候，线程 B 肯定哭晕在厕所里，并且嘴里还振振有词。那么，如何解决这个问题呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不知道你们注意到没？在使用 set 命令加锁时，除了使用 lockKey 锁标识，还多设置了一个参数：requestId，为什么要需要记录 requestId 呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;requestId 是在释放锁的时候用的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;伪代码如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (jedis.&lt;span&gt;get&lt;/span&gt;(lockKey).equals(requestId)) {&lt;br/&gt;    jedis.del(lockKey);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在释放锁的时候，先获取到该锁的值（之前设置值就是 requestId），然后判断跟之前设置的值是否相同，如果相同才允许删除锁，返回成功。如果不同，则直接返回失败。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;换句话说就是：自己只能释放自己加的锁，不允许释放别人加的锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里为什么要用 requestId，用 userId 不行吗？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如果用 userId 的话，对于请求来说并不唯一，多个不同的请求，可能使用同一个 userId。而 requestId 是全局唯一的，不存在加锁和释放锁乱掉的情况。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;此外，使用 lua 脚本，也能解决释放了别人的锁的问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;del&#x27;, KEYS[1]) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;br/&gt;&lt;span&gt;end&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;lua 脚本能保证查询锁是否存在和删除锁是原子操作，用它来释放锁效果更好一些。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;说到 lua 脚本，其实加锁操作也建议使用 lua 脚本：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;exists&#x27;, KEYS[1]) == 0) then&lt;/span&gt;&lt;br/&gt;    redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &lt;/span&gt;&lt;br/&gt;    redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; nil; &lt;br/&gt;&lt;span&gt;end&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1)&lt;/span&gt;&lt;br/&gt;   redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &lt;/span&gt;&lt;br/&gt;   redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil; &lt;br/&gt;&lt;span&gt;end&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;return&lt;/span&gt; redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;pttl&#x27;, KEYS[1]);&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是 redisson 框架的加锁代码，写的不错，大家可以借鉴一下。有趣，下面还有哪些好玩的东西？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;大量失败请求&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面的加锁方法看起来好像没有问题，但如果你仔细想想，如果有 1 万的请求同时去竞争那把锁，可能只有一个请求是成功的，其余的 9999 个请求都会失败。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在秒杀场景下，会有什么问题？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;每 1 万个请求，有 1 个成功。再 1 万个请求，有 1 个成功。如此下去，直到库存不足。这就变成均匀分布的秒杀了，跟我们想象中的不一样。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何解决这个问题呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，还有一种场景：比如，有两个线程同时上传文件到 sftp，上传文件前先要创建目录。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设两个线程需要创建的目录名都是当天的日期，比如：20210920，如果不做任何控制，直接并发的创建目录，第二个线程必然会失败。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这时候有些朋友可能会说：这还不容易，加一个 redis 分布式锁就能解决问题了，此外再判断一下，如果目录已经存在就不创建，只有目录不存在才需要创建。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;伪代码如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  String result = jedis.&lt;span&gt;set&lt;/span&gt;(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;, expireTime);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;OK&quot;&lt;/span&gt;.equals(result)) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!exists(path)) {&lt;br/&gt;       mkdir(path);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt;{&lt;br/&gt;    unlock(lockKey,requestId);&lt;br/&gt;}  &lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一切看似美好，但经不起仔细推敲。来自灵魂的一问：第二个请求如果加锁失败了，接下来，是返回失败，还是返回成功呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;主要流程图如下：&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dCoUmZFovLJETjvPfLH5FezvOaCXZZuWBmlyBRGaHbZwkiaiadZUtmOgAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;span&gt;显然第二个请求，肯定是不能返回失败的，如果返回失败了，这个问题还是没有被解决。如果文件还没有上传成功，直接返回成功会有更大的问题。头疼，到底该如何解决呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;使用自旋锁。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;Long&lt;/span&gt; start = System.currentTimeMillis();&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;     String result = jedis.&lt;span&gt;set&lt;/span&gt;(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;, expireTime);&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;OK&quot;&lt;/span&gt;.equals(result)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(!exists(path)) {&lt;br/&gt;           mkdir(path);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;     }&lt;br/&gt;&lt;br/&gt;     long time = System.currentTimeMillis() - start;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (time&amp;gt;=timeout) {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;          Thread.sleep(&lt;span&gt;50&lt;/span&gt;);&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;          e.printStackTrace();&lt;br/&gt;      }&lt;br/&gt;  }&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt;{&lt;br/&gt;    unlock(lockKey,requestId);&lt;br/&gt;}  &lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在规定的时间，比如 500 毫秒内，自旋不断尝试加锁（说白了，就是在死循环中，不断尝试加锁），如果成功则直接返回。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果失败，则休眠 50 毫秒，再发起新一轮的尝试。如果到了超时时间，还未加锁成功，则直接返回失败。好吧，学到一招了，还有吗？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;锁重入问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们都知道 redis 分布式锁是互斥的。假如我们对某个 key 加锁了，如果该 key 对应的锁还没失效，再用相同 key 去加锁，大概率会失败。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;没错，大部分场景是没问题的。为什么说是大部分场景呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;因为还有这样的场景：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;假设在某个请求中，需要获取一颗满足条件的菜单树或者分类树。我们以菜单为例，这就需要在接口中从根节点开始，递归遍历出所有满足条件的子节点，然后组装成一颗菜单树。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需要注意的是菜单不是一成不变的，在后台系统中运营同学可以动态添加、修改和删除菜单。为了保证在并发的情况下，每次都可能获取最新的数据，这里可以加 redis 分布式锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;加 redis 分布式锁的思路是对的。但接下来问题来了，在递归方法中递归遍历多次，每次都是加的同一把锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;递归第一层当然是可以加锁成功的，但递归第二层、第三层...第 N 层，不就会加锁失败了？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;递归方法中加锁的伪代码如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; int expireTime = &lt;span&gt;1000&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; void &lt;span&gt;&lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(int level,String lockKey,String requestId)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;     String result = jedis.&lt;span&gt;set&lt;/span&gt;(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;, expireTime);&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;OK&quot;&lt;/span&gt;.equals(result)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(level&amp;lt;=&lt;span&gt;10&lt;/span&gt;){&lt;br/&gt;           &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;fun&lt;/span&gt;(++level,lockKey,requestId);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;           &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;     }&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;     unlock(lockKey,requestId);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你直接这么用，看起来好像没有问题。但最终执行程序之后发现，等待你的结果只有一个：出现异常。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为从根节点开始，第一层递归加锁成功，还没释放锁，就直接进入第二层递归。因为锁名为 lockKey，并且值为 requestId 的锁已经存在，所以第二层递归大概率会加锁失败，然后返回到第一层。第一层接下来正常释放锁，然后整个递归方法直接返回了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这下子，大家知道出现什么问题了吧？没错，递归方法其实只执行了第一层递归就返回了，其他层递归由于加锁失败，根本没法执行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么这个问题该如何解决呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;使用可重入锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们以 redisson 框架为例，它的内部实现了可重入锁的功能。古时候有句话说得好：为人不识陈近南，便称英雄也枉然。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我说：分布式锁不识 redisson，便称好锁也枉然。哈哈哈，只是自娱自乐一下。由此可见，redisson 在 redis 分布式锁中的江湖地位很高。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;伪代码如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; expireTime = &lt;span&gt;1000&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;(&lt;span&gt;String lockKey&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  RLock &lt;span&gt;lock&lt;/span&gt; = redisson.getLock(lockKey);&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.fun(&lt;span&gt;lock&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;(&lt;span&gt;RLock &lt;span&gt;lock&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt; level&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;lock&lt;/span&gt;.&lt;span&gt;lock&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;, TimeUnit.SECONDS);&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(level&amp;lt;=&lt;span&gt;10&lt;/span&gt;){&lt;br/&gt;         &lt;span&gt;this&lt;/span&gt;.fun(&lt;span&gt;lock&lt;/span&gt;,++level);&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;  } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;lock&lt;/span&gt;.unlock();&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面的代码也许并不完美，这里只是给了一个大致的思路，如果大家有这方面需求的话，以上代码仅供参考。接下来，聊聊 redisson 可重入锁的实现原理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;加锁主要是通过以下脚本实现的：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;exists&#x27;, KEYS[1]) == 0) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;then&lt;/span&gt;  &lt;br/&gt;   redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;hset&#x27;, KEYS[1], ARGV[2], 1);        redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; nil; &lt;br/&gt;&lt;span&gt;end&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;then&lt;/span&gt;  &lt;br/&gt;  redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &lt;/span&gt;&lt;br/&gt;  redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil; &lt;br/&gt;&lt;span&gt;end&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;pttl&#x27;, KEYS[1]);&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;先判断如果锁名不存在，则加锁。接下来，判断如果锁名和 requestId 值都存在，则使用 hincrby 命令给该锁名和 requestId 值计数，每次都加 1。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;注意一下，这里就是重入锁的关键，锁重入一次值就加 1。如果锁名存在，但值不是 requestId，则返回过期时间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;释放锁主要是通过以下脚本实现的：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;then&lt;/span&gt; &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt;&lt;span&gt;end&lt;/span&gt;&lt;br/&gt;local counter = redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (counter &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;br/&gt;&lt;span&gt;then&lt;/span&gt; &lt;br/&gt;    redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;; &lt;br/&gt; &lt;span&gt;else&lt;/span&gt; &lt;br/&gt;   redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;del&#x27;, KEYS[1]); &lt;/span&gt;&lt;br/&gt;   redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;publish&#x27;, KEYS[2], ARGV[1]); &lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;end&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;先判断如果锁名和 requestId 值不存在，则直接返回。如果锁名和 requestId 值存在，则重入锁减 1。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果减 1 后，重入锁的 value 值还大于 0，说明还有引用，则重试设置过期时间。如果减 1 后，重入锁的 value 值还等于 0，则可以删除锁，然后发消息通知等待线程抢锁。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;再次强调一下，如果你们系统可以容忍数据暂时不一致，有些场景不加锁也行，我在这里只是举个例子，本节内容并不适用于所有场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;锁竞争问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果有大量需要写入数据的业务场景，使用普通的 redis 分布式锁是没有问题的。但如果有些业务场景，写入的操作比较少，反而有大量读取的操作。这样直接使用普通的 redis 分布式锁，会不会有点浪费性能？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们都知道，锁的粒度越粗，多个线程抢锁时竞争就越激烈，造成多个线程锁等待的时间也就越长，性能也就越差。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，提升 redis 分布式锁性能的第一步，就是要把锁的粒度变细。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 读写锁&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;众所周知，加锁的目的是为了保证，在并发环境中读写数据的安全性，即不会出现数据错误或者不一致的情况。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但在绝大多数实际业务场景中，一般是读数据的频率远远大于写数据。而线程间的并发读操作是并不涉及并发安全问题，我们没有必要给读操作加互斥锁，只要保证读写、写写并发操作上锁是互斥的就行，这样可以提升系统的性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们以 redisson 框架为例，它内部已经实现了读写锁的功能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;读锁的伪代码如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;RReadWriteLock readWriteLock = redisson.getReadWriteLock(&lt;span&gt;&quot;readWriteLock&quot;&lt;/span&gt;);&lt;br/&gt;RLock rLock = readWriteLock.readLock();&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    rLock.&lt;span&gt;lock&lt;/span&gt;();&lt;br/&gt;    &lt;span&gt;//业务操作&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;    log.error(e);&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    rLock.unlock();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;写锁的伪代码如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;RReadWriteLock readWriteLock = redisson.getReadWriteLock(&lt;span&gt;&quot;readWriteLock&quot;&lt;/span&gt;);&lt;br/&gt;RLock rLock = readWriteLock.writeLock();&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    rLock.&lt;span&gt;lock&lt;/span&gt;();&lt;br/&gt;    &lt;span&gt;//业务操作&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;   log.error(e);&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    rLock.unlock();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;将读锁和写锁分开，最大的好处是提升读操作的性能，因为读和读之间是共享的，不存在互斥性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而我们的实际业务场景中，绝大多数数据操作都是读操作。所以，如果提升了读操作的性能，也就会提升整个锁的性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面总结一个读写锁的特点：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 锁分段&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，为了减小锁的粒度，比较常见的做法是将大锁：分段。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 java 中 ConcurrentHashMap，就是将数据分为 16 段，每一段都有单独的锁，并且处于不同锁段的数据互不干扰，以此来提升锁的性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;放在实际业务场景中，我们可以这样做：比如在秒杀扣库存的场景中，现在的库存中有 2000 个商品，用户可以秒杀。为了防止出现超卖的情况，通常情况下，可以对库存加锁。如果有 1W 的用户竞争同一把锁，显然系统吞吐量会非常低。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了提升系统性能，我们可以将库存分段，比如：分为 100 段，这样每段就有 20 个商品可以参与秒杀。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在秒杀的过程中，先把用户 id 获取 hash 值，然后除以 100 取模。模为 1 的用户访问第 1 段库存，模为 2 的用户访问第 2 段库存，模为 3 的用户访问第 3 段库存，后面以此类推，到最后模为 100 的用户访问第 100 段库存。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2900662251655629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dCziaWqPRnl9m4UytstIE2IibpsY5icYShp6CG003ibwUkHmoLmbPLG6lztg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1510&quot;/&gt;&lt;span&gt;如此一来，在多线程环境中，可以大大的减少锁的冲突。以前多个线程只能同时竞争 1 把锁，尤其在秒杀的场景中，竞争太激烈了，简直可以用惨绝人寰来形容，其后果是导致绝大数线程在锁等待。现在多个线程同时竞争 100 把锁，等待的线程变少了，从而系统吞吐量也就提升了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;需要注意的地方是：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;将锁分段虽说可以提升系统的性能，但它也会让系统的复杂度提升不少。因为它需要引入额外的路由算法，跨段统计等功能。我们在实际业务场景中，需要综合考虑，不是说一定要将锁分段。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;锁超时问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我在前面提到过，如果线程 A 加锁成功了，但是由于业务功能耗时时间很长，超过了设置的超时时间，这时候 redis 会自动释放线程 A 加的锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有些朋友可能会说：到了超时时间，锁被释放了就释放了呗，对功能又没啥影响。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;错，错，错。对功能其实有影响。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通常我们加锁的目的是：为了防止访问临界资源时，出现数据异常的情况。比如：线程 A 在修改数据 C 的值，线程 B 也在修改数据 C 的值，如果不做控制，在并发情况下，数据 C 的值会出问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了保证某个方法，或者段代码的互斥性，即如果线程 A 执行了某段代码，是不允许其他线程在某一时刻同时执行的，我们可以用 synchronized 关键字加锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但这种锁有很大的局限性，只能保证单个节点的互斥性。如果需要在多个节点中保持互斥性，就需要用 redis 分布式锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;做了这么多铺垫，现在回到正题。假设线程 A 加 redis 分布式锁的代码，包含代码 1 和代码 2 两段代码。&lt;/span&gt;&lt;/section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3113207547169812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dCox1uldbqb3HAmWZyWRp8MlPsm5Ig1cMTTrLUukd5Hfenib7icnspSweA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;&lt;section&gt;&lt;span&gt;由于该线程要执行的业务操作非常耗时，程序在执行完代码 1 的时，已经到了设置的超时时间，redis 自动释放了锁。而代码 2 还没来得及执行。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6539379474940334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dC9BC6ibtCtiarBJia5ZB5CJ2MGEKnMQWuhfZYq1LANZr8ibdVGiavzrEuo6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时，代码 2 相当于裸奔的状态，无法保证互斥性。假如它里面访问了临界资源，并且其他线程也访问了该资源，可能就会出现数据异常的情况。（PS：我说的访问临界资源，不单单指读取，还包含写入）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，如何解决这个问题呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如果达到了超时时间，但业务代码还没执行完，需要给锁自动续期。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们可以使用 TimerTask 类，来实现自动续期的功能：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;Timer timer = &lt;span&gt;new&lt;/span&gt; Timer(); &lt;br/&gt;timer.schedule(&lt;span&gt;new&lt;/span&gt; TimerTask() {&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(Timeout timeout)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;//自动续期逻辑&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}, &lt;span&gt;10000&lt;/span&gt;, TimeUnit.MILLISECONDS);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;获取锁之后，自动开启一个定时任务，每隔 10 秒钟，自动刷新一次过期时间。这种机制在 redisson 框架中，有个比较霸气的名字：watch dog，即传说中的看门狗。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当然自动续期功能，我们还是优先推荐使用 lua 脚本实现，比如：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &lt;/span&gt;&lt;br/&gt;   redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&#x27;pexpire&#x27;, KEYS[1], ARGV[1]);&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;end&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;需要注意的地方是：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在实现自动续期功能时，还需要设置一个总的过期时间，可以跟 redisson 保持一致，设置成 30 秒。如果业务代码到了这个总的过期时间，还没有执行完，就不再自动续期了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;自动续期的功能是获取锁之后开启一个定时任务，每隔 10 秒判断一下锁是否存在，如果存在，则刷新过期时间。如果续期 3 次，也就是 30 秒之后，业务方法还是没有执行完，就不再续期了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;主从复制的问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面花了这么多篇幅介绍的内容，对单个 redis 实例是没有问题的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;but，如果 redis 存在多个实例。比如：做了主从，或者使用了哨兵模式，基于 redis 的分布式锁的功能，就会出现问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;具体是什么问题？假设 redis 现在用的主从模式，1 个 master 节点，3 个 slave 节点。master 节点负责写数据，slave 节点负责读数据。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4693333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dCyHic3FF76je6MGKYvoBABpkPGT7iaV3RUPqTAX7EZtOSKZm2a2VN1jiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;span&gt;本来是和谐共处，相安无事的。redis 加锁操作，都在 master 上进行，加锁成功后，再异步同步给所有的 slave。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;突然有一天，master 节点由于某些不可逆的原因，挂掉了。这样需要找一个 slave 升级为新的 master 节点，假如 slave1 被选举出来了。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.703125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dCfz9byBc8KmGqCmOTNVfp8tStCDw0MLqga8iaU1XWLf01PBV0Xib8H1bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;512&quot;/&gt;&lt;span&gt;如果有个锁 A 比较悲催，刚加锁成功 master 就挂了，还没来得及同步到 slave1。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样会导致新 master 节点中的锁 A 丢失了。后面，如果有新的线程，使用锁 A 加锁，依然可以成功，分布式锁失效了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，如何解决这个问题呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;redisson 框架为了解决这个问题，提供了一个专门的类：RedissonRedLock，使用了 Redlock 算法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RedissonRedLock 解决问题的思路如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;需要搭建几套相互独立的 redis 环境，假如我们在这里搭建了 5 套。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每套环境都有一个 redisson node 节点。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;多个 redisson node 节点组成了 RedissonRedLock。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;环境包含：单机、主从、哨兵和集群模式，可以是一种或者多种混合。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这里我们以主从为例，架构图如下：&lt;/span&gt;&lt;/section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3622641509433962&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFpywBzMdt5EHAekqHT61dCvn7c862zRO0Dn9b2ZLUZTwsaFuvOGMHf2vw77tjrpEwSK5NK2uOicNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1590&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RedissonRedLock 加锁过程如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;获取所有的 redisson node 节点信息，循环向所有的 redisson node 节点加锁，假设节点数为 N，例子中 N 等于 5。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果在 N 个节点当中，有 N/2+1 个节点加锁成功了，那么整个 RedissonRedLock 加锁是成功的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果在 N 个节点当中，小于 N/2+1 个节点加锁成功，那么整个 RedissonRedLock 加锁是失败的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果中途发现各个节点加锁的总耗时，大于等于设置的最大等待时间，则直接返回失败。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从上面可以看出，使用 Redlock 算法，确实能解决多实例场景中，假如 master 节点挂了，导致分布式锁失效的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但也引出了一些新问题，比如：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由此可见，在实际业务场景，尤其是高并发业务中，RedissonRedLock 其实使用的并不多。在分布式环境中，CAP 是绕不过去的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CAP 指的是在一个分布式系统中：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这三个要素最多只能同时实现两点，不可能三者兼顾。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你的实际业务场景，更需要的是保证数据一致性。那么请使用 CP 类型的分布式锁，比如：zookeeper，它是基于磁盘的，性能可能没那么好，但数据一般不会丢。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你的实际业务场景，更需要的是保证数据高可用性。那么请使用 AP 类型的分布式锁，比如：redis，它是基于内存的，性能比较好，但有丢失数据的风险。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实，在我们绝大多数分布式业务场景中，使用 redis 分布式锁就够了，真的别太较真。因为数据不一致问题，可以通过最终一致性方案解决。但如果系统不可用了，对用户来说是暴击一万点伤害。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9ef8e991615e60ea6a36bf96af48733c</guid>
<title>在阿里巴巴，我们如何先于用户发现和定位 Kubernetes 集群问题？</title>
<link>https://toutiao.io/k/lkx03y8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;250&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4324074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvnbRSgXlibCZy1qX6WFquAAsyYicXC2A4Rd9VfdXiaeQibAajKg4kRG9kChCZSHsEc2CuxHdd9PO7bARw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt; 作者：彭南光(光南)&lt;/em&gt;&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;本文整理自阿里云高级研发工程师彭南光(光南) 在 KubeCon China 2021 大会的演讲实录，分享了阿里巴巴是如何通过自研通用链路探测+定向巡检工具 KubeProbe 应对大规模集群的稳定性挑战的。关于阿里云云原生团队在本次 KubeCon 上分享的全部内容沉淀于电子书《云原生与云未来的新可能》当中，可点击文末“阅读原文”下载。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;快速发现和定位问题的能力是快速恢复系统的基石，只有先做到快速发现和定位问题，才能谈如何解决问题，尽量减少用户损失。那么如何在复杂的大规模场景中，做到真正的先于用户发现和定位问题呢？我会将我们在管理大型 &lt;span&gt;Kubernetes &lt;/span&gt;集群过程中快速发现和定位问题的一些经验和实践带给大家——我们是如何通过自研通用链路探测+定向巡检工具 KubeProbe 应对遇到的大规模集群的稳定性挑战的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;链路探测：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;模拟广义用户行为，探测链路和系统是否异常&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;定向检测：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;检查集群异常指标，发现未来存在或可能存在的风险点&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;系统增强：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;发现问题提速增效，根因分析&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;发现问题之后：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;后置检查和自愈，Chat-Ops&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;业务背景和挑战&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;阿里云云原生应用平台的容器服务团队，拥有 ACK 、ASI 等产品，管理了大规模的 Kubernetes 集群，不仅向外部公有云用户提供 Kubernetes 服务，还承担了阿里巴巴集团上云，阿里巴巴应用全面容器化的工作。&lt;br/&gt; &lt;br/&gt;目前，整个阿里巴巴的业务都跑在 Kubernetes 集群上并实现了云原生和容器化，例如：天猫/淘宝/高德/考拉/饿了么等等。容器服务作为阿里云的管控底座，各种云服务也运行在这些集群之上，例如视频云/dataworks /MSE 微服务引擎/MQ 消息队列等等。我们需要对这些基础设施的稳定性负责。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在，云原生的架构越来越流行，越来越多的产品和应用开始选择云原生架构，这里有一张图，大致示意了现代的云原生应用架构，应用生于云上，长于云上，各级提供分层的服务，这种分层的服务能够让业务和应用专注于业务层，屏蔽平台和基础设施层的复杂概念。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;315&quot; data-backw=&quot;578&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlyK7cicv1sxfYRtupAmjDuiabtbF7N5Vt2W2uoWrz1CCSd8qEzEIIleJA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;865&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;471.4100346020761&quot; data-ratio=&quot;0.545664739884393&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlbOryib8UYb7Rox4pzhDqJwj81wQ7BcU5gEDels6Mvd2eb5W0Y1iaGy4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;从稳定性的角度来讲，这种应用的架构分层，上层应用的稳定性就会开始依赖底层基础设施的支持；另外，大一统的基座既为大规模的资源调度优化和在离线混部提供场景，也对基础设施团队维护大规模集群的稳定性问题提出极大的挑战。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;322&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5560693641618497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlgBGfnM20iaDfibvqZZLCq3vACfzMYVaGAuXjjRMJj2UcKGA8v1SDibianQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;这里有两张形象的图示可以展现出云原生应用架构下的业务应用和平台层基础设施的关系，Kubernetes 集群是非常复杂的，一个单集群的链路组件就有数十个甚至上百个之多，何况是大规模的多&lt;/span&gt;&lt;span&gt;集群管理呢？&lt;/span&gt;&lt;span&gt;但运行在上层&lt;/span&gt;&lt;span&gt;的业务同学&lt;/span&gt;&lt;span&gt;并不会感知到&lt;/span&gt;&lt;span&gt;复杂，因为我们已经把复杂包掉了，留给用户的是一个简单的统一接口&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;就像&lt;/span&gt;&lt;span&gt;淘宝这&lt;/span&gt;&lt;span&gt;样的应用其实是非常复杂的，但在&lt;/span&gt;&lt;span&gt;用户看&lt;/span&gt;&lt;span&gt;来只&lt;/span&gt;&lt;span&gt;是一个简单的提交订单而已，按键背后蕴含着&lt;/span&gt;&lt;span&gt;极其复杂的内容。&lt;/span&gt;&lt;span&gt;为什么做到这样？&lt;/span&gt;&lt;span&gt;因为我们把复杂留给了自己，把简单交给了用&lt;/span&gt;&lt;span&gt;户。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多时候，好的应用开发者不一定是基础设施专家，云原生让业务专注业务，基础设施专注基础设施。同时，业务很多时候也只能关心业务自身的稳定性，业务大多数时候没有能力关心，或者是不希望投入大量的人力关心基础设施和平台层的稳定性，所以，关于平台层和基础设施的稳定性问题上，我们需要把复杂留给自己，把简单留给用户，为用户提供稳定的平台层服务。同时，更加关心全局稳定性和全局的可用性，而不是单点可用性。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;323&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5595375722543353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlg1BLHsYPbs6jnE2iafXbBqzUGo8qrIhtZDWgqgD31exDJiaEoB5TRzPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;容器服务是阿里巴巴集团业务以及阿里云管控/云服务的底座，上面跑着各种各样的业务，如电商业务/中间件/二方业务/搜索/阿里云云服务等等。此外还有数百个自研和开源的组件，每年数十万次的组件变更/数千个集群/数十万台节点，甚至大的集群单集群节点规模已过万。业务架构更是纷繁复杂，有单租集群、多租集群、vc 集群、联邦集群等等，同时还有各种在离线混布、统一调度、大促活动。在运行时也存在多种形态，如 runC，runD 等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此组件的繁杂、变更频繁、用户场景各异、集群规模庞大、业务架构复杂……都给业务带来了挑战：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;挑战一：如何降低系统风险。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;场景复杂，业务形态各异，任何一个不起眼细节的遗漏或环节的处置不慎都有可能导致伤害的扩大化；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;挑战二：如何对用户集群的稳定性负责。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如何先于用户发现和定位问题成为容器服务生产稳定性建设的重中之重，也是全局高可用体系的基石。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;系统是如此的复杂，任何一个不起眼的细节遗漏或处理不慎都有可能导致非预期的伤害，我们要怎样才能降低系统风险呢？另外我们又是如何对形态各异的用户集群运行时全局稳定性负责的呢？如何才能先于用户发现和定位这些集群中已经存在或即将发生的问题，是保障集群的稳定性建设的重中之重，也是 Kubernetes 全局高可用体系的基石。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;思考和方案&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于这些挑战，我们做了一些思考和预设。下图是一个极度简化的用户发布扩容链路，虽说极度简化，但实际我们仍可以看出，链路还是比较复杂的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了保障这次用户的扩容/发布链路畅通，我们首先带来几个预设：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;322&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5583815028901734&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlLw5xLAeXQrMpCC3IUD7KJs4RCf57IeknPqibMm6rwSeJfQzUAqT0bgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;预设 1：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;链路复杂组件众多，各组件分别升级迭代，数据监控无法无死角覆盖全部场景；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;预设 2：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;即使链路中各组件/节点监控数据正常，也不能保证集群整体链路 100% 可用，只有经过实际业务全链路探测才能确定实际可用的结论；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;预设 3：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;反证法在证明集群不可用场景一定优于举证法，即使 100% 监控数据正常，但只要发布失败则证明链路不通。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，在单集群之外，我们还要关注多集群的管理，下面是一些多集群管控中的不稳定性因素示例，可以看到，多集群场景下，稳定性管控的复杂度会被放大，我们继续带来几个预设：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;预设 4：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在大规模集群场景下数据一致性的问题会愈加显现，并且可能引发严重故障，成为一个显著的不稳定因素；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;预设 5：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;集群内的监控告警链路存在自依赖风险，如果集群故障，则监控告警也有可能同时故障。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;322&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5583815028901734&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlic15c6lKsewVI2Vbb9zdOxKTCRNUBdoSCdqSF2OQD9JgWvpibXkIKVhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;接下来是我们基于以上预设的一些解决方案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt; 探索和解决方案&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1.  链路探测&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;链路探测即模拟广义上的用户行为，探测链路是否畅通，流程是否无异常。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;322&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5572254335260116&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJl2r3iaOYI7PIV3zyJ7oSIZv3pm4pSQY6JAVIUIhRyPic9IiaKBud92aYDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;想要做到先于用户发现系统问题，我们自己首先要成为系统用户，并且是使用最多、了解最深、无时无刻不在使用和感知系统状态的用户。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;511&quot; data-backw=&quot;567&quot; data-ratio=&quot;0.9012345679012346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlfJMzoRTfSKIhIJib1vEHo7RFZV7xkBfmiaQC3hSsokJ8CicibRm7PFdn6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;567&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;所谓链路探测，就是模拟广义上的用户行为，去对集群组件链路中的各种等待探测的对象去做探测。此处要特别说明的是，这里的用户并不仅仅指的是狭义上使用系统的同学，而是更广义的用户，或者可以理解和引申成为依赖下游。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，在实现全链路探测的同时，拆解电路，实现全电路中的短路探测也是非常必要的，也是对全链路探测的一个补充。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.  定向巡检&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;定向巡检是指检查和分析大规模集群的异常指标，找到已有或将来可能存在的风险点，就像检修管道一样。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;403&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6973058637083994&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlkgmN1B2vQUvk4B3qhEcrYQRQTI87FQqMEZmkmzKYV020eVqus4JA4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;631&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如有若干个集群，它分为很多集群组，不同集群组之间的 etcd 冷/热备是否配置齐备，风控限流配置是否正常，webhook 版本是否正常，混部参数是否一致，包括它的证书有效期是不是快要到期了等等。不同的集群组之间可能有所差别，但同类型集群之间是有一个转衡的，因此我们可以定向做一些巡检。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来是关于链路探测的一些常见场景：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;323&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5595375722543353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlUaBkxtwcstHSjmZ4sEWhACCzTXLXUTXUdiclnibdA5icF02I0tJd0lBPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;就像一个游戏策划，如果他连自己制作的游戏都不玩，他可能发现游戏机制的问题，把这个游戏越做越好吗？我们要做到先于用户发现系统问题，那我们自己首先就要先成为系统的用户，并且一定是使用最多的，了解最深的，无时无刻不在使用和感知系统状态的用户。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，所谓链路探测，就是让自己成为自己系统的用户，模拟广义上的“用户”行为去对集群/组件/链路里的各种等待探测的对象去做探测。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一定要注意，这里的“用户”并不仅仅指的是狭义上使用系统的同学，而是更广义的用户，或者可以理解引申为依赖下游。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如业务同学要发布业务，就必然要经过 git 系统，再到发布系统，再到我们底层的基础设施平台，也就是我们的 ASI，这就是一次全链路探测流程。在这里业务同学就是用户，探测对象可以是全链路。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但如果我们把 etcd 看作一个系统服务，那么 APIServer 就是它广义上的用户，我们模拟 APIServer 请求 etcd 这条链路的探测也就有了意义。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外像 MSE 操作 zookeeper，外部用户通过阿里云控制台创建 ACK 集群，PaaS 平台操作联邦集群，甚至视频云业务方发起一次转码任务，都是一样的道理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;还有一点要关注的就是，虽然全链路探测看起来很美，但很多时候，全链路探测同时还很长，可能等到失败的时候问题已经很大了。所以，在实现全链路探测的同时，拆解链路，实现全链路中的短链路探测也是非常必要的，也是对全链路探测的一个补充。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;318&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5492468134414832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlX7HmhTLmiaibf0ATMLztRczYbicGaXPP00jDQzuYCb5kWcVM1ibRljznKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;863&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;上图是定向巡检的场景，相比链路探测关注于链路可用性，定向巡检的核心还是在大规模的集群场景下，数据一致性是非常困难的问题，数据不一致，将导致一些隐患，可能会在未来引发某些不确定性的故障。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所谓定向巡检就是对整个集群或链路中的各项数据、指标做已知原因的检查，找出不一致或数据偏离的点，判断是否可能引发风险，从而做到防患于未然，治未病。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;446&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7720364741641338&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlxJ6UfktzxepYSFqs1d5AtGuzJ9DVnttm9ABubqWd1IaSpXeVxSq4KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如我们这个里边有同一种类型的集群组，A 集群发现它的证书有效期不到三年，而其他集群的证书有效期都有三年；B 集群的 webhook 版本可能是 v2，而其他集群的 webhook 版本是 v3；C 集群的风控限流配置并没有配一个驱逐 Pod 的限流，但其他集群都配配置了驱逐 Pod 的限流，这肯定是不符合预期的；再比如 D 集群的 etcd 的冷/热备没有配置或者是运行不正常，我们也可以先把它检查出来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;系统实现&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于上面许许多多的背景预设以及方案，我们设计并实现了一套巡检/探测平台，我们取名为 KubeProbe (并未开源，和现在社区上有类似命名的项目没有任何联系)。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们早期也曾考虑使用社区项目 Kuberhealthy，并为 Kuberhealthy 做过一些代码贡献，修复过一些严重的代码 Bug，最终因为功能上不太适用于我们的场景，我们选择了自研自建。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;322&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5583815028901734&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlwfCeFhfqJp3vx8EGlic9bHauDZVUnZvQiaGu6gN6fJcudibPdsWOzqYwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;上图是一套中心架构，我们会有一套中心管控系统。用户的用例会通过统一仓库的镜像的方式接入，使用我们通用的 sdk 库，自定义巡检和探测逻辑。我们会在中心管控系统上配置好集群和用例的关系配置，如某用例应该执行在哪些集群组上，并做好各种运行时配置。我们支持了周期触发/手动触发/事件触发(如发布)的用例触发方式。用例触发后会在集群内创建一个执行巡检/探测逻辑的 Pod，这个 Pod 里会执行各种用户自定义的业务巡检/探测逻辑，并在成功和失败后通过直接回调/消息队列的方式通知中心端。中心端会负责告警和用例资源清理的工作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我举一个例子，比如 Kubelet 在我们的组件运维平台上做分批发布，每批次都会触发一次相关集群的链路探测用例作为后置检查，一旦我们发现某次发布的后置检查失败，我们会阻断掉用户的当前发布，防止伤害扩大，同时第一时间告警以及通知相关同事进入排查，是否组件新版本不符合预期。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时，我们也支持第三方的事件回调，可以更快的集成进三方系统中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，我们对于某些需要 7*24 小时不间断的高频次短周期探测用例，我们还实现了另外一套常驻分布式架构，这套架构使用一个集群内的 ProbeOperator 监听 Probe Config CRD 变化，在探测 pod 中周而复始的执行探测逻辑。这套架构，完美复用了 KubeProbe 中心端提供的告警/根因分析/发布阻断等等附加功能，同时使用了标准  Operator 的云原生架构设计，常驻体系带来了极大的探测频率提升(因为去掉了创建巡检 pod 和清理数据的开销)基本可以做到对集群的 7*24 小时无缝覆盖，同时便于对外集成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;323&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5595375722543353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlukGdmr5X5rfN0UgCPiaYxaOenAI2EV4hqH44bu1HRYMHus8Y9aU4PVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外还有一个必须要提的非常重要的点，即平台只是提供了一个平台层的能力支持，真正这个东西要起作用，还是要看在这个平台上构建的用例是否丰富，能不能方便的让更多人进来写各种巡检和探测用例。就像测试平台很重要，但测试用例比测试平台更重要这个道理一样。一些通用的 workload 探测，组件探测，固然能发现很多管控链路上的问题，但是更多的问题，甚至业务层的问题暴露，实际上依赖于基础设施和业务层同学的共同努力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从我们的实践上来说，测试同学和业务同学贡献了很多相关的检查用例，比如测试同学贡献的 ACK &amp;amp; ASK 的创建删除全链路探测巡检，金丝雀业务全链路扩容用例，比如本地生活同学的 PaaS 平台应用检查等等，也得到了很多稳定性上的结果和收益。目前我们维护的巡检/探测用例有数十个，明年有机会破百，巡检/探测次数近 3000 万次，明年可能会过亿。目前可以提前发现 99%以上的集群管控问题和隐患，效果是非常好的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;04&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;发现问题之后：根因分析和事件处理&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来我们聊聊发现问题之后的事情，这里有一个类似于问诊对话的例子，患者发现 “哎呀我不舒服了！&lt;span&gt;”&lt;/span&gt;这就是发现问题。医生参考各种化验单，同时做了信息聚合分析推断，告诉患者“你已经 24 小时没睡觉了，你睡不着是因为你很焦虑，你焦虑的根因是因为后天就要期末考试了。”这便是定位问题根因，然后针对根因去解决这个问题，他告诉患者“不要担心，我刚收到的消息，小学生已经不需要期末考试了。”这个过程一定要快！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;322&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5572254335260116&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlnQt2wajtTibbkPNg6D4LhkiaveozKSWxG0KwB8B9Ma7cXvaxXHg1jGsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;来自探测链路的告警内容往往是混沌的，和数据监控告警是有所差异的。就像上文提到的，链路探测告警的告警很可能就是一句患者的我不舒服了，需要你作为医生去判断，为什么他不舒服了呢？根因是什么。而数据监控很多时候本身就代表了原因，比如 Etcd OOM，用已有的 oncall 经验可能得不到最好的效果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外快速定位问题和根因分析，是一个树状的搜索，经验加工判断的过程，也就是如何从一个混沌的表象推断出根因，核心是逻辑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这和健康体检是不同的，健康体检是列出检查项 1，2，3，4，5......然后告诉你一堆数值。很多时候，即使存在体检中心，我们仍然也需要医院的专业医生来为您解读和判断病情，不是吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时，根因分析/问题自愈的关键在于专家经验的下沉，也就是把专家经验下沉到系统中去，专家经验的下沉带来的最大收益是可复用可输出。你可以想一下，如果我们把一个最专业的医生的能力放进系统里，他是不是更方便的为每一个人分析病情呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;322&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5583815028901734&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlgIGGWtcbPSjnaSANlbnBemficgm9EHVoLQwz87oiab3ibbiaotC89mKzew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这便是 KubeProbe 发现问题之后的全流程，我们首先会经过一个我们自建的中心化根因分析系统，在这里我们会聚合分析所有和本次失败相关的信息，包括事件/日志/变更/告警/组件升级等等，我们将这些信息进行聚合分析，并对事件做关联处理，最终通过一个树状的分析系统初步定位出某次探测失败的原因，比如说 APIServer 超时或者 etcd 断连等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此外我再补充一点，文本联想也是一个很好的根因分析方式，我们可以通过机器学习训练文本识别的方式来联想出和这种失败 case 最关联的根因，这种 AIOps 的工作我们只是略微涉及，还在持续的探索中，我们的数据量非常大，我认为这一定是未来的方向之一。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;284&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.49074074074074076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlEXicovkBUiavkiaWmDN9azJ4xsNA30PWcTuOUksRxiaBTQgW5jQjWGdoVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;KubeProbe 根因分析和后置处理全流程&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图的左下方是某次我们失败的告警，它经过根因分析系统之后发现首先最核心，最关联，最大的原因可能是 APIserver 的连接断开并且当前已经恢复，所以可能只是偶发的网络抖动，我们暂时不用特别关注，但此时可以看到置信度为 90%。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外还有一些可能的原因都会关联起来。比如某个组件，这次探测它是由某一个组件发布出发的，它的发布人是 XXX，我们可以观察这个发布对 API server 会产生某些影响，是否多次 list watch 不符合预期，然后把 API server list watch 出问题了，置信度有 50%。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当我们得到一个初步的原因之后，我们会进入二次确认系统做二次的原因确认，比如我们判断原因可能是 APIServer 超时/etcd 断联/节点超时等,我们就会自动重新拉取一下 APIServer 接口，看一下此时是否仍然超时，是否恢复，如果恢复了，我们就普通告警，并且告诉用户，现在没事了，但是你得关注。如果没恢复，那这就很严重了，属于最高优先级，直接电话告警。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;就是这个思路，如果有系统无法定位的问题，并且持续无法定位，我们也会触发高级别告警，并且会增加相关的根因分析识别树逻辑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;过多的告警等于没有告警，我是最讨厌告警海的。从经验上讲，当我们构建了一套这样的根因分析+二次确认+后置检查系统之后，我们的 Oncall 成本下降了 90% 以上，并且还能够持续下降，终态可以说是无人值守，大家也可以试试类似的工作，可以说是投入小，见效大。自从这些系统建设起来以后，我们可以自豪的说，我们用很小的精力 Oncall 了每一个告警条目（对，是每一条告警，是数千个集群，数千万次探测巡检的每一条告警）并且不会有任何遗漏了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后是一些给 Oncall 人员的小甜品，Chat-ops。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;226&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3923611111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlK6MW9koia2qnuSTmvibUMJDH8hYUH3bxmUNYEYthq35qNREJJsCSfbQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;基于 NLP 语义识别的 Chat-ops 系统&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们利用钉钉提供的 NLP 机器人，构建了一套比较完善的 Chat-ops 系统，这样之后我们的 Oncall 人员就可以很方便的在告警群里通过聊天的方式操作 KubeProbe 相关功能了，比如：重跑失败探测，查询集群状态，拉取诊断信息，查询探测日志，集群告警静默。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;252&quot; data-backw=&quot;563&quot; data-ratio=&quot;0.44760213143872113&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlglNqNKD08DgYqQRibibSIicyftUQxibA1LxezZqlxMcicRicBPT7ODGXVvdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;563&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;300&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5186385737439222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlumS0A78xqMGyOg5x7GuujQrZyZniarzkHQkhkGELRKEzovJ4KeCib8mQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;617&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图是我们操作 Chat-ops 系统的过程。这个过程非常方便。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如晚上我已经再被窝里了，这时候它给我了一个告警，比如某个集群之前出现了某次失败但当前已经恢复了，需要我关注一下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;既然我关注了，我便希望某一个常用例再跑一次（它可能周期比较长，例如一个钟头），由于短链路的用例可能随时都在跑，此时我便告诉机器人再跑一次，机器人就会识别我的语义，将集群再跑一次。跑完之后，我再通过查询状态看一下这个集群当前的状态怎么样了，这样是非常方便的，有时候你晚上上班了，或者是在路上，或者是在被窝里，都也可以很舒服的去 on-call 一个系统了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;05&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;Demo 示例&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1、发布&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;230&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3986095017381228&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJliaweWHSGXjBGxGT7GEorPvic8CyC1Cf59wgWtLDZK1hXLtbAEIeBOIfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;863&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2、探测列表&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;214&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3689095127610209&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlxThzicLj5eRrB3VFCICian127ZGsMIvlkD42NHB3lnEiapLiamLL1iaZ4NA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;862&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3、探测 Pod 开始运行&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;135&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.23406720741599074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJl6aBuKYvnweRZ6FrZ3FibosuB12P9V8E11GXka5PXdZNQgm5BIFIzKxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;863&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;4、探测结果&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;317&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5480880648899189&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlfNwGEocxzeWMfsWHFHffTHZXrRP8Ezcic02bQBXibicEZOOvvMPsiaQGbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;863&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;5、根因分析&amp;amp;告警&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;351&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6082474226804123&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlDZ4ciaXVtSdjibYOb3OwLlTeJaJzx61JghLpqgMgu4as7hQ3IGI1KurQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;582&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;6、Chat-ops&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;561&quot; data-backw=&quot;574&quot; data-ratio=&quot;0.9773519163763066&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnJ6xMzJXcibbTiaZS0CDVaJlTA4GjvyRibX9DBIhg7ARBh2Aj21m0EVS0OmXk2fSe1U9N2YdIfIsrPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;点击“&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;阅读原文&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;”即可下载《云原生与云未来的新可能》电子书全部内容。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;106069&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;近期热门&lt;/strong&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:456&quot;&gt;&lt;strong&gt;HOT TOPIC&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;#云原生与云未来的新可能#&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;复制并前往下方链接，即可免费下载电子书&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://developer.aliyun.com/topic/download?id=8265&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-id=&quot;106069&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;article data-clipboard-cangjie=&quot;[&amp;quot;root&amp;quot;,{&amp;quot;copyFrom&amp;quot;:2066387070},[&amp;quot;p&amp;quot;,{&amp;quot;uuid&amp;quot;:&amp;quot;kxu1jah36jd1phzly6b&amp;quot;,&amp;quot;jc&amp;quot;:&amp;quot;center&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;color&amp;quot;:&amp;quot;#0071C1&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;KubeMeet 新年首站-成都站开放报名！&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;uuid&amp;quot;:&amp;quot;kxu1r1079l30zzofmrc&amp;quot;,&amp;quot;jc&amp;quot;:&amp;quot;center&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;color&amp;quot;:&amp;quot;#0071C1&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]],[&amp;quot;img&amp;quot;,{&amp;quot;id&amp;quot;:&amp;quot;m7s6rh&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;0115-成都站-二维码1080-467 .png&amp;quot;,&amp;quot;size&amp;quot;:152960,&amp;quot;width&amp;quot;:649,&amp;quot;height&amp;quot;:280.6324074074074,&amp;quot;rotation&amp;quot;:0,&amp;quot;src&amp;quot;:&amp;quot;https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/WmeonapLJyyVlXxj/img/0d9d02a4-ef09-4e83-869f-80d122091586.png&amp;quot;,&amp;quot;extraData&amp;quot;:{&amp;quot;resourceId&amp;quot;:&amp;quot;0d9d02a4-ef09-4e83-869f-80d122091586&amp;quot;}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;color&amp;quot;:&amp;quot;#0071C1&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;uuid&amp;quot;:&amp;quot;kxu6dv1n97f263i2o6&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;uuid&amp;quot;:&amp;quot;kxu1vjdbovf6s1irztl&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(23, 26, 29)&amp;quot;,&amp;quot;fonts&amp;quot;:{&amp;quot;ascii&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;,&amp;quot;hAnsi&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;,&amp;quot;cs&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;,&amp;quot;eastAsia&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;},&amp;quot;spacing&amp;quot;:-0.0825,&amp;quot;sz&amp;quot;:10.5,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2022 年首场 KubeMeet 开发者沙龙将于 1 月 15 日来到成都。活动聚焦“云原生应用交付与管理”，围绕云原生应用交付、自动化部署、跨集群管理等环节中&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:false,&amp;quot;color&amp;quot;:&amp;quot;rgb(23, 26, 29)&amp;quot;,&amp;quot;fonts&amp;quot;:{&amp;quot;ascii&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;,&amp;quot;hAnsi&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;,&amp;quot;cs&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;,&amp;quot;eastAsia&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;},&amp;quot;spacing&amp;quot;:-0.0825,&amp;quot;sz&amp;quot;:10.5,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;的落地挑战，分享开源技术在企业的应用实践。&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;#FE0300&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;扫描图片二维码即可报名活动。&amp;quot;]]]]&quot;&gt;&lt;article data-clipboard-cangjie=&quot;[&amp;quot;root&amp;quot;,{&amp;quot;copyFrom&amp;quot;:2066387070},[&amp;quot;p&amp;quot;,{&amp;quot;uuid&amp;quot;:&amp;quot;kxu1jah36jd1phzly6b&amp;quot;,&amp;quot;jc&amp;quot;:&amp;quot;center&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;color&amp;quot;:&amp;quot;#0071C1&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;KubeMeet 新年首站-成都站开放报名！&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;uuid&amp;quot;:&amp;quot;kxu1r1079l30zzofmrc&amp;quot;,&amp;quot;jc&amp;quot;:&amp;quot;center&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;color&amp;quot;:&amp;quot;#0071C1&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]],[&amp;quot;img&amp;quot;,{&amp;quot;id&amp;quot;:&amp;quot;m7s6rh&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;0115-成都站-二维码1080-467 .png&amp;quot;,&amp;quot;size&amp;quot;:152960,&amp;quot;width&amp;quot;:649,&amp;quot;height&amp;quot;:280.6324074074074,&amp;quot;rotation&amp;quot;:0,&amp;quot;src&amp;quot;:&amp;quot;https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/WmeonapLJyyVlXxj/img/0d9d02a4-ef09-4e83-869f-80d122091586.png&amp;quot;,&amp;quot;extraData&amp;quot;:{&amp;quot;resourceId&amp;quot;:&amp;quot;0d9d02a4-ef09-4e83-869f-80d122091586&amp;quot;}},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:true,&amp;quot;color&amp;quot;:&amp;quot;#0071C1&amp;quot;,&amp;quot;sz&amp;quot;:12,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;uuid&amp;quot;:&amp;quot;kxu6dv1n97f263i2o6&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;&amp;quot;]]],[&amp;quot;p&amp;quot;,{&amp;quot;uuid&amp;quot;:&amp;quot;kxu1vjdbovf6s1irztl&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;data-type&amp;quot;:&amp;quot;text&amp;quot;},[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;rgb(23, 26, 29)&amp;quot;,&amp;quot;fonts&amp;quot;:{&amp;quot;ascii&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;,&amp;quot;hAnsi&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;,&amp;quot;cs&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;,&amp;quot;eastAsia&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;},&amp;quot;spacing&amp;quot;:-0.0825,&amp;quot;sz&amp;quot;:10.5,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;2022 年首场 KubeMeet 开发者沙龙将于 1 月 15 日来到成都。活动聚焦“云原生应用交付与管理”，围绕云原生应用交付、自动化部署、跨集群管理等环节中&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;bold&amp;quot;:false,&amp;quot;color&amp;quot;:&amp;quot;rgb(23, 26, 29)&amp;quot;,&amp;quot;fonts&amp;quot;:{&amp;quot;ascii&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;,&amp;quot;hAnsi&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;,&amp;quot;cs&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;,&amp;quot;eastAsia&amp;quot;:&amp;quot;PingFangSC-Regular&amp;quot;},&amp;quot;spacing&amp;quot;:-0.0825,&amp;quot;sz&amp;quot;:10.5,&amp;quot;szUnit&amp;quot;:&amp;quot;pt&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;的落地挑战，分享开源技术在企业的应用实践。&amp;quot;],[&amp;quot;span&amp;quot;,{&amp;quot;color&amp;quot;:&amp;quot;#FE0300&amp;quot;,&amp;quot;data-type&amp;quot;:&amp;quot;leaf&amp;quot;},&amp;quot;扫描图片二维码即可报名活动。&amp;quot;]]]]&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;818&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.4148148148148147&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5Iiafvnc2ujnLz2AYJK3h6HOexuW6dogZqQjbOSKG9jw86YibiaxibENLkJE23yOar4KQXv9zJ6cGtBaS1nZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/article&gt;&lt;/article&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;90215&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; data-width=&quot;100%&quot;&gt;&lt;strong&gt;往期分享实录&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-bdless=&quot;spin&quot; data-bdlessp=&quot;280&quot; data-bdopacity=&quot;50%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;4、最佳实践：Kubernetes 集群中 DNS 故障的可观测性与根因诊断&lt;/span&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>167e0238e3d9c8ec89a6f614ec62d39f</guid>
<title>实现快速准确的图像识别神经网络</title>
<link>https://toutiao.io/k/u8rlcan</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;p&gt;随着神经网络模型和训练数据规模的增长，训练效率正成为深度学习的一个重要关注点。例如，GPT-3在小样本学习方面表现出非凡的能力，但它需要使用数千个 GPU 进行数周的训练，因此很难重新训练或改进。相反，如果人们可以设计出更小、更快、但更准确的神经网络会怎样？&lt;/p&gt;&lt;p&gt;在这篇文章中，我们介绍了两个利用神经架构搜索的图像识别模型系列，以及基于模型容量和泛化的原则性设计方法。第一个是EfficientNetV2（被ICML 2021接受），它由卷积神经网络组成，旨在为相对小规模的数据集提供快速的训练速度，例如ImageNet1k（有 128 万张图像）。第二个家族是CoAtNet，它们是结合了卷积和自注意力的混合模型，目标是在大规模数据集上实现更高的准确性，例如ImageNet21（拥有 1300 万张图像）和JFT（拥有数十亿张图像）。与之前的结果相比，我们的模型速度提高了 4-10 倍，同时在完善的ImageNet数据集上实现了最新的 90.88% top-1 准确率。我们还在Google AutoML github上发布源代码和预训练模型。&lt;/p&gt;&lt;h2&gt;EfficientNetV2：更小的模型和更快的训练&lt;/h2&gt;&lt;p&gt;EfficientNetV2 基于之前的EfficientNet架构。为了改进原始版本，我们系统地研究了现代 TPU/GPU 上的训练速度瓶颈，并发现：(1) 使用非常大的图像尺寸进行训练会导致更高的内存使用率，因此在 TPU/GPU 上通常会更慢；(2) 广泛使用的深度卷积在 TPU/GPU 上效率低下，因为它们的硬件利用率低；(3) 常用的统一复合缩放方法，即对卷积网络的每个阶段均等地缩放，是次优的。为了解决这些问题，我们提出了一种训练感知神经架构搜索 (NAS)，其中训练速度包含在优化目标中，以及一种以非均匀方式缩放不同阶段的缩放方法。&lt;/p&gt;&lt;p&gt;训练感知 NAS 基于之前的平台感知 NAS，但与原始方法主要关注推理速度不同，这里我们共同优化模型精度、模型大小和训练速度。我们还扩展了原始搜索空间以包含更多加速器友好的操作，例如FusedMBConv，并通过删除不必要的操作来简化搜索空间，例如平均池化和最大池化NAS 从不选择这些操作。由此产生的 EfficientNetV2 网络在所有以前的模型上都实现了更高的准确性，同时速度更快，体积缩小了 6.8 倍。&lt;/p&gt;&lt;p&gt;为了进一步加快训练过程，我们还提出了一种增强的渐进学习方法，在训练过程中逐渐改变图像大小和正则化幅度。渐进式训练已用于图像分类、GAN和语言模型。这种方法侧重于图像分类，但与以前的方法通常以准确性为代价来提高训练速度不同，这种方法可以稍微提高准确性，同时还可以显着减少训练时间。我们改进方法的关键思想是自适应地改变正则化强度，例如丢弃率或数据增强大小，根据图像大小。对于同一个网络，较小的图像尺寸导致网络容量较低，因此需要弱正则化；反之亦然，大图像尺寸需要更强的正则化来对抗过拟合。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGiaVTJJ3JmIWyiaboBu01kcdOIiblDfst1VuEiaabrrONu9Yf2YdJ2t7U7ssyaVIO7utoV3PN77Iwr9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们在ImageNet和一些迁移学习数据集上评估 EfficientNetV2 模型，例如CIFAR-10/100、Flowers和Cars。在 ImageNet 上，EfficientNetV2 显着优于以前的模型，训练速度提高了约 5-11 倍，模型尺寸缩小了 6.8 倍，准确率没有任何下降。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGiaVTJJ3JmIWyiaboBu01kcdLOeUhLZKjVibkLCv4KT0pZibKtPzTl5iaM3FSHtlgI1YqgDRwZZrIApzw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2&gt;CoAtNet：快速准确的大规模图像识别模型&lt;/h2&gt;&lt;p&gt;虽然 EfficientNetV2 仍然是典型的卷积神经网络，但最近对Vision Transformer (ViT) 的研究表明，基于注意力的 Transformer 模型在大规模数据集上的表现优于卷积神经网络像JFT-300M。受这一观察的启发，我们进一步将我们的研究扩展到卷积神经网络之外，目的是找到更快、更准确的视觉模型。&lt;/p&gt;&lt;p&gt;在“ CoAtNet: Marrying Convolution and Attention for All Data Sizes ”中，我们系统地研究了如何结合卷积和自注意力来开发快速准确的神经网络，用于大规模图像识别。我们的工作基于一个观察，即卷积由于其归纳偏差通常具有更好的泛化能力（即训练和评估之间的性能差距），而自注意力往往具有更大的能力（即适应大规模训练的能力）数据）由于其全球接受域。通过结合卷积和自注意力，我们的混合模型可以实现更好的泛化和更大的容量。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGiaVTJJ3JmIWyiaboBu01kcd0YqIMEecZKjk2Eb6DQFYt9OKchslfxkLkEuiclJpZl4Lxj4fiaQd7J2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们从我们的研究中观察到两个关键见解：（1）深度卷积和自注意力可以通过简单的相对注意力自然地统一起来，（2）垂直堆叠卷积层和注意力层的方式考虑它们的容量和计算所需的每个stage（分辨率）在提高泛化、容量和效率方面出奇地有效。基于这些见解，我们开发了一系列具有卷积和注意力的混合模型，命名为 CoAtNets（发音为“coat”nets）。下图展示了整体的 CoAtNet 网络架构：&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGiaVTJJ3JmIWyiaboBu01kcdxRXQ064cYHsSibB39BmsrLyCwz9RezGib8iaMQnAC6wPYhFVE6pEaZJhg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;CoAtNet 模型在许多数据集（例如 ImageNet1K、ImageNet21K 和 JFT）中始终优于 ViT 模型及其变体。与卷积网络相比，CoAtNet 在小规模数据集 (ImageNet1K) 上表现出相当的性能，并且随着数据大小的增加（例如在 ImageNet21K 和 JFT 上）获得了可观的收益。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGiaVTJJ3JmIWyiaboBu01kcdXYZb39iaM1xib9fIhibSOW17jbxvtiarX8cbLfWPJt0CZCglWT3MLa638w/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们还在大规模JFT数据集上评估了 CoAtNets 。为了达到类似的准确度目标，CoAtNet 的训练速度比之前的 ViT 模型快 4 倍，更重要的是，在 ImageNet 上实现了 90.88% 的新的最先进的 top-1 准确度。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGiaVTJJ3JmIWyiaboBu01kcdDemISjVTds4qp593oRpWp2d9UAdcjJFVDibia6jM54uF6BRBNEvmnJmw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2&gt;结论和未来工作&lt;/h2&gt;&lt;p&gt;在这篇文章中，我们介绍了两个神经网络系列，名为 EfficientNetV2 和 CoAtNet，它们在图像识别方面实现了最先进的性能。所有 EfficientNetV2 模型都是开源的，预训练模型也可在 TFhub 上获得。CoAtNet 模型也将很快开源。我们希望这些新的神经网络能够使研究界和行业受益。未来我们计划进一步优化这些模型并将它们应用于新任务，例如零样本学习和自监督学习，这通常需要具有高容量的快速模型。&lt;/p&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>