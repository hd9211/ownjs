<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f4d24ca39d64e536d7762089596a9d57</guid>
<title>58 同城 App 性能治理实践：iOS 启动时间优化</title>
<link>https://toutiao.io/k/bh32yol</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.084375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2VY3NksPSaHql4LCOdAUeJwmvS72ibDvaMNiaLQkNZjTFquznHkHcccc2hnKS6nNAx0Y7bSUia0iaUZxQ5N5Zfxldw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;启动速度是用户体验一款 APP 的第一印象，良好的启动速度对于提升用户体验有着积极的作用。58 同城 APP 作为一款承载招聘、安居客、黄页、二手车等各大业务线的平台型 APP，复杂的业务启动逻辑与众多 SDK 初始化逻辑对 58 同城的启动治理带来了不少挑战。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;挑战与治理思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;启动治理是一项长期且需要公司全业务线参与的课题，当前58同城在启动治理上主要面临以下一些挑战：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如何准确、稳定地衡量 58 同城 APP 的启动时间，以及如何横向比较 58 同城 APP 在业界主流 APP 中的启动时间？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;APP 启动变慢了，如何快速找出并定位是哪些耗时方法导致的启动速度降低？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在某个版本进行了启动优化，下个版本的启动耗时又突然爆发式增长，如何监控各个版本的启动耗时数据，及早的介入新增版本的启动耗时优化？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;为了解决上面的问题，58 同城形成了一套系统的启动治理思路，首先通过探索自研了一套启动时间统计工具，包括统计单个 APP 启动耗时和多个 APP 之间的横向启动数据比较，解决启动时间衡量的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然后，开发一套方法耗时检测工具，用于检测启动过程中的方法耗时数据，方便及时定位跟踪启动变慢原因，并基于方法耗时检测工具，监控各个版本新增的方法耗时数据，在新版本发版前及早介入启动优化工作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于分析方法耗时检测工具生成的启动数据，我们针对性的优化了启动逻辑、调研并实践二进制重排方案，通过动态库懒加载方案来优化 pre-main 阶段。因此，本文将从启动时间统计工具、启动方法耗时检测工具、二进制重排、动态库懒加载几个方向介绍 58 同城 APP 在启动优化上的实践。下图展示了58 同城 APP 启动优化的治理思路：&lt;/span&gt;&lt;img data-ratio=&quot;0.3934010152284264&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYN4gTT2DEmoicWv20zSlFcmI04OiacCXr7wrnGofkRL8A0nOucJxXf49Gg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;启动时间衡量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;1、启动时间的定义&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;一般而言，我们把 APP 启动时间定义为，从点击图标到用户看到第一个界面的时间，期间主要包含了两个阶段：&lt;br/&gt;&lt;/span&gt;&lt;img data-ratio=&quot;0.11984282907662082&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYNAe5NCPiaOFKDC2ViabBj9jE4O1XTbgyPU2yHET7aBfibLkcDpKymPnkqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1018&quot;/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;pre-main 阶段，从点击图标到 main 函数执行前：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;动态库加载，包含系统动态库及自定义动态库；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Rebase，修正当前镜像内部的指针偏移；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Bind，修正不同镜像之间的外部指针偏移；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Objc 初始化，包括 Objc 类、Category 的注册,以及 selector 的唯一性检查;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Initializer 初始化，每个类和 Category 的 load 方法执行、C/C++ 构造函数调用、非基本类型的 C++ 静态全局变量初始化；&lt;br/&gt;&lt;/span&gt;&lt;img data-ratio=&quot;0.14833127317676142&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYNOUha4gic2nuM66h4IsruE4ibv8l7X0ywibzIRkruicS2F8NqHEXic1eYIZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;809&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;post-main 阶段，main 函数执行到首屏展现：主要执行各种 SDK 注册、各种业务初始化以及准备首屏渲染需要的数据等逻辑；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2、如何测量启动时间？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;一般来说，单个 APP 的启动时间测量可以通过下面两种方案获取：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;直接通过 Xcode 自带的 Timer Profier 工具进行测量，在xcode11 之后 Instrument 提供了 App Launch 工具，可以看到 pre-main 阶段的各个过程的耗时；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分别统计 pre-main 阶段和 post-main 阶段，其中 pre-main 阶段通过设置 Xcode 运行环境来获取（Project→Scheme→Edit Scheme…，在 Environment Variables 中添加 DYLD_PRINT_STATISTICS=1 的环境变量），post-main 阶段可以通过手动埋点的方式来获取；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;启动时间统计工具&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;上面两种方式都需人工进行干预，没法进行自动化统计，58 同城自研了一种基于读取手机系统日志来获取 APP 启动时间的自动化工具，通过这个自动化统计工具，我们不仅可以实现单个 APP 启动时间的获取，还可以实现多个 APP 之间的横向启动数据比较。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们发现，iOS13.0 以后，在隐私-分析与改进-分析数据中有以log-power-xxx.session命名的日志文件，日志文件中提供了应用运行的一些基本数据信息，系统日志的基本格式如下：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;log_timestamp&quot; : &quot;&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;init_count&quot; : 1,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;machine_config&quot; : &quot;iPhone12,3&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;metrics&quot; : [&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;app_sessionreporter_key&quot; : &quot;&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;app_build_version&quot; : &quot;&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;app_version&quot; : &quot;10.10.0&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;app_adamid&quot; : 0,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;app_arch&quot; : &quot;&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;app_bundleid&quot; : &quot;&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;performance_metrics&quot; : {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &quot;memory&quot; : {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &quot;average&quot; : 1000,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &quot;peak&quot; : 1000&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &quot;app_performance&quot; : {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &quot;launch&quot; : {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &quot;count&quot; : 2,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &quot;sessions&quot; : [&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              1250,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              1500&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            ]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;app_is_clip&quot; : 0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中，app_bundleid 表示启动应用的 bundleid，app_performance下的 launch 信息中就是关于启动时间的数据，count 表示当天启动该应用的次数，sessions 分别提供了每次启动的耗时（从点击图标到首屏渲染时的耗时）。基于上面的信息，我们可以获取到该 app_bundleid 对应的启动耗时数据，完整分析该日志文件，则可以获取到当日所有启动过的 APP 耗时数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了能够自动化统计启动数据，我们通过一个三方框架来自动启动指定 APP，在生成系统日志后，自动分析该日志文件，输出各个 APP 的启动时间。为了保证启动数据的稳定，减少实验结果偏差，苹果官方推荐我们每次测试时进行如下操作：&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;重启手机；&lt;br/&gt;点击其他应用，尽量将该应用在 APP 内的缓存给替换掉；&lt;br/&gt;运行多次，去掉偏差较大的值，取平均值；&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;基于这个原则，我们在每次跑数据时。通过脚本重启 SpringBoot，延迟20s 后再去打开一个 APP。通过启动时间自动化统计工具获取的不同 APP 横向启动数据如下：&lt;br/&gt;&lt;/span&gt;&lt;img data-ratio=&quot;0.4855570839064649&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYN1RCkQCK0ETtg05Jz8qLSxV5pvb85va3ZpbF5HFyzA40gmJWB7Xedjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;727&quot;/&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;获取线上用户启动耗时&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;上面几种方式，都算是一种线下&lt;/span&gt;&lt;code&gt;&lt;span&gt;单机版&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的启动耗时测量方案，对于线上实际用户的启动耗时数据获取，可以通过下面几种方式进行：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过 Xcode 自带工具来查看，选择&lt;/span&gt;&lt;code&gt;&lt;span&gt;Xcode—&amp;gt;Window—&amp;gt;Organizer&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，在左侧菜单栏选择 Launch Time 项查看线上用户 APP 的启动耗时数据，这种方式主要看线上用户整体启动耗时区间分布情况；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过获取进程信息，拿到进程创建时间作为启动初始点，如下代码。&lt;br/&gt;这种方式经过实际测试发现，获取到的进程创建时间偏差较大。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**获取进程创建时间*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;+ (NSTimeInterval)processStartTime {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    struct kinfo_proc kinfo;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if ([self processInfoForPID:[[NSProcessInfo processInfo] processIdentifier] procInfo:&amp;amp;kinfo]) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return kinfo.kp_proc.p_un.__p_starttime.tv_sec * 1000.0 + kinfo.kp_proc.p_un.__p_starttime.tv_usec / 1000.0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return 0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;+ (BOOL)processInfoForPID:(int)pid procInfo:(struct kinfo_proc*)procInfo {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    int cmd[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PID, pid};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    size_t size = sizeof(*procInfo);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return sysctl(cmd, sizeof(cmd)/sizeof(*cmd), procInfo, &amp;amp;size, NULL, 0) == 0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;创建一个自定义动态库（或直接使用已有的自定义动态库），在 +load 方法中进行埋点作为 APP 的启动时间，为了尽可能将其他动态库中的耗时统计到，我们可以将自定义的动态库放在所有动态库加载的第一位。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;那如何将指定的动态库放到第一位去加载呢？Cocoapds 管理的项目在 pod install的过程中会将动态库按一定的顺序进行排序，那这个排序顺序应该就要在 Cocoapods 生成的配置文件中体现出来，查看Pods-58tongcheng.debug.xcconfig文件，我们发现在OTHER_LDFLAGS配置下果然有已经排好序的各个待加载动态库，如下图。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.20395421436004163&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYNacVtcG2Zs6SsbKYZxgrJ4K1LOssgk0nv0N3HPpr9quCxBQkqaQ28KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;961&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果我们需要将我们自定义的动态库放在第一位加载，只需要将其按照-framework“xxx”的格式写到第一位即可，如在将 LoadHook 这个动态库按照-framework“LoadHook”这种格式写在第一位之后，查看编译生成的 Mach-O 文件的 Load Commands 区，可以看到 LoadHook 的确是被编排到第一位加载了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.1264705882352941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYNpIS64T5MBhACr0lS0iacicJ1qMQwOiaURibbRjUJcfhzCibMdn6icBTMXmuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;340&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;启动治理实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了能够快速定位启动过程中耗时较长的方法，我们调研并实现了一套方法耗时检测工具，耗时检测工具包括&lt;/span&gt;&lt;code&gt;&lt;span&gt;pre-main&lt;/span&gt;&lt;/code&gt;&lt;span&gt;阶段和&lt;/span&gt;&lt;code&gt;&lt;span&gt;post-main&lt;/span&gt;&lt;/code&gt;&lt;span&gt;阶段的启动方法。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;1、启动耗时方法检测工具&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;主线程中方法执行的快慢会直接影响 APP 启动的速度，因此，找出启动过程中那些耗时的方法，对那些耗时较长的方法进行优化可以显著改善启动时间。对于pre-main阶段主要是统计 Initialize 阶段的+load方法、C/C++ 构造函数调用和非基本类型的 C++ 静态全局变量初始化的耗时，post-main阶段基本都是我们编写的业务逻辑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于C/C++ 构造函数和非基本类型的 C++ 静态全局变量会存储在 Mach-O __DATA 下的__mod_init_func的section中，而 load 方法的执行是早于C/C++ 构造函数和非基本类型的 C++ 静态全局变量的，因此，我们可以在 load 中读取__mod_init_func这个 section ，拿到__mod_init_func中每个函数的原地址并保存到一个队列中，然后将原函数指向为 hook 后的函数地址，这样我们在 hook 后的函数中从队列中取出保存的所有原函数地址并执行，从而获取到所有C/C++ 构造函数和非基本类型的 C++ 静态全局变量的执行时间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;58 同城 APP 在C/C++ 构造函数和非基本类型的 C++ 静态全局变量的使用上并不多，总体耗时数据也较少，因此对于 pre-main 阶段我们主要关注的是 load 方法的监控与优化。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;1.1、+load 方法耗时检测&lt;/span&gt;&lt;/h4&gt;&lt;h5&gt;&lt;span&gt;1.1.1、+load 耗时统计的技术方案&lt;/span&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;我们知道，在类和分类中都可以定义 +load 方法，因此，为了完整统计所有 +load 方法耗时，我们的方案需要考虑到分类中存在 +load 方法的情况。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于定义了 +load 方法的类和分类，在编译时会被分别写入到 Mach-O 的 __DATA 段的__objc_nlclslist和__objc_nlcatlist两个 section。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6128702757916241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYNbD8Mh27BFt3kCXGyuoNBy9A8LgdfnBZf3m8rsKVnkw7icruoT8kibWnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;979&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此，我们的方案是，首先通过读取 Mach-O 中 __DATA 段的__objc_nlclslist和__objc_nlcatlist两个 section，拿到包含 +load 方法的类和分类。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/** 读取含load方法的分类__objc_nlcatlist section，读__objc_nlclslist section类似 */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;- (void)readLoadCategoryListSection:(const uint64_t)mach_header{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    const struct section_64 *non_lazy_nlcatlist_section = getsectbynamefromheader_64((void *)mach_header, &quot;__DATA&quot;, &quot;__objc_nlcatlist&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (non_lazy_nlcatlist_section == NULL) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    for (uint64_t offset = non_lazy_nlcatlist_section-&amp;gt;offset; offset &amp;lt; non_lazy_nlcatlist_section-&amp;gt;offset + non_lazy_nlcatlist_section-&amp;gt;size; offset += sizeof(const void **)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        struct category_t *cat_ref = *(struct category_t **)(mach_header + offset);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Class cls = cat_ref-&amp;gt;cls;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (cls == NULL) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            continue;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        [self.loadClassArray addObject:cls];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        NSMutableArray *categoryArray = self.classKeyCategoryValueMap[cls];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (!categoryArray) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            categoryArray = [NSMutableArray array];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            self.classKeyCategoryValueMap[(id&amp;lt;NSCopying&amp;gt;)cls] = categoryArray;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        [categoryArray addObject:@((uintptr_t)cat_ref)];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;Mach-O 文件解析可以参考 58 开源项目：WBBlades&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;拿到含有 +load 方法的类和分类之后进行遍历，拿到原始 +load 方法的 IMP，通过imp_implementationWithBlock的方式 hook 掉原有 +load 方法的 IMP，在新的 IMP 中，在方法开始和结束位置插入时间统计代码，中间去调用原有 +load 逻辑。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;IMP originLoadIMP = origin_load_method-&amp;gt;imp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;IMP hookLoadIMP = imp_implementationWithBlock(^(__unsafe_unretained id self, SEL cmd){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        uint64_t starttime = currentTime();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ((void (*)(id, SEL))originLoadIMP)(self, cmd);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        uint64_t endtime = currentTime();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        recordLoadTrace(array, invokeMethodName, endtime - starttime);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;origin_load_method-&amp;gt;imp = hookLoadIMP;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这样，通过前、后相减得到每个 +load 方法耗时数据，并将所有数据导出到 excel 文件中，并写入到沙盒文件。&lt;/span&gt;&lt;/section&gt;&lt;h5&gt;&lt;span&gt;1.1.2、遇到的一个坑&lt;/span&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;在读取 Mach-O 中__objc_nlclslist节的时候，发现读出了大量__ARCLite__类型的 load 方法，__ARCLite__load是系统库加载的时候调用的，为了避免这个干扰项，我们在读取的过程中需要跳过__ARCLite__load的处理。&lt;/span&gt;&lt;/section&gt;&lt;h5&gt;&lt;span&gt;1.1.3、load 耗时优化&lt;/span&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;通过上面方案获取所有类和分类的 load 方法耗时之后，就可以进行针对性优化了。优化的手段一般有下面几种：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果时机可以的话，优先使用 +initialize 方法替换 load 方法；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;继续使用 load 方法，但是通过监听启动完成后的一个通知，再执行原来的一些耗时逻辑，从而将耗时逻辑尽可能的延后；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;另一种方案就是利用 Clang 提供的编译器函数实现对 Mach-O 的写能力，通过使用__attribute__((used, section(&quot;__DATA,__wbce_func&quot;)))来标记函数，在编译期时，编译器会将标记的数据写入到指定的 __DATA 段的__wbce_func section中，在运行时，通过读取 Mach-O 的 __wbce_func 节，取到保存的函数地址并执行。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.30047318611987384&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYN1UUwl82ICia6ba1cKpzxicCiatHB8Vs8d9Dj44HibDEuicGLTF2iaCAs8Y6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种方式可以快速替换 load 方法，并将原 load 方法中的逻辑移入到启动过程中的某一个合适的时机去执行。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;实际上，获取到所有 load 数据之后，我们发现，正常一个普通 load 方法是不耗时的，一个耗时的 load 方法主要是在里面进行了 Method Swizzling、数据存储等耗时操作.&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;因此，我们优化的主要目标可以集中在那些耗时 load 上，利用 load 耗时检测工具，我们&lt;span&gt;推动各业务线优化了多个 load 方法的处理&lt;/span&gt;，累计优化约&lt;span&gt;182ms&lt;/span&gt;（iPhone 6S，iOS 13.0 测试设备），同时做好每个版本 load 的数据监控，防止新版本出现耗时较大的 load 方法。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;1.2、OC 方法耗时检测&lt;/span&gt;&lt;/h4&gt;&lt;h5&gt;&lt;span&gt;1.2.1、OC 方法耗时检测方案&lt;/span&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;OC 是一种动态语言，方法的调用会传递对象本身和对象的方法名称两个隐藏参数，运行时方法的调用过程会交给一个 C 函数 objc_msgSend 来完成，objc_msgSend 会根据传入的对象和方法的 selector 去查找对应的函数指针并执行。整个基本流程如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.43567753001715265&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYNyT7M89icXtQZDGBGP0egDHoWcLNRbAGkibCjgL5cWrz8cHJObJGG2GMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1166&quot;/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;可以看到，OC 方法的执行必然会经过 objc_msgSend，因此如果我们能 hook 掉 objc_msgSned 方法，也就能拦截到所有 OC 方法的执行过程，这样我们在原方法的前后插入时间统计代码就能够计算出原方法的执行时间了。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;而 objc_msgSend 是一个 C 方法，因此我们可以用 fishhook 进行 hook，苹果公司为了优化 objc_msgSend 的调用性能，对 objc_msgSend 使用了汇编进行编码，因此 hook 后的 objc_msgSend 方法也需要基于汇编进行处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于 objc_msgSend 是变参函数，因此在 hook 后的汇编函数中，先要保存寄存器中的数据来保护现场，并插入我们自定义的打点方法，用于记录函数执行的开始时间，同时保存 LR 寄存器中的数据。然后恢复寄存器的数据，开始原始 objc_msgSend 方法的调用，执行完原始 objc_msgSend 方法的调用后，再插入我们自定义的打点方法，用于记录函数执行完成时间，通过前、后时间相差得到原始函数的执行时间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了能够保存函数调用记录，我们在结束原方法调用并插入结束时间打点后，就需要对该方法的调用生成一条调用记录保存下来，同时放到一条调用队列中，主要的数据结构如下：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;typedef struct {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    __unsafe_unretained Class cls;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SEL sel;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint64_t time;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    int depth;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} LTCallRecord;//一条方法调用记录&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;typedef struct {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    LTCallRecord *record;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    int allocated_length;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    int index;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} LTMainThreadCallRecord;//方法调用队列&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过 hook objc_msgSend 拿到各个 OC 方法的调用时间数据之后，根据&lt;span&gt;函数调用栈为先进后出、而同一层的函数为先进先出&lt;/span&gt;的特性，设计相应数据结构以及记录调用深度，来将整个调用过程还原为&lt;span&gt;函数调用栈&lt;/span&gt;的形式。同时，基于最外层方法耗时进行排序，以函数调用栈的格式输出到 Excel 中，输出结果如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.8733974358974359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYNtYxD8cjmA0vFbJwJSUcz6RWys8NzfgDm41AU3NX2ycxWBrAmJV8gPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;624&quot;/&gt;&lt;/section&gt;&lt;h5&gt;&lt;span&gt;1.2.2、基于 OC 方法耗时检测的优化效果&lt;/span&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;基于 OC 方法耗时检测工具，我们检测出UserAgent 获取、音频预加载、WIFILog、IWatch 链接等几个耗时处理逻辑，分别通过异步处理、延迟加载等方式进行了优化，对于涉及到业务线部分，推动各业务线进行了相应优化，累计减少约450ms（iPhone 6S iOS 13.0 测试设备）。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;1.3、基于方法耗时检测工具在版本监控上的应用&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;方法耗时检测工具包含 pre-main 阶段的 load 耗时检测和整个 post-main 阶段方法检测，然后输出对应的耗时数据报表，从而找到那些耗时方法。另外，为了解决每个版本可能新增较大耗时方法的痛点，检测工具还应用在了各版本启动耗时监控上，我们在每个版本集成之后，跑一次最新版本的启动耗时数据，与上一版本进行对比，及时监控每个版本新增的启动耗时方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每个版本在方法耗时检测工具的监控下，我们能够及时发现和优化新增的耗时方法。为了进一步优化启动耗时，我们调研并实践了二进制重排方案，以及为优化 pre-main 阶段我们实现了动态库懒加载方案。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;2、二进制重排实践&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;二进制重排的关键是获取启动过程中的符号，目前业界常用方案有：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基于静态扫描+运行时 trace 的方案来获取启动时的符号，从而生成 order file 文件实现二进制重排；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基于 Clang 静态插桩的方式来获取启动过程中的所有函数符号；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;第一种方案存在对于initialize、block、以及 C++ 函数hook 不到的问题，第二种基于 Clang 静态插桩的方案则可以解决前种方案的不足获取到所有符号。因此，58 同城选择了&lt;span&gt;基于 Clang 静态插桩的方案&lt;/span&gt;来获取启动符号.&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;2.1、虚拟内存与 Page Fault&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;早期计算机中，并没有设计虚拟内存，程序都是直接从磁盘按序完整地加载进物理内存中，这种方式由于使用的是真实物理内存地址且程序是有序加载进去的，那么通过计算地址偏移就可以访问到其他程序的内存，存在安全隐患，另外由于是完整加载，而用户实际使用时只会用到少部分功能，这样也会造成内存的极大浪费。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了解决这些问题，现在的操作系统在物理内存的基础上引入了虚拟内存的概念。虚拟内存引入后，每个进程可以认为自己拥有从0x000000~0xffffff这一大片连续的内存空间，只不过这个内存地址是虚拟的，要访问实际物理内存地址，需要通过操作系统维护的一张映射表映射之后才可以真正访问到，而映射表是以页（Page）为单位进行管理的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.6351084812623274&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYNxKibSBFNVQfliasalAkHb6gAmaPrIEvIcZwj3TXZkBoJGN9QEwYUAcBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;507&quot;/&gt;&lt;br/&gt;&lt;span&gt;当进程要访问的一个虚拟内存页在经过映射表映射之后发现对应的物理内存页不存在时，会触发一次缺页中断Page Fault，此时会发生 I/O 操作，将磁盘中的数据读入到物理内存页中，读取的过程中苹果还会对读入的内存页进行验签处理，因此如果频繁发生Page Fault的话，Page Fault产生的耗时也不可小觑。Page Fault的数量可以通过 Instruments 自带的 System Trace 工具来查看，其中File Backed Page In就是Page Fault的次数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5160642570281124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYNj0pLlHpje9hF5emjmQzIRsxbcDauuibbuRNLdofR51RjQyCQkeNSemA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;996&quot;/&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;2.2、二进制重排优化原理&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;APP 启动过程中，会加载大量的类、执行大量的方法，当频繁触发Page Fault的话，对启动耗时会产生不小的影响，因此尽可能减少Page Fault的数量可以优化启动耗时。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当启动过程中需要调用的两个方法method1和method2分布在不同的内存页时，此时操作系统需要触发两次缺页中断Page Fault，来加载这两页到内存，如果通过一定的技术手段将这两个方法排列在同一个内存页中，那此时系统只需要触发一次缺页中断即可，如果能够减少一定数量的缺页中断次数，那也就能够减少整体启动耗时。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3261117445838084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYNoJwDXgFhSy9PWbqFBvcDgvwegdCvzuwMkLk38ZPvoiaEmUpRHkCndrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;因此，二进制重排的一个核心问题就是如何将不同的方法尽可能地排列在同一个内存页中。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;生成一个二进制的 Mach-O 文件，需要经过编译、链接的过程，Xcode 使用 ld 作为链接器，ld 链接器的配置中有一个名为Order File的参数，它可以配置一个 order 文件路径。&lt;/span&gt;&lt;img data-ratio=&quot;0.18034557235421167&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYNeFnwkV9ngRQ52DPf22NS1icbn4QzLTMPEdJStP2eMpH242Ciaz0btmKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;br/&gt;&lt;span&gt;一个 order 文件内存储的是符号列表，当我们配置了 order 文件之后，ld 在工作的时候就会根据 order 文件中的符号按照顺序进行排列生成二进制文件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此，如果我们将启动过程中调用的函数符号都找到，并配置到 order 文件中，那生成的二进制文件在启动时所调用的方法都会尽量排在相同且相邻的内存页上，从而减少启动过程中发生Page Fault的次数，减少因Page Fault而产生的耗时。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此，现在的关键是找到启动过程中调用的函数符号。通过 hook objc_msgSend 能够拿到 OC 方法的调用，但是对于load方法、C++ 构造函数还需要通过扫描 Mach-O 文件来获取，还有一种方案是基于 Clang 编译期插桩来获取符号，Clang 插桩可以一次获取 OC、Swift、C、block 函数符号，因此，58 APP 采用的就是基于 Clang 插桩来实现符号收集。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;2.3、Clang 插桩收集启动过程中的函数符号&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;基于 Clang 插桩获取符号有两种实现方式：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一种是自己编写一个 Clang 插件，在 Clang 插件中我们去分析抽象语法树不同的节点，在相应的节点中插入自定义的代码用于符号收集，这种自定义 Clang 插件的方式优点是可根据自己需求进行灵活处理，缺点是通用性较差，&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一种是利用 SanitizerCoverage 工具进行符号收集。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;SanitizerCoverage 是 LLVM 内置的一个代码覆盖率检测工具，在编译时，它能够根据我们的编译配置，将一系列以__sanitizer_cov_trace_pc_为前缀的函数插入到我们自定义的函数内，比如，我们在Clang的自定义配置 Other C Flags中新增-fsanitize-coverage=trace-pc-guard标志时，编译器将会为每个自定义的函数中插入__sanitizer_cov_trace_pc_guard回调函数。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;Clang 静态插桩收集符号的原理就是，利用编译期在每一个函数内部插入回调函数&lt;/span&gt;&lt;code&gt;&lt;span&gt;__sanitizer_cov_trace_pc_guard&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，我们通过实现该函数，在运行期间就能够拿到被插入该函数的原函数地址，通过函数地址解析出函数符号，从而达到收集启动过程中函数符号的目的。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;因此，为了 Clang 前端能够利用 SanitizerCoverage 插入插桩函数，我们首先需要在Other C Flags 中添加-fsanitize-coverage=trace-pc-guard配置，这样在编译后，我们的自定义函数中都会被插入__sanitizer_cov_trace_pc_guard函数，然后我们需要实现该回调函数，并在回调函数内部收集原函数符号：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//插桩的初始化方法，首次会进入到这里面&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  static uint64_t N; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  if (start == stop || *start) return; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  for (uint32_t *x = start; x &amp;lt; stop; x++)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *x = ++N; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//每个原函数内部被插入的回调方法&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  if (!*guard) return;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;函数__sanitizer_cov_trace_pc_guard是在编译期由 Clang 插入到原函数内部的，因此__sanitizer_cov_trace_pc_guard函数算是原函数内部的一个嵌套子函数，而操作系统在执行 bl 跳转指令的时候，会先保存下一条指令地址到lr寄存器中，当__sanitizer_cov_trace_pc_guard函数执行完即执行ret指令后，需要继续回到原函数中继续执行，操作系统会去读取 LR 寄存器中的值拿到原函数的下一条待执行指令地址，这个地址可以通过下面代码来获取：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void *PC = __builtin_return_address(0);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;也就是说，在__sanitizer_cov_trace_pc_guard函数中我们可以通过 __builtin_return_address(0) 拿到原函数某条指令的地址，那我们只要再通过 dladdr() 函数就可以获取到原函数的信息，从而拿到该函数符号。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (!*guard) return; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    void *PC = __builtin_return_address(0);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Dl_info info;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    dladdr(PC, &amp;amp;info);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    printf(&quot;fname=%s \nfbase=%p \nsname=%s\nsaddr=%p \n&quot;,info.dli_fname,info.dli_fbase,info.dli_sname,info.dli_saddr);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    char PcDescr[1024];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    printf(&quot;guard: %p %x PC %s\n&quot;, guard, *guard, PcDescr);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在实际的使用过程中，需要解决以下几个主要问题：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;多线程问题，由于__sanitizer_cov_trace_pc_guard函数是各个方法内插入的回调函数，而原函数可能处于不同的线程中，从而造成__sanitizer_cov_trace_pc_guard函数调用的多线程问题，解决这个问题可以使用原子队列 OSAtomicEnqueue 来处理，使用原子队列之后需要在 Other C Flags 配置中修改原来的配置为如下形式：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;-fsanitize-coverage=func,trace-pc-guard&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果要支持 Swift 符号收集，由于 Swift 的编译前端与 OC 不同，需要在编译配置的Other Swift Flags下，新增下面配置：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;-sanitize-coverage=func&lt;br/&gt;-sanitize=undefined&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用 Cocoapods 管理的项目，存在多 target 的情况下，需要在每个 target 下都要进行上面的Other C Flags配置。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;收集到启动过程中的函数符号之后，将这些符号写入到 order 文件中，并将该 order 文件的地址在 Xcode 的Order File参数下进行配置即可。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;2.4、二进制重排前后的效果对比&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;尽量完全冷启动 APP 进行多次试验，二进制重排前、后对比的缺页中断次数如下：&lt;br/&gt;&lt;/span&gt;&lt;img data-ratio=&quot;0.21428571428571427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYNd9QLaMU8NUP29VmwsuZhR1mFXtzgRicjpCwhMGAcLqsowmicgI5U9BOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;980&quot;/&gt;&lt;br/&gt;&lt;img data-ratio=&quot;0.18386108273748722&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaEgO49xFSEYryblVTBpCsYNzlYAZsNRPjplAHgCLPWxRem6nDKTcNU4FEElvNFymibicaG72PhHiauYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;979&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看到，二进制重排优化后，&lt;span&gt;缺页中断的次数减少约1626&lt;/span&gt;次，耗时减少约&lt;span&gt;162ms&lt;/span&gt;（iPhone 6S测试设备）。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;3、动态库懒加载&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;我们知道，pre-main 过程中，有dylib的加载步骤，而动态库加载是需要耗时的，苹果建议我们自定义的动态库不要超过 6 个，因此，尽量减少启动过程中的动态库加载有助于启动耗时的优化。减少启动过程中的动态库加载主要有以下两个方案：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上面两种方案都可行，但是在实际工程操作中可能存在转换繁琐，需要解决部分依赖的问题。iOS 58 同城 APP 采用了一种动态库懒加载的方案，来减少启动过程中需要加载的动态库数量，从而达到优化启动耗时目的。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;3.1、动态库懒加载方案&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;所谓动态库懒加载是指，在启动的过程中并不加载该动态库，而是&lt;span&gt;在业务真正使用到该动态库中的内容时才进行加载&lt;/span&gt;，从而减少启动耗时。在 Cocoapods 1.2 之前存在配置动态库懒加载的入口，升级到 1.8 之后没有了动态库懒加载的配置入口，我们需要在pod install之后生成的配置文件中进行配置。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用 Cocoapods 管理的项目，在pod install之后，会生成Pods-xxx-frameworks.sh和Pods-xxx.adhoc/debug/release.xcconfig这两个文件，其中Pods-xxx-frameworks.sh文件脚本负责&lt;span&gt;架构剔除和重签名&lt;/span&gt;等功能，而&lt;/span&gt;&lt;code&gt;&lt;span&gt;Pods-&lt;/span&gt;&lt;/code&gt;&lt;span&gt;xxx.adhoc/debug/release.xcconfig文件则负责&lt;span&gt;静态库和动态库的链接配置&lt;/span&gt;，我们自定义的动态库想要进行懒加载，只需要修改&lt;/span&gt;&lt;code&gt;&lt;span&gt;xxx.xcconfig&lt;/span&gt;&lt;/code&gt;&lt;span&gt;配置文件，将&lt;span&gt;需要懒加载的动态库从配置文件中移除，这样保证懒加载的动态库参与签名和拷贝，但是不参与链接&lt;/span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;3.2、动态库懒加载后的调用方式&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;由于采用动态库懒加载后动态库在编译时没有参与链接，原有的代码调用方式会报找不到对应动态库符号的错误，因此，原有动态库的调用方式需要修改成Runtime动态调用的形式，在使用某个动态库中的类时，先动态获取该类，如果获取不到，则通过dlopen的方式动态加载该动态库：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dlopen([path UTF8String], RTLD_LAZY);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;动态库懒加载后，将减少启动过程中dlopen带来的损耗，同时减少 rebase/bind 的时间，以及避免了该懒加载动态库内 load、contructor 等函数在启动过程中执行。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;3.3、有益效果&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;目前，58 同城已经有 &lt;span&gt;12 个动态库&lt;/span&gt; 采用了懒加载的方式引入，采用懒加载后在启动速度方面减少了约 &lt;span&gt;817ms&lt;/span&gt;（iPhone 6P iOS 12.0），同时，后续将会逐步将更多的静态库转成动态库懒加载的方式进行接入。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结与展望&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文首先介绍了 58 同城基于手机系统日志获取启动时间方案自研的横向启动时间对比统计工具，然后介绍了方法耗时检测工具、二进制重排和动态库懒加载三个方向在 58 同城 APP 启动优化上的一些实践经验，方法耗时检测工具已应用在持续监控每个版本的启动耗时数据上，同时方法耗时检测工具已应用在 58 同镇本地版 APP 上。下一阶段，我们将持续优化耗时检测工具并重点关注 pre-main 阶段的优化。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;参考文献：&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;[1] Clang 12 documentation：https://clang.llvm.org/docs/SanitizerCoverage.html&lt;br/&gt;[2] WBBlades：基于Mach-O文件解析的APP分析工具：https://mp.weixin.qq.com/s/HWJArO5y9G20jb2pqaAQWQ&lt;br/&gt;[3] 基于二进制文件重排的解决方案 APP启动速度提升超15%：https://mp.weixin.qq.com/s/Drmmx5JtjG3UtTFksL6Q8Q&lt;br/&gt;[4]App 启动速度怎么做优化与监控？:https://time.geekbang.org/column/article/85331&lt;br/&gt;[5] 监控所有的OC方法耗时：https://juejin.cn/post/6844903875804135431&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;作者简介：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;廖露阳，58 同城 – 平台技术部 – iOS 技术部 高级研发工程师&lt;br/&gt;朴惠姝，58 同城 – 平台技术部 – iOS 技术部 高级研发工程师&lt;br/&gt;邓竹立，58 同城 – 平台技术部 - iOS 技术部 资深研发工程师&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NDc5MzIxMw==&amp;amp;mid=2247491542&amp;amp;idx=1&amp;amp;sn=875629db4e57dd602c434331e38b981f&amp;amp;chksm=ea3e9b44dd491252f72c23662072c8c7d0e2939378d6c5cc74b83e2617e80c4a70fda237183b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;58安全-证件识别之版面分析实践&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NDc5MzIxMw==&amp;amp;mid=2247491611&amp;amp;idx=1&amp;amp;sn=51bc8d11cdf70b7f4bfa0bf6464ad586&amp;amp;chksm=ea3d6489dd4aed9f5d15b8e7b2e3477a28f96ea719b9aae4b757e26e6f9feb21ef24236097db&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;58安全-违规水印检测的技术实践&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NDc5MzIxMw==&amp;amp;mid=2247491582&amp;amp;idx=1&amp;amp;sn=99ac3091e1d21349a3f76c8d1e25e5fe&amp;amp;chksm=ea3e9b6cdd49127ae8ba951dc59dcc5246c16da7b3d5b825ab2a3b4a86bd6bd13416411d4de9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Taro 3.2 适配 React Native 之样式内幕&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NDc5MzIxMw==&amp;amp;mid=2247491565&amp;amp;idx=1&amp;amp;sn=367209eb87ec22a8436ca8514d8b4f5b&amp;amp;chksm=ea3e9b7fdd4912695e37346d7feddd9f7b92f9a2000f76b7dbb7a6665adaef179f0eea41c855&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Taro3.2 适配 React Native 之运行时架构详解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.35546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2VY3NksPSaHql4LCOdAUeJwmvS72ibDva6YTC5lzpo8tfzSSeQuxRfxPibP3ybyWlpt9d4VxXd8hO5GiaJdMhba5Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4b8884b08ff49a0470a2e4fdb7dfd1aa</guid>
<title>使用火焰图定位 OLAP 引擎瓶颈</title>
<link>https://toutiao.io/k/v0y3otx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;在维护 OLAP 引擎时，很多时候需要对引擎做系统的性能分析和优化，此时往往需要查看 CPU 耗时，了解主要耗时点及瓶颈在哪里。俗语有曰：兵欲善其事必先利其器，程序员定位性能问题也需要一件“利器”。性能调优工具（perf）能够显示系统的调用栈及时间分布，但是呈现内容上只能单一的列出调用栈或者非层次化的时间分布，不够直观。火焰图（flame graph）能够帮助大家更直观的发现问题。本文将以 Presto 为例，介绍火焰图的使用技巧。&lt;/p&gt;&lt;h2&gt;初识火焰图&lt;/h2&gt;&lt;p&gt;Perf 的原理是这样子的：每隔一个固定的时间，就在 CPU 上（每个核上都有）产生一个中断，在中断上看看，当前是哪个 pid，哪个函数，然后给对应的 pid 和函数加一个统计值，这样，我们就知道 CPU 有百分几的时间在某个 pid，或者某个函数上了。而火焰图（Flame Graph）是由 Linux 性能优化大师 Brendan Gregg 发明的，和所有其他的 profiling 方法不同的是，火焰图以一个全局的视野来看待时间分布，它从底部往顶部，列出所有可能导致性能瓶颈的调用栈。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.57109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ds2JiaGwEJrFCLibdvoddcdj3NaCl83sfLCOAaYmSnOPl62elbXkCzCzOicPHVAfvWHPHPS25iaoaS3tSuEPXDbO3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;火焰图整个图形看起来就像一个跳动的火焰，这就是它名字的由来。火焰图有以下特征（这里以采样CPU 火焰图为例）：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;每一列代表一个调用栈，每一个格子代表一个函数。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;纵轴展示了栈的深度，按照调用关系从下到上排列。最顶上格子代表采样时，正在占用 CPU 的函数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;横轴的意义是指：火焰图将采集的多个调用栈信息，并行关系。横轴格子的宽度代表其在采样中出现频率，所以一个格子的宽度越大，说明它是瓶颈原因的可能性就越大。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;火焰图格子的颜色是随机的暖色调，方便区分各个调用信息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;其他的采样方式也可以使用火焰图， 比如内存&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;所以，火焰图就是看顶层的哪个函数占据的宽度最大。只要有”平顶”，就表示该函数可能存在性能问题，也是我们性能优化收益最大的地方。&lt;br/&gt;Java生态常见的用于perf的工具有：allocation-instrumenter、YourKit Profiler、async-profiler、JProfiler、Arthas（基于 async-profiler ）。笔者推荐使用阿里巴巴出品的 Arthas 或 async-profiler，笔者喜欢使用 async-profiler 这个 perf 工具生成火焰图，主要原因是用法简单，足够满足日常排查性能问题了。&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;async-profiler 介绍&lt;/h2&gt;&lt;p&gt;Async-profiler是一款没有 Safepoint bias problem 的低开销 Java 采集分析器，它的实现是基于HotSpot 特有的 API，通过这些特有的 API 收集堆栈跟踪和跟踪内存分配，因而其可以和 OpenJDK、Oracle JDK 和其他基于 HotSpot JVM 的 Java 应用在运行时协同工作。&lt;/p&gt;&lt;p&gt;Async-profiler 可以跟踪以下类型的事件：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;CPU 周期；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;硬件和软件性能计数器，如 cache misses, branch misses, page faults, context switches 等；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Java 堆中的分配；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;锁尝试，包括 Java 对象监视器和可重入锁；&lt;br/&gt;支持的平台&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Linux / x64 / x86 / ARM / AArch64&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;macOS / x64&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;并且 IntelliJ IDEA Ultimate 2018.3 之后的版本也集成了 async-profiler。Github 项目链接地址：https://github.com/jvm-profiling-tools/async-profiler&lt;br/&gt;主页上有已经编译好的包，找到对应的平台下载即可：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.50625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ds2JiaGwEJrFCLibdvoddcdj3NaCl83sfLicKGlG9j9lwB9VGoZy169iaiaHQ1yBQ22Zvkibeoyo2VuhHLCJOnAXNW7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2&gt;async-profiler 使用&lt;/h2&gt;&lt;p&gt;下载好的文件解压后，有一个profiler.sh脚本，运行脚本即可对 Java 进程进行 CPU 分析。例如 Presto 的 Java 进程 id 为 8983。&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;$ jps&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;9234&lt;/span&gt; Jps&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;8983&lt;/span&gt; PrestoServer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$ ./profiler.sh start &lt;span&gt;8983&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$ ./profiler.sh stop &lt;span&gt;8983&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;或者可以用-d指定剖析的时间（秒），我们将其重定向到一个文本文件里。&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;./profiler.sh -d &lt;span&gt;30&lt;/span&gt; &lt;span&gt;8983&lt;/span&gt; &amp;gt; &lt;span&gt;8983.&lt;/span&gt;txt&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;执行完成后会输出采集的信息，这些信息可以帮我看到详细的函数调用逻辑，这非常有用，因为假如你新接触一个新的 OLAP 引擎，想快速入门，比如想了解其读写流程及代码执行流程，通过这些采集信息就可以快速帮我们捋清楚执行流程，如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.76484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ds2JiaGwEJrFCLibdvoddcdj3NaCl83sfLuLdYywkshPLKwgwZRFXgB9fEBV971Xucouic2c7DOsFvBJmy9yZ3h5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果你想生成火焰图，只需要执行如下命令即可：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;$ ./profiler.sh -d &lt;span&gt;30&lt;/span&gt; -f /tmp/flamegraph.svg &lt;span&gt;8983&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;生成的svg火焰图如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ds2JiaGwEJrFCLibdvoddcdj3NaCl83sfLdiaYoYzTGicuGwCEIU5xBiaBBXoGdRhIhGGpINFoqVnI53DiasIpkTNLaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;从上图我们可以看到大约 91.63% 的CPU用于GC，如果当前系统 CPU 使用率比较高，那就说明这些 CPU 没有在干正事，都耗费在 GC 里了，当前服务的主要瓶颈在 JVM 层，需要找下 JVM 瓶颈。&lt;/p&gt;&lt;h2&gt;event 参数介绍&lt;/h2&gt;&lt;p&gt;event 可选参数使用如下命令查看，不同 CPU 支持的 event 是不一样的。&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;./&lt;span&gt;profiler&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; &lt;span&gt;list&lt;/span&gt; &lt;span&gt;list&lt;/span&gt; 8983&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;输出结果：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;[presto@localhost ~]$ ./profiler.sh list list 8983&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Basic events:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  cpu&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  alloc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;lock&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  wall&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  itimer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Perf &lt;span&gt;events&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  page-faults&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;context&lt;/span&gt;-switches&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  cycles&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  instructions&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;cache&lt;/span&gt;-&lt;span&gt;references&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;cache&lt;/span&gt;-misses&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  branches&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  branch-misses&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  bus-cycles&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  L1-dcache-&lt;span&gt;load&lt;/span&gt;-misses&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  LLC-&lt;span&gt;load&lt;/span&gt;-misses&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  dTLB-&lt;span&gt;load&lt;/span&gt;-misses&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  mem:breakpoint&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;trace&lt;/span&gt;:tracepoint&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;event 默认为 cpu ，假如想查看内存分配，可以使用 alloc 查看，命令如下：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;./profiler.sh -e alloc -d &lt;span&gt;30&lt;/span&gt; -f /tmp/flamegraph.svg &lt;span&gt;8983&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;火焰图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.80390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ds2JiaGwEJrFCLibdvoddcdj3NaCl83sfLmu6QhwxMxTtibDQLKMibRY5PzwFUktsv4IS85icZAQdUEbHWfJGtrAfpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，可以看到内存占用主要包括三大部分：Presto执行、数据交互及读取HDFS，知道这些信息后，我们就可以针对性的优化了。&lt;/p&gt;&lt;h2&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1616504126466&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1616504126466&quot;/&gt;&lt;/h2&gt;&lt;h2&gt;使用过程中常见的问题&lt;/h2&gt;&lt;p&gt;在使用 Async-profiler 过程中，我们有时候会遇到如下错误：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;Could not &lt;span&gt;start&lt;/span&gt; attach mechanism: &lt;span&gt;No&lt;/span&gt; such &lt;span&gt;file&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; &lt;span&gt;directory&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这是因为 Java 程序第一次执行 jmap 或 jstack 等 perf 命令后会在 /tmp 下创建 socket 文件，socket 文件路径为 /tmp/.java_pidXXX，但是操作系统默认 10 天会删除这个临时文件，之后再执行 perf 命令就不行了，解决方法是在 /usr/lib/tmpfiles.d/tmp.conf 中添加 x /tmp/.java* ，这样就不会删除这个 socket 文件了。&lt;/p&gt;&lt;p&gt;参考资料：&lt;/p&gt;&lt;p&gt;https://github.com/jvm-profiling-tools/async-profiler&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b33514d051fb9b1c9653543682b2c75a</guid>
<title>Etcd 分布式锁内存泄露</title>
<link>https://toutiao.io/k/s8q5qn3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h3 cid=&quot;n2&quot; mdtype=&quot;heading&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;背景&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n3&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;通过监控看到云平台后端程序的内存使用量在稳定增加，每次上线完又会恢复，基本可以断定程序存在内存泄漏问题（可以用memleak检测，memleak是基于ebpf的一个bcc工具）&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n4&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;排查过程&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n5&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;golang程序的问题排查，无论CPU还是Memory问题都可以用官方提供的pprof工具，最简单的办法就是在代码加入如下包net/http/pprof，上线到了测试环境，然后通过go tool pprof httpaddress的方式查看内存消耗，网上也有很多pprof使用方法的文章，可以自行搜索，知道怎么用了之后看下图  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;126&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FQzrnYr2ZmFNRxt68rG9Uy3txibfbcUf40UJ0yRvdWjVKr6vRcMhhMaS1ENHibonpeKrNCZQTNMgsjjFeeVDN1nQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n6&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;由于是测试环境，对接测试集群，本身数据量就不大，程序刚启动时占用内存也就百十来M，现在已经用了1G多，占用内存最多的是newWatcherGrpcStream函数，还有一些其他的函数，占用的内存也在逐步增加，先看newWatcherGrpcStream函数，可以通过list查看其具体内存使用情况，如下图&lt;/span&gt;&lt;br/&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;193&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.33359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FQzrnYr2ZmFNRxt68rG9Uy3txibfbcUf4SiaIKXicuKzGST8Z73YVNVv8lbFApicqmYJd21I6HOIbavYkpr1lvq1cQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n9&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;fmt.Sprintf居然都占用了86.01M内存，还有几个chan占用的也比较多，但是基本都是无缓存的chan，正常不会占用这么多的。一般内存泄露可能是流未关闭，这种情况一般文件描述符也会泄露，另外就是用到缓存时也容易造成泄露，如果缓存的内容得不到释放且一直增加内容，内存就会越来越高。去看etcd相关代码，在代码中找问题，发现了一处很可疑的代码，去掉了无关内容，且增加了fmt.Println相关函数，方便观察每次运行到此处的缓存的结果，如下&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(w *watcher)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Watch&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context, key &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;, opts ...OpOption)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;WatchChan&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ctxKey := fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%v&quot;&lt;/span&gt;, ctx)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   w.mu.Lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; w.streams == &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      w.mu.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      ch := &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;chan&lt;/span&gt; WatchResponse)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__built_in&quot;&gt;close&lt;/span&gt;(ch)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; ch&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   fmt.Println(ctxKey)      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   fmt.Println(&lt;span class=&quot;code-snippet__built_in&quot;&gt;len&lt;/span&gt;(w.streams))       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   wgs := w.streams[ctxKey]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; wgs == &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;new watcher stream&quot;&lt;/span&gt;)        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      wgs = w.newWatcherGrpcStream(ctx)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      w.streams[ctxKey] = wgs&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;use exist watcher stream&quot;&lt;/span&gt;)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; watcher &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   remote pb.WatchClient&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   mu sync.RWMutex&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   streams &lt;span class=&quot;code-snippet__keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;]*watchGrpcStream&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n11&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这里出现了上面的fmt.Sprintf、newWatcherGrpcStream等函数，而且出现了缓存，即w.streams，每次watch时都是先调用fmt.Sprintf获取到key，再从缓存中取，如果有则复用，没有则新建，问题很有可能出现在这里，然后再找一下缓存删除数据的逻辑，如下&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(w *watcher)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(err error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   w.mu.Lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;begin close watcher&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   streams := w.streams&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   w.streams = &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   w.mu.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; _, wgs := &lt;span class=&quot;code-snippet__keyword&quot;&gt;range&lt;/span&gt; streams {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; werr := wgs.Close(); werr != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         err = werr&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(w *watcher)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;closeStream&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(wgs *watchGrpcStream)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   w.mu.Lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;delete watch stream&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__built_in&quot;&gt;close&lt;/span&gt;(wgs.donec)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   wgs.cancel()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; w.streams != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;before delete:&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__built_in&quot;&gt;len&lt;/span&gt;(w.streams))      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      fmt.Println(wgs.ctxKey)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; _,ok:=w.streams[wgs.ctxKey];ok{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;delete key exist&quot;&lt;/span&gt;)        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }     &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;delete key NOT exist&quot;&lt;/span&gt;)    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__built_in&quot;&gt;delete&lt;/span&gt;(w.streams, wgs.ctxKey)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;after delete:&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__built_in&quot;&gt;len&lt;/span&gt;(w.streams))       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   w.mu.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n13&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;和删除缓存相关的函数有两个，第一个Close函数只有在etcdclient的关闭链接时才会调用，而我们在不断的lock，unlock时其实用的是同一份etcdclient，所以不会是第一个函数。还剩一个closeStream函数，这里我也加了一些打印信息，用来查看缓存相关信息，closeStream调用如下&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(w *watcher)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;newWatcherGrpcStream&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(inctx context.Context)&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;watchGrpcStream&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; wgs.run()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; wgs&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(w *watchGrpcStream)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      w.owner.closeStream(w)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;整个过程从插入缓存到删除缓存看起来都没有问题，只能写个demo测试一下了，demo大致如下&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   client := instance.GetEtcdClient()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   locker := lock.New(client, lock.WithTTL(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;*time.Second))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; foo(locker)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   http.HandleFunc(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/gc&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(writer http.ResponseWriter, request *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      runtime.GC()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   http.ListenAndServe(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;:8080&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(locker lock.Locker)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ticker := time.NewTicker(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; * time.Second)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ids := []&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;{&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;1&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;2&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;3&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;4&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;5&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;6&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;7&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;8&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;9&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;10&quot;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;range&lt;/span&gt; ticker.C {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; _, v := &lt;span class=&quot;code-snippet__keyword&quot;&gt;range&lt;/span&gt; ids {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(i &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            unlock, _, err := locker.Trylock(context.TODO(), fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%s/%s&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/kaku/test/etcd/lock&quot;&lt;/span&gt;, i))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != context.DeadlineExceeded {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;lock task failed:%s&quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               time.Sleep(time.Second)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         }(v)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n17&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;特别简单，就是不断的去lock，unlock，结合之前增加的一些缓存打印信息，运行demo，结果如下&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;go&quot; cid=&quot;n18&quot; mdtype=&quot;fences&quot;&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293267&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078016721&lt;/span&gt; [&lt;span&gt;750.274218&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;watcher&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293375&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078124824&lt;/span&gt; [&lt;span&gt;704.968531&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;watcher&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293271&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078020710&lt;/span&gt; [&lt;span&gt;704.72989&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;watcher&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293342&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078090947&lt;/span&gt; [&lt;span&gt;704.058853&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;watcher&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293275&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078023966&lt;/span&gt; [&lt;span&gt;703.750266&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;watcher&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293282&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078031664&lt;/span&gt; [&lt;span&gt;703.519141&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;watcher&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293339&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078088098&lt;/span&gt; [&lt;span&gt;702.930648&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;watcher&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293454&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078203813&lt;/span&gt; [&lt;span&gt;688.620812&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;watcher&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293371&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078120807&lt;/span&gt; [&lt;span&gt;688.102422&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;watcher&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293341&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078090285&lt;/span&gt; [&lt;span&gt;688.007852&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;9&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;watcher&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;watch&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;before&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293282&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078031664&lt;/span&gt; [&lt;span&gt;703.500369&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;exist&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;after&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;watch&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;before&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293371&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078120807&lt;/span&gt; [&lt;span&gt;688.080708&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;exist&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;after&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;watch&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;before&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293275&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078023966&lt;/span&gt; [&lt;span&gt;703.729632&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;exist&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;after&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;watch&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;before&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293342&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078090947&lt;/span&gt; [&lt;span&gt;704.033358&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;exist&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;after&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;watch&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;before&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293375&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078124824&lt;/span&gt; [&lt;span&gt;704.880537&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;exist&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;after&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;watch&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;before&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293341&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078090285&lt;/span&gt; [&lt;span&gt;687.986963&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;exist&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;after&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;watch&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;before&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293339&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078088098&lt;/span&gt; [&lt;span&gt;702.908025&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;exist&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;after&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;watch&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;before&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293267&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078016721&lt;/span&gt; [&lt;span&gt;750.193256&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;exist&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;after&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;watch&lt;/span&gt; &lt;span&gt;stream&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;before&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithDeadline&lt;/span&gt;(&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;04.293271&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;0800&lt;/span&gt; &lt;span&gt;CST&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;span&gt;=+&lt;/span&gt;&lt;span&gt;3.078020710&lt;/span&gt; [&lt;span&gt;704.644318&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;])&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithCancel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;exist&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;after&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;p&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n19&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;看到每次复用缓存都会失败，而且删除缓存的key时，key都不存在，导致缓存的数量一直在增加，从而导致使用的内存越来越大。那为什么每次复用缓存和删除时都找不到对应的key呢，其实问题就出现在的缓存key的计算方法上&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ctxKey := fmt.Sprintf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%v&quot;&lt;/span&gt;, ctx)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n21&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;简单，粗暴，直接格式化ctx作为缓存的key，那问题就来了，我们传入的ctx其实是context.WithTimeout后得到的，这个ctx格式化后会带时间输出，如上面的输出结果，同一个ctx，每次格式化输出得到的string其实是不一样的，而且这个key是每次用到的时候都去获取一次，并没有在第一次获取完就保存下来，所以就会导致每次获取缓存都没有这个key，删除时也没有，这就是问题所在了，也可以解释为什么fmt.Sprintf居然还会占用那么多内存的现象了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n22&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;目前用的3.1.3的etcd代码，直到3.2.20版本时获取key的方式才改变，但是当初要改变的获取key的方式的原因并非是发现了上述问题，而是之前的设计还存在另一个问题，即竞态问题，见&lt;span&gt;https://github.com/etcd-io/etcd/issues/8275&lt;/span&gt;&lt;/span&gt;&lt;span md-inline=&quot;link&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;。无心插柳柳成荫，3.2.20版本解决了竞态问题后，上面分析的问题也就解决了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n23&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;解决方案&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n24&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;升级etcd包版本至少到3.2.20&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;K8S 进阶训练营&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4MjQ0MTU4Ng==&amp;amp;mid=2247489805&amp;amp;idx=2&amp;amp;sn=5b56d6eb75fe6c287ca1e20c153acea8&amp;amp;chksm=fdb91610cace9f06cfbbe1ef52cf7485b7b14edd918e9d568ab08dae3db5fa3263c2754daf77&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;568&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;320&quot; data-ratio=&quot;0.5714285714285714&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;840&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7Ytdz3cJQzm3PlhRuryKib0Fp6l52iciaCNguv9ia3Dr5HbD6IicwG0aS1kfZGgZyuXIicdsxmAsLJiacr0FQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.6197183&quot; data-type=&quot;gif&quot; data-w=&quot;71&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/rFWVXwibLGty0S5JgMN8PpBib2631p7cDvlvTEaxFBzljBX9qWcVMSOymhkTd6ZmanRibYWsh0HmccjGWkadiaLwAA/640?wx_fmt=gif&quot;/&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;点击屏末&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;| &lt;strong&gt;&lt;span&gt;&lt;strong&gt;阅&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;读&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;原&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;文&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt; |&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;即刻学习&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4MjQ0MTU4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtTw2oONBkwaiaM9hBxUj6yRLDEw8rSSxR8wWZFLjjXWpmGq5LNDlEAn4v9lSALDiaGfC4MyPZwL95g/0?wx_fmt=png&quot; data-nickname=&quot;k8s技术圈&quot; data-alias=&quot;kube100&quot; data-signature=&quot;专注容器、专注 kubernetes 技术......&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>828fd1b2052c0d0dcae08a7c0e8978e0</guid>
<title>[译] 何时使用 Rust？何时使用 Go？</title>
<link>https://toutiao.io/k/tt8a7m6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;原文地址：https://medium.com/codex/when-to-use-rust-and-when-to-use-go-590bcbb49bec&lt;/p&gt;&lt;p&gt;原文作者: Joel&lt;/p&gt;&lt;p&gt;本文永久链接: Github&lt;/p&gt;&lt;p&gt;译者：tt&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直截了当的说, Go 和 Rust 之间有明显的区别。Go 更加注重构建可扩展的 Web API 和微服务，尤其是有 goroutine 的助力。虽然 Rust 作为后者也可以做这些事情，但是开发体验要差许多。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vbERicIdYZbBhVBObcodrHwRckXvJzecOlnuDU0IFmuxrcibTGrekpjM1f5ibBdJqWtDg2dGlFic9euQxOsfHIpC6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rust 非常适合处理大量数据和其他 CPU 密集型操作，例如执行算法。这是 Rust 相比于 Go 的最大优势。要求高性能的项目通常更适合 Rust 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本教程中，我们将对 Go 和 Rust 进行比对，评估各自的并发性，内存管理和开发体验。我们还会对这些事物做出综述，来帮助你快速为项目做技术选型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这吸引了你，我们开始深入讲解!&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;性能&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 最初是由 Google 的工程师设计的，于 2009 年公布。它作为 C++ 的替代方案而产生，易于学习和编码，并且经过优化可在多核 CPU 上运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自那之后，Go 语言变得非常适合希望利用语言内置并发性的开发者。该语言提供的 goroutine 可以使你像子进程一样运行函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 的一大优势是您可以轻松使用 goroutine。只需将 go 关键字写到到函数前即可使其作为子进程运行。Go 的并发模型使您可以在多个 CPU 内核之间平衡工作负载，使其成为一种非常高效的语言。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;import (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;func f(from string) {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; 3; i++ {&lt;br/&gt;  fmt.Println(from, &lt;span&gt;&quot;:&quot;&lt;/span&gt;, i)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; f(&lt;span&gt;&quot;direct&quot;&lt;/span&gt;)&lt;br/&gt; go f(&lt;span&gt;&quot;goroutine&quot;&lt;/span&gt;)&lt;br/&gt; time.Sleep(time.Second)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;done&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管有多核 CPU 支持，Rust 仍然可以跑赢 Go。Rust 在执行算法和资源密集型操作方面效率更高。基准测试通过各种算法将 Rust 和 Go 做比较，例如二叉树。对于所有测试算法，Rust 至少快 30％；在二叉树计算的情况下，最高可达 1,000％。Bitbucket的一项研究表明，Rust与C++的性能相似。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6680555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbBhVBObcodrHwRckXvJzecOOFZe9KqkvRFicNFNlZJ8ZVqBr3PHbibQnTdNllpO9XZL0f9uBiad1xndg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(来源: 基准测试)&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;并发性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上所述，Go 支持并发。例如，假设您正在运行一个处理 API 请求的网络服务器。您可以使用 Go 的 goroutine 将每个请求作为子进程运行，将任务分布到所有可用的 CPU 核心来最大化效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Goroutine 是 Go 内置函数的一部分，而 Rust 仅支持使用 async/await 来实现并发。因此，当涉及到并发时，Go 的开发体验更好。但是，Rust 在内存安全性方面要好得多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个简化的 Rust 线程示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;use std::thread;&lt;br/&gt;use std::time::Duration;&lt;br/&gt;fn &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 1. create a new thread&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; 1..10 {&lt;br/&gt;        thread::spawn(|| {&lt;br/&gt;            println!(&lt;span&gt;&quot;thread: number {}!&quot;&lt;/span&gt;, i);&lt;br/&gt;            thread::sleep(Duration::from_millis(100));&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;    println!(&lt;span&gt;&quot;hi from the main thread!&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发一直是开发人员的棘手问题。在不损害开发体验的前提下，确保内存安全的并发并不是一件容易的事。但是，正是这种对安全的极端关注导致了可证明是正确的并发模型的产生。Rust 尝试使用所有权概念来防止未经授权的资源访问，以防止出现内存安全错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rust提供了四种不同的并发范式，以帮助您避免常见的内存安全陷阱。我们将仔细研究两个常见的范例：通道(Channel)和 锁(Lock)。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通道&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道有助于将消息从一个线程传输到另一个线程。虽然 Go 也存在这种概念，但 Rust 允许您将指针从一个线程转移到另一个线程，以避免资源竞争。通过传递指针，Rust 可以为通道强制执行线程隔离。同样，Rust 的并发模型也表现出对内存安全的“痴迷”。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仅在持有锁时才能访问数据。Rust 依赖于锁定数据的原则而不是 cod(condition机制)，而 cod 经常在诸如 Java 之类的编程语言中找到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有关所有权和所有并发范例的更多详细信息，请查看 “Fearless Concurrency with Rust”(无畏并发)。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;内存安全&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;早期的所有权概念是 Rust 的主要卖点之一。Rust 具有类型安全性，这一点对于用于将内存安全并发提升到一个新的水平很重要&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 Bitbucket 博客的说法，“ Rust 非常严格且繁琐的编译器会检查您使用的每个变量以及您引用的每个内存地址。它避免了可能的数据竞争情况，并通知您关于未定义行为的信息。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这意味着，由于 Rust 对内存安全性的极度痴迷，您将不会出现缓冲区溢出或竞争条件。但是，这也有其缺点。例如，您在编写代码时必须非常了解内存分配原则。始终保持内存安全编程并不容易。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开发体验&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，让我们看一下这两种语言的学习曲线。Go 的设计考虑了简单性。开发人员经常将其称为“无聊的”语言，也就是说，其有限的内置功能使 Go 易于使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，Go 作为一种 C++ 的简单替代方法，隐藏了诸如内存安全性和内存分配之类的问题。Rust 走了另一条路，强迫您考虑诸如内存安全性的概念。所有权的概念和可以传递指针的能力使 Rust 变得不那么吸引人学习。当您不断考虑内存安全性时，您的工作效率就会降低，并且您的代码注定会变得更加复杂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 Go 相比，Rust 的学习曲线非常陡峭。值得一提的是，与 Python 和 JavaScript 等动态语言相比，Go 的学习曲线更为陡峭。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么时候使用 Go&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 在各种场景中都能很好地工作，使其成为创建 Web API 的 Node.js 的绝佳替代品。正如 Loris Cro 指出的那样，“ Go 的并发模型非常适合必须处理多个独立请求的服务器端应用程序”。这正是 Go 提供 goroutine 的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，Go 内置了对 HTTP Web 协议的支持。您可以使用内置的 HTTP 支持快速实现一个小型 API，并将其作为微服务运行。因此，Go 非常适合微服务架构，可满足 API 开发人员的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简而言之，如果您重视开发速度并且更喜欢简单的语法而不是极致的性能，那么 Go 是一个很好的选择。最重要的是，Go 提供了更好的代码可读性，更符合大型开发团队的准则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候使用 Go:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;你关注简洁性和可读性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你需要简单的语法来快速编写代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你想要使用一种更加灵活的语言来做 web 开发&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么时候使用 Rust&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当性能至关重要时，例如处理大量数据时，Rust 是一个不错的选择。此外，Rust 在线程行为和资源跨线程共享方面为您提供了细粒度控制的可能。另一方面，Rust 具有陡峭的学习曲线，并且由于内存安全性的额外复杂性而减慢了开发速度。这不一定是不利的。Rust 还让编译器检查每个数据指针，来保证您不会遇到内存安全错误。对于复杂的系统，此保证会派上用场。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候使用 Rust:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;你关注性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你需要对于线程的细粒度控制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你认为内存安全性比简洁性更重要&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go vs. Rust: 我的肺腑之言&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们首先强调相似之处。Go 和 Rust 都是开源的，旨在支持微服务架构和并行计算环境。两者都通过并发优化了可用 CPU 内核的利用率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到底，哪种语言是最好的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有很多方法可以解决这个问题。我建议您考虑要构建的应用程序种类。Go 可以很好地利用内置的并发特性来创建微服务架构下的 Web 应用程序和 API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您也可以使用 Rust 来开发 Web API，但这不是在设计时考虑到的。Rust 专注于内存安全性会增加复杂性和开发时间，尤其是对于相当简单的 Web API 而言。但是，对代码的大量控制使您可以编写更优化，内存效率更高且性能更高的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简而言之，Go 与 Rust 的争论实际上是一个简单与安全的问题。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>021147d2e7209caf8651a922bc8c0089</guid>
<title>如何购买一本书？</title>
<link>https://toutiao.io/k/jtz7p3i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;p&gt;看到题目你可能就笑了，买书还用你教？&lt;/p&gt;
&lt;p&gt;确实，对于书这种相对廉价的消费品，有啥可说的，买就得了呗。但如果你没有那么大的房子可以存放下你任性购买的图书，亦或是搬家时对着成箱的书籍一筹莫展（正所谓买书一时爽，搬家火葬场），那我建议你读一下这篇文章。希望它能帮你买到值得买的书籍。&lt;br/&gt;
&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/03/1-how-to-buy-a-book.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/03/1-how-to-buy-a-book-250x300.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;选书&lt;/h3&gt;
&lt;p&gt;买书的第一件事情是要知道买哪本书。这方面一般有三个渠道：他人推荐、网络推送、自己发现。&lt;/p&gt;
&lt;p&gt;他人推荐是非常重要的知道一本书的渠道，尤其是靠谱的人的推荐。师长、朋友、同事，在和他们的交流过程中都可能会得知一些书籍的线索。比如前些天我和几个同事聊了半个小时，回头就把聊到的几本书加入了购物车。&lt;/p&gt;
&lt;p&gt;他人推荐自然包括了网络上的名人推荐。比如我以前买的很多书籍都来自&lt;a href=&quot;https://www.douban.com/people/pongba/doulists/all&quot;&gt;刘未鹏的豆列&lt;/a&gt;，吴军博士也在他的专栏里推荐过书单。这些书籍都是值得购买和阅读的。你也可以在豆瓣这类网站上通过你关注的人，知道他们正在阅读的书籍。当然还包括你关注的阅读类公众号或微博。&lt;/p&gt;
&lt;p&gt;网络推送一方面是指各种网站根据你之前搜索或购买的书籍而推荐的相关书籍，这在你要学习一个全新领域的时候特别有用。比如你想学习区块链相关的知识，无论是在豆瓣还是京东随便搜索出来一本区块链书籍，都会在推荐列表中看到很多相关书籍。另一方面是指在微信读书、得到这类阅读社区中主动推送的书籍，通常代表了近期的一些热点，值得关注。&lt;/p&gt;
&lt;p&gt;除此之外，你还可以主动去发现书籍。抛开网络去逛逛图书馆或小书店，往往会有很多惊喜。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/03/2-how-to-buy-a-book.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/03/2-how-to-buy-a-book-300x200.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;比较&lt;/h3&gt;
&lt;p&gt;知道了要买哪本书后，你是直接网上下单坐等拆封吗？你是否很多时候买完发现质量并没有想象中好？或者翻译得简直惨不忍睹？一部《福尔摩斯探案集》有十几种版本，随手一买往往会买到翻译得糟糕的版本，白花钱不说，还浪费书架。&lt;/p&gt;
&lt;p&gt;这时你需要去豆瓣这类网站上搜索你挑选的书籍，对不同版本、不同译者、不同出版社进行比较，详细阅读书评和短评，特别要关注那些评分低的评价。看看是有理有据的吐槽内容、排版、装订，还是觉得不适合他而打低分。尤其是那些翻译书籍，往往高分是打给原版的，而低分则是送给翻译。&lt;/p&gt;
&lt;h3&gt;比价和购买&lt;/h3&gt;
&lt;p&gt;挑选好版本后，不要忙着网上下单。我的做法是先通过豆瓣的购书单功能加入购书单，等攒够了几本后再对不同网站的价格进行比较，然后一键下单。或者等到618、双11这样优惠活动比较大的时候再下单。书虽然便宜，但该薅的羊毛还是要薅的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/03/3-how-to-buy-a-book.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/03/3-how-to-buy-a-book-300x153.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;电子书&lt;/h3&gt;
&lt;p&gt;除了购买纸书，电子书也是非常不错的选择。近年来电子书越来越流行，你可能留恋纸书的墨香和触感，但电子书唾手可得、随手可读的优点是纸书无法企及的。唾手可得是指，上述一系列繁琐的选书、比较和购买步骤完全可以忽略，当你了解到一本书之后，只需要几分钟操作就可以试读了，从而亲自判断出是否值得购买。随手可读是指携带方便，想看就看。一个小小的手机、平板或Kindle就可藏万卷书。&lt;/p&gt;
&lt;p&gt;我常用的电子书平台有微信读书、得到、豆瓣阅读等。相比较起来，微信读书的图书数量很多，社交体验最好，而且之前有很多羊毛可薅，可以免费阅读很多图书。豆瓣阅读的体验最好，而且那股文艺小清新的劲头是其他App不能比拟的。但相比较来说看，作为字体控，我还是更喜欢得到。&lt;/p&gt;
&lt;p&gt;如果你和我一样是一名程序员，那我强烈推荐O&#x27;Reilly Learning Platform。里面涵盖了市面上绝大多数技术书籍，而且通过ACM会员的方式购买，不到200RMB的年费也是相当良心。其手机版体验也很不错。在阅读翻译版不知所云的时候，我常常打开手机或iPad去看原版。&lt;/p&gt;
&lt;p&gt;国内的技术出版社这几年纷纷推出自己的社区，比如图灵、异步、博文视点等，既卖纸书也卖电子书，而且质量都不错，除了PDF版本，有些还包含epub和mobi版本，可以按需下载。&lt;/p&gt;
&lt;p&gt;近年来国内正版电子书的氛围虽然越来越好，但盗版电子书仍然很猖獗。我已经大概十年时间没有下载和传播过任何盗版电子书了，我相信你也可以。&lt;/p&gt;
&lt;p&gt;很多人买盗版书的原因是买不到正版，比如旧书绝版了。这种时候可以去各大电子书平台找找，或者去多抓鱼等二手商城、图书馆碰碰运气。如果实在找不到，就随缘吧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/03/4-how-to-buy-a-book.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/03/4-how-to-buy-a-book-300x169.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于书这种廉价的奢侈品，买买买就对了。&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>