<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5602a7fbbd4399ee7fd2f37520746177</guid>
<title>我用 Kafka 两年踩过的一些非比寻常的坑</title>
<link>https://toutiao.io/k/95yxept</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的上家公司是做餐饮系统的，每天中午和晚上用餐高峰期，系统的并发量不容小觑。为了保险起见，公司规定各部门都要在吃饭的时间轮流值班，防止出现线上问题时能够及时处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我当时在后厨显示系统团队，该系统属于订单的下游业务。用户点完菜下单后，订单系统会通过发&lt;code&gt;kafka&lt;/code&gt;消息给我们系统，系统读取消息后，做业务逻辑处理，持久化订单和菜品数据，然后展示到划菜客户端。这样厨师就知道哪个订单要做哪些菜，有些菜做好了，就可以通过该系统出菜。系统自动通知服务员上菜，如果服务员上完菜，修改菜品上菜状态，用户就知道哪些菜已经上了，哪些还没有上。这个系统可以大大提高后厨到用户的效率。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4534313725490196&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqoWtdHmibk2ibtpqzdfibDdylu1Ke7qClwkEqT1kzibiabPSjQM88XkKrpqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;816&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实证明，这一切的关键是消息中间件：&lt;code&gt;kafka&lt;/code&gt;，如果它有问题，将会直接影响到后厨显示系统的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我跟大家一起聊聊使用&lt;code&gt;kafka&lt;/code&gt;两年时间踩过哪些坑？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;顺序问题&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 为什么要保证消息的顺序？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚开始我们系统的商户很少，为了快速实现功能，我们没想太多。既然是走消息中间件&lt;code&gt;kafka&lt;/code&gt;通信，订单系统发消息时将订单详细数据放在消息体，我们后厨显示系统只要订阅&lt;code&gt;topic&lt;/code&gt;，就能获取相关消息数据，然后处理自己的业务即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这套方案有个关键因素：&lt;strong&gt;要保证消息的顺序&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订单有很多状态，比如：下单、支付、完成、撤销等，不可能&lt;code&gt;下单&lt;/code&gt;的消息都没读取到，就先读取&lt;code&gt;支付&lt;/code&gt;或&lt;code&gt;撤销&lt;/code&gt;的消息吧，如果真的这样，数据不是会产生错乱？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好吧，看来保证消息顺序是有必要的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.如何保证消息顺序？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道&lt;code&gt;kafka&lt;/code&gt;的&lt;code&gt;topic&lt;/code&gt;是无序的，但是一个&lt;code&gt;topic&lt;/code&gt;包含多个&lt;code&gt;partition&lt;/code&gt;，每个&lt;code&gt;partition&lt;/code&gt;内部是有序的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5851851851851851&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqOzug1A48UnG15tonQ3wBkbB5yicVnHpydn5Hq2PwiawKTVj8Vk6DB7sQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如此一来，思路就变得清晰了：只要保证生产者写消息时，按照一定的规则写到同一个&lt;code&gt;partition&lt;/code&gt;，不同的消费者读不同的&lt;code&gt;partition&lt;/code&gt;的消息，就能保证生产和消费者消息的顺序。&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们刚开始就是这么做的，同一个&lt;code&gt;商户编号&lt;/code&gt;的消息写到同一个&lt;code&gt;partition&lt;/code&gt;，&lt;code&gt;topic&lt;/code&gt;中创建了&lt;code&gt;4&lt;/code&gt;个&lt;code&gt;partition&lt;/code&gt;，然后部署了&lt;code&gt;4&lt;/code&gt;个消费者节点，构成&lt;code&gt;消费者组&lt;/code&gt;，一个&lt;code&gt;partition&lt;/code&gt;对应一个消费者节点。从理论上说，这套方案是能够保证消息顺序的。&lt;img data-ratio=&quot;0.40813464235624125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqrza43TUBKePfwRPaSrtSJiclN6ibdof2qKwyhIfGoicR4Z6C2icQP5vWuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1426&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一切规划得看似“天衣无缝”，我们就这样”顺利“上线了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.出现意外&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该功能上线了一段时间，刚开始还是比较正常的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，好景不长，很快就收到用户投诉，说在划菜客户端有些订单和菜品一直看不到，无法划菜。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我定位到了原因，公司在那段时间网络经常不稳定，业务接口时不时报超时，业务请求时不时会连不上数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况对&lt;code&gt;顺序消息&lt;/code&gt;的打击，可以说是&lt;code&gt;毁灭性&lt;/code&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么这么说？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设订单系统发了：”下单“、”支付“、”完成“ 三条消息。&lt;img data-ratio=&quot;0.30303030303030304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqlNAGCa9TQnogCS0zxjEdib4ta0Upia4NZLxe9KibnLKu2buS1In7qT27Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;而”下单“消息由于网络原因我们系统处理失败了，而后面的两条消息的数据是无法入库的，因为只有”下单“消息的数据才是完整的数据，其他类型的消息只会更新状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加上，我们当时没有做&lt;code&gt;失败重试机制&lt;/code&gt;，使得这个问题被放大了。问题变成：一旦”下单“消息的数据入库失败，用户就永远看不到这个订单和菜品了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个紧急的问题要如何解决呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.解决过程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最开始我们的想法是：在消费者处理消息时，如果处理失败了，立马重试3-5次。但如果有些请求要第6次才能成功怎么办？不可能一直重试呀，这种同步重试机制，会阻塞其他商户订单消息的读取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然用上面的这种&lt;code&gt;同步重试机制&lt;/code&gt;在出现异常的情况，会严重影响消息消费者的消费速度，降低它的吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如此看来，我们不得不用&lt;code&gt;异步重试机制&lt;/code&gt;了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用异步重试机制，处理失败的消息就得保存到&lt;code&gt;重试表&lt;/code&gt;下来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有个新问题立马出现：&lt;strong&gt;只存一条消息如何保证顺序？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存一条消息的确无法保证顺序，假如：”下单“消息失败了，还没来得及异步重试。此时，”支付“消息被消费了，它肯定是不能被正常消费的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，”支付“消息该一直等着，每隔一段时间判断一次，它前面的消息都有没有被消费?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果真的这么做，会出现两个问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;”支付“消息前面只有”下单“消息，这种情况比较简单。但如果某种类型的消息，前面有N多种消息，需要判断多少次呀，这种判断跟订单系统的耦合性太强了，相当于要把他们系统的逻辑搬一部分到我们系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;影响消费者的消费速度&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时有种更简单的方案浮出水面：消费者在处理消息时，先判断该&lt;code&gt;订单号&lt;/code&gt;在&lt;code&gt;重试表&lt;/code&gt;有没有数据，如果有则直接把当前消息保存到&lt;code&gt;重试表&lt;/code&gt;。如果没有，则进行业务处理，如果出现异常，把该消息保存到&lt;code&gt;重试表&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来我们用&lt;code&gt;elastic-job&lt;/code&gt;建立了&lt;code&gt;失败重试机制&lt;/code&gt;，如果重试了&lt;code&gt;7&lt;/code&gt;次后还是失败，则将该消息的状态标记为&lt;code&gt;失败&lt;/code&gt;，发邮件通知开发人员。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;终于由于网络不稳定，导致用户在划菜客户端有些订单和菜品一直看不到的问题被解决了。现在商户顶多偶尔延迟看到菜品，比一直看不菜品好太多。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;消息积压&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着销售团队的市场推广，我们系统的商户越来越多。随之而来的是消息的数量越来越大，导致消费者处理不过来，经常出现消息积压的情况。对商户的影响非常直观，划菜客户端上的订单和菜品可能半个小时后才能看到。一两分钟还能忍，半个消息的延迟，对有些暴脾气的商户哪里忍得了，马上投诉过来了。我们那段时间经常接到商户投诉说订单和菜品有延迟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说，加&lt;code&gt;服务器节点&lt;/code&gt;就能解决问题，但是按照公司为了省钱的惯例，要先做系统优化，所以我们开始了&lt;code&gt;消息积压&lt;/code&gt;问题解决之旅。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 消息体过大&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说&lt;code&gt;kafka&lt;/code&gt;号称支持&lt;code&gt;百万级的TPS&lt;/code&gt;，但从&lt;code&gt;producer&lt;/code&gt;发送消息到&lt;code&gt;broker&lt;/code&gt;需要一次网络&lt;code&gt;IO&lt;/code&gt;，&lt;code&gt;broker&lt;/code&gt;写数据到磁盘需要一次磁盘&lt;code&gt;IO&lt;/code&gt;（写操作），&lt;code&gt;consumer&lt;/code&gt;从&lt;code&gt;broker&lt;/code&gt;获取消息先经过一次磁盘&lt;code&gt;IO&lt;/code&gt;（读操作），再经过一次网络&lt;code&gt;IO&lt;/code&gt;。&lt;img data-ratio=&quot;0.5047619047619047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlq0tlViaqySicoAnwRJmPPPqQgnd89BrW3YyiaQUqAx3uLPicVmwpoeSq1dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1050&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一次简单的消息从生产到消费过程，需要经过&lt;code&gt;2次网络IO&lt;/code&gt;和&lt;code&gt;2次磁盘IO&lt;/code&gt;。如果消息体过大，势必会增加IO的耗时，进而影响kafka生产和消费的速度。消费者速度太慢的结果，就会出现消息积压情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上面的问题之外，&lt;code&gt;消息体过大&lt;/code&gt;，还会浪费服务器的磁盘空间，稍不注意，可能会出现磁盘空间不足的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，我们已经到了需要优化消息体过大问题的时候。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何优化呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们重新梳理了一下业务，没有必要知道订单的&lt;code&gt;中间状态&lt;/code&gt;，只需知道一个&lt;code&gt;最终状态&lt;/code&gt;就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如此甚好，我们就可以这样设计了：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;订单系统发送的消息体只用包含：id和状态等关键信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后厨显示系统消费消息后，通过id调用订单系统的订单详情查询接口获取数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后厨显示系统判断数据库中是否有该订单的数据，如果没有则入库，有则更新。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46782178217821785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqib2hB0qSIXBPjxAH1vZQbn97tcMKQBmWBDL1Rc1ytjLXoXcCPic301pQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;808&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;果然这样调整之后，消息积压问题很长一段时间都没再出现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2. 路由规则不合理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还真别高兴的太早，有天中午又有商户投诉说订单和菜品有延迟。我们一查kafka的topic竟然又出现了消息积压。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这次有点诡异，不是所有&lt;code&gt;partition&lt;/code&gt;上的消息都有积压，而是只有一个。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.369620253164557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqdaENvsBRclJSZ2zvNoXxfpDS9IgJvpM6icibHB8Y32Jt4khMicw7wictmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1580&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚开始，我以为是消费那个&lt;code&gt;partition&lt;/code&gt;消息的节点出了什么问题导致的。但是经过排查，没有发现任何异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就奇怪了，到底哪里有问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来，我查日志和数据库发现，有几个商户的订单量特别大，刚好这几个商户被分到同一个&lt;code&gt;partition&lt;/code&gt;，使得该&lt;code&gt;partition&lt;/code&gt;的消息量比其他&lt;code&gt;partition&lt;/code&gt;要多很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时我们才意识到，发消息时按&lt;code&gt;商户编号&lt;/code&gt;路由&lt;code&gt;partition&lt;/code&gt;的规则不合理，可能会导致有些&lt;code&gt;partition&lt;/code&gt;消息太多，消费者处理不过来，而有些&lt;code&gt;partition&lt;/code&gt;却因为消息太少，消费者出现空闲的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免出现这种分配不均匀的情况，我们需要对发消息的路由规则做一下调整。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们思考了一下，用订单号做路由相对更均匀，不会出现单个订单发消息次数特别多的情况。除非是遇到某个人一直加菜的情况，但是加菜是需要花钱的，所以其实同一个订单的消息数量并不多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调整后按&lt;code&gt;订单号&lt;/code&gt;路由到不同的&lt;code&gt;partition&lt;/code&gt;，同一个订单号的消息，每次到发到同一个&lt;code&gt;partition&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3888888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqoJO69ia8Fv9p1uc0HEHaJcYg85VaBlsHm25ubexHCFmmicbVWsN6IACA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1548&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调整后，消息积压的问题又有很长一段时间都没有再出现。我们的商户数量在这段时间，增长的非常快，越来越多了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 批量操作引起的连锁反应&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的场景中，消息积压问题，可以说如影随形，真的没办法从根本上解决。表面上看，已经解决了，但后面不知道什么时候，就会冒出一次，比如这次：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有天下午，产品过来说：有几个商户投诉过来了，他们说菜品有延迟，快查一下原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次问题出现得有点奇怪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么这么说？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先这个时间点就有点奇怪，平常出问题，不都是中午或者晚上用餐高峰期吗？怎么这次问题出现在下午？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据以往积累的经验，我直接看了&lt;code&gt;kafka&lt;/code&gt;的&lt;code&gt;topic&lt;/code&gt;的数据，果然上面消息有积压，但这次每个&lt;code&gt;partition&lt;/code&gt;都积压了&lt;code&gt;十几万&lt;/code&gt;的消息没有消费，比以往加压的消息数量增加了&lt;code&gt;几百倍&lt;/code&gt;。这次消息积压得极不寻常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我赶紧查服务监控看看消费者挂了没，还好没挂。又查服务日志没有发现异常。这时我有点迷茫，碰运气问了问订单组下午发生了什么事情没？他们说下午有个促销活动，跑了一个JOB批量更新过有些商户的订单信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，我一下子如梦初醒，是他们在JOB中批量发消息导致的问题。怎么没有通知我们呢？实在太坑了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说知道问题的原因了，倒是眼前积压的这&lt;code&gt;十几万&lt;/code&gt;的消息该如何处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果直接调大&lt;code&gt;partition&lt;/code&gt;数量是不行的，历史消息已经存储到4个固定的&lt;code&gt;partition&lt;/code&gt;，只有新增的消息才会到新的&lt;code&gt;partition&lt;/code&gt;。我们重点需要处理的是已有的&lt;span&gt;partition&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接加服务节点也不行，因为&lt;code&gt;kafka&lt;/code&gt;允许同组的多个&lt;code&gt;partition&lt;/code&gt;被一个&lt;code&gt;consumer&lt;/code&gt;消费，但不允许一个&lt;code&gt;partition&lt;/code&gt;被同组的多个&lt;code&gt;consumer&lt;/code&gt;消费，可能会造成资源浪费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看来只有用多线程处理了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了紧急解决问题，我改成了用&lt;code&gt;线程池&lt;/code&gt;处理消息，核心线程和最大线程数都配置成了&lt;code&gt;50&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调整之后，果然，消息积压数量不断减少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但此时有个更严重的问题出现：我收到了报警邮件，有两个订单系统的节点down机了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不久，订单组的同事过来找我说，我们系统调用他们订单查询接口的并发量突增，超过了预计的好几倍，导致有2个服务节点挂了。他们把查询功能单独整成了一个服务，部署了6个节点，挂了2个节点，再不处理，另外4个节点也会挂。订单服务可以说是公司最核心的服务，它挂了公司损失会很大，情况万分紧急。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，只能先把线程数调小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸好，线程数是可以通过&lt;code&gt;zookeeper&lt;/code&gt;动态调整的，我把核心线程数调成了&lt;code&gt;8&lt;/code&gt;个，核心线程数改成了&lt;code&gt;10&lt;/code&gt;个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面，运维把订单服务挂的2个节点重启后恢复正常了，以防万一，再多加了2个节点。为了确保订单服务不会出现问题，就保持目前的消费速度，后厨显示系统的消息积压问题，1小时候后也恢复正常了。&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5266821345707656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHq22JkuhhbPicwggABFQWlqt9gnrBjrNqmrxqjJlghuZszz8ibdGic6KbthGAdYX8yqkSibxFlH1ibFeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;862&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来，我们开了一次复盘会，得出的结论是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;订单系统的批量操作一定提前通知下游系统团队。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下游系统团队多线程调用订单查询接口一定要做压测。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这次给订单查询服务敲响了警钟，它作为公司的核心服务，应对高并发场景做的不够好，需要做优化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对消息积压情况加监控。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;顺便说一下，对于要求严格保证消息顺序的场景，可以将线程池改成多个队列，每个队列用单线程处理。&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 表过大&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了防止后面再次出现消息积压问题，消费者后面就一直用多线程处理消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有天中午我们还是收到很多报警邮件，提醒我们kafka的topic消息有积压。我们正在查原因，此时产品跑过来说：又有商户投诉说菜品有延迟，赶紧看看。这次她看起来有些不耐烦，确实优化了很多次，还是出现了同样的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在外行看来：&lt;strong&gt;为什么同一个问题一直解决不了？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其实技术心里的苦他们是不知道的。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表面上问题的症状是一样的，都是出现了菜品延迟，他们知道的是因为消息积压导致的。但是他们不知道深层次的原因，导致消息积压的原因其实有很多种。这也许是使用消息中间件的通病吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我沉默不语，只能硬着头皮定位原因了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来我查日志发现消费者消费一条消息的耗时长达&lt;code&gt;2秒&lt;/code&gt;。以前是&lt;code&gt;500毫秒&lt;/code&gt;，现在怎么会变成&lt;code&gt;2秒&lt;/code&gt;呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;奇怪了，消费者的代码也没有做大的调整，为什么会出现这种情况呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查了一下线上菜品表，单表数据量竟然到了&lt;code&gt;几千万&lt;/code&gt;，其他的划菜表也是一样，现在单表保存的数据太多了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们组梳理了一下业务，其实菜品在客户端只展示最近&lt;code&gt;3天&lt;/code&gt;的即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就好办了，我们服务端存着&lt;code&gt;多余的数据&lt;/code&gt;，不如把表中多余的数据归档。于是，DBA帮我们把数据做了归档，只保留最近&lt;code&gt;7天&lt;/code&gt;的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如此调整后，消息积压问题被解决了，又恢复了往日的平静。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;主键冲突&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;别高兴得太早了，还有其他的问题，比如：报警邮件经常报出数据库异常：&lt;code&gt; Duplicate entry &#x27;6&#x27; for key &#x27;PRIMARY&#x27;&lt;/code&gt;，说主键冲突。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现这种问题一般是由于有两个以上相同主键的sql，同时插入数据，第一个插入成功后，第二个插入的时候会报主键冲突。表的主键是唯一的，不允许重复。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我仔细检查了代码，发现代码逻辑会先根据主键从表中查询订单是否存在，如果存在则更新状态，不存在才插入数据，没得问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种判断在并发量不大时，是有用的。但是如果在高并发的场景下，两个请求同一时刻都查到订单不存在，一个请求先插入数据，另一个请求再插入数据时就会出现主键冲突的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决这个问题最常规的做法是：&lt;code&gt;加锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我刚开始也是这样想的，加数据库悲观锁肯定是不行的，太影响性能。加数据库乐观锁，基于版本号判断，一般用于更新操作，像这种插入操作基本上不会用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;剩下的只能用分布式锁了，我们系统在用redis，可以加基于redis的分布式锁，锁定订单号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但后面仔细思考了一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加分布式锁也可能会影响消费者的消息处理速度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者依赖于redis，如果redis出现网络超时，我们的服务就悲剧了。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我也不打算用分布式锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而是选择使用mysql的&lt;code&gt;INSERT INTO ...ON DUPLICATE KEY UPDATE&lt;/code&gt;语法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; (column_list)&lt;br/&gt;&lt;span&gt;VALUES&lt;/span&gt; (value_list)&lt;br/&gt;&lt;span&gt;ON&lt;/span&gt; &lt;span&gt;DUPLICATE&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt;&lt;br/&gt;c1 = v1, &lt;br/&gt;c2 = v2,&lt;br/&gt;...;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它会先尝试把数据插入表，如果主键冲突的话那么更新字段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把以前的&lt;code&gt;insert&lt;/code&gt;语句改造之后，就没再出现过主键冲突问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据库主从延迟&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不久之后的某天，又收到商户投诉说下单后，在划菜客户端上看得到订单，但是看到的菜品不全，有时甚至订单和菜品数据都看不到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题跟以往的都不一样，根据以往的经验先看&lt;code&gt;kafka&lt;/code&gt;的&lt;code&gt;topic&lt;/code&gt;中消息有没有积压，但这次并没有积压。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再查了服务日志，发现订单系统接口返回的数据有些为空，有些只返回了订单数据，没返回菜品数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就非常奇怪了，我直接过去找订单组的同事。他们仔细排查服务，没有发现问题。这时我们不约而同的想到，会不会是数据库出问题了，一起去找&lt;code&gt;DBA&lt;/code&gt;。果然，&lt;code&gt;DBA&lt;/code&gt;发现数据库的主库同步数据到从库，由于网络原因偶尔有延迟，有时延迟有&lt;code&gt;3秒&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们的业务流程从发消息到消费消息耗时小于&lt;code&gt;3秒&lt;/code&gt;，调用订单详情查询接口时，可能会查不到数据，或者查到的不是最新的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题非常严重，会导致直接我们的数据错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，我们也加了&lt;code&gt;重试机制&lt;/code&gt;。调用接口查询数据时，如果返回数据为空，或者只返回了订单没有菜品，则加入&lt;code&gt;重试表&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调整后，商户投诉的问题被解决了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;重复消费&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;kafka&lt;/code&gt;消费消息时支持三种模式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;at most onece模式
最多一次。保证每一条消息commit成功之后，再进行消费处理。消息可能会丢失，但不会重复。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;at least onece模式
至少一次。保证每一条消息处理成功之后，再进行commit。消息不会丢失，但可能会重复。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;exactly onece模式
精确传递一次。将offset作为唯一id与消息同时处理，并且保证处理的原子性。消息只会处理一次，不丢失也不会重复。但这种方式很难做到。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;kafka&lt;/code&gt;默认的模式是&lt;code&gt;at least onece&lt;/code&gt;，但这种模式可能会产生重复消费的问题，所以我们的业务逻辑必须做幂等设计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们的业务场景保存数据时使用了&lt;code&gt;INSERT INTO ...ON DUPLICATE KEY UPDATE&lt;/code&gt;语法，不存在时插入，存在时更新，是天然支持幂等性的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;多环境消费问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们当时线上环境分为：&lt;code&gt;pre&lt;/code&gt;(预发布环境) 和 &lt;code&gt;prod&lt;/code&gt;(生产环境)，两个环境共用同一个数据库，并且共用同一个kafka集群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，在配置&lt;code&gt;kafka&lt;/code&gt;的&lt;code&gt;topic&lt;/code&gt;的时候，要加前缀用于区分不同环境。pre环境的以pre_开头，比如：pre_order，生产环境以prod_开头，比如：prod_order，防止消息在不同环境中串了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有次运维在&lt;code&gt;pre&lt;/code&gt;环境切换节点，配置&lt;code&gt;topic&lt;/code&gt;的时候，配错了，配成了&lt;code&gt;prod&lt;/code&gt;的&lt;code&gt;topic&lt;/code&gt;。刚好那天，我们有新功能上&lt;code&gt;pre&lt;/code&gt;环境。结果悲剧了，&lt;code&gt;prod&lt;/code&gt;的有些消息被&lt;code&gt;pre&lt;/code&gt;环境的&lt;code&gt;consumer&lt;/code&gt;消费了，而由于消息体做了调整，导致&lt;code&gt;pre&lt;/code&gt;环境的&lt;code&gt;consumer&lt;/code&gt;处理消息一直失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其结果是生产环境丢了部分消息。不过还好，最后生产环境消费者通过重置&lt;code&gt;offset&lt;/code&gt;，重新读取了那一部分消息解决了问题，没有造成太大损失。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;后记&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上述问题之外，我还遇到过：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;kafka&lt;/code&gt;的&lt;code&gt;consumer&lt;/code&gt;使用自动确认机制，导致&lt;code&gt;cpu使用率100%&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;kafka&lt;/code&gt;集群中的一个&lt;code&gt;broker&lt;/code&gt;节点挂了，重启后又一直挂。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个问题说起来有些复杂，我就不一一列举了，有兴趣的朋友可以关注我的公众号，加我的微信找我私聊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢那两年使用消息中间件&lt;code&gt;kafka&lt;/code&gt;的经历，虽说遇到过挺多问题，踩了很多坑，走了很多弯路，但是实打实的让我积累了很多宝贵的经验，快速成长了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实&lt;code&gt;kafka&lt;/code&gt;是一个非常优秀的消息中间件，我所遇到的绝大多数问题，都并非&lt;code&gt;kafka&lt;/code&gt;自身的问题（除了cpu使用率100%是它的一个bug导致的之外）。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;各位亲爱的朋友，我的文章一周才更新一到两篇。很有可能在你不经意间，就发文了，导致你错过精彩内容。在公众号中扩展右上角“&lt;/span&gt;&lt;span&gt;设为星标&lt;/span&gt;&lt;span&gt;”能第一时间看到我的好文章喔，纯干货分享，错过真的可惜。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;2.149090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFmRHPf6poYmQMHiapibW6zTsMBkVItGxCDERfT1kr913Z5mjS9OMpUrTlOMZZCiaSSiabvd79icMYeRxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8ddbb4f828549a7ee6f5b4adf681eafa</guid>
<title>牛年行牛运！加入「码农周刊VIP会员」，一起牛起来！</title>
<link>https://toutiao.io/k/g5nf15i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;322&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.318840579710145&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8pVYfXHFZnJw6GmED4PucZvQd6m3AP8fUG1IKJyBgicmJ3P5ygQjO5r6Bib2x190MFOlb6PwExNQuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d632fa9f2831201356ef5f56c592afd9</guid>
<title>从零开始写 KV 数据库：基于哈希索引</title>
<link>https://toutiao.io/k/h0zw3k5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;新的KV数据库层出不穷，我们经常听说的KV数据库如RocksDb、Hbase等都是基于日志结构的存储引擎。最近我在看《数据密集型应用系统设计》，里面有一章专门在讲日志结构的存储引擎的演进过程，纯看理论不过瘾，所以我决定根据书里的理论动手自己实现一个KV数据库。同时，为了能顺便学习Rust，所以我使用了Rust来实现数据库。&lt;/p&gt;&lt;p&gt;除了参考《数据密集型应用系统设计》，我还参考了《pingcap/talent-plan》中使用Rust实现KV数据库的源码，恰好它的实现就是基于哈希索引和日志压缩的原理，跟书中的描述不谋而合。通过实现一个迷你数据库来学习和理解数据库的原理是一种学以致用的方式，能够帮助我们更加深入理解数据库原理。闲话不多说，开始正文。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;最简单的数据库&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在上正菜之前先来一道甜点，你知道最简单的数据库只需要几行代码吗？只需要两行，一行读取，一行写入。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#!/bin/bash&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;db_set&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;span&gt;$1&lt;/span&gt;,&lt;span&gt;$2&lt;/span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; database&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;db_get&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        grep &lt;span&gt;&quot;^&lt;span&gt;$1&lt;/span&gt;,&quot;&lt;/span&gt; database | sed -e &lt;span&gt;&quot;s/^&lt;span&gt;$1&lt;/span&gt;,//&quot;&lt;/span&gt; | tail -n 1&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以尝试保存脚本，然后在shell中试一下。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;➜  ~ &lt;span&gt;source&lt;/span&gt; db.sh&lt;br/&gt;➜  ~ db_set key1 value1&lt;br/&gt;➜  ~ db_set key2 value2&lt;br/&gt;➜  ~ db_set key1 value1&lt;br/&gt;➜  ~ db_set key1 value2&lt;br/&gt;➜  ~ db_get key1&lt;br/&gt;value2&lt;br/&gt;➜  ~ cat database&lt;br/&gt;key1,value1&lt;br/&gt;key2,value2&lt;br/&gt;key1,value1&lt;br/&gt;key1,value2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;是不是很神奇，其实原理很简单，set的操作是将数据追加到文件末尾，get的操作是先grep找到所有key的数据，然后再取最后一条数据（tail -n 1）作为结果。仔细思考一下，这个数据库逻辑是正确的，而且还是持久化的。&lt;/p&gt;&lt;p&gt;这个数据库原理虽然简单，但是其中set使用日志追加的方式写入数据却是很多数据库的常用方式，因为日志追加性能非常好。相对的，get的方式性能就比较差了，需要从头到尾扫描整个文件，查询的开销是O(n)。&lt;/p&gt;&lt;p&gt;为了提高读取的性能，我们需要用到索引，基本的思路就是通过保存额外的元数据，根据这些元数据作为路标来快速定位到想要的数据。但是天下没有免费的午餐，维护索引需要在写入的时候额外写入其他数据，这会影响写入的性能。这里就涉及到存储系统中重要的权衡设计：&lt;strong&gt;适当的索引可以加速读取，但是每个索引都会减慢写入的速度。&lt;/strong&gt;下面我们就给我们简单的数据库加上最简单的索引方式：哈希索引。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;基于哈希索引的数据库&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;回想一下我们经常使用HashMap数据结构，哈希索引就是基于内存的HashMap来实现的，不同的是我们在内存里面使用HashMap的时候value都是直接存储原始数据的，对于数据库来说，如果你把所有的原始数据都直接存储到内存的话，这是不现实的。那怎么办呢？想想我们在编程里面常用的指针，是不是得到启发了？我们可以在内存里面保存原始数据的“指针”，即文件的字节偏移量和数据的长度。指针的占用量很小，这样我们完全可以把整个数据库的key的索引都放到内存里面，读取的时候直接找到key在文件中的偏移量，直接去磁盘读取数据。&lt;/p&gt;&lt;p&gt;借用书中的图示&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4684385382059801&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ph2O4rDx4Lg6icSR9MvXSuPaxgt6CdQ1ibrTJCTonTWLPHyk36XuE1cyIhlAmOHwRJlTID8REibR7GibcvpfAaZsug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1204&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;-w602&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这个哈希索引的原理听起来很简单，但是这可是在生产中被实际使用过的Bitcask数据库的核心原理。只要保证所有key都能放到内存里面，Bitcask就能提供高性能的读写，因为它的索引结构简单，写入也是内存操作，可以说索引的代价可以忽略不计，而读取只需要一次内存寻址，在有文件系统缓存时甚至不需要IO操作。在某些场景中这个数据库可以完爆其他所有数据库。&lt;/p&gt;&lt;p&gt;了解了基本原理之后，下面开始实操环节。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;数据命令&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;首先定义一下我们数据库的基本功能：&lt;/p&gt;&lt;p&gt;如果基于日志追加来做，我们的存储结构要怎么设计呢？肯定不能按照前面的简单数据库那样搞，因为光把数据存进去不能支持删除数据的功能。回想一下MySQL的RedoLog，我们可以得到一些启发。如果我们不记录原始数据，而是记录数据命令呢？例如，我们按照下面的格式来记录数据。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;set: key1,value1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;set: key2,value2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;set: key1,value1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;rm: key1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为写入的操作只有两个：set和rm，所以我们可以定义两个数据命令，每次都把这些数据命令记录到日志里面，这样读取的时候读取到的就是数据命令，假设我们现在读取key2，实际上从磁盘读取到的数据是：&lt;code&gt;set: key2,value2&lt;/code&gt;，这样我们就知道key2现在的最新值是value2，当读取key1的时候，从磁盘读取到的数据是&lt;code&gt;rm: key1&lt;/code&gt;，那么意味着key1已经被删除了。&lt;/p&gt;&lt;p&gt;在Rust中数据命令的定义如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;pub &lt;span&gt;enum&lt;/span&gt; Command {&lt;br/&gt;    &lt;span&gt;Set&lt;/span&gt; { key: &lt;span&gt;String&lt;/span&gt;, value: &lt;span&gt;String&lt;/span&gt; },&lt;br/&gt;    Remove { key: &lt;span&gt;String&lt;/span&gt; },&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;数据写入&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;接下来定义我们的数据库对象，成员变量只有三个，一个读取器、一个写入器、一个索引。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;pub&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;KvStore&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;reader&lt;/span&gt;: BufReaderWithPos&amp;lt;File&amp;gt;,&lt;br/&gt;    writer: BufWriterWithPos&amp;lt;File&amp;gt;,&lt;br/&gt;    index: HashMap&amp;lt;String, CommandPos&amp;gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;CommandPos&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;pos&lt;/span&gt;: u64,&lt;br/&gt;    len: u64,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么写入操作具体要做什么呢？看一下的代码注释&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    pub fn set(&amp;amp;mut &lt;span&gt;self&lt;/span&gt;, key: String, value: String) -&amp;gt; Result&amp;lt;()&amp;gt; {&lt;br/&gt;        &lt;span&gt;//构造一个写入命令&lt;/span&gt;&lt;br/&gt;        let cmd = Command::set(key, value);&lt;br/&gt;        &lt;span&gt;//获取当前写入句柄的位置&lt;/span&gt;&lt;br/&gt;        let pos = &lt;span&gt;self&lt;/span&gt;.writer.pos;&lt;br/&gt;        &lt;span&gt;//通过serde把set命令序列化成json写入到文件中&lt;/span&gt;&lt;br/&gt;        serde_json::to_writer(&amp;amp;mut &lt;span&gt;self&lt;/span&gt;.writer, &amp;amp;cmd)?;&lt;br/&gt;        &lt;span&gt;//文件刷盘持久化&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;self&lt;/span&gt;.writer.flush()?;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; let Command::Set { key, .. } = cmd {&lt;br/&gt;        &lt;span&gt;//记录写入命令的开始位置和长度&lt;/span&gt;&lt;br/&gt;            let cmd_pos = CommandPos { pos, len: &lt;span&gt;self&lt;/span&gt;.writer.pos - pos };&lt;br/&gt;            &lt;span&gt;//把当前key的最新命令位置记录到索引里面&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;self&lt;/span&gt;.index.insert(key, cmd_pos);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        Ok(())&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除操作也是类似的：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    pub fn remove(&amp;amp;mut &lt;span&gt;self&lt;/span&gt;, key: String) -&amp;gt; Result&amp;lt;()&amp;gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;self&lt;/span&gt;.index.contains_key(&amp;amp;key) {&lt;br/&gt;            &lt;span&gt;//构造删除命令&lt;/span&gt;&lt;br/&gt;            let cmd = Command::remove(key);&lt;br/&gt;            &lt;span&gt;//写入到文件&lt;/span&gt;&lt;br/&gt;            serde_json::to_writer(&amp;amp;mut &lt;span&gt;self&lt;/span&gt;.writer, &amp;amp;cmd)?;&lt;br/&gt;            &lt;span&gt;self&lt;/span&gt;.writer.flush()?;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; let Command::Remove { key } = cmd {&lt;br/&gt;                &lt;span&gt;//从索引中删除key，这样就读取不到了。&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;self&lt;/span&gt;.index.remove(&amp;amp;key).expect(&lt;span&gt;&quot;key not found&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            Ok(())&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            Err(KvsError::KeyNotFound)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;数据读取&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;数据读取主要是从索引里面获取命令位置，然后从磁盘读取命令返回结果。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    pub fn get(&amp;amp;mut &lt;span&gt;self&lt;/span&gt;, &lt;span&gt;key:&lt;/span&gt; String) -&amp;gt; Result&amp;lt;Option&amp;lt;String&lt;span&gt;&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//&lt;/span&gt;从索引中读取key的命令位置，如果读取不到说明key不存在&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; let Some(cmd_pos) = &lt;span&gt;self&lt;/span&gt;.index.get(&amp;amp;key) {&lt;br/&gt;            let reader = &amp;amp;mut &lt;span&gt;self&lt;/span&gt;.reader;&lt;br/&gt;            &lt;span&gt;//&lt;/span&gt;把读取器游标设置到命令的起始位置&lt;br/&gt;            reader.seek(SeekFrom::Start(cmd_pos.pos))?;&lt;br/&gt;            &lt;span&gt;//&lt;/span&gt;指定读取的长度&lt;br/&gt;            let cmd_reader = reader.take(cmd_pos.len);&lt;br/&gt;            &lt;span&gt;//&lt;/span&gt;读取命令&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; let Command::Set {value, ..} = serde_json::from_reader(cmd_reader)? {&lt;br/&gt;                Ok(Some(value))&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                Err(KvsError::UnexpectedCommandType)&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            Ok(None)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;数据加载&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;数据库每次启动都需要从文件中命令回放一遍，然后构建出内存索引才能开始使用。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;fn load(reader: &amp;amp;mut BufReaderWithPos&amp;lt;File&amp;gt;, index: &amp;amp;mut HashMap&amp;lt;String, CommandPos&amp;gt;) -&amp;gt; Result&amp;lt;()&amp;gt; {&lt;br/&gt;    &lt;span&gt;//设置文件游标到0，从开始遍历到文件末尾&lt;/span&gt;&lt;br/&gt;    let mut pos = reader.seek(SeekFrom::Start(&lt;span&gt;0&lt;/span&gt;))?;&lt;br/&gt;    let mut stream = Deserializer::from_reader(reader).into_iter::&amp;lt;Command&amp;gt;();&lt;br/&gt;    &lt;span&gt;//遍历命令&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; let Some(cmd) = stream.next() {&lt;br/&gt;        let new_pos = stream.byte_offset() &lt;span&gt;as&lt;/span&gt; u64;&lt;br/&gt;        match cmd? {&lt;br/&gt;            &lt;span&gt;//如果是set命令就插入到索引中&lt;/span&gt;&lt;br/&gt;            Command::Set {key, ..} =&amp;gt; {&lt;br/&gt;                index.insert(key, CommandPos{pos, len: new_pos - pos});&lt;br/&gt;            },&lt;br/&gt;            &lt;span&gt;//如果是rm命令就从索引中删除key&lt;/span&gt;&lt;br/&gt;            Command::Remove {key} =&amp;gt; {&lt;br/&gt;                index.remove(&amp;amp;key);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        pos = new_pos;&lt;br/&gt;    }&lt;br/&gt;    Ok(())&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至此，一个简单的基于哈希索引的数据库就完成了。完整代码可以参考：log_base&lt;/p&gt;&lt;h3&gt;&lt;span&gt;日志文件压缩&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;上面我们实现的数据库有一个明细的缺陷：如果使用时间很长的情况下，日志文件会非常大，可能把磁盘用光了。所以要想办法对日志文件进行压缩，可以发现对于相同的key在日志文件中会重复保存，而且实际上我们只会使用最新的命令。这部分没用的命令是可以删除掉的。因此，一个简单的日志压缩方式就是把重复的key删除掉只保留每个key最近的更新。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5247524752475248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ph2O4rDx4Lg6icSR9MvXSuPaxgt6CdQ1ib1ibvtAu9dM0Uv25icHgywvfRa9DPn7NG9PtaYm6hMuYU5yUU7HSndPPw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1212&quot; title=&quot;-w606&quot;/&gt;&lt;figcaption&gt;-w606&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;压缩日志文件实现会比较复杂，核心思路就是要将日志进行分段处理，当日志大小超过某个阈值时，新建一个日志用于写入，然后再新建一个日志将之前的全部日志遍历一遍进行压缩，最后将原始日志删除。&lt;br/&gt;由于加入了分段日志的设计，所以现在要寻找一个key在磁盘的位置，需要增加一个维度：日志文件的序号。即命令位置的数据结构需要新增一个gen字段用于标识文件的序号。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;CommandPos&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;gen&lt;/span&gt;: u64,&lt;br/&gt;    pos: u64,&lt;br/&gt;    len: u64,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数据库的成员对象也需要修改，具体见注释。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;pub &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;KvStore&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//记录日志文件的目录&lt;/span&gt;&lt;br/&gt;    path: PathBuf,&lt;br/&gt;    &lt;span&gt;//从单个读取器修改为多个日志读取器的集合，key是日志文件的序号&lt;/span&gt;&lt;br/&gt;    readers: HashMap&amp;lt;u64, BufReaderWithPos&amp;lt;File&amp;gt;&amp;gt;,&lt;br/&gt;    writer: BufWriterWithPos&amp;lt;File&amp;gt;,&lt;br/&gt;    index: HashMap&amp;lt;String, CommandPos&amp;gt;,&lt;br/&gt;    &lt;span&gt;//记录当前写入的文件序号，压缩时写入的文件序号会自增切换到新的文件上&lt;/span&gt;&lt;br/&gt;    current_gen: u64,&lt;br/&gt;    &lt;span&gt;//记录当前未压缩的命令大小&lt;/span&gt;&lt;br/&gt;    uncompacted: u64,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;压缩日志的代码实现如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    pub fn compact(&amp;amp;mut &lt;span&gt;self&lt;/span&gt;) -&amp;gt; Result&amp;lt;()&amp;gt; {&lt;br/&gt;        &lt;span&gt;//新增一个压缩日志序号，为当前序号+1&lt;/span&gt;&lt;br/&gt;        let compaction_gen = &lt;span&gt;self&lt;/span&gt;.current_gen + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//当前写入的日志序号+2，作为新的日志写入序号&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;self&lt;/span&gt;.current_gen += &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;self&lt;/span&gt;.writer = &lt;span&gt;self&lt;/span&gt;.new_log_file(&lt;span&gt;self&lt;/span&gt;.current_gen)?;&lt;br/&gt;&lt;br/&gt;        let mut new_pos = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//根据压缩日志序号创建一个写入器&lt;/span&gt;&lt;br/&gt;        let mut compaction_writer = &lt;span&gt;self&lt;/span&gt;.new_log_file(compaction_gen)?;&lt;br/&gt;        &lt;span&gt;//遍历当前索引的所有key&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; cmd_pos in &amp;amp;mut &lt;span&gt;self&lt;/span&gt;.index.values_mut() {&lt;br/&gt;            &lt;span&gt;//获取当前key的关联的文件读取器&lt;/span&gt;&lt;br/&gt;            let reader = &lt;span&gt;self&lt;/span&gt;.readers.get_mut(&amp;amp;cmd_pos.gen)&lt;br/&gt;                .expect(format!(&lt;span&gt;&quot;Can&#x27;t find reader: {}&quot;&lt;/span&gt;, &amp;amp;cmd_pos.gen).as_str());&lt;br/&gt;            &lt;span&gt;//将读取器的游标切换到命令的起始位置&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; reader.pos != cmd_pos.pos {&lt;br/&gt;                reader.seek(SeekFrom::Start(cmd_pos.pos))?;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//设置读取器读取的数据长度&lt;/span&gt;&lt;br/&gt;            let mut cmd_reader = reader.take(cmd_pos.len);&lt;br/&gt;            &lt;span&gt;//把命令拷贝到压缩日志写入器中&lt;/span&gt;&lt;br/&gt;            let len = io::copy(&amp;amp;mut cmd_reader, &amp;amp;mut compaction_writer)?;&lt;br/&gt;            &lt;span&gt;//更新索引中key的命令位置数据&lt;/span&gt;&lt;br/&gt;            *cmd_pos = CommandPos {gen: compaction_gen, pos: new_pos, len };&lt;br/&gt;            new_pos += len;&lt;br/&gt;        }&lt;br/&gt;        compaction_writer.flush()?;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//因为日志序号是从小到大增长的，要删除之前的日志只需要把小于压缩日志序号的文件都删除掉就行&lt;/span&gt;&lt;br/&gt;        let stale_gens: Vec&amp;lt;_&amp;gt; = &lt;span&gt;self&lt;/span&gt;.readers.keys()&lt;br/&gt;            .filter(|&amp;amp;&amp;amp;gen| gen &amp;lt; compaction_gen)&lt;br/&gt;            .cloned().collect();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; stale_gen in stale_gens {&lt;br/&gt;            &lt;span&gt;self&lt;/span&gt;.readers.remove(&amp;amp;stale_gen);&lt;br/&gt;            fs::remove_file(log_path(&amp;amp;&lt;span&gt;self&lt;/span&gt;.path, stale_gen))?;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;self&lt;/span&gt;.uncompacted = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        Ok(())&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看代码可能不太好理解日志压缩的过程，下面我们举一个日志文件压缩的例子&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.537007874015748&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ph2O4rDx4Lg6icSR9MvXSuPaxgt6CdQ1ibULr0nZ06RIhbicF90Abc2shGRLYib5ibAhh28hk0bCLCch5jgtlqnctmQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1270&quot; title=&quot;-w635&quot;/&gt;&lt;figcaption&gt;-w635&lt;/figcaption&gt;&lt;/figure&gt;&lt;br/&gt;压缩过程中让当前写入切换到3.log，可以保证写入不受影响，同时新增一个2.log作为压缩日志进行拷贝，边拷贝边更新索引，可以保证读取不受影响，等压缩完成之后，把1.log删除，平滑切换到新的日志上面。&lt;p&gt;&lt;/p&gt;&lt;p&gt;完整的源码可以参考：log_compact，这里的实现为了简单起见没有按照书里面使用异步线程去做，是在set的时候判断未压缩的大小是否超过阈值进行同步压缩的，即会阻塞写入操作，这是一个可优化点，在后续的更新中会优化掉，但是日志压缩思路是一致的。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;哈希索引的优缺点&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;哈希索引使用顺序写入的日志来追加式地记录每一个命令，看起来非常浪费存储空间：为什么不是直接原地更新文件，用新数据覆盖老数据呢？实际上追加式的设计是非常优秀的，主要原因有以下几个：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;追加式主要使用顺序写入，性能非常高，比起覆盖式的随机写入要快得多。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;追加式的写入在处理并发和崩溃恢复时要简单得多，例如不需要担心在重写值时发生崩溃的情况，追加式写入时如果崩溃了，只需要丢弃文件末尾有问题的数据，而覆盖式更新崩溃，你都不知道哪些数据是脏数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;追加式的日志写入可以通过合并旧的日志文件解决碎片化的问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;说了优点之后，也要说一下缺点：&lt;/p&gt;&lt;h2&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;本文主要说明了基于哈希索引的KV数据库的实现原理，同时给出了代码实现。基于追加式日志写入的哈希索引非常简单高效，同时也有一定的局限性。哈希索引只是KV数据库的起步，后续我们还会看到解决哈希索引缺点的新索引结构（LSM-tree），这些索引设计的思想是很多先进KV数据库（如Hbase、Cassandra）的基石。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4dbc2361dc0b1e051662621fdbfdda30</guid>
<title>Java 代码生成</title>
<link>https://toutiao.io/k/afekh8c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;       在很多开源的后台管理系统当中都有代码生成的工具，帮助开发者完成通用代码的生成，比如生成 Controller、Service、Dao 和 XML 文件等，能够帮助开发者生成通用的CRUD 代码。还能帮助开发者生成统一的后台列表页面和表单页面，以方便开发者可以快速的完成自己业务的开发，而忽略那些重复而又繁琐的工作。其实在开发框架中也有一些简单的代码生成的工具，比如接下来要介绍的 mybatis-plus 提供的代码生成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;MyBatis-Plus 代码生成器的介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        引用 MyBatis-Plus 官网的说明，如下：&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;124&quot; data-source-title=&quot;https://mp.baomidou.com/guide/generator.html#使用教程&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%3Cp%3EAutoGenerator%26nbsp%3B%E6%98%AF%26nbsp%3BMyBatis-Plus%26nbsp%3B%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%8C%E9%80%9A%E8%BF%87%26nbsp%3BAutoGenerator%26nbsp%3B%E5%8F%AF%E4%BB%A5%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%26nbsp%3BEntity%E3%80%81Mapper%E3%80%81Mapper%26nbsp%3BXML%E3%80%81Service%E3%80%81Controller%26nbsp%3B%E7%AD%89%E5%90%84%E4%B8%AA%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%9E%81%E5%A4%A7%E7%9A%84%E6%8F%90%E5%8D%87%E4%BA%86%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E3%80%82%3C%2Fp%3E%22%2C%22digestLen%22%3A124%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22https%3A%2F%2Fmp.baomidou.com%2Fguide%2Fgenerator.html%23%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;https://mp.baomidou.com/guide/generator.html#使用教程&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;引入依赖&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        MyBatis-Plus 官网有较为详细的说明，不过对于刚开始接触的话完全可以通过拿来现成的代码使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        使用 SpringBoot 来测试一下 Mybatis-Plus 代码生成的功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        SpringBoot 项目中使用代码生成器需要引入一些依赖，依赖如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!-- MySql --&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!-- Lombok --&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!-- MyBatis-Plus --&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;version&amp;gt;3.0.5&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!-- 模板引擎 --&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;groupId&amp;gt;org.apache.velocity&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;artifactId&amp;gt;velocity-engine-core&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;version&amp;gt;2.0&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!-- Mybatis-Plus-Generator --&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;artifactId&amp;gt;mybatis-plus-generator&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;version&amp;gt;3.4.1&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;生成代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        引入上面的依赖以后，下面的代码其实进行简单的修改就可以完成自己的代码生成，非常的方便。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class CodeGenerator {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public static void main(String[] args) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 构建一个代码生成对象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        AutoGenerator mpg = new AutoGenerator();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 1. 全局配置&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        GlobalConfig gc = new GlobalConfig();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String separator = File.separator;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        gc.setOutputDir(&quot;/Users/xxx/Documents/demo/src/main/java&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        gc.setAuthor(&quot;码农UP2U&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        gc.setOpen(false);//打开目录&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        gc.setFileOverride(true);//是否覆盖&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        gc.setServiceName(&quot;%sService&quot;);//去Service的I前缀。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        gc.setIdType(IdType.ID_WORKER);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        gc.setDateType(DateType.ONLY_DATE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        gc.setSwagger2(false);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mpg.setGlobalConfig(gc);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        DataSourceConfig dsc = new DataSourceConfig();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        dsc.setUrl(&quot;jdbc:mysql://ip:port/data?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        dsc.setUsername(&quot;root&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        dsc.setPassword(&quot;password&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        dsc.setDbType(DbType.MYSQL);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mpg.setDataSource(dsc);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 包设置&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        PackageConfig pc = new PackageConfig();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        pc.setParent(&quot;com.example.demo&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        pc.setEntity(&quot;entity&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        pc.setMapper(&quot;mapper&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        pc.setController(&quot;controller&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mpg.setPackageInfo(pc);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 策略配置&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        StrategyConfig strategy = new StrategyConfig();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        strategy.setInclude(&quot;ums_member&quot;);//表名&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        strategy.setNaming(NamingStrategy.underline_to_camel);// 下划线转他驼峰&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        strategy.setColumnNaming(NamingStrategy.underline_to_camel);// 列 下划线转脱发&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        strategy.setEntityLombokModel(true);//lombok 开启&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        strategy.setLogicDeleteFieldName(&quot;deleted&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 自动填充&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TableFill gmtCreate = new TableFill(&quot;gmt_create&quot;, FieldFill.INSERT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TableFill gmtModify = new TableFill(&quot;gmt_modified&quot;, FieldFill.INSERT_UPDATE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ArrayList&amp;lt;TableFill&amp;gt; tableFills = new ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        tableFills.add(gmtCreate);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        tableFills.add(gmtModify);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        strategy.setTableFillList(tableFills);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // restcontroller&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        strategy.setRestControllerStyle(true);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        strategy.setControllerMappingHyphenStyle(true);// localhost:xxx/hello_2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mpg.setStrategy(strategy);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mpg.execute();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        上面的代码中，设置生成文件的路径，设置数据库的连接，设置包名，设置表相关的内容等。代码简单的易懂，就不做过多说明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;生成结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        运行上面的代码，来看一下生成的内容，如下图：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.4091903719912473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Bfv9smoHwtg7ogHsQn3lMCxeFeQAiaTOJYT6magWkNasKS9Sa6ywJ4GlPUtsBuE2icNWeVbgQyMCkZzYpkbiawZiaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;914&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       从图中可以看出，生成的内容有 controller、entity、dao 和 service。基本上省去了我们一些手动需要完成的工作，还是比较方便的。代码有一些部分是通用的，一部分是可能是自定义的，可以将整个代码进行封装，使得使用更加的方便的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JHWsQdz8yVn3MVh22hia7NFoPyNJz4ZI7XUnMa9xM50TJRqPkWf7BRibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;鼓励我一下吧&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>88921ce333fb61031946619f7b9f5f49</guid>
<title>使用 VuePress 搭建一个自己的知识文档</title>
<link>https://toutiao.io/k/makr7pc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近准备对前端知识做一个梳理，将自己的平时遇到的问题和解决方案形成一个知识文档。本文记录了搭建 VuePress 的主要过程，同时也提供了部分自定义的配置，示例地址：http://doc.i-fanr.com&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;环境搭建&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VuePress 有着比较完善的中文文档，我们可以直接参照文档搭建，首先确保电脑上已经安装了 Node.js 并且版本号不小于 8.6&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 检查 Node.js 版本号&lt;/span&gt;&lt;br/&gt;node -v&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建立一个文件夹用来搭建 VuePress, 例如我的 VuePress 搭建在 spacexcode目录 下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mkdir spacexcode &amp;amp;&amp;amp; &lt;span&gt;cd&lt;/span&gt; spacexcode&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将 VuePress 安装为本地依赖&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;yarn add -D vuepress &lt;span&gt;# npm install -D vuepress&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建你的第一篇文档&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mkdir docs &amp;amp;&amp;amp; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&#x27;# Hello VuePress&#x27;&lt;/span&gt; &amp;gt; docs/README.md&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;package.json&lt;/code&gt; 中添加一些 scripts&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;scripts&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;docs:dev&quot;&lt;/span&gt;: &lt;span&gt;&quot;vuepress dev docs&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;docs:build&quot;&lt;/span&gt;: &lt;span&gt;&quot;vuepress build docs&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本地启动服务器&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;yarn docs:dev &lt;span&gt;# npm run docs:dev&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;添加主题&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;环境添加完毕后接下来就是装修完善了，VuePress 的原始样式更适合制作文档，因此我们需要自定义样式。VuePress 提供了自定义主题与样式的方法，为了简单我们可以直接使用别人制作好的博客主题 这里推荐一个我正在使用的主题 vuepress-theme-reco 主题的使用方法文档中已经介绍的很详细了，这里分享几个我自己的自定义设置&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;修改页面样式&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原始主题的页面内容宽度最大值是固定的，在我的大屏幕上显得有些窄了，因此我将文本宽度改为了页面宽度的 50%，这个设置与 Hexo 的设置一致，每个人可以根据自己的爱好修改。在 &lt;code&gt;.vuepress/styles/palette.styl&lt;/code&gt; 文件中添加如下样式&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 首页内容宽度更改为页面的 75%&lt;br/&gt;.home-blog&lt;br/&gt;  .home-blog-wrapper&lt;br/&gt;    width :75%&lt;br/&gt;    &lt;br/&gt; // 文章页内容宽度更改为页面的 50%  &lt;br/&gt;.page&lt;br/&gt;  .page-title&lt;br/&gt;    max-width :50%&lt;br/&gt;  .content__default:not(.custom)&lt;br/&gt;    max-width :50%&lt;br/&gt;  .page-nav&lt;br/&gt;    max-width :50%&lt;br/&gt;    &lt;br/&gt;.comments-wrapper&lt;br/&gt;  max-width :50% !important&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;添加插件&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装插件，以  &lt;code&gt;vuepress-plugin-image&lt;/code&gt;插件为例&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;yarn add vuepress-plugin-image&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在 &lt;code&gt;config.js&lt;/code&gt; 中添加插件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;plugins: [&lt;br/&gt;    &lt;span&gt;&#x27;@vuepress/plugin-back-to-top&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&#x27;@vuepress/plugin-medium-zoom&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&#x27;image&#x27;&lt;/span&gt;&lt;br/&gt;  ]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;添加主题中未包含的插件，这里介绍几个我使用的插件 vuepress-plugin-viewer 一个图片查看插件 vuepress-plugin-pangu 自动在文章中英文与汉字之间添加空格 vuepress-plugin-tabs 增加一个带有 tab 标签的容器 vuepress-plugin-click 鼠标点击时增加特殊效果 vuepress-plugin-demo-block 添加 H5 代码预览区块&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;部署&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;博客搭建完成后需要部署，我们可以创建一个 shell 文件来打包部署，我的部署到 github.io 下面，这是我的 shell 文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#!/usr/bin/env sh&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 确保脚本抛出遇到的错误&lt;/span&gt;&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; -e&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 生成静态文件&lt;/span&gt;&lt;br/&gt;yarn docs:build&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 进入生成的文件夹&lt;/span&gt;&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; docs/.vuepress/dist&lt;br/&gt;&lt;br/&gt;git init&lt;br/&gt;git add -A&lt;br/&gt;git commit -m &lt;span&gt;&#x27;deploy&#x27;&lt;/span&gt;&lt;br/&gt;git push -f git@github.com:fantingsheng/spacexcode.git master&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;paragraph&quot; data-id=&quot;91339&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;太空编程&lt;/section&gt;&lt;section&gt;&lt;span&gt;分享硬核的编程知识&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p hm_fix=&quot;381:638&quot;&gt;分享精彩，码上快乐。JavaScript已然上天，有朝一日实现太空编程！回复【pdf】更有海量的优质电子书供下载。&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;spacexcode&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-width=&quot;30%&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wokNJRf0ytoLg5ROjicaSQF89aicueIjhOntQxHtpLxO0ftbJHush4Rw6OHzpeBbCM0XqPphO7vdtMJ9fHgclGtA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;860&quot; data-width=&quot;100%&quot; title=&quot;qrcode_for_gh_7a080facd6b5_860.jpg&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>