<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5e11f40f1892f803d0f567aa7fd13350</guid>
<title>JVM 进阶之路（十二）：字节码指令</title>
<link>https://toutiao.io/k/l9yirih</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面的  &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247485367&amp;amp;idx=1&amp;amp;sn=2d8693335a5d78efe0fbeaa10afa8208&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;【JVM进阶之路】三：探究虚拟机对象&lt;/a&gt; 里，提到了对象的初始化过程，对象初始化用的是&lt;code&gt;new&lt;/code&gt;指令——这就是字节码指令。在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247485787&amp;amp;idx=1&amp;amp;sn=88755336f545c7e0abcddb98b3a58426&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;【JVM进阶之路】十一：Class文件结构&lt;/a&gt; 中已经学习了JVM 字节码是JVM能直接识别的语言，了解了字节码文件的文件结构。接下来，我们进一步学习字节码的相关指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来看一个简单的程序：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; x=&lt;span&gt;3&lt;/span&gt;,y=&lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; r=x+y;&lt;br/&gt;        System.out.println(x+y);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译运行，使用JDK自带的&lt;code&gt;javap&lt;/code&gt;查看字节码：&lt;code&gt;javap -c -s -v -l Main.class&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来找找相加指令在哪里：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8492688413948256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdQYTiaX97YXrNVK8xKpwNGVQug9Ce1Ejrmj0fKpYnFPJn6xGaK64SaewAq9x8FRUSaPA71HarjspA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;889&quot;/&gt;&lt;figcaption&gt;image-20210515165355248&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表 float，d代表double，a代表reference。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为Java虚拟机的操作码长度只有一字节，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力：如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那么 指令的数量恐怕就会超出一字节所能表示的数量范围了。因此Java字节码指令支持的数据类型的坑位有限，不被支持的智能改头换面用支持的字节码指令来处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM主要支持byte、short、int、long、float、double、char、reference集中数据类型，每种数据类型的操作码分别以不同的字母开头，例如&lt;code&gt;iadd&lt;/code&gt;表示int类型的相加指令码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1063218390804597&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdQYTiaX97YXrNVK8xKpwNGVEwCQj6QDribwzVHcjiazbVWzUlIARlPRN3mXaXe9rO8J2euVslqJ2JBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;figcaption&gt;操作码帮助记忆&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们看看不同类型的字节码指令。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、加载和存储指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载（load）和存储（store）指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0712166172106825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdQYTiaX97YXrNVK8xKpwNGVT0HyHz4gXUuHVVicyENu8cK2q8ic7WHlGCKMzrNVwKGVKmNOAeRvLv1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;337&quot;/&gt;&lt;figcaption&gt;加载和存储&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类的主要指令有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将一个局部变量加载到操作栈：iload、iload_&amp;lt;n&amp;gt;、lload、lload_&amp;lt;n&amp;gt;、fload、fload_、dload、 dload_、aload、aload_&amp;lt;n&amp;gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将一个数值从操作数栈存储到局部变量表：istore、istore_&amp;lt;n&amp;gt;、lstore、lstore_&amp;lt;n&amp;gt;、fstore、 fstore_、dstore、dstore_&amp;lt;n&amp;gt;、astore、astore_&amp;lt;n&amp;gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、 iconst_&amp;lt;i&amp;gt;、lconst_&amp;lt;l&amp;gt;、fconst_&amp;lt;f&amp;gt;、dconst_&amp;lt;d&amp;gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;扩充局部变量表的访问索引的指令：wide&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作，除此之外，还有少量指令， 如访问对象的字段或数组元素的指令也会向操作数栈传输数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;iload_这一类以尖括号结尾的指令，实际上代表了一组指令，例如iload_，它可能代表了iload_0、iload_1、iload_2和iload_3这几条指令，这几条指令表示把第1、2、3个局部变量加载进操作数栈。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、运算指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。大体上运算指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有的算术指令包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;加法指令：iadd、ladd、fadd、dadd&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;减法指令：isub、lsub、fsub、dsub&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;乘法指令：imul、lmul、fmul、dmul&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;除法指令：idiv、ldiv、fdiv、ddiv 这类的主要指令有：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;求余指令：irem、lrem、frem、drem&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;取反指令：ineg、lneg、fneg、dneg&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;位移指令：ishl、ishr、iushr、lshl、lshr、lushr&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;按位或指令：ior、lor&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;按位与指令：iand、land&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;按位异或指令：ixor、lxor&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;局部变量自增指令：iinc&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、类型转换指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型转换指令可以将两种不同的数值类型相互转换，这些转换操作有两个作用：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型转换指令主要分为两种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）宽化，小类型向大类型转换，比如 &lt;code&gt;int–&amp;gt;long–&amp;gt;float–&amp;gt;double&lt;/code&gt;，对应的指令有：i2l、i2f、i2d、l2f、l2d、f2d。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从 int 到 long，或者从 int 到 double，是不会有精度丢失的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 int、long 到 float，或者 long 到 double 时，可能会发生精度丢失；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 byte、char 和 short 到 int 的宽化类型转换实际上是隐式发生的，这样可以减少字节码指令，毕竟字节码指令只有 256 个，占一个字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）窄化，大类型向小类型转换，比如从 int 类型到 byte、short 或者 char，对应的指令有：i2b、i2s、i2c；从 long 到 int，对应的指令有：l2i；从 float 到 int 或者 long，对应的指令有：f2i、f2l；从 double 到 int、long 或者  float，对应的指令有：d2i、d2l、d2f。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;窄化很可能会发生精度丢失，毕竟是不同的数量级；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;但 Java 虚拟机并不会因此抛出运行时异常。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、对象创建与访问指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面我们已经接触过了对象创建的指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ava虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建类实例的指令：new&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建数组的指令：newarray、anewarray、multianewarray&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、 daload、aaload&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、 dastore、aastore&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;取数组长度的指令：arraylength&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;检查类实例类型的指令：instanceof、checkcast&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、操作数栈管理指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将操作数栈的栈顶一个或两个元素出栈：pop、pop2&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将栈最顶端的两个数值互换：swap&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5、控制转移指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制转移指令包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、 if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;复合条件分支：tableswitch、lookupswitch&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;无条件分支：goto、goto_w、jsr、jsr_w、ret&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作，为了可以无须明显标识一个数据的值是否null，也有专门的指令用来检测null值。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6、方法调用和返回指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法调用在后面会学到，我们这里只是了解一下方法调用的一些指令：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）， 这也是Java语言中最常见的方法分派方式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;invokestatic指令：用于调用类静态方法（static方法）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑 是由用户所设定的引导方法决定的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7、异常处理指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛出异常的情况之外，《Java虚拟机规范》还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如当除数为零时，虚拟机会在idiv或ldiv指令中抛出 ArithmeticException异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和ret指令来实现，现在已经不用了），而是采用异常表来完成。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8、同步指令&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3416252072968491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdQYTiaX97YXrNVK8xKpwNGVHboccjzK4X0fKgdNwUEdMKRAv7icViaLgG2sHNFeVz2kqTB0Ao1Lvrlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;603&quot;/&gt;&lt;figcaption&gt;同步指令&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如一段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;onlyMe&lt;/span&gt;&lt;span&gt;(String f)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (f) {&lt;br/&gt;            System.out.println(f);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译后查看字节码指令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;         &lt;span&gt;0&lt;/span&gt;: aload_1                          &lt;br/&gt;         &lt;span&gt;1&lt;/span&gt;: dup                              &lt;br/&gt;         &lt;span&gt;2&lt;/span&gt;: astore_2                         &lt;br/&gt;         &lt;span&gt;3&lt;/span&gt;: monitorenter                     &lt;span&gt;// 以栈顶元素作为锁，开始同步&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;4&lt;/span&gt;: getstatic     #&lt;span&gt;2&lt;/span&gt;                 &lt;br/&gt;         &lt;span&gt;7&lt;/span&gt;: aload_1                          &lt;br/&gt;         &lt;span&gt;8&lt;/span&gt;: invokevirtual #&lt;span&gt;3&lt;/span&gt;                 &lt;br/&gt;        &lt;span&gt;11&lt;/span&gt;: aload_2&lt;br/&gt;        &lt;span&gt;12&lt;/span&gt;: monitorexit                     &lt;span&gt;// 退出同步&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;13&lt;/span&gt;: goto          &lt;span&gt;21&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;16&lt;/span&gt;: astore_3&lt;br/&gt;        &lt;span&gt;17&lt;/span&gt;: aload_2&lt;br/&gt;        &lt;span&gt;18&lt;/span&gt;: monitorexit&lt;br/&gt;        &lt;span&gt;19&lt;/span&gt;: aload_3&lt;br/&gt;        &lt;span&gt;20&lt;/span&gt;: athrow&lt;br/&gt;        &lt;span&gt;21&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【1】：《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【2】：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxNzQwNjM3NA==&amp;amp;mid=2247493564&amp;amp;idx=1&amp;amp;sn=1b64e663d056ef550beeaa936f5c5dca&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Java 字节码指令，让我发了疯疯疯！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【3】：《Java虚拟机规范(Java_SE_7)》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot; data-from=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aa2b4258106a66f8707b71cf1aa01fcd</guid>
<title>Java 反编译工具的使用与对比分析</title>
<link>https://toutiao.io/k/3o1c6vb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Java 反编译&lt;/strong&gt;，一听可能觉得高深莫测，其实反编译并不是什么特别高级的操作，Java 对于 Class 字节码文件的生成有着严格的要求，如果你非常熟悉 Java 虚拟机规范，了解 Class 字节码文件中一些字节的作用，那么理解反编译的原理并不是什么问题。甚至像下面这样的 Class 文件你都能看懂一二。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4lfok2icUkibTUd7It7JewEpqb0rxtLyJEk4XPbAeyK22sBnJAiaDxibyFeHfPiao0oRG6ViaaMUNTSItQ8ciaK98X31g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般在逆向研究和代码分析中，反编译用到的比较多。不过在日常开发中，有时候只是简单的看一下所用依赖类的反编译，也是十分重要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恰好最近工作中也需要用到 &lt;strong&gt;Java 反编译&lt;/strong&gt;，所以这篇文章介绍目前常见的的几种 Java 反编译工具的使用，在文章的最后也会通过&lt;strong&gt;编译速度&lt;/strong&gt;、&lt;strong&gt;语法支持&lt;/strong&gt;以及&lt;strong&gt;代码可读性&lt;/strong&gt;三个维度，对它们&lt;strong&gt;进行测试&lt;/strong&gt;，分析几款工具的&lt;strong&gt;优缺点&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Procyon&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Github 链接：https://github.com/mstrobel/procyon&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Procyon&lt;/strong&gt; &lt;span&gt;不仅仅是反编译工具，它其实是专注于 Java 代码的生成和分析的一整套的 Java 元编程工具。主要包括下面几个部分：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Core Framework&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Reflection Framework&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Expressions Framework&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Compiler Toolset (Experimental)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java Decompiler (Experimental)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到反编译只是 &lt;strong&gt;Procyon&lt;/strong&gt; 的其中一个模块，&lt;strong&gt;Procyon&lt;/strong&gt; 原来托管于 bitbucket，后来迁移到了 GitHub，根据 GitHub 的提交记录来看，也有将近两年没有更新了。不过也有依赖 &lt;strong&gt;Procyon&lt;/strong&gt; 的其他的开源反编译工具如** decompiler-procyon**，更新频率还是很高的，下面也会选择这个工具进行反编译测试。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用 Procyon&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.jboss.windup.decompiler/decompiler-procyon --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.jboss.windup.decompiler&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;decompiler-procyon&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;5.1.4.Final&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写一个简单的反编译测试。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte.decompiler;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.IOException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.nio.file.Path;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.nio.file.Paths;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.Iterator;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.List;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jboss.windup.decompiler.api.DecompilationFailure;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jboss.windup.decompiler.api.DecompilationListener;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jboss.windup.decompiler.api.DecompilationResult;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jboss.windup.decompiler.api.Decompiler;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jboss.windup.decompiler.procyon.ProcyonDecompiler;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * Procyon 反编译测试&lt;br/&gt; *&lt;br/&gt; *  &lt;span&gt;@author&lt;/span&gt; https://github.com/niumoo&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2021/05/15&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ProcyonTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        Long time = procyon(&lt;span&gt;&quot;decompiler.jar&quot;&lt;/span&gt;, &lt;span&gt;&quot;procyon_output_jar&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(String.format(&lt;span&gt;&quot;decompiler time: %dms&quot;&lt;/span&gt;, time));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Long &lt;span&gt;procyon&lt;/span&gt;&lt;span&gt;(String source,String targetPath)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; start = System.currentTimeMillis();&lt;br/&gt;        Path outDir = Paths.get(targetPath);&lt;br/&gt;        Path archive = Paths.get(source);&lt;br/&gt;        Decompiler dec = &lt;span&gt;new&lt;/span&gt; ProcyonDecompiler();&lt;br/&gt;        DecompilationResult res = dec.decompileArchive(archive, outDir, &lt;span&gt;new&lt;/span&gt; DecompilationListener() {&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;decompilationProcessComplete&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;decompilationProcessComplete&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;decompilationFailed&lt;/span&gt;&lt;span&gt;(List&amp;lt;String&amp;gt; inputPath, String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;decompilationFailed&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fileDecompiled&lt;/span&gt;&lt;span&gt;(List&amp;lt;String&amp;gt; inputPath, String outputPath)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isCancelled&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!res.getFailures().isEmpty()) {&lt;br/&gt;            StringBuilder sb = &lt;span&gt;new&lt;/span&gt; StringBuilder();&lt;br/&gt;            sb.append(&lt;span&gt;&quot;Failed decompilation of &quot;&lt;/span&gt; + res.getFailures().size() + &lt;span&gt;&quot; classes: &quot;&lt;/span&gt;);&lt;br/&gt;            Iterator failureIterator = res.getFailures().iterator();&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (failureIterator.hasNext()) {&lt;br/&gt;                DecompilationFailure dex = (DecompilationFailure)failureIterator.next();&lt;br/&gt;                sb.append(System.lineSeparator() + &lt;span&gt;&quot;    &quot;&lt;/span&gt;).append(dex.getMessage());&lt;br/&gt;            }&lt;br/&gt;            System.out.println(sb.toString());&lt;br/&gt;        }&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Compilation results: &quot;&lt;/span&gt; + res.getDecompiledFiles().size() + &lt;span&gt;&quot; succeeded, &quot;&lt;/span&gt; + res.getFailures().size() + &lt;span&gt;&quot; failed.&quot;&lt;/span&gt;);&lt;br/&gt;        dec.close();&lt;br/&gt;        Long end = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; end - start;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Procyon 在反编译时会实时输出反编译文件数量的进度情况，最后还会统计反编译成功和失败的 Class 文件数量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;....&lt;br/&gt;五月 15, 2021 10:58:28 下午 org.jboss.windup.decompiler.procyon.ProcyonDecompiler$3 call&lt;br/&gt;信息: Decompiling 650 / 783&lt;br/&gt;五月 15, 2021 10:58:30 下午 org.jboss.windup.decompiler.procyon.ProcyonDecompiler$3 call&lt;br/&gt;信息: Decompiling 700 / 783&lt;br/&gt;五月 15, 2021 10:58:37 下午 org.jboss.windup.decompiler.procyon.ProcyonDecompiler$3 call&lt;br/&gt;信息: Decompiling 750 / 783&lt;br/&gt;decompilationProcessComplete&lt;br/&gt;Compilation results: 783 succeeded, 0 failed.&lt;br/&gt;decompiler time: 40599ms&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Procyon GUI&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Procyon 反编译来说，在 GitHub 上也有基于此实现的开源 GUI 界面，感兴趣的可以下载尝试。&lt;br/&gt;Github 地址：https://github.com/deathmarine/Luyten&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CFR&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GitHub 地址：https://github.com/leibnitz27/cfr&lt;br/&gt;CFR 官方网站：http://www.benf.org/other/cfr/（可能需要FQ）&lt;br/&gt;Maven 仓库：https://mvnrepository.com/artifact/org.benf/cfr&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CFR&lt;/strong&gt;（Class File Reader） 可以支持 Java 9、Java 12、Java 14 以及其他的最新版 Java 代码的反编译工作。而且 CFR 本身的代码是由 &lt;strong&gt;Java 6 编写&lt;/strong&gt;，所以基本可以使用 CFR 在任何版本的 Java 程序中。值得一提的是，使用 CFR 甚至可以将使用其他语言编写的的 JVM 类文件反编译回 Java 文件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CFR 命令行使用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 CFR 反编译时，你可以下载已经发布的 JAR 包，进行命令行反编译，也可以使用 Maven 引入的方式，在代码中使用。下面先说命令行运行的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接在 GitHub Tags 下载已发布的最新版 JAR. 可以直接运行查看帮助。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看帮助&lt;/span&gt;&lt;br/&gt;java -jar cfr-0.151.jar --help&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是反编译某个 class.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反编译 class 文件，结果输出到控制台&lt;/span&gt;&lt;br/&gt;java -jar cfr-0.151.jar WindupClasspathTypeLoader.class&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反编译 class 文件，结果输出到 out 文件夹&lt;/span&gt;&lt;br/&gt;java -jar cfr-0.151.jar WindupClasspathTypeLoader.class --outputpath ./out&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反编译某个 JAR.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反编译 jar 文件，结果输出到 output_jar 文件夹&lt;/span&gt;&lt;br/&gt;➜  Desktop java -jar cfr-0.151.jar decompiler.jar --outputdir ./output_jar&lt;br/&gt;Processing decompiler.jar (use silent to silence)&lt;br/&gt;Processing com.strobel.assembler.metadata.ArrayTypeLoader&lt;br/&gt;Processing com.strobel.assembler.metadata.ParameterDefinition&lt;br/&gt;Processing com.strobel.assembler.metadata.MethodHandle&lt;br/&gt;Processing com.strobel.assembler.metadata.signatures.FloatSignature&lt;br/&gt;.....&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反编译结果会按照 class 的包路径写入到指定文件夹中。&lt;img data-ratio=&quot;0.631578947368421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4lfok2icUkibTUd7It7JewEpqb0rxtLyJE0s0mf6qdskAYQfxibZJdwTmPRtAPubiczm1BiaicbDhiclg2UdxMF030n4w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;950&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CFR 代码中使用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;添加依赖这里不提。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;!-- https:&lt;span&gt;//mvnrepository.com/artifact/org.benf/cfr --&amp;gt;&lt;/span&gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.benf&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;cfr&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;&lt;span&gt;0.151&lt;/span&gt;&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上我在官方网站和 GitHub 上都没有看到具体的单元测试示例。不过没有关系，既然能在命令行运行，那么直接在 IDEA 中查看反编译后的 Main 方法入口，看下命令行是怎么执行的，就可以写出自己的单元测试了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte.decompiler;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.IOException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.ArrayList;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.HashMap;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.List;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.benf.cfr.reader.api.CfrDriver;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.benf.cfr.reader.util.getopt.OptionsImpl;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * CFR Test&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; https://github.com/niumoo&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2021/05/15&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CFRTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        Long time = cfr(&lt;span&gt;&quot;decompiler.jar&quot;&lt;/span&gt;, &lt;span&gt;&quot;./cfr_output_jar&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(String.format(&lt;span&gt;&quot;decompiler time: %dms&quot;&lt;/span&gt;, time));&lt;br/&gt;        &lt;span&gt;// decompiler time: 11655ms&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Long &lt;span&gt;cfr&lt;/span&gt;&lt;span&gt;(String source, String targetPath)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        Long start = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;// source jar&lt;/span&gt;&lt;br/&gt;        List&amp;lt;String&amp;gt; files = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        files.add(source);&lt;br/&gt;        &lt;span&gt;// target dir&lt;/span&gt;&lt;br/&gt;        HashMap&amp;lt;String, String&amp;gt; outputMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;        outputMap.put(&lt;span&gt;&quot;outputdir&quot;&lt;/span&gt;, targetPath);&lt;br/&gt;&lt;br/&gt;        OptionsImpl options = &lt;span&gt;new&lt;/span&gt; OptionsImpl(outputMap);&lt;br/&gt;        CfrDriver cfrDriver = &lt;span&gt;new&lt;/span&gt; CfrDriver.Builder().withBuiltOptions(options).build();&lt;br/&gt;        cfrDriver.analyse(files);&lt;br/&gt;        Long end = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (end - start);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JD-Core&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GiHub 地址：https://github.com/java-decompiler/jd-core&lt;br/&gt;JD-core 官方网址：https://java-decompiler.github.io/&lt;br/&gt;JD-core 是一个的独立的 Java 库，可以用于 Java 的反编译，支持从 Java 1 至  Java 12 的字节码反编译，包括 Lambda 表达式、方式引用、默认方法等。知名的 JD-GUI 和 Eclipse 无缝集成反编译引擎就是 JD-core。JD-core 提供了一些反编译的核心功能，也提供了单独的 Class 反编译方法，但是如果你想在自己的代码中去直接反编译整个 JAR 包，还是需要一些改造的，如果是代码中有匿名函数，Lambda 等，虽然可以直接反编译，不过也需要额外考虑。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用 JD-core&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        &lt;span&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.jd/jd-core --&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.jd&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;jd-core&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.1.3&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了可以反编译整个 JAR 包，使用的代码我做了一些简单改造，以便于最后一部分的对比测试，但是这个示例中没有考虑内部类，Lambda 等会编译出多个 Class 文件的情况，所以不能直接使用在生产中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte.decompiler;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.File;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.IOException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.InputStream;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.nio.file.Files;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.nio.file.Path;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.nio.file.Paths;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.Enumeration;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.HashMap;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.jar.JarFile;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.zip.ZipEntry;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.zip.ZipFile;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.apache.commons.io.IOUtils;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.apache.commons.lang3.StringUtils;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jd.core.v1.ClassFileToJavaSourceDecompiler;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jd.core.v1.api.loader.Loader;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.jd.core.v1.api.printer.Printer;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; https://github.com/niumoo&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2021/05/15&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JDCoreTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        JDCoreDecompiler jdCoreDecompiler = &lt;span&gt;new&lt;/span&gt; JDCoreDecompiler();&lt;br/&gt;        Long time = jdCoreDecompiler.decompiler(&lt;span&gt;&quot;decompiler.jar&quot;&lt;/span&gt;,&lt;span&gt;&quot;jd_output_jar&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(String.format(&lt;span&gt;&quot;decompiler time: %dms&quot;&lt;/span&gt;, time));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JDCoreDecompiler&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ClassFileToJavaSourceDecompiler decompiler = &lt;span&gt;new&lt;/span&gt; ClassFileToJavaSourceDecompiler();&lt;br/&gt;    &lt;span&gt;// 存放字节码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; HashMap&amp;lt;String,&lt;span&gt;byte&lt;/span&gt;[]&amp;gt; classByteMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 注意：没有考虑一个 Java 类编译出多个 Class 文件的情况。&lt;br/&gt;     * &lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; source&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; target&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     * &lt;span&gt;@throws&lt;/span&gt; Exception&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Long &lt;span&gt;decompiler&lt;/span&gt;&lt;span&gt;(String source,String target)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; start = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;// 解压&lt;/span&gt;&lt;br/&gt;        archive(source);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String className : classByteMap.keySet()) {&lt;br/&gt;            String path = StringUtils.substringBeforeLast(className, &lt;span&gt;&quot;/&quot;&lt;/span&gt;);&lt;br/&gt;            String name = StringUtils.substringAfterLast(className, &lt;span&gt;&quot;/&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (StringUtils.contains(name, &lt;span&gt;&quot;$&quot;&lt;/span&gt;)) {&lt;br/&gt;                name = StringUtils.substringAfterLast(name, &lt;span&gt;&quot;$&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            name = StringUtils.replace(name, &lt;span&gt;&quot;.class&quot;&lt;/span&gt;, &lt;span&gt;&quot;.java&quot;&lt;/span&gt;);&lt;br/&gt;            decompiler.decompile(loader, printer, className);&lt;br/&gt;            String context = printer.toString();&lt;br/&gt;            Path targetPath = Paths.get(target + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + path + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + name);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!Files.exists(Paths.get(target + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + path))) {&lt;br/&gt;                Files.createDirectories(Paths.get(target + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + path));&lt;br/&gt;            }&lt;br/&gt;            Files.deleteIfExists(targetPath);&lt;br/&gt;            Files.createFile(targetPath);&lt;br/&gt;            Files.write(targetPath, context.getBytes());&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; System.currentTimeMillis() - start;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;archive&lt;/span&gt;&lt;span&gt;(String path)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; (ZipFile archive = &lt;span&gt;new&lt;/span&gt; JarFile(&lt;span&gt;new&lt;/span&gt; File(path))) {&lt;br/&gt;            Enumeration&amp;lt;? extends ZipEntry&amp;gt; entries = archive.entries();&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (entries.hasMoreElements()) {&lt;br/&gt;                ZipEntry entry = entries.nextElement();&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!entry.isDirectory()) {&lt;br/&gt;                    String name = entry.getName();&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (name.endsWith(&lt;span&gt;&quot;.class&quot;&lt;/span&gt;)) {&lt;br/&gt;                        &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; (InputStream stream = archive.getInputStream(entry)) {&lt;br/&gt;                            bytes = IOUtils.toByteArray(stream);&lt;br/&gt;                        }&lt;br/&gt;                        classByteMap.put(name, bytes);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Loader loader = &lt;span&gt;new&lt;/span&gt; Loader() {&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] load(String internalName) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; classByteMap.get(internalName);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;canLoad&lt;/span&gt;&lt;span&gt;(String internalName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; classByteMap.containsKey(internalName);&lt;br/&gt;        }&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Printer printer = &lt;span&gt;new&lt;/span&gt; Printer() {&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TAB = &lt;span&gt;&quot;  &quot;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String NEWLINE = &lt;span&gt;&quot;\n&quot;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indentationCount = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;protected&lt;/span&gt; StringBuilder sb = &lt;span&gt;new&lt;/span&gt; StringBuilder();&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            String toString = sb.toString();&lt;br/&gt;            sb = &lt;span&gt;new&lt;/span&gt; StringBuilder();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; toString;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;start&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; maxLineNumber, &lt;span&gt;int&lt;/span&gt; majorVersion, &lt;span&gt;int&lt;/span&gt; minorVersion)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printText&lt;/span&gt;&lt;span&gt;(String text)&lt;/span&gt; &lt;/span&gt;{ sb.append(text); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printNumericConstant&lt;/span&gt;&lt;span&gt;(String constant)&lt;/span&gt; &lt;/span&gt;{ sb.append(constant); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printStringConstant&lt;/span&gt;&lt;span&gt;(String constant, String ownerInternalName)&lt;/span&gt; &lt;/span&gt;{ sb.append(constant); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printKeyword&lt;/span&gt;&lt;span&gt;(String keyword)&lt;/span&gt; &lt;/span&gt;{ sb.append(keyword); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printDeclaration&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; type, String internalTypeName, String name, String descriptor)&lt;/span&gt; &lt;/span&gt;{ sb.append(name); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printReference&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; type, String internalTypeName, String name, String descriptor, String ownerInternalName)&lt;/span&gt; &lt;/span&gt;{ sb.append(name); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;indent&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;this&lt;/span&gt;.indentationCount++; }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unindent&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;this&lt;/span&gt;.indentationCount--; }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;startLine&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; lineNumber)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;indentationCount; i++) sb.append(TAB); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;endLine&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ sb.append(NEWLINE); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;extraLine&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; count)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;while&lt;/span&gt; (count-- &amp;gt; &lt;span&gt;0&lt;/span&gt;) sb.append(NEWLINE); }&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;startMarker&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; type)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;endMarker&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; type)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;    };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JD-GUI&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GitHub 地址：https://github.com/java-decompiler/jd-gui&lt;br/&gt;JD-core 也提供了官方的 GUI 界面，需要的也可以直接下载尝试。&lt;img data-ratio=&quot;0.595&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4lfok2icUkibTUd7It7JewEpqb0rxtLyJERibq2oXkicod6M7gzmB2xIHqppJ9LicYbHsXhonQgv2V4hjKFggKmVqXA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Jadx&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GitHub 地址：https://github.com/skylot/jadx&lt;br/&gt;Jadx 是一款可以反编译 JAR、APK、DEX、AAR、AAB、ZIP 文件的反编译工具，并且也配有 Jadx-gui 用于界面操作。Jadx 使用 Grade 进行依赖管理，可以自行克隆仓库打包运行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;git clone https://github.com/skylot/jadx.git&lt;br/&gt;cd jadx&lt;br/&gt;./gradlew dist&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看帮助&lt;/span&gt;&lt;br/&gt; ./build/jadx/bin/jadx --help&lt;br/&gt; &lt;br/&gt;jadx - dex to java decompiler, version: dev&lt;br/&gt;&lt;br/&gt;usage: jadx [options] &amp;lt;input files&amp;gt; (.apk, .dex, .jar, .class, .smali, .zip, .aar, .arsc, .aab)&lt;br/&gt;options:&lt;br/&gt;  -d, --output-dir                    - output directory&lt;br/&gt;  -ds, --output-dir-src               - output directory for sources&lt;br/&gt;  -dr, --output-dir-res               - output directory for resources&lt;br/&gt;  -r, --no-res                        - do not decode resources&lt;br/&gt;  -s, --no-src                        - do not decompile source code&lt;br/&gt;  --single-class                      - decompile a single class&lt;br/&gt;  --output-format                     - can be &#x27;java&#x27; or &#x27;json&#x27;, default: java&lt;br/&gt;  -e, --export-gradle                 - save as android gradle project&lt;br/&gt;  -j, --threads-count                 - processing threads count, default: 6&lt;br/&gt;  --show-bad-code                     - show inconsistent code (incorrectly decompiled)&lt;br/&gt;  --no-imports                        - disable use of imports, always write entire package name&lt;br/&gt;  --no-debug-info                     - disable debug info&lt;br/&gt;  --add-debug-lines                   - add comments with debug line numbers if available&lt;br/&gt;  --no-inline-anonymous               - disable anonymous classes inline&lt;br/&gt;  --no-replace-consts                 - don&#x27;t replace constant value with matching constant field&lt;br/&gt;  --escape-unicode                    - escape non latin characters in strings (with \u)&lt;br/&gt;  --respect-bytecode-access-modifiers - don&#x27;t change original access modifiers&lt;br/&gt;  --deobf                             - activate deobfuscation&lt;br/&gt;  --deobf-min                         - min length of name, renamed if shorter, default: 3&lt;br/&gt;  --deobf-max                         - max length of name, renamed if longer, default: 64&lt;br/&gt;  --deobf-cfg-file                    - deobfuscation map file, default: same dir and name as input file with &#x27;.jobf&#x27; extension&lt;br/&gt;  --deobf-rewrite-cfg                 - force to save deobfuscation map&lt;br/&gt;  --deobf-use-sourcename              - use source file name as class name alias&lt;br/&gt;  --deobf-parse-kotlin-metadata       - parse kotlin metadata to class and package names&lt;br/&gt;  --rename-flags                      - what to rename, comma-separated, &#x27;case&#x27; for system case sensitivity, &#x27;valid&#x27; for java identifiers, &#x27;printable&#x27; characters, &#x27;none&#x27; or &#x27;all&#x27; (default)&lt;br/&gt;  --fs-case-sensitive                 - treat filesystem as case sensitive, false by default&lt;br/&gt;  --cfg                               - save methods control flow graph to dot file&lt;br/&gt;  --raw-cfg                           - save methods control flow graph (use raw instructions)&lt;br/&gt;  -f, --fallback                      - make simple dump (using goto instead of &#x27;if&#x27;, &#x27;for&#x27;, etc)&lt;br/&gt;  -v, --verbose                       - verbose output (set --log-level to DEBUG)&lt;br/&gt;  -q, --quiet                         - turn off output (set --log-level to QUIET)&lt;br/&gt;  --log-level                         - set log level, values: QUIET, PROGRESS, ERROR, WARN, INFO, DEBUG, default: PROGRESS&lt;br/&gt;  --version                           - print jadx version&lt;br/&gt;  -h, --help                          - print this help&lt;br/&gt;Example:&lt;br/&gt;  jadx -d out classes.dex&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 HELP 信息，如果想要反编译 decompiler.jar 到 out 文件夹。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;./build/jadx/bin/jadx -d ./out ~/Desktop/decompiler.jar &lt;br/&gt;INFO  - loading ...&lt;br/&gt;INFO  - processing ...&lt;br/&gt;INFO  - doneress: 1143 of 1217 (93%)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Fernflower&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GitHub 地址：https://github.com/fesh0r/fernflower&lt;br/&gt;Fernflower 和 Jadx 一样使用 Grade 进行依赖管理，可以自行克隆仓库打包运行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;➜  fernflower-master ./gradlew build&lt;br/&gt;&lt;br/&gt;BUILD SUCCESSFUL in 32s&lt;br/&gt;4 actionable tasks: 4 executed&lt;br/&gt;&lt;br/&gt;➜  fernflower-master java -jar build/libs/fernflower.jar&lt;br/&gt;Usage: java -jar fernflower.jar [-&amp;lt;option&amp;gt;=&amp;lt;value&amp;gt;]* [&amp;lt;source&amp;gt;]+ &amp;lt;destination&amp;gt;&lt;br/&gt;Example: java -jar fernflower.jar -dgs=true c:\my\source\ c:\my.jar d:\decompiled\&lt;br/&gt;&lt;br/&gt;➜  fernflower-master mkdir out&lt;br/&gt;➜  fernflower-master java -jar build/libs/fernflower.jar ~/Desktop/decompiler.jar ./out&lt;br/&gt;INFO:  Decompiling class com/strobel/assembler/metadata/ArrayTypeLoader&lt;br/&gt;INFO:  ... done&lt;br/&gt;INFO:  Decompiling class com/strobel/assembler/metadata/ParameterDefinition&lt;br/&gt;INFO:  ... done&lt;br/&gt;INFO:  Decompiling class com/strobel/assembler/metadata/MethodHandle&lt;br/&gt;...&lt;br/&gt;&lt;br/&gt;➜  fernflower-master ll out&lt;br/&gt;total 1288&lt;br/&gt;-rw-r--r--  1 darcy  staff   595K  5 16 17:47 decompiler.jar&lt;br/&gt;➜  fernflower-master&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fernflower 在反编译 JAR 包时，默认反编译的结果也是一个 JAR 包。Jad&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反编译速度&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里已经介绍了五款 Java 反编译工具了，那么在日常开发中我们应该使用哪一个呢？又或者在代码分析时我们又该选择哪一个呢？我想这两种情况的不同，使用时的关注点也是不同的。如果是日常使用，读读代码，我想应该是对可读性要求更高些，如果是大量的代码分析工作，那么可能反编译的速度和语法的支持上要求更高些。为了能有一个简单的参考数据，我使用 JMH 微基准测试工具分别对这五款反编译工具进行了简单的测试，下面是一些测试结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;测试环境&lt;/strong&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;环境变量&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;处理器&lt;/td&gt;&lt;td&gt;2.6 GHz 六核Intel Core i7&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;内存&lt;/td&gt;&lt;td&gt;16 GB 2667 MHz DDR4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Java 版本&lt;/td&gt;&lt;td&gt;JDK 14.0.2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;测试方式&lt;/td&gt;&lt;td&gt;JMH 基准测试。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;待反编译 JAR 1&lt;/td&gt;&lt;td&gt;procyon-compilertools-0.5.33.jar (1.5 MB)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;待反编译 JAR 2&lt;/td&gt;&lt;td&gt;python2java4common-1.0.0-20180706.084921-1.jar (42 MB)&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反编译 JAR 1：procyon-compilertools-0.5.33.jar (1.5 MB)&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;Benchmark&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;Mode&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;Cnt&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;Score&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;Units&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;cfr&lt;/td&gt;&lt;td&gt;avgt&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;6548.642 ±  363.502&lt;/td&gt;&lt;td&gt;ms/op&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;fernflower&lt;/td&gt;&lt;td&gt;avgt&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;12699.147 ± 1081.539&lt;/td&gt;&lt;td&gt;ms/op&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;jdcore&lt;/td&gt;&lt;td&gt;avgt&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;5728.621 ±  310.645&lt;/td&gt;&lt;td&gt;ms/op&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;procyon&lt;/td&gt;&lt;td&gt;avgt&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;26776.125 ± 2651.081&lt;/td&gt;&lt;td&gt;ms/op&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;jadx&lt;/td&gt;&lt;td&gt;avgt&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;7059.354 ±  323.351&lt;/td&gt;&lt;td&gt;ms/op&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反编译 JAR 2:  python2java4common-1.0.0-20180706.084921-1.jar (42 MB)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JAR 2 这个包是比较大的，是拿很多代码仓库合并到一起的，同时还有很多 Python 转 Java 生成的代码，理论上代码的复杂度会更高。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Benchmark&lt;/th&gt;&lt;th&gt;Cnt&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Cfr&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;413838.826ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;fernflower&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;246819.168ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;jdcore&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Error&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;procyon&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;487647.181ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;jadx&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;505600.231ms&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;语法支持和可读性&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果反编译后的代码需要自己看的话，那么可读性更好的代码更占优势，下面我写了一些代码，主要是 Java 8 及以下的代码语法和一些嵌套的流程控制，看看反编译后的效果如何。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte.decompiler;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.ArrayList;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.List;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.stream.IntStream;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.benf.cfr.reader.util.functors.UnaryFunction;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; https://www.wdbyte.com&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2021/05/16&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HardCode&lt;/span&gt; &amp;lt;&lt;span&gt;A&lt;/span&gt;, &lt;span&gt;B&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;HardCode&lt;/span&gt;&lt;span&gt;(A a, B b)&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;... args)&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String... args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        test(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;byteAnd0&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; b = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;            b = (&lt;span&gt;byte&lt;/span&gt;)((b ^ x));&lt;br/&gt;        } &lt;span&gt;while&lt;/span&gt; (b++ &amp;lt; &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; b;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;&lt;span&gt;(Integer i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        a(i);&lt;br/&gt;        b(i);&lt;br/&gt;        c(i);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        a(i);&lt;br/&gt;        b(i);&lt;br/&gt;        c(i);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;(&lt;span&gt;double&lt;/span&gt; d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        c(d);&lt;br/&gt;        d(d);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;d&lt;/span&gt;&lt;span&gt;(Double d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        c(d);&lt;br/&gt;        d(d);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;(Short s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        b(s);&lt;br/&gt;        c(s);&lt;br/&gt;        e(s);&lt;br/&gt;        f(s);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;short&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        b(s);&lt;br/&gt;        c(s);&lt;br/&gt;        e(s);&lt;br/&gt;        f(s);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;(String path)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (NullPointerException t) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;File Not found&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;return&lt;/span&gt;; }&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; t;&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;Fred&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(); }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Integer&amp;gt; stuff = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();{&lt;br/&gt;        stuff.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        stuff.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;plus&lt;/span&gt;&lt;span&gt;(&lt;span&gt;boolean&lt;/span&gt; t, &lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; c = t ? a : b;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; c;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Lambda&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;Integer &lt;span&gt;lambdaInvoker&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arg, UnaryFunction&amp;lt;Integer, Integer&amp;gt; fn)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; fn.invoke(arg);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Lambda&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;testLambda&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; lambdaInvoker(&lt;span&gt;3&lt;/span&gt;, x -&amp;gt; x + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//        return 1;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Lambda&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;testLambda&lt;/span&gt;&lt;span&gt;(List&amp;lt;Integer&amp;gt; stuff, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;boolean&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; stuff.stream().filter(b ? x -&amp;gt; x &amp;gt; y : x -&amp;gt; x &amp;lt; &lt;span&gt;3&lt;/span&gt;).findFirst().orElse(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// stream&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;Y extends Integer&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;testStream&lt;/span&gt;&lt;span&gt;(List&amp;lt;Y&amp;gt; list)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        IntStream s = list.stream()&lt;br/&gt;            .filter(x -&amp;gt; {&lt;br/&gt;                System.out.println(x);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; x.intValue() / &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;                })&lt;br/&gt;            .map(x -&amp;gt; (Integer)x+&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;            .mapToInt(x -&amp;gt; x);&lt;br/&gt;        s.toArray();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// switch&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt;(((Long)(i + &lt;span&gt;1L&lt;/span&gt;)) + &lt;span&gt;&quot;&quot;&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;1&quot;&lt;/span&gt;:&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;one&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// switch&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch2&lt;/span&gt;&lt;span&gt;(String string)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt; (string) {&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;apples&quot;&lt;/span&gt;:&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;apples&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;pears&quot;&lt;/span&gt;:&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;pears&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// switch&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch3&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (x &amp;lt; &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;switch&lt;/span&gt; (&lt;span&gt;&quot;test&quot;&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;okay&quot;&lt;/span&gt;:&lt;br/&gt;                        &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                        &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;wow x2!&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此处本来贴出了所有工具的反编译结果，但是碍于文章长度和阅读体验，没有放出来，不过我在个人博客的发布上是有完整代码的，个人网站排版比较自由，可以使用 Tab 选项卡的方式展示。如果需要查看可以访问 https://www.wdbyte.com 进行查看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Procyon&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到 Procyon 的反编译结果，还是比较吃惊的，在正常反编译的情况下，反编译后的代码基本上都是&lt;strong&gt;原汁原味&lt;/strong&gt;。唯一一处反编译后和源码语法上有变化的地方，是一个集合的初始化操作略有不同。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 源码&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;HardCode&lt;/span&gt;&lt;span&gt;(A a, B b)&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Integer&amp;gt; stuff = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();{&lt;br/&gt;    stuff.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    stuff.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt;&lt;span&gt;// Procyon 反编译&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Integer&amp;gt; stuff;&lt;br/&gt;    &lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;HardCode&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; A a, &lt;span&gt;final&lt;/span&gt; B b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    (&lt;span&gt;this&lt;/span&gt;.stuff = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;()).add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.stuff.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而其他部分代码， 比如装箱拆箱，Switch 语法，Lambda 表达式，流式操作以及流程控制等，几乎完全一致，阅读没有障碍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;装箱拆箱操作反编译后完全一致，没有多余的类型转换代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 源码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;&lt;span&gt;(Integer i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    a(i);&lt;br/&gt;    b(i);&lt;br/&gt;    c(i);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    a(i);&lt;br/&gt;    b(i);&lt;br/&gt;    c(i);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;(&lt;span&gt;double&lt;/span&gt; d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    c(d);&lt;br/&gt;    d(d);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;d&lt;/span&gt;&lt;span&gt;(Double d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    c(d);&lt;br/&gt;    d(d);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;(Short s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    b(s);&lt;br/&gt;    c(s);&lt;br/&gt;    e(s);&lt;br/&gt;    f(s);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;short&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    b(s);&lt;br/&gt;    c(s);&lt;br/&gt;    e(s);&lt;br/&gt;    f(s);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Procyon 反编译&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Integer i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.a(i);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.b(i);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.c(i);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.a(i);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.b(i);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.c(i);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.c(d);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.d(d);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;d&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Double d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.c(d);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.d(d);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Short s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.b(s);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.c(s);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.e(s);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.f(s);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;short&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.b(s);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.c(s);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.e(s);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.f(s);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Switch 部分也是一致，流程控制部分也没有变化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 源码 switch&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt;(((Long)(i + &lt;span&gt;1L&lt;/span&gt;)) + &lt;span&gt;&quot;&quot;&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;1&quot;&lt;/span&gt;:&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;one&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch2&lt;/span&gt;&lt;span&gt;(String string)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (string) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;apples&quot;&lt;/span&gt;:&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;apples&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;pears&quot;&lt;/span&gt;:&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;pears&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch3&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (x &amp;lt; &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;switch&lt;/span&gt; (&lt;span&gt;&quot;test&quot;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;okay&quot;&lt;/span&gt;:&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;wow x2!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Procyon 反编译&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; String string = (Object)(i + &lt;span&gt;1L&lt;/span&gt;) + &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (string) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;1&quot;&lt;/span&gt;: {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;one&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; String string)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (string) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;apples&quot;&lt;/span&gt;: {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;apples&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;pears&quot;&lt;/span&gt;: {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;pears&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}   &lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch3&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (x &amp;lt; &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; String s = &lt;span&gt;&quot;test&quot;&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;switch&lt;/span&gt; (s) {&lt;br/&gt;                &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;okay&quot;&lt;/span&gt;: {&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;default&lt;/span&gt;: {&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;wow x2!&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lambda 表达式和流式操作完全一致。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 源码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Lambda&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;testLambda&lt;/span&gt;&lt;span&gt;(List&amp;lt;Integer&amp;gt; stuff, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;boolean&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; stuff.stream().filter(b ? x -&amp;gt; x &amp;gt; y : x -&amp;gt; x &amp;lt; &lt;span&gt;3&lt;/span&gt;).findFirst().orElse(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// stream&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;Y extends Integer&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;testStream&lt;/span&gt;&lt;span&gt;(List&amp;lt;Y&amp;gt; list)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    IntStream s = list.stream()&lt;br/&gt;        .filter(x -&amp;gt; {&lt;br/&gt;            System.out.println(x);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; x.intValue() / &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            })&lt;br/&gt;        .map(x -&amp;gt; (Integer)x+&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        .mapToInt(x -&amp;gt; x);&lt;br/&gt;    s.toArray();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Procyon 反编译&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;testLambda&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; List&amp;lt;Integer&amp;gt; stuff, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; stuff.stream().filter(b ? (x -&amp;gt; x &amp;gt; y) : (x -&amp;gt; x &amp;lt; &lt;span&gt;3&lt;/span&gt;)).findFirst().orElse(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;Y extends Integer&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;testStream&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; List&amp;lt;Y&amp;gt; list)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; IntStream s = list.stream().filter(x -&amp;gt; {&lt;br/&gt;        System.out.println(x);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; x / &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }).map(x -&amp;gt; x + &lt;span&gt;2&lt;/span&gt;).mapToInt(x -&amp;gt; x);&lt;br/&gt;    s.toArray();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程控制，反编译后发现丢失了无异议的代码部分，阅读来说并无障碍。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 源码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;(String path)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (NullPointerException t) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;File Not found&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;return&lt;/span&gt;; }&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; t;&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Fred&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(); }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Procyon 反编译&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; String path)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {}&lt;br/&gt;    &lt;span&gt;catch&lt;/span&gt; (NullPointerException t) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;File Not found&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; t;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Fred&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鉴于代码篇幅，下面几种的反编译结果的对比只会列出不同之处，相同之处会直接跳过。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CFR&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CFR 的反编译结果多出了类型转换部分，个人来看没有 Procyon 那么原汁原味，不过也算是十分优秀，测试案例中唯一不满意的地方是对 &lt;code&gt;while continue&lt;/code&gt; 的处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// CFR 反编译结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 装箱拆箱&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;(Short s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;.b(s.shortValue()); &lt;span&gt;// 装箱拆箱多出了类型转换部分。&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;.c(s.shortValue()); &lt;span&gt;// 装箱拆箱多出了类型转换部分。&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;.e(s);&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;.f(s);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 流程控制&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;(String path)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;3&lt;/span&gt;;&lt;span&gt;// 流程控制反编译结果十分满意，原汁原味，甚至此处的无意思代码都保留了。&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;catch&lt;/span&gt; (NullPointerException t) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;File Not found&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; t;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Fred&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (path == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Lambda 和 Stream 操作完全一致，不提。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// switch 处，反编译后功能一致，但是流程控制有所更改。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch3&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    block6: &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) { &lt;span&gt;// 源码中只有 while(true)，反编译后多了 block6&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (x &amp;lt; &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;switch&lt;/span&gt; (&lt;span&gt;&quot;test&quot;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;okay&quot;&lt;/span&gt;: {&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt; block6; &lt;span&gt;// 多了 block6&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;wow x2!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JD-Core&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JD-Core 和 CFR 一样，对于装箱拆箱操作，反编译后不再一致，多了类型转换部分，而且自动优化了数据类型。个人感觉，如果是反编译后自己阅读，通篇的数据类型的转换优化影响还是挺大的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// JD-Core 反编译&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;d&lt;/span&gt;&lt;span&gt;(Double d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  c(d.doubleValue()); &lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;  d(d);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;(Short s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  b(s.shortValue()); &lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;  c(s.shortValue()); &lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;  e(s);&lt;br/&gt;  f(s.shortValue()); &lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;short&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  b(s);&lt;br/&gt;  c(s);&lt;br/&gt;  e(Short.valueOf(s)); &lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;  f(s);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Stream 操作中，也自动优化了数据类型转换，阅读起来比较累。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;Y extends Integer&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;testStream&lt;/span&gt;&lt;span&gt;(List&amp;lt;Y&amp;gt; list)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  IntStream s = list.stream().filter(x -&amp;gt; {&lt;br/&gt;        System.out.println(x);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (x.intValue() / &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;      }).map(x -&amp;gt; Integer.valueOf(x.intValue() + &lt;span&gt;2&lt;/span&gt;)).mapToInt(x -&amp;gt; x.intValue());&lt;br/&gt;  s.toArray();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Jadx&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先 Jadx 在反编译测试代码时，报出了&lt;strong&gt;错误&lt;/strong&gt;，反编译的结果里也有提示&lt;strong&gt;不能反编 Lambda 和 Stream 操作&lt;/strong&gt;，反编译结果中&lt;strong&gt;变量名称杂乱无章&lt;/strong&gt;，&lt;strong&gt;流程控制&lt;/strong&gt;几乎阵亡，如果你想反编译后生物肉眼阅读，Jadx 肯定不是一个好选择。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Jadx 反编译&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;(Short s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    b(s.shortValue());&lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;    c((&lt;span&gt;double&lt;/span&gt;) s.shortValue());&lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;    e(s);&lt;br/&gt;    f(s.shortValue());&lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;short&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    b(s);&lt;br/&gt;    c((&lt;span&gt;double&lt;/span&gt;) s);&lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;    e(Short.valueOf(s));&lt;span&gt;// 新增了数据类型转换&lt;/span&gt;&lt;br/&gt;    f(s);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;testLambda&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;// testLambda 反编译失败&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;        r2 = this;&lt;br/&gt;        r0 = 3&lt;br/&gt;        r1 = move-result&lt;br/&gt;        java.lang.Integer r0 = r2.lambdaInvoker(r0, r1)&lt;br/&gt;        int r0 = r0.intValue()&lt;br/&gt;        return r0&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException(&lt;span&gt;&quot;Method not decompiled: com.wdbyte.decompiler.HardCode.testLambda():int&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Stream 反编译失败&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;Y extends java.lang.Integer&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;testStream&lt;/span&gt;&lt;span&gt;(java.util.List&amp;lt;Y&amp;gt; r3)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;        java.util.stream.Stream r1 = r3.stream()&lt;br/&gt;        r2 = move-result&lt;br/&gt;        java.util.stream.Stream r1 = r1.filter(r2)&lt;br/&gt;        r2 = move-result&lt;br/&gt;        java.util.stream.Stream r1 = r1.map(r2)&lt;br/&gt;        r2 = move-result&lt;br/&gt;        java.util.stream.IntStream r0 = r1.mapToInt(r2)&lt;br/&gt;        r0.toArray()&lt;br/&gt;        return&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException(&lt;span&gt;&quot;Method not decompiled: com.wdbyte.decompiler.HardCode.testStream(java.util.List):void&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch2&lt;/span&gt;&lt;span&gt;(String string)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;// switch 操作无法正常阅读，和源码出入较大。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; c = &lt;span&gt;65535&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (string.hashCode()) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; -&lt;span&gt;1411061671&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (string.equals(&lt;span&gt;&quot;apples&quot;&lt;/span&gt;)) {&lt;br/&gt;                c = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;106540109&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (string.equals(&lt;span&gt;&quot;pears&quot;&lt;/span&gt;)) {&lt;br/&gt;                c = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (c) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;apples&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;pears&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Fernflower&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fernflower 的反编译结果总体上还是不错的，不过也有不足，它对变量名称的指定，以及 Switch 字符串时的反编译结果不够理想。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//反编译后变量命名不利于阅读，有很多 var 变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;byteAnd0&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;int&lt;/span&gt; b = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;   &lt;span&gt;byte&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;byte&lt;/span&gt; var10000;&lt;br/&gt;   &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;int&lt;/span&gt; b = (&lt;span&gt;byte&lt;/span&gt;)(b ^ x);&lt;br/&gt;      var10000 = b;&lt;br/&gt;      b = b + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;   } &lt;span&gt;while&lt;/span&gt;(var10000 &amp;lt; &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; b;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// switch 反编译结果使用了hashCode&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSwitch3&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (x &amp;lt; &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt;         String var1 = &lt;span&gt;&quot;test&quot;&lt;/span&gt;;&lt;br/&gt;         &lt;span&gt;byte&lt;/span&gt; var2 = -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;         &lt;span&gt;switch&lt;/span&gt;(var1.hashCode()) {&lt;br/&gt;         &lt;span&gt;case&lt;/span&gt; &lt;span&gt;3412756&lt;/span&gt;: &lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (var1.equals(&lt;span&gt;&quot;okay&quot;&lt;/span&gt;)) {&lt;br/&gt;               var2 = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;           }&lt;br/&gt;         &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;switch&lt;/span&gt;(var2) {&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;            }&lt;br/&gt;         }&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;         System.out.println(&lt;span&gt;&quot;wow x2!&quot;&lt;/span&gt;);&lt;br/&gt;      }&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;五种反编译工具比较下来，结合&lt;strong&gt;反编译速度&lt;/strong&gt;和代码可读性测试，看起来 &lt;strong&gt;CFR&lt;/strong&gt; 工具胜出，&lt;strong&gt;Procyon&lt;/strong&gt; 紧随其后。CFR 在速度上不落下风，在反编译的代码可读性上，是最好的，主要体现在反编译后的&lt;strong&gt;变量命名&lt;/strong&gt;、&lt;strong&gt;装箱拆箱&lt;/strong&gt;、&lt;strong&gt;类型转换&lt;/strong&gt;，&lt;strong&gt;流程控制&lt;/strong&gt;上，以及对 &lt;strong&gt;Lambda&lt;/strong&gt; 表达式、&lt;strong&gt;Stream&lt;/strong&gt; 流式操作和 &lt;strong&gt;Switch&lt;/strong&gt; 的&lt;strong&gt;语法支持&lt;/strong&gt;上，都非常优秀。根据 CFR 官方介绍，已经支持到 Java 14 语法，而且截止写这篇测试文章时，CFR 最新提交代码时间实在 11 小时之前，更新速度很快。&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中部分代码已经上传 GitHub 的 &lt;span&gt;niumoo/lab-notes 仓库 的 java-decompiler 目录。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;---- E&lt;/span&gt;&lt;span&gt;ND ----&lt;/span&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&quot;未读代码，一线技术工具人，认认真真写文章&quot;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4lfok2icUkibTUd7It7JewEpqb0rxtLyJE17XokYic4keU90H4vF2qOib0ib7HibVtUOzAa2M61a38XWPTgyeBUnGyMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;点个在看，加油充电～&lt;/span&gt;&lt;strong&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>febcd97027d114eeb4dfd3fd0edb9aee</guid>
<title>Go sync.Pool 浅析</title>
<link>https://toutiao.io/k/pwz9rfd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hi, 大家好，我是 haohongfan。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 应该是 Go 里面明星级别的数据结构，有很多优秀的文章都在介绍这个结构，本篇文章简单剖析下 sync.Pool。不过说实话 sync.Pool 并不是我们日常开发中使用频率很高的的并发原语。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管用的频率很低，但是不可否认的是 sync.Pool 确实是 Go 的杀手锏，合理使用 sync.Pool 会让我们的程序性能飙升。本篇文章会从使用方式，源码剖析，运用场景等方面，让你对 sync.Pool 有一个清晰的认知。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用方式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 使用很简单，但是想用对却很麻烦，因为你有可能看到网上一堆错误的示例，各位同学在搜索 sync.Pool 的使用例子时，要特别注意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 是一个内存池。通常内存池是用来防止内存泄露的（例如C/C++)。sync.Pool 这个内存池却不是干这个的，带 GC 功能的语言都存在垃圾回收 STW 问题，需要回收的内存块越多，STW 持续时间就越长。如果能让 new 出来的变量，一直不被回收，得到重复利用，是不是就减轻了 GC 的压力。&lt;/p&gt;&lt;p&gt;正确的使用示例（下面的demo选自gin）&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request)&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;    c := engine.pool.Get().(*Context)&lt;br/&gt;    c.writermem.reset(w)&lt;br/&gt;    c.Request = req&lt;br/&gt;    c.reset()&lt;br/&gt;&lt;br/&gt;    engine.handleHTTPRequest(c)&lt;br/&gt;&lt;br/&gt;    engine.pool.Put(c)&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一定要注意的是：是先 Get 获取内存空间，基于这个内存做相关的处理，然后再将这个内存还回（Put）到 sync.Pool。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Pool 结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9594813614262561&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2Yw2tia1ibmh3uncc8BNUjUMwibcibPIB6aiadD6qNnicgp2XmdZxaaQ8Mo2a2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1234&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;sync.Pool 全景图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;源码图解&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9374262101534829&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2YwZlMxIYhfR6LJjfA46S2B3fScFvGZB5icpulDpPr8iaicSjibKIxwiaib4Dlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1694&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Pool.Get&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7169811320754716&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2YwibarZj8RGvpqCv3Ayx5vuu2JssAyPUSXJQibNicpkVjS3tLkbqvbUiaWXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1696&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Pool.Put&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单点可以总结成下面的流程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3131768953068592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2Yw6BXv3BOjcfSBLysfCdtBO9r6K0MGgS7sHXVMdfur1TbfiauvsgZ4sibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2216&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Pool.Get 流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4831804281345566&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2Ywz8NQU7nn3wZxBAibsJRwMQ1b4waLqOaBliaf7GtVqIn2nJPyrR9zvJpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1308&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Pool.Put流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23261117445838084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2YwNPHyvpGjSyKFiar4mibibU3XrOm3VZC8nW2lfpujnEnaNUuqQiaibec42uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1754&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Pool GC 流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Sync.Pool 梳理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Pool 的内容会清理？清理会造成数据丢失吗？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 会在每个 GC 周期内定期清理 sync.Pool 内的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要分几个方面来说这个问题。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;已经从 sync.Pool Get 的值，在 poolClean 时虽说将 pool.local 置成了nil，Get 到的值依然是有效的，是被 GC 标记为黑色的，不会被 GC回收，当 Put 后又重新加入到 sync.Pool 中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在第一个 GC 周期内 Put 到 sync.Pool 的数值，在第二个 GC 周期没有被 Get 使用，就会被放在 local.victim 中。如果在 第三个 GC 周期仍然没有被使用就会被 GC 回收。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;runtime.GOMAXPROCS 与 pool 之间的关系？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;s := p.localSize&lt;br/&gt;l := p.local&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;uintptr&lt;/span&gt;(pid) &amp;lt; s {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; indexLocal(l, pid), pid&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; p.local == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    allPools = &lt;span&gt;append&lt;/span&gt;(allPools, p)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.&lt;/span&gt;&lt;br/&gt;size := runtime.GOMAXPROCS(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;local := &lt;span&gt;make&lt;/span&gt;([]poolLocal, size)&lt;br/&gt;atomic.StorePointer(&amp;amp;p.local, unsafe.Pointer(&amp;amp;local[&lt;span&gt;0&lt;/span&gt;])) &lt;span&gt;// store-release&lt;/span&gt;&lt;br/&gt;runtime_StoreReluintptr(&amp;amp;p.localSize, &lt;span&gt;uintptr&lt;/span&gt;(size))     &lt;span&gt;// store-release&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;runtime.GOMAXPROCS(0) 是获取当前最大的 p 的数量。sync.Pool 的 poolLocal 数量受 p 的数量影响，会开辟 runtime.GOMAXPROCS(0) 个 poolLocal。某些场景下我们会使用 runtime.GOMAXPROCS（N) 来改变 p 的数量，会使 sync.Pool 的 pool.poolLocal 释放重新开辟新的空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要开辟 runtime.GOMAXPROCS 个 local？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pool.local 是个 poolLocal 结构，这个结构体是 private + shared链表组成，在多 goroutine 的 Get/Put 下是有数据竞争的，如果只有一个 local 就需要加锁来操作。每个 p 的 local 就能减少加锁造成的数据竞争问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;New() 的作用？假如没有 New 会出现什么情况？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的 pool.Get 流程图可以看出来，从 sync.Pool 获取一个内存会尝试从当前 private，shared，其他的 p 的 shared 获取或者 victim 获取，如果实在获取不到时，才会调用 New 函数来获取。也就是 New() 函数才是真正开辟内存空间的。New() 开辟出来的的内存空间使用完毕后，调用 pool.Put 函数放入到 sync.Pool 中被重复利用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 New 函数没有被初始化会怎样呢？很明显，sync.Pool 就废掉了，因为没有了初始化内存的地方了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;先 Put，再 Get 会出现什么情况？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「一定要注意，下面这个例子的用法是错误的」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    pool:= sync.Pool{&lt;br/&gt;        New: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; item{}&lt;br/&gt;        },&lt;br/&gt;    }&lt;br/&gt;    pool.Put(item{value:&lt;span&gt;1&lt;/span&gt;})&lt;br/&gt;    data := pool.Get()&lt;br/&gt;    fmt.Println(data)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你直接跑这个例子，能得到你想像的结果，但是在某些情况下就不是这个结果了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Pool.Get 注释里面有这么一句话：“Callers should not assume any relation between values passed to Put and the values returned by Get.”，告诉我们不能把值 Pool.Put 到 sync.Pool 中，再使用 Pool.Get 取出来，因为 sync.Pool 不是 map 或者 slice，放入的值是有可能拿不到的，sync.Pool 的数据结构就不支持做这个事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说使用 sync.Pool 容易被错误示例误导，就是上面这个写法。为什么 Put 的值 再 Get 会出现问题？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;情况1：sync.Pool 的 poolCleanup 函数在系统 GC 时会被调用，Put 到 sync.Pool 的值，由于有可能一直得不到利用，被在某个 GC 周期内就有可能被释放掉了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;情况2：不同的 goroutine 绑定的 p 有可能是不一样的，当前 p 对应的 goroutine 放入到 sync.Pool 的值有可能被其他的 p 对应的 goroutine 取到，导致当前 goroutine 再也取不到这个值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;情况3：使用 runtime.GOMAXPROCS（N) 来改变 p 的数量，会使 sync.Pool 的 pool.poolLocal 释放重新开辟新的空间，导致 sync.Pool 被释放掉。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;情况4：还有很多情况&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;只 Get 不 Put 会内存泄露吗？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用其他的池，如连接池，如果取连接使用后不放回连接池，就会出现连接池泄露，&lt;strong&gt;「是不是 sync.Pool 也有这个问题呢？」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的流程图，可以看出来 Pool.Get 的时候会尝试从当前 private，shared，其他的 p 的 shared 获取或者 victim 获取，如果实在获取不到时，才会调用 New 函数来获取，New 出来的内容本身还是受系统 GC 来控制的。所以如果我们提供的 New 实现不存在内存泄露的话，那么 sync.Pool 是不会内存泄露的。当 New 出来的变量如果不再被使用，就会被系统 GC 给回收掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不 Put 回 sync.Pool，会造成 Get 的时候每次都调用的 New 来从堆栈申请空间，达不到减轻 GC 压力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用场景&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说到 sync.Pool 业务开发中不是一个常用结构，我们业务开发中没必要假想某块代码会有强烈的性能问题，一上来就用 sync.Pool 硬怼。sync.Pool 主要是为了解决 Go GC 压力过大问题的，所以一般情况下，当线上高并发业务出现 GC 问题需要被优化时，才需要用 sync.Pool 出场。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用注意点&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;sync.Pool 同样不能被复制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;好的使用习惯，从 pool.Get 出来的值进行数据的清空（reset），防止垃圾数据污染。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;本文基于的 Go 源码版本：1.16.2&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考链接&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;深度解密 Go 语言之 sync.Pool https://www.cnblogs.com/qcrao-2018/p/12736031.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请问sync.Pool有什么缺点？&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMTY3NDI3Ng==&amp;amp;mid=2247483691&amp;amp;idx=1&amp;amp;sn=92aa7a03d8229f64eee183ad118a3336&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s/2ZC1BWTylIZMmuQ3HwrnUg&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 1.13中 sync.Pool 是如何优化的? https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 的剖析到这里基本就写完了，想跟我交流的可以在评论区留言。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 完整流程图获取链接：链接: https://pan.baidu.com/s/1T5e8qCzp8JcTgARZFjGQoQ  密码: ngea 其他模块流程图，请关注公众号回复1获取。学习资料分享，关注公众号回复指令：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;回复 0，获取 《Go 面经》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回复 1，获取 《Go 源码流程图》&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMDY4ODg5MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlob0NQenCHM7wrDdQicgdcYyDWDr78gNib4SBlxN6QnF644ytlDHx8EMq4DzbLWYqsajAXWQGDRZQ00g/0?wx_fmt=png&quot; data-nickname=&quot;HHFCodeRv&quot; data-alias=&quot;hhfcodearts&quot; data-signature=&quot;资深 Go 开发, Dubbogo commiter, 分享一些开发日常&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2dcba8279be74b5ef5a14ac703e1b3c9</guid>
<title>如何快速实现一个聊天室？</title>
<link>https://toutiao.io/k/6xcz0t9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何快速实现一个聊天室？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5384615384615384&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JJRW7FxQREz58QHz9k1ZDfgvLLIGqToR9cEK0XfhaNezuiaib8NlZjwqBEBaW8EK9QHVaNWibfiauic2LfJwnLAHQNQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;聊天室&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前些天做了一个网站：https://modubox.cn 其中有个群聊插件，许多人问如何实现的。这里简单说下，为了快速完成群聊功能，我选择从最简单的 WebSocket 开始。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;什么是WebSocket ？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然要使用它，就需要了解一下它吧。WebSocket其实也是一种基于TCP的网络协议，它与HTTP协议最大的不同是：是一种双向通信协议，在建立连接后，WebSocket服务器端和客户端都能主动向对方发送或接收数据，而HTTP协议只能客户端主动发起通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以WebSocket能够用于聊天，当然其他地方也能应用，如果做客服系统或推送消息都可以从这里开始。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;如何实现单聊/群聊？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;群聊：所有客户端的消息发送到服务器，服务端将消息发送给所有客户端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单聊：WebSocket客户端之间是无法直接通信的，想要通信，必须由服务端转发。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JJRW7FxQREz58QHz9k1ZDfgvLLIGqToRqr9iaZM2vdviaOWVibylkiaJhsdArOIO5r3D8WMSrSzicTW7bgCWpSB17sA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;群聊单聊&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 引入WebSocket的支持&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用当前最流行的Spring Boot框架构建项目，然后引入Spring Boot 对 WebSocket 的支持：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-websocket&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 开启WebSocket&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebSocketConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ServerEndpointExporter &lt;span&gt;serverEndpointExporter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServerEndpointExporter();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 服务端&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要有以下几点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;声明服务端点路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储所有连接用户，等待匹配用户&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;连接 onOpen，消息OnMessage，关闭onClose，错误onError 方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送消息给特定连接者&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@ServerEndpoint&lt;/span&gt;(value = &lt;span&gt;&quot;/websocket/random/&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ChatRandomServer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//所有连接&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConcurrentHashMap&amp;lt;String, ChatRandomServer&amp;gt; webSocketSet = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//与某个客户端的连接会话，需要通过它来给客户端发送数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Session session;&lt;br/&gt;    &lt;span&gt;//所有在配对的ID&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt; webSocketLiveList = &lt;span&gt;new&lt;/span&gt; CopyOnWriteArrayList();&lt;br/&gt;    &lt;span&gt;//自己的id标识&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String id = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//连接对象的id标识&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String toUser = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 连接建立成功调用的方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@OnOpen&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onOpen&lt;/span&gt;&lt;span&gt;(Session session)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        session.setMaxIdleTimeout(&lt;span&gt;3600000&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.session = session;&lt;br/&gt;        &lt;span&gt;//获取用户ip&lt;/span&gt;&lt;br/&gt;        String ip = IpUtil.getRemoteAddress(session);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = ip;&lt;br/&gt;        ChatRandomServer put = webSocketSet.put(&lt;span&gt;this&lt;/span&gt;.id, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//如果已经在队里，就不去找对象&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (put == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (pair()) {&lt;br/&gt;                    sendMessage(&lt;span&gt;&quot;匹配成功&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                sendMessage(&lt;span&gt;&quot;匹配失败&quot;&lt;/span&gt;);&lt;br/&gt;                webSocketSet.remove(&lt;span&gt;this&lt;/span&gt;.id); &lt;br/&gt;                session.close();&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;        log.info(&lt;span&gt;&quot;用户{}加入！当前在线人数为: {}&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.id, webSocketSet.size());&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 连接关闭调用的方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@OnClose&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onClose&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ChatRandomServer UserId = webSocketSet.get(toUser);&lt;br/&gt;        webSocketLiveList.remove(&lt;span&gt;this&lt;/span&gt;.id);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (UserId != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                sendToUser(session, &lt;span&gt;&quot;对方已离开&quot;&lt;/span&gt;, toUser);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        webSocketSet.remove(&lt;span&gt;this&lt;/span&gt;.id);&lt;br/&gt;        log.info(&lt;span&gt;&quot;{}连接关闭！当前在线人数:{}, 当前在匹配的人数:{}&quot;&lt;/span&gt; ,&lt;span&gt;this&lt;/span&gt;.id,webSocketSet.size(), webSocketLiveList.size());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 收到客户端消息后调用的方法&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; message 客户端发送过来的消息&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@OnMessage&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onMessage&lt;/span&gt;&lt;span&gt;(String message, Session session)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;来自 {} 的消息: {}&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.id, message);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            ChatRandomServer.sendToUser(session, message, toUser, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@OnError&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onError&lt;/span&gt;&lt;span&gt;(Session session, Throwable error)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.error(&lt;span&gt;&quot;发生错误&quot;&lt;/span&gt;);&lt;br/&gt;        error.printStackTrace();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            SendSelf(session,&lt;span&gt;&quot;服务器出现错误&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 发送消息给自己&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendMessage&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        SendSelf(&lt;span&gt;this&lt;/span&gt;.session, message);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;SendSelf&lt;/span&gt;&lt;span&gt;(Session session, String message)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        session.getBasicRemote().sendText(message);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 发送信息给指定ID用户&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendToUser&lt;/span&gt;&lt;span&gt;(Session session, String message, String sendUserId)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        ChatRandomServer UserId = webSocketSet.get(sendUserId);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (UserId != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            UserId.sendMessage(message);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            SendSelf(session, &lt;span&gt;&quot;发送失败&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 通知除了自己之外的所有人&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendOnlineCount&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String key : webSocketSet.keySet()) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (key.equals(id)) {&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                webSocketSet.get(key).sendMessage(message);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 发送信息给所有人&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendToAll&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String key : webSocketSet.keySet()) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                webSocketSet.get(key).sendMessage(message);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;pair&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//是否存在等待匹配的用户&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (webSocketLiveList.size() &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//随机匹配一个&lt;/span&gt;&lt;br/&gt;            Random ra = &lt;span&gt;new&lt;/span&gt; Random();&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; nextInt = ra.nextInt(webSocketLiveList.size());&lt;br/&gt;            toUser = webSocketLiveList.get(nextInt);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                ChatRandomServer UserId = webSocketSet.get(toUser);&lt;br/&gt;                UserId.setToUser(id);&lt;br/&gt;                sendToUser(session, &lt;span&gt;&quot;配对成功&quot;&lt;/span&gt;, toUser);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;            webSocketLiveList.remove(nextInt);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//没有匹配的，则将自己加入等待匹配队列&lt;/span&gt;&lt;br/&gt;        webSocketLiveList.add(id);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 前端支持&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; start: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; (WebSocket) === &lt;span&gt;&quot;undefined&quot;&lt;/span&gt;) {&lt;br/&gt;          alert(&lt;span&gt;&quot;您的浏览器不支持socket&quot;&lt;/span&gt;)&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;// 实例化socket&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.socket = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;`ws://localhost:8082/websocket/room`&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;// 监听socket连接&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.socket.onopen = &lt;span&gt;this&lt;/span&gt;.open&lt;br/&gt;          &lt;span&gt;// 监听socket错误信息&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.socket.onerror = &lt;span&gt;this&lt;/span&gt;.error&lt;br/&gt;          &lt;span&gt;// 监听socket消息&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.socket.onmessage = &lt;span&gt;this&lt;/span&gt;.getMessage&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.socket.onclose = &lt;span&gt;this&lt;/span&gt;.close&lt;br/&gt;        }&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;open&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;error&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;getMessage&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;obj&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//接收信息后根据不同情况不同处理方式&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; data = &lt;span&gt;JSON&lt;/span&gt;.parse(obj.data);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (data.code === &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.code === &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        }&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;close&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      },&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;doSend&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (that.sendData === &lt;span&gt;&#x27;&#x27;&lt;/span&gt;) {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.socket.send(that.sendData);&lt;br/&gt;        that.sendData = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;      },&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码不完整，如果需要看下完整代码，联系我。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;500&quot; data-backw=&quot;500&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;256&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;257&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQRExGEvHCSlBlBDLibfHJXldiaZ96rd67AIDF213cJzwICFLdUOFuib9cCibV1G8WVsG983iaRQZ1v1LRkUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>41b0d82d0979638429953710fee14561</guid>
<title>WebRTC 的前世今生</title>
<link>https://toutiao.io/k/r3kppel</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p line=&quot;ftUQ&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;在线会议、在线教育、在线面试、在线社交、在线医疗、金融证券在线开户、智能家居等等已经成为了现代人们生活中非常熟悉的一部分，将常见的线下场景转至线上，人们足不出户便能体验上述场景。这些实时互动场景在很大程度上已经改变了我们原本的生活方式。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;51c9&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;evkG&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;如果我们将时间倒回到 10 年前，也就是在 4G 即将商用的时候，几乎所有的媒体和技术都在强调 4G 可以看高清视频，但多数都聚焦在讨论手机看视频有多么的方便，没有人预测到短视频的彻底爆发；多数人都知道 4G 的上传速度可以视频直播了，但当时的设想更多的是应用于专业的新闻领域，没有想到这个全民皆可直播的时代的来临；对于视频会议的设想也大多停留在跨国办公的需求上，但没想到就在去年，线上办公几乎成为了每一位上班族的日常。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;TnV5&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;HXcB&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;在这十年间，实时互动场景的日常化又是如何一步一步实现的呢？&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;HZPk&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;从 2010 年左右，实时通信只能使用专有软件、插件或Adobe Flash进行实时通信；2013年，Chrome 和 Firefox 之间进行了首次跨浏览器视频通话；2014年，第一次跨浏览器数据传输得以实现，通过客户端进行实时通信打开了一个新兴的趋势......而今天，它被称为WebRTC，我们每天都在 Chrome，Mozilla Firefox，Opera，Safari，Edge，iOS 和 Android 的实时互动场景中使用它。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.502127659574468&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGoEltU0Kia3lA2NLVK9DbtlC4A6kgEia952HhxJR0soYRArRZxQt2hc9ng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;470&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;WebRTC 是一个由 Google、Mozilla、Opera 等发起的开源项目，名称源自网页即时通信（Web Real-Time Communication）的缩写。因此，不难看出这项技术最开始的目标是希望为实现自由地在浏览器上进行实时音视频传输做准备的。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;“其实 WebRTC 在不同场景下包含不同的含义，它既可以代表 Google 开源的 WebRTC 项目，又可以代表 W3C（World Wide Web Consortium-万维网联盟） 工作组制定的 WebRTC 标准，也可以代表浏览器中的 WebRTC 接口，我们将他们统称为 WebRTC 技术。”&lt;/span&gt;&lt;span&gt;&lt;em&gt;【1】&lt;/em&gt;&lt;/span&gt;&lt;span&gt;多数时候，对于开发者而言 WebRTC 是一套支持网页浏览器进行实时音视频对话的 W3C Javascript API，&lt;strong&gt;它包括了音视频的采集、编解码、网络传输、显示等功能&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;由于几乎所有主流浏览器都支持 WebRTC 标准 API ，因此也让浏览器之间无插件化的音视频互通成为可能， 大大降低了音视频开发的门槛，开发者只需要调用 WebRTC API 即可快速构建出音视频应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;9.31125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGoibU0LV1ibAMANYhLlSCfiaBiad7abkRbGD4IShUcA8iaYia6OzuWCKqWQXUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2289156626506024&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGoxspGvicqM2nW01rPA102iaPXOFXJ7R2lpcicBic5KLu8G5NTYlZJb851Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;66&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;“WebRTC 的使命是使丰富、高质量的 RTC 应用程序能够为浏览器、移动平台和 IoT 设备开发，并允许所有人通过一组通用协议进行通信。”&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;WebRTC 解决了什么问题？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;在没有 WebRTC 前，对于开发者而言 RTC 通信的难点主要来自于互联网网络复杂、延时敏感、实时音视频流畅度及清晰度较低以及运营成本较高等。但这些问题在 WebRTC 出现后都得到了较好的解决：&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;1、互联网网络复杂&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;不同的 NAT、防火墙对媒体 P2P 的建立带来了很大的挑战。而 WebRTC 的出现为浏览器提供了端到端的直接通信，使开发者可以轻松地实现这种连接。同时，WebRTC 里面有 P2P 打洞的开源项目 libjingle ,支持 STUN，TURN 等协议。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;2、延时敏感&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;在早期的 RTC 技术中，TCP（Transmission Control Protocol-传输控制协议）由于自身机制的缺陷，只能使用 UDP 传输，但这需要开发人员解决重传、乱序等问题。而 WebRTC 则提供了 NACK，FEC 技术，不再需要通过服务器进行路由，减少了延迟和带宽消耗。直接通信可提高数据传输和文件共享的速度。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;3、流畅性&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;互联网网络不稳定，特别一些小运营商，在流量使用高峰期往往无法保证足够的带宽。需要一套自适应的算法来应对网络拥塞、平滑发送等问题。WebRTC 中提供了 TCC + SVC + PACER + JitterBuffer 技术支持。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;4、语音清晰&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;由于终端设备和环境复杂，会有噪声、回声的干扰，这时候 WebRTC 提供了 3A 算法 + NetEQ，让实时环境中的声音处理及互动体验得到了大幅的提升。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;对于开发人员或企业而言，使用 WebRTC 的过程中只需要下载兼容 WebRTC 的浏览器并使用，不需要额外的软件、插件或持续的服务器的参与就可以将音视频应用轻松嵌入到任何网站中，并通过 Internet 进行连接，大大节省了开发时间和成本。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;目前主流的浏览器如 Microsoft Edge、Google Chrome、Mozilla Firefox、Safari、Safari、Opera、Vivaldi 等都已支持 WebRTC。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用 WebRTC 安全吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;WebRTC 作为一项开源技术，可在任何 Web 浏览器上免费使用，并且不受插件限制。那么，这时候可能有人会问，使用 WebRTC 安全吗？使用 WebRTC 会不会有恶意访问我的用户数据或者专用网络的情况出现？&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;放心吧，在安全方面，WebRTC同样做了优化设计：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;所有 WebRTC 媒体数据都必须经过加密&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;由于 WebRTC 并非是一个插件，也不用安装别的插件，因此所有应用都可以在浏览器的沙箱中运行，并不用再额外创建新进程。也正因为如此， WebRTC 有效地阻止了恶意软件进入用户系统。在任何实时通信应用程序中，数据传输的过程都有可能会增加安全风险，因此加密是WebRTC 的强制性功能，并在所有媒体数据上强制执行。&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;【2】&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;WebRTC使用两种标准化的加密协议：&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;V1i8&quot; linespacing=&quot;115&quot;&gt;&lt;/p&gt;&lt;p linespacing=&quot;115&quot;&gt;&lt;strong&gt;&lt;span&gt;数据报传输层安全性（DTLS）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;浏览器中内置的标准化协议。是基于传输层协议（TLP）的数据流加密；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于 DTLS 使用用户数据协议（UDP），因此保留了传输的语义；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;它是安全套接字层（SSL）的扩展，任何 SSL 协议均可用于保护 WebRTC 数据，从而允许端到端加密。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p linespacing=&quot;115&quot;&gt;&lt;strong&gt;&lt;span&gt;安全实时传输协议（SRTP）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p linespacing=&quot;115&quot; line=&quot;CSHU&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;（* 但 SRTP 协议也有它的一些缺点，比如虽然它为 RTP 数据包提供加密，但不对标头进行加密。）&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;Zjw7,8VlP,yBQz,HBL0,AIUQ,k4YV,9yt3,ABb1,PiqB,AVnB,nmPb&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;在我们日常使用网络下载应用程序、电影或者通过邮件传输信息/文件的过程中，其实都有可能会存在恶意入侵的风险。但是，WebRTC 技术通过上述标准，&lt;/span&gt;&lt;span&gt;可&lt;/span&gt;&lt;span&gt;以有效保护敏感数据的传输，为安全的实时通信环境提供保障。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3175182481751825&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEL86uUh6Az7NfWTWEX7AGoibgwjbYs8W984YAx1EGW8IAeYAPQzzEhCt1KlNUZBBCRG02VE8M9pVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;548&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;WebRTC 是互联网行业在实时通信方面影响深远的一项努力，大幅降低了开发人员实现实时音视频通信功能的门槛。那我是不是有了好的想法，就可以直接使用 WebRTC 来进行开发并商用了呢？（搓手😄...）很遗憾，答案是否定的。&lt;/span&gt;&lt;/section&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;由于 WebRTC 的传输是基于公共互联网，而公共互联网并不是为了实时通信而设计的，因此在网络协议、跨区域带宽、跨运营商、用户设备、网络架构、文档支持等方面都会对 WebRTC 的开发有牵制，从而会导致实时音视频等传输质量没办法得到有效的保证。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;*关于 WebRTC 的优缺点详情可参考：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNzA1OTA2OQ==&amp;amp;mid=2657207480&amp;amp;idx=2&amp;amp;sn=a34fce2d9d18d5e697a0ca79288d05e1&amp;amp;chksm=8c8d45aabbfaccbc38835368cd438e2907c2219eed6439dcf58f85b9f27d9173b0cac23b4a6c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;WebRTC现状及优缺点，音视频通信必看的开源项目&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;因此，可以说如果 WebRTC 直接拿过来商用的话，几乎是不太可能的，当下普遍的解决方案是自研，根据自身的业务场景进行二次定制开发，或者更简单一点使用第三方 SDK。（Agora WebSDK 是基于 WebRTC 封装的API集合，极致简单，对开发者更加友好，能十行之内完成一个简单的 demo 并上线。点击【阅读原文】可查看详情。）&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;关于 WebRTC 如何进行二次定制开发以及 WebRTC 的最佳实践内容，我们会在本系列后续内容中与大家分享。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 敬请期待～ &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;em&gt;参考资料：&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;em&gt;【1】毛玉杰. 2018. 进击的WebRTC：我们为什么需要它？-InfoQ. [online] Infoq.cn. Available at: &amp;lt;https://www.infoq.cn/article/why-do-we-need-webrtc&amp;gt; [Accessed 28 April 2021].&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;7TIE&quot; linespacing=&quot;115&quot;&gt;&lt;span&gt;&lt;em&gt;【2】&lt;/em&gt;&lt;em&gt;&lt;span&gt;Grandviewresearch.com. 2021. &lt;/span&gt;&lt;em&gt;Web Real-Time Communication Market Report, 2020-2027&lt;/em&gt;&lt;span&gt;. [online] Available at: &amp;lt;https://www.grandviewresearch.com/industry-analysis/web-real-time-communication-market&amp;gt; [Accessed 18 May 2021].&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>