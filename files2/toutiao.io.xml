<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d94851ca017f26ea687c9708250e6a05</guid>
<title>京东不再需要CTO；架构师成长路线；Go1.18泛型编程体验｜码农周刊VIP会员专属邮件周报 Vol.085</title>
<link>https://toutiao.io/k/spdubm8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;以下内容节选自「码农周刊VIP会员专属邮件周报 Vol.085」，查看完整链接版请微信扫描下方二维码，加入「码农周刊VIP会员」。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本期，首先分享的是&lt;strong&gt;有效沟通的四个误区&lt;/strong&gt;，供参考。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）我是对的，&lt;strong&gt;错的是你&lt;/strong&gt;；&lt;br/&gt;2）我了解事情的全貌，&lt;strong&gt;你不了解&lt;/strong&gt;；&lt;br/&gt;3）我动机单纯，&lt;strong&gt;你可不一定&lt;/strong&gt;；&lt;br/&gt;4）我不是问题的始作俑者。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicExaAOpFGs2HwoLibfVcbghYjBFH0wjibEvDYjKib0ptt4jic9AtPboeZZNcGehAj7tiaYYtNI6Pa31iaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;黑匣子这么重要，为什么数据不能云同步？&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;https://mp.weixin.qq.com/s/VvAGVX_MsXQ8gKIcodSnRw&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;黑匣子最主要的任务是保存数据，其他方面的性能很差，无法搭载实现数据同步所需的操作环境。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;京东不再需要 CTO&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://mp.weixin.qq.com/s/WT1CB6ORxhHsl4bbIXADpA&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;李大学退休、王亚卿失势、张晨淡出，刘强东找不到心中的理想CTO。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;架构师成长路线&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://mp.weixin.qq.com/s/EQZRy63YW58J8dDGqfHM4w&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从各个角度来解读架构师&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;货拉拉全链路监控演进史&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/nrsy3uf&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一年实现降本60%&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Java开发中那些非常好用的工具&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/4clfoez&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;太顺手了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;Go1.18泛型编程体验&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/fq5drnb&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Go 1.18版本发布了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;低代码是什么？有什么优势&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/mh3ya24&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;编写信息安全规划的几点经验&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://mp.weixin.qq.com/s/EjFZ2wr5ynzhiqttVAm8ng&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实操内容&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;查看完整链接版请微信扫描下方二维码，加入「码农周刊VIP会员」。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b38fa017c9a1af130515b2a42adb2b6c</guid>
<title>[推荐] 如果你是一个Golang面试官，你会问哪些问题？</title>
<link>https://toutiao.io/k/yvw61mc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小土这两天本来想在公司发个面经，于是偶然搜到了这篇 &lt;span&gt;如果你是一个Golang面试官，你会问哪些问题？&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;,文章下面也有很多大佬的优秀回答，感兴趣的同学可以查看原文了解更多内容。下面小土主要收集了两个回答。另外小土在语雀也搜集了不少Gopher面经，&lt;span&gt;面试题库收集&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;回答 1:&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者：混血王子
链接：https://www.zhihu.com/question/67846139/answer/2105444792&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有假如，我就是一个Golang面试官，来自百度。同时我到百度之前也面过头条，腾讯，小米，高德的golang，基本都过了。我回答应该还是比较有说服力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，golang的问题只占我面试问题的20%左右。问东西的顺序不一定是下面的顺序，有的时候我会根据简历选择二分法难度来问，直接问一个难度适中的问题。说上来就继续二分法筛。下面是我问过的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1，make和new差别，引用类型的意义&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2，逃逸分析&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3，channel的实现&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4，gmp与gc，重点问题（网络io等待队列，读写屏障）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5，map的实现，重点问题（sync.map的实现，map实现随机的方法）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;期间会根据实际情况，从这几个题发散问一些细节，但是难度不会太难了。因为我面的是p6级别的，问源码有点欺负人了。另外会问一个开发性问题，你写go遇到的坑点。从这里也可以发散问一些，但是不会问太多了。这几个问题在10分钟之内肯定要问完的。我的面试范围和我之前遇到过的面试基本都在&lt;span&gt;https://draveness.me/golang/&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 内，这个教程还是非常不错的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些问题不一定都要答上来，我是综合考察的，我写这几个题目也不是让大家去背这几个题的，只是想告诉大家面试的难度一般如何，顺便说几个经典题目。另外我主要关注的问题其实主要是mysql，redis，mq，算法，分布式。有人看的话，我就补充一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;9.7 补充mysql&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先声明一下，我说的面试题都是个人向的，其实大家要面哪家公司的时候，搜那家公司的面试题用处其实不大，因为面试官并没有说题库，或者统一标准的说法。如果我去了其他家公司当面试官我一样也会这么问（注意是提问方式和难度，题目我会换的）。而你碰到百度其他面试官，也很可能不会按我这么问。另外，因为我面的校招到10年的都有，所以具体问法也会灵活调整。说到校招，这次大校招我也被安排当面试官了，校招的朋友也可以关注一下，如果能答出来，那就惊喜级别&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;补充一下我对mysql的考察方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1，八股，为什么用b+树不用b树&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以第一题为分界线，答出来了问下面的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2，说说对mvcc的理解&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3，幻读是怎么解决的&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4，redo，undo的作用和实现&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5，事务的实现&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答不出第一题就问，下面就是纯八股了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2，索引怎么建&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3，联合索引最左前缀&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4，聚簇索引与回表&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果觉得前半部分回答得不行，就会转问后半部分的简单题。和上面一样，我问的问题和我遇见过的问题，基本都在《&lt;em&gt;MySQL技术内幕&lt;/em&gt;:InnoDB存储引擎》姜承尧老师的书里面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;9.8 补充redis&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis的东西虽然不多，但是也是必问的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1，底层数据结构实现，重点问题如：压缩列表&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2，aof与rdb，重点问题如：aof重写机制&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3，为什么用跳表&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4，分布式锁与redlock&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5，三种分布式的结构&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6，大KEY&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本上说明白一半就行了，和上面一样，我问的问题和我遇见过的问题，大部分都在《Redis设计与实现》里面。因为redis的问题都不算难，如果全答上来了，我可能会问一个：在扩容rehash的时候scan扫集合，会不会扫到重复的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;9.9 补充mq+es+分布式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就补一下剩下的常问问题吧，mq主要是kafka。下面基本上工作3年之内不怎么问，3年以上的说上1/3到1/2就通过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1，kafka的零拷贝和顺序io 零拷贝最好说说细节，其实就是用户空间和内核空间mmap&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2，kafka的分片，分片的读一致性（水位和活跃组？忘了叫什么了）和写一致性怎么保证&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3，es的倒排索引，和分片的查询召回&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4，分布式锁，redis redlock etcd&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5，分布式事务 2pc 3pc tcc&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6，分布式共识协议 raft和paxos&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7，分布式数据库 CAP BASE的概念 etcd tidb的了解&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;额外的问题，只有简历写了我才会问&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1，k8s的应用和架构（k8s其实我也没深入研究，随便）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2，监控prometheus，比如里面时序数据库TSDB&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3，微服务架构的内容，比如服务发现和链路追踪的工具&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4，校招的话问问tcp&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5，其他我感兴趣的东西&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6，算法题必问，一般先选一个中等偏难的，难度参见周赛第三题。要是很顺畅就加一个第四题难度（困难），做不出来就换一个第二题难度（中等偏简单）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7，架构设计，因为我只是一面，这种问题一般留给二面问。不过我给的建议是，mysql分表，redis缓存，kafka削峰这三板斧&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写在最后，其实我的标准只有一个，我的所有提问也是围绕这一标准来的，就是让我感受到你对技术的热情，对技术路线有清晰规划，并且正在进行系统性地有条理的学习持续一年以上，比如看书，事实上我也是这么要求自己的。我相信满足了这个条件，你面其他公司也很容易。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;回答2:&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者：HelloKaton
链接：https://www.zhihu.com/question/67846139/answer/257359743&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章翻译自一位外国友人的关于面试后端程序员的文章，我比较喜爱这篇文章。一是因为它极大的拓宽了我的视角，另一方面是其中的一些问题非常具有启发性。不仅对于面试者，对于面试官来说也是个不错的参考。于是迫不及待的翻译了一下，给各位看官做个参考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原文参见 &lt;span&gt;@arialdomartini&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;的: &lt;span&gt;Back-End Developer Interview Questions&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是原文翻译。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通用问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开放式问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计模式相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码设计相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语言相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Web相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非关系型数据库相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码版本管理相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式系统相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软件生命周期和团队管理相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;逻辑和算法相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软件架构相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面向服务架构(SOA)和微服务(Microservice)相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比尔盖茨式问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码示例问题&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通用问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;语言设计中空引用(&lt;span&gt;null reference&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;)的存在有什么问题？假设你想要将空引用的概念从你的首选语言中移除，可能导致什么结果？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么函数式编程重要？什么时候适用函数式语言？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计(design)、架构(architecture)、功能(functionality)和美学(aesthetic)之间有什么区别？讨论一下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;微软、谷歌、欧朋(opera)和火狐这类公司是如何从他们的浏览器中获利的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么打开TCP套接字有很大的开销？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;封装的重要性体现在哪儿？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是实时系统？它与普通系统有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实时语言(real-time language)和堆内存分配(heap memory allocation)之间的关系是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不变性(Immutability)是指: (变量的)值只能在创建的时候被设置一次，之后就不能被改变。为什么不变性对写更加安全的代码有帮助？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可变值(mutable values)和不可变值(immutable values)有哪些优缺点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是O/R阻抗失衡(Object-Relational impedence mismatch)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你需要使用缓存，你使用哪些原则来确定缓存的大小？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TCP和HTTP有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在客户端渲染(client-side rendering)和服务端渲染(server-side rendering)之间，你是如何权衡的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何在一个不可靠的协议之上构建一个可靠的通信协议？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;开放式问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;为什么人们会抵制变化？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何向你的祖母解释什么是线程？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;作为一个软件工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是好的代码？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解释什么是流(Streaming)和如何实现一个流？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设你的公司给你一周的时间，用来改善你和同事的生活: 你将如何使用这一周？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本周你学了什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;所有的设计中都会有美学元素(aesthetic element)的存在。问题是，你认为美学元素是你的朋友还是敌人？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;列出最近你读过的5本书。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设目前有个大型公司（非常有钱），他们的开发流程是瀑布式流程（Waterfall），如果需要你在他们公司引入持续交付（&lt;span&gt;Continue Devivery&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;），你会怎么做？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们来谈谈&quot;&lt;em&gt;重复造轮子&lt;/em&gt;&quot;,&quot;&lt;em&gt;非我发明症&lt;/em&gt;&quot;, &quot;&lt;em&gt;吃自己做出来的狗粮&lt;/em&gt;&quot;的这些做法吧。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(注: 重复造轮子: Reinventing the wheel; 非我发明症:Not Invented Here Syndrome; 吃自己做出来的狗粮: Eating Your Own Dog Food)&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在你当前的工作流中，什么事情是你计划下一步需要自动化的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么写软件是困难的？是什么使软件的维护变得困难？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你更喜欢在全新项目（Green Field Project）上工作还是在已有项目(Brown Field Project)基础上工作？为什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当你在浏览器地址栏输入google.com回车之后都发生了什么?&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当操作系统CPU处于空闲的时候，它可能在处理哪些事情？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何向一个5岁的孩子解释什么是Unicode/数据库事务？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何维护单体架构(monolithic architecture)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个&quot;专业的开发者&quot;意味着什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软件开发是艺术、是技艺还是工程？你的观点是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&quot;喜欢这个的人也喜欢...&quot;，如何在一个电子商务商店里实现这种功能？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么在创新上，企业会比创业公司慢些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么说，你不应该尝试应用自己发明或者设计的密码学？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;设计模式相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;请用一个例子表明，全局对象是邪恶的存在。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设你工作的系统不支持事务性，你会如何从头开始实现它？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是好莱坞原则（Hollywood Principles）？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于迪米特法则(最少知识原则): 写一段代码违反它, 然后修复它。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（注: 迪米特法则：the Law of Demeter, 最少知识原则：the Principle of Least Knowledge）&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Active-Record模式有什么限制和缺陷？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Data-Mapper模式和Active-Record模式有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;空对象模式(Null Object Pattern)的目的是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么组合(Composition)比继承(Inheritance)更好？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是反腐败层(Anti-corruption Layer)?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你可以写一个线程安全的单例(Singleton)类吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据抽象(Data Abstraction)能力是指能改变实现而不影响客户端的这种能力。请构造一个一个例子，违反这个特性，并且尝试修复它。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你是如何处理依赖关系地狱(Dependency Hell)的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么说goto语句是恶魔般的存在？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;健壮性是进行软件设计时的一个通用原则，它建议 &lt;em&gt;“发送时要保守，接收时要开放”&lt;/em&gt;。这也经常被写成，“做一个有耐心的读者，做一个谨慎的作者”。你能解释一些这背后的逻辑吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;译者注：&quot;发送时要保守，接收时要开发&quot;的原文是：&quot;Be conservative in what you send, be liberal in what you accept&quot;，有点类似于“严于律己，宽于待人”的意味。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码设计相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;你在进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内聚和耦合的区别是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重构在哪些场景下有用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码中的注释有用吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计和架构有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么在测试驱动开发(TDD)中是先写测试，再写代码？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C++支持多继承，Java允许类实现多个接口。这些特性对正交性有什么影响？使用多继承和使用多接口有区别吗？[这个问题来自Andrew .Hunt 和 David Thomas写的《程序员修炼之道》]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在存储过程（Stored Procedures）中写业务逻辑有什么优缺点？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;语言相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;告诉我你的首选语言的三个最坏的缺陷。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么现在函数式编程这么越来越受关注？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;闭包是什么？它有什么用途？闭包和类有什么共同点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;泛型有什么用途？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是高阶函数？有什么用途？用你的首选语言写个例子出来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;讨论一下，如何写一个循环，然后把它转换成递归函数，要避免易变性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有些语言将函数视为第一公民，这是什么意思？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用一个例子说明匿名函数是有用的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是动态方法调度(Dynamic Method Dispatch)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;名字空间(Namespace)有什么用？有什么可以替代它的吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;谈谈Java和C#之间的互操作性(Interoperability) (任选其他两门语言都行)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么很多软件工程师不喜欢Java？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你认为好的语言好在哪里？差的语言差在哪里？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写两个函数，一个是&quot;引用透明的(Referentially Transparent)&quot;，另一个是&quot;引用不透明的(Referentially Opaque)&quot;。讨论之。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是栈？什么是堆？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么一个语言中，&quot;函数是第一公民&quot;是很重要的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模式匹配(Pattern Matching)和Switch语句(Switch clauses)的区别在哪儿？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么有些语言设计上没有异常机制？这有什么优缺点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果&lt;code&gt;Cat&lt;/code&gt;是一个&lt;code&gt;Animal&lt;/code&gt;, 那么&lt;code&gt;TaskCare&amp;lt;Cat&amp;gt;&lt;/code&gt;是一个&lt;code&gt;TakeCare&amp;lt;Animal&amp;gt;&lt;/code&gt;吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;web相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;为什么&quot;第一方cookie(first-party cookie)&quot;和&quot;第三方cookie(third-party cookie)&quot;被如此不同的对待？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据库相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果要你将一个项目从MySQL迁移至PostgreSQL中，你会如何迁移？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么&lt;code&gt;SELECT * FROM table WHERE field = null&lt;/code&gt;不能匹配空的字段？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是ACID(原子性，一致性，隔离性，持久性)原则？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你是如何进行数据库模式(Database schema)迁移的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;延迟加载(lazy loading)是如何实现的？什么场景下有用？他有什么缺陷？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是N+1问题？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何找出应用中开销最大的查询？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;非关系型数据库相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是最终一致性(Eventual Consistency)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于CAP理论，举一些CP、AP、CA系统的例子。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NoSQL是如何解决可伸缩性的挑战的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么情况下你会使用类似于MongoDB的文档数据库而不是关系型数据库（如Mysql或者PostgreSQL）？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码版本管理相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;为什么在Mercurial或者git中(管理)分支比SVN容易？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分散式版本控制系统（比如git），相比集中式版本控制系统（如svn）有哪些优势和劣势？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(注:集中式版本控制系统: Centralized Version Control Systems；分散式版本控制系统: Distributed Version Control Systems)&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;能描述一下什么是GitHubFlow和GitFlow工作流吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是rebase？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么合并操作(merge)在Mercurial和git中比在SVN和CVS中容易？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;并发问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;为什么我们需要并发呢？解释一下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么测试多线程/并发代码这么困难？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是竞争条件（Race Condition）？用任何一个语言写一个例子。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是死锁？用代码解释一下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是饿死？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是Wait-Free算法？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分布式系统相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;怎么测试一个分布式系统？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么场景下你会在两个系统中采用异步通信机制？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;远程过程调用的通用缺点是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你为了可扩展性和鲁棒性而构建一个分布式的系统，分别在封闭安全的网络环境情况下，和地理上的位置不同但是网络环境不是封闭和安全的情况下，你会考虑什么不同的事情？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在Web应用中如何管理容错性？在桌面端呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在分布式系统中，如何处理故障？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;让我们来谈谈网络分裂(network partitions)后有的几种恢复的手段吧。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你认为分布式计算中有哪些谬论？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你在什么时候会使用Request/Response模式，什么时候使用Publish/Subscribe模式？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;软件生命周期和团队管理相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是敏捷（Agility）？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你是如何处理遗留代码（Legacy Code）的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设我是你们公司的CEO，请向我解释什么是看板，并且说服我在它上面投资。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;敏捷（Agility）和瀑布（Waterfall）之间的最大区别是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;作为团队管理者，你对会议太多这个问题是如何处理的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你会如何处理延期很长时间了的项目？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&quot;&lt;em&gt;个体与交互重于过程和工具&lt;/em&gt;&quot;和&quot;&lt;em&gt;客户协作重于合同谈判&lt;/em&gt;&quot;占了敏捷宣言（Agile Manifesto）的一半，谈论一下这两个观念。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你是你们公司的CTO，你会采取什么样的决策？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你觉得项目经理有用吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果要你组织一个弹性工作制的开发团队（即没有强制工作时间的要求），并且假期制度是&quot;按需休假&quot;，你会如何做？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你会如何管理一个人员流动非常高的团队？如何在不加薪的条件下说服团队成员不要离开？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;除了代码之外，你最关注你的同事的哪3项素质？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于代码，你最希望非技术人员能知道的的三件事是什么？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逻辑和算法相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;只用LIFO栈如何构造一个FIFO队列？只用FIFO队列如何构造一个LIFO栈？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一段有栈溢出的代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一个尾递归版本的阶乘函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用任何一个语言，写一个REPL，功能是echo你输入的字符串。然后将它演化成一个逆波兰表达式的计算器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果需要你设计一个文件系统磁盘碎片整理程序，你会如何设计？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一个生成随机迷宫的程序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一段有内存泄漏的示例代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;随机生成一个的数字序列，里面每个数字都不同。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一个简单的垃圾回收系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用任何一门语言，写一个基本的消息代理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一个基础的web服务器，然后画一张线路图，展示你将来还想要实现的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何对一个10GB的文件进行排序？如果是10TB的数据，你会采用什么方法？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请实现&lt;code&gt;rnd()&lt;/code&gt;函数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;软件架构相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么情况下缓存是没用的，甚至是危险的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么事件驱动的架构能提高可扩展性(scalability)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么样的代码是可读性强的代码？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;紧急设计(Emergent Design)和演化架构(Evolutionary Architecture)之间的区别是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;横向扩展(scale out) vs 纵向扩展(scale up): 有什么区别？分别在什么场景下使用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式系统中如何处理&quot;故障切换(failover)&quot;和&quot;用户会话(user session)&quot;？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是CQRS(Command Query Responsibility Segregation)?他和最早的Command-Query Separation原则有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是三层架构？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何设计一个可扩展性高的系统？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;处理C10k问题的策略有哪些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果让你来设计一个去中心化的P2P系统，你会如何设计？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么CGI的扩展性不好？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在设计系统时，你如何防止供应商依赖(&lt;span&gt;Vendor Lock-in&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在可扩展性上，发布/订阅(Publish-Subscribe)模式有什么缺点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;80年代以后，CPU有哪些变化？这些变化，对编程产生了什么影响？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能生命周期(performace lifecycle)中，你认为哪个部分是需要考虑进去的？如何管理？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;除了恶意攻击造成的拒绝服务现象以外，哪些设计或者架构上的问题会导致拒绝服务？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能和可扩展性之间有什么关系？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么时候紧耦合是OK的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个系统要有什么特征才能适配云计算环境(Cloud Ready)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Does unity of design imply an aristocracy of architects?&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;面向服务架构(SOA)和微服务(Microservice)相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在SOA中，为什么长期存活的事务(Long-lived transation)不被看好，而Saga却被看好？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SOA和MicroService之间有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们来谈谈Web服务的版本管理、版本兼容性、重大变更管理这些事情吧.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在saga中事务和补偿操作(compensation operation)之间的区别是什么？在SOA中呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;微服务不能做得太&quot;微&quot;，你认为什么时候微服务太&quot;微&quot;了？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MicroService架构的优劣是什么？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;安全相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是双因素认证(Two Factor Authentication)？在一个已有的Web应用中，你如何实现这种机制？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;比尔盖茨式问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果你把一面镜子放在扫描仪上，会发生什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设有一个和你完全一样的克隆人，而他是你的上司，你愿意和他工作吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;现在请你面试一下我。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么Quora上的回答会比Yahoo Answer上的回答好？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对手是现代语言，你的任务是要为Cobol辩护，你会如何进行？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;10年后的你是什么样子？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设你是我老板，我被解雇了。你会如何通知我？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我想要重构一个系统，而你想要从头重写。我们来争论一下该怎么弄吧。然后我们反转角色，再争论一下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老板要你对公司撒谎，你的反应是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你可以穿越到以前，你会给年轻时候的你什么建议？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码示例问题:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;function &lt;span&gt;hookupevents&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++) {&lt;br/&gt;    document.getElementById(&lt;span&gt;&quot;button&quot;&lt;/span&gt; + i)&lt;br/&gt;      .addEventListener(&lt;span&gt;&quot;click&quot;&lt;/span&gt;, function() { &lt;br/&gt;        alert(i); &lt;br/&gt;      });&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;关于类型擦除(Type Erasure)，这段Java代码的输出是什么？为什么？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ArrayList&amp;lt;Integer&amp;gt; li = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;ArrayList&amp;lt;Float&amp;gt; lf = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Float&amp;gt;();&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (li.getClass() == lf.getClass()) &lt;span&gt;// evaluates to true&lt;/span&gt;&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;Equal&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Stack&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Object[] elements;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Stack&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        elements = &lt;span&gt;new&lt;/span&gt; Object[DEFAULT_INITIAL_CAPACITY];&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;push&lt;/span&gt;&lt;span&gt;(Object e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ensureCapacity();&lt;br/&gt;        elements[size++] = e;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (size == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; EmptyStackException();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; elements[--size];&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Ensure space for at least one more element, roughly&lt;br/&gt;     * doubling the capacity each time the array needs to grow.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ensureCapacity&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (elements.length == size)&lt;br/&gt;            elements = Arrays.copyOf(elements, &lt;span&gt;2&lt;/span&gt; * size + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;if&lt;/code&gt;语句，或者更加通用点，条件表达式通常是过程式编程/命令式编程的形式。你能去掉这段代码中的&lt;code&gt;switch&lt;/code&gt;语句，用面向对象的方式来修改这段代码吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Formatter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Service service;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Formatter&lt;/span&gt;&lt;span&gt;(Service service)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.service = service;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;doTheJob&lt;/span&gt;&lt;span&gt;(String theInput)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String response = service.askForPermission();&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt; (response) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;FAIL&quot;&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;error&quot;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;OK&quot;&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; String.format(&lt;span&gt;&quot;%s%s&quot;&lt;/span&gt;, theInput, theInput);&lt;br/&gt;        &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TheService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; FileHandler fileHandler;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; FooRepository fooRepository;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;TheService&lt;/span&gt;&lt;span&gt;(FileHandler fileHandler, FooRepository fooRepository)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.fileHandler = fileHandler;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.fooRepository = fooRepository;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;Execute&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; String file)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; String rewrittenUrl = fileHandler.getXmlFileFromFileName(file);&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; String executionId = fileHandler.getExecutionIdFromFileName(file);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((executionId == &lt;span&gt;&quot;&quot;&lt;/span&gt;) || (rewrittenUrl == &lt;span&gt;&quot;&quot;&lt;/span&gt;)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        Foo knownFoo = fooRepository.getFooByXmlFileName(rewrittenUrl);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (knownFoo == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; knownFoo.DoThat(file);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span/&gt;)&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    HRESULT error = S_OK;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(SUCCEEDED(Operation1()))&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(SUCCEEDED(Operation2()))&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(SUCCEEDED(Operation3()))&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt;(SUCCEEDED(Operation4()))&lt;br/&gt;                {&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;                {&lt;br/&gt;                    error = OPERATION4FAILED;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;            {&lt;br/&gt;                error = OPERATION3FAILED;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            error = OPERATION2FAILED;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        error = OPERATION1FAILED;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; error;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你是一个Golang面试官，你会问哪些问题？欢迎留言讨论。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;如果你是一个Golang面试官，你会问哪些问题？: &lt;span&gt;https://www.zhihu.com/question/67846139&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;面试题库收集: &lt;span&gt;https://www.yuque.com/go-interview/set/interview-index&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;https://draveness.me/golang/: &lt;span&gt;https://link.zhihu.com/?target=https%3A//draveness.me/golang/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;@arialdomartini: &lt;span&gt;https://link.zhihu.com/?target=https%3A//github.com/arialdomartini&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Back-End Developer Interview Questions: &lt;span&gt;https://link.zhihu.com/?target=https%3A//github.com/arialdomartini/Back-End-Developer-Interview-Questions&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;null reference: &lt;span&gt;https://link.zhihu.com/?target=http%3A//programmers.stackexchange.com/questions/12777/are-null-references-really-a-bad-thing&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;Continue Devivery: &lt;span&gt;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Continuous_delivery&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;当你在浏览器地址栏输入google.com回车之后都发生了什么?: &lt;span&gt;https://link.zhihu.com/?target=https%3A//github.com/alex/what-happens-when&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Vendor Lock-in: &lt;span&gt;https://link.zhihu.com/?target=https%3A//sourcemaking.com/antipatterns/vendor-lock-in&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>003ff2ee4c82de98be46b80ee29ed3bc</guid>
<title>[推荐] 时间轮原理及其在框架中的应用</title>
<link>https://toutiao.io/k/1dwwpfd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;28&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;作者：vivo互联网服务器团队-Li Wanghong&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、时间轮简介&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.1 为什么要使用时间轮&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在平时开发中，经常会与定时任务打交道。下面举几个定时任务处理的例子。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）心跳检测&lt;/strong&gt;。在Dubbo中，需要有心跳机制来维持Consumer与Provider的长连接，默认的心跳间隔是60s。当Provider在3次心跳时间内没有收到心跳响应，会关闭连接通道。当Consumer在3次心跳时间内没有收到心跳响应，会进行重连。Provider侧和Consumer侧的心跳检测机制都是通过定时任务实现的，而且是本篇文章要分析的时间轮HashedWheelTimer处理的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）超时处理&lt;/strong&gt;。在Dubbo中发起RPC调用时，通常会配置超时时间，当消费者调用服务提供者出现超时进行一定的逻辑处理。那么怎么检测任务调用超时了呢？我们可以利用定时任务，每次创建一个Future，记录这个Future的创建时间与超时时间，后台有一个定时任务进行检测，当Future到达超时时间并且没有被处理时，就需要对这个Future执行超时逻辑处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）Redisson分布式锁续期&lt;/strong&gt;。在分布式锁处理中，通常会指定分布式锁的超时时间，同样会在finally块里释放分布式锁。但是有一个问题时，通常分布式锁的超时时间不好判断，如果设置短了业务却没执行完成就把锁释放掉了，或者超时时间设置很长，同样也会存在一些问题。Redisson提供了一种看门狗机制，通过时间轮定时给分布式锁续期，也就是延长分布式锁的超时时间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以看到，上述几个例子都与定时任务有关，那么传统的定时任务有什么缺点呢？为什么要使用时间轮来实现？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;假如使用普通的定时任务处理机制来处理&lt;strong&gt;例2）&lt;/strong&gt;中的超时情况：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1）简单地，可以针对每一次请求创建一个线程，然后Sleep到超时时间，之后若判断超时则进行超时逻辑处理。存在的问题是如果面临是高并发请求，针对每个请求都要去创建线程，这样太耗费资源了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2）针对方案1的不足，可以改成一个线程来处理所有的定时任务，比如这个线程可以每隔50ms扫描所有需要处理的超时任务，如果发现有超时任务，则进行处理。但是，这样也存在一个问题，可能一段时间内都没有任务达到超时时间，那么就让CPU多了很多无用的轮询遍历操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对上述方案的不足，可以采用时间轮来进行处理。下面先来简单介绍下时间轮的概念。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;1.2 单层时间轮&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们先以单层时间轮为例，假设时间轮的周期是1秒，时间轮中有10个槽位，则每个槽位代表100ms。假设我们现在有3个任务，分别是任务A（220ms后执行）、B（410ms之后运行）、C（1930ms之后运行）。则这三个任务在时间轮所处的槽位如下图，可以看到任务A被放到了槽位2，任务B被放到了槽位4，任务C被放到了槽位9。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当时间轮转动到对应的槽时，就会从槽中取出任务判断是否需要执行。同时可以发现有一个剩余周期的概念，这是因为任务C的执行时间为1930ms，超过了时间轮的周期1秒，所以可以标记它的剩余周期为1，当时间轮第一次转动到它的位置时，发现它的剩余周期为1，表示还没有到要处理的时间，将剩余周期减1，时间轮继续转动，当下一次转动到C任务位置时，发现剩余周期为0，表示时间到了需要处理该定时任务了。Dubbo中采用的就是这种单层时间轮机制。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8234165067178503&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvoL7qrRAPH5Sjd5mXWGZYTdE1Dff4YUjYG60iagKEoTMl54fq1jGfc1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;521&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.3 多层时间轮&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;既然有单层时间轮，那么自然而然可以想到利用多层时间轮来解决上述任务执行时间超出时间轮周期的情况。下面以两层时间轮为例，第一层时间轮周期为1秒，第二层时间轮周期为10秒。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;还是以上述3个任务为例，可以看到任务A和B分布在第一层时间轮上，而任务C分布在第二层时间轮的槽1处。当第一层时间轮转动时，任务A和任务B会被先后执行。1秒钟之后，第一层时间轮完成了一个周期转动。从新开始第0跳，这时第二层时间轮从槽0跳到了槽1处，将槽1处的任务，也就是任务C取出放入到第一层时间轮的槽位9处，当第一层时间轮转动到槽位9处，任务C就会被执行。这种将第二层的任务取出放入第一层中称为降级，它是为了保证任务被处理的时间精度。Kafka内部就是采用的这种多层时间轮机制。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;301&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5205949656750573&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvArjABxkglzibdia54ficuEN81VNEvLAu5R2EBwxFNro15bVQsBpaIicocw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;874&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、时间轮原理&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面先来看一下Dubbo中的时间轮的结构，可以看到，它和时钟很像，它被划分成了一个个Bucket，每个Bucket有一个头指针和尾指针，分别指向双向链表的头节点和尾节点，双向链表中存储的就是要处理的任务。时间轮不停转动，当指向Bucket0所负责维护的双向链表时，就将它所存储的任务遍历取出来处理。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;405&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7009063444108762&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvMgiba9hibt6JoX2NGjmuAeml6DdMHzNCunDaI6QXQRg5NEJj0IYLzcrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面我们先来介绍下Dubbo中时间轮HashedWheelTimer所涉及到的一些核心概念，在讲解完这些核心概念之后，再来对时间轮的源码进行分析。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1 TimerTask&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在Dubbo中，TimerTask封装了要执行的任务，它就是上图双向链表中节点所封装的任务。所有的定时任务都需要继承TimerTask接口。如下图，可以看到Dubbo中的心跳任务HeartBeatTask、注册失败重试任务FailRegisteredTask等都实现了TimerTask接口。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TimerTask&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Timeout timeout)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;153&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.264&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvlBwPu6NhLhYN3ttTY9HJd2FRPEfrzzvsHujH2Qew9zfQlZyjPmf7JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 Timeout&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;TimerTask中run方法的入参是Timeout，Timeout与TimerTask一一对应，Timeout的唯一实现类HashedWheelTimeout中就封装了TimerTask属性，可以理解为HashedWheelTimeout就是上述双向链表的一个节点，因此它也包含两个HashedWheelTimeout类型的指针，分别指向当前节点的上一个节点和下一个节点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Timeout&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;Timer &lt;span class=&quot;code-snippet__title&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;TimerTask &lt;span class=&quot;code-snippet__title&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;isExpired&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;isCancelled&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelTimeout是Timeout的唯一实现，它的作用有两个：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面来看一下Timeout的实现类HashedWheelTimeout的核心字段与实现。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ST_INIT = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;、&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ST_CANCELLED = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;、&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ST_EXPIRED = &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   HashedWheelTimeout里定义了三种状态，分别表示任务的初始化状态、被取消状态、已过期状态&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) STATE_UPDATER&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   用于更新定时任务的状态&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) HashedWheelTimer timer&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   指向时间轮对象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;) TimerTask task&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   实际要执行的任务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; deadline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   指定时任务执行的时间，这个时间是在创建 HashedWheelTimeout 时指定的&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   计算公式是: currentTime(创建 HashedWheelTimeout 的时间) + delay(任务延迟时间)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             - startTime(HashedWheelTimer 的启动时间)，时间单位为纳秒&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; state = ST_INIT&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   任务初始状态&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;7&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; remainingRounds&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   指当前任务剩余的时钟周期数. 时间轮所能表示的时间长度是有限的， 在任务到期时间与当前时刻&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   的时间差超过时间轮单圈能表示的时长，就出现了套圈的情况，需要该字段值表示剩余的时钟周期&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;) HashedWheelTimeout next、HashedWheelTimeout prev&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   分别对应当前定时任务在链表中的前驱节点和后继节点，这也验证了时间轮中每个槽所对应的任务链表是&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   一个双链表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;9&lt;/span&gt;) HashedWheelBucket bucket&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮中的一个槽，对应时间轮圆圈的一个个小格子，每个槽维护一个双向链表，当时间轮指针转到当前&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   槽时，就会从槽所负责的双向链表中取出任务进行处理&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelTimeout提供了remove操作，可以从双向链表中移除当前自身节点，并将当前时间轮所维护的定时任务数量减一。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    HashedWheelBucket bucket = &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.bucket;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (bucket != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket.&lt;span class=&quot;code-snippet__keyword&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timer.pendingTimeouts.decrementAndGet();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelTimeout提供了cancel操作，可以取消时间轮中的定时任务。当定时任务被取消时，它会首先被暂存到canceledTimeouts队列中。在时间轮转动到槽进行任务处理之前和时间轮退出运行时都会调用cancel，而cancel会调用remove，从而清理该队列中被取消的定时任务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; boolean cancel() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!compareAndSetState(ST_INIT, ST_CANCELLED)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    timer.cancelledTimeouts.add(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelTimeout提供了expire操作，当时间轮指针转动到某个槽时，会遍历该槽所维护的双向链表，判断节点的状态，如果发现任务已到期，会通过remove方法移除，然后调用expire方法执行该定时任务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;expire&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!compareAndSetState(ST_INIT, ST_EXPIRED)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        task.run(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.3 HashedWheelBucket&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;前面也介绍过了，它是时间轮中的槽，它内部维护了双向链表的首尾指针。下面我们来看一下它内部的核心资源和实现。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;1) HashedWheelTimeout head、HashedWheelTimeout tail&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   指向该槽所维护的双向链表的首节点和尾节点&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelBucket提供了addTimeout方法，用于添加任务到双向链表的尾节点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;addTimeout&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(HashedWheelTimeout timeout)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;assert&lt;/span&gt; timeout.bucket == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    timeout.bucket = &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (head == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        head = tail = timeout;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        tail.next = timeout;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timeout.prev = tail;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        tail = timeout;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelBucket提供了remove方法，用于从双向链表中删除指定节点。核心逻辑如下图所示，根据要删除的节点找到其前置节点和后置节点，然后分别调整前置节点的next指针和后置节点的prev指针。删除过程中需要考虑一些边界情况。删除之后将pendingTimeouts，也就是当前时间轮的待处理任务数减一。remove代码逻辑较简单，这边就不贴代码了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;259&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.44880546075085326&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvjNKodCNcQugf5JQlFp2yQoibg2aw3SnCcsw8IkbeS9vEf7QcicFWX7Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;586&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelBucket提供了expireTimeouts方法，当时间轮指针转动到某个槽时，通过该方法处理该槽上双向链表的定时任务，分为3种情况：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;定时任务已到期，则会通过remove方法取出，并调用其expire方法执行任务逻辑。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;定时任务已被取消，则通过remove方法取出直接丢弃。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;定时任务还未到期，则会将remainingRounds（剩余时钟周期）减一。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;expireTimeouts&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; deadline&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    HashedWheelTimeout timeout = head;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (timeout != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HashedWheelTimeout next = timeout.next;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout.remainingRounds &amp;lt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            next = &lt;span class=&quot;code-snippet__keyword&quot;&gt;remove&lt;/span&gt;(timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout.deadline &amp;lt;= deadline) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                timeout.expire();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout.isCancelled()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            next = &lt;span class=&quot;code-snippet__keyword&quot;&gt;remove&lt;/span&gt;(timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            timeout.remainingRounds--;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timeout = next;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelBucket也提供了clearTimeouts方法，该方法会在时间轮停止的时候被使用，它会遍历并移除所有双向链表中的节点，并返回所有未超时和未被取消的任务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.4 Worker&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Worker实现了Runnable接口，时间轮内部通过Worker线程来处理放入时间轮中的定时任务。下面先来看一下它的核心字段和run方法逻辑。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;1) &lt;span class=&quot;code-snippet__keyword&quot;&gt;Set&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;Timeout&lt;/span&gt;&amp;gt; unprocessedTimeouts&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   当时间轮停止时，用于存放时间轮中未过期的和未被取消的任务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; tick&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮指针，指向时间轮中某个槽，当时间轮转动时该tick会自增&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;729&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.26171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvpuyqYmHbpeG02qJOSrNo4pp7FPsn8nw4jgpqoem0O62GIDkI5rXDPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    startTime = System.nanoTime();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    startTimeInitialized.countDown();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;do&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        final &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; deadline = waitForNextTick();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (deadline &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; idx = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;) (tick &amp;amp; mask);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            processCancelledTasks();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            HashedWheelBucket bucket = wheel[idx];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            transferTimeoutsToBuckets();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            bucket.expireTimeouts(deadline);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            tick++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (WORKER_STATE_UPDATER.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(HashedWheelTimer.&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    == WORKER_STATE_STARTED);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (HashedWheelBucket bucket : wheel) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket.clearTimeouts(unprocessedTimeouts);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (; ; ) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HashedWheelTimeout timeout = timeouts.poll();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!timeout.isCancelled()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            unprocessedTimeouts.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    processCancelledTasks();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面对run方法中涉及到的一些方法进行介绍：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）waitForNextTick&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;逻辑比较简单，它会判断有没有到达处理下一个槽任务的时间了，如果还没有到达则sleep一会。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）processCancelledTasks&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;遍历cancelledTimeouts，获取被取消的任务并从双向链表中移除。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processCancelledTasks&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (; ; ) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HashedWheelTimeout timeout = cancelledTimeouts.poll();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timeout.&lt;span class=&quot;code-snippet__keyword&quot;&gt;remove&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3）transferTimeoutsToBuckets&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当调用newTimeout方法时，会先将要处理的任务缓存到timeouts队列中，等时间轮指针转动时统一调用transferTimeoutsToBuckets方法处理，将任务转移到指定的槽对应的双向链表中，每次转移10万个，以免阻塞时间轮线程。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;transferTimeoutsToBuckets&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;100000&lt;/span&gt;; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HashedWheelTimeout timeout = timeouts.poll();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout.state() == HashedWheelTimeout.ST_CANCELLED) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; calculated = timeout.deadline / tickDuration;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timeout.remainingRounds = (calculated - tick) / wheel.length;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; ticks = Math.max(calculated, tick);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; stopIndex = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;) (ticks &amp;amp; mask);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HashedWheelBucket bucket = wheel[stopIndex];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket.addTimeout(timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.5 HashedWheelTimer&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最后，我们来分析时间轮HashedWheelTimer，它实现了Timer接口，提供了newTimeout方法可以向时间轮中添加定时任务，该任务会先被暂存到timeouts队列中，等时间轮转动到某个槽时，会将该timeouts队列中的任务转移到某个槽所负责的双向链表中。它还提供了stop方法用于终止时间轮，该方法会返回时间轮中未处理的任务。它也提供了isStop方法用于判断时间轮是否终止了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;先来看一下HashedWheelTimer的核心字段。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) HashedWheelBucket[] wheel&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   该数组就是时间轮的环形队列，数组每个元素都是一个槽，一个槽负责维护一个双向链表，用于存储定时&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   任务。它会被在构造函数中初始化，当指定为n时，它实际上会取最靠近n的且为&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;的幂次方值。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) Queue&amp;lt;HashedWheelTimeout&amp;gt; timeouts&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   timeouts用于缓存外部向时间轮提交的定时任务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) Queue&amp;lt;HashedWheelTimeout&amp;gt; cancelledTimeouts&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   cancelledTimeouts用于暂存被取消的定时任务，时间轮会在处理槽负责的双向链表之前，先处理这两&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   个队列中的数据。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;) Worker worker&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮处理定时任务的逻辑&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;) Thread workerThread&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮处理定时任务的线程&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;) AtomicLong pendingTimeouts&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮剩余的待处理的定时任务数量&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;7&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; tickDuration&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮每个槽所代表的时间长度&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; workerState&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮状态，可选值有init、started、shut down&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面来看一下时间轮的构造函数，用于初始化一个时间轮。首先它会对传入参数ticksPerWheel进行转换处理，返回大于该值的2的幂次方，它表示时间轮上有多少个槽，默认是512个。然后创建大小为该值的HashedWheelBucket[]数组。接着通过传入的tickDuration对时间轮的tickDuration赋值，默认是100ms。节通过threadFactory创建workerThread工作线程，该线程就是负责处理时间轮中的定时任务的线程。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;HashedWheelTimer&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;ThreadFactory threadFactory,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; tickDuration, TimeUnit unit,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ticksPerWheel,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; maxPendingTimeouts&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    wheel = createWheel(ticksPerWheel);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mask = wheel.length - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.tickDuration = unit.toNanos(tickDuration);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    workerThread = threadFactory.newThread(worker);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.maxPendingTimeouts = maxPendingTimeouts;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; HashedWheelBucket[] &lt;span class=&quot;code-snippet__title&quot;&gt;createWheel&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ticksPerWheel&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    HashedWheelBucket[] wheel = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashedWheelBucket[ticksPerWheel];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; wheel.length; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        wheel[i] = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashedWheelBucket();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; wheel;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;初始化时间轮之后，就可以向其中提交定时任务了，可以通过时间轮提供的newTimeout方法来完成。首先将待处理的任务数量加1，然后启动时间轮线程，这时worker的run方法就会被系统调度运行。然后将该定时任务封装成HashedWheelTimeout加入到timeouts队列中。start之后，时间轮就开始运行起来了，直到外界调用stop方法终止退出。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; Timeout &lt;span class=&quot;code-snippet__title&quot;&gt;newTimeout&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;TimerTask task, &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; delay, TimeUnit unit&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; pendingTimeoutsCount = pendingTimeouts.incrementAndGet();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; deadline = System.nanoTime() + unit.toNanos(delay) - startTime;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    HashedWheelTimeout timeout = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashedWheelTimeout(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;, task, deadline);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    timeouts.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; timeout;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;start&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;switch&lt;/span&gt; (WORKER_STATE_UPDATER.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; WORKER_STATE_INIT:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (WORKER_STATE_UPDATER.compareAndSet(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     WORKER_STATE_INIT, WORKER_STATE_STARTED)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                workerThread.start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; WORKER_STATE_STARTED:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; WORKER_STATE_SHUTDOWN:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Error(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Invalid WorkerState&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (startTime == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            startTimeInitialized.&lt;span class=&quot;code-snippet__keyword&quot;&gt;await&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException ignore) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、时间轮应用&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;到这里，Dubbo中的时间轮原理就分析完了。接下来呼应本文开头的三个例子，结合它们来分析下时间轮在Dubbo或Redisson中是如何使用的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）HeartbeatTimerTask&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在Dubbo的HeaderExchangeClient类中会向时间轮中提交该心跳任务。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;startHeartBeatTask&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;URL url&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!client.canHandleIdle()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        AbstractTimerTask.ChannelProvider cp =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          () -&amp;gt; Collections.singletonList(HeaderExchangeClient.&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; heartbeat = getHeartbeat(url);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; heartbeatTick = calculateLeastDuration(heartbeat);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.heartBeatTimerTask =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HeartbeatTimerTask(cp, heartbeatTick, heartbeat);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        IDLE_CHECK_TIMER.newTimeout(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; HashedWheelTimer IDLE_CHECK_TIMER =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                              &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashedWheelTimer(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; NamedThreadFactory(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;dubbo-client-idleCheck&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;), &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, TimeUnit.SECONDS, TICKS_PER_WHEEL);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;doTask&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Long lastRead = lastRead(channel);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Long lastWrite = lastWrite(channel);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; ((lastRead != &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; now() - lastRead &amp;gt; heartbeat)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            || (lastWrite != &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; now() - lastWrite &amp;gt; heartbeat)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Request req = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Request();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            req.setVersion(Version.getProtocolVersion());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            req.setTwoWay(&lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            req.setEvent(HEARTBEAT_EVENT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            channel.send(req);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2）Redisson锁续期机制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当获取锁成功后，Redisson会封装一个锁续期任务放入时间轮中，默认10s检查一下，用于对获取到的锁进行续期，延长持有锁的时间。如果业务机器宕机了，那么该续期的定时任务也就没法跑了，就没法续期了，那等加锁时间到了锁就自动释放了。逻辑封装在RedissonLock中的renewExpiration()方法中。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;194&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3363886342804766&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvd2SgvYgR98dCAEVAYibSSxpib3gIOaoMjJNpJzw1HtuB0G5Hbt2ZcGKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1091&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; void renewExpiration() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(getEntryName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (ee == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; void run(Timeout timeout) throws Exception {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(getEntryName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (ent == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;Long&lt;/span&gt; threadId = ent.getFirstThreadId();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (threadId == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            RFuture&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Boolean&lt;/span&gt;&amp;gt; future = renewExpirationAsync(threadId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            future.onComplete((res, e) -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (e != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    log.error(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Can&#x27;t update lock &quot;&lt;/span&gt; + getName() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; expiration&quot;&lt;/span&gt;, e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (res) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    renewExpiration();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }, internalLockLeaseTime / &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;, TimeUnit.MILLISECONDS);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ee.setTimeout(task);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; RFuture&amp;lt;Boolean&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;renewExpirationAsync&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; threadId&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;return 1; &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;end; &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;return 0;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          Collections.singletonList(getName()),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          internalLockLeaseTime, getLockName(threadId));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3）超时重试&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;使用方式和HeartbeatTimerTask方式类似，读者可以自己动手去分析下它是在哪里被引入的。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在本篇文章中，先是举了3个例子来论述为什么需要使用时间轮，使用时间轮的优点，在文末处也分别对这3个例子在Dubbo或Redisson中的使用做了介绍。接着通过画图讲解了单层时间轮与多层时间轮机制，让读者对时间轮算法有了一个简单的认识。在第二部分，依次讲解了Dubbo时间轮中涉及到的TimerTask、Timeout、HashedWheelBucket、Worker、HashedWheelTimer，分析了它们的原理与源码实现。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:117.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ef837d0286ce7a1866ce8c839df10d49</guid>
<title>[推荐] 你管这破玩意儿叫高可用</title>
<link>https://toutiao.io/k/qudsbeg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;今天我们来聊一下互联网三高（高并发、高性能、高可用）中的高可用，看完本文相信能解开你关于高可用设计的大部分困惑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高可用（High availability，即 HA）的主要目的是为了保障「业务的连续性」，即在用户眼里，业务永远是正常（或者说基本正常）对外提供服务的。高可用主要是针对架构而言，那么要做好高可用，就要首先设计好架构，第一步我们一般会采用分层的思想将一个庞大的 IT 系统拆分成为应用层，中间件，数据存储层等独立的层，每一层再拆分成为更细粒度的组件，第二步就是让每个组件对外提供服务，毕竟每个组件都不是孤立存在的，都需要互相协作，对外提供服务才有意义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要保证架构的高可用，就要保证架构中所有组件以及其对外暴露服务都要做高可用设计，任何一个组件或其服务没做高可用，都意味着系统存在风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么这么多组件该怎么做高可用设计呢，其实任何组件要做高可用，都离不开「冗余」和「自动故障转移」，众所周知单点是高可用的大敌，所以组件一般是以集群（至少两台机器）的形式存在的，这样只要某台机器出现问题，集群中的其他机器就可以随时顶替，这就是「冗余」。简单计算一下，假设一台机器的可用性为 90%，则两台机器组成的集群可用性为 1-0.1*0.1 = 99%，所以显然冗余的机器越多，可用性越高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但光有冗余还不够，如果机器出现问题，需要人工切换的话也是费时费力，而且容易出错，所以我们还需要借助第三方工具（即仲裁者）的力量来实现「自动」的故障转移，以达到实现&lt;/span&gt;&lt;span&gt;近实时&lt;/span&gt;&lt;span&gt;的故障转移的目的，&lt;/span&gt;&lt;span&gt;近实时的故障转移才是高可用的主要意义&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;怎样的系统可以称之为高可用呢，业界一般用几个“九”来衡量系统的可用性，如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6686103012633625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxECjvy7L8AZicH8XP4AbRqRxpFgsx4rKKOTOmCL4lL9I6QzGdh2yvZgeN7kX6qd3px0MLvjibfGauA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1029&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般实现两个 9 很简单，毕竟每天宕机 14 分钟已经严重影响业务了，这样的公司迟早歇菜，大厂一般要求 4 个 9，其他要求严苛的业务要达到五个九以上，比如如果因为一个电脑的故障导致所有列车停驶，那么就会有数以万计的人正常生活受到阻碍，这种情况就要求五个九以上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们就来一起看看架构中的各个组件如何借助「冗余」和「自动故障转移」来实现高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 互联网架构剖析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前多数互联网都会采用微服务架构，常见架构如下:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9707792207792207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFF2y5qicTib6bSVPvebnjeAzMMqAWTWB2r5Bx5Vwz2THY50RIic1nBMmgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;924&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到架构主要分以下几层：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;接入层&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要由 F5 硬件或 LVS 软件来承载所有的流量入口；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;反向代理层&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Nginx，主要负责根据 URL 来分发流量，限流等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;网关&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要负责流控、风控、协议转换等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;站点层&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要负责调用会员，促销等基本服务来装配 JSON 等数据并返回给客户端；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;基础 service&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：其实与站点层都属于微服务，是平级关系，只不过基础 service 属于基础设施，能被上层的各个业务层 server 调用而已；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;存储层&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：也就是 DB，如 MySQL、Oracle 等，一般由基础 service 调用返回给站点层；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;中间件&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：ZK、ES、Redis、MQ 等，主要起到加速访问数据等功能，在下文中我们会简单介绍下各个组件的作用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如前所述，要实现整体架构的高可用，必须要实现每一层组件的高可用，接下来我们就来分别看一下每一层的组件都是如何实现高可用的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 接入层 &amp;amp; 反向代理层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这两层的高可用都和 keepalived 有关，所以我们结合起来一起看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0052447552447552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFVgylNIdGrhDkSF8FibpNr6eoUGjEibuCFm4bmcz5ibszdZ6XefKTwG9LA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;572&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对外，两个 LVS 以主备的形式对外提供服务，注意只有 master 在工作（即此时的 VIP 在 master 上生效），另外一个 backup 在 master 宕机之后会接管 master 的工作，那么 backup 怎么知道 master 是否正常呢？答案是通过 keepalived，在主备机器上都装上 keepalived 软件，启动后就会通过心跳检测彼此的健康状况，一旦  master 宕机，keepalived 会检测到，从而 backup 自动转成 master 对外提供服务，此时 VIP 地址（即图中的 115.204.94.139）即在 backup 上生效，也就是我们常说的「IP漂移」，通过这样的方式即解决了 LVS 的高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;keepalived 的心跳检测主要通过发送 ICMP 报文，或者利用 TCP 的端口连接和扫描检测来检测的，同样的，它也可以用来检测 Nginx 暴露的端口，这样的话如果某些 Nginx 不正常 Keepalived 也能检测到并将其从 LVS 能转发的服务列表中剔出。Nginx也能通过端口检测服务健康状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;借用 keepalived 这个第三方工具，同时实现了 LVS 和 Nginx 的高可用，同时在出现故障时也可以将宕机情况发送到对应开发人员的邮箱以让他们及时收到通知处理，确实很方便，Keepalived 应用广泛，下文我们会看到它也可以用在 MySQL 上来实现 MySQL 的高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 微服务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们再来看一下「网关」、「站点层」、「基础服务层」，这三者一般就是我们所说的微服务架构组件。当然这些微服务组件还需要通过一些 RPC 框架如 Dubbo 来支撑才能通信，所以微服务要实现高可用，就意味着 Dubbo 这些 RPC 框架也要提供支撑微服务高可用的能力，我们就以 Dubbo 为例来看下它是如何实现高可用的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来简单地看下 Dubbo 的基本架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7773584905660378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFvmiaryD4ebUrFo6Be22J24afz1w72oyUlyOemjYH7ZBccsV5RpcyCMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;思路也很简单，首先是 Provider（服务提供者）向 Registry（注册中心，如 ZK 或 Nacos 等）注册服务，然后 Consumer（服务消费者）向注册中心订阅和拉取 Provider 服务列表，获取服务列表后，Consumer 就可以根据其负载均衡策略选择其中一个  Provider 来向其发出请求，当其中某个 Provider 不可用（下线或者因为 GC 阻塞等）时，会被注册中心及时监听（通过心跳机制）到，也会及时推送给 Consumer，这样 Consumer 就能将其从可用的 Provider 列表中剔除，也就实现了故障的自动转移，不难看出，注册中心就起到了类似 keepalived 的作用。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. 中间件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们再来看下这些中间件如 ZK、Redis 等是如何实现高可用的呢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.1 ZooKeeper（ZK）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4/&gt;&lt;h4/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上一节微服务中我们提到了注册中心，那我们就以 ZK 为例来看看它的高可用是如何实现的，先来看下它的整体架构图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGF48MtucWD8DPMCz0mfjqytSlSvljubib3ia1xIR6La51orJIssR1ISmZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zookeeper 中的主要角色如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即领导者，在集群中只有一个 Leader，主要承担了以下的功能：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事务请求的唯一调度和处理者，保证集群事务处理的顺序性，所有 Follower 的写请求都会转给 Leader 执行，用来保证事务的一致性；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;集群内部各服务器的调度者：处理好事务请求后，会将数据广播同步到各个 Follower，统计 Follower 写入成功的数量，超过半数 Follower 写入成功，Leader 就会认为写请求提交成功，通知所有的 Follower commit 这个写操作，保证事后哪怕是集群崩溃恢复或者重启，这个写操作也不会丢失。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Follower&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;处理客户端非事务请求、转发事务请求给 leader 服务器；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参与事物请求 Proposal 的投票（需要半数以上服务器通过才能通知 leader commit 数据; Leader 发起的提案，要求 Follower 投票）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参与 Leader 选举的投票。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;画外音：Zookeeper 3.0 之后新增了一种 Observer 的角色，不过与此处讨论的 ZK 高可用关系不是很大，为了简化问题，所以省略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到由于只有一个 Leader，很显然，此 Leader 存在单点隐患，那么 ZK 是怎么解决此问题的呢，首先 Follower 与 Leader 会用心跳机制保持连接，如果 Leader 出现问题了（宕机或者因为 FullGC 等原因无法响应），Follower 就无法感知到 Leader 的心跳，就会认为 Leader 出问题了，于是它们就会发起投票选举，最终在多个 Follower 中选出一个 Leader 来（这里主要用到了 Zookeeper Atomic Broadcast，即 ZAB 协议，它是为 ZK 专门设计的一种支持崩溃恢复的一致性协议），选举的细节不是本文重点，就不在此详述了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了 ZAB 协议，业界上常用的还有 Paxos，Raft 等协议算法，也可以用在 Leader 选举上，也就是是在分布式架构中，这些协议算法承担了“第三者”也就是仲裁者的作用，以承担故障的自动转移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.2 Redis&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis 的高可用需要根据它的部署模式来看看，主要分为「主从模式」和「Cluster 分片模式」两种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;主从模式&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先来看一下主从模式，架构如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0134529147982063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFFWlG0mOU7CGJ7PocwSNywKzyqLicoR0dPFSGYSZxeyqpyz4vBib9j39g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;446&quot; title=&quot;主从模式&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;主从模式&lt;/span&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;主从模式即一主多从（一个或者多个从节点），其中主节点主要负责读和写，然后会将数据同步到多个从节点上，Client 也可以对多个从节点发起读请求，这样可以减轻主节点的压力，但和 ZK 一样，由于只有一个主节点，存在单点隐患，所以必须引入第三方仲裁者的机制来判定主节点是否宕机以及在判定主节点宕机后快速选出某个从节点来充当主节点的角色，这个第三方仲裁者在 Redis 中我们一般称其为「哨兵」（sentinel），当然哨兵进程本身也有可能挂掉，所以为了安全起见，需要部署多个哨兵（即哨兵集群）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4821428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFjCMq4hjcVibRr7ODrhBwMJG1wfAJOaO3F5VGpJ9GyEAgTWhM1yPyEAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;504&quot; title=&quot;哨兵集群&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;哨兵集群&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些哨兵通过 Gossip（流言） 协议来接收关于主服务器是否下线的信息，并在判定主节点宕机后使用 Raft 协议来选举出新的主节点。&lt;/span&gt;&lt;/p&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;Cluster 分片集群&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主从模式看似完美，但存在以下几个问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主节点写的压力难以降低：因为只有一个主节点能接收写请求，如果在高并发的情况下，写请求如果很高的话可能会把主节点的网卡打满，造成主节点对外无法服务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主节点的存储能力受到单机存储容量的限制：因为不管是主节点还是从节点，存储的都是全量缓存数据，那么随着业务量的增长，缓存数据很可能直线上升，直到达到存储瓶颈；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;同步风暴：因为数据都是从 master 同步到 slave 的，如果有多个从节点的话，master 节点的压力会很大。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决主从模式的以上问题，分片集群应运而生，所谓分片集群即将数据分片，每一个分片数据由相应的主节点负责读写，这样的话就有多个主节点来分担写的压力，并且每个节点只存储部分数据，也就解决了单机存储瓶颈的问题，但需要注意的是每个主节点都存在单点问题，所以需要针对每个主节点做高可用，整体架构如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.731457800511509&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGF14icPLDKtw0iagY9sFicsZrFDibZESUInZXgbAq2J6iaaAtF7z6EEWiaoIOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原理也很简单，在 Proxy 收到 client 执行的 redis 的读写命令后，首先会对 key 进行计算得出一个值，如果这个值落在相应 master 负责的数值范围（一般将每个数字称为槽，Redis 一共有 16384 个槽）之内，那就把这条 redis 命令发给对应的 master 去执行，可以看到每个 master 节点只负责处理一部分的 redis 数据，同时为了避免每个 master 的单点问题，也为其配备了多个从节点以组成集群，当主节点宕机时，集群会通过 Raft 算法来从从节点中选举出一个主节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.3 Elasticsearch（ES）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再来看一下 ES 是如何实现高可用的，在 ES 中，数据是以分片（Shard）的形式存在的。如下图所示，一个节点中索引数据共分为三个分片存储：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4613259668508287&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFicqfXTgHCVicUOE5iaLX0J1ogI140QfpkaQGCRAW6U52VNXeq3gj4DPtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;362&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但只有一个节点的话，显然存在和 Redis 的主从架构一样的单点问题，这个节点挂了，ES 也就挂了，所以显然需要创建多个节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46344086021505376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFYLmibg8rMgib2wCwcTicmiaoElKcI3ZnR5UrkHTxaOAFAjg4OAmfQ7h20g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;930&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一旦创建了多个节点，分片（图中 P 为主分片，R 为副本分片）的优势就体现出来了，可以将分片数据分布式存储到其它节点上，极大提升了数据的水平扩展能力，同时每个节点都能承担读写请求，采用负载均衡的形式避免了单点的读写压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ES 的写机制与 Redis 和 MySQL 的主从架构有些差别（后两者的写都是直接向 master 节点发起写请求，而 ES 则不是），所以这里稍微解释一下 ES 的工作原理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先说下节点的工作机制，节点（Node）分为主节点（Master Node）和从结点（Slave Node），主节点的主要职责是负责集群层面的相关操作，管理集群变更，如创建或删除索引，跟踪哪些节点是集群的一部分，并决定哪些分片分配给相关的节点，主节点也只有一个，一般通过类 Bully 算法来选举出来，如果主节点不可用了，则其他从节点也可以通过此算法来选举以实现集群的高可用，任何节点都可以接收读写请求以达到负载均衡的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再说一下分片的工作原理，分片分为主分片（Primary Shard，即图中 P0，P1，P2）和副本分片（Replica Shard，即图中 R0，R1，R2），主分片负责数据的写操作，所以虽然任何节点可以接收读写请求，但如果此节点接收的是写请求并且没有写数据所在的主分片话，此节点会将写请求调度到主分片所在的节点上，写入主分片后，主分片再把数据复制到其他节点的副本分片上，以有两个副本的集群为例，写操作如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3515704154002026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGF693SL8F4eVU8zOQjwcndJIKL38DBIp1ThXwpnDZjSicvibq8N8N0zEcQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;987&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.4 Message Queue（MQ）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ES 利用数据分片来提升高可用和水平扩展能力的思想也应用在其他组件的架构设计上，我们以 MQ 中的 Kafka 为例再来看下数据分片的应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6520833333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGF5QticRNDibRbvK5yY68X5bXiaUKboEibtbFBfVHhPBoUXg5K3B17WXkGyw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot; title=&quot;Kafka 高可用设计，图片来自《武哥漫谈IT》&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;Kafka 高可用设计，图片来自《武哥漫谈IT》&lt;/span&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;如上是 Kafka 集群，可以看到每个 Topic 的 Partition 都分布式存储在其它消息服务器上，这样一旦某个 Partition 不可用，可以从 follower 中选举出 leader 继续服务，不过与 ES 中的数据分片不同的是，follower Partition 属于冷备，也就是说在正常情况下不会对外服务，只有在 leader 挂掉之后从 follower 中选举出 leader 后它才能对外提供服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5. 存储层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们再来看一下最后一层，存储层（DB），这里我们以 MySQL 为例来简单地讨论一下其高可用设计，其实大家如果看完了以上的高可用设计，会发现 MySQL 的高可用也不过如此，思想都是类似的，与 Redis 类似，它也分主从和分片（即我们常说的分库分表）两种架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主从的话与 LVS 类似，一般使用 keepalived 的形式来实现高可用，如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.647766323024055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFgHR6pzBAx1fEzzgiaaax5JBlcWFXOz4uiaNBBBGlX2YYzGngfYOCpKBg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;582&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果 master 宕机了，Keepalived 也会及时发现，于是从库会升级主库，并且 VIP 也会“漂移”到原从库上生效，所以说大家在工程配置的 MySQL 地址一般是 VIP 以保证高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据量大了之后就要分库分表了，于是就有了多主，就像 Redis 的分片集群一样，需要针对每个主配备多个从，如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5478170478170478&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFmmhvFuzrI226JU1zyEKGwOdvecu8iaLXLVw2Cko1p5ppByw4Hd8k8tw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;962&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之前有读者问分库分表之后为啥还要做主从，现在我想大家应该都明白了，不是为了解决读写性能问题，主要是为了实现高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完了架构层面的高可用设计，相信大家对高可用的核心思想「冗余」和「自动故障转移」会有更深刻的体会，观察以上架构中的组件你会发现冗余的主要原因是因为只有一主，为什么不能有多主呢，也不是不可以，但这样在分布式系统下要保证数据的一致性是非常困难的，尤其是节点多了的话，数据之间的同步更是一大难题，所以多数组件采用一主的形式，然后再在主和多从之间同步，多数组件之所以选择一主本质上是技术上的 tradeoff。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么做好每个组件的高可用之后是否整个架构就真的可用了呢，非也，这只能说迈出了第一步，在生产上还有很多突发情况会让我们的系统面临挑战，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;瞬时流量问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：比如我们可能会面临秒杀带来的瞬时流量激增导致系统的承载能力被压垮，这种情况可能影响日常交易等核心链路，所以需要做到系统之间的隔离，如单独为秒杀部署一套独立的集群；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;安全问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：比如 DDOS 攻击，爬虫频繁请求甚至删库跑路等导致系统拒绝服务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;代码问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：比如代码 bug 引起内存泄露导致 FullGC 导致系统无法响应等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;部署问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在发布过程中如果贸然中止当前正在运行的服务也是不行的，需要做到优雅停机，平滑发布；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三方问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：比如我们之前的服务依赖第三方系统，第三方可能出问题导致影响我们的核心业务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;不可抗力&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：如机房断电，所以需要做好容灾，异地多活，之前我司业务就由于机房故障导致服务四小时不可用，损失惨重。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以除了做好架构的高可用之外，我们还需要在做好系统隔离，限流，熔断，风控，降级，对关键操作限制操作人权限等措施以保证系统的可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里特别提一下降级，这是为了保证系统可用性采取的常用的措施，简单举几个例子：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们之前对接过一个第三方资金方由于自身原因借款功能出了问题导致无法借款。这种情况为了避免引起用户恐慌，于是我们在用户申请第三方借款的时候返回了一个类似「为了提升你的额度，资金方正在系统升级」这样的文案，避免了客诉；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在流媒体领域，当用户观看直播出现严重卡顿时，很多企业的第一选择不是查 log 排查问题，而是为用户自动降码率。因为比起画质降低，卡得看不了显然会让用户更痛苦；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;双十一零点高峰期，我们把用户的注册登录等非核心功能给停掉了，以保证下单等核心流程的顺利。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外我们最好能做到事前防御，在系统出问题前把它扼杀在摇篮里，所以我们需要做单元测试，做全链路压测等来发现问题，还需要针对 CPU，线程数等做好&lt;strong&gt;监控&lt;/strong&gt;，当其达到我们设定的域值时就触发告警以让我们及时发现修复问题（我司之前就碰到过一个类似的&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651486188&amp;amp;idx=1&amp;amp;sn=46cc45885e42c0d5028359ba85193eca&amp;amp;chksm=bd251b938a529285c1ade09ffeac58fc88e997b02c028cd911514861e278b243efdc4e26b9e1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍生产事故复盘‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;生产事故复盘&lt;/span&gt;&lt;/a&gt;&lt;span&gt;大家可以看一下），此外在做好单元测试的前提下，依然有可能因为代码的潜在 bug 引起线上问题，所以我们需要在关键时间（比如双十一期间）封网（也就是不让发布代码）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外我们还需要在出事后能快速定位问题，快速回滚，这就需要记录每一次的发布时间，发布人等，这里的发布不仅包括工程的发布，还包括配置中心等的发布。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2505733944954128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFDZduepG2dgaBNDNkI7HVfXQ2l4WMzgHtc2Wiasgm0SHiaLdPZKWbZ4ew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3488&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;画外音：上图是我司的发布记录，可以看到有代码变更，回滚等，这样如果发现有问题的话可以一键回滚。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后我们以一张图来总结一下高可用的常见手段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7684887459807074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGF6n4vJibqCjicK5G405dyccnUoPVfU14fp7TtyfiaYbW89nEumuWJkAW7g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;622&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651506905&amp;amp;idx=2&amp;amp;sn=be4dc72831a156ff656ca5c40e643944&amp;amp;chksm=bd25a4a68a522db0b135b5fb87ffc5b76c27aeeaf9407a3ca7beadda7b47b61e06a963556516&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;B站高可用架构实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;B站高可用架构实践&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651496233&amp;amp;idx=2&amp;amp;sn=213ecb44769419caa0121e90e12d57e7&amp;amp;chksm=bd25f3568a527a40763d094b84609e27bea2b05e42819bb0898f97907a4ebb67c5a33fc7f9ff&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kafka宕机后不再高可用？探究Kafka高可用实现&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Kafka宕机后不再高可用？探究Kafka高可用实现&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651498116&amp;amp;idx=2&amp;amp;sn=dcc1fb4707cbc355679d4f1c9af91c72&amp;amp;chksm=bd25cafb8a5243ed6ffcfb07c004c1a4518d98a6c503fd457cfff099c3fa46fee3d48a870ebd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Elastic Job从单点到高可用、同城主备、同城双活&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Elastic Job从单点到高可用、同城主备、同城双活&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9a956ed1c93b6e6321cedbaea6d0f255</guid>
<title>[推荐] 消息队列经典十连问，你能扛到第几问？</title>
<link>https://toutiao.io/k/8jfl3pp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好呀。金三银四即将来临，整理了十道十分经典的消息队列面试题，看完肯定对面试有帮助的，大家一起加油哈~&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是消息队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息队列的应用场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息队列如何解决消息丢失问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息队列如何保证消息的顺序性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息有可能发生重复消费吗？如何幂等处理？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何处理消息队列的消息积压问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息队列技术选型，Kafka还是RocketMQ，还是RabbitMQ&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息中间件如何做到高可用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何保证数据一致性，事务消息如何实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果让你写一个消息队列，该如何进行架构设计？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 什么是消息队列&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以把消息队列理解为一个&lt;strong&gt;使用队列来通信&lt;/strong&gt;的组件。它的本质，就是个&lt;strong&gt;转发器&lt;/strong&gt;，包含&lt;strong&gt;发消息、存消息、消费消息&lt;/strong&gt;的过程。最简单的消息队列模型如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2651869158878505&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZXia000yHwcrHRuBWJkhDaIYnL9QPC0hNk3Kor0vJCVVLKUKYvNbf7FA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;856&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通常说的消息队列，简称&lt;strong&gt;MQ（Message Queue）&lt;/strong&gt;，它其实就指&lt;strong&gt;消息中间件&lt;/strong&gt;，当前业界比较流行的开源消息中间件包括：&lt;code&gt;RabbitMQ、RocketMQ、Kafka&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 消息队列有哪些使用场景。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候面试官会换个角度问你，&lt;strong&gt;为什么使用消息队列&lt;/strong&gt;。你可以回答以下这几点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;应用解耦&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流量削峰&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息通讯&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;远程调用&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 应用解耦&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个常见业务场景：下单扣库存，用户下单后，订单系统去通知库存系统扣减。传统的做法就是订单系统直接调用库存系统：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3371710526315789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZYuic2iaAbIW1SicOAg37ictQ6GSMAaqnxg5YcB1SePEQD3AaK3ib1VD9hoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果库存系统&lt;strong&gt;无法访问&lt;/strong&gt;，下单就会失败，订单和库存系统存在耦合关系&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果业务又接入一个营销积分服务，那订单下游系统要扩充，如果未来接入越来越多的下游系统，那订单系统代码需要经常&lt;strong&gt;修改&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6386554621848739&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZng2aZTdnOJWNq87kyVibrfiaicAvaDRADBFImjSIXTDlJwjJdmQMPaaIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;595&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何解决这个问题&lt;/strong&gt;呢？可以引入消息队列&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36862244897959184&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZpibLq2pOkKrDWkfjjchpuy2MZg9PvQTIrs62Usrn83mAz0oaQu0icGUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;784&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;订单系统：用户下单后，消息写入到消息队列，返回下单成功&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;库存系统：订阅下单消息，获取下单信息，进行库存扣减操作。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 流量削峰&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流量削峰也是&lt;strong&gt;消息队列的常用场景&lt;/strong&gt;。我们做秒杀实现的时候，需要避免流量暴涨，打垮应用系统的风险。可以在应用前面加入消息队列。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21443965517241378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZdMrO0WO8XT83PWIsWAR8WqCthjtv24R0WOEupKPWDiaFlCibQ3hyTYYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;928&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设秒杀系统每秒最多可以处理&lt;code&gt;2k&lt;/code&gt;个请求，每秒却有&lt;code&gt;5k&lt;/code&gt;的请求过来，可以引入消息队列，秒杀系统每秒从消息队列拉2k请求处理得了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些伙伴担心这样会出现&lt;strong&gt;消息积压&lt;/strong&gt;的问题，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先秒杀活动不会每时每刻都那么多请求过来，&lt;strong&gt;高峰期过去后&lt;/strong&gt;，积压的请求可以慢慢处理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其次，如果消息队列长度超过最大数量，可以直接抛弃用户请求或跳转到错误页面；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 异步处理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们经常会遇到这样的业务场景：用户注册成功后，给它发个短信和发个邮件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果注册信息入库是30ms，发短信、邮件也是30ms，三个动作&lt;strong&gt;串行执行&lt;/strong&gt;的话，会比较耗时，响应90ms：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2062062062062062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZ8jSz7ABG9r0kW3ic6wjc4eLoUW1bJj10aRfLlkIiaod2v6fUTp3h0tAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;999&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果采用并行执行的方式，可以减少响应时间。注册信息入库后，同时异步发短信和邮件。如何实现异步呢，用消息队列即可，就是说，注册信息入库成功后，写入到消息队列（这个一般比较快，如只需要3ms），然后异步读取发邮件和短信。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4047856430707876&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZlfr89uPw7yMN54YNugsJHicwic57feIXiaW98cSuYwTVoD1dicZHFFX8Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1003&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 消息通讯&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列内置了高效的通信机制，可用于消息通讯。如实现点对点消息队列、聊天室等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 远程调用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们公司基于MQ，自研了远程调用框架。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 消息队列如何解决消息丢失问题？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个消息从生产者产生，到被消费者消费，主要经过这3个过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24957841483979765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZ8f2bfhS3xcKmA5DNC7J0fFOlf29B1L35fQYjljrPhPcJyzYnowRVLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;593&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此如何保证MQ不丢失消息，可以从这三个阶段阐述：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 生产者保证不丢消息&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产端如何保证不丢消息呢？&lt;strong&gt;确保生产的消息能到达存储端&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是&lt;strong&gt;RocketMQ&lt;/strong&gt;消息中间件，Producer生产者提供了三种发送消息的方式，分别是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者要想发消息时保证消息不丢失，可以：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;采用&lt;strong&gt;同步方式&lt;/strong&gt;发送，send消息方法返回&lt;strong&gt;成功&lt;/strong&gt;状态，就表示消息正常到达了存储端Broker。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果send消息&lt;strong&gt;异常&lt;/strong&gt;或者返回&lt;strong&gt;非成功&lt;/strong&gt;状态，可以&lt;strong&gt;重试&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以使用事务消息，RocketMQ的事务消息机制就是为了保证零丢失来设计的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 存储端不丢消息&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何保证存储端的消息不丢失呢？确保消息&lt;strong&gt;持久化&lt;/strong&gt;到磁盘。大家很容易想到就是&lt;strong&gt;刷盘机制&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刷盘机制分&lt;strong&gt;同步刷盘和异步刷盘&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;生产者消息发过来时，只有持久化到磁盘，RocketMQ的存储端Broker才返回一个成功的ACK响应，这就是&lt;strong&gt;同步刷盘&lt;/strong&gt;。它保证消息不丢失，但是影响了性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步刷盘的话，只要消息写入PageCache缓存，就返回一个成功的ACK响应。这样提高了MQ的性能，但是如果这时候机器断电了，就会丢失消息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Broker一般是&lt;strong&gt;集群部署&lt;/strong&gt;的，有master主节点和slave从节点。消息到Broker存储端，只有主节点和从节点都写入成功，才反馈成功的ack给生产者。这就是&lt;strong&gt;同步复制&lt;/strong&gt;，它保证了消息不丢失，但是降低了系统的吞吐量。与之对应的就是&lt;strong&gt;异步复制&lt;/strong&gt;，只要消息写入主节点成功，就返回成功的ack，它速度快，但是会有性能问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 消费阶段不丢消息&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者执行完业务逻辑，再反馈会Broker说消费成功，这样才可以保证消费阶段不丢消息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 消息队列如何保证消息的顺序性。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息的有序性，就是指可以按照消息的发送顺序来消费。有些业务对消息的顺序是有要求的，比如&lt;strong&gt;先下单再付款，最后再完成订单&lt;/strong&gt;，这样等。假设生产者先后产生了两条消息，分别是下单消息（M1），付款消息（M2），M1比M2先产生，&lt;strong&gt;如何保证M1比M2先被消费&lt;/strong&gt;呢。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3372013651877133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZ2Kax0UIQ5ECaMmHLLOYJHBbhM1Sb7eHznIb0IQ18OxMypMJKl2ib0Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1465&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保证消息的顺序性，可以&lt;strong&gt;将M1、M2发送到同一个Server&lt;/strong&gt;上，当M1发送完收到ack后，M2再发送。如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32085932085932084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZQTwczcBJgGsiczQ1gWAMqUNeicyhGL0JgAooiarb5pw8wMTiaeEFgOQRqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1443&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样还是可能会有问题，因为从MQ服务器到消费端，可能&lt;strong&gt;存在网络延迟&lt;/strong&gt;，虽然M1先发送，但是它&lt;strong&gt;比M2晚到&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3224461431549687&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZicyDBQP63Nw3V53KiaPiaaicXiajloFsMOaarib89B4KP08dmz5yNBr6gomA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1439&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那还能怎么办才能保证消息的顺序性呢？将M1和M2发往&lt;strong&gt;同一个消费者&lt;/strong&gt;，且发送M1后，等到消费端ACK成功后，才发送M2就得了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3388543823326432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZjQI3ibREicKYdAbOfJf23A1GW6l1VGFJz5Tnyy0LtZP8nzRfSgiacLZmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1449&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列保证顺序性&lt;strong&gt;整体思路&lt;/strong&gt;就是这样啦。比如Kafka的全局有序消息，就是&lt;strong&gt;这种思想&lt;/strong&gt;的体现: 就是生产者发消息时，1个&lt;code&gt;Topic&lt;/code&gt;只能对应1个&lt;code&gt;Partition&lt;/code&gt;，一个 &lt;code&gt;Consumer&lt;/code&gt;，内部单线程消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这样&lt;strong&gt;吞吐量太低&lt;/strong&gt;，一般保证消息&lt;strong&gt;局部有序&lt;/strong&gt;即可。在发消息的时候指定&lt;code&gt;Partition Key&lt;/code&gt;，Kafka对其进行Hash计算，根据计算结果决定放入哪个&lt;code&gt;Partition&lt;/code&gt;。这样Partition Key相同的消息会放在同一个Partition。然后多消费者单线程消费指定的Partition。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.消息队列有可能发生重复消费，如何避免，如何做到幂等？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列是可能发生重复消费的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;生产端为了保证消息的可靠性，它可能往MQ服务器重复发送消息，直到拿到成功的ACK。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再然后就是消费端，消费端消费消息一般是这个流程：&lt;strong&gt;拉取消息、业务逻辑处理、提交消费位移&lt;/strong&gt;。假设业务逻辑处理完，事务提交了，但是需要更新消费位移时，消费者却挂了，这时候另一个消费者就会拉到重复消息了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何幂等处理重复消息呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我之前写过一篇幂等设计的文章，大家有兴趣可以看下哈：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247497427&amp;amp;idx=1&amp;amp;sn=2ed160c9917ad989eee1ac60d6122855&amp;amp;chksm=cf2229faf855a0ecf5eb34c7335acdf6420426490ee99fc2b602d54ff4ffcecfdab24eeab0a3&amp;amp;token=429828252&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;聊聊幂等设计&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幂等处理重复消息，简单来说，就是搞个本地表，带&lt;strong&gt;唯一业务标记的&lt;/strong&gt;，利用主键或者唯一性索引，每次处理业务，先校验一下就好啦。又或者用redis缓存下业务标记，每次看下是否处理过了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 如何处理消息队列的消息积压问题&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息积压是因为生产者的生产速度，大于消费者的消费速度。遇到消息积压问题时，我们需要先排查，是不是有bug产生了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不是bug，我们可以&lt;strong&gt;优化一下消费的逻辑&lt;/strong&gt;，比如之前是一条一条消息消费处理的话，我们可以确认是不是可以优为&lt;strong&gt;批量处理消息&lt;/strong&gt;。如果还是慢，我们可以考虑水平扩容，增加Topic的队列数，和消费组机器的数量，提升整体消费能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是bug导致几百万消息持续积压几小时。有如何处理呢？需要解决bug，&lt;strong&gt;临时紧急扩容&lt;/strong&gt;，大概思路如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先修复consumer消费者的问题，以确保其恢复消费速度，然后将现有consumer 都停掉。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新建一个 topic，partition 是原来的 10 倍，临时建立好原先10倍的queue 数量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 消息队列技术选型，Kafka还是RocketMQ，还是RabbitMQ&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先可以对比下它们优缺点：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;Kafka&lt;/th&gt;&lt;th&gt;RocketMQ&lt;/th&gt;&lt;th&gt;RabbitMQ&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;单机吞吐量&lt;/td&gt;&lt;td&gt;17.3w/s&lt;/td&gt;&lt;td&gt;11.6w/s&lt;/td&gt;&lt;td&gt;2.6w/s（消息做持久化）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;开发语言&lt;/td&gt;&lt;td&gt;Scala/Java&lt;/td&gt;&lt;td&gt;Java&lt;/td&gt;&lt;td&gt;Erlang&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;主要维护者&lt;/td&gt;&lt;td&gt;Apache&lt;/td&gt;&lt;td&gt;Alibaba&lt;/td&gt;&lt;td&gt;Mozilla/Spring&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;订阅形式&lt;/td&gt;&lt;td&gt;基于topic，按照topic进行正则匹配的发布订阅模式&lt;/td&gt;&lt;td&gt;基于topic/messageTag，按照消息类型、属性进行正则匹配的发布订阅模式&lt;/td&gt;&lt;td&gt;提供了4种：direct, topic ,Headers和fanout。fanout就是广播模式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;持久化&lt;/td&gt;&lt;td&gt;支持大量堆积&lt;/td&gt;&lt;td&gt;支持大量堆积&lt;/td&gt;&lt;td&gt;支持少量堆积&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;顺序消息&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;td&gt;支持&lt;/td&gt;&lt;td&gt;不支持&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;集群方式&lt;/td&gt;&lt;td&gt;天然的Leader-Slave，无状态集群，每台服务器既是Master也是Slave&lt;/td&gt;&lt;td&gt;常用 多对’Master-Slave’ 模式，开源版本需手动切换Slave变成Master&lt;/td&gt;&lt;td&gt;支持简单集群，&#x27;复制’模式，对高级集群模式支持不好。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;性能稳定性&lt;/td&gt;&lt;td&gt;较差&lt;/td&gt;&lt;td&gt;一般&lt;/td&gt;&lt;td&gt;好&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RabbitMQ是开源的，比较稳定的支持，活跃度也高，但是不是Java语言开发的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;很多公司用RocketMQ，比较成熟，是阿里出品的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. 消息中间件如何做到高可用&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息中间件如何保证高可用呢？单机是没有高可用可言的，高可用都是对集群来说的，一起看下kafka的高可用吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 的基础集群架构，由多个&lt;code&gt;broker&lt;/code&gt;组成，每个&lt;code&gt;broker&lt;/code&gt;都是一个节点。当你创建一个&lt;code&gt;topic&lt;/code&gt;时，它可以划分为多个&lt;code&gt;partition&lt;/code&gt;，而每个&lt;code&gt;partition&lt;/code&gt;放一部分数据，分别存在于不同的 broker 上。也就是说，一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些伙伴可能有疑问，每个&lt;code&gt;partition&lt;/code&gt;放一部分数据，如果对应的broker挂了，那这部分数据是不是就丢失了？那还谈什么高可用呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Kafka 0.8 之后，提供了复制品副本机制来保证高可用，即每个 partition 的数据都会同步到其它机器上，形成多个副本。然后所有的副本会选举一个 leader 出来，让leader去跟生产和消费者打交道，其他副本都是follower。写数据时，leader 负责把数据同步给所有的follower，读消息时，
直接读 leader 上的数据即可。如何保证高可用的？就是假设某个 broker 宕机，这个broker上的partition 在其他机器上都有副本的。如果挂的是leader的broker呢？其他follower会重新选一个leader出来。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. 如何保证数据一致性，事务消息如何实现&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一条普通的MQ消息，从产生到被消费，大概流程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5354713313896987&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZJLn0HKnR8oYQxibORz2wDQ5icnThm2xwUzSyxXlGichibptOeUIjFMLT6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1029&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;生产者产生消息，发送带MQ服务器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ收到消息后，将消息持久化到存储系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ服务器返回ACk到生产者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ服务器把消息push给消费者&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者消费完消息，响应ACK&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ服务器收到ACK，认为消息消费成功，即在存储中删除消息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们举个&lt;strong&gt;下订单&lt;/strong&gt;的例子吧。订单系统创建完订单后，再发送消息给下游系统。如果订单创建成功，然后消息没有成功发送出去，下游系统就无法感知这个事情，出导致数据不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何保证数据一致性呢？可以使用&lt;strong&gt;事务消息&lt;/strong&gt;。一起来看下事务消息是如何实现的吧。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6591549295774648&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZViaNwEDJupeX148JES81ic3QTSNb8MyFgjatIbiaIyEwWbS9CQXWw7mGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1065&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;生产者产生消息，发送一条&lt;strong&gt;半事务消息&lt;/strong&gt;到MQ服务器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ收到消息后，将消息持久化到存储系统，这条消息的状态是&lt;strong&gt;待发送&lt;/strong&gt;状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ服务器返回ACK确认到生产者，此时MQ不会触发消息推送事件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者执行本地事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果本地事务执行成功，即commit执行结果到MQ服务器；如果执行失败，发送rollback。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是正常的commit，MQ服务器更新消息状态为&lt;strong&gt;可发送&lt;/strong&gt;；如果是rollback，即删除消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果消息状态更新为可发送，则MQ服务器会push消息给消费者。消费者消费完就回ACK。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果MQ服务器长时间没有收到生产者的commit或者rollback，它会反查生产者，然后根据查询到的结果执行最终状态。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. 让你写一个消息队列，该如何进行架构设计？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题面试官主要考察三个方面的知识点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;你有没有对消息队列的架构原理比较了解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;考察你的个人设计能力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;考察编程思想，如什么高可用、可扩展性、幂等等等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;遇到这种设计题，大部分人会很蒙圈，因为平时没有思考过类似的问题。大多数人平时埋头增删改啥，不去思考框架背后的一些原理。有很多类似的问题，比如让你来设计一个 Dubbo 框架，或者让你来设计一个MyBatis 框架，你会怎么思考呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回答这类问题，并不要求你研究过那技术的源码，你知道那个技术框架的基本结构、工作原理即可。设计一个消息队列，我们可以从这几个角度去思考：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7301231802911534&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZzWDtNaqf4UoDQ7z13CImnSw1sNnvO34gnxVCGF2ZHJU2ZXVLDBSMibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;893&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先是消息队列的整体流程，producer发送消息给broker，broker存储好，broker再发送给consumer消费，consumer回复消费确认等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;producer发送消息给broker，broker发消息给consumer消费，那就需要两次RPC了，RPC如何设计呢？可以参考开源框架Dubbo，你可以说说服务发现、序列化协议等等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;broker考虑如何持久化呢，是放文件系统还是数据库呢，会不会消息堆积呢，消息堆积如何处理呢。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费关系如何保存呢？点对点还是广播方式呢？广播关系又是如何维护呢？zk还是config server&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息可靠性如何保证呢？如果消息重复了，如何幂等处理呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息队列的高可用如何设计呢？可以参考Kafka的高可用保障机制。多副本 -&amp;gt; leader &amp;amp; follower -&amp;gt; broker 挂了重新选举 leader 即可对外服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息事务特性，与本地业务同个事务，本地消息落库;消息投递到服务端，本地才删除；定时任务扫描本地消息库，补偿发送。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ得伸缩性和可扩展性，如果消息积压或者资源不够时，如何支持快速扩容，提高吞吐？可以参照一下 Kafka 的设计理念，broker -&amp;gt; topic -&amp;gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考与感谢&lt;/span&gt;&lt;/h2&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;阿里RocketMQ如何解决消息的顺序&amp;amp;重复两大硬伤？: &lt;em&gt;https://dbaplus.cn/news-21-1123-1.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;消息中间件面试题：如何解决消息队列的延时以及过期失效问题？: &lt;em&gt;https://jsbintask.cn/2019/01/28/interview/interview-middleware-manymessage/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;消息队列设计精要: &lt;em&gt;https://zhuanlan.zhihu.com/p/21649950&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;MQ消息最终一致性解决方案: &lt;em&gt;https://juejin.cn/post/6844903951448408071&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>