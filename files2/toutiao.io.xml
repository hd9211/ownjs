<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9693dde22571bcf1b07aa16d8d6fd8f5</guid>
<title>开源｜一款易用友好的监控告警系统</title>
<link>https://toutiao.io/k/r6uk1x1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;扫描下方二维码，即刻加入！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;HertzBeat赫兹跳动是由Dromara孵化，TanCloud开源的一个支持网站，API，PING，端口，数据库，操作系统等监控类型，拥有易用友好的可视化操作界面的开源监控告警项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.064&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ79yQa6fyj2TT9ic9ReZ4LZclDdjATH5TT1mHDDB8xw0TwKZAuYK36LshnPVG2RSChglyVr65KQ3SA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>70bccc2c9d9c0cdb8cb4270077c59322</guid>
<title>面试题总结</title>
<link>https://toutiao.io/k/3ig04un</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;h1&gt;一、Linux网络编程&lt;/h1&gt;&lt;h2&gt;1.1 进程通信的定义&lt;/h2&gt;&lt;p&gt;进程通信IPC(Inter-ProcessCommunication)是进程之间互相交换信息的工作。进程的互斥、同步、通信是用来解决并发进程的资源竞争与协作的手段。通信包含同步，同步又包含互斥。&lt;/p&gt;&lt;h2&gt;1.2 进程间通信的方式&lt;/h2&gt;&lt;p&gt;信号，管道，管道又分为匿名管道和命名管道，共享资源。AT&amp;amp;T在UNIXSystem V中又引入了三种通信方式分别是：消息队列、信号量和共享内存。统称为System V IPC。&lt;/p&gt;&lt;h3&gt;1.2.1 管道的定义&lt;/h3&gt;&lt;p&gt;管道分为匿名管道和命名管道。匿名管道只能用于父子进程通讯，命名管道也就是FIFO管道可以用于公共通信。&lt;/p&gt;&lt;h3&gt;1.2.2五种进程间通信方式的比较&lt;/h3&gt;&lt;p&gt;1&amp;gt;管道：速度慢，容量优先，只能用于父子进程通信。&lt;/p&gt;&lt;p&gt;2&amp;gt;FIFO：速度慢，任何进程都能通信。&lt;/p&gt;&lt;p&gt;3&amp;gt;消息队列：容量受系统限制，而且要注意第一次读的时候要考虑上一次没有读完数据的问题。&lt;/p&gt;&lt;p&gt;4&amp;gt;信号量：不能传递复杂消息，只能用来同步。&lt;/p&gt;&lt;p&gt;5&amp;gt;共享内存区：能够很容易控制容量，速度快，但要保持同步。&lt;/p&gt;&lt;h2&gt;1.3线程与进程的区别&lt;/h2&gt;&lt;p&gt;进程是程序在执行过程中分配和管理资源的基本单位。线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(程序计数器、一组寄存器和栈)，它与进程的其他线程共享进程的资源。&lt;/p&gt;&lt;p&gt;进程和线程是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但是线程没有单独的地址空间。一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大。对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。&lt;/p&gt;&lt;p&gt;进程的通信包含资源的通信和状态的同步。因为线程资源是共享的，所以线程的通信基本就是线程的同步。&lt;/p&gt;&lt;h2&gt;1.4多线程之间通信方式or线程池内数据如何保证一致性&lt;/h2&gt;&lt;p&gt;锁机制：悲观锁、乐观锁&lt;/p&gt;&lt;p&gt;同步原语：如volatile、sychronized、final&lt;/p&gt;&lt;p&gt;等待唤醒机制：wait、notify&lt;/p&gt;&lt;p&gt;线程需要返回数据的可以用Callable、Future、FutureTask这些。&lt;/p&gt;&lt;h3&gt;1.4.1 volatile关键字的语义&lt;/h3&gt;&lt;p&gt;通过在读写操作前后添加内存屏障，达到两个效果：1是强制将修改的值写入主存，并将工作内存的值缓存失效，保证了不同线程对这个变量进行操作时的可见性。2是禁止指令重排。&lt;/p&gt;&lt;h3&gt;1.4.2 final关键字的语义&lt;/h3&gt;&lt;p&gt;根据JSR133规范&lt;/p&gt;&lt;p&gt;1&amp;gt;对于final变量的初始化重排查规则是：final关键字修饰的变量初始化的代码不能重排序到构造函数结束之后。&lt;/p&gt;&lt;p&gt;2&amp;gt;对final变量的读取重排序规则是:初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作。&lt;/p&gt;&lt;p&gt;其他方面，编译器有很大自由，能将对final字段的读操作移到同步屏障之外，也允许编译器将final字段的值保存到寄存器，在非final字段需要重新加载的那些地方，final字段无需重新加载。&lt;/p&gt;&lt;h3&gt;1.4.3 sychronized关键字的内存语义&lt;/h3&gt;&lt;p&gt;进入管程时将同步块内使用到的变量从工作内存清除，退出管程时把共享变量刷新到主内存。&lt;/p&gt;&lt;h3&gt;1.4.4 线程的5个基本的同步机制&lt;/h3&gt;&lt;p&gt;互斥量、读写锁、条件变量、自旋锁以及屏障&lt;/p&gt;&lt;h2&gt;1.5 Linux文件&lt;/h2&gt;&lt;h3&gt;1.5.1 Linux文件相关的系统调用都有哪些&lt;/h3&gt;&lt;p&gt;最常用的是5个: open、read、write、lseek和close。&lt;/p&gt;&lt;h2&gt;1.5 Java主流锁&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.883054892601432&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib8ZWymacb2bN1Sdd1MibqAbY3QBcc9za9zb0PibO932hicDkNztyjpZUuhSs7JDR7ydgasUDib0unS9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;/p&gt;&lt;h3&gt;1.5.1 悲观锁和乐观锁&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;悲观锁：获取数据时先加锁。如Synchronized关键字和基于AQS的锁。&lt;/p&gt;&lt;p&gt;乐观锁：基于无锁编程，常用的是CAS算法。如JUC的atomic包下的原子类。&lt;/p&gt;&lt;h3&gt;1.5.2 阻塞和非阻塞&lt;/h3&gt;&lt;p&gt;阻塞：需要操作系统切换CPU状态。&lt;/p&gt;&lt;p&gt;非阻塞：不需要切换CPU状态。&lt;/p&gt;&lt;p&gt;自旋锁:底层也是通过CAS实现。&lt;/p&gt;&lt;p&gt;自适应自旋锁：意味着自旋时间或次数不再固定，而是由前一次的状态来决定。&lt;/p&gt;&lt;h2&gt;1.6 简述一下BIO、AIO和NIO的区别&lt;/h2&gt;&lt;p&gt;1&amp;gt;BIO是同步阻塞通信&lt;/p&gt;&lt;p&gt;服务器实现模式为一个连接一个线程：客户端有连接请求时服务器端就需要启动一个线程进行处理。如果这个连接不做任何事情会造成不必要的线程开销。&lt;/p&gt;&lt;p&gt;2&amp;gt;NIO是同步非阻塞通信&lt;/p&gt;&lt;p&gt;服务器实现模式为一个请求一个线程：客户端发送的连接请求都会注册到多路复用器上，多路复用器轮序到连接有IO请求时才启动一个线程进行处理。&lt;/p&gt;&lt;p&gt;3&amp;gt;AIO是异步非阻塞通信&lt;/p&gt;&lt;p&gt;服务器实现模式为一个有效请求一个线程，客户端的IO请求是由操作系统先完成，再通知服务器应用去创建线程进行处理。&lt;/p&gt;&lt;h2&gt;1.7 通信协议有哪些&lt;/h2&gt;&lt;p&gt;XNS(XeroxNetwork Systems)协议、IPX(网际包交换)/SPX(排序包交换)协议、Apple Talk、SNA、TCP/IP&lt;/p&gt;&lt;h2&gt;1.8 TCP/IP结构模型&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5606936416184971&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib8ZWymacb2bN1Sdd1MibqAbsysY32Q8jMZ1XnlPsUcsKrZjyfR2j0bibo5Lw8iawAC3Tv9bIia1AS7JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p&gt;大体分为三部分&lt;/p&gt;&lt;p&gt;1&amp;gt;  Internet协议(IP)&lt;/p&gt;&lt;p&gt;2&amp;gt;  传输控制协议(TCP)和用户数据报文协议(UDP)&lt;/p&gt;&lt;p&gt;3&amp;gt;  处于TCP和UDP之上的一组协议专门开发的应用程序。它们包括:TELNET、文件传送协议(FTP)、域名服务(DNS)和简单的邮件传送程序(SMTP)等许多协议。&lt;/p&gt;&lt;h3&gt;1.8.1 IP的四个主要功能&lt;/h3&gt;&lt;p&gt;1&amp;gt;数据传送&lt;/p&gt;&lt;p&gt;2&amp;gt;寻址&lt;/p&gt;&lt;p&gt;3&amp;gt;路由选择&lt;/p&gt;&lt;p&gt;4&amp;gt;  数据报文的分段&lt;/p&gt;&lt;h3&gt;1.8.2 控制位的取值及含义&lt;/h3&gt;&lt;p&gt;URG 紧急指示字段&lt;/p&gt;&lt;p&gt;ACK 如果设置，该包包含确认&lt;/p&gt;&lt;p&gt;PSH 推入功能&lt;/p&gt;&lt;p&gt;RST 恢复链接&lt;/p&gt;&lt;p&gt;SYN 用于建立序号(同步序号)&lt;/p&gt;&lt;p&gt;FIN 数据不再从连接的发送点进入，结束总报文&lt;/p&gt;&lt;h3&gt;1.8.3 套接字的三种类型&lt;/h3&gt;&lt;p&gt;1&amp;gt;流式套接字（如TCP）&lt;/p&gt;&lt;p&gt;2&amp;gt;数据报套接字(如UDP)&lt;/p&gt;&lt;p&gt;3&amp;gt;原始套接字&lt;/p&gt;&lt;h3&gt;1.8.4 五种IO模式&lt;/h3&gt;&lt;p&gt;1&amp;gt;阻塞I/O&lt;/p&gt;&lt;p&gt;进程在调用recvfrom等待有拷贝到程序的数据区到一直到从recvfrom返回这段时间是阻塞的。进程这段时间会让出CPU时间片进行休眠等待。&lt;/p&gt;&lt;p&gt;2&amp;gt;非阻塞I/O&lt;/p&gt;&lt;p&gt;进程不断调用recvfrom进行检查，如果程序数据区还没有数据则立即返回一个错误。直到recvfrom检查到数据正常返回。&lt;/p&gt;&lt;p&gt;3&amp;gt;I/O多路复用&lt;/p&gt;&lt;p&gt;I/O多路复用是先调用select函数或poll函数，当有数据时才调用recvfrom进行真正的读写。&lt;/p&gt;&lt;p&gt;4&amp;gt;信号驱动I/O(SIGIO)&lt;/p&gt;&lt;p&gt;使用信号让内核在文件描述符就绪的时候使用SIGIO信号来通知。&lt;/p&gt;&lt;p&gt;5&amp;gt;  异步I/O&lt;br/&gt;我们如果想进行I/O操作，只需要告诉内核我们要进行I/O操作，然后内核会马上返回。具体的I/O和数据的拷贝全部由内核来完成，我们的程序可以继续向下执行。当内核完成所有的I/O操作和数据拷贝后，内核将通知我们的程序。异步I/O和信号驱动I/O的区别是：信号驱动I/O模式下，内核在操作可以被操作的时候通知给我们应用程序发送SIGIO消息。异步I/O模式下，内核在所有的操作都已经被内核操作结束之后才会通知我们的应用程序。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5904605263157895&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib8ZWymacb2bN1Sdd1MibqAbG3arw0abvL5OTfSwDBpjU150daUibP98I4ezKghpeOhKwsr9Bg6fA9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/p&gt;&lt;h3&gt;1.8.5 简述Https流程&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6809248554913295&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib8ZWymacb2bN1Sdd1MibqAbhsPdwC0Yb5qzkFAQiaIL8To3hhBib9U5UwQ66Zf8ftYz82MrseVv0Wgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;h3&gt;1.8.6 TCP/IP三次握手建立连接（连接是全双工）&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;第一次握手：建立连接时，客户端发送SYN包到服务器，并进入syn_send状态。&lt;/p&gt;&lt;p&gt;第二次握手：服务器收到syn包，确认客户端的syn为收到的序号+1，同时自己也发送一个syn包，即发送(syn+ack)包，此时服务器进入syn_recv状态。&lt;/p&gt;&lt;p&gt;第三次握手：客户端收到服务器的syn+ack包，向服务器发送确认包ack，其中ack的值+1，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。&lt;/p&gt;&lt;h3&gt;1.8.7 TPC/IP四次挥手关闭连接&lt;/h3&gt;&lt;p&gt;第一次挥手，客户端A发送一个FIN，用来关闭客户端到服务器的数据传送。&lt;/p&gt;&lt;p&gt;第二次挥手，服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号+1。&lt;/p&gt;&lt;p&gt;第三次挥手，服务器关闭与客户端的连接，发送一个FIN给客户端。&lt;/p&gt;&lt;p&gt;第四次挥手，客户端发回ACK报文确认，并将确认序号设置为收到序号+1。&lt;/p&gt;&lt;h2&gt;二、JAVA&lt;/h2&gt;&lt;h2&gt;2.1 JVM&lt;/h2&gt;&lt;h3&gt;2.1.1 简述JVM内存模型&lt;/h3&gt;&lt;p&gt;根据JSR133规范,内存模型描述了一个给定程序和它的执行路径是否是一个合法的执行路径。&lt;/p&gt;&lt;p&gt;与这个相近的一个概念是JVM内存结构：&lt;/p&gt;&lt;h3&gt;2.1.2 JVM内存结构&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6161849710982659&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib8ZWymacb2bN1Sdd1MibqAbP6iauxRRMSl9zQBccY3BWUuGBTojMYnA1SNGtnibia2VIV36H21MtG46Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;h3&gt;2.1.3实例对象的存储&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;对象的实例(包括对象头、实例数据和填充数据)存储在堆，对象的元数据存储在方法区(元空间)，对象的引用存储在栈。&lt;/p&gt;&lt;h3&gt;2.1.4如何实现基于引用计数的垃圾回收器，避免循环引用&lt;/h3&gt;&lt;p&gt;数据结构我会用hashmap来保存对象的加减计数，要避免循环引用，需要添加辅助的工具比如基于引用遍历的垃圾回收器来清理它们。&lt;/p&gt;&lt;h3&gt;2.1.5可以作为GC ROOT的对象&lt;/h3&gt;&lt;p&gt;1&amp;gt;虚拟机栈中的局部变量表中引用的对象  &lt;/p&gt;&lt;p&gt;2&amp;gt;方法区中类静态属性引用的对象&lt;/p&gt;&lt;p&gt;3&amp;gt;方法区中常量引用的对象&lt;/p&gt;&lt;p&gt;4&amp;gt;本地方法栈中JNI引用的对象&lt;/p&gt;&lt;p&gt;5&amp;gt;由系统类加载器加载的类&lt;/p&gt;&lt;p&gt;6&amp;gt;存活的线程&lt;/p&gt;&lt;p&gt;7&amp;gt;用作同步监控的对象&lt;/p&gt;&lt;p&gt;8&amp;gt;被JVM持有的对象比如重要的异常处理类&lt;/p&gt;&lt;h3&gt;2.1.6 finalizer有哪些替代&lt;/h3&gt;&lt;p&gt;在java9中，finalizers的替代者是cleaners&lt;/p&gt;&lt;h3&gt;2.1.7 AQS如何避免加锁&lt;/h3&gt;&lt;p&gt;AQS抽象队列同步器本身是基于CLH队列的，通过自旋锁来进行资源的获取和释放，它本身就是一种锁实现。所以避免加锁可能是一个伪命题。但是有些常用的减少锁竞争的优化方式：比如在ConcurrentHashMap中使用锁分段技术来减小锁粒度，读写锁代替独占锁。&lt;/p&gt;&lt;h3&gt;2.1.8 JIT（Just in time complication）&lt;/h3&gt;&lt;p&gt;-server 编译速度慢，启动后性能更高&lt;/p&gt;&lt;p&gt;-XX:CompileThreshold默认1w次&lt;/p&gt;&lt;p&gt;-XX:MaxFreqInlineSize=N&lt;/p&gt;&lt;p&gt; -XX:MaxInlineSize=N&lt;/p&gt;&lt;p&gt;1&amp;gt;针对特定CPU型号的编译优化&lt;/p&gt;&lt;p&gt;2&amp;gt;热点数据减少查表次数&lt;/p&gt;&lt;p&gt;3&amp;gt;逃逸分析，直接栈上分配内存&lt;/p&gt;&lt;p&gt;4&amp;gt;寄存器分配&lt;/p&gt;&lt;p&gt;6&amp;gt;  热点代码缓存&lt;/p&gt;&lt;p&gt;7&amp;gt;  方法内联&lt;/p&gt;&lt;h3&gt;2.1.9 简述JVM的垃圾回收机制&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5284015852047557&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib8ZWymacb2bN1Sdd1MibqAbtog5DfhiaB6AZhJlkNOtFKgEmtHvtdlEDDZq4pOgTnvz8eRf2GjEQEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;757&quot;/&gt;&lt;/p&gt;&lt;p&gt;Java运行时内存的各个区域，对于程序计算器、虚拟机栈、本地方法栈这三个部分而言，生命周期随线程而生、随线程而灭。线程结束时内存就回收了。&lt;/p&gt;&lt;p&gt;而方法区和堆区需要使用对象是否存活的算法来判断是否可以回收。&lt;/p&gt;&lt;p&gt;常用的判断是否可回收算法有：引用计数器、可达性分析算法。&lt;/p&gt;&lt;p&gt;引用计数器算法采用引用加减的方法，优点是速度快，基本不需要STW，缺点是循环引用对象无法回收。可达性分析算法是从GC ROOT开始向下搜索，当一个对象没有和任何一个GC ROOT相连时，证明对象不可达。&lt;/p&gt;&lt;p&gt;对象的回收还和引用强弱有关，按照引用强弱又可分为强引用、软引用、弱引用、虚引用。&lt;/p&gt;&lt;p&gt;目前一般垃圾收集器中采用的是可达性分析算法来标记引用。&lt;/p&gt;&lt;p&gt;垃圾回收算法主要有标记-清除、复制算法、标记-整理算法、分代收集算法。&lt;/p&gt;&lt;h3&gt;2.1.10 方法区如何判断是否需要回收&lt;/h3&gt;&lt;p&gt;1&amp;gt;该类所有的实例都已经被回收，也就是Java堆中不存在该类的实例。&lt;/p&gt;&lt;p&gt;2&amp;gt;加载该类的类加载器已经被回收。&lt;/p&gt;&lt;p&gt;3&amp;gt;该类对应的Class对应没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。&lt;/p&gt;&lt;h3&gt;2.1.11 JVM组成部分&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.45734597156398105&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib8ZWymacb2bN1Sdd1MibqAbLEn59smo6U78obIK2HOuNClsuBmzAicGwhej7wMQzPaJ6PVfD1z9aKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot;/&gt;&lt;/p&gt;&lt;h2&gt;2.2 JAVA基础和源码&lt;br/&gt;&lt;/h2&gt;&lt;h3&gt;2.2.1反射为什么能访问私有数据&lt;/h3&gt;&lt;p&gt;因为使用了字节码文件&lt;/p&gt;&lt;h3&gt;2.2.2 Java泛型的本质是什么&lt;/h3&gt;&lt;p&gt;把类型明确的工作推迟到创建对象或调用方法的时候。只要在编译期没出现告警，运行期就不会出现ClassCastException。&lt;/p&gt;&lt;h3&gt;2.2.3 lambda表达式原理&lt;/h3&gt;&lt;p&gt;基于单一抽象方法类型的接口，也就是函数式接口来实现。它会调用编译器生成静态方法，使用lambda表达式的地方，通过传递内部类实例，来调用函数式接口方法。&lt;/p&gt;&lt;h3&gt;2.2.4列举其他的函数式接口&lt;/h3&gt;&lt;p&gt;java.lang.Runnable、java.util.Comparator&lt;/p&gt;&lt;h1&gt;二、算法&lt;/h1&gt;&lt;h2&gt;2.1 哈希&lt;/h2&gt;&lt;h3&gt;2.1.1介绍一下一致性哈希算法&lt;/h3&gt;&lt;p&gt;在处理数据和多个缓存服务器之间对应关系的时候，可以使用哈希值取模运算，但是这时候如果需要增加或减少服务器，很多缓存会失效。一致性哈希是这个问题的一个解决方案：从0为起点到2的32次方-1做成一个哈希环。将服务器的IP地址对2的32次方取模，如果需要，每个服务器也可以复制一些虚拟节点同样映射到哈希环上。将数据的哈希值对2的32次方进行取模(2^32刚好是无符号整形的最大值)。根据取模结果离哪个节点最近决定映射到哪台服务器上。这样增加和减少节点，影响的都是它临近的节点。由于增加了虚拟节点，所以数据的压力会分散。&lt;/p&gt;&lt;h3&gt;2.1.2介绍一下哈希槽&lt;/h3&gt;&lt;p&gt;共2的14次方个槽，每台服务器分管一部分。插入数据时，根据CRC(循环冗余检验)16算法计算key对应的值，用该值对2的14次方取余数。在添加或删除节点时，只需要对节点的上哈希槽做调整。调整过程中映射先不改变，等数据迁移完成后，映射才修改。客户端可以向任何一个节点发送请求，然后由节点将请求重定向到正确的节点上。&lt;/p&gt;&lt;h3&gt;2.1.2.1 哈希槽为什么是2的14次方&lt;/h3&gt;&lt;p&gt;CRC16会输出一个16位结果，redis作者测试发现这个数对2的14次方取模会将key分布的很均匀，因此选了这个值。&lt;/p&gt;&lt;h3&gt;2.1.3 二分查找算法&lt;/h3&gt;&lt;p&gt;在有序数组中，每次先判断中间位置是否满足条件。满足则直接返回；不满足就看在前半段还是后半段。在可能满足目标条件的半段再次这样按照中间位置查找直接找到满足条件的或者确定不能满足条件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;三、工程技术&lt;/h1&gt;&lt;h2&gt;3.1 spring&lt;/h2&gt;&lt;h3&gt;3.1.1谈谈对spring的理解&lt;/h3&gt;&lt;p&gt;Spring的目标:是要最大限度的简化开发工作，让开发人员集中精力于自己的业务逻辑，也是业务领域的开发。&lt;/p&gt;&lt;p&gt;开发的两个核心问题解耦和复用spring是这样解决的：&lt;/p&gt;&lt;p&gt;1&amp;gt;对于解耦&lt;/p&gt;&lt;p&gt;开发人员希望聚焦于业务领域的开发，首先要解决的事情是我修改一个业务代码，不希望显示层、模型层和控制层都要改。不希望改一个类，依赖它的类也需要改。Spring为了应对这个问题使用了控制反转的理念。将所有的依赖都由框架注入到一个上下文环境中(DI)。在这个环境中，Bean之间可以自由的使用。&lt;/p&gt;&lt;p&gt;2&amp;gt;对于复用&lt;/p&gt;&lt;p&gt;一些逻辑，比如日志，鉴权，很多地方都需要用到。这些与业务逻辑的关系又不是很紧密。这就用到了AOP(面向切面编程)。&lt;/p&gt;&lt;p&gt;Spring对解耦和复用的解决方案就是控制反转、依赖注入和AOP，在实现上&lt;/p&gt;&lt;p&gt;需要用到RobertMartin提出的SOLID原则。分别是单一职责、开放封闭、里氏替换、接口隔离和依赖倒置。控制反转、依赖注入和AOP，分别对应了三个spring的jar包：spring-beans、spring-context、spring-aop。每个包单一的负责一个核心功能的实现。这些都需要先做对象的实例化，这个功能由spring-core这个jar包来实现。在Spring-beans中，Spring使用工厂模式来管理程序中使用的对象Bean。每个Bean实例以BeanDefinition的形式被创建，通过java的反射机制将需要初始化的字段写入，最终保存在BeanDefinitionMap中。这整个过程由容器来实现，完成了控制反转。有了控制反转，开发者可以通过调用getBean获取到所需要的对象。spring-context提供文件列表的读入，将所有依赖的Bean放到一个Context中，就是常说的依赖注入。AOP的主要作用是不通过修改源代码的方式将功能代码织入来实现对方法的增强。实现的关键在于使用了代理模式。&lt;/p&gt;&lt;h3&gt;3.1.2谈谈对spring boot的理解&lt;/h3&gt;&lt;p&gt;使用约定大于配置的方式进一步简化Spring开发&lt;/p&gt;&lt;h3&gt;3.1.3谈谈对springcloud的理解&lt;/h3&gt;&lt;p&gt;SpringCloud是Spring为微服务架构思想做的一个一站式实现。它提供了服务注册发现Netflix Eureka、配置中心spring cloud config、负载均衡Netflix Ribbon、断路器Netflix Hystrix、路由Netflix Zuul。基本就是这些，因为美团这边主要用octo，spring cloud了解的不多。在实际项目中只用过spring cloud feign hystrix。&lt;/p&gt;&lt;h3&gt;3.1.4谈谈hystrix&lt;/h3&gt;&lt;p&gt;hystrix主要提供2种容错方法：资源隔离和熔断、降级。&lt;/p&gt;&lt;p&gt;资源隔离主要是线程的隔离，hystrix提供了两种线程隔离方式：线程池和信号量。线程池隔离是为每个类型的命令配置一个线程池，当线程池或请求队列饱和时，hystrix做快速失败处理，防止级联故障。&lt;/p&gt;&lt;p&gt;信号量隔离是对每个请求做信号量计数来控制并发请求量，防止请求线程大面积阻塞，从而达到限流和防止雪崩的目的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;熔断&lt;/p&gt;&lt;p&gt;在一段时间内，如果服务的错误百分比超过了一个阈值，就可以自动或手动触发断路器，停止对特定服务的所有请求。&lt;/p&gt;&lt;p&gt;降级&lt;/p&gt;&lt;p&gt;降级主要是做快速失败，使用者可以自定义fallback方法来定义失败后的处理逻辑。&lt;/p&gt;&lt;h2&gt;3.2设计模式具体使用&lt;/h2&gt;&lt;p&gt;Spring中大量使用设计模式&lt;/p&gt;&lt;p&gt;1&amp;gt;简单工厂模式，如Spring的BeanFactory&lt;/p&gt;&lt;p&gt;2&amp;gt;工厂方法，如Spring的FactoryBean接口&lt;/p&gt;&lt;p&gt;3&amp;gt;单例模式，Spring依赖注入Bean实例默认是单例的&lt;/p&gt;&lt;p&gt;4&amp;gt;适配器模式，Spring MVC的HandlerAdapter根据不同规则找到对应的Handler&lt;/p&gt;&lt;p&gt;5&amp;gt;代理模式，比如AOP&lt;/p&gt;&lt;p&gt;6&amp;gt;策略模式，比如加载资源文件的方式可以用ClassPathResource、FileSystemResource、ServletContextResourse、UrlResource。AOP的实现可以采用JDK动态代理和CGLIB代理。&lt;/p&gt;&lt;p&gt;7&amp;gt;装饰器模式，ApacheCommon大量使用装饰器模式，比如StringUtils、CollectionUtils这些工具类。&lt;/p&gt;&lt;p&gt;8&amp;gt;我自己写过一个观察者模式的，我做基于kubernetes的容器化项目，线上有几十个kubernetes集群。这些集群的信息是从数据库中读取的，因为比较少并改动不频繁。默认初始化时加载到内存中，数据库就相当于事件源。有一个线程会定时轮询数据库中的信息，一旦发生变化，就相当于是监听器监听到事件变化，则更新内存中数据。这样所有使用它的地方直接读取的就是最新的数据。&lt;/p&gt;&lt;h2&gt;3.3简单说一下分布式事务&lt;/h2&gt;&lt;p&gt;事务是n个事件要不全部成功要不全部失败。数据库事务是刚性事务，遵循ACID强一致性原则(原子性、一致性、隔离性、持久性)。&lt;/p&gt;&lt;p&gt;分布式事务是在分布式系统环境下由不同的服务之间通过网络协作完成的事务。分布式事务一般采用柔性事务。基于BASE(Basically Available、Soft state、Eventually consistent)理论。&lt;/p&gt;&lt;p&gt;我在实际工作中常用的主要有4种：&lt;/p&gt;&lt;p&gt;1&amp;gt;两阶段提交：预提交阶段判断是否满足条件，不满足则返回失败。满足则将资源预占住执行提交，提交阶段成功则返回成功，不成功则撤销提交操作。&lt;/p&gt;&lt;p&gt;举个我实际应用的例子：在我们申请服务器接口请求层就使用了这种方法，先预提交检查是否有服务器资源，有的话就将资源预占住，然后提交操作真正执行服务器申请。&lt;/p&gt;&lt;p&gt;2&amp;gt;异步确保型&lt;/p&gt;&lt;p&gt;将同步阻塞的事务操作变为异步操作。&lt;/p&gt;&lt;p&gt;举个我实际应用的例子：刚才提到的申请服务接口请求层。申请服务器接口实际上分成了请求层和执行层两层。因为申请服务器是一个耗时很长的操作。因为需要执行一系列的kubernetes操作，把容器创建出来，服务启动起来这些。平均需要30s。我们系统采用的方式是请求层判断是否满足申请服务器的条件，如果满足则发送两个mq，然后返回请求层的响应。这两个mq，一个是立即执行申请服务器的后续流程。另外一个是发送到延迟消息队列，5分钟后检查容器的状态看是否存在超时，超时则进行补偿处理。用户收到请求层提示成功后，再自己去轮询执行层的真正结果。&lt;/p&gt;&lt;p&gt;3&amp;gt;还有一个TCC解决方案是两阶段提交的改进，将整个业务逻辑显式的分成了try、confirm和cancel三个操作。这属于一种补偿性事务。&lt;/p&gt;&lt;p&gt;在之前负责美团金融交易时就使用过这种方式：先尝试支付，收到支付成功消息则返回结果，否则发起冲正(就是撤销)操作。&lt;/p&gt;&lt;p&gt;4&amp;gt;最大努力通知型&lt;/p&gt;&lt;p&gt;我做过一个统一降级开关的项目，一个降级开关是要对好几个子服务进行降级。这个降级接口收到请求验证符合降级条件后就返回「请求已受理，实际执行结果以通知为准」。同时异步的对每个子服务发起降级请求，请求有重试。所有请求成功或者重试超限后会发出通知各子服务的最终返回状态。&lt;/p&gt;&lt;p&gt;5&amp;gt;数据一致性算法&lt;/p&gt;&lt;p&gt;我听说过一些数据一致性算法，没有实际直接用过：比如Paxos、Raft、ZAB、Gossip这些少数服从多数的算法。具体内容没有研究过。由于目前的工作还是偏工程，所以我学习过的算法也就仅限于一致性哈希这种的。&lt;/p&gt;&lt;h2&gt;3.4 Kubernetes架构&lt;/h2&gt;&lt;p&gt;Kubernetes采用主从分布式架构，包括主节点、从节点，以及客户端命令行工具和其他附加项。&lt;/p&gt;&lt;p&gt;1&amp;gt;主节点&lt;/p&gt;&lt;p&gt;其中主节点负责对集群进行调度管理。由API Server、Scheduler、Cluster State Store（etcd）和Controller Manager Server组成。我们线上一个大集群master节点都是部署在三台物理机上，1主2从的架构。&lt;/p&gt;&lt;p&gt;1.1&amp;gt;Api server提供了统一的资源操作入口，主要用来处理REST操作。提供认证、授权、访问控制。确保它们生效，并执行相关业务逻辑，以及更新Cluster State Store中的相关对象。&lt;/p&gt;&lt;p&gt;1.2&amp;gt;Scheduler负责资源调度，按照预定的调度策略将Pod调度到相应的节点上。&lt;/p&gt;&lt;p&gt;1.3&amp;gt;ClusterState Store保存了整个集群的状态，主要用来共享配置和服务发现。我们这边用的是默认的etcd。&lt;/p&gt;&lt;p&gt;1.4&amp;gt;Controller-ManagerServer 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等。默认提供Repication Controller、Node controller、Namespace Controller、Service Controller、Endpoints Controller、Persistent Controller、DaemonSet Controller。由于美团这边对容器的用法还是接近与虚拟机的用法。所以这边的容器管理已经全部从原来的基于RC的创建方式改成了直接基于Pod的创建方式。&lt;/p&gt;&lt;p&gt;2&amp;gt;再说从节点&lt;/p&gt;&lt;p&gt;从节点包含kubelet、kube proxy和Container Runtime。&lt;/p&gt;&lt;p&gt;2.1&amp;gt;kubelet维护容器的生命周期，并管理CSI（Container Storage Interface）和CNI（Container Network Interface）。存储方面美团这边主要使用FlexVolume插件进行LVM本地存储(逻辑卷管理)。目前也有部分是基于CSI连接EBS（弹性块存储）磁盘的。&lt;/p&gt;&lt;p&gt;2.2&amp;gt;kube-proxy基于一种公共访问策略提供访问pod的途径。&lt;/p&gt;&lt;p&gt;2.3&amp;gt;ContainerRuntime负责镜像管理以及Pod和容器的真正运行，我们这边用的docker。&lt;/p&gt;&lt;p&gt;3&amp;gt;kubectl&lt;/p&gt;&lt;p&gt;用于通过命令行与APIServer进行交互，实现在集群中进行各种资源的维护与管理操作。&lt;/p&gt;&lt;p&gt;4&amp;gt;附加项：对kubernetes核心功能的扩展，主要有网络、服务发现和可视化三类。&lt;/p&gt;&lt;h2&gt;3.5 谈谈领域驱动设计&lt;/h2&gt;&lt;p&gt;DDD不需要特殊的架构，只要是能将技术问题与业务问题分离的架构即可。强调保持领域模型复杂性与技术代码复杂性的隔离。核心价值点是协作、通用语言UL以及有界上下文。&lt;/p&gt;&lt;p&gt;战术有CQRS命令查询隔离、事件溯源、RESTful服务、消息传递、MVP最小可行产品、ACL防止损坏层、提炼核心、支撑和通用域。还有消除依赖、弱化依赖和控制依赖。这是我自己提出来的一个战术。并在之前的项目得到很好的应用。&lt;/p&gt;&lt;h2&gt;3.6 稳定性&lt;/h2&gt;&lt;p&gt;针对不同的场景和痛点，整体的方案也会不同。有一些主要的战术。&lt;/p&gt;&lt;h3&gt;3.6.1隔离术&lt;/h3&gt;&lt;p&gt;1&amp;gt;领域拆分隔离方面&lt;/p&gt;&lt;p&gt;    ACL防止损坏层&lt;/p&gt;&lt;p&gt;    有界上下文&lt;/p&gt;&lt;p&gt;    提炼核心、支撑和通用域&lt;/p&gt;&lt;p&gt;    分层架构&lt;/p&gt;&lt;p&gt;    CRUD增删改查简单架构&lt;/p&gt;&lt;p&gt;    CQRS命令查询隔离&lt;/p&gt;&lt;p&gt;    依赖消弱控&lt;/p&gt;&lt;p&gt;2&amp;gt;服务部署隔离方面&lt;/p&gt;&lt;p&gt;   环境拆分&lt;/p&gt;&lt;p&gt;    机房隔离&lt;/p&gt;&lt;p&gt;    通道隔离&lt;/p&gt;&lt;p&gt;    单元化&lt;/p&gt;&lt;p&gt;    泳道&lt;/p&gt;&lt;p&gt;    热点隔离&lt;/p&gt;&lt;p&gt;    读写隔离&lt;/p&gt;&lt;p&gt;    容器隔离&lt;/p&gt;&lt;p&gt;    拆库拆表&lt;/p&gt;&lt;p&gt;    动静隔离&lt;/p&gt;&lt;p&gt;    非核心流量隔离&lt;/p&gt;&lt;p&gt;3&amp;gt;服务间交互隔离方面&lt;/p&gt;&lt;p&gt;   超时熔断&lt;/p&gt;&lt;p&gt;   失败率超限降级&lt;/p&gt;&lt;p&gt;4&amp;gt;服务内资源隔离方面&lt;/p&gt;&lt;p&gt;    线程池隔离&lt;/p&gt;&lt;p&gt;    信号量隔离&lt;/p&gt;&lt;h3&gt;3.6.2 风险巡检术&lt;/h3&gt;&lt;p&gt;1&amp;gt;慢查询治理&lt;/p&gt;&lt;p&gt;2&amp;gt;超时治理&lt;/p&gt;&lt;p&gt;3&amp;gt;依赖治理：消除依赖、弱化依赖、控制依赖&lt;/p&gt;&lt;p&gt;4&amp;gt;系统破窗户治理&lt;/p&gt;&lt;p&gt;5&amp;gt;废弃代码资源治理&lt;/p&gt;&lt;p&gt;6&amp;gt;系统异常治理&lt;/p&gt;&lt;p&gt;7&amp;gt;告警治理&lt;/p&gt;&lt;p&gt;8&amp;gt;数据一致性治理&lt;/p&gt;&lt;h3&gt;3.6.3 稳定性设计术&lt;/h3&gt;&lt;p&gt;我们团队目前用的方案设计模板是我编写的，里面包含一个checklist有下面这些条目：&lt;/p&gt;&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;无状态化设计&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;幂等设计&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;包含容量预估与冗余设计&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;兜底策略设计&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;提供灰度方案&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;提供应急预案&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;核心链路尽量用成熟的技术，非核心链路可做技术探索&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;核心链路点对点设计，非核心链路有批量操作需设计审批流程或者熔断逻辑&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;包含超时和重试设计&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;核心数据需要对账&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;包含开关上线设计&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;敏感数据需要加密&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; &lt;/p&gt;&lt;h3&gt;3.6.4 流程规范术&lt;/h3&gt;&lt;p&gt;1&amp;gt;设计规范&lt;/p&gt;&lt;p&gt;设计按照统一的设计模板来进行。&lt;/p&gt;&lt;p&gt;2&amp;gt;开发规范&lt;/p&gt;&lt;p&gt;与第三方交互，交互前后都要打日志。交互后的日志要把第三方返回的结果打印出来。一旦第三方出现问题。我们拿着第三方返回的结果来跟第三方沟通。避免责怪他人讹的出现。&lt;/p&gt;&lt;p&gt;3&amp;gt;上线规范&lt;/p&gt;&lt;p&gt;提测分支至少2名同学进行code review。Reviewer一般为之前负责过此模块开发的同学和架构师。&lt;/p&gt;&lt;p&gt;Sonar静态代码检查、自动化测试要跑通。这些都是通过工具来保证的。&lt;/p&gt;&lt;p&gt;重大变更要开验收会进行项目验收。&lt;/p&gt;&lt;p&gt;因为我们有环境拆分，分成了线下环境和线上环境。发布线下环境后要观察2天以上才可以发布线上。发布有窗口期，只能在指定的流量低峰期发布。发布要提供紧急预案。&lt;/p&gt;&lt;h1&gt;四、中间件&lt;/h1&gt;&lt;h2&gt;3.1 redis&lt;/h2&gt;&lt;h3&gt;3.1.1 redis的架构或redis的持久化架构&lt;/h3&gt;&lt;p&gt;目前主流的架构是基于redis-cluster集群的无中心架构，采用哈希槽来做分布式存储。&lt;/p&gt;&lt;p&gt;redis与memcached相比，数据可以持久化，支持的数据类型丰富，支持服务端计算集合的并、交和补集。还支持多种排序功能。&lt;/p&gt;&lt;p&gt;Redis的所有数据保存在内存中，持久化方面支持半持久化模式和全持久化模式。&lt;/p&gt;&lt;p&gt;半持久化模式也叫RDB持久化是在指定时间间隔内将内存中的数据集快照通过异步方式保存到磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。&lt;/p&gt;&lt;p&gt;全持久化模式也叫AOF持久化是以日志的形式将每一次数据变化都写入到aof文件里。&lt;/p&gt;&lt;h3&gt;3.1.2 redis如何使用&lt;/h3&gt;&lt;p&gt;一台物理机部署mysql的读写性能在每秒几千，同配置的机器如果部署redis性能可达到mysql的几十倍，加上支持复杂的数据类型，可以方便的和对象进行映射，所以非常合适做缓存使用。但是value尽量不要太大，会影响性能，响应时间不能保证。另外可以使用set if not exist和expire设置过期时间命令来实现分布式锁。另外也可以做计数器之类的。&lt;/p&gt;&lt;h3&gt;3.1.3 redis在使用过程中如何保证高可用&lt;/h3&gt;&lt;p&gt;目前主流的基于redis-cluster集群的无中心架构，采用哈希槽来做分布式存储。哈希槽对应的节点是一主多从的。主节点发生故障，父节点会代替主节点承担流量。&lt;/p&gt;&lt;h3&gt;3.1.4 redis如何选择主节点？&lt;/h3&gt;&lt;p&gt;首先过滤掉不健康的数据节点，比如下线、断线的、失联的。然后选择slave-priority优先级最高的从节点返回，如果不存在则选择偏移量最大的从节点。也不存在则选择runid最小的节点。&lt;/p&gt;&lt;h3&gt;3.1.5 redis线程安全问题&lt;/h3&gt;&lt;p&gt;因为redis是单线程程序，所以是线程安全。&lt;/p&gt;&lt;h3&gt;3.1.6单线程的redis性能为何这么高&lt;/h3&gt;&lt;p&gt;redis是基于内存的，读写速度非常快，CPU不是瓶颈。单线程反而避免了不必要的上下文切换和竞争。另外采用了非阻塞的IO多路复用机制提高性能。&lt;/p&gt;&lt;h3&gt;3.1.7 redis缓存淘汰算法lru&lt;/h3&gt;&lt;p&gt;      Least recently used最近最少使用算法根据数据的历史访问记录来进行淘汰数据，最常见的实现是使用一个链表保存缓存数据，新数据插入到链表头部，每当缓存命中，则将数据移到链表头部，当链表满的时候，将链表尾部的数据丢弃。这种算法插入删除节点时间复杂度O(1)，获取节点的时间复杂度是O(n)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;3.1.8描述一下redis数据结构&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1. 字符串 - 通过数值或 SDS 实现　　&lt;/p&gt;&lt;p&gt;2. 列表 - 通过压缩列表或双端链表实现&lt;/p&gt;&lt;p&gt;3. 哈希 - 通过压缩列表或字典实现&lt;/p&gt;&lt;p&gt;3. 集合 - 通过整数集合或字典实现&lt;/p&gt;&lt;p&gt;4. 有序集合 - 通过压缩列表的有序集合或跳跃表+字典组合的数据&lt;/p&gt;&lt;h4&gt;3.1.8.1 redis数据结构底层如何实现&lt;/h4&gt;&lt;p&gt;1&amp;gt;redis的hash采用链地址法来处理冲突，没有使用红黑树优化。&lt;/p&gt;&lt;p&gt;2&amp;gt;redis自己构建了一种名叫Simple dynamic string(SDS)的数据结构,开发者不用担心字符串变更造成的内存溢出问题。常数时间复杂度获取字符串长度len字段。空间预分配free字段，会默认留够一定的空间防止多次重分配内存。&lt;/p&gt;&lt;h4&gt;3.1.8.2 redis的sortedset的get的时间复杂度&lt;/h4&gt;&lt;p&gt;      集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。&lt;/p&gt;&lt;h3&gt;3.1.9缓存穿透、缓存击穿、缓存雪崩&lt;/h3&gt;&lt;p&gt;缓存穿透的解决方案：布隆过滤器、缓存空对象&lt;/p&gt;&lt;p&gt;缓存雪崩：缓存时间加入随机引子，尽可能分散缓存过期时间。&lt;/p&gt;&lt;p&gt;缓存击穿：热点数据在失效的瞬间直接请求数据库，解决方案：热点数据永不过期。&lt;/p&gt;&lt;h2&gt;3.2 Kafka&lt;/h2&gt;&lt;h3&gt;3.2.1描述一下Kafka以及实现原理&lt;/h3&gt;&lt;p&gt;Kafka是高吞吐量的、超强消息堆积的、有持久化能力的、快速进行消息处理的分布式消息系统中间件。&lt;/p&gt;&lt;p&gt;核心组件是producer、broker和consumer。broker和consumer通过zk来做分布式协调。client和server之间采用TCP协议。Kafka的存储架构方面……&lt;/p&gt;&lt;h3&gt;3.2.2如何保证消息刚好消费一次&lt;/h3&gt;&lt;p&gt;Kafka通常情况下不保证无重复消息，一般需要消费方自己做幂等。不过记得17年的时候读过一篇文章，Kafka的创始人写了一篇《正好一次传递与事务性消息》，里面介绍了将偏移量和消费端的状态更新一起写入DB来，忽略所有小于偏移量的消息，从而达到刚好一次产生副作用的目的。&lt;/p&gt;&lt;h3&gt;3.2.3 Kafka存储架构&lt;/h3&gt;&lt;p&gt;Kafka是一个分布式的、分区的、复制的提交日志服务。&lt;/p&gt;&lt;p&gt;      就是说消息会按照分区分布在集群的所有节点上。每个分区会有多个副本存储在不同的节点上。新的消息总是以追加的方式进行存储。&lt;/p&gt;&lt;p&gt;      分区和副本之间是是主从关系。主分片负责读写，从分片只是从主分片同步消息，用于在主分片出现问题时代替主分片。AP表示分区的所有副本，ISR表示和主副本同步的所有副本。如果副本超出同步范围，就叫做OSR。&lt;/p&gt;&lt;p&gt;      每个分区副本对应一个日志目录，目录下有多个日志分段。日志分段有大小上限，超过阈值会滚动创建新的日志分段。&lt;/p&gt;&lt;p&gt;      在物理上，每个日志分段由一个数据文件和一个索引文件组成。数据文件存储的是消息的真正内容，索引文件存储的数据文件的索引信息。&lt;/p&gt;&lt;p&gt;      索引文件采用内存映射加快读取速度。索引文件以稀疏的方式存储部分消息的偏移量到物理位置的对应关系，减少内存占用。这个偏移量是相对偏移量，并且单调递增。可以进一步减少内存的占用，并可使用二分查询快速确定偏移量的位置。&lt;/p&gt;&lt;p&gt;      数据文件的读取利用了现代操作系统针对磁盘读写的优化方案来加快磁盘的访问速度。比如，预读会提前将一个大磁盘快读入内存。后写会将很多小逻辑写合并起来组合成大物理写操作。还会将主内存剩余的所有空间内存都用作磁盘缓存。除了直接IO外的磁盘读写都会经过统一的磁盘缓存。消息直接在内核态使用零拷贝技术绕过用户缓冲区和socket缓冲区直接复制到网卡接口通过网络发送出去。&lt;/p&gt;&lt;p&gt;      以上是Kafka的核心处理。管理方面,Kafka有日志管理器和副本管理器。&lt;/p&gt;&lt;p&gt;Kafka服务启动时会创建一个日志管理类。负责日志的创建、检索、清理。每个日志分区都有一个全局的检查点文件。检查点表示日志已经刷新到磁盘的位置，主要用于故障的恢复。日志管理器也会定时将页面缓存中的数据真正flush到磁盘文件中。消息追加到日志中，有下面两种场景会发生刷新日志的动作。1是新创建一个日志分段，立即刷新旧的日志分段。2是日志中未刷新的消息数量超过配置项的值。&lt;/p&gt;&lt;p&gt;      日志管理器也会定时清理旧的日志分段。清理日志分段时从最旧的日志分段开始清理。有两种策略：一种是根据时间或大小策略，直接物理删除整个日志分段。另一是针对针对有键的消息进行日志合并压缩。&lt;/p&gt;&lt;p&gt;      副本管理器，追加消息时，生产者客户端会发送每个分区以及对应的消息集，拉取消息时，客户端会发送每个分区以及对应的拉取信息。服务端返回给客户端的响应结果也会按照分区分别返回。生产者可以用同步和异步模式发送生成请求给服务端。生产者发送的生产请求还有一个设置项，应答的值表示：生产者要求主副本收到指定数量的应答，才会认为生产请求完成了。如果生产者设置的应答值等于-1，服务端必须等待ISR所有副本都同步完消息，才会发送生产结果给生产者。Kafka在处理这种类型的请求时，会将延迟返回响应结果的请求放入延迟缓存队列。在操作完成或超时时，延迟操作会被从缓存队列中移除。&lt;/p&gt;&lt;h3&gt;3.2.4 Kafka消费者拉取消息的频率&lt;/h3&gt;&lt;p&gt;      因为消费者拉取数据采用轮询的方式，类似于死循环，在串行模式下是处理完消息结果后进行下一次拉取。在并行模式下是获取结果后就进行下一次拉取。轮询可以设置超时时间，超时时间内如果获取到的数据为空会多次轮询直到超时。&lt;/p&gt;&lt;h3&gt;3.2.5 Kafka的性能优化&lt;/h3&gt;&lt;p&gt;1&amp;gt;顺序写盘：Kafka在设计时采用追加方式来写入消息，这是典型的顺序写盘操作。可以充分利用操作系统对线性读写的深层优化，比如预读和后写。&lt;/p&gt;&lt;p&gt;预读会提前将一个大磁盘快读入内存。后写会将很多小逻辑写合并起来组合成大物理写操作。&lt;/p&gt;&lt;p&gt;2&amp;gt;页缓存，Kafka中大量使用了页缓存。消息都是先被写入页缓存，然后再由操作系统负责具体的刷盘操作。索引文件采用内存映射加快读取速度。索引文件以稀疏的方式存储部分消息的偏移量到物理位置的对应关系，减少内存占用。这个偏移量是相对偏移量，并且单调递增。可以进一步减少内存的占用，并可使用二分查询快速确定偏移量的位置。&lt;/p&gt;&lt;p&gt;3&amp;gt;零拷贝：消息直接在内核态使用零拷贝技术绕过用户缓冲区和socket缓冲区直接复制到网卡接口通过网络发送出去。&lt;/p&gt;&lt;p&gt;5&amp;gt;批量处理：生产者将多个消息封装成消息集，一次性发送到broker&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;h1&gt;五、存储&lt;/h1&gt;&lt;h2&gt;5.1 mysql&lt;/h2&gt;&lt;h3&gt;5.1.1 mysql的主从复制&lt;/h3&gt;&lt;p&gt;      mysql主从复制是mysql高可用、高性能的基础。有三种复制模式：全同步模式、半同步模式、异步模式。mysql默认使用异步模式。&lt;/p&gt;&lt;p&gt;全同步模式是主节点和从节点全部执行了commit并确认才会向客户端返回成功。半同步模式是主节点只需要接收到其中一台从节点的返回信息就commit；否则需要等待直到超时时间然后切换成异步模式再提交。异步模式是主节点不会主动push bin log到从节点，直接返回成功。&lt;/p&gt;&lt;p&gt;      主从复制设计三个线程，一个运行在主节点（log dump thread）,其余两个(I/O thread， SQL thread)运行在从节点。当从节点连接主节点时，主节点会创建一个log dump线程，用于发送binlog内容。在读取binlog中的操作时，此线程会对主节点的binlog加锁，当读取完成时锁会被释放。当从节点上执行start slave命令后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin log。I/O线程接收到主节点bin log dump进程发来的更新之后，保存在本地relay log中。SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。&lt;/p&gt;&lt;p&gt;      MySQL主从复制有三种方式：基于SQL语句的复制(statement-based replication,SBR)，基于行的复制(row-based replication,RBR),混合模式复制(mixed-based replication,MBR)。它们分别对应三种binlog文件格式。&lt;/p&gt;&lt;p&gt;      基于SQL语句的复制就是记录sql语句在binlog中，优点是只需要记录会修改数据的sql语句到binlog，减少binlog日志量，节约I/O，提高性能。缺点是在某些情况下，会导致主从节点中数据不一致(比如存储过程，函数等)。&lt;/p&gt;&lt;p&gt;基于行的复制（RBR）是mysql master将sql语句分解为基于行新的语句并记录在binlog中，优点是不会出现某些特定情况下的存储过程或者函数，或者触发器的调用或触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是表结构更改会让日志暴增，同时增加binlog同步时间。也不能通过binlog解析获取执行过的sql语句，只能看到发生的数据变更。&lt;/p&gt;&lt;p&gt;      混合模式复制是以上两种模式的混合，对于一般的复制使用基于SQL语句的复制，对于基于SQL语句无法复制的操作则使用基于行的复制，mysql会根据执行的sql语句自己选择日志保存方式。&lt;/p&gt;&lt;h3&gt;5.1.2 MySql的数据结构or索引原理&lt;/h3&gt;&lt;p&gt;MySql实际使用的是B+Tree作为索引的数据结构，它实际上是多路平衡查找树。搜索的渐进时间复杂度是logdN。由于出度d是非常大的数据，通常超过100，所以搜索时I/O次数一般不会超过3次。但是只在叶子节点带有指向记录的指针，这样可以增加树的度。叶子节点通过指针相连来实现范围查询。&lt;/p&gt;&lt;p&gt;当B+Tree的数据项是复合的数据结构，B+Tree是按照从左到右的顺序来建立搜索树的，所以符合最左匹配原则。&lt;/p&gt;&lt;h3&gt;5.1.3 MySql索引优化&lt;/h3&gt;&lt;p&gt;对经常用作查询条件的、表连接的和经常出现在order by 、groupby之后的字段创建索引。可以利用最左匹配原则减少索引数量。因为索引多了会影响数据更新效率。&lt;/p&gt;&lt;p&gt;数据库字段最好不要允许为null，因为mysql很难对空值做查询优化。作为索引的字段值尽量不要有大量相同值，尽量选择区分度高、离散度大的。&lt;/p&gt;&lt;p&gt;索引字段要尽量小，因为索引所在的B+Tree的大小不超过一个内存页大小(mysql定制版16K)，是固定的，保证访问1个节点只需要1次IO。&lt;/p&gt;&lt;h3&gt;5.1.4聚集索引和非聚集索引&lt;/h3&gt;&lt;p&gt;聚集还是非聚集指的是B+Tree叶子节点存的是指针还是数据记录&lt;/p&gt;&lt;p&gt;MyISAM引擎索引和数据分离，使用的是非聚集索引。&lt;/p&gt;&lt;p&gt;InnoDB引擎数据文件就是索引文件，主键索引就是聚集索引。&lt;/p&gt;&lt;p&gt;聚集索引的好处之一：它对主键的排序查找和范围查找速度非常快，叶子节点的数据就是用户所要查询的数据。&lt;/p&gt;&lt;p&gt;聚集索引的好处之二：范围查询（range query），即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可。&lt;/p&gt;&lt;h3&gt;5.1.5 聚集索引和非聚集索引的区别&lt;/h3&gt;&lt;p&gt;聚集索引&lt;/p&gt;&lt;p&gt;1.纪录的索引顺序与物理顺序相同&lt;/p&gt;&lt;p&gt;   因此更适合between and和order by操作&lt;/p&gt;&lt;p&gt;2.叶子结点直接对应数据&lt;/p&gt;&lt;p&gt;3.每张表只能创建一个聚集索引&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;非聚集索引&lt;/p&gt;&lt;p&gt;1.索引顺序和物理顺序无关&lt;/p&gt;&lt;p&gt;2.叶子结点不直接指向数据页&lt;/p&gt;&lt;p&gt;3.每张表可以有多个非聚集索引，需要更多磁盘和内容&lt;/p&gt;&lt;p&gt;   多个索引会影响insert和update的速度&lt;/p&gt;&lt;h3&gt;5.1.6怎样做分库分表&lt;/h3&gt;&lt;p&gt;分库分表分为垂直拆分和水平拆分。还有一种方式，同时结合和垂直拆分和水平拆分，比如主从表。&lt;/p&gt;&lt;p&gt;垂直拆分是按照领域分。水平拆分是数据量和流量的拆分。一般单表数据量超过千万性能会急剧下降需要拆表。单库TPS达到几千后，再增长就需要拆库。&lt;/p&gt;&lt;p&gt;刚才提到主从表，或者也有人成为子母表。是将业务主要信息放到主表，扩展信息用与主表关联的从表来存储。因为主表和从表的信息量不同。可以各自决定是否需要水平拆分。&lt;/p&gt;&lt;h3&gt;5.1.7 sql查询所有成绩大于80的姓名&lt;/h3&gt;&lt;p&gt;先扫描表，查出有成绩小于80的人的姓名，然后再次扫描表，用not in 或notexists 方法。&lt;/p&gt;&lt;h3&gt;5.1.8 磁盘IO的优化&lt;/h3&gt;&lt;p&gt;磁盘预读：根据局部预读性原理，计算机操作系统在一次IO时，不光把当前磁盘地址的数据，而且把相邻的数据也都读取到内存缓冲区内。&lt;/p&gt;&lt;p&gt;5.1.9mysql主从自动切换&lt;/p&gt;&lt;p&gt;mysql主从自动切换使用的是相对成熟的mha(Master HighAvailability)，一旦检测到主服务器故障，就会自动进行故障转移。及时有些从服务器没有收到最新的relay log，MHA自动从最新的从服务器上识别差异的relay log并把这些日志应用到其他从服务器上，因此所有的从服务器保持一致性了。MHA通常在几秒内完成故障转移，9-12秒可以检测出主服务器故障，8-10秒内关闭故障的主服务器以避免脑裂，几秒钟内应用异常的relay log到新的主服务器上，整个过程可以在1—30s&lt;/p&gt;&lt;p&gt;5.1.10事务的基本要素&lt;/p&gt;&lt;p&gt;原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durabillity)&lt;/p&gt;&lt;p&gt;5.1.10.1事务隔离级别和不同级别的并发问题&lt;/p&gt;&lt;p&gt;ReadUncommitted读未提交级别下会引起脏读的并发问题&lt;/p&gt;&lt;p&gt;ReadCommitted 读提交级别下会引起不可重复读的并发问题&lt;/p&gt;&lt;p&gt;RepeatableRead 重复读级别下如果使用的是基于锁的并发控制，会引起幻读的并发问题&lt;/p&gt;&lt;p&gt;Serializable串行化级别下没有并发问题，但是并发度很低。&lt;/p&gt;&lt;p&gt;并发问题解决的原理主要有两种: LBCC和MVCC。基于锁的并发控制是悲观机制，而多版本并发控制是乐观机制。&lt;/p&gt;&lt;p&gt;Innodb会为每一行添加两个隐藏字段，一个表示该行的创建版本，一个表示该行的删除版本。填入的事务的版本号。&lt;/p&gt;&lt;p&gt;它是在一个时间点生成一个版本快照，对于RC级别下，是在事务在每次读数据的时候就创建一个read view。而RR级别下，是在事务一开始时创建一个read view。&lt;/p&gt;&lt;p&gt;5.1.11查询在什么时候不走索引&lt;/p&gt;&lt;p&gt;3种情况：1&amp;gt;不满足走索引的条件 2&amp;gt;走索引效率低于全表扫描 3&amp;gt;需要回表的查询结果集过大，超过了配置的范围&lt;/p&gt;&lt;p&gt;符合1的情况有：不满足最左匹配原则；查询条件使用了函数；or操作有一个字段没有索引；使用like条件以%开头&lt;/p&gt;&lt;p&gt;符合2的情况有：查询条件对null做判断，而null的值很多；一个字段区分度很小，比如性别、状态&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2a7a86dc1a1f009ae6ade3b8c39605d4</guid>
<title>除了居家抗疫，你还可以做什么？</title>
<link>https://toutiao.io/k/ykkx4eo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7b95aa89eee4ebb8b0a334aff5b9537b</guid>
<title>云原生时代如何用 Prometheus 实现性能压测可观测-Metrics 篇</title>
<link>https://toutiao.io/k/gs7pi2p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article tabindex=&quot;0&quot;&gt;&lt;p&gt;&lt;span&gt;压测监控最重要的 3 个指标：请求成功率、服务吞吐量(TPS)、请求响应时长(RT)，这 3 个指标任意一个出现拐点，都可以认为系统已达到性能瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里特别说明下响应时长，对于这个指标，用平均值来判断很有误导性，因为一个系统的响应时长并不是平均分布的，往往会出现长尾现象，表现为一部分用户请求的响应时间特别长，但整体平均响应时间符合预期，这样其实是影响了一部分用户的体验，不应该判断为测试通过。因此对于响应时长，常用 99、95、90 分位值来判断系统响应时长是否达标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，如果需要观察请求响应时长的分布细节，可以补充请求建联时长(Connect Time)、等待响应时长(Idle Time)等指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;资源性能指标&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;压测过程中，对系统硬件、中间件、数据库资源的监控也很重要，包括但不限于：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CPU 使用率&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内存使用率&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;磁盘吞吐量&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网络吞吐量&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据库连接数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;缓存命中率&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;... ...&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;详细可见&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;测试指标&lt;/span&gt;&lt;span&gt;》&lt;sup&gt;&lt;strong&gt;[1&lt;/strong&gt;&lt;/sup&gt;&lt;sup&gt;&lt;strong&gt;]&lt;/strong&gt;&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;一文。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;施压机性能指标&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;压测链路中，施压机性能是容易被忽略的一环，为了保证施压机不是整个压测链路的性能瓶颈，需要关注如下施压机性能指标：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt; 为什么用 Prometheus 做压测监控&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开源压测工具如 JMeter 本身支持简单的系统性能监控指标，如：请求成功率、系统吞吐量、响应时长等。但是对于大规模分布式压测来说，开源压测工具的原生监控有如下不足：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;监控指标不够全面，一般只包含了基础的系统性能指标，只能用于判断压测是否通过。但是如果压测不通过，需要排查、定位问题时，如分析一个 API 的 99 分位建联时长，原生监控指标就无法实现。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;聚合时效性不能保证&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;无法支持大规模分布式的监控数据聚合&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;监控指标不支持按时间轴回溯&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上，在大规模分布式压测中，不推荐使用开源压测工具的原生监控。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面对比 2 种开源的监控方案：&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;方案一：Zabbix&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zabbix 是早期开源的分布式监控系统，支持 MySQL 或 PostgreSQL 关系型数据库作为数据源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于系统性能监控，需要施压机提供秒级的监控指标，每秒高并发的监控指标写入，使关系型数据库成为了监控系统的瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于资源性能监控，Zabbix 对物理机、虚拟机的指标很全面，但是对容器、弹性计算的监控支持还不够。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;方案二：Prometheus&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Prometheus 使用时序数据库作为数据源，相比传统关系型数据库，读写性能大大提高，对于施压机大量的秒级监控数据上报的场景，性能表现良好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于资源性能监控，Prometheus 更适用于云资源的监控，尤其对 Kubernates 和容器的监控非常全面，对使用云原生技术的用户，上手更简单。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结下来，Prometheus 相较 Zabbix，更适合于压测中高并发监控指标的采集和聚合，并且更适用于云资源的监控，且易于扩展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;当然，使用成熟的云产品也是一个很好选择，如&lt;/span&gt;&lt;/span&gt;&lt;span&gt;压测工具 &lt;/span&gt;&lt;span&gt;PTS&lt;sup&gt;&lt;strong&gt;[2&lt;/strong&gt;&lt;/sup&gt;&lt;sup&gt;&lt;strong&gt;]&lt;/strong&gt;&lt;/sup&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;+&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;可观测工具 &lt;/span&gt;&lt;span&gt;AR&lt;/span&gt;&lt;/span&gt;&lt;span&gt;MS&lt;sup&gt;&lt;strong&gt;[&lt;/strong&gt;&lt;/sup&gt;&lt;sup&gt;&lt;strong&gt;3]&lt;/strong&gt;&lt;/sup&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，就是一组黄金搭档。PTS 提供压测时的系统性能指标，ARMS 提供资源监控和整体可观测的能力，一站式解决压测可观测的问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;怎么使用 Prometheus 实现压测监控&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt; 开源 JMeter 改造&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Prometheus 是拉数据模型，因此需要压测引擎暴露 HTTP 服务，供 Prometheus 获取各压测指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JMeter 提供了插件机制，可以自定义插件来扩展 Prometheus 监控能力。在自定插件中，需要扩展 JMeter 的 BackendListener，让在采样器执行完成时，更新每个压测指标，如成功请求数、失败请求数、请求响应时长。并将各压测指标在内存中保存，在 Prometheus 拉数据时，通过 HTTP 服务暴露出去。整体结构如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;248&quot; data-backw=&quot;458&quot; data-ratio=&quot;0.5414847161572053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvlpVJSP1JTcqpOCqhRsSvTbhPCHut4OAuBibbwIfuQk2jGoic0DXz4eHDibOp1ic3V29cSAicNRviaLDTUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;916&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JMeter 自定义插件需要改造的点：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;增加指标注册中心&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;扩展 Prometheus 指标更新器&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实现自定义 JMeter BackendListener，在采样器执行结束后，调用 Prometheus 更新器&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实现 HTTP Server，如果有安全需要，补充鉴权逻辑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;2&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt; PTS 压测工具&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;性能测试 PTS（Performance Testing Service）是一款阿里云 SaaS 化的性能测试工具。PTS支持自研压测引擎，同时支持开源 JMeter 压测，在 PTS 上开放压测指标到 Prometheus，无需开发自定义插件来改造引擎，只需 3 步白屏化操作即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体步骤如下：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;PTS 压测的高级设置中，打开【Prometheus】开关&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;压测开始后，在【监控导出】一键复制 Prometheus 配置&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;自建的 Prometheus 中粘贴并热加载此配置，即可生效&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详细参考：&lt;/span&gt;&lt;span&gt;《如何将 PTS 压测的指标数据输出到 Prometheus》&lt;sup&gt;&lt;strong&gt;[&lt;/strong&gt;&lt;/sup&gt;&lt;sup&gt;&lt;strong&gt;4]&lt;/strong&gt;&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;快速搭建 Grafana 监控大盘&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;PTS 提供了&lt;/span&gt;&lt;/span&gt;&lt;span&gt;官方 Grafana 大盘模板&lt;sup&gt;&lt;strong&gt;[&lt;/strong&gt;&lt;/sup&gt;&lt;sup&gt;&lt;strong&gt;5]&lt;/strong&gt;&lt;/sup&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，支持一键导入监控大盘，并可以灵活编辑和扩展，满足您的定制监控需求。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本大盘提供了全局请求成功率，系统吞吐量(TPS)，99、95、90 分位响应时长，以及按错误状态码聚合的错误请求数等数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 API 分布专栏中，可以直观的对比各 API 的监控指标，快速定位性能短板 API。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 API 详情专栏中，可以查看单个 API 的详细指标，准确定位性能瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，大盘还提供了施压机的JVM垃圾回收监控指标，可以辅助判断施压机是否是压测链路中的性能瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;导入步骤如下：&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;步骤一&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在菜单栏，点击 Dashboard 下的 import：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;430&quot; data-backw=&quot;534&quot; data-ratio=&quot;0.8052434456928839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvlpVJSP1JTcqpOCqhRsSvTb7WDPurFMUYbbwLAhLSEvC0AGvcibtG1lckrkeTKtiaRyVU6uwLNQcdCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;步骤二&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;填写 PTS Dashboard 的 id：15981&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;397&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6873350923482849&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvlpVJSP1JTcqpOCqhRsSvTbuptN0suSP72khNrFClc0nN9bg4GNC6gzFwohGwjiclI9h7uugraSsEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1516&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Prometheus 选择您已有的数据源，本示例中数据源名为 Prometheus。选中后，单击 Import 导入&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h5&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;337&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.58311345646438&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvlpVJSP1JTcqpOCqhRsSvTbVe8VOrU7lKgV7rfpvIbibzGtkgOyzetLOcAULpjRVxlrgTL8mUUxCEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1516&quot;/&gt;&lt;/h5&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;步骤三&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;导入后，在左上角【PTS 压测任务】，选择需要监控的压测任务，即可看到当前监控大盘。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此任务名对应 PTS 控制台在监控导出-Prometheus 配置中的 jobname。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;302&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5226130653266332&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvlpVJSP1JTcqpOCqhRsSvTbYatKAShbeWvYtVrPnibuPibTgJwr3ic9JBPMVcu9U5HeYdmg3x6AEdZlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3582&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;04&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;本文阐述了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;什么是性能测试可观测&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;为什么用 Prometheus 做压测性能指标监控&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如何使用开源 JMeter 和云上 PTS 实现基于 Prometheus 的压测监控&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;PTS 压测监控导出 Prometheus 功能，目前免费公测中，欢迎使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时，PTS 全新售卖方式来袭，基础版价格直降 50%！百万并发价格只需 6200！更有新用户 0.99 体验版、VPC 压测专属版，欢迎大家选购！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;1044&quot; data-backw=&quot;375&quot; data-ratio=&quot;2.784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvlpVJSP1JTcqpOCqhRsSvTbSjcnsGibHG9XgpL9E6Z5333gsEnIibDELKQZM23PswMGvo7yk7Cj0W2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;05&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;相关链接&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;[1] &lt;/span&gt;测试指标&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://help.aliyun.com/document_detail/29338.html&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;[2] &lt;/span&gt;压测工具 &lt;/span&gt;&lt;span&gt;PTS&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://www.aliyun.com/product/pts&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;[3] &lt;/span&gt;可观测工具 &lt;/span&gt;&lt;span&gt;ARMS&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://www.aliyun.com/product/arms&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[4] 如何将 PTS 压测的指标数据输出到 Prometheus&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://help.aliyun.com/document_detail/416784.html&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;5]&lt;/span&gt;官方 Grafana 大盘模板&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://grafana.com/grafana/dashboards/15981&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击&lt;/span&gt;&lt;strong&gt;&lt;span&gt;阅读原文&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，了解性能测试 PTS 更多资讯！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/article&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8d645bb4d1f2b1dbda2d73dcde788c61</guid>
<title>HTML5崛起之时，Java桌面时代就已经终结了</title>
<link>https://toutiao.io/k/x0rdhsx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.15625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YriaiaJPb26VN5koUu22VNrAnuXDfGLRs8w4tRT63wErRVia5ic9J4ZyzWLDwcKT1Ldrzibn8lWIAnCQmkMCAVEtuIg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;section&gt;作者｜Steve Hannah&lt;/section&gt;&lt;section&gt;
翻译｜核子可乐&lt;/section&gt;&lt;section&gt;
编辑｜燕珊&lt;/section&gt;&lt;section&gt;
2004 年 Google Maps 的面世标志着 Java 桌面时代的终结，也改变了桌面环境下“跨平台”的基本定义。&lt;/section&gt;&lt;p&gt;本文作者以个人视角对 Java 桌面发展历程做了回顾，内容来自他在上世纪九十年代后期担任 Java 开发者时的所见所感，主要讲述曾经的“杀手级”桌面语言 Java 是为何从 21 世纪开始颓势尽显、步入衰落的。值得一提的是，作者如今在做一款开发者友好型 Java 桌面部署工具（jDeploy），其实他还是希望 Java 可以重拾风采，再度变得对桌面开发具有吸引力。&lt;/p&gt;&lt;p&gt;本文是该回顾系列文章中的第二篇，在&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651108991&amp;amp;idx=1&amp;amp;sn=180fd0e868e1afa4fedea4f70a06e2c1&amp;amp;chksm=bdb94e2c8acec73ad8ccc83bf902e888ddf08981eb7bb62f29249749b9946f0a46d1e13894a2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;上期文章&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;上期文章&lt;/a&gt;中，作者回顾了 Java 制霸桌面的鸿图如何在 1999 至 2005 的短短几年间烟消云散。当初的 Java 可谓志得意满、凭 Applet 小程序技惊四座，下决心要在互联网时代下重新定义“桌面”。互联网的未来在于“跨平台”，而 Java 的血管中涌动的正是“跨平台”的血液，优势在握！可遗憾的是，事后来看，此跨平台似乎并非彼跨平台。接下来，让我们继续跟着作者的脚步去看看，具体在 2004 至 2007 年间，Java 桌面又经历了什么。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;桌面王朝的最后时光&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;2002 年左右，我在客服中心为客户提供计算机与打印机技术支持。我和小伙伴们挤在小小的隔间里，面对着一款桌面程序。通过这款软件，我们可以快速查询客户和产品信息，并把通话中的重要信息记录进去。&lt;/p&gt;&lt;p&gt;在典型的客服来电中，我们会询问客户的产品序列号，再把结果输入系统。如果他们之前就打过电话，系统就会输出窗口，里面包含产品的完整历史记录和之前的求助细节。在参考其他同事留下的事由记录后，我还能操作界面中的选项卡和功能按钮，例如帮客户更换新机。&lt;/p&gt;&lt;p&gt;我不记得这款软件叫什么名字了，可能是为公司或者客服中心专门定制的吧。印象里这应该是 PeopleSoft（仁科公司，2005 年已被甲骨文收购）的产品，但我也不太确定。总之，这款桌面软件运行在 Windows 2000 系统上，肯定不是 Web 应用程序。它其实挺复杂，里面包含不少菜单和表单；不过一旦上手，整个使用体验相当棒——速度快、反应灵敏，几乎没有任何延迟。以输入电话号码查询客户记录为例，我们只需要在“电话”字段里输入号码，其余空白表格就会立刻被客户信息填充完整。&lt;/p&gt;&lt;p&gt;据我所知，这款程序肯定不是用 Swing 编写的。但如今全球各地无数公司都在使用由 Swing 编写的企业级桌面软件，它们在使用体验上跟我当初接触的这款程序非常相似。换句话说，Swing 已经满足了我们在 2001、2002 年那会对于桌面业务软件的全部期望和想象。&lt;/p&gt;&lt;p&gt;在工作半年之后，上边来了新指示，要求我们用 Web 应用程序替换掉之前的桌面软件。据说新系统会让我们的工作更轻松，但在第一节培训课刚刚过去十分钟后，我们就意识到这根本就是胡说八道：新系统简直烂透了！&lt;/p&gt;&lt;p&gt;我不太记得当时使用的是 IE 5.5 还是 IE 6 了，总之就是前 AJAX 时代的 Web 环境。现在在产品字段中输入序号后，系统会弹出一个窗口，上面写着“正在加载……请勿关闭此窗口”。几秒后，窗口自行消失，客户详细信息出现在表单当中。反正每当需要从服务器获取内容时，这个倒霉窗口就会跳出来。领导还提醒我们别随便在浏览器里点“刷新”，说是这样会破坏系统状态。于是每每出现问题，我就只能先登出、再重新登录。&lt;/p&gt;&lt;p&gt;我不太理解公司为什么要用这款“傻了吧唧”的 Web 应用程序替代之前的桌面软件。可能是出于成本考虑吧，毕竟跟桌面软件相比，Web 应用程序的开发和维护成本都更低。或者是软件供应商强行施压，比如“Web 才是未来，每个人都必须接受！”但，真有这么强势的乙方吗？&lt;/p&gt;&lt;p&gt;无论如何，这里透露出一个重要的信息：&lt;strong&gt;Web 应用程序还没等发展完善，就已经开始蚕食桌面软件的生存空间。唯一的问题就是 Web 应用需要多久才能追平桌面软件的使用体验。而事实证明，用不了多久。&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;
&lt;span&gt;恐怖谷效应&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;再回到 Java 这边。热情的支持者们正不断扩大 Java 帝国的桌面版图，对 WORA（一次编写、随处运行）的热情也引导他们最终迈向跨平台小程序与“本机”应用程序之间的秘密山谷。那时候的 Java IDE 主要面向三大构建目标：&lt;/p&gt;&lt;section&gt;&lt;p&gt;1. 小程序&lt;br/&gt;2. Java Web 开发&lt;br/&gt;3. 可执行 Jar 文件&lt;/p&gt;&lt;/section&gt;&lt;p&gt;是的，没有直接开发本机应用程序的选项。虽然有第三方工具可以把 Jar 文件转换为本机应用程序，但这类工具相当复杂而且操作流程极为繁琐。只有对自己最“狠”的人才能坚持用得下去。而 Java 之所以有勇气忽视这一点，靠的就是对未来的判断——本机桌面应用程序终于被淘汰。其实这个预言是正确的，只是在时间上有所偏差。&lt;/p&gt;&lt;p&gt;从 2022 年的角度回顾，Java 身上其实有很多显而易见的问题。应用程序可以作为 Web 部署、也可以按本机部署，但这两种形式都没有一丁点“原生”感。Web 部署的小程序运行在自己的“沙箱”内并被集成到网页当中，整个运行过程又慢又迟钝。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;HTML5 的崛起&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;虽然 Java 总想在 Web 和桌面之间建起一道桥梁，但它自身却被 Web 所裹挟。到 2002 年，很多企业开始把原本的桌面软件功能迁移到 Web 端。这些 Web 应用程序的构建、维护和部署成本确实比桌面软件低得多，代价就是在用户体验上做出妥协。&lt;/p&gt;&lt;p&gt;大约也是在这个时候，Java 开始推崇“富互联网应用”的概念，希望把好 Web 应用跟差 Web 应用区分开来。但到 2004 年 Google Maps 正式亮相时，Java 的小把戏彻底宣告破产。Google Maps 以令人震惊的效果为富 Web 应用程序树立了标杆，而人家用的是 HTML5。&lt;/p&gt;&lt;p&gt;我最近又看了一次 Bill Atkinson 第一次向苹果爱好者们展示 MacPaint 的旧视频。在他第一次通过鼠标用画笔工具绘出图案时，现场一片“哇哦”和掌声。这就叫开创性。我第一次看到 Google Maps 也是类似的感觉，地图可以无缝缩放、万向平移，压根看不出来任何拼接的痕迹。这里使用的全新技术被称为 AJAX（异步 JavaScript 与 XML），这也是人们第一次能够在 Web 应用程序中向服务器后台无缝发出请求。现在这一切当然被视为理所当然，可 2004 年那会，开发者需要绞尽脑汁才能把那些让人想吐的框架或者弹窗隐藏起来，确保不用刷新整个页面就能从服务器处加载新数据。&lt;/p&gt;&lt;p&gt;身为 Web 开发者，我当然对其中的无穷可能性心生向往。但从桌面开发的角度看，这场历史性的变革似乎没有给桌面、特别是 Java 带来任何影响。&lt;/p&gt;&lt;p&gt;在 HTML5 之前，“跨平台”的意思是“跨 Windows、Mac 和 Linux”，所以跨的范围还是在桌面范畴之内。当时我并没意识到，但现在来看 HTML5 的亮相代表着新平台时代的降临——它将成为客户端应用程序的客观标准；更重要的是，Java 支持不了这个平台。突然之间，WORA 理念就出现空白了——Swing 应用程序适用于一切平台，除了最重要的那个：网络浏览器。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;Java 开发者纷纷“外逃”&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;那 Java 桌面开发者们都跑哪去了？方向主要有三：&lt;/p&gt;&lt;section&gt;&lt;p&gt;1. 服务器&lt;br/&gt;2. 浏览器（HTML5）&lt;br/&gt;3. 桌面应用&lt;/p&gt;&lt;/section&gt;&lt;p&gt;如果大家对自己的基本定位首先是“Java 开发者”、其次是“客户端开发者”，那最终应该会选择 Java 在当下仍然占据主动的平台——服务器。如果你对面向用户开发（客户端）更感兴趣，而且主要看中 Java 的跨平台价值主张，那接下来的目标很可能是 HTML5 （Javascript/HTML/CSS）开发。如果你是铁杆“保皇党”（比如说我），那就继续坚守 Java 桌面开发，同时满腹狐疑地看着自己这个圈子越来越小。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;GWT：让 Java 走进浏览器&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;2000 年初，JavaScript 开发工具尚处于起步阶段。大多数 Web 开发者只能使用文本编辑器来编写.js 文件。简单的验证脚本和交互设计倒是没问题，但这种粗糙的方法肯定不能扩展并支持大型企业应用程序项目。另外，当时的 JavaScript 语言还不具备开发者在重构等重要操作时所需要的功能，例如静态类型。&lt;/p&gt;&lt;p&gt;相比之下，Java 已经拥有一套全面的开发工具，能够轻松扩展至任何规模的项目。到 2004 年，领先且成熟的 Java IDE 已经成为开发环境中的标杆，其中的静态类型更是大大简化了大型项目的维护难度。到这时，唯一的遗憾就是 Java 应用程序无法在网络浏览器中运行（只有小程序可以）。&lt;/p&gt;&lt;p&gt;为了解决这个难题，Google 打造出 GWT（Google Web Toolkit）。这是一套 Java 到 JavaScript 的编译器加运行时库，允许开发者借助 Java 那一整套领先的开发工具编写应用程序，再把成果部署成 JavaScript 应用的形式在浏览器内原生运行。这套运行时库包含诸多核心 Java API（例如 java.lang、java.util 等）的实现，确保业务逻辑能够在 GWT 应用程序与服务器应用程序间顺畅共享。&lt;/p&gt;&lt;p&gt;在用户界面方面，GWT 也提供自己的功能部件，其实质就是以 Java 的形式将各部件与浏览器中的本机 HTML 部件相绑定。虽然我们还是没法直接使用 Swing 代码、大部分第三方库也不在支持之列，但我们至少可以用到自己最熟悉的 Java 开发环境和核心 API。&lt;/p&gt;&lt;p&gt;所以这不能算是让 Java 真正走进了浏览器——标准 JavaSE 库仍然大部分不受支持，线程等核心功能也无法起效。但至少对多数用例来说，这已经够了。&lt;/p&gt;&lt;p&gt;Google 用 GWT 开发出很多流行一时的 HTML5 应用程序，其中最著名的就是 Gmail，这个项目还催生出一个规模不大、但却相当活跃的开源社区。虽然影响力已经今非昔比，但这个社区直到现在也仍然存在。与此同时，JavaScript 工具的逐步改进也在挤占 GWT 的生存空间，过去十年来诞生的一系列更为现代的解决方案也允许我们在浏览器中更“无脑”地使用 Java。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;服务器上的淘金热&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;HTML5 的出现颠覆了 Java 制霸桌面的野心，但这里也有好消息。由于不必分神于桌面端，Java 在服务器端迎来了全面发展。Java 做好了战斗准备、努力满足开发者对后端服务的种种新需求——毕竟没有后端，再好的 Web 应用也出不来。&lt;/p&gt;&lt;p&gt;Java 在服务器端的受欢迎程度在接下来几年中持续增长，也吸引到整个生态系统的高度关注。第三方库不断涌现，而 2005 年 Maven 的诞生也让第三方库的使用不再复杂繁琐。无需额外下载、不必寻找依赖项，直接把片段粘贴到 pom 文件中，它就能自动下载一切相应依赖项。&lt;/p&gt;&lt;p&gt;Java 的开发工具也在不断改进，这在很大程度上要归功于 Java 在服务器端的优势地位。这些改进也对桌面开发者产生了积极影响，让我们用上了跟服务器端相同的 IDE、编译器、虚拟机和库。然而，代表 Java 世界“最后的坚持”的这帮桌面开发者眼界还是没能打开，仍在围着 UI 库的改进和部署打转。&lt;/p&gt;&lt;p&gt;遇到问题时，我的习惯是上 Google 搜一搜，看看有没有其他人遇到或者已经解决过相同的问题。但在 Swing 开发上，我发现最新的搜索结果也基本是 2005 年左右的内容了，之后基本再无新增。在找不到答案时，我偶尔会写一篇问题分析博文。而在两年后再次遇到类似问题时，我在 Google 上找到的就是自己两年前那篇博文……说真的，现在还有喘气的 Swing 开发者吗？感觉真的说不好。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;重新定义“桌面应用”&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;从各个方面来看，Web 的兴起让“桌面应用”的概念清晰了起来。Java 最初的跨平台客户端开发愿景并没有把瘦客户端（主要与远程服务器交互）跟本机完整桌面应用程序区分开来。这不仅提高了理解难度，更让安全模型的设计有些无所适从。Java 理解中的“平台”就是计算机本身，所以会使用笨拙的沙箱来限制可能引发安全威胁的 API 访问，例如访问文件系统。这是 Java 一切安全漏洞的根源，也是导致 Java 被逐出浏览器世界的原因。&lt;/p&gt;&lt;p&gt;这种基于“沙箱”的开发体验相当糟糕，因为我们很容易意外“越界”并触发安全异常。最终结果是，几乎所有客户端都会请求对系统进行“可信”访问，这样也就完全绕过了沙箱的限制。&lt;/p&gt;&lt;p&gt;相比之下，HTML5 在 Web 和桌面之间设立了明确的边界。Web 应用程序默认无权访问客户端计算机，而浏览器才是那个“平台”，这就让客户端应用程序的安全保障变得更轻松、更易行。&lt;/p&gt;&lt;p&gt;经过此番变革，“桌面”的范畴变得更小，以往很多被视为“桌面应用程序”的软件现在被划入“客户端应用程序”类别。具体来讲，如果应用程序只负责在用户与服务器交互时提供 UI，那它就属于客户端应用程序。“桌面”这个概念现在指的就是那些以某种方式与本机设备相集成的应用程序，包括访问文件系统（开发工具、文件转换工具等）、调用浏览器中不存在的某些平台本机 API、以及执行算力密集型任务的软件。&lt;/p&gt;&lt;p&gt;这倒不是说“客户端”应用程序跟“桌面”应用程序间就毫无交集——当然有，这两者都涉及 GUI，而且不少现代桌面应用程序也都需要接入服务器。所以无论是桌面还是客户端应用程序，都能享受到 GUI 工具包改进、媒体（音频 / 视频）及网络等技术层面的改进成果。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;Java 桌面的新征程&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;2004 年，我曾在 Mac 和 Windows 上都开发出一些商用级别的 Java 桌面应用程序。HTML5 对这类应用程序基本没有任何直接影响。结合自身需求，Swing 还是完全够用，我用来构建本机捆绑包的各种桌面部署工具也都能正常起效。&lt;/p&gt;&lt;p&gt;但很遗憾，科技行业就是个不进则退的世界。在接下来的几年中，Web 平台一路突飞猛进、而 Swing 却始终停滞不前。到 2007 年，Swing 已经到了不变革、就消亡的危难关头。它需要响应 HTML5 这波历史性潮流，而最终答案就是 JavaFX。这是一种新奇的 Java UI 工具包，能够把 Java 带入 GPU 加速、场景图、3D 图形、Web 视图的现代新世界，同时支持 MP3 和 MP4 等现代音视频编解码器。&lt;/p&gt;&lt;p&gt;在下一篇文章中，我们将回顾 JavaFX 的火爆人气、深远影响，以及 2011 年 Mac 应用商店出现前 Java 领域的其他发展趋势。别小瞧 Mac 应用商店，它的出现堪称对 Java for Mac 桌面开发生态的“斩首行动”。&lt;/p&gt;&lt;p&gt;（感兴趣的朋友可以多留言，InfoQ 将根据大家的需求继续翻译系列文章，以飨读者）&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://jdeploy.substack.com/p/the-decline-and-fall-of-java-on-the-970&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;今日好文推荐&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651111518&amp;amp;idx=1&amp;amp;sn=ffeb59fa91740f58805dc645b4514ef1&amp;amp;chksm=bdb9380d8aceb11b31fa55cb361ac2a78c643e98955eaed12e51b0abf1ddcde31f045c841c06&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;云端开发是个坑！4年后，我们又回到了本地环境&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651111905&amp;amp;idx=1&amp;amp;sn=07ea419d3211c76030ddf980671647c4&amp;amp;chksm=bdb939b28aceb0a4b455b11bbe577da64f11790f51fb3c97fbfe7c01e1fa13b67fe3c8d98745&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;互联网企业给被裁员工发“毕业须知”；孟晚舟担任华为轮值董事长；腾讯员工被曝偷看创业公司工作文档 | Q资讯&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;互联网企业给被裁员工发“毕业须知”；孟晚舟担任华为轮值董事长；腾讯员工被曝偷看创业公司工作文档 | Q资讯&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651111518&amp;amp;idx=1&amp;amp;sn=ffeb59fa91740f58805dc645b4514ef1&amp;amp;chksm=bdb9380d8aceb11b31fa55cb361ac2a78c643e98955eaed12e51b0abf1ddcde31f045c841c06&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;云端开发是个坑！4年后，我们又回到了本地环境&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;云端开发是个坑！4年后，我们又回到了本地环境&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651111224&amp;amp;idx=1&amp;amp;sn=7b16797189197654afb16f1f8fc2ccbc&amp;amp;chksm=bdb9476b8acece7d1d0abc9ac821f64577a02dfcfb0ae20bf2645450a70419d2a304c8f1d066&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;不用任何框架开发 Web 应用程序，可能吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;不用任何框架开发 Web 应用程序，可能吗？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651111220&amp;amp;idx=1&amp;amp;sn=e6f3724e018a4d505e55c54881e5ecfe&amp;amp;chksm=bdb947678acece71bc15dda607017bca216f604f6cf75db79aa6067e3cba9ddb8054d150a80d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;腾讯回应裁员；小米辞退绩效考核分数低员工终审败诉；GitHub 频繁宕机原因：MySQL 负载过重 | Q资讯&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;腾讯回应裁员；小米辞退绩效考核分数低员工终审败诉；GitHub 频繁宕机原因：MySQL 负载过重 | Q资讯&lt;/a&gt;&lt;span&gt;      
                &lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt; &lt;span/&gt;&lt;span&gt;活动推荐&lt;/span&gt;&lt;/p&gt;&lt;p&gt;今年 6 月 10 日 -11 日，GMTC 全球大前端技术大会将再一次落地北京。其中「移动端性能与效率优化」专题，邀请到阿里巴巴无线开发专家储龙江（大音）老师现场分享，想了解阿里是如何给亿级用户规模的 App 做线上稳定性监控和客户端运维的？点击底部&lt;strong&gt;【阅读原文】&lt;/strong&gt;查看更多。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;大会门票 8 折优惠中，组团学习还有更多折扣哦～联系票务经理：+86 13269078023（同微信）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VPgjDlDjj62rWbZgQLf1x8kd2kdpoGXBLCnIeIw0v4SrlV7UQOcwdw2oWNIsetpaiagicAu9fbBZzVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点个在看少个 bug&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>