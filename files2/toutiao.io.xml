<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>4b88104a8252db55bb625ea849e199c4</guid>
<title>一文理解 ThreadLocal</title>
<link>https://toutiao.io/k/7jywmxc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-source-line=&quot;1&quot;&gt;本文讲解ThreadLocal、InheritableThreadLocal与TransmittableThreadLocal。&lt;/p&gt;&lt;p data-source-line=&quot;3&quot;&gt;有关本文的实验代码，可以查看文末补充：“比较一下ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal在线程池复用线程的情况下的执行情况”。&lt;/p&gt;&lt;h2 data-source-line=&quot;5&quot;&gt;ThreadLocal&lt;/h2&gt;&lt;h3 data-source-line=&quot;7&quot;&gt;ThreadLocal的使用场景&lt;/h3&gt;&lt;ol data-source-line=&quot;9&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;分布式跟踪系统&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;日志收集记录系统上下文&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Session级Cache&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;应用容器或上层框架跨应用代码给下层SDK传递信息&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;14&quot;&gt;举例：&lt;/p&gt;&lt;ol data-source-line=&quot;16&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Spring的事务管理，用ThreadLocal存储Connection，从而各个DAO可以获取同一Connection，可以进行事务回滚，提交等操作。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;某些业务场景下，需要强制读主库来保证数据的一致性。在Sharding-JDBC中使用了ThreadLocal来存储相关配置信息，实现优雅的数据传递。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Spring Cloud Zuul用过滤器可以实现权限认证，日志记录，限流等功能，多个过滤器之间透传数据，底层使用了ThreadLocal。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在整个链路的日志中输出当前登录的用户ID，首先就得在拦截器获取过滤器中获取用户。ID，然后将用户ID进行存储到slf4j的MDC对象（底层使用ThreadLocal），然后进行链路传递打印日志。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-source-line=&quot;21&quot;&gt;ThreadLocal的结构&lt;/h3&gt;&lt;ol data-source-line=&quot;23&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;ThreadLocal的get()、set()方法，实际操作的都是Thread.currentThread()，即当前线程的threadLocals变量。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;threadLocals变量包含了一个map成员变量（ThreadLocalMap）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;ThreadLocalMap的key为当前ThreadLocal, value为set的值。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;27&quot;&gt;相同的key在不同的散列表中的值必然是独立的，每个线程都是在各自的散列表中执行操作，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.725&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7EicBhMWxhH71IOArGVZECQbRxiccuwymCK2LMPOxkFPDqtS5PPg3AgayPtDxicKyWHMT7jF8hgjjf0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;31&quot;&gt;ThreadLocal的set方法：&lt;/p&gt;&lt;pre data-source-line=&quot;33&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;(T value) {&lt;br/&gt;    &lt;span&gt;//currentThread&lt;span&gt;是个&lt;/span&gt;native&lt;span&gt;方法，会返回对当前执行线程对象的引用。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;Thread&lt;/span&gt; t = &lt;span&gt;Thread&lt;/span&gt;.currentThread();&lt;br/&gt;    &lt;span&gt;//getMap &lt;span&gt;返回线程自身的&lt;/span&gt;threadLocals&lt;/span&gt;&lt;br/&gt;    ThreadLocalMap &lt;span&gt;map&lt;/span&gt; = getMap(t);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;map&lt;/span&gt; != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;//&lt;span&gt;把&lt;/span&gt;value set&lt;span&gt;到线程自身的&lt;/span&gt;ThreadLocalMap&lt;span&gt;中了&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;map&lt;/span&gt;.&lt;span&gt;set&lt;/span&gt;(this, value);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;//&lt;span&gt;线程自身的&lt;/span&gt;ThreadLocalMap&lt;span&gt;未初始化，则先初始化，再&lt;/span&gt;set&lt;/span&gt;&lt;br/&gt;        createMap(t, value);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;ThreadLocalMap getMap(&lt;span&gt;Thread&lt;/span&gt; t) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; t.threadLocals;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;54&quot;&gt;ThreadLocal在set的时候，没有进行相应的深拷贝，所以ThreadLocal要想做线程隔离，必须是基本类型或者是Runable实现类的局部变量。&lt;/p&gt;&lt;h3 data-source-line=&quot;56&quot;&gt;ThreadLocal造成内存泄漏&lt;/h3&gt;&lt;p data-source-line=&quot;58&quot;&gt;ThreadLocalMap内部Entry：&lt;/p&gt;&lt;pre data-source-line=&quot;59&quot;&gt;&lt;code&gt;static &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt;&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/** The value associated with this ThreadLocal. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;Object&lt;/span&gt; value;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;Entry&lt;/span&gt;(&lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt; k, &lt;span&gt;Object&lt;/span&gt; v) {&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(k);&lt;br/&gt;        value = v;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;70&quot;&gt;从代码中看到，Entry继承了WeakReference，并将ThreadLocal设置为了WeakReference，value设置为强引用。也就是：当没有强引用指向ThreadLocal变量时，它可被回收。&lt;/p&gt;&lt;p data-source-line=&quot;72&quot;&gt;内存泄漏风险：ThreadLocalMap维护ThreadLocal变量与具体实例的映射，当ThreadLocal变量被回收后（变为null），无法路由到ThreadLocalMap。而该Entry还是在ThreadLocalMap中，从而这些无法清理的Entry，会造成内存泄漏。&lt;/p&gt;&lt;p data-source-line=&quot;74&quot;&gt;所以，在使用ThreadLocal的时候，会话结束前务必使用ThreadLocal.remove方法（remove方法会将Entry的value及Entry自身设置为null并进行清理）。&lt;/p&gt;&lt;h3 data-source-line=&quot;76&quot;&gt;ThreadLocal的最佳实践&lt;/h3&gt;&lt;ol data-source-line=&quot;78&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;ThreadLocal使用时必须显式地调用remove方法来避免内存泄漏。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;ThreadLocal对象建议使用static修饰。这样做的好处是可以避免重复创建对象所导致的浪费（类第一次被使用时装载，只分配一块存储空间）。坏处是正好形成内存泄漏所需的条件(延长了ThreadLocal的生命周期，因此需要remove方法兜底)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;注释说明使用场景。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对性能有极致要求可以参考开源框架优化后的类，比如Netty的FastThreadLocal、Dubbo的InternalThreadLocal等。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-source-line=&quot;83&quot;&gt;InheritableThreadLocal&lt;/h2&gt;&lt;p data-source-line=&quot;85&quot;&gt;在全链路跟踪框架中，Trace信息的传递功能是基于ThreadLocal的。但实际业务中可能会使用异步调用，这样就会丢失Trace信息，破坏了链路的完整性。&lt;/p&gt;&lt;p data-source-line=&quot;87&quot;&gt;此时可以使用JDK实现的InheritableThreadLocal，但它只支持父子线程间传递信息（例如：paramstream、new Thread等）。&lt;/p&gt;&lt;p data-source-line=&quot;89&quot;&gt;Thread内部为InheritableThreadLocal开辟了一个单独的ThreadLocalMap（与ThreadLocal并列的成员变量）。在父线程创建一个子线程的时候，会检查这个ThreadLocalMap是否为空，不为空则会浅拷贝给子线程的ThreadLocalMap。&lt;/p&gt;&lt;p data-source-line=&quot;91&quot;&gt;从类的继承层次来看，InheritableThreadLocal只是在ThreadLocal的get、set、remove流程中，重写了getMap、createMap方法，整体流程与ThreadLocal保持一致。&lt;/p&gt;&lt;p data-source-line=&quot;93&quot;&gt;Thread的init相关逻辑如下：&lt;/p&gt;&lt;pre data-source-line=&quot;94&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (parent.inheritableThreadLocals != null)&lt;br/&gt;    this.inheritableThreadLocals = &lt;span&gt;&lt;span&gt;&lt;span&gt;ThreadLocal&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;create&lt;span&gt;InheritedMap(&lt;span&gt;parent&lt;/span&gt;.&lt;span&gt;inheritableThreadLocals&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-source-line=&quot;99&quot;&gt;&lt;p&gt;需要注意的是拷贝为浅拷贝。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-source-line=&quot;101&quot;&gt;TransmittableThreadLocal&lt;/h2&gt;&lt;p data-source-line=&quot;103&quot;&gt;InheritableThreadLocal可以在父线程创建子线程的时候将ThreadLocal中的值传递给子线程，从而完成链路跟踪框架中的上下文传递。&lt;/p&gt;&lt;p data-source-line=&quot;105&quot;&gt;但大部分业务应用都会使用线程池，这种复用线程的池化场景中，线程池中的线程和主线程并不都是父子线程的关系，不能直接使用InheritableThreadLocal。&lt;/p&gt;&lt;blockquote data-source-line=&quot;107&quot;&gt;&lt;p&gt;例如从Tomcat的线程（池化）提交task到业务线程池，就不能直接使用InheritableThreadLocal。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-source-line=&quot;109&quot;&gt;Transmittable ThreadLocal（简称TTL）是阿里开源的库，继承了InheritableThreadLocal，实现线程本地变量在线程池的执行过程中，能正常的访问父线程设置的线程变量。&lt;/p&gt;&lt;h3 data-source-line=&quot;111&quot;&gt;TransmittableThreadLocal实现原理&lt;/h3&gt;&lt;p data-source-line=&quot;113&quot;&gt;InheritableThreadLocal不支持池化线程提交task到业务线程池的根本原因是，父线程创建子线程时，子线程InheritableThreadLocal只会复制一次环境变量。要支持线程池中能访问提交任务线程的本地变量，只需要在线程向线程池提交任务时复制父线程的上下环境，那在线程池中就能够访问到父线程中的本地变量，实现本地环境变量在线程池调用中的透传。&lt;/p&gt;&lt;blockquote data-source-line=&quot;115&quot;&gt;&lt;p&gt;源码见于参考文档1，README有很详细的讲解，核心源码也不难，建议看看。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-source-line=&quot;117&quot;&gt;&lt;p&gt;此外，项目引入TTL的时候，可以使用Java Agent植入修饰代码，修改runnable或者callable类，可以做到对应用代码无侵入（这个在README也有相关讲解）。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-source-line=&quot;119&quot;&gt;补充说明&lt;/h1&gt;&lt;p data-source-line=&quot;121&quot;&gt;ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal在线程池复用线程的情况下的执行情况如下：&lt;/p&gt;&lt;h2 data-source-line=&quot;123&quot;&gt;1.线程局部变量为基础类型&lt;/h2&gt;&lt;h3 data-source-line=&quot;124&quot;&gt;1.1 ThreadLocal&lt;/h3&gt;&lt;pre data-source-line=&quot;125&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; TransmittableThreadLocalTest1 {&lt;br/&gt;    static ThreadLocal&amp;lt;&lt;span&gt;Integer&lt;/span&gt;&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    static ExecutorService executorService =&lt;br/&gt;            Executors.newFixedThreadPool(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; static &lt;span&gt;void&lt;/span&gt; main(String[] args) throws InterruptedException {&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;主线程开启&lt;/span&gt;&quot;);&lt;br/&gt;        threadLocal.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;&lt;br/&gt;        executorService.submit(() -&amp;gt; {&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        TimeUnit.SECONDS.sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        threadLocal.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;&lt;br/&gt;        executorService.submit(() -&amp;gt; {&lt;br/&gt;            //[&lt;span&gt;没有读到了主线程修改后的新值&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;            threadLocal.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        TimeUnit.SECONDS.sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        //&lt;span&gt;依旧读取的是&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;158&quot;&gt;输出结果为：&lt;/p&gt;&lt;pre data-source-line=&quot;159&quot;&gt;&lt;code&gt;&lt;span&gt;主线程开启&lt;/span&gt;&lt;br/&gt;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-source-line=&quot;168&quot;&gt;1.2 InheritableThreadLocal&lt;/h3&gt;&lt;pre data-source-line=&quot;169&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; TransmittableThreadLocalTest2 {&lt;br/&gt;    static ThreadLocal&amp;lt;&lt;span&gt;Integer&lt;/span&gt;&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    static ExecutorService executorService =&lt;br/&gt;            Executors.newFixedThreadPool(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; static &lt;span&gt;void&lt;/span&gt; main(String[] args) throws InterruptedException {&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;主线程开启&lt;/span&gt;&quot;);&lt;br/&gt;        threadLocal.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;&lt;br/&gt;        executorService.submit(() -&amp;gt; {&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        TimeUnit.SECONDS.sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        threadLocal.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;&lt;br/&gt;        executorService.submit(() -&amp;gt; {&lt;br/&gt;            //[&lt;span&gt;没有读到了主线程修改后的新值&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;            threadLocal.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        TimeUnit.SECONDS.sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        //&lt;span&gt;依旧读取的是&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;202&quot;&gt;输出结果为：&lt;/p&gt;&lt;pre data-source-line=&quot;203&quot;&gt;&lt;code&gt;&lt;span&gt;主线程开启&lt;/span&gt;&lt;br/&gt;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-source-line=&quot;212&quot;&gt;1.3 TransmittableThreadLocal&lt;/h3&gt;&lt;pre data-source-line=&quot;214&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; TransmittableThreadLocalTest3 {&lt;br/&gt;    static ThreadLocal&amp;lt;&lt;span&gt;Integer&lt;/span&gt;&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; TransmittableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    static ExecutorService executorService =&lt;br/&gt;            TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; static &lt;span&gt;void&lt;/span&gt; main(String[] args) throws InterruptedException {&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;主线程开启&lt;/span&gt;&quot;);&lt;br/&gt;        threadLocal.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;&lt;br/&gt;        executorService.submit(() -&amp;gt; {&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        TimeUnit.SECONDS.sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        threadLocal.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;&lt;br/&gt;        executorService.submit(() -&amp;gt; {&lt;br/&gt;            //[&lt;span&gt;读到了主线程修改后的新值&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;            threadLocal.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        TimeUnit.SECONDS.sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        //&lt;span&gt;依旧读取的是&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.println(&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot; + threadLocal.&lt;span&gt;get&lt;/span&gt;());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;247&quot;&gt;输出结果为：&lt;/p&gt;&lt;pre data-source-line=&quot;248&quot;&gt;&lt;code&gt;&lt;span&gt;主线程开启&lt;/span&gt;&lt;br/&gt;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-source-line=&quot;257&quot;&gt;2.线程局部变量为类对象&lt;/h2&gt;&lt;p data-source-line=&quot;258&quot;&gt;首先定义一个数据类：&lt;/p&gt;&lt;pre data-source-line=&quot;259&quot;&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@AllArgsConstructor&lt;/span&gt;&lt;br/&gt;class UserSession{&lt;br/&gt;    &lt;span&gt;String&lt;/span&gt; &lt;span&gt;uuid&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;String&lt;/span&gt; &lt;span&gt;nickname&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-source-line=&quot;267&quot;&gt;2.1 ThreadLocal&lt;/h3&gt;&lt;pre data-source-line=&quot;268&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; TransmittableThreadLocalTest4 {&lt;br/&gt;    static ThreadLocal&amp;lt;UserSession&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;&lt;span&gt;()&lt;/span&gt;;&lt;br/&gt;    static ExecutorService executorService =&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&lt;span&gt;Executors&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;FixedThreadPool(1)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    public static void main(String&lt;span&gt;[]&lt;/span&gt; args) throws InterruptedException {&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;主线程开启&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;        threadLocal.set(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;UserSession(&lt;span&gt;&quot;001&quot;&lt;/span&gt;,&lt;span&gt;&quot;hello&quot;&lt;/span&gt;)&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        executorService.submit(&lt;span&gt;()&lt;/span&gt; -&amp;gt; {&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;TimeUnit&lt;/span&gt;.&lt;/span&gt;&lt;span&gt;&lt;span&gt;SECONDS&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        threadLocal.get&lt;span&gt;()&lt;/span&gt;.set&lt;span&gt;Nickname(&lt;span&gt;&quot;world&quot;&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        executorService.submit(&lt;span&gt;()&lt;/span&gt; -&amp;gt; {&lt;br/&gt;            &lt;span&gt;//[&lt;span&gt;没有读到了主线程修改后的新值&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;            threadLocal.get&lt;span&gt;()&lt;/span&gt;.set&lt;span&gt;Nickname(&lt;span&gt;&quot;Java&quot;&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;TimeUnit&lt;/span&gt;.&lt;/span&gt;&lt;span&gt;&lt;span&gt;SECONDS&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//&lt;span&gt;依旧读取的是&lt;/span&gt; world&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;301&quot;&gt;输出结果为：&lt;/p&gt;&lt;pre data-source-line=&quot;302&quot;&gt;&lt;code&gt;&lt;span&gt;主线程开启&lt;/span&gt;&lt;br/&gt;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;UserSession(&lt;span&gt;uuid&lt;/span&gt;=001, &lt;span&gt;nickname&lt;/span&gt;=hello)&lt;br/&gt;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;UserSession(&lt;span&gt;uuid&lt;/span&gt;=001, &lt;span&gt;nickname&lt;/span&gt;=world)&lt;br/&gt;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;UserSession(&lt;span&gt;uuid&lt;/span&gt;=001, &lt;span&gt;nickname&lt;/span&gt;=world)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-source-line=&quot;310&quot;&gt;2.2 InheritableThreadLocal&lt;/h3&gt;&lt;pre data-source-line=&quot;311&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; TransmittableThreadLocalTest5 {&lt;br/&gt;    static ThreadLocal&amp;lt;UserSession&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;&lt;span&gt;()&lt;/span&gt;;&lt;br/&gt;    static ExecutorService executorService =&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&lt;span&gt;Executors&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;FixedThreadPool(1)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    public static void main(String&lt;span&gt;[]&lt;/span&gt; args) throws InterruptedException {&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;主线程开启&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;        threadLocal.set(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;UserSession(&lt;span&gt;&quot;001&quot;&lt;/span&gt;,&lt;span&gt;&quot;hello&quot;&lt;/span&gt;)&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        executorService.submit(&lt;span&gt;()&lt;/span&gt; -&amp;gt; {&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;TimeUnit&lt;/span&gt;.&lt;/span&gt;&lt;span&gt;&lt;span&gt;SECONDS&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        threadLocal.get&lt;span&gt;()&lt;/span&gt;.set&lt;span&gt;Nickname(&lt;span&gt;&quot;world&quot;&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        executorService.submit(&lt;span&gt;()&lt;/span&gt; -&amp;gt; {&lt;br/&gt;            &lt;span&gt;//[&lt;span&gt;读到了主线程修改后的新值&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;            threadLocal.get&lt;span&gt;()&lt;/span&gt;.set&lt;span&gt;Nickname(&lt;span&gt;&quot;Java&quot;&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;TimeUnit&lt;/span&gt;.&lt;/span&gt;&lt;span&gt;&lt;span&gt;SECONDS&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//&lt;span&gt;读取的是&lt;/span&gt; Java&lt;span&gt;（因为浅拷贝）&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-source-line=&quot;344&quot;&gt;&lt;code&gt;&lt;span&gt;主线程开启&lt;/span&gt;&lt;br/&gt;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;UserSession(&lt;span&gt;uuid&lt;/span&gt;=001, &lt;span&gt;nickname&lt;/span&gt;=hello)&lt;br/&gt;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;UserSession(&lt;span&gt;uuid&lt;/span&gt;=001, &lt;span&gt;nickname&lt;/span&gt;=hello)&lt;br/&gt;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;UserSession(&lt;span&gt;uuid&lt;/span&gt;=001, &lt;span&gt;nickname&lt;/span&gt;=world)&lt;br/&gt;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;UserSession(&lt;span&gt;uuid&lt;/span&gt;=001, &lt;span&gt;nickname&lt;/span&gt;=world)&lt;br/&gt;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;UserSession(&lt;span&gt;uuid&lt;/span&gt;=001, &lt;span&gt;nickname&lt;/span&gt;=Java)&lt;br/&gt;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;UserSession(&lt;span&gt;uuid&lt;/span&gt;=001, &lt;span&gt;nickname&lt;/span&gt;=Java)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-source-line=&quot;353&quot;&gt;2.3 InheritableThreadLocal&lt;/h3&gt;&lt;pre data-source-line=&quot;355&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; TransmittableThreadLocalTest6 {&lt;br/&gt;    static ThreadLocal&amp;lt;UserSession&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; TransmittableThreadLocal&amp;lt;&amp;gt;&lt;span&gt;()&lt;/span&gt;;&lt;br/&gt;    static ExecutorService executorService =&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&lt;span&gt;TtlExecutors&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;get&lt;span&gt;TtlExecutorService(Executors.&lt;span&gt;newFixedThreadPool&lt;/span&gt;(1)&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    public static void main(String&lt;span&gt;[]&lt;/span&gt; args) throws InterruptedException {&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;主线程开启&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;        threadLocal.set(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;UserSession(&lt;span&gt;&quot;001&quot;&lt;/span&gt;,&lt;span&gt;&quot;hello&quot;&lt;/span&gt;)&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        executorService.submit(&lt;span&gt;()&lt;/span&gt; -&amp;gt; {&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;TimeUnit&lt;/span&gt;.&lt;/span&gt;&lt;span&gt;&lt;span&gt;SECONDS&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        threadLocal.get&lt;span&gt;()&lt;/span&gt;.set&lt;span&gt;Nickname(&lt;span&gt;&quot;world&quot;&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        executorService.submit(&lt;span&gt;()&lt;/span&gt; -&amp;gt; {&lt;br/&gt;            &lt;span&gt;//[&lt;span&gt;读到了主线程修改后的新值&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;            threadLocal.get&lt;span&gt;()&lt;/span&gt;.set&lt;span&gt;Nickname(&lt;span&gt;&quot;Java&quot;&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;子线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;TimeUnit&lt;/span&gt;.&lt;/span&gt;&lt;span&gt;&lt;span&gt;SECONDS&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//&lt;span&gt;读取的是&lt;/span&gt; Java&lt;span&gt;（因为浅拷贝）&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&lt;span&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(&lt;span&gt;&quot;&lt;span&gt;主线程读取本地变量：&lt;/span&gt;&quot;&lt;/span&gt; + threadLocal.get&lt;span&gt;()&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;388&quot;&gt;输出结果与上面2.2的结果一样&lt;/p&gt;&lt;p data-source-line=&quot;391&quot;&gt;参考文档：&lt;/p&gt;&lt;ol data-source-line=&quot;392&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;https://github.com/alibaba/transmittable-thread-local&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0a19e07c6e6eed89ff0bb4e5ee7b38db</guid>
<title>携程最终一致和强一致性缓存实践</title>
<link>https://toutiao.io/k/nvmnd0f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:0.title1&quot;&gt;&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;GSF，携程高级技术专家，关注高可用、高并发系统建设，致力于用技术驱动业务。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;一、前言&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程金融从成立至今，整体架构经历了从0到1再到10的变化，其中有多个场景使用了缓存来提升服务质量。从系统层面看，使用缓存的目的无外乎缓解DB压力（主要是读压力），提升服务响应速度。引入缓存，就不可避免地引入了缓存与业务DB数据的一致性问题，而不同的业务场景，对数据一致性的要求也不同。本文将从以下两个场景介绍我们的一些缓存实践方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：我们DB用的是MySQL，缓存介质用的是携程高可用Redis服务，存储介质的选型及存储服务的高可用不是本文重点，后文也不再做特别说明。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;二、最终一致性分布式缓存场景&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2.1 场景描述&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过几年演进，携程金融形成了自顶向下的多层次系统架构，如业务层、平台层、基础服务层等，其中用户信息、产品信息、订单信息等基础数据由基础平台等底层系统产生，服务于所有的金融系统，对这部分基础数据我们引入了统一的缓存服务（系统名utag），缓存数据有三大特点：全量、准实时、永久有效，在数据实时性要求不高的场景下，业务系统可直接调用统一的缓存查询接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的典型使用场景有：风控流程、APP入口信息提示等，而对数据一致性要求高的场景依然需要走实时的业务接口查询。引入缓存前后系统架构对比如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cQzdDVSm0jV87CjsyvX1dq6G3wyHYyH4YsN0ICytVicNlYFX8amhZnyicNAygAuZMtTGe71VpbGL5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;统一缓存服务的构建给部门的整体系统架构带来了一些优势：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对业务系统：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;对基础服务：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;整体而言，缓存服务处于中间层，数据的写入方和数据查询方解耦，数据甚至可以在底层系统不感知的情况下写入（见下文），而数据使用方的查询也可在底层服务不可用或“堵塞”时候仍然保持可用（前提是缓存服务是可用的，而缓存服务的处理逻辑简单、统一且有多种手段保证，其可用性比单个子系统都高），整体上服务的稳定性得到了提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在构建此统一缓存服务时候，有三个关键目标：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据准确性：DB中单条数据的更新一定要准确同步到缓存服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据完整性：将对应DB表的全量数据进行缓存且永久有效，从而可以替代对应的DB查询。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;系统可用性：我们多个产品线的多个核心服务都已经接入，utag的高可用性显的尤为关键。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来先说明统一缓存服务的整体方案，再逐一介绍此三个关键特性的设计实现方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2.2 整体方案&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;我们的系统在多地都有部署，故缓存服务也做了相应的异地多机房部署，一来可以让不同地区的服务调用本地区服务，无需跨越网络专线，二来也可以作为一种灾备方案，增加可用性。&lt;/h3&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于缓存的写入，由于缓存服务是独立部署的，因此需要感知业务DB数据变更然后触发缓存的更新，本着“可以多次更新，但不能漏更新”的原则，我们设计了多种数据更新触发源：定时任务扫描，业务系统MQ、binlog变更MQ，相互之间作为互补来保证数据不会漏更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外为了缓存更新流程的统一和与触发源的解耦，我们使用MQ来驱动多地多机房的缓存更新，在不同的触发源触发后，会查询最新的DB数据，然后发出一个缓存更新的MQ消息，不同地区机房的缓存系统同时监听该主题并各自进行缓存的更新。对于MQ我们使用携程开源消息中间件QMQ 和 Kafka，在公司内部QMQ和Kafka也做了异地机房的互通。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于缓存的读取，utag系统提供dubbo协议的缓存查询接口，业务系统可调用本地区的接口，省去了网络专线的耗时（50ms延迟）。在utag内部查询redis数据，并反序列化为对应的业务model，再通过接口返回给业务方。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了描述方便，以下异地多机房部署统一使用AB两地部署的概念进行说明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体框架如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.434375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cQzdDVSm0jV87CjsyvX1dqZxgdChGjkglNX2bdaY3KWGZLXYu8yw8MWdQDz9C8gfLIhKPCjR3nag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;接下来介绍一下几个关键点的设计 。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2.3  数据准确性设计&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同的触发源，对缓存更新过程是一样的，整个更新步骤可抽象为4步：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;step1：触发更新，查询DB中的新数据，并发送统一的MQ&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;step2：接收MQ，查询缓存中的老数据&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;step3：新老数据对比，判断是否需要更新&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;step4：若需要，则更新缓存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于我们业务的大部分核心系统和所有的DB都在A地机房，所以触发源（如binlog的消费、业务MQ的接收、扫表任务的执行）都在A侧，触发更新后，第一步查询DB数据也只能在A侧查询（避免跨网络专线的数据库连接，影响性能）。查询到新数据后，发送更新缓存的MQ，两地机房的utag服务进行消费，之后进行统一的缓存更新流程。总体的缓存更新方案如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.24765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cQzdDVSm0jV87CjsyvX1dqbEKRHU1XBjvibPRFOdHibroiau3YDLuL1ia4S3UIX2vqBexgykjSgOFjTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于有多个触发源，不同的触发源之间可能会对同一条数据的缓存更新请求出现并发，此外可能出现同一条数据在极短时间内（如1秒内）更新多次，无法区分数据更新顺序，因此需要做两方面的操作来确保数据更新的准确性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）并发控制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若一条DB数据出现了多次更新，且刚好被不同的触发源触发，更新缓存时候若未加控制，可能出现数据更新错乱，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.20859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6ka2RxW76IBUXLWZsrkCfHNG1auzKDKYwGQTe0lib0lXKJBZVibdD2w3Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;故需要将第2、3、4步加锁，使得缓存刷新操作全部串行化。由于utag本身就依赖了redis，此处我们的分布式锁就基于redis实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）基于updateTime的更新顺序控制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即使加了锁，也需要进一步判断当前db数据与缓存数据的新老，因为到达缓存更新流程的顺序并不代表数据的真正更新顺序。我们通过对比新老数据的更新时间来实现数据更新顺序的控制。若新数据的更新时间大于老数据的更新时间，则认为当前数据可以直接写入缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们系统从建立之初就有自己的MySQL规范，每张表都必须有update_time字段，且设置为ON UPDATE CURRENT_TIMESTAMP，但是并没有约束时间字段的精度，大部分都是秒级别的，因此在同一秒内的多次更新操作就无法识别出数据的新老。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对同一秒数据的更新策略我们采用的方案是：先进行数据对比，若当前数据与缓存数据不相等，则直接更新，并且发送一条延迟消息，延迟1秒后再次触发更新流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举个例子：假设同一秒内同一条数据出现了两次更新，value=1和value=2，期望最终缓存中的数据是value=2。若这两次更新后的数据被先后触发，分两种情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1680064308681672&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kfTib68l3Ddht8K0UFPzQkicv6wfcFILJF76HBaKy1mfAjib2gxaX1a1Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1244&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过以上方案我们可以确保缓存数据的准确性。有几个点需要额外说明：  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实不用延迟消息也是可以的，毕竟DB数据的更新时间是不变的，但是考虑到出现同一秒更新的可能是高频更新场景，若直接发消息，然后立即消费并触发二次更新，可能依然查到同一秒内更新的其他数据，为减少此种情况下的多次循环更新，延迟几秒再刷新可作为一种优化策略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为删除操作和update操作无法进行数据对比，无法确定操作的先后顺序，进而可能导致更新错乱。而在数据异常宝贵的时代，一般的业务系统中也没有物理删除的逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以将查DB、查缓存、数据对比、更新缓存这四个步骤全部放到锁的范围内，这样就不需要处理同一秒的顺序问题。因为在这个串行化操作中每次都从DB中查询到了最新的数据，可以直接更新，而时间的判断、值的判断可以作为优化操作，减少缓存的更新次数，也可以减少锁定的时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而我们为何不采用该方案？因为查询DB的操作我们只能在一侧机房处理，无法让AB两地系统的更新流程统一，也就降低了二者互备的可能性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2.4  数据完整性设计&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述数据准确性是从单条数据更新角度的设计，而我们构建缓存服务的目的是替代对应DB表的查询，因此需要缓存对应DB表的全量数据，而数据的完整性从以下三个方面得到保证：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）“把鸡蛋放到多个篮子里”，使用多种触发源（定时任务，业务MQ，binglog MQ）来最大限度降低单条数据更新缺失的可能性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;单一触发源有可能出现问题，比如消息类的触发依赖业务系统、中间件canel、中间件QMQ和Kafka，扫表任务依赖分布式调度平台、MySQL等。中间任何一环都可能出现问题，而这些中间服务同时出概率的可能相对来说就极小了，相互之间可以作为互补。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）全量数据刷新任务：全表扫描定时任务，每周执行一次来进行兜底，确保缓存数据的全量准确同步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）数据校验任务：监控Redis和DB数据是否同步并进行补偿。   &lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2.5  系统可用性设计&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;统一缓存服务被多个业务线的核心系统所依赖，所以缓存服务的高可用是至关重要的。而对高可用的建设，除了集群部署、容量规划、熔断降级等常用手段外，针对我们自己的场景也做了一些方案。主要有以下三点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）异地机房互备&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上所述，我们的服务在AB两地部署，两机房的缓存通过两地互通的MQ同时写入。在这套机制下，本地区的业务系统可以直接读取本地区的缓存，如果出现了本地区utag应用异常或redis服务异常，则可以快速降级到调用另外机房的服务接口。具体方案如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.57265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cQzdDVSm0jV87CjsyvX1dqMnBSyTVfyyg70GAnrBEphhoBwiaofnMAVywNUmrCDz2mhrDL2Gkn3og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本地业务系统通过dubbo调用本地的utag服务，在utag的本地处理流程中，查询本地缓存前后分别可根据一定的条件进行服务降级，即查询另一机房。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了避免循环调用，在降级调用前，需要判断当前请求是否来自本地，而此功能通过Dubbo的RpcContext透传特定标识来实现。除此之外，还建立了两机房的应用心跳，来辅助切换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kN6bU5TCvYGhU2EP9utQ1L3NOBSkwWP8AibZuLt0BJtbHrrBaE3ykurQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）QMQ和Kafka互备&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缓存更新流程通过MQ来驱动，虽然公司的MQ中间件服务由专人维护，但是万一出现问题长时间不能恢复，对我们来说将是致命的。所以我们决定同时采用Kafka和QMQ两种中间件来作为互备方案。默认情况下对于全表扫描任务和binlog消费这类大批量消息场景使用Kafka来驱动，而其他场景通过QMQ来驱动。所有的场景都可以通过开关来控制走Kafka或者QMQ。目前该功能可通过配置管理平台来实现快速切换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）快速恢复&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在极端情况下，可能出现Redis数据丢失的情况，如主机房（A机房）突然断网，redis集群切换过程出现数据丢失或同步错乱，此时很可能无法通过自动触发来补齐数据，因此设计了全表快速扫描的补偿机制，通过多任务并行调度，可在30分钟内将全量数据完成刷新。此功能需要人工判断并触发。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2.6 总结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上介绍了我们最终一致性分布式缓存服务的设计思路和要点，其中的关键点为数据准确性、数据完整性、系统可用性的设计。除此之外，还有一些优化点如降级方案的自动触发、异地机房缓存之间、缓存与DB之间做旁路数据diff，可进一步确保缓存服务整体的健壮性，在后续的版本中进行迭代。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;三、强一致性分布式缓存场景&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.1 场景描述&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;强一致性分布式缓存目前主要应用在我们携程金融的消金贷前服务中。随着我们用户量和业务量的增涨，贷前服务的查询量激增，给数据库带来了很大的压力，解决此问题有几种可选方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）分库分表：成本和复杂度相对较高，我们场景下只是数据查询流量较大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）读写分离：出于数据库性能考虑，我们的MySQL大部分采用异步复制的方式，而由于我们的场景对数据实时性要求较高，因此无法直接利用读写分离的优势来分担主库压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综合来看，增加缓存是更加合适的方案，我们决定设计一套高可用的满足强一致性要求的分布式缓存。接下来介绍我们的具体设计实现方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.2 整体方案&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缓存的处理我们采用了较为常见的处理思路：在更新操作中，先更新数据库，再删除缓存，查询操作中，触发缓存更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3497164461247637&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kqDF2emTIUY3df2B0ibAA4MRpibmL8dYm2VrVqA2vIWUtVq4sbgvpnLew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在此过程中，若不加控制，则会存在数据不一致性问题，主要是由于缓存操作和DB更新之间的并发导致的。具体分析如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）缓存读取和DB更新并发&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示，查询时候若缓存已经存在，则会直接返回缓存数据。若查询缓存的操作，发生在“更新DB数据”和“删除缓存”之间，则本次查询到数据为缓存中的老数据，导致不一致。当然下次查询可能就会查询到最新的数据。这种并发在我们服务中是存在的，比如某个产品开通后，会在更新DB（产品开通状态）后立即发送MQ（事务型消息）告知业务，业务侧处理流程中会立即发起查询操作。此场景中数据库的更新和数据的查询间隔极短，很容易出现此种并发问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.38515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6ka3hvMuBHXJATPeIlfnWnAvVbY9O13mVjaFm5BQf61bYBE7sAUoYp9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）缓存更新与DB更新并发&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示，查询的时候，若缓存不存在，则更新缓存，流程是先查询DB再更新Redis。若更新缓存时候，出现以下时序：查询DB老数据（T0时刻，DB中value=1）→ 更新DB（T1时刻，更新DB为value=2）→ 删除Redis（T2）→ 更新Redis（T3），则会导致本次查询返回数据及缓存中的数据与DB数据不一致，即接口返回和更新后的缓存都为脏数据。若T2和T3互换，即更新DB后，先更新Redis，再删除Redis ，由于缓存被删除在下次更新可能会被正确更新，但本次返回数据依然与DB更新后的数据不一致。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.32421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kJhHvrn84jZkXPHEic6uj2hYngfbAlZx5LOMsWiazD6auRjnjgGWzj54Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于以上分析，为了避免并发带来的缓存不一致问题，需要将&quot;更新DB&quot;+&quot;删除缓存&quot;、&quot;查询DB&quot;+&quot;更新缓存&quot;两个流程都进行加锁。此处需要加的是分布式锁，我们使用的是redis分布式锁实现。加锁后的读写整体流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kpGC0WQbFQ9GTLs1n44GpgzWpFR48pPrvYE5NtwXoNyxhDy8c05NAnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，有两处加锁，更新DB时加锁，锁范围为&quot;更新DB&quot;+&quot;删除cache&quot;（图中lock1），更新缓存时加锁，锁范围为&quot;查询DB&quot; + &quot;更新cache&quot;（图中lock2），两处对应的锁key是相同的。基于此方案，对于上面所说的两种并发场景，做针对性分析如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）缓存查询和DB更新的并发控制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查询操作流程中，先判断lock是否存在，若存在，则表示当前DB或缓存正在更新，不能直接查询缓存，在查询DB后返回数据。之所以这么做，还是由场景决定的，如前文所述，我们场景下的基本处理思路是，缓存仅作为“DB降压”的辅助手段，在不确定缓存数据是否最新的情况下，宁可多查询几次DB，也不要查询到缓存中的不一致数据。此外，更新操作相对于查询操作是很少的，在我们贷前服务中，读写比例约为8:1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此处另外的一个可行方案是可在检测到有锁后可进行短暂的等待和重试，好处是可进一步增加缓存的命中率，但是多一次锁等待，可能会影响到查询接口的性能。可根据自身场景进行抉择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，为了进行降级，在锁判断前也增加了降级开关判断，若降级开关开启，也会直接查询DB。而降级主要是由于redis故障引起的，下文详述。若检测是否有锁时发生了异常同样也会直接查询DB。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）缓存更新和DB更新的并发控制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查询操作流程中，若缓存不存在，则进行缓存的更新，在更新时候先尝试进行加锁，若当前有锁说明当前有DB或缓存正在更新，则进行等待和重试，从而可避免查询到DB中的老数据更新到缓存中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中lock2的流程（load cache），我们是同步进行的。另外一个可行的方案是，异步发起缓存的加载，可减少锁等待时间，但是若出现瞬时的高并发查询，可能缓存无法及时加载产生从而频繁产生瞬时压力。可根据自身场景进行抉择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上为我们的整体设计思路，接下来从实现的角度分别描述一下基于本地消息表的缓存删除策略，缓存的降级和恢复这两个方面的具体方案。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.3 缓存删除策略&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在更新操作中，在锁的范围内，先更新DB，再删除缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中锁的选型，我们采用与缓存同介质的redis分布式锁，这样做的好处是若因为redis服务不可用导致的锁处理失败，对于缓存本身也就不可用，可以自动走降级方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，更新流程还要考虑两点：锁的范围和删除缓存失败后如何补偿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）锁粒度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更新操作中加锁粒度有以下三种方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案一：事务提交后加锁，只锁定删除缓存操作。对原事务无任何额外影响，但是在事务提交后到删除缓存之间存在与查询的并发可能性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案二：在事务提交前加锁，删除缓存后解锁。在满足一致性要求的前提下，锁的粒度可以做到最小，但是增加了DB事务的范围，若redis出现超时则可能导致事务时间拉长，进而影响DB操作性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案三：在事务开始前加锁，删除缓存后解锁。锁的范围较大，但是能满足我们一致性要求，对单个DB事务也基本无影响。且对同一个用户来说，贷前数据的更新并不频繁，锁范围稍大一些是我们可以接受的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kMBiaYaAqReicL7Fs264A4RTd053loSsXTmKcQEic96zQQicERh3Y1Sajnw/0?wx_fmt=png&quot; data-cropx1=&quot;1.679300308968452&quot; data-cropx2=&quot;972.3148788927336&quot; data-cropy1=&quot;18.52864884866979&quot; data-cropy2=&quot;614.8142572513157&quot; data-ratio=&quot;0.6125385405960946&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6k1YlA9KfrSvcO3dHak47Oyicribib07q7SIVh4jTuMS5XuT8FlgMsyMtAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;973&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;立足自身场景，权衡一致性要求和服务性能要求，我们剔除了方案二，默认情况下使用方案三，但是若在事务开始前加锁失败，为了不影响原业务流程（缓存只是辅助方案，redis故障不影响原应用功能）会自动降级到方案一，即在事务提交后删除缓存前再加锁。而这种降级，若出现并发的查询操作，依然可能出现上述不一致的问题，但是是可以容忍的，原因如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常情况下加锁失败是由于操作redis异常或者锁竞争引起的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;若出现redis异常，同时出现了并发的查询，而并发的两个操作时间间隔是极短的，因此查询时候，锁检测操作通常也是异常的，此时查询会自动降级为查询DB。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;若极短时间内的redis集群抖动，事务执行前redis不可用，事务执行后redis恢复，而此时在加锁操作还没有完成前恰巧又进行了并发的查询操作，检测锁成功且锁不存在，才可能会出现查询出老数据的情况。这种是极其严苛的并发条件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;而加锁过程会进行重试（可动态调整配置），多次重试后可解决大部分的锁竞争情况。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;综上，在上述锁降级的方案下，数据不一致出现的情况虽然无法完全避免，但是产生条件极其苛刻，而应对这种极其极端的情况，在系统层面做更加强的方案带来的复杂度提升与收益是不成正比的，一般情况下做好日志记录、监控、报警，通过人工介入来弥补即可。从该方案上线后至今两年多的时间内，没有出现过该情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）删除缓存失败的补偿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外要考虑的问题是，如果更新DB成功但删除缓存失败要后如何处理，而此种情况往往因应用服务器故障、网络故障、redis故障等原因导致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若应用服务器突然故障，则服务整体不可用，跟缓存就没多大关系了。若是由于网络、redis故障等原因导致的删除缓存失败，此时查询缓存也不可用，查询走DB，但需要可靠地记录下哪些数据做了变更，待redis可用后需要进行恢复，需要将中间变更的记录对应的缓存全部删除。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此处的一个关键点在于数据变更的可靠性记录，受到QMQ事务消息实现方案的启发，我们的方案是构建一张简易的记录表（代表发生变更的DB数据），每次DB变更后，将该变更记录表的插入和业务DB操作放在一个事务中处理。事务提交后，对应的变更记录持久化，之后进行删除缓存，若缓存删除成功，则将对应的记录表数据也删除掉。若缓存删除失败，则可根据记录表的数据进行补偿删除，而在redis的恢复流程中，需要校验记录表中是否存在数据，若存在则表示有变更后的数据对应的缓存未清除，不可进行缓存读取的恢复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外删除操作还要进行异步重试，来避免偶尔超时引起的缓存删除失败。此方案整体流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6k0VSZWI4Wiaxr2h6WyBVjiadCa2vaoYlo908TKRHcnh48zahLHunzqyvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中cache_key_queue表即为我们的变更记录表，放在业务的同DB内。其表结构非常简单，只有插入和删除操作，对业务DB的额外影响可以忽略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;CREATE TABLE `cache_key_queue` (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    `cache_key` varchar(1024) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;待删除的缓存key&#x27;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    PRIMARY KEY (`id`)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;) ENGINE = InnoDB AUTO_INCREMENT = 0 CHARSET = utf8 COMMENT &#x27;缓存删除队列表&#x27;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;基于以上分析，为了锁范围尽可能小，且为了尽可能降低极端的redis抖动情况下产生的影响，我们期望可以在事务提交后立即触发缓存的删除操作。为了能够对redis不可用期间发生变更的数据进行清除，我们需要可靠地记录数据变更记录。幸运的是，基于Spring的事务同步机制 TransactionSynchronization，可以很容易实现该方案。简单来说，该机制提供了Spring环境中事务执行前后的AOP功能，可以在spring事务的执行前后添加自己的操作，如下所示（代码和注释经过了简化）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public interface TransactionSynchronization extends Flushable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 事务同步器挂起处理&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    void suspend();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 事务同步器恢复处理&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    void resume();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 事务提交前处理&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    void beforeCommit(boolean readOnly);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 事务完成(提交或回滚)前处理&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    void beforeCompletion();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 事务提交后处理&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    void afterCommit();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 事务完成(提交或回滚)后处理&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    void afterCompletion(int status);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;基于此机制，我们可以很方便且相对优雅地实现我们的设计思路，即在 beforeCommit方法中，插入cache_key_queue记录；在 afterCommit方法中同步删除缓存，若删除缓存成功则同步删除cache_key_queue表记录；在afterCompletion方法中进行锁的释放处理。若同步删除缓存失败，则cache_key_queue表记录也会保留下来，之后触发异步删除，并启动定时任务不断扫描cache_key_queue表进行缓存删除的补偿。需要注意的是可能存在嵌套事务，一个完整事务中，可能存在多次数据更新，可借助ThreadLocal进行多条更新记录的汇总。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.4 缓存的熔断和恢复&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了上述锁处理流程中讨论的redis抖动问题外，还需要考虑缓存服务redis集群不可用（网络问题、redis集群问题等）。按照我们的基本原则，引入的缓存服务仅做辅助，并不能强依赖。如果缓存不可用，主业务依然要保持可用，这就是我们接下来要讨论的缓存的熔断和恢复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）缓存熔断&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;熔断的目的是在redis不可用时避免每次调用（查询或更新）都进行额外的缓存操作，这些缓存操作会进行多次尝试，比如加锁操作我们设置的自动重试3次，每次间隔50ms，总耗时会增加150ms。若redis不可用则每次调用的耗时都会有额外增加，这对主业务功能可能会产生影响，降低底层服务的质量和性能。因此我们需要识别出 redis不可用的情况，并进行熔断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的熔断判断逻辑为：每个redis操作都try-catch异常，并做计数统计（不区分读写操作），若在M秒内出现N次异常则开启熔断。我们的场景下设置为10秒内出现50次异常就熔断，可根据自身场景设置，需要注意的是如果redis请求次数比较少，则需要在配置上保证在M秒内至少出现N次请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外熔断开关的配置是放在应用服务器的内存中，即单机熔断，而非集群熔断，这样做的原因是，redis服务不可用有可能是单机与redis服务的连通性问题导致，而在其他机器上依然可以访问缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）缓存恢复&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;熔断之后的恢复策略相对复杂一些，需要区分缓存的读操作恢复和写操作恢复。具体如下流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kxeESTdYL05cFvcJr8qI3oea4og4fl1vyPgoM37D45jMBf0A226J6qg/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1254&quot; data-cropy1=&quot;36.88235294117647&quot; data-cropy2=&quot;242.98961937716265&quot; data-ratio=&quot;0.16507177033492823&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kvucAnlzYHgRhWJPhfF4WBeHj21BAGwOxj2V2qqbYU1jFmYU86fNyrg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1254&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;step1：校验redis是否可用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;判断逻辑为，连续发起特定的set操作N次，每次间隔一定时间，若都成功，则认为redis恢复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此处需要注意的是，我们的redis集群是Cluster模式，不同的key会散落在不同的redis主节点上，因此最保险的做法是判断当前集群中所有的主节点都恢复才认为操作恢复，而简单的做法是每次探测恢复的set操作都设置不同的key以求能尽可能散列到不同的节点去。可按照自身场景进行方案抉择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;step2：恢复缓存写操作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若redis恢复，缓存的写操作就可以恢复了。即可在更新操作中进行加锁、更新DB、删除缓存。但是此时读操作还不能立即恢复，因为redis不可用期间发生了DB变更但是缓存并没有变更，依然为老数据，因此需要将这部分老数据剔除后才能恢复读操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;step3：校验挤压的cache_key_queue记录&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;轮训查看cache_key_queue表中是否有记录存在，若存在记录则认为当前有不一致的缓存数据，需要等待定时任务将暂存的key表记录对应的缓存全部删除（同时也会删除cache_key_queue表记录）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; step4：恢复缓存读操作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;若当前不存在cache_key_queue记录则可恢复读操作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;      &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以上阐述了redis缓存的自动熔断和恢复方案。需要明确的是，能够进行熔断是有前提条件的，即应用完全去掉缓存，DB还是可以抗住一段时间压力的，否则一旦出现缓存服务故障，流量全部走到应用，超过了应用和DB的承受能力，将服务压垮，后果更加严重。所以不能强依赖熔断机制，不能强依赖缓存，而这就需要接口限流等其他手段来从整体上保证服务的高可用。此外可进行定期压测，来锚定服务性能上限，进而不断优化对各种策略和资源的配置。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.5 总结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上描述了我们强一致性缓存方案的设计思路及一些实现细节。基于该方案，我们核心数据库的QPS降低了80%，缓存的命中率达到92%。而该方案的关键是通过加锁来控制读写，&lt;/span&gt;&lt;span&gt;从表面上看会牺牲一些性能，但是实际上高缓存命中率同样弥补了此缺陷，缓存的建立使得我们服务查询接口AVG响应时间降低了10%左右。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.18125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kJxFSbkwNJfHIWReJ21wvic2jXhMuwr6CNDk1pjGuSZ3zRVZDEcQ42hQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;四、结语&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上分别描述了我们的最终一致性和强一致性缓存设计和实现思路。两套缓存方案侧重点各有不同：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;此外，我们的最终一致性缓存方案是独立的缓存服务，而该强一致缓存方案，是需要嵌入到应用系统中去使用的。方案的选择需要立足于自身场景，希望我们的分享能够给大家带来一些启发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;团队招聘信息&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们是携程金融团队，从事支付、信贷等金融业务，这里拥有优秀、强大、富有创造性的团队，可以与你一起不断研究行业新技术，找寻业务解决方案的最优解，构建可驱动业务发展的技术价值体系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你热爱技术，喜欢挑战，渴望不断成长，携程金融期待与你一起腾飞。目前我们前端、后端、测试等大量技术职位开放。简历投递邮箱：tech@trip.com，邮件标题：【姓名】-【携程金融】-【投递职位】。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;【推荐阅读】&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kxzSLSBveXYicSqD1JgdicDpl9NoNy6zeY9vEBZZoxtWDDKsVlcfVwu5Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; “携程技术”公众号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  分享，交流，成长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b3ebe7976a17f69c6d1589fc48ee6cc4</guid>
<title>一个全新 Flutter UI 适配方案，低入侵 &amp; 100% 还原设计稿</title>
<link>https://toutiao.io/k/zohb9z6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/liaczD18OicSwTgDOZFUw1En9Cegibicq4BuRjv63ccqicScZkvCsBsKCXPErUlL5hzx8Ek0YJedzZgHoGBTicIcY3oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、序&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，这里是承香墨影！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天介绍一个我最近开源的 Flutter UI 方案，可以做到在全设备上 100% 还原设计稿，其背后的思想类似 Android 侧今日头条基于 density 的 UI 适配方案，接下来进入正题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 Android 的碎片化，全设备的 UI 一致性，一直是开发者和设计师所追求的。后续也衍生出各种不同的适配方案以及对应的开源库，例如：AndroidAutoLayout、smallestWidth，以及最后今日头条基于修改 density 的 UI 适配方案。到后期对于 Android 的 UI 适配，基本上不存在什么新的问题了，只有方案的选择和使用问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在 Flutter 中，由于要支持 Android 和 iOS 多系统的设备，UI 适配遇到的场景将更加复杂，这一切又要重新来一遍。对于各个系统的屏幕适配原理都差不多，Flutter 也是如此，我们在 Flutter 中直接写在 Widget 的尺寸，会被乘以一个倍数去放大，最终对应到的是物理设备屏幕的像素尺寸。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个倍数，在 Flutter 中就是 &lt;code&gt;devicePixelRatio&lt;/code&gt;。它是设备上一个固定的值，不同设备的取值会不相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主流的 Flutter UI 适配方案，就是使用 &lt;code&gt;flutter_screenutils&lt;/code&gt; 这个 Package，它也是基于 devicePixelRatio 对设置给 Widget 的尺寸进行调整，但入侵还是比较高的，需要遵循它的一些约束，如果想在成熟的项目上迁移使用，改动不会小。并且也有一些小问题，例如：无法适应 const Widget 的优化（&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247487203&amp;amp;idx=1&amp;amp;sn=d78cdd433114c3a52f0fd7c4b7dbfb77&amp;amp;chksm=978517c2a0f29ed4cf21a9b127df12f9d77da22fe99596c9798a830ab6427c4116d6676af3da&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;戳此了解&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;戳此了解&lt;/a&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么针对我的一些需求，我开源了一个 Flutter &lt;code&gt;package：screen_autosize&lt;/code&gt;，对于成熟的项目也可以做到低入侵的引入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然是 UI 适配，直接上效果说话。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一套相同的代码，使用 1080 宽度的设备，但从左到右的 dpi 分别是 375 → 392 → 440，运行后的效果如下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7222222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaczD18OicSwTgDOZFUw1En9Cegibicq4BuiaRYjdARb94uxSmoAUGUVsCKiaWicjurr3qEaW773n0FeThoQrqpwQR6A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入 screen_autosize 后，运行效果如下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7222222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaczD18OicSwTgDOZFUw1En9Cegibicq4BuicWBO6MA7mLo0Tic5vCPWrzsVNGSTMXz1eicPNDlLWqJmgP7YRVj8bjFw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该有的元素都有，可以看到在不同的参数设备下，可以做到 100% 的一致性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、screen_autosize&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们正式介绍 screen_autosize。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/liaczD18OicSwTgDOZFUw1En9Cegibicq4BuLibYtv57313uJJ9baKMajxvJKiaDvN6csm3ZDdszaibPDIhaG1QnZ5iabA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;96&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 优势 &amp;amp; 劣势&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优势：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;适配效果：100% 还原 UI；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;稳定性高：原理简单，无任何 Framework 的 Hook；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;侵入性低：修改点少且统一，日常编写 UI 无需特殊注意；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用成本低：统一修改，全局有效；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能损耗：几乎没有；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不破坏 const Widget 常量优化&lt;span&gt;（&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247487203&amp;amp;idx=1&amp;amp;sn=d78cdd433114c3a52f0fd7c4b7dbfb77&amp;amp;chksm=978517c2a0f29ed4cf21a9b127df12f9d77da22fe99596c9798a830ab6427c4116d6676af3da&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;戳此了解&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;戳此了解&lt;/a&gt;&lt;span&gt;）&lt;/span&gt;；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;劣势：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;全局有效，无法单页面设置，需统一同项目不同模块的设计和开发标准；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;编码注意点：不能使用 window 类 Api 获取尺寸信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要重写 WidgetsFlutterBinding，可能与部分库存在冲突，需特殊处理；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 使用方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;1.&lt;/em&gt; &lt;strong&gt;安装依赖&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装之前，请查看最新版本（&lt;span&gt;新版本如有问题，请使用上一版本&lt;/span&gt;）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;dependencies:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;flutter:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;sdk:&lt;/span&gt; &lt;span&gt;flutter&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# 添加依赖&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;screen_autosize:&lt;/span&gt; &lt;span&gt;^{latest&lt;/span&gt; &lt;span&gt;version}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;2.&lt;/em&gt; &lt;strong&gt;使用导包&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&#x27;package:screen_autosize/screen_autosize.dart&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;3.&lt;/em&gt; &lt;strong&gt;初始化&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Step1：设定基准屏幕宽度。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要在 &lt;code&gt;runApp()&lt;/code&gt; 之前设置，使用 AutoSizeUtils 的 initConfig() 设置设计稿的基准宽度。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;void&lt;/span&gt; main() {&lt;br/&gt;  &lt;span&gt;// 这里使用 iPhone 一倍的宽度作为基准宽度；&lt;/span&gt;&lt;br/&gt;  AutoSizeUtils.instance.initConfig(&lt;span&gt;375&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Step2：替换 runApp()。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将原本的 &lt;code&gt;runApp()&lt;/code&gt; 用 &lt;code&gt;runAutoSizeApp(MyApp())&lt;/code&gt; 替换。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;void&lt;/span&gt; main() {&lt;br/&gt;  &lt;span&gt;// 这里使用 iPhone 一倍的宽度作为基准宽度；&lt;/span&gt;&lt;br/&gt;  AutoSizeUtils.instance.initConfig(&lt;span&gt;375&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;// runApp(MyApp());&lt;/span&gt;&lt;br/&gt;  runAutoSizeApp(MyApp());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Step3: 替换 MaterialApp 生成的 MediaQuery&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MaterialApp 内部会生成 MediaQuery，需要将其通过 MediaQueryWrapper 替换。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyApp&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;StatelessWidget&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;@override&lt;/span&gt;&lt;br/&gt;  Widget build(BuildContext context) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; MaterialApp(&lt;br/&gt;      title: &lt;span&gt;&#x27;Flutter Demo&#x27;&lt;/span&gt;,&lt;br/&gt;      builder: (context, widget) {&lt;br/&gt;        &lt;span&gt;// 替换根的 MediaQuery&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; MediaQueryWrapper(builder: (BuildContext context){&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; widget;&lt;br/&gt;        },);&lt;br/&gt;      },&lt;br/&gt;      home: HomePage(title: &lt;span&gt;&#x27;Flutter ScreenAutoSize示例&#x27;&lt;/span&gt;),&lt;br/&gt;    );&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;4.&lt;/em&gt; &lt;strong&gt;开始写 UI&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编码时，无任何注意点，直接按照设计图的尺寸写就行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;eg. 在 375 宽度（&lt;span&gt;iPhone 1 倍尺寸&lt;/span&gt;）的设计稿下，一个 100x100 黄色区域，直接写参数就行，无需任何注意点。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ColorsWidget&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;StatelessWidget&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;@override&lt;/span&gt;&lt;br/&gt;  Widget build(BuildContext context) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Container(&lt;br/&gt;      padding: EdgeInsets.all(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;// 不需要转换，设计稿是多少，就写多少&lt;/span&gt;&lt;br/&gt;      width: &lt;span&gt;100&lt;/span&gt;,  &lt;span&gt;// 不需要转换，设计稿是多少，就写多少&lt;/span&gt;&lt;br/&gt;      height: &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;// 不需要转换，设计稿是多少，就写多少&lt;/span&gt;&lt;br/&gt;      color: Colors.orange,&lt;br/&gt;      child: Text(&lt;br/&gt;        &lt;span&gt;&#x27;我是正方形,边长是100&#x27;&lt;/span&gt;,&lt;br/&gt;        style: TextStyle(&lt;br/&gt;          color: Colors.white,&lt;br/&gt;          fontSize: &lt;span&gt;12&lt;/span&gt;,&lt;br/&gt;        ),&lt;br/&gt;      ),&lt;br/&gt;    );&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要写满屏的尺寸，例如某个 Widget 宽度需要撑满屏幕，可以使用 2 种方法。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;利用 &lt;code&gt;MediaQuery&lt;/code&gt; 获取：&lt;code&gt;MediaQuery.of(context).size.width&lt;/code&gt;;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;利用 &lt;code&gt;AutoSizeUtils&lt;/code&gt; 获取：&lt;code&gt;AutoSizeUtils.instance.mediaWidth&lt;/code&gt;;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与宽度（&lt;span&gt;width&lt;/span&gt;）对应的还有高度（&lt;span&gt;height&lt;/span&gt;）的尺寸。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用上有 2 点需要注意：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不能从 &lt;code&gt;window&lt;/code&gt; 获取屏幕尺寸。因为库里改写了 &lt;code&gt;devicePixelRatio&lt;/code&gt;，所以不能直接从 &lt;code&gt;ui.window&lt;/code&gt; 里获取对应参数；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有多个 &lt;code&gt;MaterialApp&lt;/code&gt;，也需要同步使用 &lt;code&gt;MediaQueryWrapper&lt;/code&gt; 包装。&lt;code&gt;MaterialApp&lt;/code&gt; 内部会从 window 中获取参数生成 MediaQuery，所以需要特殊处理；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了这 2 点，其他暂时未发现其他需要特殊注意的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 示例 &amp;amp; 效果&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;void&lt;/span&gt; main() {&lt;br/&gt;  AutoSizeUtils.instance.initConfig(baseWidth: &lt;span&gt;375&lt;/span&gt;);&lt;br/&gt;  runAutoSizeApp(MyApp());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyApp&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;StatelessWidget&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;@override&lt;/span&gt;&lt;br/&gt;  Widget build(BuildContext context) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; MaterialApp(&lt;br/&gt;      title: &lt;span&gt;&#x27;Flutter Demo&#x27;&lt;/span&gt;,&lt;br/&gt;      builder: (context, widget) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; MediaQueryWrapper(builder: (BuildContext context){&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; widget;&lt;br/&gt;        },);&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;      home: HomePage(title: &lt;span&gt;&#x27;Flutter ScreenAutoSize示例&#x27;&lt;/span&gt;),&lt;br/&gt;    );&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HomePage&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;StatefulWidget&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; HomePage({Key key, &lt;span&gt;this&lt;/span&gt;.title}) : &lt;span&gt;super&lt;/span&gt;(key: key);&lt;br/&gt;  &lt;span&gt;final&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; title;&lt;br/&gt;  &lt;span&gt;@override&lt;/span&gt;&lt;br/&gt;  _HomePageState createState() =&amp;gt; _HomePageState();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;_HomePageState&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;State&lt;/span&gt;&amp;lt;&lt;span&gt;HomePage&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;@override&lt;/span&gt;&lt;br/&gt;  Widget build(BuildContext context) {&lt;br/&gt;    printScreenInformation();&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; sysMediaData = MediaQueryData.fromWindow(ui.&lt;span&gt;window&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Scaffold(&lt;br/&gt;      appBar: AppBar(&lt;br/&gt;        title: Text(widget.title),&lt;br/&gt;      ),&lt;br/&gt;      body: SingleChildScrollView(&lt;br/&gt;        child: Column(&lt;br/&gt;          crossAxisAlignment: CrossAxisAlignment.center,&lt;br/&gt;          children: &amp;lt;Widget&amp;gt;[&lt;br/&gt;            Container(&lt;br/&gt;              padding: EdgeInsets.only(left: &lt;span&gt;10&lt;/span&gt;),&lt;br/&gt;              width: MediaQuery.of(context).size.width,&lt;br/&gt;              height: AutoSizeUtils.instance.statusBarHeight,&lt;br/&gt;              color: Colors.orange,&lt;br/&gt;              alignment: Alignment.centerLeft,&lt;br/&gt;              child: Text(&lt;br/&gt;                &lt;span&gt;&#x27;我和 StatusBar 的高度一致，高度是：&lt;span&gt;${AutoSizeUtils.instance.statusBarHeight}&lt;/span&gt; dp&#x27;&lt;/span&gt;,&lt;br/&gt;                style: TextStyle(&lt;br/&gt;                  color: Colors.white,&lt;br/&gt;                  fontSize: &lt;span&gt;12&lt;/span&gt;,&lt;br/&gt;                ),&lt;br/&gt;              ),&lt;br/&gt;            ),&lt;br/&gt;            Row(&lt;br/&gt;              children: &amp;lt;Widget&amp;gt;[&lt;br/&gt;                Container(&lt;br/&gt;                  padding: EdgeInsets.all(&lt;span&gt;10&lt;/span&gt;),&lt;br/&gt;                  width: &lt;span&gt;180&lt;/span&gt;,&lt;br/&gt;                  height: &lt;span&gt;80&lt;/span&gt;,&lt;br/&gt;                  color: Colors.red,&lt;br/&gt;                  child: Text(&lt;br/&gt;                    &lt;span&gt;&#x27;实际宽度:&lt;span&gt;${&lt;span&gt;180&lt;/span&gt;}&lt;/span&gt;dp \n&#x27;&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&#x27;实际高度:&lt;span&gt;${&lt;span&gt;80&lt;/span&gt;}&lt;/span&gt;dp&#x27;&lt;/span&gt;,&lt;br/&gt;                    style: TextStyle(color: Colors.white, fontSize: &lt;span&gt;12&lt;/span&gt;),&lt;br/&gt;                  ),&lt;br/&gt;                ),&lt;br/&gt;                Container(&lt;br/&gt;                  padding: EdgeInsets.all(&lt;span&gt;10&lt;/span&gt;),&lt;br/&gt;                  width: &lt;span&gt;180&lt;/span&gt;,&lt;br/&gt;                  height: &lt;span&gt;80&lt;/span&gt;,&lt;br/&gt;                  color: Colors.blue,&lt;br/&gt;                  child: Text(&lt;br/&gt;                      &lt;span&gt;&#x27;设计稿宽度: 180dp \n&#x27;&lt;/span&gt;&lt;br/&gt;                          &lt;span&gt;&#x27;设计稿高度: 80dp&#x27;&lt;/span&gt;,&lt;br/&gt;                      style: TextStyle(&lt;br/&gt;                          color: Colors.white,&lt;br/&gt;                          fontSize: &lt;span&gt;12&lt;/span&gt;)),&lt;br/&gt;                ),&lt;br/&gt;              ],&lt;br/&gt;            ),&lt;br/&gt;            Container(&lt;br/&gt;              padding: EdgeInsets.all(&lt;span&gt;10&lt;/span&gt;),&lt;br/&gt;              width: &lt;span&gt;375&lt;/span&gt;,&lt;br/&gt;              height: &lt;span&gt;80&lt;/span&gt;,&lt;br/&gt;              color: Colors.blueGrey,&lt;br/&gt;              child: Text(&lt;br/&gt;                  &lt;span&gt;&#x27;设计稿宽度: 375dp \n&#x27;&lt;/span&gt;&lt;br/&gt;                      &lt;span&gt;&#x27;设计稿高度: 80dp&#x27;&lt;/span&gt;,&lt;br/&gt;                  style: TextStyle(&lt;br/&gt;                      color: Colors.white,&lt;br/&gt;                      fontSize: &lt;span&gt;12&lt;/span&gt;)),&lt;br/&gt;            ),&lt;br/&gt;            Container(&lt;br/&gt;              padding: EdgeInsets.all(&lt;span&gt;10&lt;/span&gt;),&lt;br/&gt;              width: MediaQuery.of(context).size.width,&lt;br/&gt;              height: &lt;span&gt;80&lt;/span&gt;,&lt;br/&gt;              color: Colors.green,&lt;br/&gt;              child: Text(&lt;br/&gt;                  &lt;span&gt;&#x27;设计稿要求宽度撑满屏幕，使用 MediaQuery.of().size.width 设置 \n&#x27;&lt;/span&gt;&lt;br/&gt;                      &lt;span&gt;&#x27;设计稿高度: 80dp&#x27;&lt;/span&gt;,&lt;br/&gt;                  style: TextStyle(&lt;br/&gt;                      color: Colors.white,&lt;br/&gt;                      fontSize: &lt;span&gt;12&lt;/span&gt;)),&lt;br/&gt;            ),&lt;br/&gt;            Container(&lt;br/&gt;              padding: EdgeInsets.all(&lt;span&gt;10&lt;/span&gt;),&lt;br/&gt;              width: &lt;span&gt;100&lt;/span&gt;,&lt;br/&gt;              height: &lt;span&gt;100&lt;/span&gt;,&lt;br/&gt;              color: Colors.orange,&lt;br/&gt;              child: Text(&lt;br/&gt;                &lt;span&gt;&#x27;我是正方形,边长是100&#x27;&lt;/span&gt;,&lt;br/&gt;                style: TextStyle(&lt;br/&gt;                  color: Colors.white,&lt;br/&gt;                  fontSize: &lt;span&gt;12&lt;/span&gt;,&lt;br/&gt;                ),&lt;br/&gt;              ),&lt;br/&gt;            ),&lt;br/&gt;&lt;br/&gt;            Text(&lt;span&gt;&#x27;设备原始像素尺寸: &lt;span&gt;${ui.window.physicalSize.width}&lt;/span&gt; x &lt;span&gt;${ui.window.physicalSize.height}&lt;/span&gt; (px)&#x27;&lt;/span&gt;),&lt;br/&gt;            Text(&lt;span&gt;&#x27;设备原始 density: &lt;span&gt;${sysMediaData.devicePixelRatio}&lt;/span&gt;dp&#x27;&lt;/span&gt;),&lt;br/&gt;            Text(&lt;span&gt;&#x27;设备原始宽度: &lt;span&gt;${sysMediaData.size.width}&lt;/span&gt; dp&#x27;&lt;/span&gt;),&lt;br/&gt;            Text(&lt;span&gt;&#x27;设备原始高度: &lt;span&gt;${sysMediaData.size.height}&lt;/span&gt; dp&#x27;&lt;/span&gt;),&lt;br/&gt;            Text(&lt;span&gt;&quot;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=&quot;&lt;/span&gt;),&lt;br/&gt;            Text(&lt;span&gt;&#x27;调整后的的像素密度: &lt;span&gt;${AutoSizeUtils.instance.devicePixelRatio}&lt;/span&gt;&#x27;&lt;/span&gt;),&lt;br/&gt;            Text(&lt;span&gt;&#x27;调整后的宽度: &lt;span&gt;${AutoSizeUtils.instance.mediaWidth}&lt;/span&gt; dp&#x27;&lt;/span&gt;),&lt;br/&gt;            Text(&lt;span&gt;&#x27;调整后的高度: &lt;span&gt;${AutoSizeUtils.instance.mediaHeight}&lt;/span&gt; dp&#x27;&lt;/span&gt;),&lt;br/&gt;            Text(&lt;span&gt;&#x27;状态栏高度: &lt;span&gt;${AutoSizeUtils.instance.statusBarHeight}&lt;/span&gt; dp&#x27;&lt;/span&gt;),&lt;br/&gt;            Text(&lt;span&gt;&#x27;底部安全区距离: &lt;span&gt;${AutoSizeUtils.instance.bottomBarHeight}&lt;/span&gt; dp&#x27;&lt;/span&gt;),&lt;br/&gt;            Visibility(&lt;br/&gt;              visible: AutoSizeUtils.instance.bottomBarHeight &amp;gt; &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;              child: Container(&lt;br/&gt;                padding: EdgeInsets.only(left: &lt;span&gt;10&lt;/span&gt;),&lt;br/&gt;                width: MediaQuery.of(context).size.width,&lt;br/&gt;                height: AutoSizeUtils.instance.bottomBarHeight,&lt;br/&gt;                color: Colors.orange,&lt;br/&gt;                alignment: Alignment.centerLeft,&lt;br/&gt;                child: Text(&lt;br/&gt;                  &lt;span&gt;&#x27;我和 BottomBar 的高度一致，高度是：&lt;span&gt;${AutoSizeUtils.instance.bottomBarHeight}&lt;/span&gt; dp&#x27;&lt;/span&gt;,&lt;br/&gt;                  style: TextStyle(&lt;br/&gt;                    color: Colors.white,&lt;br/&gt;                    fontSize: &lt;span&gt;12&lt;/span&gt;,&lt;br/&gt;                  ),&lt;br/&gt;                ),&lt;br/&gt;              ),&lt;br/&gt;            ),&lt;br/&gt;&lt;br/&gt;          ],&lt;br/&gt;        ),&lt;br/&gt;      ),&lt;br/&gt;    );&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 适配效果&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;未适配前：从左到右的 dpi 分别是 375 → 392 → 440。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7222222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaczD18OicSwTgDOZFUw1En9Cegibicq4BuiaRYjdARb94uxSmoAUGUVsCKiaWicjurr3qEaW773n0FeThoQrqpwQR6A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 screen_autosize 适配后：从左到右的 dpi 分别是 375 → 392 → 440。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7222222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaczD18OicSwTgDOZFUw1En9Cegibicq4BuicWBO6MA7mLo0Tic5vCPWrzsVNGSTMXz1eicPNDlLWqJmgP7YRVj8bjFw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3240&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的分享就到这里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 screen_autosize 来说，收敛了配置，只需要在固定位置进行简单的配置，之后在项目中写 Flutter 代码，就无需额外的任何代码，做到低入侵，对一些已经开发成熟，比较友好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次 Package 开源，有一些细节还没准备好，例如还不支持 2.0 的空安全，后面有需要会继续迭代。不过基本功能都包含了，原则上可以直接使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计思想和原理讲解的文章，后续会补上，涉及的代码比较简单，&lt;span&gt;有兴趣也可以直接看源码&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要是有任何不对的地方，各位老铁轻喷。有任何问题欢迎在留言区讨论，或提 issues。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文末「&lt;span&gt;阅读&lt;/span&gt;&lt;span&gt;原文&lt;/span&gt;」可直接跳转到 pub.dev (screen_autosize)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;-- End --&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIxNjc0ODExMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/liaczD18OicSyqdR0dH2EH3UXkJNVxb3VEOd59JWpUZSckeEIB0gK8xK9OszbSalkrljFOu4c7tEfExya24cdHWg/0?wx_fmt=png&quot; data-nickname=&quot;承香墨影&quot; data-alias=&quot;cxmyDev&quot; data-signature=&quot;我是承香墨影，8 年技术老司机。在这里，主要分享我个人的原创内容，不仅限于技术，职场、产品、设计思想等等，统统都有。这里已经汇集了有很多小伙伴了，欢迎你加入！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;references：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Github: https://github.com/CxmyDev/screen_autosize&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;screen_autosize: https://pub.flutter-io.cn/packages/screen_autosize&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文对你有帮助吗？&lt;strong&gt;留言、转发、点好看&lt;/strong&gt;是最大的支持，谢谢！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-recommend-type=&quot;list-title&quot; data-recommend-tid=&quot;6&quot; data-mpa-template=&quot;t&quot; data-mid=&quot;&quot; data-from=&quot;yb-recommend&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;6&quot; data-recommend-article-id=&quot;2247487354_1&quot; data-recommend-article-time=&quot;1624493400&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/liaczD18OicSwicHzAm9KalbCqT4c9nyUc1icvWhr0EVlB6KdCoXzlrWwX0PKVFKo4Md2Gr4aZOibuONoCjMdDlUOdA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;Kotlin 协程第一弹：协程的使用，一文讲清楚！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247487354&amp;amp;idx=1&amp;amp;sn=057a9314d5bd9698d13c3fc04de5de09&amp;amp;chksm=9785165ba0f29f4defec96703cd86551033156928d7ec78b6184ad9b30de94dc9f5bba6e3893#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247487354&amp;amp;idx=1&amp;amp;sn=057a9314d5bd9698d13c3fc04de5de09&amp;amp;chksm=9785165ba0f29f4defec96703cd86551033156928d7ec78b6184ad9b30de94dc9f5bba6e3893&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;Kotlin 协程第一弹：协程的使用！&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;6&quot; data-recommend-article-id=&quot;2247487279_1&quot; data-recommend-article-time=&quot;1624407000&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/liaczD18OicSwJMkuC8mZPu1vMib0MDYOsicllhs2bACBNIZNMr54854w6ncqNg6JIGibjeUVbjicooM7PGDwVSUjsVQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;Fragment懒加载还在用setUserVisiblity？看AndroidX带来那些新的Api.&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247487279&amp;amp;idx=1&amp;amp;sn=47d1dcb72ea4ba3e4ce458923fed3bbf&amp;amp;chksm=9785160ea0f29f1847a2ed1290691f614dde309663db8c887ade48d607c81466ebc71acf70c6#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247487279&amp;amp;idx=1&amp;amp;sn=47d1dcb72ea4ba3e4ce458923fed3bbf&amp;amp;chksm=9785160ea0f29f1847a2ed1290691f614dde309663db8c887ade48d607c81466ebc71acf70c6&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;AndroidX助力Fragment懒加载&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;6&quot; data-recommend-article-id=&quot;2247487244_1&quot; data-recommend-article-time=&quot;1624320600&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_png/liaczD18OicSxiaQNJJR1icfSXuibAc7bxgLHVE2CPiaUXrxqUnQB8y9kJMRzRsbks3iaC7P2NtKwumCBVA8QyV7FJfaA/0?wx_fmt=png&quot; data-recommend-article-title=&quot;Android 启动优化：合并多个 SDK 中的 FileProvider！效果：150ms → 20ms&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247487244&amp;amp;idx=1&amp;amp;sn=ce843bd367881f150b363d8ce75d849b&amp;amp;chksm=9785162da0f29f3b281db27fc8b9bb914b4340ac3daf985eaf1faee11811958e80c1bf78bbc1#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247487244&amp;amp;idx=1&amp;amp;sn=ce843bd367881f150b363d8ce75d849b&amp;amp;chksm=9785162da0f29f3b281db27fc8b9bb914b4340ac3daf985eaf1faee11811958e80c1bf78bbc1&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;启动优化：合并多个FileProvider！效果:150ms→20ms&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaczD18OicSwTgDOZFUw1En9Cegibicq4Bu7HhP8rIH9WmQP5vcuowsFJCtEic6POPN5UIZRaaUxUAlPc5jm8cJOog/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dd367c80695e74f558f48e69b322e199</guid>
<title>Dubbo 2.7 应用级服务发现踩坑小记</title>
<link>https://toutiao.io/k/3n9jfwf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;背景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文记录最近一位读者反馈的dubbo 2.7.x中应用级服务发现的问题，关于dubbo应用级服务发现的相关介绍可以参考之前的文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5NjE2MDQwNg==&amp;amp;mid=2247484508&amp;amp;idx=1&amp;amp;sn=2f15b121230bdda3b2e59bd06b649f94&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《dubbo应用级服务发现初体验》&lt;/a&gt;，这里不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读者反馈他们在基于dubbo 2.7应用级服务发现开发dubbo网关，根据文章《dubbo应用级服务发现初体验》写了demo调用时报&lt;code&gt;no provider&lt;/code&gt;的错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先觉得他们挺有想法，把dubbo应用级服务发现搬上生产的公司不多。其次当时写文章时测试并没有遇到问题，但本着帮读者解决问题的态度，还是重新写个demo测试下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题定位&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随手拿了一个平时测试用的dubbo demo工程（注意不是dubbo源码中的demo），发现确实注册不到zookeeper上，接着测试了不同的版本，发现都注册不了，在2.7.5 ~ 2.7.11版本不报错，2.7.12版本会报如下的NPE错误&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;2021-06-16 13:17:31,086 [Dubbo-framework-scheduler-thread-1] ERROR org.apache.dubbo.config.bootstrap.DubboBootstrap (DubboBootstrap.java:1172) -  [DUBBO] refresh metadata and instance failed, dubbo version: 2.7.12, current host: 172.23.233.52&lt;br/&gt;java.lang.NullPointerException&lt;br/&gt; at org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.calInstanceRevision(ServiceInstanceMetadataUtils.java:249)&lt;br/&gt; at org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.lambda&lt;span&gt;$refreshMetadataAndInstance&lt;/span&gt;&lt;span&gt;$6&lt;/span&gt;(ServiceInstanceMetadataUtils.java:272)&lt;br/&gt; at java.util.ArrayList.forEach(ArrayList.java:1259)&lt;br/&gt; at org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.refreshMetadataAndInstance(ServiceInstanceMetadataUtils.java:271)&lt;br/&gt; at org.apache.dubbo.config.bootstrap.DubboBootstrap.lambda&lt;span&gt;$registerServiceInstance&lt;/span&gt;&lt;span&gt;$20&lt;/span&gt;(DubboBootstrap.java:1170)&lt;br/&gt; at java.util.concurrent.Executors&lt;span&gt;$RunnableAdapter&lt;/span&gt;.call(Executors.java:511)&lt;br/&gt; at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)&lt;br/&gt; at java.util.concurrent.ScheduledThreadPoolExecutor&lt;span&gt;$ScheduledFutureTask&lt;/span&gt;.access&lt;span&gt;$301&lt;/span&gt;(ScheduledThreadPoolExecutor.java:180)&lt;br/&gt; at java.util.concurrent.ScheduledThreadPoolExecutor&lt;span&gt;$ScheduledFutureTask&lt;/span&gt;.run(ScheduledThreadPoolExecutor.java:294)&lt;br/&gt; at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)&lt;br/&gt; at java.util.concurrent.ThreadPoolExecutor&lt;span&gt;$Worker&lt;/span&gt;.run(ThreadPoolExecutor.java:624)&lt;br/&gt; at java.lang.Thread.run(Thread.java:748)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推测服务注册时存在问题，跟着这个错误栈debug，很快就定位到问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接导致NPE的是位于&lt;code&gt;org.apache.dubbo.registry.client.AbstractServiceDiscovery#register&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&amp;lt;=2.7.11版本中&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(ServiceInstance serviceInstance)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; RuntimeException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.serviceInstance = serviceInstance;&lt;br/&gt;    doRegister(serviceInstance);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在2.7.12版本中代码顺序被调整成了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(ServiceInstance serviceInstance)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; RuntimeException &lt;/span&gt;{&lt;br/&gt;   doRegister(serviceInstance);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.serviceInstance = serviceInstance;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么调整了代码顺序导致了报错？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;追踪下来发现NPE的来源是&lt;code&gt;this.serviceInstance&lt;/code&gt;为null，原先的代码先对其赋值再执行doRegister。调整过后的代码先执行&lt;code&gt;doRegister&lt;/code&gt;再赋值，然而在执行&lt;code&gt;diRegister&lt;/code&gt;时抛出异常了，不幸的是这个异常被吃掉了，doRegister的实现如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(ServiceInstance serviceInstance)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; RuntimeException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    assertDestroyed(REGISTER_ACTION);&lt;br/&gt;    assertInitialized(REGISTER_ACTION);&lt;br/&gt;&lt;br/&gt;    executeWithEvents(&lt;br/&gt;            of(&lt;span&gt;new&lt;/span&gt; ServiceInstancePreRegisteredEvent(serviceDiscovery, serviceInstance)),&lt;br/&gt;            () -&amp;gt; serviceDiscovery.register(serviceInstance),&lt;br/&gt;            of(&lt;span&gt;new&lt;/span&gt; ServiceInstanceRegisteredEvent(serviceDiscovery, serviceInstance))&lt;br/&gt;    );&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这个&lt;code&gt;executeWithEvents&lt;/code&gt;会将异常以事件的形式发出去&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;executeWithEvents&lt;/span&gt;&lt;span&gt;(Optional&amp;lt;? extends Event&amp;gt; beforeEvent,&lt;br/&gt;                                       ThrowableAction action,&lt;br/&gt;                                       Optional&amp;lt;? extends Event&amp;gt; afterEvent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    beforeEvent.ifPresent(&lt;span&gt;this&lt;/span&gt;::dispatchEvent);&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        action.execute();&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Throwable e) {&lt;br/&gt;        dispatchEvent(&lt;span&gt;new&lt;/span&gt; ServiceDiscoveryExceptionEvent(&lt;span&gt;this&lt;/span&gt;, serviceDiscovery, e));&lt;br/&gt;    }&lt;br/&gt;    afterEvent.ifPresent(&lt;span&gt;this&lt;/span&gt;::dispatchEvent);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而这个事件丢出去之后并没有被处理，也就是说这个异常被吃掉了。这也就是为什么之前的dubbo版本没有抛出异常，也不能注册上服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个异常是什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java.lang.NoClassDefFoundError: org/apache/curator/x/discovery/ServiceDiscovery&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实只是少引入了一个依赖。加入以下以下就能解决这个问题&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.dubbo&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;dubbo-registry-zookeeper&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;${version}&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么当时写文章时没有遇到这个问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恰好本次调试是基于一个demo工程，《dubbo应用级服务发现初体验》文章是直接在dubbo源码中修改demo，源码中已经把依赖都引入了&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;更进一步&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实是个小问题，但对用户来说挺困惑的，为什么没有报错但也没法注册服务？如果不是2.7.12有个附带的报错，可能排查起来更加困难。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是提了个issue和社区的朋友交流下，得出的结论是2.7.x的应用级服务发现不再维护，3.x会继续维护。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/apache/dubbo/issues/8061&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提个issue也是让有问题的用户能搜索到，少走弯路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便也提了个PR，加一行log，方便直观的发现这个问题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24489795918367346&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Q6EwOicVX1AkIevFia5MV1G9klqNKxeWibmj8AQR7d56uJgGmzc5XdPPLsBdiavsrcOye8cMm3ePBQTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2058&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/apache/dubbo/pull/8066&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新版本（&amp;gt;=2.7.13）如果有朋友再遇到这个问题，会直接打印出错误，就像这样&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;2021-06-16 16:58:02,210 [main] ERROR org.apache.dubbo.registry.client.EventPublishingServiceDiscovery (EventPublishingServiceDiscovery.java:287) -  [DUBBO] Execute action throws and dispatch a ServiceDiscoveryExceptionEvent, dubbo version: 2.7.12, current host: 172.23.233.52&lt;br/&gt;java.lang.BootstrapMethodError: java.lang.NoClassDefFoundError: org/apache/curator/x/discovery/ServiceDiscovery&lt;br/&gt; at org.apache.dubbo.registry.zookeeper.ZookeeperServiceDiscovery.doRegister(ZookeeperServiceDiscovery.java:92)&lt;br/&gt; at org.apache.dubbo.registry.client.AbstractServiceDiscovery.register(AbstractServiceDiscovery.java:33)&lt;br/&gt; at org.apache.dubbo.registry.client.EventPublishingServiceDiscovery.lambda&lt;span&gt;$register&lt;/span&gt;&lt;span&gt;$0&lt;/span&gt;(EventPublishingServiceDiscovery.java:159)&lt;br/&gt; at org.apache.dubbo.registry.client.EventPublishingServiceDiscovery.executeWithEvents(EventPublishingServiceDiscovery.java:285)&lt;br/&gt; at org.apache.dubbo.registry.client.EventPublishingServiceDiscovery.register(EventPublishingServiceDiscovery.java:157)&lt;br/&gt; at org.apache.dubbo.config.bootstrap.DubboBootstrap.lambda&lt;span&gt;$doRegisterServiceInstance&lt;/span&gt;&lt;span&gt;$21&lt;/span&gt;(DubboBootstrap.java:1192)&lt;br/&gt; at java.util.ArrayList.forEach(ArrayList.java:1259)&lt;br/&gt;  ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然2.7.x的应用级服务发现不再更新，下次写一篇分析3.0版本的应用级服务发现源码的文章吧~&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;搜索关注微信公众号&quot;捉虫大师&quot;，后端技术分享，架构设计、性能优化、源码阅读、问题排查、踩坑实践。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/xacdaKuBM0Q6EwOicVX1AkIevFia5MV1G9SKvAHL3p42YQ2OnYsibgvWe0ffib7mqWibzTq16KDWV2ibEz6UyicqST6BQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a42e4b269b295fd737dafb54e46aca56</guid>
<title>Google 官方强烈推荐 ROOM 数据库，为何放弃 ORMLite、GreenDao、SQLite？</title>
<link>https://toutiao.io/k/k8xvayl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;48&quot; data-source-title=&quot;&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;Google官方强烈推荐ROOM数据库，为何放弃ORMLite、GreenDao、SQLite？&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Room是什么？为何放弃SQLite？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Room 在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;处理大量结构化数据的应用可极大地受益于在本地保留这些数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最常见的用例是缓存相关数据。这样，当设备无法访问网络时，用户仍可在离线状态下浏览相应内容，设备重新连接到网络后，用户发起的所有内容更改都会同步到服务器。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;由于 Room 负责为您处理这些问题，因此Google强烈建议您使用 Room（而不是 SQLite）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;对比了市面上流行ORM框架ORMLite、GreenDao的读写速度如下图&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5049342105263158&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhFRyFIZU4zdW5BnkS9WJ4FEpY5ibicUDVH9GhtxLNGrTaayCNtBYtF1jqY291iaZ9nyCIh4FHfjFrorA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Room 包含 3 个主要组件：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;①数据库：包含数据库持有者，并作为应用已保留的持久关系型数据的底层连接的主要接入点；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;②Entity：表示数据库中的表；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;③DAO：包含用于访问数据库的方法；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;应用使用 Room 数据库来获取与该数据库关联的数据访问对象 (DAO)。然后，应用使用每个 DAO 从数据库中获取实体，然后再将对这些实体的所有更改保存回数据库中， 最后，应用使用实体来获取和设置与数据库中的表列相对应的值。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、Room简单使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;官方标准图&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9033333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhFRyFIZU4zdW5BnkS9WJ4FERMrI3vXlFCz3LWnExtLMJyok0hBWQN4vDqJuGiamdm0TW8QB8qd29Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;dependencies&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attribute&quot;&gt;def&lt;/span&gt; room_version = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;2.3.0&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    implementation &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;androidx.room:room-runtime:&lt;span class=&quot;code-snippet__variable&quot;&gt;$room_version&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    annotationProcessor &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;androidx.room:room-compiler:&lt;span class=&quot;code-snippet__variable&quot;&gt;$room_version&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;http&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @&lt;span class=&quot;code-snippet__attribute&quot;&gt;Entity&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public class User {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        @PrimaryKey&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public int uid;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        @ColumnInfo(name = &quot;first_name&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public String firstName;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        @ColumnInfo(name = &quot;last_name&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public String lastName;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__meta&quot;&gt;@Dao&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;UserDao&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Query&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;SELECT * FROM user&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;List&amp;lt;User&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getAll&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Query&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;List&amp;lt;User&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;loadAllByIds&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;[] userIds)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Query&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;SELECT * FROM user WHERE first_name LIKE :first AND &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;last_name LIKE :last LIMIT 1&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;User &lt;span class=&quot;code-snippet__title&quot;&gt;findByName&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String first, String last)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Insert&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;insertAll&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(User... users)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Delete&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(User user)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Database&lt;/span&gt;(entities = {User.class}, version = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, exportSchema = &lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;DBManager&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;RoomDatabase&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; DBManager INSTANCE = &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;abstract&lt;/span&gt; EventsDao &lt;span class=&quot;code-snippet__title&quot;&gt;eventsDao&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; DBManager &lt;span class=&quot;code-snippet__title&quot;&gt;getDatabase&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (INSTANCE == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;synchronized&lt;/span&gt; (DBManager.class) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (INSTANCE == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    INSTANCE = Room.databaseBuilder(DTEventManager.getInstance().getContext(), DBManager.class, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;dnName&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            .allowMainThreadQueries()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            .build();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; INSTANCE;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;User&amp;gt; usersAll= DBManager.getDatabase().eventsDao().getAll();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; DBManager.getDatabase().insertAll(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; User());&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、room数据库使用中细节详解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1、使用 Room 实体定义&lt;/strong&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;96&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;使用 Room 持久性库时，您可以将相关字段集定义为实体。对于每个实体，系统会在关联的 Database 对象中创建一个表，以存储这些项。您必须通过 Database 类中的 entities 数组引用实体类&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__meta&quot;&gt;@Entity&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; User {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@PrimaryKey&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; int id;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; firstName;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; lastName;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;  1.1使用主键&lt;/strong&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;155&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;每个实体必须将至少 1 个字段定义为主键。即使只有 1 个字段，您仍然需要为该字段添加 @PrimaryKey 注释。此外，如果您想让 Room 为实体分配自动 ID，则可以设置 @PrimaryKey 的 autoGenerate 属性。如果实体具有复合主键，您可以使用 @Entity 注释的 primaryKeys 属性，如以下代码段所示&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__meta&quot;&gt;@Entity&lt;/span&gt;(primaryKeys = {&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;firstName&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;lastName&quot;&lt;/span&gt;})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; User {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; firstName;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; lastName;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;1.2默认情况下，Room 将类名称用作数据库表名称。如果您希望表具有不同的名称，请设置 @Entity 注释的 tableName 属性&lt;/strong&gt;，如以下代码段所示：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__meta&quot;&gt;@Entity(tableName = &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;users&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;User&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;注意：SQLite 中的表名称不区分大小写。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.3与 tableName 属性类似，Room 将字段名称用作数据库中的列名称。如果您希望列具有不同的名称&lt;/strong&gt;，请将 @ColumnInfo 注释添加到字段，如以下代码段所示：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Entity(tableName = &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;users&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;User&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@PrimaryKey&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; int id;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@ColumnInfo(name = &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;first_name&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; String firstName;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@ColumnInfo(name = &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;last_name&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; String lastName;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;1.4忽略字段&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;默认情况下，Room 会为实体中定义的每个字段创建一个列。如果某个实体中有您不想保留的字段，则可以使用 @Ignore 为这些字段添加注释，如以下代码段所示：   &lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__meta&quot;&gt;@Entity&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; User {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@PrimaryKey&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; int id;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; firstName;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; lastName;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Ignore&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Bitmap picture;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;2、使用 Room DAO 访问数据&lt;/strong&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;246&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;如需使用 Room 持久性库访问应用的数据，您可以使用数据访问对象 (DAO)。这些 Dao 对象构成了 Room 的主要组件，因为每个 DAO 都包含一些方法，这些方法提供对应用数据库的抽象访问权限。&lt;/p&gt;&lt;p&gt;通过使用 DAO 类（而不是查询构建器或直接查询）访问数据库，您可以拆分数据库架构的不同组件。此外，借助 DAO，您可以在测试应用时轻松模拟数据库访问；   DAO 既可以是接口，也可以是抽象类。如果是抽象类，则该 DAO 可以选择有一个以 RoomDatabase 为唯一参数的构造函数。Room 会在编译时创建每个 DAO 实现。&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt; 2.1插入&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当您创建 DAO 方法并使用 @Insert 对其进行注释时，Room 会生成一个实现，该实现在单个事务中将所有参数插入数据库中&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__meta&quot;&gt;@Dao&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyDao&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Insert&lt;/span&gt;(onConflict = OnConflictStrategy.REPLACE)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;insertUsers&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(User... users)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Insert&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;insertBothUsers&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(User user1, User user2)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Insert&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;insertUsersAndFriends&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(User user, List&amp;lt;User&amp;gt; friends)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;  如果 @Insert 方法只接收 1 个参数，则它可以返回 long，这是插入项的新 rowId。如果参数是数组或集合，则应返回 long[] 或 List&amp;lt;Long&amp;gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;strong&gt;2.2 更新&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Update 便捷方法会修改数据库中以参数形式给出的一组实体。它使用与每个实体的主键匹配的查询&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Dao&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyDao&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Update&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;updateUsers&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(User... users)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;虽然通常没有必要，但是您可以让此方法返回一个 int 值，以指示数据库中更新的行数&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.3删除&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Delete 便捷方法会从数据库中删除一组以参数形式给出的实体。它使用主键查找要删除的实体&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__meta&quot;&gt;@Dao&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyDao&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Delete&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;deleteUsers&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(User... users)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;2.4查询信息&lt;/strong&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;193&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;@Query 是 DAO 类中使用的主要注释。它允许您对数据库执行读/写操作。每个 @Query 方法都会在编译时进行验证，因此如果查询出现问题，则会发生编译错误，而不是运行时失败。&lt;/p&gt;&lt;p&gt;Room 还会验证查询的返回值，以确保当返回的对象中的字段名称与查询响应中的对应列名称不匹配时，Room 可以通过以下两种方式之一提醒您：&lt;/p&gt;&lt;p&gt;如果只有部分字段名称匹配，则会发出警告。&lt;/p&gt;&lt;p&gt;如果没有任何字段名称匹配，则会发出错误。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;简单查询&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Dao&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyDao&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Query(&lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;SELECT * FROM user&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; User[] loadAllUsers();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;参数传递给查询&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在大多数情况下，您需要将参数传递给查询以执行过滤操作，例如仅显示某个年龄以上的用户。要完成此任务，请在 Room 注释中使用方法参数，如以下代码段所示 &lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__meta&quot;&gt;@Dao&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyDao&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Query&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;SELECT * FROM user WHERE age &amp;gt; :minAge&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; User[] loadAllUsersOlderThan(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; minAge);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt; 3、迁移 Room 数据库&lt;/strong&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;251&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;当您在应用中添加和更改功能时，需要修改 Room 实体类以反映这些更改。但是，如果应用更新更改了数据库架构，那么保留设备内置数据库中已有的用户数据就非常重要。&lt;/p&gt;&lt;p&gt;Room 持久性库支持通过 Migration 类进行增量迁移以满足此需求。每个 Migration 子类通过替换 Migration.migrate() 方法定义 startVersion 和 endVersion 之间的迁移路径。当应用更新需要升级数据库版本时，Room 会从一个或多个 Migration 子类运行 migrate() 方法，以在运行时将数据库迁移到最新版本&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; Migration MIGRATION_1_2 = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Migration(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;migrate&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(SupportSQLiteDatabase database)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        database.execSQL(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;CREATE TABLE `Fruit` (`id` INTEGER, &quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;`name` TEXT, PRIMARY KEY(`id`))&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; Migration MIGRATION_2_3 = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Migration(&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;migrate&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(SupportSQLiteDatabase database)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        database.execSQL(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ALTER TABLE Book &quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; ADD COLUMN pub_year INTEGER&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Room.databaseBuilder(getApplicationContext(), MyDb.class, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;database-name&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        .addMigrations(MIGRATION_1_2, MIGRATION_2_3).build();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;room使用起来很简单，有点sql基础知识点就可以使用；&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;不用使用第三方数据库，毕竟room是官方推荐指定的数据库；&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;room比市面上的流程的ORM框架ORMLite、GreenDao速度和性能上都快很多。&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzk0NDE3MjM1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhFRZkgpibUGGz2NIiaBUpj7NeBSJASje1M1ZhVvpDIGibicMUeCiad3ptsJLaLUjhrVYs5bGZWuenY6UaQ/0?wx_fmt=png&quot; data-nickname=&quot;Android开发编程&quot; data-alias=&quot;&quot; data-signature=&quot;一个有10多年经验开发的android、java、前端等语言的老程序员，在这里一起聊聊技术，一起聊聊生活、一起聊聊中年危机的生存之道，一起进步一起加油，感兴趣的欢迎订阅；不定时的更新。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>