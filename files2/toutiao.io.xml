<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>fb0477070a579d90a5bd39e3799c5248</guid>
<title>[推荐] “三次握手，四次挥手” 这么讲，保证你忘不了</title>
<link>https://toutiao.io/k/ngx4og0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP三次握手、四次挥手，在面试这锅滚油里，可谓是炸了千百遍的老油条。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcUdEsjLhrqT29X3Lb8QxkQqSuCBIYJOsD8PKicM5HVzlicgXyKLKJGkvqXk3AxBhfhuPsaCEibOmQpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6613636363636364&quot; data-w=&quot;440&quot;/&gt;&lt;figcaption&gt;老油条&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道TCP是面向连接的，&lt;code&gt;三次握手&lt;/code&gt;就是用来建立连接的，&lt;code&gt;四次握手&lt;/code&gt;就是用来断开连接的。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三次握手&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先上图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUdEsjLhrqT29X3Lb8QxkQToUqcAPJia1xRPGYW8F2AjC8z1ktNAmaqJ8azFtvNEHo1TPvrBpLbCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9139414802065404&quot; data-w=&quot;581&quot;/&gt;&lt;figcaption&gt;三次握手&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下三次握手的过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一开始，客户端和服务端都处于 &lt;code&gt;CLOSED&lt;/code&gt; 状态。客户端主动打开连接，服务端被动打卡连接，结束&lt;code&gt;CLOSED&lt;/code&gt; z状态，开始监听，进入 &lt;code&gt;LISTEN&lt;/code&gt;状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一次握手&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端会随机初始化序号（&lt;code&gt;client_isn&lt;/code&gt;），将此序号置于 TCP 首部的「序号」字段中，同时把 &lt;code&gt;SYN&lt;/code&gt; 标志位置为 &lt;code&gt;1&lt;/code&gt; ，表示 &lt;code&gt;SYN&lt;/code&gt; 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 &lt;code&gt;SYN-SENT&lt;/code&gt; 状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;二次握手&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;服务端收到客户端的 &lt;code&gt;SYN&lt;/code&gt; 报文后，首先服务端也随机初始化自己的序号（&lt;code&gt;server_isn&lt;/code&gt;），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 &lt;code&gt;client_isn + 1&lt;/code&gt;, 接着把 &lt;code&gt;SYN&lt;/code&gt; 和 &lt;code&gt;ACK&lt;/code&gt; 标志位置为 &lt;code&gt;1&lt;/code&gt;。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 &lt;code&gt;SYN-RCVD&lt;/code&gt; 状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;三次握手&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 &lt;code&gt;ACK&lt;/code&gt; 标志位置为 &lt;code&gt;1&lt;/code&gt; ，其次「确认应答号」字段填入 &lt;code&gt;server_isn + 1&lt;/code&gt; ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，经过三次握手的过程，客户端和服务端之间的确定连接正常，接下来进入&lt;code&gt;ESTABLISHED&lt;/code&gt;状态，服务端和客户端就可以快乐地通信了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个动态过程的图示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PMZOEonJxWcUdEsjLhrqT29X3Lb8QxkQv1XlfgWTBNX8uCJ7Qqdv5HcYrDO6yfnpQib2woFJLYmWuqSkge1mfpw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.5915492957746479&quot; data-w=&quot;639&quot;/&gt;&lt;figcaption&gt;三次握手动图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个小细节，第三次握手是可以携带数据的，这是面试常问的点。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;&lt;strong&gt;那么为什么要三次握手呢？两次不行吗？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为了防止服务器端开启一些无用的连接增加服务器开销&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于网络传输是有延时的(要通过网络光纤和各种中间代理服务器)，在传输的过程中，比如客户端发起了 SYN=1 的第一次握手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务器端就直接创建了这个连接并返回包含 SYN、ACK 和 Seq  等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有第三次握手告诉服务器端客户端收的到服务器端传输的数据的话，服务器端是不知道客户端有没有接收到服务器端返回的信息的。服务端就认为这个连接是可用的，端口就一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来，就会有很多无效的连接端口白白地开着，导致资源的浪费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程可理解为：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUdEsjLhrqT29X3Lb8QxkQP45Hccn8Dw6LWj7oLAMJs45B3b0bnxFPV9r1udseibcIMKjJDKSS9wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.42731277533039647&quot; data-w=&quot;681&quot;/&gt;&lt;figcaption&gt;非三次握手-有差错情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种情况是已经失效的客户端发出的请求信息，由于某种原因传输到了服务器端，服务器端以为是客户端发出的有效请求，接收后产生错误。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUdEsjLhrqT29X3Lb8QxkQWKgQ7xu0b8Kym4sK32yccubjgQcy8XXgQdM6YjbicVxT4df29b50DFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.43047337278106507&quot; data-w=&quot;676&quot;/&gt;&lt;figcaption&gt;失效请求&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们需要“第三次握手”来确认这个过程：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过第三次握手的数据告诉服务端，客户端有没有收到服务器“第二次握手”时传过去的数据，以及这个连接的序号是不是有效的。若发送的这个数据是“&lt;code&gt;收到且没有问题&lt;/code&gt;”的信息，接收后服务器就正常建立 TCP 连接，否则建立 TCP  连接失败，服务器关闭连接端口。由此减少服务器开销和接收到失效请求发生的错误。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四次挥手&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是先上图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUdEsjLhrqT29X3Lb8QxkQ8XKEsmsicY0r0ibfxqJFY0RJSeiaUwqAqica1XNhnHOmNhcOeTuULeqCmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9483648881239243&quot; data-w=&quot;581&quot;/&gt;&lt;figcaption&gt;四次挥手示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聚散终有时，TCP 断开连接是通过&lt;strong&gt;四次挥手&lt;/strong&gt;方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;双方&lt;/code&gt;都可以主动断开连接，断开连接后主机中的「资源」将被释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图是客户端主动关闭连接 ：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一次挥手&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端打算关闭连接，此时会发送一个 TCP 首部 &lt;code&gt;FIN&lt;/code&gt; 标志位被置为 &lt;code&gt;1&lt;/code&gt; 的报文，也即 &lt;code&gt;FIN&lt;/code&gt; 报文，之后客户端进入 &lt;code&gt;FIN_WAIT_1&lt;/code&gt; 状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;二次挥手&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;服务端收到该报文后，就向客户端发送 &lt;code&gt;ACK&lt;/code&gt; 应答报文，接着服务端进入 &lt;code&gt;CLOSED_WAIT&lt;/code&gt; 状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;三次挥手&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端收到服务端的 &lt;code&gt;ACK&lt;/code&gt; 应答报文后，之后进入 &lt;code&gt;FIN_WAIT_2&lt;/code&gt; 状态。等待服务端处理完数据后，也向客户端发送 &lt;code&gt;FIN&lt;/code&gt; 报文，之后服务端进入 &lt;code&gt;LAST_ACK&lt;/code&gt; 状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;四次挥手&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端收到服务端的 &lt;code&gt;FIN&lt;/code&gt; 报文后，回一个 &lt;code&gt;ACK&lt;/code&gt; 应答报文，之后进入 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器收到了 &lt;code&gt;ACK&lt;/code&gt; 应答报文后，就进入了 &lt;code&gt;CLOSED&lt;/code&gt; 状态，至此服务端已经完成连接的关闭。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端在经过 &lt;code&gt;2MSL&lt;/code&gt; 一段时间后，自动进入 &lt;code&gt;CLOSED&lt;/code&gt; 状态，至此客户端也完成连接的关闭。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以看到，每个方向都需要&lt;strong&gt;一个 FIN 和一个 ACK&lt;/strong&gt;，因此通常被称为&lt;strong&gt;四次挥手&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;&lt;strong&gt;为什么要挥手四次？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来回顾下四次挥手双方发 &lt;code&gt;FIN&lt;/code&gt; 包的过程，就能理解为什么需要四次了。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;关闭连接时，客户端向服务端发送 &lt;code&gt;FIN&lt;/code&gt; 时，仅仅表示客户端不再发送数据了但是还能接收数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器收到客户端的 &lt;code&gt;FIN&lt;/code&gt; 报文时，先回一个 &lt;code&gt;ACK&lt;/code&gt; 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 &lt;code&gt;FIN&lt;/code&gt; 报文给客户端来表示同意现在关闭连接。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 &lt;code&gt;ACK&lt;/code&gt; 和 &lt;code&gt;FIN&lt;/code&gt; 一般都会分开发送，从而比三次握手导致多了一次。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;&lt;strong&gt;为什么客户端在TIME-WAIT阶段要等2MSL？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为的是确认服务器端是否收到客户端发出的 ACK 确认报文，当客户端发出最后的 ACK 确认报文时，并不能确定服务器端能够收到该段报文。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以客户端在发送完 ACK 确认报文之后，会设置一个时长为 2MSL 的计时器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MSL 指的是 Maximum Segment Lifetime：一段 TCP 报文在传输过程中的最大生命周期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2MSL 即是服务器端发出为 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器端在 1MSL 内没有收到客户端发出的 ACK 确认报文，就会再次向客户端发出 FIN 报文：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果客户端在 2MSL 内，再次收到了来自服务器端的 FIN 报文，说明服务器端由于各种原因没有接收到客户端发出的 ACK 确认报文。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端再次向服务器端发出 ACK 确认报文，计时器重置，重新开始 2MSL 的计时。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;否则客户端在 2MSL 内没有再次收到来自服务器端的 FIN 报文，说明服务器端正常接收了 ACK 确认报文，客户端可以进入 CLOSED  阶段，完成“四次挥手”。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，客户端要经历时长为 2SML 的 TIME-WAIT 阶段;这也是为什么客户端比服务器端晚进入 CLOSED 阶段的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里同样有个动态过程的图示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PMZOEonJxWcUdEsjLhrqT29X3Lb8QxkQcKicMnV7jY1wSpic8wSgvNa5BZTVe31zHBn8WvdqicbiaPaetetMdDOIkA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.5916666666666667&quot; data-w=&quot;480&quot;/&gt;&lt;figcaption&gt;四次挥手动态图示&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，我们的文章到这就……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;唉，不对，就这么完了，这会我好像知道了，但过会儿那就说不定了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcUdEsjLhrqT29X3Lb8QxkQURRzNLaZCPCZtde49jSzBJe1dpH4zvvV9WkwJ3b6ub6DhyCVRrmYsQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;1&quot; data-w=&quot;640&quot;/&gt;&lt;figcaption&gt;知识不进脑子&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没关系，我苦思冥想，找了两个大白话的例子，保准你忘不了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;大白话说三次握手&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在二十年前的农村，电话没有普及，手机就更不用说了，所以，通信基本靠吼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老张和老王是邻居，这天老张下地了，结果家里有事，热心的邻居老王赶紧跑到村口，开始叫唤老王。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;老王：老张唉！我是老王，你能听到吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老张一听，是老王的声音：老王老王，我是老张，我能听到，你能听到吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老王一听，嗯，没错，是老张：老张，我听到了，我有事要跟你说。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&quot;你老婆要生了，赶紧回家吧！&quot;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老张风风火火地赶回家，老婆顺利地生了个带把的大胖小子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;握手的故事充满了幸福和美满。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUdEsjLhrqT29X3Lb8QxkQJKT1RUURJsic62NYf8Dboibj7O4L15MjSDM9sQoaoQJo74jYQ15wTJ7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.8261617900172118&quot; data-w=&quot;581&quot;/&gt;&lt;figcaption&gt;大白话说三次握手&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;大白话说四次挥手&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如博主有一个女朋友——只是“假如”，该死的，这不争气的眼泪，怎么止不住地滴在键盘上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于博主上班九九六，下班肝博客，导致没有时间陪女朋友，女朋友忍无可忍。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;女朋友：臭男人，最近你都不理我，你是不是不爱我了？你是不是外面有别的狗子了？我要和你分手？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;沙雕博主一愣，怒火攻心：分手就分手，不陪你闹了，等我把东西收拾收拾。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;沙雕博主小心翼翼地装起了自己的青轴机械键盘。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;哼，蠢女人，我已经收拾完了，我先滚为敬，再见！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;女朋友：滚，滚的远远的，越远越好，我一辈子都不想再见到你。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;唉，挥手的故事总充满了悲伤和遗憾！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUdEsjLhrqT29X3Lb8QxkQjYUUttF8kL9UHfRVVAWmTibSEia6Qq5XiaKsicm4NjLVAZVcOuyd4TazgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.9532062391681109&quot; data-w=&quot;577&quot;/&gt;&lt;figcaption&gt;白话四次挥手&lt;/figcaption&gt;&lt;/figure&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;好了，白话纯属娱乐！看在博主费了不少脑子的份上，点个赞再走呗！！&lt;/p&gt;&lt;/blockquote&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;【1】：[两张动图-彻底明白TCP的三次握手与四次挥手](https://blog.csdn.net/qzcsu/article/details/72861891)&lt;br/&gt;&lt;br/&gt;【2】：[35 张图解：被问千百遍的 TCP 三次握手和四次挥手面试题](https://www.cnblogs.com/xiaolincoding/p/12638546.html)&lt;br/&gt;&lt;br/&gt;【3】：[三次握手+四次挥手，一文搞定所有！](https://network.51cto.com/art/202001/609110.htm)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fd2508dbd06110abd730f8820c6363f4</guid>
<title>[推荐] Golang 内存管理分析</title>
<link>https://toutiao.io/k/5za3e5u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大纲&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;1. 目录&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2. 由一个问题展开&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3. 名字说明&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4. 内存怎么采样？&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;4.1 编译期间逃逸分析&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.2 采样的简单实现&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.3 内存采样的时机&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.4 内存采样的入口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.5 内存采样的信息&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.6 golang的类型反射&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;5. 内存分配&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;5.1 C语言你分配和释放内存怎么做？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;5.2 内存分配设计考虑的几个问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;5.3 golang的内存分配&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;6. 内存回收&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;6.1 golang协程抢占执行&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.2 STW是怎么回事？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.3 垃圾回收要求&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.4 golang版本迭代历史&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.5 GC触发条件&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.6 三色定义&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.7 GC流程&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.8 写屏障&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.9 内存可见性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.10 注意问题&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 目录&lt;strong/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 由一个问题展开&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang从语言级别，就提供了完整的采样和分析的机制。大家经常使用 pprof 分析内存占用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5359477124183006&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DIlBNOZ88iaCnvgTgGLTF9HbeHX7WCJS22BYiajN5aXVWj6qzGLuf2EXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是不清楚怎么实现？不清楚怎么看指标？不清楚 flat，cum的区别？我们就从这个问题展开。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 名字说明&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;内存分析的时候，有四个输入选项：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;alloc_objects : 历史总分配的累计&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;alloc_space ：历史总分配累计&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;inuse_objects：当前正在使用的对象数&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;堆上分配出来，业务正在使用的，也包括业务没有使用但是还没有垃圾回收掉的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;inuse_space：当前正在使用的内存&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;两个输出选项：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;flat：平坦分配，非累加&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cum：累加&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考几个问题：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;上面说的对象是什么概念？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;经常使用内存分析，这个内存分析是否是精确的？性能消耗大不大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为啥显示的是堆栈？不是说分配的对象吗？为啥不直接显示分配的对象结构名？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 内存怎么采样？&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 编译期间逃逸分析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明下，golang pprof是分析从堆上分配的内存。golang的内存在堆上，还是在栈上？这个不是我们决定的，就算你调用new这个关键字，也不一定是在堆上分配。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.29850746268656714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DwtPSLRiaQhRoe92zpicanF5zAKlECXHeME4ZKqAwfOHSZicz1zJu5cfvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;402&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.21794871794871795&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DwB356SekRQGzKxIMD16Kropp3P1q4TH9picsL6VPF3UwSM1NY3yn7eQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;逃逸分析是golang的一个非常重要的一个点。&lt;/span&gt;&lt;span&gt;对于内存分配，垃圾回收的设计都有非常重要的影响。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 采样的简单实现&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采样的实现非常简单。简单描述流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用一个公共变量用来记录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分配内存的时候，加alloc size，加alloc对象数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;释放内存的时候，加free size，加free对象数&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;累计分配：就是alloc
当前在用 inuse：就是 &lt;code&gt;alloc-free&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8091603053435115&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DjOF71fW6Fln0WUH6ulvHYPkYGomUPHPOUicXY7dutDSQn8opHbVfTdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 内存采样的时机&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;采样的时机说3个点：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分配堆上内存的时候，累计分配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回收器释放堆上内存的时候，累计释放&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每512KB打点采样&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是注意一点：并不是每一次分配内存都会被采样。也就是说这里其实是有个权衡的。现在是每满512KB才会采样一次。这里的考虑是性能和采样效果的权衡。因为采样是要耗费性能的，是要取堆栈的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;怎么理解？举个例子&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想情况下（不考虑其他任何影响）：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4197247706422018&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4Dv7xia7VVEaaxR0V7ZASiagO7tuibSQTI8TwD3JeXqdFUQOXITx6qbr9ibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1744&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么有人会想，这样岂不是会漏掉了很多内存？统计还能用来排查问题吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是性能和效果的一个考虑，一般来讲，我们是用pprof分析内存占用的时候，在整个golang程序跑起来后，时时刻刻都在分配释放内存，每累计分配512KB，打点一次。虽然会漏掉一些内存分配释放，但是对每个结构都是公平的。如果有一个内存泄露分配行为，那么累计下来一定会被抓住的，并且是非常容易被抓住。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.4 内存采样的入口&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存采样的入口，这个非常简单理解。肯定是一个在分配内存的函数位置，一个是释放内存的位置。这里要特意提下上下文环境。因为golang是垃圾回收类型的语言，内存分配是完全交由golang自己管理，自己不能管理内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;两个入口函数：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mProf_Malloc&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mProf_Free&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个是配套使用的采样打点函数。而且一定是配套的。简单说：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mProf_Malloc 是由业务程序行为（赋值器）触发的，分配内存嘛。比如你new了一个对象，这个对象在堆上，那么会调用 &lt;code&gt;mallocgc&lt;/code&gt; 分配内存，如果到了采样点，那么会调用 &lt;code&gt;mProf_Malloc&lt;/code&gt; 采样。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mProf_Free 是回收器在确定并且将要回收内存的时候调用的。是垃圾回收过程的一环。并且还要注意一点，只有打过点的（mProf_Malloc计数过的对象，会有一个特殊处理），才会配套使用mProf_Free。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不是说，任意给一个内存地址给你。你都知道这个是业务类型。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.5 内存采样的信息&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里问你的是，golang采样是采样啥？类型信息？这里也说过一点，内存这里和类型系统是没啥关系的。这里采样的是分配栈，也就是分配路径。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.5.1 flat，cum 分别是怎么来的？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看个例子：&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9725490196078431&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DfG9con5dbDHuPsyiaUFqnA9qEMNoNfPWuus2C0e6DEtq2KcibB9nKUmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;510&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以先猜下，我们看alloc_space。这个内存会是怎么累计到的。实际统计如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3450087565674256&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DiapKxudCtticZGcDvZy4vFrYO4RB8yeQSak92CgqdiaSOf9gvacMcicqbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和大家猜的一样吗？这些是怎么看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;首先说几个结论：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;flat统计到的，就是这个函数实际分配的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cum是累计的，包含自己分配的，也包含路过的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;cum和flat不相同的时候，代表这个函数除了自己分配内存，自己内部调用的别的函数也在分配内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重点提示：这个要理解这个，首先要知道，内存采样的是什么，内存采样的是分配栈。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解释说明&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图中140M我们当150M看哈，这里采样少了第一次，细节原因可以看代码，这里提一下，不做阐述。）：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;main函数里，A函数调用了5次，B函数 5次，C函数5次。其中B会调用A，C会调用B。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用一次A会分配10M内存，调用一次B会分配20M，调用一次C会分配30M。总累计分配内存是300M&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A函数实际调用次数是 15次；这个和flat的值是一致的：150M&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;(A) * 5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(B -&amp;gt; A) * 5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(C -&amp;gt; B -&amp;gt; A) * 5&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;B函数函数实际调用10次；这个和flat的值也是一致的：100M&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;B * 5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(C -&amp;gt; B) * 5&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;C函数5次：这个和flat的值是一致的：50M&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;C * 5&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;main函数300M，也是一致的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图示&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8029925187032418&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DfIOOpsV7U94sIWrGM8vhXBQMq9SgljYRHPwx5PKZicaqMDEahawGeqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记住一句话：采样是记录分配堆栈，而不是类型信息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.6 golang的类型反射&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考几个问题：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;任意给一个内存地址给你，能知道这个对象类型吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang的反射到底是怎么回事？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先说结论：golang里面，内存块是没有携带对象类型信息的，这个跟C是一样的。但是golang又有反射，golang的反射一定要基于interface使用。这个要仔细理解下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为，golang里面interface的结构变量，是会记录type类型的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反射定律一：&lt;/strong&gt;反射一定是基于接口的。是从接口到反射类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反射定律二：&lt;/strong&gt;反射一定是基于接口的。是从反射类型到接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是那句话，golang的反射一定是依赖接口类型的，一定是经过接口倒腾过的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.44385026737967914&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DR1Tyicnbtesda7qV9SViavDJ0siaWEe1AtzTb5a3tRWnJqdlvzwQTAmAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;374&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为当前接口这个类型对应了两个内部结构：&lt;code&gt;struct iface&lt;/code&gt;，&lt;code&gt;struct eface&lt;/code&gt;，这两个结构都是会存储type类型。以后的一切都是基于这个类型的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 内存分配&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 C语言你分配和释放内存怎么做？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思考一个问题，在C语言里，我们分配内存：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分配内存的时候，传入大小，拿到一个指针。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ptr = malloc(1024);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放内存的时候，直接传入ptr，没有任何其他参数：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;free (ptr);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放的时候，怎么确定释放哪些位置？如果要你自己实现，有很多简单的思路，说一个最简单的：分配的时候，不止分配1024字节，还分配了其他的信息，带head了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.3878048780487804&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DpWk8icmdLTf4ddR3pOjLzymKAEC6icv2V9NtG32IAicz0ic9qUH9K8Z1BA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;410&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种分配方式有什么问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;开销大，在通用的内存分配器中，很多场景下，有可能meta信息比自身还要大。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 内存分配设计考虑的几个问题&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;性能&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;局部性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;碎片率&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内部碎片率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;外部碎片率&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 golang的内存分配&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang大方向的考虑就是基于局部性和碎片率来考虑的。使用的是和tcmalloc一致的设计。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.1 整体设计&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，内存块是不带类型信息的。像我们在C语言里面，有时候实现的简单的内存池，在不考虑一些开销的时候，会把业务类型放到meta信息里，为的是排查问题方便。golang内存管理作为一个通用模块，不会这么搞。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.1.1 地址空间设计&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，你查golang的资料，会看到这张图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.16575449569976544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4Deia6DHht4QwS4kE9VUW6yHlvY6Iwl2bnYf4iaK6p35KdicwL6ejnnmQmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1279&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这张图有几个信息比较重要&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为什么spans区域是512M，bitmap区是16G，arena是512G？先不要纠结值，我们先说这个比例关系：&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;spans区域，一个指针大小（8Byte）对应arena的一个page（8KB），倍数是1024&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bitmap区域，一个字节（8bit）对应arena的32Bytes，倍数是32倍&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;我们给用户分配的内存就是arena区域的内存，spans区，bitmap区均为其他用途的元数据信息。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;bitmap这个实现我们这次不谈，不同通过这个你得知道一点：并不是所有的内存空间都会扫描一把，是有挑选判断的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;spans区域是一般用来根据一个内存地址查询mspan结构的。调用函数：spanOf。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bitmap是用来辅助垃圾回收用的区域。有这个bitmap信息可以提高回收效率和精度。注意一点，这个不是标识object是否分配的位图，标识是否分配object的问题是&lt;code&gt;mspan.allocBits&lt;/code&gt;结构。这个可以理解为提高垃圾回收效率的实现。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意几个点：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;很多文章都提到golang内存512GB这个事情。512GB说的是内存虚拟地址空间的限制，是最大能力，是最大的规划利用。golang之前最大可以使用的内存地址空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang1.11 之后已经没有512GB的限制了。基本上和系统的虚拟地址空间一致&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个比例还是一样的，1：1024，1：32&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;就算golang1.11之前，也不是说golang的程序上来就向系统申请这么大块虚拟地址。也是每64M的申请，管理对象单元是heapArea结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;三个区域看着连续结在一起，但是其实不是连续的地址。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实际的实现中都是以64M（heapArena）的小单位进行的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.2 抽象对象概念&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4629981024667932&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4D6IqsF5vpIumCKMxwOhDB4A4dQeakqdwOZRt95gicXbqVY09K56bYiaJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1054&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;物理偏向概念&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;heapArena：堆上物理空间管理的一个小单元，64M一个。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;page：物理内存最小单位，8KB一个。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逻辑偏向概念&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;span：span为内存分配的一个管理单元。span内按照固定大小size划分，相同的size划分为同一类。一个span管理一个连续的page。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;object：内存分配的最小单元。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;管理结构层次概念&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mcache：每个M上的，管理内存用的。我们都知道GMP架构，每个M都有自己的内存cache管理，这样是为了局部性。只是一个cache管理。mcentral：mheap结构所有，也只是一个cache管理，但是是为所有人服务的。mheap：是真正负责分配和释放物理内存的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3 局部性的设计&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个思路很简单，就是设计成局部性的一个层次设计。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3.1 mcache&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mcache由于只归属自己的M，span一旦在这个结构管理下，其他人是不可见，不会去操作的。只有这个m会操作。所以自然就不需要加锁。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3.2 mcentral&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mcentral是所有人可见的。所以操作自然要互斥，这个的作用也是一个cache的统一管理。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3.3 mheap&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是负责真实内存分配和释放的的一个结构。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.4 针对碎片率的设计&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang的内存设计目标：碎片率平均12.5%左右。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7231726283048211&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DRE53brYCleJl6622uSwAsh9QFwu9GBhezQMxT19GDEibhB4OibnrKQNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;643&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;tail wast实际是浪费的外部碎片&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;比如说，第一种size，8字节。一个page 8KB，8字节刚好对齐。外部碎片为0.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;max waste说的是最大的内部碎片率&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;怎么算的？每一个放进该span的对象大小都是最小值的情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比如说，第一种size，8字节。最小的对象是1字节，浪费7字节，最大碎片率为 1-1/8 = 87.5%&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么的出来的这些值？经验值吧，可能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 内存回收&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 golang协程抢占执行&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，golang没有真正的抢占。golang调度单位为协程，所谓抢占，也就是强行剥夺执行权。但是有一点，golang本质上是非抢占的，不像操作系统那样，有时钟中断和时间片的概念。golang虽然里面是有一个抢占的概念，但是注意了，这个抢占是建议性质的抢占，也就是说，如果有协程不听话，那是没有办法的，实现抢占的效果是要对方协程自己配合的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话：系统想让某个goroutine自己放弃执行权，会给这个协程设置一个魔数，协程在切调度，或者其他时机检查到了的时候，会感知到这一个行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当前的抢占实现是：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;给这个协程设置一个的魔数(stackguard)。每个函数的入口会比较当前栈寄存器值和stackguard值来决定是否触发morestack函数。（这是一个抢占调度点）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协程调用函数的时候，会检查是否需要栈扩容。如果被设置了抢占标示，那么就会首先调用到&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用newstack，在newstack里面判断是否是特殊值，这种特殊值，目的不在于扩容，而在于让出调度。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在golang里面，只要有函数调用，就会有感知抢占的时机。stw就是基于这个实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考一个问题：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有一个猥琐的函数：非常耗时，一直在做cpu操作，并且完全没有函数调用。这种情况下，golang是没有一点办法的。那么这种情况会影响到整个程序的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们平时写函数，一定要短小精悍，功能拆分合理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2 STW是怎么回事？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;STW：stop the world，也就是说暂停说由协程的调度和执行。stw是怎么实现？stw的基础就是上面提到的抢占实现。stw调用的目的是为了让整个程序（赋值器停止），那么就需要剥夺每一个协程的执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;stw在垃圾回收的几个关键操作里是需要的，比如开启垃圾回收，需要stw，做好准备工作。如果stw的时候，出现了猥琐的函数，那么会导致整个系统的能力降低。因为大家都在等你一个人。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3 垃圾回收要求&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;正确性：绝对不能回收正在使用的的内存对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存活性：一轮回收过程一定是有边界，可结束的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.4 golang版本迭代历史&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;go 1.3 以前，使用是标记-清扫的方式，整个过程需要stw&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go 1.3 版本分离了标记和清扫操作，标记过程stw，清扫过程并发执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go 1.5 版本在标记过程中，使用三色标记法。回收过程分为四个阶段，其中，标记和清扫都并发执行的，但标记阶段的前后需要stw一定时间来做gc的准备工作和栈的re-scan。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go 1.8 版本引入了混合写屏障机制，避免了对栈的re-scan，极大的减少了stw的时间。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.5 GC触发条件&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;gcTriggerHeap 当分配的内存达到一定值就触发GC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gcTriggerTime 当一定时间没有执行过GC就触发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gcTriggerCycle 要求启动新一轮的GC，一启动则跳过，手动触发GC的runtime.GC( )会使用这个条件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6 三色定义&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6.1 强三色&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;黑色对象不允许指向白色对象。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6.2 弱三色&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;黑色对象可以指向白色对象，但是前提是，该白色对象一定是处于灰色保护链中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.7 GC流程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里不详细阐述了。贴一张go1.8之前的图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DzW1eHrJBFC877UblYFvicerpibx33hDrxmbKq41EQEwSmaYlmGAJOiaZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当下GC大概分为四个阶段：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;GC准备阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标记阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标记结束阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;清理阶段&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8 写屏障&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果标记和回收不用和应用程序并发，在标记和回收整个过程直接stw，那么就简单了。golang为了提供低时延，就必须让赋值器和回收器并发起来。但是在并发的过程中，赋值器和回收器对于引用树的理解就会出现不一致，这里就一定要配合写屏障技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写屏障技术，是动态捕捉写操作，维持回收正确性的技术。写屏障就是一段 hook 代码，编译期间生成，运行期间跟进情况会调用到 hook 的代码段，也就是写屏障的代码；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面系统整体的讨论下写屏障的技术。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.1 插入写屏障&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（Dijkstra &#x27;78）&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer ( slot, ptr ):&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 无脑保护插入的新值&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade ( ptr )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是另外一个通用的屏障技术。这个维护的是强三色不变式来保证正确性，保证黑色对象一定不能指向白色对象。golang使用的是这个屏障，插入屏障。按照道理，是几乎完全不需要stw的。但是golang有一个处理，由于栈上面使用屏障会导致处理非常复杂，并且开销会非常大。所以当前golang只针对堆上的写操作做了屏障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么就会带来一个问题：所以当一轮扫描完了之后，在标记结束的阶段，还需要重新扫描一遍goroutine栈，并且栈引用到的所有对象也要扫描。因为goroutine有可能直接指向了白色对象。在扫描goroutine栈过程中，需要stw。这个也是go1.8以前的一个非常大的延迟来源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（开始的时候，stw扫描栈，得到灰色对象）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图表演示&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆上路径赋值：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1：堆上对象赋值的时候，插入写屏障，保护强三色不变式&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.36728395061728397&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DF11J33eLfia9xy4ayicqjFhKiaUlolbJiaeSBEggF7OkOHa0HvHUyHehGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：删除的时候，没啥问题&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.36699239956568946&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DHmRyWF8d4hV8kyIj0nc9lwcNiawRWBOVuBhPwYvXKTbr1hhwQFHyueg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;921&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;栈上对象赋值：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step3：栈上对象赋值的时候，没有写屏障。白色对象直接被黑色对象引用。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3575240128068303&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DUfO37E2nVSWzicziaqGdTkrxencx5GPpEDUjBwg5UGGLZO1Mc1q4s7Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;937&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step4：删除灰色保护路径。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.393018018018018&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DpgtnqHS2v5Hq1qG9RAI8CicMpJicZz4EluZJJA6EiaibOfGj3LnauQQO4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以才需要在mark terminato阶段，重新扫描栈。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.2 删除写屏障&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（Yuasa &#x27;90）&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer ( slot, ptr ):&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     // 删除之前，保护原先白色或者灰色指向的数据块&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if ( isGery ( slot )  || isWhite ( slot ) )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        shade ( *slot )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是通用的一种写屏障技术。golang并没有实现，而是实现了插入写屏障。原因就在于：这个在垃圾回收之前，必须做一个快照扫描，这个就会对用户时延有比较严重的影响。下面详述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主要流程：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在标记之前，需要打一个引用关系的快照。所以，这个对于栈内存很大的时候，影响越大。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不需要完整的快照，只需要在扫描堆对象之前，确保所有的栈对象是黑色的。引用都是灰色的，这样就保证了一个前提：所有可达的对象都处于灰色保护状态中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对栈快照扫描需要stw，去扫描栈对象。这个时候，是需要暂停所有的用户程序。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;扫描堆对象的时候，可以和应用程序并发的。此后根一直保持黑色（黑色赋值器），不用再扫描栈。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对象被删除的时候，删除写屏障会捕捉到。置灰。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;上面的伪代码显示有条件，其实第一版的时候是没有条件的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这里加上条件是为了回收精度：当上游之前是白色或者灰色才需要把这个置灰色。如果是黑？那么一定是处于灰色保护状态，因为这个是前提（理解这个非常重要）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（开始的时候，stw扫描栈，得到灰色对象）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图表演示&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始扫描快照后：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37760702524698136&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DLicOrYWuDIic3rNQPtJNmbCx5iaevmMaKcic3DUeuW0iapotAibnGhUx2kWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1: 赋值。这里赋值是允许的，虽然是破坏了强三色不变式。但是还是符合弱三色不变式。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.324&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DAVAO12ru4MZXSHGTcNgNxFOJuSf4EbrS36FKict4EUW6fKDoqicd6ZcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：删除。这里就拦截了，必须置灰色。保证弱三色不变式。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3452502553626149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DGHKQZBgNYAQtHye4aA4F385MLcBPqrylWt0SQr03fEzF38hatbAgJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;979&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;回收精度：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除写屏障的精度比插入写屏障的精度更低。删除的即使是最后一个指针，也会保留到下一轮，属于一个浮动垃圾。这个比插入屏障精度还低。因为，对于插入屏障所保留的对象，回收器至少可以确定曾在其中执行了某些回收相关的操作（获取或写入对象的引用），但删除屏障所保留的对象却不一定被赋值器操作过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么需要打快照？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除写屏障，又叫快照屏障增量技术（或者说，一定要配合这个来做）。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，是需要stw，针对扫描整个栈根打做一遍扫描。相当于一个快照。这个过程扫描之后，就能保证当前（时刻）所有可达的对象都处于灰色保护状态，满足弱三色不变式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，赋值器和回收器就可以并发。但是并发有可能会破坏导致弱三色不变式。这个时候，就需要删除写屏障来时刻保护白色对象。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;golang为啥没有用这个？&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个是精度问题，这个精度要比插入写屏障低；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;考虑goroutine可能非常多，不适合上来就stw，扫描所有的内存栈。这个适合小内存的场景。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;思考一个问题：这个和混合写屏障有没有区别？还是有区别的，这里是要锁整个栈，混合写屏障是并发的，每次只需要锁单个栈。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.3 混合写屏障&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合屏障是结合插入屏障和删除屏障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;伪代码：&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer (slot, ptr) :&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 保护原来的（被删除的）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade ( *slot )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if current stack is grey:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 如果对象为灰色，则还需要保护新指向的对象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        shade ( ptr )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（开始的时候，stw扫描栈，得到黑色对象）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;golang实际情况：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪代码如上。但是这里提出来一点，golang根本不是和伪代码说的这样。没有做条件判断，所以现在的回收精度很低。这个算是一个TodoList。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0122591943957968&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DVkeCnpYkTS4rfhJmYmicZyYMbNKtGj55dWLSzwWU2LcNiaLO0clJRsJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：使用了混合屏障，还是针对堆上的，栈上对象写入还是没有barrier。golang之前只使用插入屏障，关键在于栈对象没有，导致栈上黑对象可能指向白对象。所以要rescan。因为如果不rescan，而且又破坏了弱三色不变式（没有处于灰色保护链中），那么就丢数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合屏障，就是结合删除屏障，保护这一个前提，代价就是进一步降低回收精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图表示例：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合屏障就是要解决：&lt;strong&gt;栈指向白色对象，stw重新扫描栈的问题。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1：赋值白对象到黑对象引用，这个不会阻止这个，也不会有写屏障。就是一个正常的赋值。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个时候黑色指向了白色对象。破坏了强三色不变式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;但是这个白色对象还处于灰色状态保护下。符合弱三色不变式。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.35441527446300713&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DiaujllHfur23qsTtVYRv3WHS75iaic25pzYkVf6Y3RC0dCdz7eqIcyANg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1676&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：删除指针的时候，意图破坏弱三色不变式的时候，写屏障就会把这个对象置灰色。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36830102622576966&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DjkltfZP8Er69jfV4hLtmMUwCtPusQvgfqCvyZzar1xzvezSxm3icfXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1754&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题一：如果有个还会想？由于栈上没有写屏障，这个删除的对象式根指向的呢？如果存在以下场景?&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1：堆上的白色对象引用赋值给黑色栈对象。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3645955451348183&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DMmViaDZLmjTrlLcRAv9W2daNtHXMX8ic6rXMH0PGGe5ysALjgD4Kib28g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1706&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：如果删除指针，岂不是连弱三色不变式也破坏了？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36874236874236876&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DhOuzeeiacib7etGBg8pQib4xSmycRjsA8UEhHAFWUTF6xiazYyOZbz3yFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1638&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这个怎么办呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是：其实根本就不可能出现这个场景的引用图。第一个图就不会出现。因为虽然没有stw，但是扫描某个g的时候，这个g是暂停的。相当于这个g栈是一个快照状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;混合写屏障的栈，要么全黑，要么全白（单个栈）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个暂停g这个是怎么做到的？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;扫描的时候，会设置一个 _Gscan 状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;casgstatus的时候，保证循环等待这个状态完成。之前是直接吃cpu的，后面做了一个优化，加了一个yield，5us的间隔。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;关于这段代码的改动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.39296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DOvKRyxEOkc0JLVLU9v2sp4bJyXcia4nkxbJmB8H1taXYdSZ0ibYhmFwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题二：如果是多个栈呢，那么就不是原子的快照了。比如下图？那么就可能导致这种情况。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8549528301886793&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DLQ3JtedhgaOYWEnicYmxlvFQ4k79eXIJVl1z4icMicGN5icx2YcN28aGPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;848&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说A和前面的黑色对象不属于同一个g栈。那么是否可能会导致这种场景出现？分析下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个场景是有这么一个白色对象，先只被G2栈根引用到。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前G1已经被扫描完，G2还没有扫描。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把这个白色对象赋值给G1栈的黑色对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个时候把G2对白色对象的引用删掉，这样岂不是会出现黑色白色对象，且为唯一指针？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是：这里的关键在于第三步。G1的栈对象接受赋值，这个并不是凭空来的。那么一定是G1自己找来的，可达的对象。这个是一个前提。所以，如果能接受这样的赋值，那么这个白色对象一定是处于G1栈的灰色保护下，因为G1一定是可访问这个对象的。否则，根本就不能完成这个赋值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合写屏障的场景，白色对象处于灰色保护下，但是只由堆上的灰色对象保护。注意理解这点；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;屏障生成示例：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4738562091503268&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4Dcziamq5dlDp6dHsPIkOjDJ0Dh0kSGsQl5QCOmSdu1D4tB2icgZfqUicIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;918&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;写堆上内容，才会在编译期间生成写屏障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;栈上的写，不会有写屏障。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;runtime.gcWriteBarrier :&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5614457831325301&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DqC3Km4voNU8PgnVaDYvicLfrKgGzpiavSBrp9HNZSPMw7icAic9DRsq5ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算出wbBuf的next位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;record ptr&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ptr指针放到wbBuf队列中。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;把 &lt;code&gt;*(slot)&lt;/code&gt; 存到wbBuf队列中 ( 置灰色，flush了就是灰色 )&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;shade( *slot )&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;如果队列没有满&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;那么就赋值写（&lt;code&gt;*(slot) = ptr&lt;/code&gt;）; 则返回&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;如果队列满了，那么跳到flush&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;wbBufFlush就是把wbBufFlush里的元属flush到灰色队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用完了 runtime.wbBufFlush 处理之后，返回赋值ret（&lt;code&gt;*(slot) = ptr&lt;/code&gt;）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么看起来，就不存在 判断stack是否为灰色的条件？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.4 其他屏障&lt;span/&gt;&lt;/h4&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer(slot, ptr):&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade(*slot)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade(ptr)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这种无条件的屏障更加容易理解，直接把目标和源都置灰色保护&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;heap上没有黑色到白色的指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;唯一有可能出现黑色到白色的引用 只可能出现在 被扫描了的stack&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一旦 stack 被扫描过了，只有一种办法能得到白色对象指针（white pointer）：通过transfer一个可达（reachable）对象&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;删除屏障和混合写屏障，保护了&lt;code&gt;shade(*slot)&lt;/code&gt;这个指针，就保护了一条路径：这个来路一定是灰色的，下游的白色都会收到保护。并且，我们知道，栈上得到的白色指针一定是可达的，那么一定是有堆上灰色对象保护的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;任何一个白色对象（被黑色栈对象指向的）一定是被堆上灰色对象保护可达的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种屏障会导致比较多的屏障，两倍。所以针对这个考虑权衡，会加一个stack条件判断，就是我们看到的混合屏障的样子。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.9 内存可见性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提一下golang的内存可见性。在c里面，如果是在多线程环境，并发操作一些变量，需要考虑一些可见性的问题。比如赋值一个变量，这个线程还有可能在寄存器里没有刷下去，或者编译器帮你优化到寄存器中，不去内存读。所以有一个volatile关键字，强制去内存读。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang是否有这个内存可见性的问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话，golang里面，只要你保证顺序性，那么内存一致性就没有问题。具体可以搜索happen-before的机制。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.10 注意问题&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.10.1 千万不要尝试绕过golang的类型系统&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;千万不要尝试绕过golang的类型系统。golang官方在提到uintptr类型的时候，都说不要产生uintptr的临时变量，因为很有可能会导致gc的错误回收（这个做过一个简单的验证，1.13本的uintptr类型是不作为指针标记的）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一个极端的例子，如果你new了一个对象，然后把这个对象的地址保存在8个不连续的byte类型里，那就等着coredump吧。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.10.2 在golang里按照c的思路实现一个内存池很容易踩到巨坑。&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如现在你分配一个大内存出来（1G的[ ]byte类型空间）。这是一个大内存块。并且golang没有任何标识这个地方标识指针。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;golang&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 分配一个大内存数组（1GB），数组元素是byte。那么自然每个元素都是不含指针的。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;begin := make([]byte, 1024*1024*1024)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.14094650205761317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DTv0cf8PLNFgtWxhvpiaEY2voibYpX6iaA4r9ibwNibL5A0qtygnhjqO5oGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么扫描是不会扫描这个内部的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存池分配器接口：&lt;code&gt;func (ac *Allocator) Alloc (size int) unsafe.Pointer&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来分配对象，使用可能会导致莫名其妙的内存错误。假设用来分配对象T：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;golang&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type T struct {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    s *S&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;t := (*T) (ac.Alloc(sizeT))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;t.s = &amp;amp;S{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;T对象是从一个大数组里划出来的，垃圾回收其实并不知道T这个对象。不过只要1G内存池本身不被回收，T对象还是安全的。但是T里面的S，是golang走类型系统分配出来的，就会有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设发生垃圾回收了，GC会认为这个内存空间是一个Byte数组，而不会扫描，那么t.s指向的对象认为未被任何对象引用到，它会被清理掉。最后t.s就成了一个悬挂指针。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;golang里面实现内存分配器，适用处理两种情况：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一种是用于分配对象里面不包含其他引用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另一种，包含的引用对象也在这个分配器里&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，没必要自己搞通用内存池。一旦绕过了golang的类型系统，就会出现坑。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>308f5ac1bf4aab7e0ce0b46755339e3f</guid>
<title>[推荐] 架构师图谱（上篇）</title>
<link>https://toutiao.io/k/xha1t37</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot;&gt;
&lt;h1&gt;1. 概述&lt;/h1&gt;
&lt;p&gt;“架构师图谱”是一个很宏大的命题，特别是优秀的架构师自身也是“由点到面再到图”，一点点成长积累起来，尝试写这篇文章的目的更多的是结合自身的一些架构、研发、管理经验对现阶段做一个复盘总结，所以这里更偏向于后端图谱，依赖于开源技术、云原生或者其他第三方服务。 这里会重点介绍一些技术栈、设计理念以及适应场景，这些可以作为我们选型时的依据。所谓“架构即决策”，是在一个有约束的盒子中寻求最优解。这个有约束的盒子是团队经验、成本、资源、进度、业务所处阶段等编织、掺杂在一起的综合体。本质上无优劣，但是存在恰当的架构用在合适的软件系统中，而这些就是决策的结果。&lt;/p&gt;
&lt;h2&gt;1.1 序章&lt;/h2&gt;
&lt;p&gt;一个技术图谱：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://yueqian-wordpress.stor.sinaapp.com/uploads/2021/05/uTools_1621160730437.png&quot;&gt;&lt;img src=&quot;http://yueqian-wordpress.stor.sinaapp.com/uploads/2021/05/uTools_1621160730437.png&quot; alt=&quot;&quot; class=&quot;alignnone size-full wp-image-235&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;计划会分上、中、下三个篇章来介绍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上篇：重点聚焦在微服务和常用的消息队列，包括相关的选型以及一些理论基础&lt;/li&gt;
&lt;li&gt;中篇：主要集中在数据库、分布式（一致性/锁/缓存/发号/任务调度等），以及流媒体&lt;/li&gt;
&lt;li&gt;下篇：分享一些Devops、项目管理、团队建设方向的一些经验&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;完整的思维导图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://yueqian-wordpress.stor.sinaapp.com/uploads/2021/05/ArchitectMap.png&quot;&gt;&lt;img src=&quot;http://yueqian-wordpress.stor.sinaapp.com/uploads/2021/05/ArchitectMap.png&quot; alt=&quot;&quot; class=&quot;alignnone size-full wp-image-232&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;2. 微服务&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;微服务&lt;/strong&gt;（英语：Microservices）是一种&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84&quot;&gt;软件架构风格&lt;/a&gt;，它是以专注于单一责任与功能的小型功能区块 (Small Building Blocks) 为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关 (Language-Independent/Language agnostic）的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3&quot;&gt;API&lt;/a&gt;集相互通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;微服务架构有别于更为传统的单体服务，可将应用拆分成多个核心功能。每个功能都被称为一项服务，可以单独构建和部署。这也体现了可扩展的基本思想：将原本大一统的系统拆成多个小部分，扩展时只修改其中一部分，通过这种方式减少改动范围，降低改动风险。 微服务架构涵盖了服务的多个方面，包括网关、通信协议、服务注册/发现、可观察性、如何合理的划分等等。&lt;/p&gt;
&lt;h2&gt;2.1 理论基础&lt;/h2&gt;
&lt;p&gt;微服务的理论基础主要用来指导微服务架构设计、服务拆分，确定合适的服务粒度和边界。在做微服务之前我们首先要想明白我们现有系统面临什么样的问题，为什么需要微服务，随后才是怎么做。微服务很多核心理念其实在半个世纪前的一篇文章中就被阐述过了，而且这篇文章中的很多论点在软件开发飞速发展的这半个世纪中竟然一再被验证，这就是康威定律（Conway’s Law）。在康威的这篇文章中，最有名的一句话就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations. – Melvin Conway(1967)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;中文直译大概的意思就是：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。 最初这篇文章只是描述作者自己的发现和总结，后来“人月神话”中，引用这个观点，并将其“吹捧”成现在熟知的“高位定律”，其中的一些核心观点可以概括如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组织沟通方式决定系统设计，对于复杂的系统，聊设计就离不开聊人与人的沟通，解决好人与人的沟通问题，才能有一个好的系统设计&lt;/li&gt;
&lt;li&gt;时间再多一件事情也不可能做的完美，但总有时间做完一件事情，这与架构设计的“简单、合适、演化”思维不谋而合&lt;/li&gt;
&lt;li&gt;线型系统和线型组织架构间有潜在的异质同态特征，更直白的说，你想要什么样的系统，就搭建什么样的团队，定义好系统的边界和接口，团队内应该是自治的，这样将沟通成本维持在系统内部，每个子系统就会更加内聚&lt;/li&gt;
&lt;li&gt;大的系统组织总是比小系统更倾向于分解，面对复杂的系统及组织，往往可以采用分而治之&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是当我们的业务和组织架构复杂度比较高的时候，很多概念只从技术角度很难去抽象，这就需要我们自上而下，建立起通用语言，让业务人员和研发人员说一样的话，把思考层次从代码细节拉到业务层面。越高层的抽象越稳定，越细节的东西越容易变化。通过对不同领域的建模，逐步确定领域范围和业务边界，这也就是领域驱动设计（DDD）。 DDD 是一种在面向高度复杂的软件系统时，关于如何去建模的方法论，它的关键点是根据系统的复杂程度建立合适的模型，DDD中的界限上下文也完美匹配了微服务的高内聚、低耦合特性，这也为我们微服务的划分提供了强有力的基础。DDD实施的一般步骤是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据需求划分出初步的领域和限界上下文，以及上下文之间的关系&lt;/li&gt;
&lt;li&gt;进一步分析每个上下文内部，识别出哪些是实体，哪些是值对象&lt;/li&gt;
&lt;li&gt;对实体、值对象进行关联和聚合，划分出聚合的范畴和聚合根&lt;/li&gt;
&lt;li&gt;为聚合根设计仓储，并思考实体或值对象的创建方式&lt;/li&gt;
&lt;li&gt;在工程中实践领域模型，并在实践中检验模型的合理性，倒推模型中不足的地方并重构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是DDD也不是银弹，特别是在一些新业务场景，本身就充满了很多的不确定性，一次性把边界划清楚并不是一件很容易的事。大家在一个进程里，调整起来会相对容易，然后让不同的界限上下文各自演化，等到了一定程度之后再考虑微服务也是一个不错的选择。&lt;/p&gt;
&lt;h2&gt;2.2 网关&lt;/h2&gt;
&lt;p&gt;作为微服务的统一入口，也肩负着整个微服务的流量接入、管理、聚合、安全等，从服务分层的角度可以划分为接入网关和业务网关。 &lt;strong&gt;接入网关&lt;/strong&gt; 接入网关提供最基础的流量接入和安全防护能力，侧重于全局，与业务无关。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;域名&amp;amp;DNS，作为服务的流量入口，对外通过域名和DNS提供服务，国内域名厂商一般都依托于共有云或被共有云厂商收购，用来完善自由的云生态，像阿里的万网，腾讯的DNSPod等，也有国外的aws，godaddy和neamcheap等，可以用作.me等国内无法托管或备案域名的管理，其次也可以借助DNS（HTTPDNS、EDNS）实现跨地域、运营商网络等负载均衡，实现异地多活、就近访问、容灾等。&lt;/li&gt;
&lt;li&gt;负载均衡（LB），主要负责请求的转发代理，按机器负载来分配流量等，对外提供VIP，这里的负载可以宽泛的理解为系统的压力，可以用 CPU 负载来衡量，也可以用连接数、I/O 使用率、网卡吞吐量等来衡量。负载均衡器按服务层级来划分，除了前边提到的DNS，还有集群级别的硬件负载均衡，以及机器级别的软件负载均衡。
&lt;ul&gt;
&lt;li&gt;DNS/硬件负载均衡(F5/A10)主要用来应对海量用户的访问，中小量用户使用无疑会增加更多的维护和采购成本。&lt;/li&gt;
&lt;li&gt;软件负载均衡可以选择自研或上云，LVS、Keepalived主要用于四层（IP+端口）的负载均衡，在四层的基础之上如果要实现应用层（域名/URL/用户会话）等的7层负载均衡，可以使用Nginx、Keepalived的组合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除此之外，网关也负责服务整体的安全防护，SSL，IPV6等。
&lt;ul&gt;
&lt;li&gt;安全防护目的是保护服务数据以及可用性，例如防范常见的DDOS/CC网络攻击，反爬虫，自定义访问控制，自研成本往往比较高，可以借助云上一系列的高防、防火墙服务。&lt;/li&gt;
&lt;li&gt;SSL（TLS）用来提供外部https访问，https可以防止数据在传输过程中不被窃取、改变，确保数据的完整性，在支付或者用户登录等敏感数据场景，可以起到一定的保护作用，同时https页面对搜索引擎也比较友好。&lt;/li&gt;
&lt;li&gt;IPV6，全球43亿IPV4地址已经在2019年年底耗尽，网信办在2018年开始就已经推行各大运营商、CDN厂商、互联网核心产品支持IPV6，我们公司之前也是试点之一。IPV6的支持只需要增加一条“AAAA”DNS记录，将域名解析到自持IPV6的IP/VIP即可。IPV4到IPV6由于存在兼容性等问题，一定是长期共存的，过渡方案可以采用IPV6代理（IPV6代理转发到IPV4服务）或者双栈（同时支持IPV6和IPV4）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;业务网关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://yueqian-wordpress.stor.sinaapp.com/uploads/2021/05/企业微信截图_290de30d-bf31-4921-978c-2bd8b8f56be9.png&quot;&gt;&lt;img src=&quot;http://yueqian-wordpress.stor.sinaapp.com/uploads/2021/05/企业微信截图_290de30d-bf31-4921-978c-2bd8b8f56be9.png&quot; alt=&quot;&quot; class=&quot;alignnone size-full wp-image-231&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;业务网关作为业务的最上层出口，一般承担起业务接入或者BFF的工作，例如基础的路由、鉴权、限流、熔断降级、服务聚合、插件化能力，并可以通过可视化界面管理网关配置。可选框架有基于openrestry的kong、apisix以及其他语言相关的spring cloud gateway、grpc-gateway等等，国内开源的goku、kratos、go-zero go框架，有很多比较有意思的组件实现，我们日常业务上也可以借鉴。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鉴权，鉴权的目的是为了验证用户、请求等的有效性，例如用户身份鉴权（jwt/oauth2/cookie），请求鉴权（请求签名、请求加密），鉴权逻辑也花样繁多，大多需要基于业务定制化，通过网关插件能很好的集成进来。&lt;/li&gt;
&lt;li&gt;限流，限流是为了做一定的流量控制，防止对系统产生过大压力从而影响整个服务。可以基于单台机器或整个集群限流，常见的方式有限制总量和限制速率，超过的则排队或丢弃，例如令牌桶（弹性）/漏桶（匀速）算法。&lt;/li&gt;
&lt;li&gt;熔断降级，熔断作为服务断路器，当下游的服务因为某种原因突然变得不可用或响应过慢（这里既可以指单次请求也可以指一段时间），上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回，这样也能对整体链路起到保护作用。如果目标服务情况好转则恢复调用，同时结合降级策略提升服务的鲁棒性。常见的有hystrix/resilience4J（hystrix虽然已停止更新，但现有功能已经能满足大多业务场景）。&lt;/li&gt;
&lt;li&gt;重试，大量网络IO，避免不了会出现因网络抖动，出现连接失败或者超时，重试可以提高请求的最终成功率，削平服务毛刺。但重试也有可能放大故障，所以可以结合退避策略（backoff）、限制单点重试、限制链路重试这些策略进行优雅的重试，同时也可以采用更加激进的“对冲请求”提前（tp99时间未响应时）发起重试请求，降低系统时延。&lt;/li&gt;
&lt;li&gt;插件化，各个网关集成插件的方式尽不相同，但是目的都是为了集成技术人员编写的一些业务相关的通用能力，例如前边提到的身份鉴权、请求鉴权等等。另外作为业务网关插件，也可以编写一些基础业务（API鉴权、请求格式化）逻辑，直接透传请求到服务层，省去很多BFF和上下游对接的工作。&lt;/li&gt;
&lt;li&gt;BFF，Backend For Frontend，可以按照业务逻辑，以串行、并行和分支等结构编排多个服务API，为服务提供聚合、适配、裁剪（只返回需要的字段）功能，核心是API的动态编排以满足日益增长的业务逻辑，降低前端与微服务之间的对接成本。BFF并不意味着只能由后端实现，也可以在前端通过GraphQL等API查询语言实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.3 协议&lt;/h2&gt;
&lt;p&gt;服务间的通信方式是在采用微服务架构时需要做出一个最基本的决策，统一的协议标准也能大大降低服务的联调和维护成本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP REST，REST更确切的讲是指的API设计风格，而不是协议标准。通常基于使用HTTP，URL，和JSON这些现有的广泛流行的协议和标准。符合REST设计风格的API称作RESTful API。在实际应用中大多实现的是伪REST API，例如用POST请求同时实现资源的增删改，或者为了请求的扩展性，资源的增删改查都使用POST JSON。&lt;/li&gt;
&lt;li&gt;RPC，RPC协议描绘了客户端与服务端之间的点对点调用流程，包括stub、通信、RPC消息协议部分。可以基于tcp，也可以基于http。在实际应用中，还需要考虑服务的高可用、负载均衡等问题，所以产品级的 RPC 框架除了点对点的 RPC 协议的具体实现外，还应包括服务的发现与注册、提供服务的多台 Server 的负载均衡、服务的高可用等更多的功能。目前的 RPC 框架大致有两种不同的侧重方向，一种偏重于服务治理（Dubbo、Motan），另一种偏重于跨语言调用（Thrift/GRPC）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RPC vs HTTP REST优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更清晰的API定义，例如grpc协议的定义文件proto，自身就可以作为很好的API文档，日常开发中也可以把proto文件独立版本库管理，精简目录结构，方便不同的服务引用。&lt;/li&gt;
&lt;li&gt;更好的传输效率，通过序列化和反序列化进一步压缩网络传输数据，不过序列化、反序列化也会有一定的性能损耗，protobuf可以说很好的兼顾了这两点。&lt;/li&gt;
&lt;li&gt;更合适的容错机制，可以基于实际的业务场景，实现更合适的超时控制与异常重试机制，以应对网络抖动等对服务造成的影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一些特定场景，例如：OpenApi、BFF等，HTTP REST可以更大程度上降低外部团队的接入成本。并且RPC也有调试不便、多语言互通需要对应的SDK支持这些问题，各有利弊。综合考虑来看，除了一些特定场景，如果我们已经有相对完善的基础设施支撑（RPC框架、服务治理），RPC可以为一个更合适的选择。&lt;/p&gt;
&lt;h2&gt;2.4 服务注册/发现&lt;/h2&gt;
&lt;p&gt;服务注册主要是通过将微服务的后端机器IP、端口、地域等信息注册起来，并结合一定的发现机制使客户端的请求能够直连具体的后端机器。从实现方式上可以分为服务端模式与客户端模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端模式，也可以说是传统模式，通过借助负载均衡器和DNS实现，负载均衡器负责健康检查、负载均衡策略，DNS负责实现访问域名到负载均衡器IP/VIP的映射。通过直接暴露域名和端口的方式提供客户端访问。&lt;/li&gt;
&lt;li&gt;客户端模式，可以借助注册中心实现，注册中心负责服务的注册与健康检查，客户端通过监听配置变更的方式及时把配置中心维护的配置同步到本地，通过客户端负载均衡策略直接向后端机器发起请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从两种模式的实现方式上可以看出&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端模式注册与发现都由服务端完成，这样可以使客户端专注在自身的业务实现，但是由于依赖负载均衡器，也就是集中式的proxy，proxy需要维护双向连接，也很容易使自己成为系统瓶颈，可用性的高低直接决定了服务质量，并且DNS缓存机制也会导致故障发生时，迁移并不能及时完成。当然在服务量少，且负载均衡器有VIP的情况下，我们也可以不使用DNS。&lt;/li&gt;
&lt;li&gt;客户端模式注册与发现由配置中心和客户端共同完成，通过分布式的方式，可以避免出现proxy节点性能瓶颈问题，但是可靠性与性能瓶颈很容器出现在配置中心上，并且客户端的也需要一定的接入成本。好在开源的已经有很成熟的架构方案与丰富的客户端SDK，例如etcd/zookeeper/consul，consul提供开箱即用的功能，etcd社区和接入易用性方面更优一些，他们之间的一些具体区别：&lt;br/&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Feature&lt;/th&gt;
&lt;th&gt;etcd&lt;/th&gt;
&lt;th&gt;zookeeper&lt;/th&gt;
&lt;th&gt;consul&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;服务健康检查&lt;/td&gt;
&lt;td&gt;连接心跳&lt;/td&gt;
&lt;td&gt;连接心跳&lt;/td&gt;
&lt;td&gt;心跳、内存、硬盘等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;一致性&lt;/td&gt;
&lt;td&gt;raft&lt;/td&gt;
&lt;td&gt;paxos&lt;/td&gt;
&lt;td&gt;raft&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;接口&lt;/td&gt;
&lt;td&gt;http/grpc&lt;/td&gt;
&lt;td&gt;客户端sdk&lt;/td&gt;
&lt;td&gt;http/dns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;metrics&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;安全&lt;/td&gt;
&lt;td&gt;https&lt;/td&gt;
&lt;td&gt;acl&lt;/td&gt;
&lt;td&gt;acl/https&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kv存储&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.5 配置中心&lt;/h2&gt;
&lt;p&gt;配置中心从使用场景来讲，一类是前边讲到的服务注册、发现和KV存储，例如etcd/zk/consul，在k8s场景下也可以通过configmap/secret将配置写入本地文件、环境变量或者共享的volume中，这样没有了中心服务的依赖和客户端的接入，可以实现一些老旧服务的无侵入式改造。但是作为配置中心，除了基础的配置数据，一些情况下还要开放给非开发人员（测试、运维、产品）使用，完善的控制台、权限管理、dashbord的支持，也非常重要，这类可以参考nacos（阿里开源）/apollo（携程开源）。nacos在读写性能上优于apollo，但是功能特性（例如权限管理）稍逊于apollo。&lt;/p&gt;
&lt;h2&gt;2.6 可观察性&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在控制论中，可观察性是用系统输出到外部的信息来推断系统内部运运行状态的一种度量方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在云原生时代，容器和服务的生命周期是紧密联系在一起的，相较在传统的单体服务运行在物理主机或者虚拟机当中，排查问题的时候显得非常不便，这种复杂性导致了一个定义研发运营效率的MTTR（平均故障修复时间）指标急剧增加。所以这里更强调的是微服务的可观察性，需要提前想好我们要如何观察容器内的服务以及服务之间的拓扑信息、各式指标的搜集等，这些监测能力相当重要。 可观察性三大支柱围绕Tracing（链路追踪）、Logging（日志）和Metrics（度量）展开，这三个维度几乎涵盖了应用程序的各种表征行为，开发人员通过收集并查看这三个维度的数据时刻掌握应用程序的运行情况。很长一段时间，这三者是独立存在的，随着时间的推移，这三者已经相互关联，相辅相成。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://yueqian-wordpress.stor.sinaapp.com/uploads/2021/05/observability.jpg&quot;&gt;&lt;img src=&quot;http://yueqian-wordpress.stor.sinaapp.com/uploads/2021/05/observability.jpg&quot; alt=&quot;&quot; class=&quot;alignnone size-full wp-image-233&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2.6.1 链路追踪&lt;/h3&gt;
&lt;p&gt;链路追踪为分布式应用的开发者提供了完整的调用链路还原、调用请求量统计、链路拓扑、应用依赖分析等工具，可以帮助开发者快速分析和诊断分布式应用架构下的性能瓶颈，提高微服务时代下的开发诊断效率以及系统的可观察性。 为了解决不同的分布式系统API不兼容的问题，诞生了OpenTracing规范，OpenTracing中的Trace可以被认为是由多个Spacn组成的DAG图。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Span A]  ←←←(the root span)
            |
     +------+------+
     |             |
 [Span B]      [Span C] ←←←(Span C 是 Span A 的孩子节点, ChildOf)
     |             |
 [Span D]      +---+-------+
               |           |
           [Span E]    [Span F] &amp;gt;&amp;gt;&amp;gt; [Span G] &amp;gt;&amp;gt;&amp;gt; [Span H]
                                       ↑
                                       ↑
                                       ↑
                         (Span G 在 Span F 后被调用, FollowsFrom)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OpenTracing专注在tracing，除此之外还有包含了metrics的OpenCensus标准，以及由CNCF推出，融合OpenTracing和OpenCensus的OpenTelemetry。OpenTelemetry旨在实现云原生时代可观察性指标（Tracing、Logging、Metrics）的统一收集和处理，同时提供推动这些标准实施的组件和工具。 OpenTracing中的佼佼者当属Jaeger、Zipkin、Skywalking。他们之间的一些对比：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Feature&lt;/th&gt;
&lt;th&gt;Jaeger&lt;/th&gt;
&lt;th&gt;Zipkin&lt;/th&gt;
&lt;th&gt;Skywalking&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;OpenTracing兼容&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;社区&lt;/td&gt;
&lt;td&gt;社区生态好，文档丰富&lt;/td&gt;
&lt;td&gt;社区生态好，文档丰富&lt;/td&gt;
&lt;td&gt;时间不长，仅限中文社区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;存储&lt;/td&gt;
&lt;td&gt;In-Memory/Cassandra/ES&lt;/td&gt;
&lt;td&gt;In-Memory/Cassandra/Mysql/ES&lt;/td&gt;
&lt;td&gt;Mysql/ES/H2/TiDB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传输协议&lt;/td&gt;
&lt;td&gt;UDP/HTTP&lt;/td&gt;
&lt;td&gt;HTTP/Kafka/Scribe/AMQP&lt;/td&gt;
&lt;td&gt;gRPC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;APM监控&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;侵入性&lt;/td&gt;
&lt;td&gt;侵入&lt;/td&gt;
&lt;td&gt;侵入&lt;/td&gt;
&lt;td&gt;无侵入（部分语言）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;采样策略&lt;/td&gt;
&lt;td&gt;全量/概率/限速/动态限速&lt;/td&gt;
&lt;td&gt;全量/概率/限速/计数&lt;/td&gt;
&lt;td&gt;全量/概率&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Zipkin开源时间长，社区相对丰富，Jaeger更加轻量，也是Istio推荐方案，Skywalking支持部分语言（Java、PHP、Python等）的无侵入式接入。另外APM（应用性能）监控的支持也会影响到我们的选型。 除此之外，面对线上海量请求，如果采用抽样采样策略，那就需要支持一定的流量染色，把我们核心关注的请求（例如链路中发生了错误、部分请求耗时过高等）都进行采样，可以通过结合opentelemetry-collector以及开箱即用的&lt;a href=&quot;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/tailsamplingprocessor&quot;&gt;tailsamplingprocessor&lt;/a&gt;构建pipeline插件实现。&lt;/p&gt;
&lt;h3&gt;2.6.2 日志&lt;/h3&gt;
&lt;p&gt;服务间的链路日志能否帮助我们判断错误发生的具体位置，这类业务日志主要集中在访问日志/打点日志等等。随着大数据的兴起，我们对数据的分析解读能力越来越强，日志作为原始数据则体现出了更大的价值，例如用户的行为分析，反垃圾，舆情分析等等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务日志：这类日志重点在于通过不同级别的日志，及时发现分析系统存在的异常，RFC 5424定义的8中日志级别:
&lt;ul&gt;
&lt;li&gt;Emergency: system is unusable&lt;/li&gt;
&lt;li&gt;Alert: action must be taken immediately&lt;/li&gt;
&lt;li&gt;Critical: critical conditions&lt;/li&gt;
&lt;li&gt;Error: error conditions&lt;/li&gt;
&lt;li&gt;Warning: warning conditions&lt;/li&gt;
&lt;li&gt;Notice: normal but significant condition&lt;/li&gt;
&lt;li&gt;Informational: informational messages&lt;/li&gt;
&lt;li&gt;Debug: debug-level messages&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际使用过程中可能会对日志级别进行简化和调整，一般来讲Warning及以上的日志是需要重点关注的，需要做好及时的监控告警，Warning以下的日志也可以辅助问题的定位。 日志写入可以选择写入消息队列，也可以选择落地磁盘，将关心的结构化或非结构化日志、业务模块信息（如果是细粒度的微服务，可以选择将日志放同一模块收集），以及级别、时间（who、when、where、how、what）等要素正确的写入正确写入后再收集到日志服务。写入消息队列需要考虑消息队列的选型以及做好可用性和积压监控，写入磁盘需要考虑写入性能以及日志的切割清理，例如golang的zap+rotatelogs组合。日志收集的话，由于Logstash资源消耗相对比较大，虚拟机环境中可以使用filebeat来替代，更严苛的线上或容器环境，可以使用Fluentd/Fluentd Bit。日志最终汇总到ES和Kibana做展示，通过esalert定制告警策略。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大数据日志：大数据日志本质上也对应着我们一定的业务场景，但大多是海量日志、高吞吐量场景，所以对海量日志的收集和存储是较大的挑战。实现方案我们可以采用高吞吐量的流式中间件，例如kafka/plusar等，在结合流式处理(flink)或者批处理(spark)系统，将数据汇总到hadoop进行分析，这里涉及到的中间件和数据库可参考后续章节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.6.3 指标&lt;/h3&gt;
&lt;p&gt;指标是有关系统的离散的数据点，这些指标通常表示为计数或度量，并且通常在一段时间内进行汇总或计算，一般用来做基础的资源监控和业务监控：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源监控：CPU、内存、IO、fd、GC等&lt;/li&gt;
&lt;li&gt;业务监控：QPS、模调、耗时分布等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Zabbix作为老牌的监控系统，适合更复杂的物理机、虚拟机、数据库等更复杂的场景，同时也拥有更丰富的图形化界面，但是Prometheus作为云原生的代表作，与k8s、容器等能更好的结合，协同grafana实现可定制化的界面，另外存储基于TSDB，相比于关系型数据库也有更好的扩展性。以Prometheus为例，支持的数据类型有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Counter 只增不减的计数器，例如请求数（http_requests_total）。基于此数据模型，使用Prometheus提供的强大PromQL表达式能够拓展出更加适合开发观察的指标数据。 分钟增量请求：increase(http_requests_total[1m]) 分钟QPS：rate(http_requests_total[1m])&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Gauge 可增可减的时刻量，例如Go语言协程数（go_goroutines） 波动量：delta(go_goroutines[10m])&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Histogram 直方图，不同区间内样本的个数。例如，耗时50ms-100ms每分钟请求量，100ms-150ms每分钟请求量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Summary 概要，反应百分位值。例如，某RPC接口，95%的请求耗时低于150ms，99%的请求耗时低于200ms。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.7 Service Mesh&lt;/h2&gt;
&lt;p&gt;Service Mesh这个服务网格专注于处理服务和服务之间的通信，包括我们前边讲的服务发现、熔断降级、安全、流量控制、可观察性等能力。这些通用能力在Service Mesh出现之前，由Lib/Framework完成，这样就可以在开发层面上很容易地集成到我们的应用服务中。但是并没有办法实现跨语言编程，有什么改动后，也需要重新编译重新发布服务。理论上应该有一个专门的层来干这事，于是出现了 Sidecar，Sidecar 集群就成了 Service Mesh，加上对整个集群的管理控制面板，就成了现在的 Service Mesh 架构，可以说Service Mesh是云原生时代的必然产物。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://yueqian-wordpress.stor.sinaapp.com/uploads/2021/05/WechatIMG47.jpeg&quot;&gt;&lt;img src=&quot;http://yueqian-wordpress.stor.sinaapp.com/uploads/2021/05/WechatIMG47.jpeg&quot; alt=&quot;&quot; class=&quot;alignnone size-full wp-image-237&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前比较流行的 Service Mesh 开源软件是 Istio 和 Linkerd，还有更加轻量级的Conduit，它们都可以在 Kubernetes 中集成。Istio 基于 Golang 编写，使用Envoy作为Sidecar，在服务治理方面职责分明，国内落地案例相较 Linkerd 、Conduit更加广泛。 由于Service Mesh承担了服务核心的流量调度环节，再给我们带来便利的同时，也引入很多的不可控因素，例如：Sidecar组件不可用，将直接导致系统出现致命问题。所以在充分做好服务可观察性的前提下，也要保证Service Mesh的高可用，一种比较好的方式是，除了在本机有 Sidecar，我们还可以部署一下稍微集中一点的 Sidecar——比如为某个服务集群部署一个集中式的 Sidecar。一旦本机的有问题，可以走集中的。&lt;/p&gt;
&lt;h1&gt;3. 消息队列&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://yueqian-wordpress.stor.sinaapp.com/uploads/2021/05/Screen-Shot-2017-05-22-at-09.05.54.png&quot;&gt;&lt;img src=&quot;http://yueqian-wordpress.stor.sinaapp.com/uploads/2021/05/Screen-Shot-2017-05-22-at-09.05.54.png&quot; alt=&quot;&quot; class=&quot;alignnone size-full wp-image-234&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实际应用场景中，消息队列也经常作为中间件，用于异步解耦、削峰填谷、数据广播、错峰与流控、最终一致性等，在一些核心的大数据分析、交易支付等场景也经常扮演重要角色，消息队列的选型主要侧重以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HA：自身的高可用性保障，避免消息队列的引入而影响整体服务的可用性&lt;/li&gt;
&lt;li&gt;高吞吐：在面对海量数据写入能否保持一个相对稳定、高效的数据处理能力&lt;/li&gt;
&lt;li&gt;功能丰富性：是否支持延迟消息、事务消息、死信队列、优先级队列等&lt;/li&gt;
&lt;li&gt;消息广播：是否支持将消息广播给消费者组或者一组消费者&lt;/li&gt;
&lt;li&gt;消息堆积能力：在数据量过大时，是否允许一定消息堆积到broker&lt;/li&gt;
&lt;li&gt;数据持久性：数据持久化策略的采用，也决定着数据在宕机恢复后是否会丢失数据&lt;/li&gt;
&lt;li&gt;重复消费：是否支持ack机制，在消费者未正确处理消息时，支持重新消费&lt;/li&gt;
&lt;li&gt;消息顺序性：针对顺序消费的场景保证数据按写入时间的顺序性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里着重对比一下Redis、Rabbitmq/Rocketmq、Kafka、Plusar&lt;/p&gt;
&lt;h2&gt;3.1 Redis&lt;/h2&gt;
&lt;p&gt;redis实现消息队列可以通过List类型、Pub/Sub、Stream（redis 5.0）类型来实现，HA使用多副本或者集群的方式。作为消息队列使用起来非常方便，但是也有很多的弊端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能丰富性：只支持普通的消息类型&lt;/li&gt;
&lt;li&gt;数据持久性：Pub/Sub只提供缓冲区广播能力，不进行持久化，List/Stream即使基于aof和rdb持久化策略，但是并没有事务性保障，在宕机恢复后还是存在丢失数据的可能性&lt;/li&gt;
&lt;li&gt;消息堆积能力：List随长度增大，内存不断增长；Pub/Sub只在缓冲区内堆积，缓冲区满消费者强制下线；Stream创建时可以指定队列最大长度，写满后剔除旧消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，List类型无法支持消息广播，和Pub/Sub一样也不支持重复消费。结合整体来看redis作为消息队列大多数只应用在数据量小，对丢失数据不敏感的业务场景，适用范围较小，复杂业务并且有一定运维支撑的情况下，可以直接考虑企业级消息中间件。&lt;/p&gt;
&lt;h2&gt;3.2 Rabbitmq vs Kafka vs Rocketmq&lt;/h2&gt;
&lt;p&gt;这几个可以作为企业级消息中间件的代表，Rabbitmq和kafka的一些详细对比，可以参考之前写的这篇文章《&lt;a href=&quot;https://blog.xstudio.mobi/a/60.html&quot;&gt;消息队列Rabbitmq与Kafka对比分析&lt;/a&gt;》。而Rocketmq在设计之初就借鉴了很多Rabbitmq、Kafka的设计理念，例如：Routing、多副本、顺序写（IO），也广泛应用在淘宝双十一等场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HA&lt;/strong&gt;&lt;br/&gt;
在HA方面他们都是通过副本的方式，区别是Rabbitmq是集群级别的副本，Kafka是多partiton和ISR、选举机制，而Rocketmq通过多（master/slave）副本同时保障NameServer和Broker。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高吞吐&lt;/strong&gt;&lt;br/&gt;
Kafka和Rocketmq通过直接操作文件系统，相比于Rabbitmq，顺序写能大幅度提升数据的处理速度。Kafka为了进一步提升消息的吞吐量，可以采用客户端缓冲队列的方式批量发送，但也会存在宕机丢失数据的可能性，可以通过设置 batch.size 与 linger.ms 来动态调整，相比于Rocketmq更加灵活。Kafka的partition机制的确会带来性能的提升，但是在Topic不断增多的情况下，众多的partition及副本也将顺序写逐步退化为随机写，并且扩容时，由于hash值的变化，也会涉及到大量partiton数据的迁移。Rocketmq采用commitlog的方式实现全局写，所以能支持更多的Topic，扩容也不涉及大量数据的迁移。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能丰富性&lt;/strong&gt;&lt;br/&gt;
Kafka只有基础的消息类型，Rabbitmq支持优先级队列，通过TTL和死信队列可以实现消息的延迟和重试，但是需要提前创建好对应重试频率的队列，例如：1s重试队列，10s重试队列，Rocketmq则内置了18个重试频率“1s 5s 10s 30s 1m 2m…”，另外也具有独有的2PL事务消息，很好的保障业务逻辑与消息发送的一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重复消费&lt;/strong&gt;&lt;br/&gt;
他们三者都采用Ack机制保障了单条消息重复消费的能力，Kafka通过offset和partition特殊的ttl机制（segment过期，按文件名顺序清理），能支持通过重置offset来回溯历史数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息顺序性&lt;/strong&gt;&lt;br/&gt;
Rabbitmq和Rocketmq可以保证写入同一topic的顺序性，但是在多个消费者同时消费的情况下还是会出现乱序的情况，在数据量较大的时候，我们也可以通过单个消费者消费，再按照一定的分发策略分配给多个消费者执行，只不过会提升整体复杂度，同时会带来更多的HA、维护成本考量。Kafka可以保障单个partition的顺序性，并且每个partiton只允许一个消费者来消费（N：1），这就从策略上避免了多消费者的情况，在数据量较大的情况下，可以通过划分更多的partition提升数据处理能力。 综合来讲，Rabbitmq、Rocketmq使用Queue模型，丰富的消息队列功能，更多的应用在业务场景，Kafka基于Streaming模型，结合批处理、流式处理，更多的应用在大数据分析场景。&lt;/p&gt;
&lt;h2&gt;3.3 Pulsar&lt;/h2&gt;
&lt;p&gt;Pulsar作为Apache开源、云原生的消息中间件，诞生之初就引发了很大的关注。设计上避免了kafka遇到的功能丰富性、扩容等方面的问题，采用计算、存储分离的架构，broker层只作为“API接口层”，存储交给更专业的bookeeper，由于broker层的无状态性，结合k8s等非常方便的进行扩容。并且Pulsar支持多个消费模型提升消费者处理能力，例如：exclusive、failover、shared、key-shared等，可以说综合了kafka和其他消息中间件的众多优点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://yueqian-wordpress.stor.sinaapp.com/uploads/2021/05/WechatIMG45.jpeg&quot;&gt;&lt;img src=&quot;http://yueqian-wordpress.stor.sinaapp.com/uploads/2021/05/WechatIMG45.jpeg&quot; alt=&quot;&quot; class=&quot;alignnone size-full wp-image-236&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HA、高吞吐：和kafka类似，通过多partition和选举机制功，除此之外，还支持丰富的跨地域复制能力&lt;/li&gt;
&lt;li&gt;功能丰富性：可以支持秒级的延迟消息，以及独特的重试队列和私信队列&lt;/li&gt;
&lt;li&gt;消息顺序性：为了实现partition消息的顺序性，和kafka一样，都需要将消息写入到同一broker，区别是kafka会同时存储消息在该broker，broker和partiton绑定在一起，而pulsar可以将消息分块（segment）后，更加均匀的分散到bookeeper节点上，broker只需要记录映射关系即可，这样在资源扩容时，可以更加快速便捷&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;像能量守恒定律一样，系统的复杂度往往也是守恒的，实现即高性能又高可用的消息中间件需要的技术复杂性，不会凭空消失，只会从一个地方转移到另一个地方，消息队列本质上可以理解为feature+fs，只不过存储、计算分离架构，将各层间的职责分离，使每一层都能专注在自身领域，以应对海量数据和更加复杂多变的环境，这也是现在新技术发展的一个趋势。 作为后起之秀，的确可以站在巨人的肩膀上，避免很多设计上的不足，同时引入一些新的架构理念，但是要成功的在其中分一杯羹，同样也要面临用户学习成本高、缺少杀手级应用、如何迁移等等这些现实性的问题，不过依靠良好的社区和技术先驱，随着时间的变迁，这些短板也会逐步补齐，真正适应当前时代的技术一定会脱颖而出。ps：腾讯云最近开源&lt;a href=&quot;https://github.com/streamnative/rop&quot;&gt;Rop&lt;/a&gt;，支持Rocketmq相对平滑的迁移至Pulsar。&lt;/p&gt;
&lt;h1&gt;4.推荐阅读&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Github Gateway &lt;a href=&quot;https://github.com/search?o=desc&amp;amp;p=2&amp;amp;q=gateway&amp;amp;s=stars&amp;amp;type=Repositories&quot;&gt;https://github.com/search?o=desc&amp;amp;p=2&amp;amp;q=gateway&amp;amp;s=stars&amp;amp;type=Repositories&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Rest vs RPC &lt;a href=&quot;https://cloud.google.com/blog/products/application-development/rest-vs-rpc-what-problems-are-you-trying-to-solve-with-your-apis&quot;&gt;https://cloud.google.com/blog/products/application-development/rest-vs-rpc-what-problems-are-you-trying-to-solve-with-your-apis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;IPV6 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/35509560&quot;&gt;https://zhuanlan.zhihu.com/p/35509560&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;k8s secret &amp;amp; configmap &lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/configuration/&quot;&gt;https://kubernetes.io/zh/docs/concepts/configuration/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;OPENTRACING-SPECIFICATION &lt;a href=&quot;https://opentracing-contrib.github.io/opentracing-specification-zh/specification.html&quot;&gt;https://opentracing-contrib.github.io/opentracing-specification-zh/specification.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;可观察性和微服务 &lt;a href=&quot;https://www.infoq.cn/article/2018/06/observability-microservices&quot;&gt;https://www.infoq.cn/article/2018/06/observability-microservices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RFC 5424 &lt;a href=&quot;https://tools.ietf.org/html/rfc5424&quot;&gt;https://tools.ietf.org/html/rfc5424&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;分布式文件系统架构对比 &lt;a href=&quot;https://www.infoq.cn/article/bp7uvbnb7dbgdk2gtxl9&quot;&gt;https://www.infoq.cn/article/bp7uvbnb7dbgdk2gtxl9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Service Mesh 中的可观察性实践 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/145524861&quot;&gt;https://zhuanlan.zhihu.com/p/145524861&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;全面解析 GraphQL，携程微服务背景下的前后端数据交互方案 &lt;a href=&quot;https://www.infoq.cn/article/xz0ws6_a5jmrj6ztpoz8&quot;&gt;https://www.infoq.cn/article/xz0ws6_a5jmrj6ztpoz8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;调用链追踪系统在伴鱼：实践篇 &lt;a href=&quot;https://tech.ipalfish.com/blog/2021/03/04/implementing-tail-based-sampling/&quot;&gt;https://tech.ipalfish.com/blog/2021/03/04/implementing-tail-based-sampling/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Conway’s Law — A Theoretical Basis for the Microservice Architecture &lt;a href=&quot;https://alibaba-cloud.medium.com/conways-law-a-theoretical-basis-for-the-microservice-architecture-c666f7fcc66a&quot;&gt;https://alibaba-cloud.medium.com/conways-law-a-theoretical-basis-for-the-microservice-architecture-c666f7fcc66a&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如何优雅地重试 &lt;a href=&quot;https://www.infoq.cn/article/5fboevkal0gvgvgeac4z&quot;&gt;https://www.infoq.cn/article/5fboevkal0gvgvgeac4z&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Pattern: Service Mesh &lt;a href=&quot;https://philcalcado.com/2017/08/03/pattern_service_mesh.html&quot;&gt;https://philcalcado.com/2017/08/03/pattern_service_mesh.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>96efc02aca32a4f4994f52572fed39a8</guid>
<title>[推荐] 听叔一句劝，消息队列的水太深，你把握不住</title>
<link>https://toutiao.io/k/obo72ks</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;这是Jam的第 &lt;/span&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;156 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;篇原创分享&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.05&quot; data-type=&quot;png&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6rXsLrncBqzrqzaZMY3L9QQQLr2beXVha4MicumtStMbcghJUPIVwPlHALTGTkkmpGicPYQbQObXGWIZr9NvjAtw/640?wx_fmt=png&quot;/&gt;   很多人在做架构设计时往往会“过度设计”,简单问题复杂化，上来就引一堆中间件，我想大概原因主要有下面两点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;为了秀（学）技术而架构&lt;br/&gt;我们常说技术是为业务服务的，不能为了技术而技术，为了秀技术引入一堆复杂架构这是要不得的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;考虑问题不全面，或者说广度不够，不知道如何简单化&lt;br/&gt;举个栗子，假设有一个高并发的用户平台需要处理注册（写）及登录查询（读）功能，在数据库层做了主从同步。&lt;br/&gt;&lt;br/&gt;有人为了解决主从同步延时问题引入了一个Redis，想实现写主库的时候同时写Redis，然后读的时候直接读Redis，用以避免了主从延时同步问题，这就是典型的考虑问题不全面，这虽然可以解决主从延时问题，但是又会导致双写一致性事务问题的产生，那不如直接把主从同步的方式改成强同步复制直接从数据库层面保证了一致性。&lt;br/&gt;&lt;br/&gt;那你可能会说改成强同步复制不是会增加响应时间进而影响系统吞吐量吗，那咱还可以对用户做个分库，多做几个主从同步出来不就可以了吗？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;诶诶诶，跑题了，今天咱不是说消息队列吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哦，言归正传。今天我们说说消息队列的问题，希望看完本文大家在引入消息队列的时候先想一想，是不是一定要引入？引入消息队列后产生的问题能不能解决？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列的作用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务开发中我们经常会引入消息中间件实现业务解耦，执行异步操作， 现在让我们来看看使用消息中间件的好处和弊端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先需要肯定是使用消息组件有很多好处，其中最核心的三个是：解耦、异步、削峰。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;解耦&lt;/strong&gt;：客户端只要讲请求发送给特定的通道即可，不需要感知接收请求实例的情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;异步&lt;/strong&gt;：将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;削峰&lt;/strong&gt;：消息中间件在消息被消费之前一直缓存消息，消息处理端可以按照自己处理的并发量从消息队列中慢慢处理消息，不会一瞬间压垮业务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然消息中间件并不是银弹，引入消息机制后也会有如下一些弊端：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;潜在的性能瓶颈&lt;/strong&gt;：消息代理可能会存在性能瓶颈。幸运的是目前主流的消息中间件都支持高度的横向扩展。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;潜在的单点故障&lt;/strong&gt;：消息代理的高可用性至关重要，否则系统整体的可靠性将受到影响，幸运的是大多数消息中间件都是高可用的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;额外的操作复杂性&lt;/strong&gt;：消息系统是一个必须独立安装、配置和运维的系统组件，增加了运维的复杂度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些弊端我们借助消息中间件本身提供的扩展、高可用能力可以解决，但是要真正用好消息中间件我们还需要关注可能会遇到的一些设计难题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列的设计难题&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;处理并发和顺序消息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在生产环境中为了提高消息处理的能力以及应用程序的吞吐量，一般会将消费者部署多个实例节点。那么带来的挑战就是 &lt;strong&gt;如何确保每个消息只被处理一次，并且是按照他们的发送顺序来处理的。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：假设有3个相同的接收方实例从同一个点对点通道读取消息，发送方按顺序发布了 &lt;code&gt;Order Created&lt;/code&gt;、&lt;code&gt;Order Updated&lt;/code&gt; 和 &lt;code&gt;Order Cancelled&lt;/code&gt; 这3个事件消息。简单的消息实现可能就会同事讲每个消息给不同的接收方。若由于网络问题导致延迟，消息可能没有按照他们发出时的顺序被处理，这将导致奇怪的行为，服务实例可能在另一个服务器处理 &lt;code&gt;Order Created&lt;/code&gt; 消息之前处理 &lt;code&gt;Order Cancelled&lt;/code&gt;消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 使用的解决方案是使用分片（分区）通道。整体解决方案分为三个部分：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个主题通道由多个分片组成，每个分片的行为类似一个通道。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送方在消息头部指定分片键如orderId，Kafka使用分片键将消息分配给特定的分片。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将接收方的多个实例组合在一起，并将他们视为相同的逻辑接收方（消费者组）。kafka将每个分片分配给单个接收器，它在接收方启动和关闭时重新分配分片。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iayMvgxttQ19lYM82uMqboNc828uf261U6CXqoUVMlQt1Oxz0HcIltRvHl6shqR3yCsncgOw1ica4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;如上图所示，每个Order事件消息都将orderId作为其分片键。特定订单的每个事件都发布到同一个分片。而且该分片中的消息始终由同一个接收方实例读取，因此这样就能够保证按顺序处理这些消息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;处理重复消息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入消息架构必须要解决的另一个挑战是处理重复消息。在理想情况下，消息代理应该只传递一次消息，但保证消息有且仅有一次的消息传递的成本通常很高。相反，很多消息组件承诺至少保证成功传递一次消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在正常情况下，消息组件只会传递一次消息。但是当客户端、网络或消息组件故障可能导致消息被多次传递。假设客户端在处理消息后发送确认消息前，他的数据库崩溃了，这时消息组件将再次发送未确认的消息，在数据库重新启动时向该客户端发送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;处理重复消息有以下两种不同的方法：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;编写幂等消息处理器&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果应用程序处理消息的逻辑是满足幂等的，那么重复消息就是无害的。程序的幂等性是指，即使这个应用被相同输入参数多次重复调用时，也不会产生额外的效果。例如：取消一个已经取消的订单，就是一个幂等性操作。同样，创建一个已经存在的订单操作也必是这样。满足幂等的消息处理程序可以被放心的执行多次，只要消息组件在传递消息时保持相同的消息顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是不幸的是，应用程序通常不是幂等的。或者你现在正在使用的消息组件在重新传递消息时不会保留排序。重复或无序消息可能会导致错误。在这种情况下，你需要编写跟踪消息并丢弃重复消息的消息处理程序。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;跟踪消息并丢弃重复消息&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑一个授权消费者信用卡的消息处理程序。它必须为每个订单仅执行一次信用卡授权操作。这段应用程序每次调用时都会产生不同的效果。如果重复消息导致消息处理程序多次执行该逻辑，则应用程序的行为将不正确。执行此类应用程序逻辑的消息处理程序必须通过检测和丢弃重复消息而让它成为幂等的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个简单的解决方案是消息接收方使用 message id 跟踪他已处理的消息并丢弃任何重复项。例如，在数据库表中存储它消费的每条消息的 message id。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4696969696969697&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iayMvgxttQ19lYM82uMqboNpJox7MnVRhzCk2DicL2Ak5ljIp4GCtESv4PTHqzGjm91xF152sFn29Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;792&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;当接收方处理消息时，它将消息的 message id 作为创建和变更业务实体的事务的一部分记录在数据表里。如上图所示，接收方将包含message id 的行插入 PROCESSED_MESSAGE表。如果消息是重复的，则INSERT将失败，接收方可以选择丢弃该消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个解决方案是消息处理程序在应用程序表，而不是专门表中记录 message id。当时用具有受限事务模型的NoSQL数据库时，此方法特别有用，因为 NoSQL数据库通常不支持将针对两个表的更新作为数据库事务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;处理事务性消息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务通常需要在更新数据库的事务中发布消息，数据库更新和消息发送都必须在事务中进行，否则服务可能会更新数据库然后在发送消息之前崩溃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务不以原子方式执行者两个操作，则类似的故障可能使系统处于不一致状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们看一下常用的保证事务消息的两种解决方案，最后再看看现代消息组件RocketMQ的事务性消息解决方案。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;使用数据库表作为消息队列&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的应用程序正在使用关系型数据库，要保证数据的更新和消息发送之间的事务可以直接使用 &lt;strong&gt;事务性发件箱模式，Transactional Outbox&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5447530864197531&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iayMvgxttQ19lYM82uMqboNUn8CpCOO9P5PqUp4JMuTwYPlKShzlP5BRUHcib6o4YOo0GnlaLWcLUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;648&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;此模式使用数据库表作为临时消息队列。如上图所示，发送消息的服务有个OUTBOX数据表，在进行INSERT、UPDATE、DELETE 业务操作时也会给OUTBOX数据表INSERT一条消息记录，这样可以保证原子性，因为这是基于本地的ACID事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OUTBOX表充当临时消息队列，然后我们在引入一个消息中继（MessageRelay）的服务，由他从OUTBOX表中读取数据并发布消息到消息组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息中继的实现可以很简单，只需要通过定时任务定期从OUTBOX表中拉取最新未发布的数据，获取到数据后将数据发送给消息组件，最后将完成发送的消息从OUTBOX表中删除即可。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;使用事务日志发布事件&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一种保证事务性消息的方式是基于数据库的事务日志，也就是所谓的数据变更捕获，Change Data Capture，简称CDC。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般数据库在数据发生变更的时候都会记录事务日志（Transaction Log），比如MySQL的binlog。事务日志可以简单的理解成数据库本地的一个文件队列，它主要记录按时间顺序发生的数据库表变更记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们利用alibaba开源的组件canal结合MySQL来说明下这种模式的工作原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多操作说明可以参考官方文档：https://github.com/alibaba/canal&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;canal工作原理&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;canal 模拟 MySQL slave 的交互协议，把自己伪装成一个MySQL的 slave节点 ，向 MySQL master 发送dump 协议；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;canal 解析 binary log 对象(原始为 byte 流)，然后可以将解析后的数据直接发送给消息组件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;RocketMQ事务消息解决方案&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apache RocketMQ在4.3.0版中已经支持分布式事务消息，RocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4503464203233256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4iayMvgxttQ19lYM82uMqboNJI9MzqA4yvCR4mVs8XK1iaDb3Suu7dYSSZ3YiaeWumtauAjRXTQIbN7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;866&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;RocketMQ实现事务消息主要分为两个阶段：正常事务的发送及提交、事务信息的补偿流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体流程为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;正常事务发送与提交阶段&lt;br/&gt;1、生产者发送一个半消息给MQServer（半消息是指消费者暂时不能消费的消息）&lt;br/&gt;2、服务端响应消息写入结果，半消息发送成功&lt;br/&gt;3、开始执行本地事务&lt;br/&gt;4、根据本地事务的执行状态执行Commit或者Rollback操作&lt;br/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务信息的补偿流程&lt;br/&gt;1、如果MQServer长时间没收到本地事务的执行状态会向生产者发起一个确认回查的操作请求&lt;br/&gt;2、生产者收到确认回查请求后，检查本地事务的执行状态&lt;br/&gt;3、根据检查后的结果执行Commit或者Rollback操作
补偿阶段主要是用于解决生产者在发送Commit或者Rollback操作时发生超时或失败的情况。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在生产者使用RocketMQ发送事务消息的时候我们也会借鉴第一种方案即自建一张事务日志表，然后在执行本地事务的时候同时生成一条事务日志记录，让本地事务与日志事务在同一个方法中，同时添加 &lt;code&gt;@Transactional&lt;/code&gt; 注解，保证两个操作事务是一个原子操作。&lt;strong&gt;这样如果事务日志表中有这个本地事务的信息，那就代表本地事务执行成功，需要Commit，相反如果没有对应的事务日志，则表示没执行成功，需要Rollback。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2dbcd68da884dc0b91ea258b367faa4e</guid>
<title>[推荐] 高性能万亿级消息吞吐 Pulsar 设计原理</title>
<link>https://toutiao.io/k/q8zmevp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;高性能万亿级消息吞吐Pulsar设计原理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、MQ 基本介绍&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 核心概念&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Topic：消息主题，一级消息类型，生产者向其发送消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者：也称为消息发布者，负责生产并发送消息至 Topic。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者：也称为消息订阅者，负责从 Topic 接收并消费消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息：生产者向 Topic 发送并最终传送给消费者的数据和（可选）属性的组合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息属性：生产者可以为消息定义的属性，包含 Message Key 和 Tag。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Group：一类生产者或消费者，这类生产者或消费者通常生产或消费同一类消息，且消息发布或订阅的逻辑一致。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 消息类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;普通消息：消息队列 RocketMQ 版中无特性的消息，区别于有特性的定时/延时消息、顺序消息和事务消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务消息：实现类似 X/Open XA 的分布事务功能，以达到事务最终一致性状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定时和延时消息：允许消息生产者对指定消息进行定时（延时）投递，最长支持 40 天。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;顺序消息：允许消息消费者按照消息发送的顺序对消息进行消费。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 MQ应用场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;交易系统&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;红包秒杀&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关闭未支付订单&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户信息注册&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在线抽奖设计&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任务系统设计&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跨私网数据交换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跨区域数据同步&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步解耦&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;削峰填谷&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式事务消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大数据分析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式模缓存同步&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异地多活&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步通知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;........&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.4 MQ消息模型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.15051020408163265&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWGhegoX9q2KDZcIxtrNQX3ouUxPKbMY605Ey6G1lHicazxNVqkL2f0sA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;392&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33433734939759036&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWFdia1rpA9FRhbhxPdAF4zAic4FaX0jYOzGibry3FlibQokiaZkoyS58gQ7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;332&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2557603686635945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWB0al497ic32IRdQLsAjbr5ToI4L9SrWQ0IbLcjje7z4ApFsHFrC7bPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;434&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40425531914893614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWREQibG9nEI0xGKPEEKdCIyPwpseMUnFUHiawnK2XlibntjUEuXhictFprw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;423&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4033018867924528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWlWk65yWQs5icWLuhbyRBe1PLL91nU4Oq1BtR8ptEyKlK2Sico9dSP4icA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3472222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWSmEs2ic0egnDYwhAicnOHzBFXFYHgAiaiaicxAz5DZ9KUfVJBDhKHGSuBeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;576&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.5 MQ产品发展路线&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3562753036437247&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWp8ib9LstburbOJ3glTdbX80L2XBmoJNn8HicLhZuyCyRHXCicnmr5Eojg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;741&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.6 MQ应用场景选型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4421168687982359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWRhkIKSITYC7N7QYVQjKyTBGpCSaibdlyjjSqhQ8xDh1LzuIMYbJ30lQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.7 MQ云原生场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6374695863746959&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWfhicPz3aR1QAdejY77xfribp0DfhSibvhbqIYOjdC6jZWDqh5yCicMNkAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1644&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.8 Pulsar  MQ&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 是一个用于服务器到服务器的消息系统，具有多租户、高性能等优势。Pulsar 最初由 &lt;strong&gt;Yahoo&lt;/strong&gt;开发，目前由 &lt;strong&gt;Apache&lt;/strong&gt; 软件基金会管理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.8.1 &lt;strong&gt;Pulsar 集群包含&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一组 Broker（服务发布 - 订阅流量）&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Pulsar Broker 是负责接收和交付消息的组件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Bookie（消息存储）&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Bookie 则是为最终消费前的消息提供持久存储的 Apache BookKeeper 服务器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;一个负责整体协调和配置管理的 Apache ZooKeeper&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7722222222222223&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoW4apjsI79pkZSVC3uCPSp2J4NPL1IjIE5LL8tops0E9w6F80ksOFoag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.8.2 &lt;strong&gt;Pulsar 的关键特性如下：&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Pulsar 的单个实例原生支持多个集群，可&lt;strong&gt;跨机房&lt;/strong&gt;在集群间无缝地完成消息复制。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;极低的发布延迟和端到端延迟。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可无缝扩展到超过一&lt;strong&gt;百万个 topic&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;支持多种topic 订阅模式（独占订阅、共享订阅、故障转移订阅）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过 Apache BookKeeper 提供的&lt;strong&gt;持久化消息存储机制&lt;/strong&gt;保证消息传递 。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由轻量级的 &lt;strong&gt;serverless&lt;/strong&gt; 计算框架 &lt;strong&gt;Pulsar Functions&lt;/strong&gt; 实现流原生的数据处理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;基于 &lt;strong&gt;Pulsar Functions&lt;/strong&gt; 的 &lt;strong&gt;serverless connector&lt;/strong&gt; 框架 &lt;strong&gt;Pulsar IO&lt;/strong&gt;使得数据更易移入、移出 Apache Pulsar。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;分层式存储&lt;/strong&gt;可在数据陈旧时，将数据从&lt;strong&gt;热存储卸载到冷/长期存储&lt;/strong&gt;（如S3、GCS）中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.8.3 pulsar 云原⽣架构&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 能够无缝扩容、延迟低、吞吐高，支持多租户和跨地域复制。最重要的是，Pulsar 存储、计算分离的架构能够完美解决 Kafka 扩缩容的问题。Pulsar producer 把消息发送给 broker，broker 通过 bookie client 写到第二层的存储 BookKeeper 上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6575052854122622&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWibbLAiauTibGCn1LOXmyv60nRBxMtaYaEr5HghSorHEAMs7dCDnTSRPjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;946&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0900735294117647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWl38YOOJhTXEIzoAicJLib61M05Bib5Qr0xuiboVtibbu60cwPtWGyC7ibXibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;544&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5352112676056338&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWIKibncU01mNWqSOOGd3p3WdPql6FLibAMQL7ZI7vUTMD4ZIPtLwv373g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1278&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;水平扩容：能够无缝扩容到成百上千个节点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;高吞吐：已经在 Yahoo! 的生产环境中经受了考验，支持每秒数百万条消息的发布 - 订阅（Pub-Sub）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;低延迟：在大规模的消息量下依然能够保持低延迟（小于 5 ms）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;持久化机制：Pulsar 的持久化机制构建在 Apache BookKeeper 上，实现了读写分离。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;读写分离：BookKeeper 的读写分离 IO 模型极大发挥了磁盘顺序写性能，对机械硬盘相对比较友好，单台 bookie 节点支撑的 topic 数不受限制。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、消息系统概述&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 Product 分块发送&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当启用分块(chunking) 时(&lt;code&gt;chunkingEnabled=true&lt;/code&gt;) ，如果消息大小大于允许的最大发布有效载荷大小，则 producer 将原始消息分割成分块的消息，并将它们与块状的元数据一起单独和按顺序发布到 broker&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;处理一个 producer 和一个订阅 consumer 的分块消息&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，当生产者向主题发送一批大的分块消息和普通的非分块消息时。假设生产者发送的消息为 M1，M1 有三个分块 M1-C1，M1-C2 和 M1-C3。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个 broker 在其管理的ledger里面保存所有的三个块消息，然后以相同的顺序分发给消费者（独占/灾备模式）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消费者将在内存缓存所有的块消息，直到收到所有的消息块&lt;/strong&gt;。&lt;strong&gt;将这些消息合并成为原始的消息M1&lt;/strong&gt;，发送给处理进程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2582025677603424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWichwiabso6sbdsShhPUiaTTga7Vvb9Td905ccaakK0NBvPP8eqdg87SUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;701&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;多个生产者和一个生产者处理块消息&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下所示，生产者1发布的消息 M1，M1 由 M1-C1, M1-C2 和 M1-C3 三个块组成。生产者2发布的消息 M2，M2 由 M2-C1, M2-C2 和 M2-C3 三个块组成。&lt;strong&gt;这些特定消息的所有分块是顺序排列的&lt;/strong&gt;，&lt;strong&gt;但是其在 ledger 里面可能不是连续的。这种方式会给消费者带来一定的内存负担。&lt;strong&gt;因为消费者会为&lt;/strong&gt;每个大消息在内存开辟一块缓冲区&lt;/strong&gt;，以便将所有的块消息合并为原始的大消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4356005788712012&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWJgf3INzAc74zd7Q0s6ticJJHs3J6ZvJn0a4qZdgCBzfyLL7JYkVF3zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 Topic结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;topic的名称为符合良好结构的URL&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{persistent（持久）|non-persistent(非持久)}://tenant(租户)/namespace（命令空间）/topic（主题）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;持久与非持久&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对于持久化的主题，所有的消息都会被持久化的保存到磁盘当中(如果 broker 不是单机模式，消息会被持久化到多块磁盘)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主题默认持久化类型，非持久需要指定。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非持久化的主题的数据不会被保存到磁盘里面。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;租户&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实例中的主题租户，对于Pulsar中的多租户至关重要，并且分布在集群中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;命名空间&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将相关联的 topic 作为一个组来管理，是管理 Topic 的基本单元。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大多数对 topic 的管理都是对&lt;strong&gt;命名空间&lt;/strong&gt;的一项配置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个租户里面可以有一个或者多个命名空间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 消息保留和过期&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar broker默认如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;立即删除消费者已确认的&lt;em&gt;所有&lt;/em&gt;消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;以消息backlog的形式，&lt;strong&gt;持久保存&lt;/strong&gt;所有的未被确认消息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar有两个特性，让你可以覆盖上面的默认行为。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息&lt;strong&gt;保留&lt;/strong&gt;使您能够存储消费者已确认的消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息&lt;strong&gt;到期&lt;/strong&gt;允许为尚未确认的消息设置生存时间（TTL）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所有消息保留和过期都在[命名空间]中管理级别。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;下图说明了这两种概念：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5455059355568117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWTEN9lVUlhDtLIIENVK3VAMePicM01zu0bL39rlvkuYezptzHWc76wvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1769&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;图中上面的是消息存留&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;存留规则会被&lt;strong&gt;用于某namespace下所有的topic&lt;/strong&gt;，指明哪些消息会被持久存储，即使已经被确认过。没有被&lt;strong&gt;留存规则&lt;/strong&gt;覆盖的消息将会被删除。&lt;strong&gt;如果没有保留策略&lt;/strong&gt;，所有已确认的消息都将被删除&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;图中下面的是消息过期&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有些消息即使还没有被确认，也被删除掉了。因为根据设置在namespace上的TTL，他们已经过期了。（例如，TTL为5分钟，过了十分钟消息还没被确认）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 消息去重&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息去重保证了一条消息只能在 Pulsar 服务端被&lt;strong&gt;持久化&lt;/strong&gt;一次。消息去重是一个 Pulsar 可选的特性，它能够阻止不必要的消息重复，它保证了即使消息被消费了多次，也只会被保存一次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图展示了开启和关闭消息去重的场景：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8177014531043593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWjBfEC4Atl3xCmxrvLUqbssSTeZMxia2RIWEcibK20Via3CtXLovaV5YvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1514&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最上面的场景中，消息去重被关闭。Producer发布消息1到一个topic，消息到达broker后，被&lt;strong&gt;持久化&lt;/strong&gt;到BookKeeper。然后producer又发送了消息1（可能因为某些重试逻辑），然后消息被接收后又持久化在BookKeeper，这意味着消息重复发生了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在第二个场景中，producer发送了消息1，消息被broker接收然后持久化，和第一个场景是一样的。当producer再次发送消息时，broker知道已经收到个消息1，所以不会再持久化消息1.&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4.1 生产者幂等&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种可用的消息重复数据消除方法是确保每条消息&lt;em&gt;&lt;strong&gt;只生成一次***。这种方法通常称为&lt;/strong&gt;生产者幂等&lt;/em&gt;*。这种方式的缺点是，把消息去重的工作推给了应用去做。在 Pulsar 中，消息去重是在 &lt;strong&gt;broker&lt;/strong&gt;上处理的，用户不需要去修改客户端的代码。相反，你只需要通过修改配置就可以实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;命名空间级别启用去重&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ bin/pulsar-admin namespaces &lt;span&gt;set&lt;/span&gt;-deduplication \&lt;br/&gt;  public/default \&lt;br/&gt;  --&lt;span&gt;enable&lt;/span&gt; &lt;span&gt;# or just -e&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在命名空间级别禁用去重&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ bin/pulsar-admin namespaces &lt;span&gt;set&lt;/span&gt;-deduplication \&lt;br/&gt;  public/default \&lt;br/&gt;  --&lt;span&gt;disable&lt;/span&gt; &lt;span&gt;# or just -d&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.5 消息延迟传递&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;延时消息功能允许你能够过一段时间才能消费到这条消息，而不是消息发布后，就马上可以消费到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，说明了延时消息的实现机制：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40312876052948254&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWUia7OP8sf6mWgV7XrMJ7ysoLTOXGFIF1fWXwg2wRstT5lDLwLHnX6oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;831&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Broker 保存消息是不经过任何检查的。当消费者消费一条消息时，如果这条消息是延时消息，那么这条消息会被加入到&lt;code&gt;DelayedDeliveryTracker&lt;/code&gt;当中。订阅检查机制会从&lt;code&gt;DelayedDeliveryTracker&lt;/code&gt;获取到超时的消息，并交付给消费者。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、消息系统架构设计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;单个 Pulsar 集群&lt;/strong&gt;由以下三部分组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个或者多个 broker 负责处理和负载均衡 producer 发出的消息，并将这些消息分派给 consumer；将消息存储在 BookKeeper 实例中（又称 bookies）；Broker 依赖 ZooKeeper 集群处理特定的任务等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;包含一个或多个 bookie 的 BookKeeper 集群负责消息的&lt;strong&gt;持久化存储&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个Zookeeper集群，用来处理多个Pulsar集群之间的协调任务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 Pulsar 集群&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图为一个 &lt;strong&gt;Pulsar 集群&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6613039796782387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWclERUmwtkqEd05WleqQBX8Yia7ECxuBE2Bqq18dInRYpDXIS2jA0l3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1181&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.1 集群&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 集群由N个Pulsar 实例组成，包含了&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个或者多个Pulsar &lt;strong&gt;brokers&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个ZooKeeper协调器，用于集群级别的配置和协调&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一组BookKeeper的Bookies用于消息的&lt;strong&gt;持久化存储&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集群间可以通过&lt;strong&gt;异地复制&lt;/strong&gt;进行消息同步&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.2 元数据存储&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 使用 &lt;strong&gt;Zookeeper&lt;/strong&gt; 存储元数据, 集群配置和协调信息。包含了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;配置与仲裁存储&lt;/strong&gt;: 存储租户，命名域和其他需要全局一致的配置项&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个集群有自己独立的&lt;strong&gt;ZooKeeper&lt;/strong&gt;保存集群内部配置和协调信息，例如归属信息，broker负载报告，BookKeeper ledger信息（这个是BookKeeper本身所依赖的）等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.3  brokers持久化存储&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;bookies特征适合Pulsar的应用场景&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为按条目复制的顺序数据提供了非常高效的存储。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保证了多系统挂掉时ledgers的读取一致性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供不同的Bookies之间均匀的IO分布的特性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Bookies被设计成可以承载数千的并发读写的ledgers&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用多个磁盘设备，一个用于日志，另一个用于存储，这样Bookies可以将读操作的影响和对于写操作的延迟分隔开&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5913410770855333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWatlMiaaAXr9bGJRmZTSAdLfX7rDE2HXHQPTvHny3uD7dlXcnypTmKcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;947&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 Pulsar服务发现机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;客户端&lt;/strong&gt;能够使用单个 URL 与整个 Pulsar 实例进行通信。Pulsar内部提供了服务发现的机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面这张图展示了Pulsar服务发现机制：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1021159153633855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoW3BXQJNZdq1qXR4pialn3ib73XLexXdVGqHyVCyolRx6FQjN28icvsJSKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1087&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、高吞吐量设计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 分区主题提升高吞吐&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;普通主题仅仅保存单个 broker中，&lt;strong&gt;这限制了主题的最大吞吐量&lt;/strong&gt;。&lt;strong&gt;分区主题是一种特殊类型的主题，由多个代理处理&lt;/strong&gt;，因此允许更高的吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分区主题&lt;/strong&gt;实际是通过在&lt;strong&gt;底层拥有 N 个内部主题来实现&lt;/strong&gt;，这个 N 的数量就是等于分区的数量。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当向分区的topic发送消息，每条消息被路由到其中一个broker。Pulsar自动处理跨broker的分区分布。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3972194637537239&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWEyzFu1MLfibIyMPh5DE5aGibvWSSmDPz7CeHticO4fCPuts9qhXMkbb8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1007&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图：Topic1主题有五个分区（P0到P4）被分成三个代理。因为分区多于broker数量，其中有两个broker要处理两个分区。第三个broker则只处理一个（分区的分布是Pulsar自动处理的）。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;这个topic的消息被广播给两个consumer。&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;发送模式&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;RoundRobinPartition&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;如果消息没有指定 key&lt;/strong&gt;，为了达到最大吞吐量，消息会以 round-robin 方式被路由所有分区。请注意round-robin并不是作用于每条单独的消息，而是作用于延迟处理的批次边界，以确保批处理有效。如果为消息指定了key，发往分区的消息会被分区生产者根据 key 做 hash，然后分散到对应的分区上。这是默认的模式。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;SinglePartition&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;如果消息没有指定 key&lt;/strong&gt;，生产者将会随机选择一个分区，并发送所有消息。&lt;strong&gt;如果为消息指定了key&lt;/strong&gt;，发往分区的消息会被分区生产者根据 key 做 hash，然后分散到对应的分区上。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;CustomPartition&lt;/code&gt;&lt;/td&gt;&lt;td&gt;使用自定义消息路由，可以定制消息如何进入特定的分区。可以使用 Java client 或实现MessageRouter 接口来实现自定义的路由模式。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分区topic和普通topic，对于订阅模式如何工作，没有任何不同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;订阅模式&lt;/strong&gt;确定消息应传递给哪个消费者&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;路由模式&lt;/strong&gt;决定消息应该发送到哪个内部主题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;备注：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;路由和订阅模式可以分开制定。吞吐能力的要求，决定了分区/路由的方式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;分区只决定生产者的消息到消费者处理及确认消息过程中发生的事情。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;非持久性消息&lt;/strong&gt;传递通常比持久性消息传递快，因为&lt;strong&gt;代理不会持久化消息&lt;/strong&gt;，一旦消息传递到连接的代理，就会立即将ack发送回生产者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5、跨机房复制&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 支持在不同的地理位置生产和消费消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，应用程序在某一地区或市场中发布数据，但需要在其他地区或市场处理和消费数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.1 跨域复制是怎样工作的&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 在不同集群之间跨地域复制的过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4922425952045134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWDpLe34WNBheEicbYwzhAU5TUvFiaH19VxXvwFxxHWVpOfxstjq34Fp3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;709&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在这个图中，每当P1、P2和P3生产者将消息分别发布到Cluster-A、Cluster-B和Cluster-C集群上的T1主题时，这些消息会立即在集群之间复制。一旦消息被复制，C1和C2消费者就可以从各自的集群中使用这些消息。如果没有地理复制，C1和C2使用者将无法使用P3生产者发布的消息&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在Pulsar中基于每个租户启用&lt;strong&gt;地理复制&lt;/strong&gt;， 跨域复制是在命名空间级别管理的&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2 本地存储和转发&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当消息发送到 Pulsar 的主题中，消息&lt;strong&gt;首先会被存储在本地的集群&lt;/strong&gt;，然后&lt;strong&gt;再被异步转发到远程集群&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在正常情况下，消息会被立即复制，并同时分发给本地的消费者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;应用程序可以在任何集群中创建生产者和消费者，可在 Pulsar 实例中的任意一个集群生产消息和消费消息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;订阅不仅可本地集群订阅，启用&lt;strong&gt;复制订阅&lt;/strong&gt;后在集群之间传输。&lt;strong&gt;一旦启用订阅复制，你能够保持同步的订阅状态。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主题能够异步的跨多个地域进行复制。如果发生故障，消费者能够在其他的集群从这个失败的点重新消费消息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图： &lt;strong&gt;T1&lt;/strong&gt;主题在&lt;strong&gt;Cluster-A&lt;/strong&gt;、&lt;strong&gt;Cluster-B&lt;/strong&gt;和&lt;strong&gt;Cluster-C&lt;/strong&gt;三个集群之间复制。这三个集群中的任何一个集群生成的所有消息都交付给其他集群中的所有订阅。在这种情况下，&lt;strong&gt;C1&lt;/strong&gt;和&lt;strong&gt;C2&lt;/strong&gt;消费者接收&lt;strong&gt;P1&lt;/strong&gt;、&lt;strong&gt;P2&lt;/strong&gt;和&lt;strong&gt;P3&lt;/strong&gt;生产者发布的所有消息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.3 主题跨域复制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命名空间级别创建了跨域复制，任何生产者或者消费者在这个命名空间创建的主题都会被复制到所有的集群中。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.3.1 选择性复制&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认消息被复制到命名空间配置的&lt;strong&gt;所有集群&lt;/strong&gt; ，可以通过为&lt;strong&gt;消息指定需要复制的目标集群列表&lt;/strong&gt;，来选择性地复制数据到目标集群&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构建&lt;strong&gt;Message&lt;/strong&gt;对象可以使用&lt;code&gt;setReplicationClusters&lt;/code&gt; 方法来指定目标集群:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//限制复制集群&lt;/span&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; restrictReplicationTo = Arrays.asList(&lt;br/&gt;        &lt;span&gt;&quot;us-west&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;us-east&quot;&lt;/span&gt;&lt;br/&gt;);&lt;br/&gt;&lt;span&gt;//生产者&lt;/span&gt;&lt;br/&gt;Producer producer = client.newProducer()&lt;br/&gt;        .topic(&lt;span&gt;&quot;some-topic&quot;&lt;/span&gt;)&lt;br/&gt;        .create();&lt;br/&gt;&lt;span&gt;//发送消息&lt;/span&gt;&lt;br/&gt;producer.newMessage()&lt;br/&gt;        .value(&lt;span&gt;&quot;my-payload&quot;&lt;/span&gt;.getBytes())&lt;br/&gt;        .setReplicationClusters(restrictReplicationTo)&lt;br/&gt;        .send();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.4 复制订阅&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 支持&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;复制订阅关系&lt;/strong&gt;，所以能够在不到1秒的时间内，在不同集群间保持订阅状态的同步。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;主题的上下文信息&lt;/strong&gt;也能在跨多个物理地域间进行异步复制。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果发生故障，消费者重启后能够在其他的集群从这个消费失败的点开始消费。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.4.1 启用复制订阅&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认禁用复制订阅，创建使用者时可启动。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//创建消费者&lt;/span&gt;&lt;br/&gt;Consumer&amp;lt;String&amp;gt; consumer = client.newConsumer(Schema.STRING)&lt;br/&gt;            .topic(&lt;span&gt;&quot;my-topic&quot;&lt;/span&gt;)&lt;span&gt;//主题&lt;/span&gt;&lt;br/&gt;            .subscriptionName(&lt;span&gt;&quot;my-subscription&quot;&lt;/span&gt;)&lt;span&gt;//订阅名&lt;/span&gt;&lt;br/&gt;            .replicateSubscriptionState(&lt;span&gt;true&lt;/span&gt;)&lt;span&gt;//启用复制订阅&lt;/span&gt;&lt;br/&gt;            .subscribe();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6、多租户&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 的多租户能力按照设计可满足下列需求：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;确保严苛的 SLA 可顺利满足&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保证不同租户之间的隔离&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对资源利用率强制实施配额&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供每租户和系统级的安全性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;确保低成本运维以及尽可能简单的管理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apache Pulsar 通过下列方式满足了上述需求：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过为每个租户进行身份验证、授权和 ACL（访问控制列表）获得所需安全性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为每个租户强制实施&lt;strong&gt;存储配额&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;以策略的方式定义所有隔离机制，策略可在运行过程中更改，借此降低运维成本并简化管理工作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1 命名空间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;命名空间是租户内部逻辑上的命名术语&lt;/strong&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;例如，包含多个应用程序的租户可以为每个应用程序创建单独的命名空间。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Namespace使得程序可以&lt;strong&gt;以层级的方式创建和管理主题&lt;/strong&gt; Topic 为&lt;code&gt;my-tenant/app1&lt;/code&gt; ，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它的namespace是&lt;code&gt;app1&lt;/code&gt;这个应用，对应的租户是 &lt;code&gt;my-tenant&lt;/code&gt;，可以在namespace下创建任意数量的topic&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 从设计之初就可以支持多租户。因此&lt;strong&gt;主题可按照与多租户有关的两个资源进行组织&lt;/strong&gt;：资产（Property）和名称空间（Namespace）。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;资产&lt;/strong&gt;代表系统中的&lt;strong&gt;租户&lt;/strong&gt;，&lt;strong&gt;租户&lt;/strong&gt;可以在自己的资产内&lt;strong&gt;配置多个名称空间&lt;/strong&gt;，每个&lt;strong&gt;名称空间&lt;/strong&gt;可包含&lt;strong&gt;任意数量个主题&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;名称空间&lt;/strong&gt;是 Pulsar 中每个租户&lt;strong&gt;最基本的管理单位&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可针对名称空间设置 ACL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调整副本数目设置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;管理跨集群的消息数据多地域复制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;控制消息的过期&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;.....&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**如下图：**一个 Pulsar 部署中包含了三个相互独立的租户&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.51875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoW1UE41Q9mtp4nN8rYWdmUHK3CvpiaXibLRaZlewyhdl3TkSgv9W6yRUQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2 订阅&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订阅是命名好的配置规则，指导消息如何投递给消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图：Pulsar4种订阅模型关系&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7336561743341404&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWeQ2wlgT9dJibNpZMjicjtCKPnACvAV6S3lfrCxPCLIp7hYV2S1skMxCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1652&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;消费者如使用传统的”&lt;strong&gt;发布-订阅消息&lt;/strong&gt;“，可以&lt;strong&gt;为每个消费者&lt;/strong&gt;指定一个特定的订阅名称， 这就是&lt;strong&gt;独占模式&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;消费者实现”&lt;strong&gt;消息队列&lt;/strong&gt;“的效果，则&lt;strong&gt;多个消费者会拥有相同的订阅名称&lt;/strong&gt;(如&lt;strong&gt;灾备模式，共享模式&lt;/strong&gt;，&lt;strong&gt;key共享模式&lt;/strong&gt;)。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2.1 &lt;strong&gt;独占模式&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只允许单个使用者附加到订阅。如果多个使用者使用相同的订阅订阅订阅主题，则会发生错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下图中，仅允许使用者A-0使用消息&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34543391945547364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoW86xpR0Tgebg5ADeotzIUQ1eaSl1zzSFqIibERzxRIGYhfKla7jcmCSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1763&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2.2 Failover（灾备）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;故障转移模式下，多个消费者可以附加到同一订阅，主消费者消费非分区主题或者分区主题中的每个分区的消息，当主消费者断开连接时，所有（未确认和后续的）消息都会传递给队列中的下一个消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下图中，Consumer-B-0是主Consumer，而Consumer-B-1是在Consumer-B-0断开连接时接收消息的下一个Consumer。&lt;img data-ratio=&quot;0.3811684628474192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWfQrG3JsOGBfHJicVl43nRSe2fzk7SmDXTv5DBDjBMetWRy6XnJOfPag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1763&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;备注：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分区主题&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Broker按照&lt;strong&gt;消费者优先级&lt;/strong&gt;和&lt;strong&gt;消费者名称词汇表顺序&lt;/strong&gt;对消费者进行排序。然后将主题均匀的分配给优先级最高的消费者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;非分区主题&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;broker 会根据消费者订阅非分区主题的顺序选择消费者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2.3 Shared（共享）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;strong&gt;共享&lt;/strong&gt;或&lt;strong&gt;循环模式&lt;/strong&gt;下，多个使用者可以附加到同一订阅。消息通过&lt;strong&gt;round robin轮询机制&lt;/strong&gt;分发给不同的消费者，&lt;strong&gt;并且每个消息仅会被分发给一个消费者&lt;/strong&gt;。当消费者断开连接，所有被发送给他，但没有被确认的消息将被重新安排，分发给其它存活的消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下图中，Consumer-C-1和Consumer-C-2可以订阅主题，Consumer-C-3和其他也可以订阅。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.417607223476298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWD6dKJlicLfdCLaicSAycZYDBwKWVvreGzYzwnnia1FDXrbmUsxsj4PYicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1772&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;共享模式的限制，不保证消息顺序，不能在共享模式下使用累积确认。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2.4 Key_Shared（键共享）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;strong&gt;键共享模式&lt;/strong&gt;下，多个使用者可以附加到同一订阅。消息以分发方式在消费者之间传递，并且具有相同密钥或相同排序密钥的消息只传递给一个消费者。无论消息被重新传递多少次，它都被传递给同一个消费者。当用户连接或断开连接时，将导致服务用户更改消息的某些键。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4330175913396482&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWfvXLwmZxB0bIeHM154oU5NAia8g8PeeiaW6GTuqtNXNTwMJnJtZkzyVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1478&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;键共享模式的限制，需要为消息指定键 或 orderingKey。不能在键共享模式下使用累积确认。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;可以在 &lt;code&gt;broker.config&lt;/code&gt; 中禁用 Key_Shared 模式。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.3 Pulsar 实现多租户的机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**核心手段为：**限制，为不同的租户设置权利范围 ，例如：身份验证和授权实现安全隔离，通过流控制、限流调节和存储配额实现共享物理资源的隔离，以及 通过 放置策略实现物理资源的隔离&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;安全性&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;授权是在资产层面上管理，权限是在命名空间的层面上管理，也就是在资产内部管理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;身份验证和授权实现了租户间的隔离，租户无法访问自己无权访问的主题或执行无权限的操作。通过插接式（Pluggable）的身份验证和授权机制实现的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;隔离&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;隔离满足安全方面的需求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多租户应用程序还需要满足 SLA 的要求，为此 Pulsar 还针对健壮性和性能进行了隔离。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;例如：将某租户隔离在提供服务的某个 Broker 子网内部，并使用 BookKeeper bookie 实现存储隔离。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;例如：&lt;strong&gt;磁盘配额&lt;/strong&gt;、&lt;strong&gt;流控制&lt;/strong&gt;、&lt;strong&gt;限流调节&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;软隔离&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;硬隔离&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7、层级存储&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar的面向segment的架构允许主题积压增长非常大，有效地没有限制。然而，随着时间的推移，这可能会变得昂贵，有一个降低消耗的办法，那就是使用分层存储（&lt;strong&gt;Tiered Storage&lt;/strong&gt;） 通过分层存储，在 backlog 中的旧消息可以从 BookKeeper 转移到更廉价的存储中，不出其他问题，客户端将仍然可以访问 backlog。&lt;img data-ratio=&quot;0.627927927927928&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3D6FrOsX8TF53zAbPDgMt4eYQ7wvtWoWNtQWgwlXe4EHVT5OwRbnT9JN8NeugflzQleSdXTCzkwG8icY2PqavWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1110&quot;/&gt;默认情况下写入到 BookKeeper 的数据会复制三个物理机副本。但是，一旦一个 segment 被BookKeep 封存（sealed），该 segment 就变得不可改变，此时就可以复制到长期存储中去了。长期存储可以达到节省存储费用的目的。通过使用 &lt;strong&gt;Reed-Solomon error correction&lt;/strong&gt;机制，还可减少物理备份数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 当前支持 S3, Google Cloud Storage (GCS) 和文件系统来做长期存储&lt;strong&gt;long term store&lt;/strong&gt;可以通过 REST API 或者命令行接口，将数据卸载（Offloading）到长期存储中。用户传入他们想要保留在 BookKeeper 上的 topic 数据总量，Broker 将复制所有 backlog 数据到长期存储。在 BookKeeper 上的原始数据将会被删除（延迟可配，默认4小时）。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>