<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>95c200fdcbccaf94a721172cb805f1a5</guid>
<title>吐血整理：一份不可多得的架构师图谱！</title>
<link>https://toutiao.io/k/ptp0ru2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section class=&quot;channels_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAjw8kH8ALjgAAAAstQy6ubaLX4KHWvLEZgBPE2aJARlkOVeeDzNPgMIszdok7Y2sA7EK5cGOVPGVT&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqzEIHCJXSxqN7aDrH7kFY7TFxQUQsiaKRXpdeEw1xjekbj9qlTkiciaDibcsiaXc0uvsjKUeuKicS921Cia4gP5ictNfcxLA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=x5Y29zUxcibB3cuGBzHk7qrmuEZVBUZdsFglyGvCjOIuIjS2Flxr69bOVhsOX2icjoc21khuyK3NQ&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/Q3auHgzwzM5nv7YHhmhvPsGGX04JCIgibK2x2Ru0TOY9HeZTGSIL1KQ/0&quot; data-username=&quot;v2_060000231003b20faec8c5e08a1fc3d5c807ec30b07756771265bc6b6234fb9e05062ae69ab4@finder&quot; data-nickname=&quot;儒猿IT&quot; data-desc=&quot;Dubbo是如何基于动态代理实现RPC调用的？平时大家用Dubbo做开发的时候，一定要了解他底层的原理！#Dubbo #RPC #动态代理 @微信时刻 &quot; data-nonceid=&quot;14306340900658042942&quot; data-type=&quot;video&quot; data-width=&quot;1728&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; powered-by=&quot;xmyeditor.com&quot;&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;文章来源：https://c1n.cn/J3wve&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;“架构师图谱”是一个很宏大的命题，特别是优秀的架构师自身也是“由点到面再到图”，一点点成长积累起来。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;尝试写这篇文章的目的更多的是结合自身的一些架构、研发、管理经验对现阶段做一个复盘总结，所以这里更偏向于后端图谱，依赖于开源技术、云原生或者其他第三方服务。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;这里会重点介绍一些技术栈、设计理念以及适应场景，这些可以作为我们选型时的依据。所谓“架构即决策”，是在一个有约束的盒子中寻求最优解。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;这个有约束的盒子是团队经验、成本、资源、进度、业务所处阶段等编织、掺杂在一起的综合体。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;本质上无优劣，但是存在恰当的架构用在合适的软件系统中，而这些就是决策的结果。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;一个技术图谱：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6188925081433225&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlE6kYgtPNWm2DqOm5W7hoAHjxbe9vIhvMwqxeSSrvN8lcd7BYMUUzag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1842&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;本文重点聚焦在微服务和常用的消息队列，包括相关的选型以及一些理论基础。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;完整的思维导图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlAHTcXLJ6ISmhIaz9gNQaKbkr6Nl1wkvYk4YVvcn39kZQQLCpqUcNWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;微服务&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;微服务是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关的 API 集相互通信。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;br/&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;微服务架构有别于更为传统的单体服务，可将应用拆分成多个核心功能。每个功能都被称为一项服务，可以单独构建和部署。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;这也体现了可扩展的基本思想：将原本大一统的系统拆成多个小部分，扩展时只修改其中一部分，通过这种方式减少改动范围，降低改动风险。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;微服务架构涵盖了服务的多个方面，包括网关、通信协议、服务注册/发现、可观察性、如何合理的划分等等。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 理论基础&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;微服务的理论基础主要用来指导微服务架构设计、服务拆分，确定合适的服务粒度和边界。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在做微服务之前我们首先要想明白我们现有系统面临什么样的问题，为什么需要微服务，随后才是怎么做。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;微服务很多核心理念其实在半个世纪前的一篇文章中就被阐述过了，而且这篇文章中的很多论点在软件开发飞速发展的这半个世纪中竟然一再被验证，这就是康威定律（Conway’s Law）。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在康威的这篇文章中，最有名的一句话就是：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;中文直译大概的意思就是：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;最初这篇文章只是描述作者自己的发现和总结，后来“人月神话”中，引用这个观点，并将其“吹捧”成现在熟知的“高位定律”。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;其中的一些核心观点可以概括如下：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;组织沟通方式决定系统设计，对于复杂的系统，聊设计就离不开聊人与人的沟通，解决好人与人的沟通问题，才能有一个好的系统设计&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;时间再多一件事情也不可能做的完美，但总有时间做完一件事情，这与架构设计&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;“简单、合适、演化”思维不谋而合&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;线&lt;/span&gt;&lt;span&gt;型系统和线型组织架构间有潜在的异质同态特征，更直白的说，你想要什么样的系统，就搭建什么样的团队，定义好系统的边界和接口，团队内应该是自治的，这样将沟通成本维持在系统内部，每个子系统就会更加内聚&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;大的系统组织总是比小系统更倾向于分解，面对复杂的系统及组织，往往可以采用分而治之&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;但是当我们的业务和组织架构复杂度比较高的时候，很多概念只从技术角度很难去抽象，这就需要我们自上而下，建立起通用语言，让业务人员和研发人员说一样的话，把思考层次从代码细节拉到业务层面。越高层的抽象越稳定，越细节的东西越容易变化。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;通过对不同领域的建模，逐步确定领域范围和业务边界，这也就是领域驱动设计（DDD）。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;DDD 是一种在面向高度复杂的软件系统时，关于如何去建模的方法论，它的关键点是根据系统的复杂程度建立合适的模型，DDD 中的界限上下文也完美匹配了微服务的高内聚、低耦合特性，这也为我们微服务的划分提供了强有力的基础。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;DDD 实施的一般步骤是：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;根据需求划分出初步的领域和限界上下文，以及上下文之间的关系&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;进一步分&lt;/span&gt;&lt;span&gt;析每个上下文内部，识别出哪些是实体，哪些是值对象&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;对实体、值对象进行关联和聚合，划分出聚合的范畴和聚合根&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;为聚合根设计仓储，并思考实体或值对象的创建方式&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在工程中实践领域模型，并在实践中检验模型的合理性，倒推模型中不足的地方并重构&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;但是 DDD 也不是银弹，特别是在一些新业务场景，本身就充满了很多的不确定性，一次性把边界划清楚并不是一件很容易的事。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;大家在一个进程里，调整起来会相对容易，然后让不同的界限上下文各自演化，等到了一定程度之后再考虑微服务也是一个不错的选择。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 网关&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;作为微服务的统一入口，也肩负着整个微服务的流量接入、管理、聚合、安全等，从服务分层的角度可以划分为接入网关和业务网关。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;接入网关接入网关提供最基础的流量接入和安全防护能力，侧重于全局，与业务无关。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;域名&amp;amp;DNS：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;作为服务的流量入口，对外通过域名和 DNS 提供服务，国内域名厂商一般都依托于共有云或被共有云厂商收购，用来完善自由的云生态。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;像阿里的万网，腾讯的 DNSPod 等，也有国外的 AWS，GoDaddy 和 Namecheap 等，可以用作 .me 等国内无法托管或备案域名的管理。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;其次也可以借助DNS（HTTPDNS、EDNS）实现跨地域、运营商网络等负载均衡，实现异地多活、就近访问、容灾等。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;负载均衡（LB）：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;主要负责请求的转发代理，按机器负载来分配流量等，对外提供 VIP，这里的负载可以宽泛的理解为系统的压力，可以用 CPU 负载来衡量，也可以用连接数、I/O 使用率、网卡吞吐量等来衡量。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;负载均衡器按服务层级来划分，除了前边提到的 DNS，还有集群级别的硬件负载均衡，以及机器级别的软件负载均衡。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;DNS/硬件负载均衡（F5/A10）主要用来应对海量用户的访问，中小量用户使用无疑会增加更多的维护和采购成本。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;软件负载均衡可以选择自研或上云，LVS、Keepalived 主要用于四层（IP+端口）的负载均衡，在四层的基础之上如果要实现应用层（域名/URL/用户会话）等的 7 层负载均衡，可以使用 Nginx、Keepalived 的组合。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;除此之外，网关也负责服务整体的安全防护，SSL，IPV6 等：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;安全防护目的是保护服务数据以及可用性，例如防范常见的 DDOS/CC 网络攻击，反爬虫，自定义访问控制，自研成本往往比较高，可以借助云上一系列的高防、防火墙服务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;SSL（TLS）用来提供外部 https 访问，https 可以防止数据在传输过程中不被窃取、改变，确保数据的完整性，在支付或者用户登录等敏感数据场景，可以起到一定的保护作用，同时 https 页面对搜索引擎也比较友好。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;IPV6，全球 43 亿 IPV4 地址已经在 2019 年年底耗尽，网信办在 2018 年开始就已经推行各大运营商、CDN 厂商、互联网核心产品支持 IPV6，我们公司之前也是试点之一。&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;&lt;span&gt;IPV6 的支持只需要增加一条“AAAA”DNS记录，将域名解析到自持 IPV6 的 IP/VIP 即可。&lt;/span&gt;&lt;span&gt;IPV4 到 IPV6 由于存在兼容性等问题，一定是长期共存的，过渡方案可以采用 IPV6 代理（IPV6 代理转发到 IPV4 服务）或者双栈（同时支持 IPV6 和 IPV4）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;业务网关：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4760672703751617&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlMicyOKTcNTt3yLGqZzHibdK8DziaPsZibuUiaX6CEsy9yGTotN4h0p19niaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1546&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;业务网关作为业务的最上层出口，一般承担起业务接入或者 BFF 的工作，例如基础的路由、鉴权、限流、熔断降级、服务聚合、插件化能力，并可以通过可视化界面管理网关配置。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;可选框架有基于 OpenResty 的 Kong、APISIX 以及其他语言相关的 SpringCloud Gateway、gRPC-Gateway 等等。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;国内开源的 Goku、Kratos、go-zero go 框架，有很多比较有意思的组件实现，我们日常业务上也可以借鉴。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;鉴权：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;鉴权的目的是为了验证用户、请求等的有效性，例如用户身份鉴权（JWT/Oauth2/Cookie），请求鉴权（请求签名、请求加密），鉴权逻辑也花样繁多，大多需要基于业务定制化，通过网关插件能很好的集成进来。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;限流：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;限流是为了做一定的流量控制，防止对系统产生过大压力从而影响整个服务。&lt;/span&gt;&lt;span&gt;可以基于单台机器或整个集群限流，常见的方式有限制总量和限制速率，超过的则排队或丢弃，例如令牌桶（弹性）/漏桶（匀速）算法。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;熔断降级：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;熔断作为服务断路器，当下游的服务因为某种原因突然变得不可用或响应过慢（这里既可以指单次请求也可以指一段时间），上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回，这样也能对整体链路起到保护作用。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;如果目标服务情况好转则恢复调用，同时结合降级策略提升服务的鲁棒性。&lt;/span&gt;&lt;span&gt;常见的有Hystrix/Resilience4J（Hystrix 虽然已停止更新，但现有功能已经能满足大多业务场景）。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;重试：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;大量网络 IO，避免不了会出现因网络抖动，出现连接失败或者超时，重试可以提高请求的最终成功率，削平服务毛刺。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;但重试也有可能放大故障，所以可以结合退避策略（backoff）、限制单点重试、限制链路重试这些策略进行优雅的重试，同时也可以采用更加激进的“对冲请求”提前（tp99 时间未响应时）发起重试请求，降低系统时延。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;插件化：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;各个网关集成插件的方式尽不相同，但是目的都是为了集成技术人员编写的一些业务相关的通用能力，例如前边提到的身份鉴权、请求鉴权等等。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;另外作为业务网关插件，也可以编写一些基础业务（API 鉴权、请求格式化）逻辑，直接透传请求到服务层，省去很多 BFF 和上下游对接的工作。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;BFF：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Backend For Frontend，可以按照业务逻辑，以串行、并行和分支等结构编排多个服务 API，为服务提供聚合、适配、裁剪（只返回需要的字段）功能，核心是 API 的动态编排以满足日益增长的业务逻辑，降低前端与微服务之间的对接成本。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;BFF 并不意味着只能由后端实现，也可以在前端通过 GraphQL 等 API 查询语言实现。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 协议&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;服务间的通信方式是在采用微服务架构时需要做出一个最基本的决策，统一的协议标准也能大大降低服务的联调和维护成本。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;HTTP REST：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;REST 更确切的讲是指的 API 设计风格，而不是协议标准。&lt;/span&gt;&lt;span&gt;通常基于使用 HTTP，URL，和 JSON 这些现有的广泛流行的协议和标准。&lt;/span&gt;&lt;span&gt;符合 REST 设计风格的 API 称作 RESTful API。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;在实际应用中大多实现的是伪 REST API，例如用 POST 请求同时实现资源的增删改，或者为了请求的扩展性，资源的增删改查都使用 POST JSON。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;RPC：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;RPC 协议描绘了客户端与服务端之间的点对点调用流程，包括 stub、通信、RPC 消息协议部分。&lt;/span&gt;&lt;span&gt;可以基于 TCP，也可以基于 http。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;在实际应用中，还需要考虑服务的高可用、负载均衡等问题，所以产品级的 RPC 框架除了点对点的 RPC 协议的具体实现外，还应包括服务的发现与注册、提供服务的多台 Server 的负载均衡、服务的高可用等更多的功能。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;目前的 RPC 框架大致有两种不同的侧重方向，一种偏重于服务治理（Dubbo、Motan），另一种偏重于跨语言调用（Thrift/GRPC）。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;RPC vs HTTP REST 优点：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;更清晰的 API 定义，例如 gRPC 协议的定义文件 proto，自身就可以作为很好的 API 文档，日常开发中也可以把 proto 文件独立版本库管理，精简目录结构，方便不同的服务引用。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;更好的传输效率，通过序列化和反序列化进一步压缩网络传输数据，不过序列化、反序列化也会有一定的性能损耗，protobuf 可以说很好的兼顾了这两点。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;更合适的容错机制，可以基于实际的业务场景，实现更合适的超时控制与异常重试机制，以应对网络抖动等对服务造成的影响。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在一些特定场景，例如：OpenAPI、BFF 等，HTTP REST 可以更大程度上降低外部团队的接入成本。并且 RPC 也有调试不便、多语言互通需要对应的 SDK 支持这些问题，各有利弊。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;综合考虑来看，除了一些特定场景，如果我们已经有相对完善的基础设施支撑（RPC 框架、服务治理），RPC 可以为一个更合适的选择。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 服务注册/发现&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;服务注册主要是通过将微服务的后端机器 IP、端口、地域等信息注册起来，并结合一定的发现机制使客户端的请求能够直连具体的后端机器。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从实现方式上可以分为服务端模式与客户端模式：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6162109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1Vl1xI9X0VuzhotibBhQMDiapMMhMHrT4ADmtg2hXGlBAq1v1PtibBJFaldg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;服务端模式：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;也可以说是传统模式，通过借助负载均衡器和 DNS 实现，负载均衡器负责健康检查、负载均衡策略，DNS 负责实现访问域名到负载均衡器 IP/VIP 的映射。通过直接暴露域名和端口的方式提供客户端访问。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9443359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlhNPoQOria7DXfibibVLomDwRkDSsvC7FSGOuR5sMF0X5FIrsjcSr7AB6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/section&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;客户端模式：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;可以借助注册中心实现，注册中心负责服务的注册与健康检查，客户端通过监听配置变更的方式及时把配置中心维护的配置同步到本地，通过客户端负载均衡策略直接向后端机器发起请求。&lt;/span&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;从两种模式的实现方式上可以看出：&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;①服务端模式注册与发现都由服务端完成，这样可以使客户端专注在自身的业务实现，但是由于依赖负载均衡器，也就是集中式的 proxy，proxy 需要维护双向连接，也很容易使自己成为系统瓶颈，可用性的高低直接决定了服务质量。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;并且 DNS 缓存机制也会导致故障发生时，迁移并不能及时完成。&lt;/span&gt;&lt;span&gt;当然在服务量少，且负载均衡器有 VIP 的情况下，我们也可以不使用 DNS。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;②客户端模式注册与发现由配置中心和客户端共同完成，通过分布式的方式，可以避免出现 proxy 节点性能瓶颈问题，但是可靠性与性能瓶颈很容器出现在配置中心上，并且客户端的也需要一定的接入成本。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;好在开源的已经有很成熟的架构方案与丰富的客户端 SDK，例如 etcd/ZooKeeper/Consul。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Consul 提供开箱即用的功能，etcd 社区和接入易用性方面更优一些，他们之间的一些具体区别：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41675977653631285&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlXQcwY57rGd9ftwXhZMZtp7BpFFmO3dibEqRIH2g95iabPCLbdmrEiapTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;895&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 配置中心&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;配置中心从使用场景来讲，一类是前边讲到的服务注册、发现和 KV 存储，例如 etcd/ZooKeeper/Consul，在 Kubernetes 场景下也可以通过 ConfigMap/Secret 将配置写入本地文件、环境变量或者共享的 Volume 中。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;这样没有了中心服务的依赖和客户端的接入，可以实现一些老旧服务的无侵入式改造。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;但是作为配置中心，除了基础的配置数据，一些情况下还要开放给非开发人员（测试、运维、产品）使用，完善的控制台、权限管理、Dashbord 的支持，也非常重要，这类可以参考 Nacos（阿里开源）/Apollo（携程开源）。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Nacos 在读写性能上优于 Apollo，但是功能特性（例如权限管理）稍逊于 Apollo。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| 可观察性&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在控制论中，可观察性是用系统输出到外部的信息来推断系统内部运运行状态的一种度量方式。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在云原生时代，容器和服务的生命周期是紧密联系在一起的，相较在传统的单体服务运行在物理主机或者虚拟机当中，排查问题的时候显得非常不便，这种复杂性导致了一个定义研发运营效率的 MTTR（平均故障修复时间）指标急剧增加。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;所以这里更强调的是微服务的可观察性，需要提前想好我们要如何观察容器内的服务以及服务之间的拓扑信息、各式指标的搜集等，这些监测能力相当重要。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;span&gt;可观察性三大支柱围绕 Tracing（链路追踪）、Logging（日志）和 Metrics（度量）展开，这三个维度几乎涵盖了应用程序的各种表征行为，开发人员通过收集并查看这三个维度的数据时刻掌握应用程序的运行情况。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;很长一段时间，这三者是独立存在的，随着时间的推移，这三者已经相互关联，相辅相成。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5175925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlP4Yiciay5XEcu3TqOTibYuEzYCw76Mb6oLoVj1cZAdCibxN2DMiceW2zBrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;①链路追踪&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;链路追踪为分布式应用的开发者提供了完整的调用链路还原、调用请求量统计、链路拓扑、应用依赖分析等工具，可以帮助开发者快速分析和诊断分布式应用架构下的性能瓶颈，提高微服务时代下的开发诊断效率以及系统的可观察性。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了解决不同的分布式系统 API 不兼容的问题，诞生了 OpenTracing 规范，OpenTracing 中的 Trace 可以被认为是由多个 Spacn 组成的 DAG 图。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;[&lt;span&gt;Span A&lt;/span&gt;]  ←←←(the root span)&lt;br/&gt;            |&lt;br/&gt;     +------+------+&lt;br/&gt;     |             |&lt;br/&gt; [&lt;span&gt;Span B&lt;/span&gt;]      [Span C] ←←←(Span C 是 Span A 的孩子节点, ChildOf)&lt;br/&gt;     |             |&lt;br/&gt; [&lt;span&gt;Span D&lt;/span&gt;]      +---+-------+&lt;br/&gt;               |           |&lt;br/&gt;           [&lt;span&gt;Span E&lt;/span&gt;]    [Span F] &amp;gt;&amp;gt;&amp;gt; [Span G] &amp;gt;&amp;gt;&amp;gt; [Span H]&lt;br/&gt;                                       ↑&lt;br/&gt;                                       ↑&lt;br/&gt;                                       ↑&lt;br/&gt;                         (Span G 在 Span F 后被调用, FollowsFrom)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–&amp;gt; time&lt;br/&gt;&lt;br/&gt; [&lt;span&gt;Span A···················································&lt;/span&gt;]&lt;br/&gt;   [&lt;span&gt;Span B··············································&lt;/span&gt;]&lt;br/&gt;      [&lt;span&gt;Span D··········································&lt;/span&gt;]&lt;br/&gt;    [&lt;span&gt;Span C········································&lt;/span&gt;]&lt;br/&gt;         [&lt;span&gt;Span E·······&lt;/span&gt;]        [Span F··] [Span G··] [Span H··]&lt;br/&gt;&lt;/code&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;OpenTracing 专注在 tracing，除此之外还有包含了 Metrics 的 OpenCensus 标准，以及由 CNCF 推出，融合 OpenTracing 和 OpenCensus 的 OpenTelemetry。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;OpenTelemetry 旨在实现云原生时代可观察性指标（Tracing、Logging、Metrics）的统一收集和处理，同时提供推动这些标准实施的组件和工具。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;OpenTracing 中的佼佼者当属 Jaeger、Zipkin、Skywalking。&lt;/span&gt;&lt;span&gt;他们之间的一些对比：&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8491446345256609&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VljunIy1K4jNlwSgMKKofAMdvQzkPHiciatnv0tKibgn0O7ibtibrVQAv118w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1286&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Zipkin 开源时间长，社区相对丰富，Jaeger 更加轻量，也是 Istio 推荐方案，SkyWalking 支持部分语言（Java、PHP、Python 等）的无侵入式接入。另外 APM（应用性能）监控的支持也会影响到我们的选型。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;除此之外，面对线上海量请求，如果采用抽样采样策略，那就需要支持一定的流量染色，把我们核心关注的请求（例如链路中发生了错误、部分请求耗时过高等）都进行采样。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;可以通过结合 opentelemetry-collector 以及开箱即用的 tailsamplingprocessor 构建 Pipeline 插件实现。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;②日志&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;服务间的链路日志能否帮助我们判断错误发生的具体位置，这类业务日志主要集中在访问日志/打点日志等等。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;随着大数据的兴起，我们对数据的分析解读能力越来越强，日志作为原始数据则体现出了更大的价值，例如用户的行为分析，反垃圾，舆情分析等等。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;业务日志：这类日志重点在于通过不同级别的日志，及时发现分析系统存在的异常。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;RFC 5424 定义的 8 中日志级别：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Emergency：system is unusable&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Alert：action must be taken immediately&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Critical：critical conditions&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Error：error conditions&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Warning：warning conditions&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Notice：normal but significant condition&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Informational：informational messages&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Debug：debug-level messages&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在实际使用过程中可能会对日志级别进行简化和调整，一般来讲 Warning 及以上的日志是需要重点关注的，需要做好及时的监控告警，Warning 以下的日志也可以辅助问题的定位。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;日志写入可以选择写入消息队列，也可以选择落地磁盘，将关心的结构化或非结构化日志、业务模块信息（如果是细粒度的微服务，可以选择将日志放同一模块收集），以及级别、时间（who、when、where、how、what）等要素正确的写入正确写入后再收集到日志服务。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;写入消息队列需要考虑消息队列的选型以及做好可用性和积压监控，写入磁盘需要考虑写入性能以及日志的切割清理，例如 Golang 的 zap+rotatelogs 组合。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;日志收集的话，由于 Logstash 资源消耗相对比较大，虚拟机环境中可以使用 Filebeat 来替代，更严苛的线上或容器环境，可以使用 Fluentd/Fluentd Bit。日志最终汇总到 ES 和 Kibana 做展示，通过 Esalert 定制告警策略。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;大数据日志：大数据日志本质上也对应着我们一定的业务场景，但大多是海量日志、高吞吐量场景，所以对海量日志的收集和存储是较大的挑战。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;实现方案我们可以采用高吞吐量的流式中间件，例如 Kafka/Plusar 等，在结合流式处理（Flink）或者批处理（Spark）系统，将数据汇总到 Hadoop 进行分析，这里涉及到的中间件和数据库可参考后续章节。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;③指标&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;指标是有关系统的离散的数据点，这些指标通常表示为计数或度量，并且通常在一段时间内进行汇总或计算。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;一般用来做基础的资源监控和业务监控：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;资源监控：CPU、内存、IO、fd、GC等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;业务监控：QPS、模调、耗时分布等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Zabbix 作为老牌的监控系统，适合更复杂的物理机、虚拟机、数据库等更复杂的场景，同时也拥有更丰富的图形化界面。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;但是 Prometheus 作为云原生的代表作，与 Kubernetes、容器等能更好的结合，协同 Grafana 实现可定制化的界面，另外存储基于 TSDB，相比于关系型数据库也有更好的扩展性。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;以 Prometheus 为例，支持的数据类型有：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Counter 只增不减的计数器，例如请求数（http_requests_total）。基于此数据模型，使用 Prometheus 提供的强大 PromQL 表达式能够拓展出更加适合开发观察的指标数据。分钟增量请求：increase(http_requests_total[1m]) 分钟 QPS：rate(http_requests_total[1m])&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Gauge 可增可减的时刻量，例如 Go 语言协程数（go_goroutines） 波动量：delta(go_goroutines[10m])&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Histogram 直方图，不同区间内样本的个数。例如，耗时 50ms-100ms 每分钟请求量，100ms-150ms 每分钟请求量。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Summary 概要，反应百分位值。例如，某 RPC 接口，95% 的请求耗时低于 150ms，99% 的请求耗时低于 200ms。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Prometheus 指标支持 pull 和 push 模式：&lt;/span&gt;&lt;/p&gt;&lt;span&gt;‍&lt;/span&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| Service Mesh&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;我们前边讲的服务发现、熔断降级、安全、流量控制、可观察性等能力。这些通用能力在 Service Mesh 出现之前，由 Lib/Framework 通过一些切面的方式完成，这样就可以在开发层面上很容易地集成到我们的应用服务中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是并没有办法实现跨语言编程，有什么改动后，也需要重新编译重新发布服务。理论上应该有一个专门的层来干这事，于是出现了 Sidecar。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一代 Service Mesh，像 Linkerd，后边又出现了第二代 Service Mesh，Istio，职责分明，分离出处数据面和控制面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是 Sidecar 作为代理层，避免不了性能损耗（CPU 序列化反序列化 UDS），所以 proxyless service mesh 重新被提起，和之前的 「RPC + 服务发现治理」区别是啥？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;感觉这个名词营销味道略重。其实不能简单的 “Proxyless Service Mesh” 理解为 “一个简单的 RPC 框架，暴露了几个超时参数到配置中心来控制”，它重在统一协议、API。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这样就便于基于统一的协议实现 proxyless mesh 和 proxy mesh 的互通，可以同时满足性能敏感型和快速迭代型的业务场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.706766917293233&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1Vlem16fKehBmfsiaGXibQaEjzSLWFfILO7zibar7clwu9YpMdIxrSOdv3Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;665&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;他们相辅相成，丰富了 service mesh 的形态：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5882352941176471&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlicBqb1pzybKeIba5I4vVE5sW8c38B3jkicHibQff14zyWpiarPh7lYsIog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;850&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;servicemesh 对于微服务基础设施的一种演进，但不代表他已经非常成熟了，相反像迁移成本高，甚至一些可用性设计还不如业务自己做那么灵活。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些现实的问题还摆在面前，我觉得这也是属于技术进化的一种趋势，当一项技术足够成熟的时候，又回衍生出新的复杂度问题，从而又需要发展出新技术解决。&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在计算机科学中，消息队列是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.328159645232816&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1VlfQqGib5H1WL4dbeFicn5mfnqNW0beAibIF8G8jPI77iaIGS9wjHnnsXS7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;实际应用场景中，消息队列也经常作为中间件，用于异步解耦、削峰填谷、数据广播、错峰与流控、最终一致性等，在一些核心的大数据分析、交易支付等场景也经常扮演重要角色。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;关于服务解耦，会有很多人质疑，消息队列是否能真正解耦，我的理解是：数据要发生流转，系统之间要有依赖关系。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;例如上游服务直接读写下游存储、中间件进行数据交互，解耦则更侧重于将易于变化的复杂度转移，对下游存储、中间件的依赖，通过消息队列转化为双方的弱接口（消息payload）依赖。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;但如果上游是本身是依赖的下游 API，这种方式就需要考虑有多个下游时，自身复杂度和可用性的变化。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;消息队列的选型主要侧重以下几点：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;HA：自身的高可用性保障，避免消息队列的引入而影响整体服务的可用性&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;高吞吐：在面对海量数据写入能否保持一个相对稳定、高效的数据处理能力&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;功能丰富性：是否支持延迟消息、事务消息、死信队列、优先级队列等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;消息广播：是否支持将消息广播给消费者组或者一组消费者&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;消息堆积能力：在数据量过大时，是否允许一定消息堆积到broker&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;数据持久性：数据持久化策略的采用，也决定着数据在宕机恢复后是否会丢失数据&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;重复消费：是否支持ack机制，在消费者未正确处理消息时，支持重新消费&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;消息顺序性：针对顺序消费的场景保证数据按写入时间的顺序性&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;这里着重对比一下 Redis、RabbitMQ/RocketMQ、Kafka、Plusar。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| Redis&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Redis 实现消息队列可以通过 List 类型、Pub/Sub、Stream（Redis 5.0）类型来实现，HA 使用多副本或者集群的方式。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;作为消息队列使用起来非常方便，但是也有很多的弊端：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;功能丰富性：只支持普通的消息类型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;数据持久性：Pub/Sub 只提供缓冲区广播能力，不进行持久化，List/Stream 即使基于 aof 和 rdb 持久化策略，但是并没有事务性保障，在宕机恢复后还是存在丢失数据的可能性&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;消息堆积能力：List 随长度增大，内存不断增长；Pub/Sub 只在缓冲区内堆积，缓冲区满消费者强制下线；Stream 创建时可以指定队列最大长度，写满后剔除旧消息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;除此之外，List 类型无法支持消息广播，和 Pub/Sub 一样也不支持重复消费。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;结合整体来看 Redis 作为消息队列大多数只应用在数据量小，对丢失数据不敏感的业务场景，适用范围较小，复杂业务并且有一定运维支撑的情况下，可以直接考虑企业级消息中间件。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| RabbitMQ vs Kafka vs RocketMQ&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;这几个可以作为企业级消息中间件的代表，而 RocketMQ 在设计之初就借鉴了很多 RabbitMQ、Kafka 的设计理念，例如：Routing、多副本、顺序写（IO），也广泛应用在淘宝双十一等场景。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;HA：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在 HA 方面他们都是通过副本的方式，区别是 RabbitMQ 是集群级别的副本，Kafka 是多 partiton 和 ISR、选举机制，而 RocketMQ 通过多（master/slave）副本同时保障 NameServer 和 Broker。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;高吞吐：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Kafka 和 RocketMQ 通过直接操作文件系统，相比于 RabbitMQ，顺序写能大幅度提升数据的处理速度。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Kafka 为了进一步提升消息的吞吐量，可以采用客户端缓冲队列的方式批量发送，但也会存在宕机丢失数据的可能性，可以通过设置 batch.size 与 linger.ms 来动态调整，相比于 RocketMQ 更加灵活。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Kafka 的 partition 机制的确会带来性能的提升，但是在 Topic 不断增多的情况下，众多的 partition 及副本也将顺序写逐步退化为随机写，并且扩容时，由于 hash 值的变化，也会涉及到大量 partiton 数据的迁移。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;RocketMQ 采用 commitlog 的方式实现全局写，所以能支持更多的 Topic，扩容也不涉及大量数据的迁移。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;功能丰富性：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Kafka 只有基础的消息类型，RabbitMQ 支持优先级队列，通过 TTL 和死信队列可以实现消息的延迟和重试，但是需要提前创建好对应重试频率的队列。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;例如：1s 重试队列，10s 重试队列，RocketMQ 则内置了 18 个重试频率“1s 5s 10s 30s 1m 2m……”，另外也具有独有的 2PL 事务消息，很好的保障业务逻辑与消息发送的一致性。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;重复消费：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;他们三者都采用 ACK 机制保障了单条消息重复消费的能力，Kafka 通过 offset 和 partition 特殊的 ttl 机制（segment 过期，按文件名顺序清理），能支持通过重置 offset 来回溯历史数据。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;消息顺序性：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;RabbitMQ 和 RocketMQ 可以保证写入同一 topic 的顺序性，但是在多个消费者同时消费的情况下还是会出现乱序的情况。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;在数据量较大的时候，我们也可以通过单个消费者消费，再按照一定的分发策略分配给多个消费者执行，只不过会提升整体复杂度，同时会带来更多的 HA、维护成本考量。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Kafka 可以保障单个 partition 的顺序性，并且每个 partiton 只允许一个消费者来消费（N：1），这就从策略上避免了多消费者的情况，在数据量较大的情况下，可以通过划分更多的 partition 提升数据处理能力。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;综合来讲，RabbitMQ、RocketMQ 使用 Queue 模型，丰富的消息队列功能，更多的应用在业务场景，Kafka 基于 Streaming 模型，结合批处理、流式处理，更多的应用在大数据分析场景。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;| Pulsar&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;Pulsar 作为 Apache 开源、云原生的消息中间件，诞生之初就引发了很大的关注。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;设计上避免了 Kafka 遇到的功能丰富性、扩容等方面的问题，采用计算、存储分离的架构，broker 层只作为“API 接口层”，存储交给更专业的 bookeeper，由于 broker 层的无状态性，结合 Kubernetes 等非常方便的进行扩容。&lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0884086444007859&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLZTyO29KNYEDfTeDicmmH1Vlg8ykiahcOXkPwY7sVe4XTUk6K4NvySdY2AITVPEQ9fEFw85E3c0RgJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1018&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;并且 Pulsar 支持多个消费模型提升消费者处理能力，例如：exclusive、failover、shared、key-shared 等。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;可以说综合了 Kafka 和其他消息中间件的众多优点：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;HA、高吞吐：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;和 Kafka 类似，通过多 partition 和选举机制功，除此之外，还支持丰富的跨地域复制能力&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;功能丰富性：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;可以支持秒级的延迟消息，以及独特的重试队列和私信队列&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;消息顺序性&lt;/strong&gt;：为了实现 partition 消息的顺序性，和 Kafka 一样，都需要将消息写入到同一 broker，区别是 Kafka 会同时存储消息在该 broker，broker 和 partiton 绑定在一起，而 Pulsar 可以将消息分块（segment）后，更加均匀的分散到 bookeeper 节点上，broker 只需要记录映射关系即可，这样在资源扩容时，可以更加快速便捷&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;像能量守恒定律一样，系统的复杂度往往也是守恒的，实现即高性能又高可用的消息中间件需要的技术复杂性，不会凭空消失，只会从一个地方转移到另一个地方。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;消息队列本质上可以理解为 feature+fs，只不过存储、计算分离架构，将各层间的职责分离，使每一层都能专注在自身领域，以应对海量数据和更加复杂多变的环境，这也是现在新技术发展的一个趋势。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;作为后起之秀，的确可以站在巨人的肩膀上，避免很多设计上的不足，同时引入一些新的架构理念，但是要成功的在其中分一杯羹，同样也要面临用户学习成本高、缺少杀手级应用、如何迁移等等这些现实性的问题。&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;不过依靠良好的社区和技术先驱，随着时间的变迁，这些短板也会逐步补齐，真正适应当前时代的技术一定会脱颖而出。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAjw8kH8ALjgAAAAstQy6ubaLX4KHWvLEZgBPE2aJARlkOVeeDzNPgMIszdok7Y2sA7EK5cGOVPGVT&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqzEIHCJXSxqN7aDrH7kFY7TFxQUQsiaKRXpdeEw1xjekbj9qlTkiciaDibcsiaXc0uvsjKUeuKicS921Cia4gP5ictNfcxLA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdWRRHVNKCmVibXvGib0vU50ibFSVgJ3xciaZTJ0licvQCIZKrhlqmHicicD2LiamfHibxeibHtNM&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/Q3auHgzwzM5nv7YHhmhvPsGGX04JCIgibK2x2Ru0TOY9HeZTGSIL1KQ/0&quot; data-username=&quot;v2_060000231003b20faec8c5e08a1fc3d5c807ec30b07756771265bc6b6234fb9e05062ae69ab4@finder&quot; data-nickname=&quot;儒猿IT&quot; data-desc=&quot;Dubbo是如何基于动态代理实现RPC调用的？平时大家用Dubbo做开发的时候，一定要了解他底层的原理！#Dubbo #RPC #动态代理 @微信时刻 &quot; data-nonceid=&quot;14306340900658042942&quot; data-type=&quot;video&quot; data-width=&quot;1728&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;-------------  END  -------------&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;扫码&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;免费&lt;/span&gt;&lt;span&gt;获取&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;600+页&lt;/span&gt;&lt;span&gt;&lt;strong&gt;石杉老师原创精品文章汇总PDF&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;266&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;267&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZ5icqLlExialiaCQxchGhiayjmvre9iaGxkcEbZ7nouMhzte6DQrdm66ygQWsZLgTquaNdXiaV55v7fiaqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4Acg4lxHhCmfrJ0pDVibHNTZT9yPjQDtW34fia88kcXic4lkhDKpD2D43m2ZIFmK06HQtTiaFaiawhHfqgh3JJzcFDA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;原创技术文章汇总&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.5096045197740113&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLb1sI49A5HEg8H7tqAfMEhtgy64yFFyq3ibTTZZS36cToFCiaFZWA7ABjpbTkHXlTUDWkvQRTKkQkUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19607843137254902&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tyspBV9djfmj4CQpUYhF0Wr0PoVybcdicFSfXGYyxueVI1UMO2GOtrCyYe0PaXwSsdbQCW1iaveicQaRovgrA3eog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;102&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点个&lt;span data-mid=&quot;&quot;&gt;在看&lt;/span&gt;你最好看&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19607843137254902&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zgt3gMUJ2LGbE25ticZVnaXibaNMqN2jHzc7IT1tcmFIktmDib2hsdO9IiaE4r4Cia4iaKWb8jzwWmLWicyZ7Foibhh9oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;102&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;span&gt;‍‍‍‍‍‍‍‍‍‍‍‍&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3c0dc79ba2ae0136d00c37875274d20d</guid>
<title>金融风控系统的演进与升级:从第一代到第四代</title>
<link>https://toutiao.io/k/55p47ii</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;风控系统随着业务发展多元化，场景复杂化，市场监管趋严，商业纵深整合的需要以及黑产专业化，风险对抗加剧，也经历着不断的演进与升级，今天就来一起探究这些年风控系统经历过的演进与升级。&lt;/span&gt;&lt;/p&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;34&quot;&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;34&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;34&quot;&gt;▌&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;34&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;34&quot;&gt;第一代：单体系统/规则硬编码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;34&quot;&gt;&lt;span&gt;第一代风控系统大多基于规则策略做硬编码开发，各家系统大同小异，毕竟满足业务需求是第一位。而其最大的问题就是风控策略流程变更迭代周期长、效率低，毕竟就算调整一个阈值也需要 IT 开发人员排期、开发、测试、部署流程走一遍，平均每次迭代要 1-2 天。此外，由于频繁上线加之小需求繁杂，需求沟通差异（开发人员计算机工程背景与风控分析人员数据分析和金融背景）导致的线上问题日渐频繁，难以维护。硬编码为主的系统难以满足更复杂、快速迭代的风控需求，于是，&lt;/span&gt;&lt;span&gt;如何解决迭代效率&lt;/span&gt;&lt;span&gt;成为首先要解决的问题。&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;34&quot;&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;34&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;34&quot;&gt;▌&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;34&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;34&quot;&gt;第 1.5 代：规则引擎/专家系统&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以 drools 为代表的规则引擎（专家系统）成为救命稻草，通过引入配置化脚本简化风控策略调整。其编码风格如下：&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;rule&lt;/span&gt; &lt;span&gt;&quot;test_rule1&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;when&lt;/span&gt;&lt;br/&gt;        $user: User(age &amp;gt;= &lt;span&gt;18&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;then&lt;/span&gt;&lt;br/&gt;        $user.setRank(&lt;span&gt;&quot;A&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;end&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过掌握脚本语言语法，即可配置所需规则策略，再通过代码引擎自动执行，将规则策略调整与代码分离，降低开发测试要求，大大提高了迭代效率。但这一代风控引擎需要额外引入新的脚本语法学习成本，也很难直接交付给风控分析师，大多仍需要 IT 开发来完成迭代。算是决策引擎的过渡版本，所以归为第 1.5 代风控系统。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▌&lt;/span&gt;&lt;span&gt;第二代：智能决策引擎&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;1、图形化决策引擎&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二代风控决策引擎系统，具备简单易用的图形化操作后台，支持风控分析师后台调整风控规则和流程，并一键热部署生效，大大提升风控策略调整效率。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5133333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9jQ9iaibWHNaubTVKa5ibP47kAR0RyBsIfG7ia9VI1tqzNjOWtdIu6KekdiaVIHpNAM82O2VavztMaEibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;支持 BPMN 标准图形化风控决策流配置，还支持冠军挑战者 &lt;/span&gt;&lt;span&gt;/ &lt;/span&gt;&lt;span&gt;AB Test &lt;/span&gt;&lt;span&gt;分&lt;/span&gt;&lt;span&gt;流&lt;/span&gt;&lt;span&gt;测试，以及条件分流配置。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4095940959409594&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9jQ9iaibWHNaubTVKa5ibP47k69yh6riciaicYpZBk8YWIN1xRk0H5CnFNeN2XwNrrEeZ4iaFkHBKaspW7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1626&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;支持决策表、决策树、决策矩阵、评分卡、表达式等更复杂规则决策配置方式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.21756487025948104&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9jQ9iaibWHNaubTVKa5ibP47k5FVvpXVddQoQvIpiaqtmJrsWAa03I0XvwhRPjLZ3HyvwYB0hHHGvyqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2004&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二代风控决策引擎彻底解决了风控策略调整效率问题，实现了风控策略流程迭代&lt;/span&gt;&lt;span&gt;从天级降到小时级&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、机器学习模型&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在解决效率问题的同时，效果是另一个待提升的问题。&lt;span&gt;随着黑产的专业化发展，&lt;/span&gt;单纯的规则配置可以通过反复测试试探阈值而被突破，&lt;span&gt;规则&lt;/span&gt;调整变更手段滞后难起到最佳效果，引入机器学习等智能化模型成了进一步解决问题的银弹，这也是现在常说的“&lt;/span&gt;&lt;span&gt;智能风控&lt;/span&gt;&lt;span&gt;”的开始。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5485996705107083&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9JBHX1h6U0ztib3uNsVMDiay8cKYvRJoWqq7vrDxNZuJXiaA00I9MmqNqjGYqD4eVjQV4QfY3hR2ktw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;607&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38127090301003347&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9JBHX1h6U0ztib3uNsVMDiayZiby75fRnkicZDhgRAMoyDJ7fa9Kic86MzrILVzTIjG53EUNYu9Nov0ibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;598&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;通过将模型与决策引擎整合，将模型打分作为重要决策特征，提升决策效果。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、大数据应用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;引入三方征信数据补充规则与模型，充分利用大数据优势，可以更好地提高风险识别能力，也就是“&lt;/span&gt;&lt;span&gt;大数据风控&lt;/span&gt;&lt;span&gt;”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.55668358714044&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9jQ9iaibWHNaubTVKa5ibP47kOyQp01zCtdGsnR5vEvwKbcZ5XvBQUXJQYjdg0fOxqx3wKVovIhCeyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1182&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结：第二代风控系统，以高效的决策引擎为主，引入了机器学习模型和大数据，大幅提升了风控迭代效率和风险识别效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▌&lt;/span&gt;&lt;span&gt;第三代：智能风控大中台&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;随着互联网高速发展，在高性能、可靠性、通用性、风险识别等方面提出了更高的要求和挑战。&lt;/span&gt;&lt;span&gt;第三代风控系统满足精细化运营需求，表现为支持高性能、高度平台化、智能化的风控大中台，下面分别展开描述。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、系统高性能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;互联网场景下，秒级风控决策能力成了普遍性要求。在决策流程短，特征涉及少，没有太多外部数据源的情况下，比较容易达成。而随着决策流配置更长，规则策略更多，特征繁多且加工逻辑复杂，并引入一堆外部数据源的情况下，提升执行效率成为一个更复杂的系统性能工程亟待解决。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;※&lt;/span&gt; &lt;span&gt;提升特征计算性能&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基本思路是空间换时间。如果每次决策流执行时才去实时计算特征，那么特征计算所消耗的时间将会导致整体流程时间变长。通过预计算方式提前完成特征计算，将计算结果冗余 KV 存储中，执行时即可 O(1）取出所需特征数据。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4169611307420495&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbdicGzdoS9K4c4pJjM2tNJMJicVxjWxvjXdsH18bEfbKyKF6GGrnvZNicFuHoRKH2DvnZlXmwjy5E0kOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;预计算的方案亦有其局限性：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;首先，准确性上可能不如实时计算，比如预计算结果后发生了数据变更，所以触发预计算时机需要考虑。可以通过 CDC （变更数据捕获）的方案，来实现每一次数据变更后完成一次计算变更，提高特征数据的准确率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，可能存在决策发生时预计算未完成，导致特征数据缺失。&lt;/span&gt;&lt;span&gt;此时处理方案是忽略，或是失败异常，或是触发实时计算，亦或是要求必须预计算结束通知才能做决策调用，需要根据业务需求来择优。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;再有，针对三方数据源接&lt;/span&gt;&lt;span&gt;口存在收费问题，如果预计算后并没有使用，可能导致数据成本浪费，所以一般只对内部数据进行预计算，对三方数据进行实时计算。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此外，可以对历史数据（t-1）进行批处理计算，再融合当日数据进行融合计算，可进一步提升计算效率，也是大数据 Lambda 架构形式，但对于需要做全局去重统计的数据可能会损失精度&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.37670514165792235&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9jQ9iaibWHNaubTVKa5ibP47k5JqicB7pTGyRLuzGAtvkT0HHaTYsONMb6UuI730dGrl4iaFv4boxxNhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;953&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;※ 提升并发执行能力&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;决策引擎的流程配置，在一定程度上会影响其执行效率。通过配置并行网关，节点并发执行，可缩短执行时间。但风控分析师一般关注风控效果和成本，让其兼顾考虑并行执行有些强人所难。因此，有必要让系统自动分析完成高效并发执行流程。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;过程可以分发布时（将配置的决策流转成决策引擎执行的 DSL），运行时（决策引擎执行 DSL）两个阶段，类似某些编程语言的编译期和运行时。发布时可以提示方案修改建议，运行时可以强制按最优并行度来执行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4255050505050505&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9jQ9iaibWHNaubTVKa5ibP47krQgWSLVJ5wg6uqMaX8nF3WhOYliaj0ibicicBTQgibwGgQ7bvs9hyeFRxUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;792&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;提高并行度，分析决策流图节点依赖关系，将无上下文依赖的节点并行执行，可以充分利用 CPU 多核以及并发批量调用特征。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.31378763866877973&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9jQ9iaibWHNaubTVKa5ibP47kmcqYfQdgyPptLZ5cPe1RX3OepYhu7edFfH8pEmP7X9FQPaPW1BlSVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;631&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对上图进行广度优先遍历，获取一个 List(A,s1,B,E,C,F,D) ，如果后继节点依赖特征不与前序节点输出重合，那么即可认为前后节点没有上下文依赖，可以并发执行。此外 s1 排它网关会选择 BCD 或 EFD 一条路径执行，可以进行剪枝操作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此外&lt;span&gt;还要考虑有成本数据特征，以及提前中断情况，需要结合业务场景需求合理做出并发优化。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、系统高可靠&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;※ 决策流配置校验&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;规则配置是风控的一道重要防线，如何防止配置出错这类操作风险造成业务损失？&lt;span&gt;决策流校验是重要的保障。既要保障减少业务耦合打造决策引擎的通用性，也要降低配置出错率让操作风险可控，因此每一条校验规则都是在实践与犯错中总结而成。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;校验同样分为发布时校&lt;/span&gt;&lt;span&gt;验和运行时校验两部分&lt;/span&gt;&lt;span&gt;治理&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;发布时校验，保障决策流无明显语法错误，分支闭合，流程完整。如 ab 分流网关要求所有分支流量之和必须等于 100%；决策矩阵要求所有分箱区间必须连续无交叉且覆盖所有取值范围；下游节点依赖某决策树输出特征，上游必须配置该决策树节点；只有分支节点出度可大于 1 其他类型必须为 1；决策流构建成有向无环图（DAG）做成环检测避免执行无法终止...&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4691848906560636&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9jQ9iaibWHNaubTVKa5ibP47krCkfQr3SMG0RKEaP7DLD0jfNTCbDygC1DhD9vVJO0mpqiceAuk6MnLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;503&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;运行时校验，针对某分支或模式匹配失败而导致决策流无法正常流转下去，进入异常案件中。常见如遇特征缺失（获取失败或其他原因），忽略继续执行，抛异常，或者强制失败。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;※ 实时监控报警&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;打造全方位分层监控报警，系统层、链路层、应用层、业务层，除传统监控报警之外，针对风控指标和模型效果的监控必不可少。针对模型调用情况，风控通过率的监控；基于模型分分箱条件下的数据和效果稳定性，计算出 PSI、AUC、KS 等指标；以及底层特征的缺失率、零值率等指标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.33879781420765026&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd8OLCymuLgRy6bc7UqjzsKeASmGberB5ibLkynxJ4a2BarFc21Gtl81KgiatrypMOHu0wO0wdv4cwnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1098&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;※ 流量回放与模型回溯&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过“录制”线上流量的方式，将决策流执行过程所依赖的数据特征，及请求入参和结果快照下来。此数据可以作为流量回放和模型回溯的源数据，通过部署离线引擎，可以在线下对决策流调整进行效果评估与验证，以此来降低决策流变更带来的的风险。同理，通过离线回溯进行模型性能分析，结合模型陪跑，可以实现新模型平滑决策。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44692737430167595&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9AiaZTJHSqolBXtiaFibDy8xzeGw6Ub37b162GBkGzjJf13Ze37p8jSjeialWuXpgECmy5bMBlXKA6qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;895&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;3、系统高可用&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于决策流配置长短不一导致决策引擎执行时间不确定，属于不均衡延时系统，因此其部署和执行上必须要考虑隔离方案以保障系统高可用。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;※ 长短请求调度隔离 / 同步异步隔离&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;一般像前筛、预审等场景配置规则较少，需要快速响应（&amp;lt;1s），同步返回。而授信、支用等场景需要校验更多，响应时间可以更长（5-20 s），可以采用异步方式获取结果。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在部署决策引擎执行决策流时针对不同场景性能要求和调用方式差异采取隔离部署，降低因资源池打满而造成的互相影响。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;※ 业务线流量调度资源隔离&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;作为统一风控中台，如面对多条业务线接入，一定要减少相互影响，由于决策引擎对数据库依赖较小，因此数据层只做逻辑隔离，但引擎应用层需要保障各业务有独立资源，并在网关层（调度层）做分流路由。可以依托 K8s 的 label 对资源分组，通过请求 header 标签做流量调度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9035916824196597&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9AiaZTJHSqolBXtiaFibDy8xz6GJJ53S8h5fzgaF1yJc5VriafiaYByndcpKzyicliaxj74eP78ExuRn18g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;529&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此外保障高可用做好集群负载均衡、服务治理、限流、熔断、降级方案，以及请求链路监控等。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、平台化工程化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;※ 数据源接入与特征加工工程化&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当决策引擎完成工程化后，大量的风控开发工作集中在数据源 API 接入和特征开发上，而借助工程化、平台化可以进一步减少开发工作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据源接入大多工作可模板化解决，通过配置请求地址 、请求方式、超时时间等必要信息，再结合入参、出参报文映射解析实现模板化接入数据源。入参通过配置参数映射或常量值完成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35811648079306074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9jQ9iaibWHNaubTVKa5ibP47ktpwQDmD8HQLPPYibPmNKq3kTwqYQwINdaqW8ziaRKrS9DlIZKYmWJuXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1614&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;简单的报文解析，可以通过 Jsonp 的方式，直接从结果集中提取关键字段。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;复杂的报文解析，需要进一步代码加工工作，也可以开发一些常用的函数辅助完成粗加工。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.787257019438445&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9jQ9iaibWHNaubTVKa5ibP47kCURetot0jgRnLGnA4ZMy6B3BVyBaJJC3AbTjEYwdr57uRjXxEnvKeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于批量加载&lt;/span&gt;&lt;span&gt;特征且有多源依赖的，可以通过构造接口依赖关系图，并通过逐层调用执行加工。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5057603686635944&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9jQ9iaibWHNaubTVKa5ibP47kGXM5wU1qgHdfxK2t13Y6vDUPt4LkpwtW9yBqa9flUTC9skpYqaU4OQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;868&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span/&gt;&lt;span&gt;※ 模型工程化&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;随着大规模机器学习的应用，为进一步提升模型迭代效率，&lt;span&gt;让&lt;/span&gt;&lt;/span&gt;&lt;span&gt;模型迭代周期从月级降低到天级&lt;/span&gt;&lt;span&gt;，将模型工程化，打造出自动建模平台及模型管理平台，整体工程分为离线工程和在线工程两部分。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;离线工程，机器学习平台，主要围绕模型训练和回溯，通过自动特征工程、自动建模技术（AutoML）提高模型迭代效率和效果。按模型开发流程依次分为：数据管理（维护样本和数据集），数据挖掘（自动特征工程），算法选择（支持 XGBoost/LightGBM等），模型训练（训练任务管理），模型调优（自动调参），效果评估（一键打分），发布上线（输出标准 PMML 模型和 python pickle 模型）。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;122&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.21119592875318066&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbdictoMItLMF1FG7qQH6XGsIjs2WeiadpjfGkWhBY5Bro2MXpGtlk1h7vEGFyRQrHxzePjziauGxFyHibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在线工程，模型引擎，&lt;span&gt;通过&lt;/span&gt;&lt;span&gt;加载&lt;/span&gt;&lt;span&gt;模型库模&lt;/span&gt;&lt;span&gt;型文件（支持 PMML 和 pickle），&lt;/span&gt;完成实时预测打分，并提供 API 供决策引擎调用。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.617059891107078&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9jQ9iaibWHNaubTVKa5ibP47kY5Nja3P7bG3M9rKiaT45RcHYUguJVXJ7RGMicW6SjYxHSy5pSDE14NnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;551&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;模型管理平台&lt;/span&gt;&lt;strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;包括模型资产管理、生命周期管控、监控报警管理，整合机器学习平台实现模型生成后一键热部署，整合决策引擎配置实现关联调用和在线陪跑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;span&gt;第三代风控系统，针对业务的高速发展，满足互联网三高场景，全面平台化，打造出一个完整的风控中台。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▌&lt;/span&gt;&lt;span&gt;第四代：数字化智能化创新&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;第四代风控系统通过全面大数据、人工智能、云计算、区块链等技术实现进一步提质增效，个人觉得大多数企业仍处于此探索阶段，故称为数字化智能化创新阶段。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、智能化决策&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;智能化决策基于数据分析、机器学习、深度学习、专家经验，通过归因下探，规则量化，全链路过程监控追踪，结果回溯等手段实现规则策略自动调优、自动生成与推荐，达成风控“自动驾驶”。用以解决人工配置操作风险、策略效果衰减以及迭代调整滞后等问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8479880774962743&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9Hl2FfDRnGzUS5ClqwefnJ6ZXh8zOhjUGw6CQzhFn9RFyXoOtF5w7lfa9NGHkIJ0qVk3pTc1hb2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;671&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;实践中自动调优风控策略以及自适应模型也会带来“可解释性”问题和稳定性因素，需要大量 AB 实验探索，与专家经验对比，人工干预和过程管控&lt;/span&gt;&lt;span&gt;不可或缺。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;2、图应用&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;随着黑产职业化分工和集团化发展，金融风险呈现规模化特征，给传统规则策略和模型识别带来巨大挑战，针对个体行为属性的特征难以识别团伙行为的规模风险，因此关联分析需求及图解决方案成为风控发展的新趋势。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;图数据库应用，图数据库相比关系型数据库具有更高效的关联查询性能。通过图数据库群体特征（如二度联系人中黑名单用户占比）能更好的识别团伙欺诈；通过图计算特征进行子图匹配，发现相似模式风险账号；利用社区发现算法进行社群发现，识别群体风险；通过图连通性、路径发现做失联修复；通过构建用户 360 视图（异构图）完善用户画像，更好地发现信贷风险；此外基于图神经网络的深度学习技术成为图应用的发展趋势。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.39015151515151514&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9AiaZTJHSqolBXtiaFibDy8xzcic3zMKDuia8t3ib8OWdS1w3IrG9MkGtoPf7ZKOic9VSgbdBxibsibYambiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1584&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实践中 Neo4j 代表的原生图数据库，满足一般中小规模数据量级，有更好的性能表现，但其集群版本不支持开源；JanusGraph 分布式数据库，可以构建更大规模图，性能方面略有不足。购买商业版或自造轮子开发图数据库，解决海量数据构建异构图，原生图，以及查询性能成为关键。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、&lt;strong&gt;隐私计算&lt;/strong&gt;与联邦学习&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;随着数据安全法和个人信息保护法的实施，数据安全和隐私保护日趋严格，为了满足“&lt;/span&gt;&lt;span&gt;原始数据不出域，数据可用不可见&lt;/span&gt;&lt;span&gt;”，隐私计算解决方案成为破局之道。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;隐私计算&lt;/span&gt;&lt;span&gt;分为联邦学习（FL）、安全多方计算（MPC）、可信执行环境（TEE）等。&lt;/span&gt;联邦学习是通过数据加密计算，分布式机器学习，实现各公司间数据在不出库的前提下完成联合建模需求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;FATE 框架使用多方安全计算 (MPC) 以及同态加密 (HE) 技术构建底层安全计算协议，以此支持不同种类的机器学习的安全计算，包括逻辑回归、基于树的算法、深度学习和迁移学习等，基于此框架可快速构建隐私计算体系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9823529411764705&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd8OLCymuLgRy6bc7UqjzsKe2abRabWL2gVAUOtvtkSUbibnxmViaZIw2WhG5F46dTQfKBXNalYykyOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实践中由于要求合作双方部署同套隐私计算方案，而市面上隐私计算体系割裂，不同解决方案难以互通，成本较高成为主要限制屏障。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、区块链&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;区块链去中心化、不可篡改、开放自治的特性，建立数据联盟链，既保障了数据的可信赖，又可利用其网络广播特性实现数据共享，有效解决大数据风控的数据孤岛问题；在供应链金融方面区块链提供信用保证和履约保证，提供更好的风控解决方案；在金融智能合约应用上，通过区块链可编程特点，构建智能合约，有效防范了人为操作风险。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;区块链技术+大数据+人工智能的组合也是未来风控的发展趋势。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▌总结 Roadmap&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;风控系统演进之路，从不断提升效率实现自动化，解决性能、可靠性问题，到全面数字化、智能化升级，不断探索应用新技术手段提升风控效果。&lt;/span&gt;&lt;span&gt;各家系统发展和迭代方式不同，但基本演进思路和发展方向殊途同归。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4804832713754647&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9JBHX1h6U0ztib3uNsVMDiaynGwsE7RfiaSEHwt3Ce6v28Do19AeM3wIPHOYneu46b0qWMpxGtLwkwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1076&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;感&lt;/span&gt;&lt;span&gt;谢阅读&lt;/span&gt;！欢迎与我交流提出您的见解，觉得文章可以欢迎分享、点赞支持。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;107447&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;218:358&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  往期推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;144&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;144&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWH0hficYGBZI8qZSNxI5FiadxVSicSfvTZSNbNJGbX8d3bNJbTg1HfvOEIbM2rVa8I078ibV7wcKys75w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;长按二维码关注&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;以分布式设计、架构、体系思想为基础，兼论研发相关的点点滴滴，不限于代码、质量体系和研发管理。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8ef28ce09274d77f7e0b20da31ba5209</guid>
<title>入职一家新公司，如何快速熟悉代码？</title>
<link>https://toutiao.io/k/ee8ki7c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;strong/&gt;&lt;strong&gt;&lt;span&gt;点击关注公众号，一周多次&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;包邮送书&lt;/span&gt;&lt;/strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100064273&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;64&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100064273&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;64&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100064273&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;64&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIzMjg5MTU1MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/I0nV5DiabQiajWb0TDrpqbicibnkpDSDicWFe1TK805sQwu802AgvyQI879jE4dtaRebnKsDYXg3UUcKibWOCEcEHxMQ/0?wx_fmt=png&quot; data-nickname=&quot;程序员架构&quot; data-alias=&quot;chengxuyuanjg&quot; data-signature=&quot;一个有趣的专注用人话说技术、帮助程序员成长的架构公众号&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;来源：经授权转自 微观技术（ID：weiguanjishu）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者&lt;span&gt;：&lt;/span&gt;Tom哥&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互联网的薪资还是非常诱人的，高辄年薪百万，低辄几万十几万，差异非常大&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然，很多互联网企业每年都有2% ~ 20% 不等的调薪&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，这点工资涨幅跟程序员付出的辛苦相比，根本不值一提&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，跳槽也就成为了很多程序员 &lt;code&gt;快速涨薪&lt;/code&gt; 的首选方式&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但，人的本性是喜欢稳定，突然换一个陌生环境，开始时会有强烈的不安全感。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何快速适应新的工作环境？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里面既要熟悉公司的企业文化、产品业务、技术框架、系统代码，还要处理好身边的同事关系。。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要面对的事情好多呀，生活太难了&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwcRk0gI83k9Ursn0VF3lKYsI8H36R3xL6Cg0v9EbjAYA5M5MibzjwkrI0aYH3tpRTvd0PUuE7BREHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;225&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，程序员的工作首选还是快速熟悉系统，进而能快速上手写代码&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Tom哥面试过 &lt;code&gt;500&lt;/code&gt; 多位候选人，经常也问候选人这个问题？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么今天，就跟大家做个分享&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，你要清楚，每个人的大脑想法都不一样，正如莎士比亚说的，一千个人眼中有一千个汉姆雷特。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你如果按常规思路，去揣测别人的代码思路，很容易陷入细节中&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6654545454545454&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwcRk0gI83k9Ursn0VF3lKYsb21icMS29vZeSX3C8FLicAnzJI2BvRX9rWD4DBkFRpnPazGZTjIgmntg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;275&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你不疯，谁疯！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;先看文档&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计文档就像一座大楼的设计图纸，让我们对整个系统先有个直观的认识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说，对于刚入职的新人，一定要和身边同事尤其是带你的师兄搞好关系，给人家买买奶茶，请个午饭啥的，程序员一般内心善良，很容易被打动。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6866666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwcRk0gI83k9Ursn0VF3lKYstoExIzMicb26cfmlh49pJqD4B184hrVjauKFhyeHAtZgnrMyVISxWXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;450&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你后续的答疑肯定要麻烦人家，当然人家也可能顺手分享给你一些有用的技术文档资料，你别小看着这个，它对你快速熟悉系统起到了至关重要的作用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;特别注意：通常文档与代码存在一定的滞后性，比如修复线上bug、或者一些小需求，可能就没有文档更新，如果这类需求迭代较多时，那么文档与代码的不一致性会很大。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记住一点，文档只是一个参考，不能全信。&lt;code&gt;要不然你会被坑的很惨！&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;万物都是相通&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任何事情都是有技巧的，就像小时候语文老师教我们如何写作文一样，&lt;code&gt;总分&lt;/code&gt;、&lt;code&gt;分总&lt;/code&gt;、&lt;code&gt;总分总&lt;/code&gt;，这些框架思路大家一定不陌生。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7985989492119089&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwcRk0gI83k9Ursn0VF3lKYsUIJtdJeGpHZSfAC6j3u4FciaquBjmd09I0lBuG6yX3M12hTUSYMt97g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1142&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如上面系统架构，当然每个公司的系统也是大同小异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，最上层的业务输入层，可能是页面，也可能是对外的API接口&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是哪一种形式，我们可以快速将其转换为 &lt;code&gt;用例图&lt;/code&gt;。通过用户故事，帮助我们先了解整个系统的 &lt;code&gt;核心功能&lt;/code&gt;，让我们对业务体系先有个体感。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;家里有粮，心中不慌。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，就是另一端了，没错，就是底层的关系存储，将业务表的ER图快速还原&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8002544529262087&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwcRk0gI83k9Ursn0VF3lKYsVcU6Q40gWsH4HntTt43j8kFLAMgskZq5Sic0eUTC5q4ZtxRKkNE5UbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管中间的 &lt;code&gt;Service层&lt;/code&gt;、&lt;code&gt;Manager层&lt;/code&gt;、&lt;code&gt;infrastructure层&lt;/code&gt; 如何复杂，最终数据肯定是要落盘存储。打蛇要打七寸，解决问题要抓主要矛盾。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们把业务表的 ER关系还原出来后，我们基本上能从上下两端，快速摸清业务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稍微有些经验的架构师、领域专家对于系统如何搭建，心中会形成个概要方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后带着这个思路，再去看代码，不断纠正自己心中的设想方案。就像拿着手电筒走路，不会两眼一抹黑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;同事解惑，结果论证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然了，你全身心投入看了几天的代码，感觉懂了很多，但又缺少一种&lt;code&gt;脚踏实地&lt;/code&gt;的感觉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能你也收集了一些问题，还没有答案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以找熟悉系统的同学，占用人家一点时间寻求答疑解惑。当然你也可以讲下对系统的个人理解，听听别人的反馈，验证自己的理解是否有偏差。&lt;code&gt;教学相长&lt;/code&gt; 会让自己进步更快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果恰好你是老板的话，那相对容易很多，你可以安排团队成员对自己负责的模块，梳理产出&lt;code&gt;用例图&lt;/code&gt;、&lt;code&gt;类图&lt;/code&gt;、&lt;code&gt;状态机&lt;/code&gt;、&lt;code&gt;时序图&lt;/code&gt; 、&lt;code&gt;流程图&lt;/code&gt;、&lt;code&gt;架构图&lt;/code&gt; 等，既锻炼了小伙伴们的逻辑思维能力、表达能力，也为自己熟悉系统提供更多的信息输入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最后&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前人栽树，后人乘凉。无论你是原创作者，还是后来接手，技术文档一定要持续建设。随着越来越多的人接手并重视文档的建设，才能让代码逻辑显性化、清晰化，也便于我们的持续优化升级。而不是处于一种持续混乱的状态中。&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;p&gt;&lt;span&gt;·················END·················&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzMjg5MTU1MA==&amp;amp;mid=2247512670&amp;amp;idx=1&amp;amp;sn=2994ccce4be886cba7050937e1163195&amp;amp;chksm=e88f07afdff88eb94b5e62e117f276ad9012bf574a7929254ae185d407aba956432fbf86a14f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;我们用了一个周末，将 370 万行代码迁移到了 TypeScript&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;我们用了一个周末，将 370 万行代码迁移到了 TypeScript&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;•&lt;/span&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzMjg5MTU1MA==&amp;amp;mid=2247512532&amp;amp;idx=1&amp;amp;sn=be40e16eecdc54087759f8c13b1d25bb&amp;amp;chksm=e88f0425dff88d33c3dc9d3e7bd6b2b3f56681e3091404b98d3d996533439689de82d4137b44&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Tauri 1.0正式发布，Rust编写的桌面UI框架&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Tauri 1.0正式发布，Rust编写的桌面UI框架&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzMjg5MTU1MA==&amp;amp;mid=2247512392&amp;amp;idx=1&amp;amp;sn=e2a5b52f71c4432e5a87fa0c8981a8ca&amp;amp;chksm=e88f04b9dff88daf61cd46f3968069414247ab045c99e8d4eedbf4be62df100628dd5435bc9f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;突然！VS Code 杀死 IDEA？！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;突然！VS Code 杀死 IDEA？！&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzMjg5MTU1MA==&amp;amp;mid=2247512391&amp;amp;idx=1&amp;amp;sn=52a9b6e1c49e072e0392d386283e8b35&amp;amp;chksm=e88f04b6dff88da04eb2dfca679df4f919ee65a20b70e89692096a0491f5792d2610226fe66a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;B站，又一次被骂上热搜！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;B站，又一次被骂上热搜！&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzMjg5MTU1MA==&amp;amp;mid=2247512239&amp;amp;idx=1&amp;amp;sn=5286cd492dc4901a16a19484c472dafe&amp;amp;chksm=e88f055edff88c48227fa691b31d4d3f4fea4a3079a640d90253f9006d5a60600b505312f0f5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;微信更新，可一键查看已销号好友，朋友圈也有变化（文末送书）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;微信更新，可一键查看已销号好友，朋友圈也有变化（文末送书）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzMjg5MTU1MA==&amp;amp;mid=2247512161&amp;amp;idx=1&amp;amp;sn=6f8e8cfbd249fa714936d2e9b9746337&amp;amp;chksm=e88f0590dff88c86cf5fbd87d5063b5c995d4e66c59d827470b3f339eed18d3e1c3dad1bc39c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;模仿今日头条失败，腾讯又一款App即将下架！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;模仿今日头条失败，腾讯又一款App即将下架！&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzMjg5MTU1MA==&amp;amp;mid=2247512051&amp;amp;idx=1&amp;amp;sn=2e2f483163063cc24a20c1b02a5fe3ac&amp;amp;chksm=e88f1a02dff89314962d99a23be82cc7b286555d4872a130082895e00d01aaea548ddb017e8a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;离大谱！win10/11又爆多个离奇Bug，速看避坑！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;离大谱！win10/11又爆多个离奇Bug，速看避坑！&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;• &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzMjg5MTU1MA==&amp;amp;mid=2247511948&amp;amp;idx=1&amp;amp;sn=05cd431edfd7ca6ad317e1cf7c4622e4&amp;amp;chksm=e88f1a7ddff8936b9ff37a6969be0ebbff3929a3f86c31557b359ac5adea233d2a6b6d490bde&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;微软禁止俄用户下载安装Win10/11&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;微软禁止俄用户下载安装Win10/11&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;👇&lt;/span&gt;&lt;strong&gt;&lt;span&gt;更多内容请点击&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIzMjg5MTU1MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/I0nV5DiabQiajWb0TDrpqbicibnkpDSDicWFe1TK805sQwu802AgvyQI879jE4dtaRebnKsDYXg3UUcKibWOCEcEHxMQ/0?wx_fmt=png&quot; data-nickname=&quot;程序员架构&quot; data-alias=&quot;chengxuyuanjg&quot; data-signature=&quot;一个有趣的专注用人话说技术、帮助程序员成长的架构公众号&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot; wah-hotarea=&quot;click&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-fileid=&quot;100015080&quot; data-ratio=&quot;0.13333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/k1pCs0kyE2aLViaDJyP7HLFCqBUNzXticVmFaia24LEbGE2ZJvCgbjLkZgK4OTfpGAK34gt4Cb2QCMshwdoglE7wQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>31adf88347e76942e38da79dacd6cda5</guid>
<title>分布式监控神器之 Frostmourne</title>
<link>https://toutiao.io/k/4xjq446</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;_2rhmJa&quot;&gt;&lt;p&gt;&lt;code&gt;Frostmourne&lt;/code&gt;是开源分布式监控系统，用于帮助监控几乎所有数据库数据(包括&lt;code&gt;Elasticsearch&lt;/code&gt;, &lt;code&gt;Prometheus&lt;/code&gt;, &lt;code&gt;SkyWalking&lt;/code&gt;, &lt;code&gt;MySql&lt;/code&gt; 等)。如果你已经建立起了日志系统和指标体系，却苦恼于没有一个监控系统，也许它能帮到你。除了日志监控，&lt;code&gt;Frostmourne&lt;/code&gt;还可以用于运维监控，业务监控等多维度的监控，规则语法强大使得自定义性和使用场景非常丰富。&lt;/p&gt;
&lt;h3&gt;日志监控介绍&lt;/h3&gt;
&lt;p&gt;通常我们都搭建&lt;code&gt;ELK&lt;/code&gt;来搜集日志，然后对应用的日志进行埋点监控，此时需要一个灵活的可视化监控管理平台，下图是&lt;code&gt;Frostmourne&lt;/code&gt; 的日志监控方案和支持的报警渠道。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Frostmourne&lt;/code&gt;最大优点在于开箱即用，支持监控任务和数据源分开管理，嵌套使用。报警内容支持&lt;code&gt;text&lt;/code&gt;和&lt;code&gt;markdown&lt;/code&gt;两种格式，并可以配置消息的模版。以下是&lt;code&gt;Frostmourne&lt;/code&gt;功能截图&lt;br/&gt;
&lt;/p&gt;&lt;p/&gt;


&lt;h3&gt;运维监控介绍&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Frostmourne&lt;/code&gt;支持配置&lt;code&gt;Prometheus&lt;/code&gt;为数据源，通过&lt;code&gt;Promsql&lt;/code&gt;来获取数据，然后通过Javascript表达式来判断是否告警，例如查询语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;access_evaluation_duration_count{job=&quot;grafana&quot;} == 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;点击预览数据可以获得如图json格式的数据，再配置Javascript表达式来进行报警判断&lt;/p&gt;
&lt;br/&gt;
&lt;br/&gt;

&lt;p&gt;运维的维度上除了支持&lt;code&gt;Prometheus&lt;/code&gt;外，还支持&lt;code&gt;ping&lt;/code&gt;方式，且数据源支持万能的&lt;code&gt;http&lt;/code&gt;请求形式，只要返回结果是&lt;code&gt;json&lt;/code&gt;格式参数则便可以进行表达式规则判断以达到监控目的。另外运维最大的痛点是告警轰炸，举个例子，当某个节点宕机时，由于任务执行的相对频繁，告警消息会持续到达，如果关闭报警又担心错过别的报警。为解决该问题，&lt;code&gt;Frostmourne&lt;/code&gt;支持逻辑运算符表达式智能判断是否静默，避免被消息轰炸。&lt;/p&gt;

&lt;h3&gt;业务监控&lt;/h3&gt;
&lt;p&gt;在灵活的数据获取和强大的规则判断下，可以用&lt;code&gt;Frostmourne&lt;/code&gt;创造丰富的监控场景。业务场景下，可以对特定场景下进行日志埋点，以达到业务报警，比如某件商品库存低于某个值时进行报警。丰富的数据源情况下，可以直接对业务数据进行监控，例如可以直接通过&lt;code&gt;sql&lt;/code&gt;读取&lt;code&gt;mysql&lt;/code&gt;数据库，通过库里的实时或历史数据进行同比或环比来监控业务数据量是否正常，或者对每日数据统计自动进行消息播报等等。例如对支付业务进行监控：&lt;br/&gt;
&lt;/p&gt;&lt;p/&gt;
&lt;h3&gt;最后&lt;/h3&gt;
&lt;p&gt;更多使用介绍和安装方法可参考 &lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FAutohomeCorp%2Ffrostmourne&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt; 或 &lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fgitee.com%2Ftim_guai%2Ffrostmourne&quot; target=&quot;_blank&quot;&gt;gitee&lt;/a&gt;链接，文档相当详细，不妨一阅。&lt;/p&gt;
&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>42a65e94d029bc1b537fd03910bd43a9</guid>
<title>集成Flutter到现有项目，并实现使用单个FlutterEngine管理多个入口</title>
<link>https://toutiao.io/k/o3gun07</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章示例代码已上传 GitHub，地址：&lt;code&gt;https://github.com/chenglei1986/reuse_a_flutter_engine_across_screens&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1 准备工作&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集成 Flutter 到现有项目具体步骤请参考官方文档。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的项目是基于 Flutter stable 分支（在这篇文章完成当时的版本为 1.17.1-stable），那么 Android 项目 Application 模块的文件夹名称必须为 app，否则编译报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有一个工程下有多个 Application 模块，那么请将 Flutter 切换到 dev 或 master 分支，并在 gradle.properties 文件中加入&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 指定 app 模块的目录名称为 xxx&lt;/span&gt;&lt;br/&gt;flutter.hostAppProjectName=xxx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后再参考 Adding a Flutter screen to an Android app，编写 Android 端代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完成 Step 1 和 Step 2 就能运行 Flutter 代码了，只是每次启动都很慢，而且 Activity 切换动画会有肉眼可见的黑色背景，纯 Flutter 项目可以将启动页的 windowBackground 设置成启动图来提升用户体验，对于混合项目没有帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时再看 Step 3，翻一下文档相应部分如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;默认情况下，每个 FlutterActivity 都会创建一个自己的 FlutterEngine。而每个 FlutterEngine 都会有一个明显的 “预热” 时间。这就意味着启动标准的 FlutterActivity ，在 Flutter 界面显示之前，将会有一个短暂的延迟。为了将这个延迟最小化，你可以在启动 FlutterActivity 之前对 FlutterEngine 进行预加载，之后使用这个预加载的 FlutterEngine 即可。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;框架提供了方法，可以将 FlutterEngine 缓存起来，这样每次启动 FlutterActivity 都是“热启动”，用户体验上与原生基本没有差别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，对于文档中提及的混合开发方案中的所有步骤都已经完成。此时我们还面临一个最大的问题就是，缓存了 FlutterEngine 之后，无法指定入口，这一点文档也有提到，大意就是：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;FlutterEngine 是独立于 FlutterActivity 的，FlutterEngine 会在预热的时候就执行一部分 Dart 代码，如果等到 FlutterActivity 启动的时候再指定入口就晚了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2 解决多个 Flutter 页面的入口问题&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flutter 混合开发，一般都是使用 Flutter 来开发部分模块，所以原生界面启动在前。除非所有使用 Flutter 开发的模块都从同一个入口进入，否则多入口是无法逃避的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到 FlutterEngine 会在预热的时候就开始执行 Dart 代码，这就意味着，同一个 FlutterEngine 只能指定一个入口，所以我自己在做项目的时候最先想到的是，我可以缓存多个 FlutterEngine 啊。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 一次预热多个 FlutterEngine&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;/**&lt;br/&gt;&lt;span&gt; * &lt;/span&gt;初始化 FlutterEngine&lt;br/&gt;&lt;span&gt; *&lt;br/&gt; &lt;/span&gt;* @param context 上下文&lt;br/&gt;&lt;span&gt; * &lt;/span&gt;@param routes  路由名称列表&lt;br/&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; initFlutterEngine(Context context, &lt;span&gt;List&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; routes) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;String&lt;/span&gt; route : routes) {&lt;br/&gt;        FlutterEngine flutterEngine = &lt;span&gt;new&lt;/span&gt; FlutterEngine(context, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;        flutterEngine.getDartExecutor().executeDartEntrypoint(&lt;br/&gt;                DartExecutor.DartEntrypoint.createDefault()&lt;br/&gt;        );&lt;br/&gt;        &lt;span&gt;// 使用路由名称作为 engineId&lt;/span&gt;&lt;br/&gt;        FlutterEngineCache.getInstance().put(route, flutterEngine);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案可以解决问题，但是面临最大的风险与挑战就是，每初始化一个 FlutterEngine 都要消耗相应的内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据文档，在 Flutter v1.10.3 版本上使用 2015 年的低端手机测试，Android 系统中每加载一个 FlutterEngine 需要 42 MB 内存，渲染首页需要约 12MB 内存。随着版本的升级，预计消耗内存会更多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着项目的迭代升级，功能模块越来越多，这个方案的风险就越大。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 复用 FlutterEngine&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.2.1 改造 Flutter 入口代码&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个典型的 Flutter 程序如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;void&lt;/span&gt; main() {&lt;br/&gt;  runApp(MyApp());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyApp&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;StatelessWidget&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;@override&lt;/span&gt;&lt;br/&gt;  Widget build(BuildContext context) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; MaterialApp(&lt;br/&gt;      title: &lt;span&gt;&#x27;Flutter Demo&#x27;&lt;/span&gt;,&lt;br/&gt;      theme: ThemeData(&lt;br/&gt;        primarySwatch: Colors.blue,&lt;br/&gt;        visualDensity: VisualDensity.adaptivePlatformDensity,&lt;br/&gt;      ),&lt;br/&gt;      home: MyHomePage(),&lt;br/&gt;    );&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyHomePage&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;StatelessWidget&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;@override&lt;/span&gt;&lt;br/&gt;  Widget build(BuildContext context) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Scaffold(&lt;br/&gt;      appBar: AppBar(&lt;br/&gt;        title: Text(&lt;span&gt;&#x27;Default Home Page&#x27;&lt;/span&gt;),&lt;br/&gt;      ),&lt;br/&gt;      body: Container(),&lt;br/&gt;    );&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 MyApp 是继承自 StatelessWidget，所以是无法改变状态的，我们要进行如下改造：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;void&lt;/span&gt; main() =&amp;gt; runApp(MyApp());&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;/// 继承自 StatefulWidget&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyApp&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;StatefulWidget&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;@override&lt;/span&gt;&lt;br/&gt;  _MyAppState createState() =&amp;gt; _MyAppState();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;_MyAppState&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;State&lt;/span&gt;&amp;lt;&lt;span&gt;MyApp&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;/// 实例化一个 MethodChannel&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  MethodChannel _methodChannel = MethodChannel(&lt;span&gt;&#x27;com.example/method_channel&#x27;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;&lt;span&gt;/// Flutter 页面入口&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  Widget _initRoute = DefaultHomePage();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;void&lt;/span&gt; initState() {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;.initState();&lt;br/&gt;    &lt;span&gt;// 设置 MethodCallHandler 接收来自 Android 的消息&lt;/span&gt;&lt;br/&gt;    _methodChannel.setMethodCallHandler((call) &lt;span&gt;async&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;switch&lt;/span&gt; (call.method) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;setInitRoute&#x27;&lt;/span&gt;:&lt;br/&gt;          _handleInitRouteMethodCall(call);&lt;br/&gt;          &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@override&lt;/span&gt;&lt;br/&gt;  Widget build(BuildContext context) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; MaterialApp(&lt;br/&gt;      title: &lt;span&gt;&#x27;Flutter Demo&#x27;&lt;/span&gt;,&lt;br/&gt;      theme: ThemeData(&lt;br/&gt;        primarySwatch: Colors.blue,&lt;br/&gt;        visualDensity: VisualDensity.adaptivePlatformDensity,&lt;br/&gt;      ),&lt;br/&gt;      &lt;span&gt;// home 设置成变量，当接收到 Android 发过来的路由时，&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 将 home 修改以实现入口的切换&lt;/span&gt;&lt;br/&gt;      home: _initRoute,&lt;br/&gt;    );&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/// 处理来自 setInitRoute 的消息&lt;br/&gt;void _handleInitRouteMethodCall(MethodCall call) async {&lt;br/&gt;  switch (call.arguments) {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;/page_a&#x27;&lt;/span&gt;:&lt;br/&gt;      _initRoute = PageA();&lt;br/&gt;      &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;/page_b&#x27;&lt;/span&gt;:&lt;br/&gt;      _initRoute = PageB();&lt;br/&gt;      &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    default:&lt;br/&gt;      _initRoute = DefaultHomePage();&lt;br/&gt;      &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  /// 更新界面&lt;br/&gt;  setState(() {});&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/// 默认入口，空白即可&lt;br/&gt;class DefaultHomePage extends StatelessWidget {&lt;br/&gt;  @override&lt;br/&gt;  Widget build(BuildContext context) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Scaffold(&lt;br/&gt;      appBar: AppBar(&lt;br/&gt;        // 因为是路由栈的最底层，所以不会自动处理返回，我们要自己处理&lt;br/&gt;        leading: GestureDetector(&lt;br/&gt;          child: Icon(Icons.arrow_back),&lt;br/&gt;          // 退出 FlutterActivity，iOS 不支持，要单独处理&lt;br/&gt;          onTap: () =&amp;gt; SystemNavigator.pop(),&lt;br/&gt;        ),&lt;br/&gt;        title: Text(&lt;span&gt;&#x27;Default Home Page&#x27;&lt;/span&gt;),&lt;br/&gt;      ),&lt;br/&gt;      body: Container(),&lt;br/&gt;    );&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/// page_a.dart&lt;br/&gt;class PageA extends StatelessWidget {&lt;br/&gt;  @override&lt;br/&gt;  Widget build(BuildContext context) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Scaffold(&lt;br/&gt;      appBar: AppBar(&lt;br/&gt;        leading: GestureDetector(&lt;br/&gt;          child: Icon(Icons.arrow_back),&lt;br/&gt;          onTap: () =&amp;gt; onBackPressed(context),&lt;br/&gt;        ),&lt;br/&gt;        title: Text(&lt;span&gt;&#x27;Page A&#x27;&lt;/span&gt;),&lt;br/&gt;      ),&lt;br/&gt;      body: Container(),&lt;br/&gt;    );&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  void onBackPressed(BuildContext context) {&lt;br/&gt;    NavigatorState navigatorState = Navigator.of(context);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (navigatorState.canPop()) {&lt;br/&gt;      navigatorState.pop();&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      SystemNavigator.pop();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/// page_b.dart&lt;br/&gt;class PageB extends StatelessWidget {&lt;br/&gt;  @override&lt;br/&gt;  Widget build(BuildContext context) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Scaffold(&lt;br/&gt;      appBar: AppBar(&lt;br/&gt;        leading: GestureDetector(&lt;br/&gt;          child: Icon(Icons.arrow_back),&lt;br/&gt;          onTap: () =&amp;gt; onBackPressed(context),&lt;br/&gt;        ),&lt;br/&gt;        title: Text(&lt;span&gt;&#x27;Page B&#x27;&lt;/span&gt;),&lt;br/&gt;      ),&lt;br/&gt;      body: Container(),&lt;br/&gt;    );&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  void onBackPressed(BuildContext context) {&lt;br/&gt;    NavigatorState navigatorState = Navigator.of(context);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (navigatorState.canPop()) {&lt;br/&gt;      navigatorState.pop();&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      SystemNavigator.pop();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要思路是把 MyApp 改成 StatefulWidget，同时创建一个 MethodChannel 用于接收原生 App 发送的消息，当启动 FlutterActivity 时，使用该 MethodChannel 将要进入的界面路由发送过来，然后将 DefaultHomePage 替换掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为此我们还要自定义一个 FlutterActivity。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.2.2 改造 Android 端代码&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AndroidFlutterActivity&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;FlutterActivity&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; EXTRA_CACHED_ENGINE_ID = &lt;span&gt;&quot;cached_engine_id&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; EXTRA_ROUTE = &lt;span&gt;&quot;extra_route&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; EXTRA_DESTROY_ENGINE_WITH_ACTIVITY = &lt;span&gt;&quot;destroy_engine_with_activity&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    public &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; open(Context context, &lt;span&gt;String&lt;/span&gt; route) {&lt;br/&gt;        Intent intent = &lt;span&gt;new&lt;/span&gt; Intent(context, AndroidFlutterActivity.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;                .putExtra(EXTRA_CACHED_ENGINE_ID, &lt;span&gt;&quot;default_engine_id&quot;&lt;/span&gt;)&lt;br/&gt;                .putExtra(EXTRA_ROUTE, route)&lt;br/&gt;                &lt;span&gt;// Activity 销毁时保留 FlutterEngine&lt;/span&gt;&lt;br/&gt;                .putExtra(EXTRA_DESTROY_ENGINE_WITH_ACTIVITY, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;        context.startActivity(intent);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    public &lt;span&gt;void&lt;/span&gt; onFlutterUiDisplayed() {&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;.onFlutterUiDisplayed();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 设置 Flutter 界面入口，注意不要在 onCreate 方法中调用，否则&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// Flutter 入口不会更新。&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; route = getIntent().getStringExtra(EXTRA_ROUTE);&lt;br/&gt;        FlutterTools.setInitRoute(route);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意得是，AndroidFlutterActivity 向 Flutter 发送入口路由的时机。因为 FlutterEngine 在预加载的时候并不会执行 Flutter 首页的全部代码，即在界面展示出来之前，Widget 的 build 方法不会执行，所以如果在 AndroidFlutterActivity onCreate 方法中向 Flutter 发送消息，虽然能够收到，但是时机过早，当 Flutter 页面真正展示之后，还是会展示 DefaultHomePage。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FlutterTools&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    public &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; ENGINE_ID = &lt;span&gt;&quot;default_engine_id&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    public &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; ROUTE_PAGE_A = &lt;span&gt;&quot;/page_a&quot;&lt;/span&gt;;&lt;br/&gt;    public &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; ROUTE_PAGE_B = &lt;span&gt;&quot;/page_b&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    private &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; METHOD_CHANNEL = &lt;span&gt;&quot;com.example/method_channel&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    private &lt;span&gt;static&lt;/span&gt; FlutterEngine sFlutterEngine;&lt;br/&gt;    private &lt;span&gt;static&lt;/span&gt; MethodChannel sMethodChannel;&lt;br/&gt;&lt;br/&gt;    public &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; preWarmFlutterEngine(Context context) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; == sFlutterEngine) {&lt;br/&gt;            sFlutterEngine = &lt;span&gt;new&lt;/span&gt; FlutterEngine(context);&lt;br/&gt;            sFlutterEngine.getDartExecutor().executeDartEntrypoint(&lt;br/&gt;                    DartExecutor.DartEntrypoint.createDefault()&lt;br/&gt;            );&lt;br/&gt;            sMethodChannel = &lt;span&gt;new&lt;/span&gt; MethodChannel(sFlutterEngine.getDartExecutor(), METHOD_CHANNEL);&lt;br/&gt;            FlutterEngineCache.getInstance().put(ENGINE_ID, sFlutterEngine);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setInitRoute(&lt;span&gt;String&lt;/span&gt; route) {&lt;br/&gt;        sMethodChannel.invokeMethod(&lt;span&gt;&quot;setInitRoute&quot;&lt;/span&gt;, route);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; destroyEngine() {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (sFlutterEngine != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            sFlutterEngine.destroy();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原生 App 入口&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MainActivity&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AppCompatActivity&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;View&lt;/span&gt;.&lt;span&gt;OnClickListener&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    protected &lt;span&gt;void&lt;/span&gt; onCreate(&lt;span&gt;@Nullable&lt;/span&gt; Bundle savedInstanceState) {&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;.onCreate(savedInstanceState);&lt;br/&gt;        setContentView(R.layout.activity_main);&lt;br/&gt;        setSupportActionBar(findViewById(R.id.tool_bar));&lt;br/&gt;        initViews();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 预加载 FlutterEngine&lt;/span&gt;&lt;br/&gt;        FlutterTools.preWarmFlutterEngine(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private &lt;span&gt;void&lt;/span&gt; initViews() {&lt;br/&gt;        findViewById(R.id.button_page_a).setOnClickListener(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;        findViewById(R.id.button_page_b).setOnClickListener(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    public &lt;span&gt;void&lt;/span&gt; onClick(View v) {&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt; (v.getId()) {&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; R.id.button_page_a:&lt;br/&gt;                AndroidFlutterActivity.open(&lt;span&gt;this&lt;/span&gt;, FlutterTools.ROUTE_PAGE_A);&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; R.id.button_page_b:&lt;br/&gt;                AndroidFlutterActivity.open(&lt;span&gt;this&lt;/span&gt;, FlutterTools.ROUTE_PAGE_B);&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    protected &lt;span&gt;void&lt;/span&gt; onDestroy() {&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;.onDestroy();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 释放资源&lt;/span&gt;&lt;br/&gt;        FlutterTools.destroyEngine();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后看效果。模拟器上会有短暂的白屏，真机上基本看不出来。&lt;/p&gt;&lt;section&gt;&lt;span&gt;https://upload-images.jianshu.io/upload_images/23473819-8ade76a3172440ff.gif&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>