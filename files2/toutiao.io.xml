<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>35e98654a235566e1ff30563ec249071</guid>
<title>每个程序员都应该知道的 latency time</title>
<link>https://toutiao.io/k/ol06bm3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;385&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/la8s6uvJibdR3AKJ73XnRn9lyCPwrmC0ibce9eHibks0xAkDsmzVA4512KV0BRFq4JVFdRzHR4JwntE5aIK9cFpfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Photo by &lt;/span&gt;&lt;span&gt;Denny Müller&lt;/span&gt;&lt;span&gt; on &lt;/span&gt;&lt;span&gt;Unsplash&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果你是计算机系毕业的，可以不会修电脑，但应该了解几组关于 &lt;/span&gt;&lt;span&gt;“Latency time” &lt;/span&gt;&lt;span&gt;的数字，&lt;/span&gt;&lt;span&gt;&lt;span&gt;诸如&lt;/span&gt;：&lt;/span&gt;&lt;span&gt;L1 cache reference&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; c&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;he &lt;/span&gt;&lt;span&gt;reference&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Disk seek  &lt;/span&gt;&lt;span&gt;等操作的耗时情况。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2001 &lt;/span&gt;&lt;span&gt;年，&lt;/span&gt;&lt;span&gt;Peter Norvig&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;&lt;span&gt;曾任 &lt;/span&gt;&lt;span&gt;Google &lt;/span&gt;&lt;span&gt;搜索质量总监，经典教材《人工智能：一种现代方法》的作者之一&lt;/span&gt;&lt;/span&gt;&lt;span&gt;）在 “ &lt;/span&gt;&lt;span&gt;Teach Yourself Programming in Ten Years” &lt;/span&gt;&lt;span&gt;一文中，首次讨论了&lt;span&gt;计算机领域&lt;/span&gt;中 &lt;/span&gt;&lt;span&gt;memory&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Cache&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Disk&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;network&lt;/span&gt;&lt;span&gt; 等相关延时的数据（&lt;/span&gt;&lt;span&gt;&lt;span&gt;By the way&lt;/span&gt;&lt;span&gt;，“ &lt;span&gt;Teach Yourself Programming in Ten Years&lt;/span&gt;”这篇文章本身也是神文，&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt; 年过去了，依旧经典&lt;/span&gt;&lt;/span&gt;&lt;span&gt;）&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img data-backh=&quot;323&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5583333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/la8s6uvJibdR3AKJ73XnRn9lyCPwrmC0ibrUO2pRfus2ibFibUU5dic8e4ydkagbYzwUjmml1knpOYnONLFsXB7EEvA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而让这些数字再次受关注的，是 &lt;span&gt;Google &lt;/span&gt;&lt;/span&gt;&lt;span&gt;的另一位&lt;/span&gt;&lt;span&gt;&lt;span&gt;大神。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;2010 &lt;/span&gt;&lt;span&gt;年，&lt;/span&gt;&lt;span&gt;Jeff  Dean &lt;/span&gt;&lt;span&gt;在斯坦福做了一次精彩的演讲：“&lt;/span&gt;&lt;span&gt;Building Software Systems at Google and
Lessons Learned”&lt;/span&gt;&lt;span&gt;，其中又讨论了这些计算机领域的&lt;/span&gt;&lt;span&gt; latency&lt;/span&gt;&lt;span&gt; 。毕竟，要做出优秀的架构，反而需要更加关注那些基础的领域知识。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;436&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7540500736377025&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdR3AKJ73XnRn9lyCPwrmC0ibpQicichemZ12aopG9xILdl6ZYiaK9ottzS5k0dxDeyzPvkcl3vq92ticBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;随后，&lt;/span&gt;&lt;span&gt;&lt;span&gt;一名 &lt;/span&gt;&lt;span&gt;UC Berkeley&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;的学生&lt;/span&gt;&lt;/span&gt;将这些计算机系统中的 &lt;span&gt;latency time &lt;/span&gt;做了一个可交互的网页，&lt;span&gt;得出这些指标的&lt;/span&gt;&lt;span&gt;计算公式也写在网页的&lt;/span&gt;&lt;span&gt;源码里&lt;/span&gt;（&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://colin-scott.github.io/personal_website/research/interactive_latency.html&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;拖动标记年份的滚动条,  我们可以很直观地看到，不同年份下，&lt;/span&gt;&lt;span&gt;CPU cache&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;main memory&lt;/span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;network &lt;/span&gt;&lt;span&gt;这些技术发展&lt;/span&gt;&lt;span&gt;对系统延迟时间的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;246&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4254016832440704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdR3AKJ73XnRn9lyCPwrmC0ibLw0n7LrheFuicsLAeoCD2EvCf0VVGjFE5zlXILLn0HDWntRJlZJdaCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1307&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;下面是 &lt;/span&gt;&lt;span&gt;2020 &lt;/span&gt;&lt;span&gt;年&lt;/span&gt;的数据：&lt;/span&gt;&lt;/p&gt;&lt;table align=&quot;center&quot; interlaced=&quot;disabled&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;p&gt;&lt;span&gt;L1 cache reference&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;读取&lt;/span&gt; CPU &lt;/span&gt;&lt;span&gt;一级缓存 &lt;span&gt;latency&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;p&gt;&lt;span&gt;1 ns&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1 &lt;/span&gt;&lt;span&gt;纳秒&lt;/span&gt;&lt;span&gt; = 10 亿分之一秒&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;L2 cache &lt;/span&gt;&lt;span&gt;reference&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;读取&lt;/span&gt;&lt;span&gt; CPU&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 二级&lt;/span&gt;&lt;span&gt;缓存 &lt;span&gt;latency&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;left&quot;&gt;&lt;span&gt;4 ns&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;CPU Branch mispredict&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 分支错误&lt;/span&gt;&lt;span&gt;预&lt;/span&gt;&lt;span&gt;测耗时&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;3 ns&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Mutex Lo&lt;/span&gt;&lt;span&gt;ck / Unlock&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加互斥锁 / 解锁&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;17 n&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;Main memory &lt;span&gt;reference&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;读取主内存数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;100 ns&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;Compress 1 KB with Zippy&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1 k&lt;/span&gt;&lt;span&gt; 字节压缩&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;2000 ns = 2 &lt;/span&gt;&lt;span&gt;μs&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1 微秒 = 100 万分之一秒&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;Read 1,000,000 bytes sequentially from main memory&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;从主内存中顺序读取 1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;&lt;span&gt; 字节数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;left&quot;&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;μs&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;Solid State Drive (SSD) random read&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;span&gt;从 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;SSD&lt;/span&gt;&lt;span&gt;&lt;span&gt; 中读取数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;span&gt;16 &lt;/span&gt;&lt;span&gt;&lt;span&gt;μs&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;Read 1,000,000 bytes sequentially from SSD&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;从 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;SSD&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 中顺序读取 1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;&lt;span&gt; 字节数据&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;μs&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;Read 1,000,000 bytes sequentially from disk&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;从机械&lt;span&gt;硬&lt;/span&gt;盘&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;中顺序读取 1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;&lt;span&gt; 字节数据&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;25 &lt;/span&gt;&lt;span&gt;μs&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;Disk (Hard / magnetic drive) seek&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从机械硬盘中随机读取数&lt;/span&gt;&lt;span&gt;据&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;2 ms&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1 毫秒 &lt;/span&gt;&lt;span&gt;= 1000 分之一秒&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;2&quot; rowspan=&quot;1&quot;&gt;&lt;strong&gt;&lt;span&gt;网络&lt;/span&gt; &lt;span&gt;latency&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;Send 2000 bytes over commodity &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;network&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过商用网络发送 &lt;/span&gt;&lt;span&gt;2k&lt;/span&gt;&lt;span&gt; 字节数据&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;left&quot;&gt;&lt;span&gt;44 ns&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;Round trip network request in same &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;data centre&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在同一数据中心的&lt;span&gt;一&lt;/span&gt;&lt;span&gt;次&lt;/span&gt;&lt;span&gt;网&lt;/span&gt;&lt;span&gt;络请&lt;/span&gt;&lt;span&gt;求&lt;/span&gt;往返&lt;/span&gt;&lt;span/&gt;&lt;span&gt;耗时&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;left&quot;&gt;&lt;span&gt;500 &lt;span&gt;μs&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;Packet roundtrip CA to Netherlands &lt;/span&gt;&lt;span&gt;从加拿大到荷兰的&lt;span&gt;一次&lt;/span&gt;网&lt;/span&gt;&lt;span&gt;&lt;span&gt;络请&lt;/span&gt;&lt;span&gt;求&lt;/span&gt;&lt;/span&gt;&lt;span&gt;往返耗时&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;left&quot;&gt;&lt;span&gt;150 ms&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;通过分析这些变化，可以发现一些有意思的事情：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.  &lt;/span&gt;&lt;span&gt;从&lt;/span&gt;&lt;span&gt; 2006&lt;/span&gt;&lt;span&gt; 年开始，前两列操作的数值（&lt;/span&gt;&lt;span&gt;L1 cache&lt;span&gt;，&lt;/span&gt;L2 cache&lt;/span&gt;&lt;span&gt;，解压缩）基本不再变化。从另一侧面反映了 &lt;/span&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;span&gt; 芯片发展的时代烙印：从注重提升主频到往&lt;/span&gt;&lt;span&gt;多核方向发展；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.  &lt;/span&gt;&lt;span&gt;机械硬盘的&lt;/span&gt;&lt;span&gt;随机读写&lt;/span&gt;&lt;span&gt;性能&lt;/span&gt;&lt;span&gt;很差&lt;/span&gt;&lt;span&gt;，比内存慢 &lt;/span&gt;&lt;span&gt;1000 &lt;/span&gt;&lt;span&gt;倍。而异地访问的网络请求时延，又比硬盘读慢 &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt; 倍&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;span&gt;SSD&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;的随机读取速度 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;&lt;span&gt; 年间基本&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;没有提升，而顺序读取速度却从&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 50 ms&lt;/span&gt;&lt;span&gt;&lt;span&gt; 提升到 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;49 &lt;span&gt;μs&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，提升了 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;&lt;span&gt; 倍。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;在某些场景下，基于 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;SSD&lt;/span&gt;&lt;span&gt;&lt;span&gt; 的顺序读性能甚至好于内存的随机读；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.  &lt;/span&gt;&lt;span&gt;不管是在同一数据中心还是异地数据中心，&lt;/span&gt;&lt;span&gt;RTT &lt;/span&gt;&lt;span&gt;基本不变，&lt;/span&gt;&lt;span&gt;一致保持 &lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;μs&lt;/span&gt; 和 &lt;/span&gt;&lt;span&gt;150 ms&lt;/span&gt;&lt;span&gt;。假设信号在光纤中以近似光速传播，理论上 &lt;/span&gt;&lt;span&gt;RTT&lt;/span&gt;&lt;span&gt; 由物理规律决定。比如：&lt;/span&gt;&lt;span&gt;杭州到北京&lt;/span&gt;&lt;span&gt;距离大约为 &lt;/span&gt;&lt;span&gt;1500&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;km&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;RTT &lt;/span&gt;&lt;span&gt;延迟至少在： ( &lt;/span&gt;&lt;span&gt;2 * 1500 km&lt;/span&gt;&lt;span&gt; ) / (&lt;/span&gt;&lt;span&gt;300,000 &lt;/span&gt;&lt;span&gt;km/s&lt;/span&gt;&lt;span&gt;) = &lt;/span&gt;&lt;span&gt;10 &lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上， &lt;/span&gt;&lt;span&gt;Enjoy ~&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考资源：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1. http://norvig.com/21-days.html&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;2. &lt;/span&gt;&lt;span&gt;https://static.googleusercontent.com/media/research.google.com/en//people/jeff/Stanford-DL-Nov-2010.pdf&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;3. &lt;/span&gt;&lt;span&gt;https://colin-scott.github.io/personal_website/research/&lt;span&gt;interactive_latency.html&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dce718a19689e296868feac01abe5a73</guid>
<title>到达率 99.9%：闲鱼消息在高速上换引擎（集大成）</title>
<link>https://toutiao.io/k/9u3thf6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在2020年年初的时候接手了闲鱼的消息，当时的消息存在一些反馈：“闲鱼消息丢失”、“消息用户头像乱了”、“订单状态不对”。闲鱼消息的稳定性是个亟待解决的问题，我们调研了集团的一些解决方案，例如钉钉的IMPass。直接迁移的成本和风险都是比较大，包括服务端数据需要双写、新老版本兼容等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那基于闲鱼现有的消息架构和体系，如何来保证它的稳定性？治理应该从哪里开始？现在闲鱼的稳定性是什么样的？如何衡量稳定性？希望这篇文章，能让大家看到一个不一样的闲鱼消息。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;行业方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;消息的投递链路大致分为三步：发送者发送，服务端接收然后落库，服务端通知接收端。特别是移动端的网络环境比较复杂，可能你发着消息，网络突然断掉了；可能消息正在发送中，网络突然好了，需要重发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;189&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.5998336106489185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp6RjvAGqqo10esHT7l1NPgf5KLxQVo7TXqpiaegVutEq4kZqXxzENDGNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2404&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在如此复杂的网络环境下，是如何稳定可靠的进行消息投递的？对发送者来说，它不知道消息是否有送达，要想做到确定送达，就需要加一个响应机制，类似下面的响应逻辑：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;发送者发送了一条消息“Hello”，进入等待状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接收者收到这条消息“Hello”，然后告诉发送者说我已经收到这条消息了的确认信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;发送者接收到确认信息后，这个流程就算完成了，否则会重试。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;上面流程看似简单，关键是中间有个服务端转发过程，问题就在于谁来回这个确认信息，什么时候回这个确认信息。网上查到比较多的是如下一个必达模型，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;98&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.31106612685560053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp6c6RyBmibrKckz8TLpTQibmUCEEtmukrwQCm1ZjWarO37RjIWQ5Mb53qA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2964&quot; title=&quot;null&quot;/&gt;&lt;img data-ratio=&quot;0.2487708947885939&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp67cHNMGJqGtbJwtNgoy1Jx1fZZqb7mpoIAL2AsCK7ym5D4Vb4yb3I0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2034&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[发送流程]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;A向IM-server发送一个消息请求包，即msg:R1&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;IM-server在成功处理后，回复A一个消息响应包，即msg:A1&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果此时B在线，则IM-server主动向B发送一个消息通知包，即msg:N1（当然，如果B不在线，则消息会存储离线）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[接收流程]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;B向IM-server发送一个ack请求包，即ack:R2&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;IM-server在成功处理后，回复B一个ack响应包，即ack:A2&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;则IM-server主动向A发送一个ack通知包，即ack:N2&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;一个可信的消息送达系统就是靠的6条报文来保证的，有这个投递模型来决定消息的必达，中间任何一个环节出错，都可以基于这个request-ack机制来判定是否出错并重试。看下在第4.2章中，也是参考了上面这个模型，客户端发送的逻辑是直接基于http的所以暂时不用做重试，主要是在服务端往客户端推送的时候，会加上重试的逻辑。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;闲鱼消息的问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;刚接手闲鱼消息，没有稳定相关的数据，所以第一步还是要对闲鱼消息做一个系统的排查，首先对消息做了全链路埋点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;146&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.46415770609318996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp6bm4PP2xbnkicMKSDdeMkJSoZNSvexU2oKxgQH5fdgzXKy0HhdjQ6EcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2232&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于消息的整个链路，我们梳理出来了几个关键的指标：发送成功率、消息到达率、客户端落库率。整个数据的统计都是基于埋点来做的。在埋点的过程中，发现了一个很大的问题：闲鱼的消息没有一个全局唯一的ID，导致在全链路埋点的过程中，无法唯一确定这条消息的生命周期。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;消息唯一性问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img data-backh=&quot;152&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.48270787343635024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp6HOXn00WoQ8PFrwsxHibic5OzYVrBcLria8eohN35ib59Mbn3YB0icgzCYlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2718&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之前闲鱼的消息是通过3个变量来唯一确定一个消息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;•SessionID: 当前会话的ID&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;•SeqID：用户当前本地发送的消息序号，服务端是不关心此数据，完全是透传&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;•Version：这个比较重要，是消息在当前会话中的序号，以服务端为准，但是客户端也会生成一个假的version&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上图为例，当A和B同时发送消息的时候，都会在本地生成如上几个关键信息，当A发送的消息（黄色）首先到达服务端，因为前面没有其他version的消息，所以会将原数据返回给A，客户端A接收到消息的时候，再跟本地的消息做合并，只会保留一条消息。同时服务端也会将此消息发送给B，因为B本地也有一个version=1的消息，所以服务端过来的消息就会被过滤掉，这就出现消息丢失的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当B发送消息到达服务端后，因为已经有version=1的消息，所以服务端会将B的消息version递增，此时消息的version=2。这条消息发送给A，和本地消息可以正常合并。但是当此消息返回给B的时候，和本地的消息合并，会出现2条一样的消息，出现消息重复，这也是为什么闲鱼之前总是出现消息丢失和消息重复最主要的原因。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;消息推送逻辑问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;之前闲鱼的消息的推送逻辑也存在很大的问题，发送端使用http请求，发送消息内容，基本不会出问题，问题是出现在服务端给另外一端推送的时候。如下图所示，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;105&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.33362218370883884&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp6S0pvib3obVzXNr4cFcdjGwiav1wR7FuneIM2rZjjKdtQhgT8fsF25ic6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2308&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务端在给客户端推送的时候，会先判断此时客户端是否在线，如果在线才会推送，如果不在线就会推离线消息。这个做法就非常的简单粗暴。长连接的状态如果不稳定，导致客户端真实状态和服务端的存储状态不一致，就导致消息不会推送到端上。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;客户端逻辑问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;除了以上跟服务端有关系外，还有一类问题是客户端本身设计的问题，可以归结为以下几种情况：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;多线程问题 反馈消息列表页面会出现布局错乱，本地数据还没有完全初始化好，就开始渲染界面&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;未读数和小红点的计数不准确 本地的显示数据和数据库存储的不一致。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消息合并问题 本地在合并消息的时候，是分段合并的，不能保证消息的连续性和唯一性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;诸如以上的几种情况，我们首先是对客户端的代码做了梳理与重构，架构如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;253&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.804424778761062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp60IoX66ccLIK3lbrWlgVPMyibMZBvyqic3sgicT7s1EI7qmOAqNSd9l8icw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1130&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我们的解法 - 引擎升级&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;进行治理的第一步就是，解决闲鱼消息的唯一性的问题。我们也调研了钉钉的方案，钉钉是服务端全局维护消息的唯一ID，考虑到闲鱼消息的历史包袱，我们这边采用UUID作为消息的唯一ID，这样就可以在消息链路埋点以及去重上得到很大的改善。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;消息唯一性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在新版本的APP上面，客户端会生成一个uuid，对于老版本无法生成的情况，服务端也会补充上相关信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;136&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.4322250639386189&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp634CED2wJZeOr7RX3qXJWLaxxtJokN2zUjqcbfFznfyJbqV075CNf5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2346&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息的ID类似&lt;/span&gt;&lt;code&gt;&lt;span&gt;a1a3ffa118834033ac7a8b8353b7c6d9&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，客户端在接收到消息后，会先根据MessageID来去重，然后基于Timestamp排序就可以了，虽然客户端的时间可能不一样，但是重复的概率还是比较小。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span&gt;- (&lt;span&gt;void&lt;/span&gt;)combileMessages:(&lt;span&gt;NSArray&lt;/span&gt;&amp;lt;PMessage*&amp;gt;*)messages {&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 1. 根据消息MessageId进行去重&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;NSMutableDictionary&lt;/span&gt; *messageMaps = [&lt;span&gt;self&lt;/span&gt; containerMessageMap];&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (PMessage *message &lt;span&gt;in&lt;/span&gt; msgs) {&lt;br/&gt;        [messageMaps &lt;span&gt;set&lt;/span&gt;Object:message &lt;span&gt;for&lt;/span&gt;Key:message.messageId];&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 2. 消息合并后排序&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;NSMutableArray&lt;/span&gt; *tempMsgs = [&lt;span&gt;NSMutableArray&lt;/span&gt; array];&lt;br/&gt;&lt;span&gt;    [tempMsgs addObjectsFromArray:messageMaps.allValues]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;br/&gt;    [tempMsgs sortUsingComparator:^NSComparisonResult(PMessage * _Nonnull obj1, PMessage * _Nonnull obj2) {&lt;br/&gt;        &lt;span&gt;// 根据消息的timestamp进行排序&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;obj1&lt;/span&gt;&lt;span&gt;.timestamp&lt;/span&gt; &amp;gt; &lt;span&gt;obj2&lt;/span&gt;&lt;span&gt;.timestamp&lt;/span&gt;;&lt;br/&gt;    }];&lt;br/&gt;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重发重连&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img data-backh=&quot;110&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.3499005964214712&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp68WfJ4rt1420cNfRjb552pEiaHtJ6QFp3h8sh2ogNzPiccRhKvtLCDn7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2012&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;基于#2中的重发重连模型，闲鱼完善了服务端的重发的逻辑，客户端完善了重连的逻辑。&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;客户端会定时检测ACCS长连接是否联通&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务端会检测设备是否在线，如果在线会推送消息，并会有超时等待&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;客户端接收到消息之后，会返回一个Ack&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;已经有小伙伴发表了一篇文章：&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4MDUxOTI5NA==&amp;amp;mid=2247486684&amp;amp;idx=1&amp;amp;sn=9a3c17289e0fd67e61cb30fd4920cedc&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《向消息延迟说bybye：闲鱼消息及时到达方案（详细）》&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《向消息延迟说bybye：闲鱼消息及时到达方案（详细）》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，讲解了下关于网络不稳定给闲鱼消息带来的问题，在这里就不多赘述了。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据同步&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;重发重连是解决的基础网络层的问题，接下来就要看下业务层的问题，很多复杂情况是通过在业务层增加兼容代码来解决的，闲鱼消息的数据同步就是一个很典型的场景。在完善数据同步的逻辑之前，我们也调研过钉钉的一整套数据同步方案，他们主要是由服务端来保证的，背后有一个稳定的长连接保证，大致流程如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;161&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.5126262626262627&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp6tm7opyUKwrSpJhcLzNzFiawWmwEK07CPtJF1bKsDlpJF9ZJPSRy5LyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1584&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;闲鱼的服务端暂时还没有这种能力，原因详见4.5的服务端存储模型。所以闲鱼这边只能从客户端来控制数据同步的逻辑，数据同步的方式包括：拉取会话、拉取消息、推送消息等。因为涉及到的场景比较复杂，之前有个场景就是推送会触发增量同步，如果推送过多的话，会同时触发多次网络请求，为了解决这个问题，我们也做了相关的推拉队列隔离。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;216&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6849865951742627&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp6ugolstbj5P6sTGA3QAlEibOqSdDGgTDtTVnvb97D28IF4VUKjs6rsWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1492&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;客户端控制的策略就是如果在拉取的话，会先将push过来的消息加到缓存队列里面，等拉取的结果回来，会再跟本地缓存的逻辑做合并，这样就可以避免多次网络请求的问题。之前同事已经写了一篇关于推拉流控制的逻辑，&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4MDUxOTI5NA==&amp;amp;mid=2247486155&amp;amp;idx=1&amp;amp;sn=7d44cc32814283b332ea8cf78c3116df&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《如何有效缩短闲鱼消息处理时长》&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《如何有效缩短闲鱼消息处理时长》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，这里也不过多赘述了。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;客户端模型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;客户端在数据组织形式上，主要分2种：会话和消息，会话又分为虚拟节点、会话节点和文件夹节点。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;214&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6802721088435374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp659iayQ3pGOoMzLbqHj8FEtMQ4jakQ0tb28gycjgpnuntHqkYoMicLpFw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2058&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在客户端会构建上图一样的树，这棵树主要保存的是会话显示的相关信息，比如未读数、红点以及最新消息摘要，子节点更新，会顺带更新到父节点，构建树的过程也是已读和未读数更新的过程。其中比较复杂的场景是闲鱼情报社，这个其实是一个文件夹节点，它包含了很多个子的会话，这就决定了他的消息排序、红点计数以及消息摘要的更新逻辑会更复杂，服务端告知客户端子会话的列表，然后客户端再去拼接这些数据模型。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;服务端存储模型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img data-backh=&quot;203&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6446199407699901&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp6SkJIl4FqYIW5YAfcrJLC4wibsd7tJJVH4MMHDVibqxuMYbyvRDPnIRKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2026&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在4.3中大概讲了客户端的请求逻辑，历史消息会分为增量和全量域同步。这个域其实是服务端的一层概念，本质上就是用户消息的一层缓存，消息过来之后会暂存在缓存中，加速消息读取。但是这个设计也存在一个缺陷，就是域环是有长度的，最多保存256条，当用户的消息数多于256条，只能从数据库中读取。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于服务端的存储方式，我们也调研过钉钉的方案，是写扩散，优点就是可以很好地对每位用户的消息做定制化，比如钉的逻辑，缺点就是存储量很很大。闲鱼的这套解决方案，应该是介于读扩散和写扩散之间的一种解决方案。这个设计方式不仅使客户端逻辑复杂，服务端的数据读取速度也会比较慢，后续这块也可以做优化。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我们的解法 - 质量监控&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;在做客户端和服务端的全链路改造的同时，我们也对消息线上的行为做了监控和排查的逻辑。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;全链路排查&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img data-backh=&quot;99&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.3132530120481928&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp6aSdcQl2ib0b8yoKWmOvtrHSuskKuD1Ihtea0ezk3j4y332XyiaayYTIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2158&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;全链路排查是基于用户的实时行为日志，客户端的埋点通过集团实时处理引擎Flink，将数据清洗到SLS里面，用户的行为包括了消息引擎对消息的处理、用户的点击/访问页面的行为、以及用户的网络请求。服务端侧会有一些长连接推送以及重试的日志，也会清洗到SLS，这样就组成了从服务端到客户端全链路的排查的方案，详情请参考&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4MDUxOTI5NA==&amp;amp;mid=2247486473&amp;amp;idx=1&amp;amp;sn=a91aefc430776a4d0f15547016243a06&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《消息质量平台系列文章|全链路排查篇》&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《消息质量平台系列文章|全链路排查篇》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;对账系统&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;当然为了验证消息的准确性，我们还做了对账系统。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;198&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6307385229540918&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp6XnJ8GVMeNFgUmsYvhPQWT4XnGKHaxPQpsqwRpSSApMDfqvBwjJLibMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在用户离开会话的时候，我们会统计当前会话一定数量的消息，生成一个md5的校验码，上报到服务端。服务端拿到这个校验码之后再判定是否消息是正确的，经过抽样数据验证，消息的准确性基本都在99.99%。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;核心数据指标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;我们在统计消息的关键指标的时候，遇到点问题，之前我们是用用户埋点来统计的，发现会有3%~5%的数据差；所以后来我们采用抽样实时上报的数据来计算数据指标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;消息到达率=客户端实际收到的消息量/客户端应该收到的消息量&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;客户端实际收到的消息的定义为消息落库才算是 该指标不区分离线在线，取用户当日最后一次更新设备时间，理论上当天且在此时间之前下发的消息都应该收到。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;139&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.4412171507607192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1EdAU0LQrO8AzzuQ6cUUCp6vicypZBnkmBXPCVBMEJ6Xk67t1gGSQnZhlcicvbkFoj0kemST5xsibXjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1446&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;最新版本的到达率已经基本达到99.9%，从舆情上来看，反馈丢消息的也确实少了很多。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;未来规划&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;整体看来，经过一年的治理，闲鱼的消息在慢慢的变好，但还是存在一些待优化的方面：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;•现在消息的安全性不足，容易被黑产利用，借助消息发送一些违规的内容。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;•消息的扩展性较弱，增加一些卡片或者能力就要发版，缺少了动态化和扩展的能力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;•现在底层协议比较难扩展，后续还是要规范一下协议。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;•从业务角度看，消息应该是一个横向支撑的工具性或者平台型的产品，规划可以快速对接二方和三方的快速对接。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在2021年，我们会持续关注消息相关的用户舆情，希望闲鱼消息能帮助闲鱼用户更好的完成二手交易。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;[参考资料]&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;http://www.52im.net/thread-464-1-1.html&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;闲不住？来闲鱼！&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7870968&quot; data-type=&quot;gif&quot; data-w=&quot;155&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/HvyYm0PI63T6ypu7tGic9rQS8shV87p7VOgVr8CqsPWHNJYLSl5F44KzGnNoyHNrgDmaT6GP32Cpoe2AeO5ZthA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;PICK ME&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;闲鱼是阿里巴巴旗下品牌，是中国最大的闲置交易平台，于2014年成立至今，是继淘宝、天猫之后，阿里巴巴正在催生的第三个万亿级平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;闲鱼技术部不断在驱动业务变革，通过创新追寻更多价值。从出版书籍、峰会发声，到开源专利、海外传播。闲不住，上闲鱼——技术团队对极致的探索与深耕是我们的底气。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 立即加入 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、招&lt;/span&gt;&lt;span&gt;&lt;strong&gt;项目经理PMO&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;/客户端/服务端/前端/数据+算法/质量工程师&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、发简历给guicai.gxy@alibaba-inc.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、您还可以在头条、知乎、掘金、facebook、twitter找到我们&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c06242eb61d43d3593cfa3561d2599ab</guid>
<title>实战：Express 模拟 CSRF 攻击</title>
<link>https://toutiao.io/k/sgmfmzm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 每日前端夜话 第483篇&lt;br/&gt;// 正文共：2400 字&lt;br/&gt;// 预计阅读时间：10 分钟&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ttJazfuZaRgN8tjWDn3KB4wIGsia3Ef9VcJ774P6AMe15Ry7iboYyjXRxv7YcFrX8D2HA2L74g1NXulFZh42vlKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5973333333333334&quot; data-w=&quot;750&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CSRF攻击&lt;/strong&gt; 是前端领域常见的安全问题，概念方面不再赘述，可以参考维基百科。对于这些概念，包括名词定义、攻击方式、解决方案等估计大家都看过不少，但留下印象总是很模糊，要动手操作一番才能加深印象并能真正理解，所以我决定动手实现一个 CSRF 的攻击场景，并通过演示的方式讲解 CSRF 的防范手段。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CSRF 攻击流程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CSRF 模拟攻击&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CSRF 防范方法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CSRF 攻击流程&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设用户先通过 bank.com/auth 访问银行网站A的授权接口，通过认证后拿到A返回的 cookie: userId=ce032b305a9bc1ce0b0dd2a，接着携带 cookie 访问 bank.com/transfer?number=15000&amp;amp;to=Bob 银行A的转账接口转给Bob 15000元，然后A返回 success 表示转账成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;钓鱼网站B(hack.com)通过邮件或者广告等方式引诱小明访问，并返回给小明恶意的 HTML 攻击代码，HTML 中会包含发往银行A的敏感操作：bank.com/transfer?number=150000&amp;amp;to=Jack ，此时浏览器会携带A的 cookie 发送请求，A拿到请求后，只通过 cookie 判断是个合法操作，于是在小明不知情的情况下，账户里150000元被转给了Jack，即恶意攻击者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就完成了一次基本的 CSRF 攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CSRF 攻击流程图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SM05zvmibH7KMMEiaf2ribSfRDkm3qEvzXXzVReApMvdSwaXxyzNhhr8ibBE3ngAuaibL0Pd0XtqXWIGlAh4lFibhD0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6138888888888889&quot; data-w=&quot;1080&quot;/&gt;&lt;span/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果现在看不懂没关系，可以看完演示再回头看此图就会恍然大悟了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CSRF 模拟攻击&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先通过 express 搭建后端，以模拟 CSRF 攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动银行 A 的服务器，端口 3001，包含 3 个接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;app.use(&lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, indexRouter);&lt;br/&gt;app.use(&lt;span&gt;&#x27;/auth&#x27;&lt;/span&gt;, authRouter);&lt;br/&gt;app.use(&lt;span&gt;&#x27;/transfer&#x27;&lt;/span&gt;, transferRouter);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;authRouter:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;router.get(&lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;(req, res, next) {&lt;br/&gt;  res.cookie(&lt;span&gt;&#x27;userId&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;ce032b305a9bc1ce0b0dd2a&#x27;&lt;/span&gt;, { expires: new Date(Date.now() + 900000) })&lt;br/&gt;  res.end(&lt;span&gt;&#x27;ok&#x27;&lt;/span&gt;)&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;transferRouter：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;router.get(&lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;(req, res, next) {&lt;br/&gt;  const { query } = req;&lt;br/&gt;  const { userId } = req.cookies;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(userId){&lt;br/&gt;    res.send({&lt;br/&gt;      status: &lt;span&gt;&#x27;transfer success&#x27;&lt;/span&gt;,&lt;br/&gt;      transfer: query.number&lt;br/&gt;    })&lt;br/&gt;  }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;    res.send({&lt;br/&gt;      status: &lt;span&gt;&#x27;error&#x27;&lt;/span&gt;,&lt;br/&gt;      transfer: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;    })&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 ejs 提供银行转账页面：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html lang=&lt;span&gt;&quot;en&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;  &amp;lt;meta charset=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;  &amp;lt;meta name=&lt;span&gt;&quot;viewport&quot;&lt;/span&gt; content=&lt;span&gt;&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;  &amp;lt;title&amp;gt;&lt;br/&gt;    &amp;lt;%= title %&amp;gt;&lt;br/&gt;  &amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;  &amp;lt;h2&amp;gt;&lt;br/&gt;    转账&lt;br/&gt;  &amp;lt;/h2&amp;gt;&lt;br/&gt;  &amp;lt;script&amp;gt;&lt;br/&gt;    const h2 = document.querySelector(&lt;span&gt;&#x27;h2&#x27;&lt;/span&gt;);&lt;br/&gt;    h2.addEventListener(&lt;span&gt;&#x27;click&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;      fetch(&lt;span&gt;&#x27;/transfer?number=15000&amp;amp;to=Bob&#x27;&lt;/span&gt;).&lt;span&gt;then&lt;/span&gt;(res =&amp;gt; {&lt;br/&gt;        console.log(res.json());&lt;br/&gt;      })&lt;br/&gt;    })&lt;br/&gt;  &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设钓鱼网站 B 提供的恶意代码为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html lang=&lt;span&gt;&quot;en&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;  &amp;lt;meta charset=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;  &amp;lt;meta name=&lt;span&gt;&quot;viewport&quot;&lt;/span&gt; content=&lt;span&gt;&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;div class=&lt;span&gt;&quot;wrapper&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;  &amp;lt;iframe src=&lt;span&gt;&quot;http://bank.com/transfer?number=150000&amp;amp;to=Jack&quot;&lt;/span&gt; frameborder=&lt;span&gt;&quot;0&quot;&lt;/span&gt;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;  &amp;lt;script&amp;gt;&lt;br/&gt;&lt;br/&gt;  &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并将其启动在3002端口，再通过 Whistle 进行域名映射，因为两者都是 Localhost 域名，而 Cookie 不区分端口，所以需要区分域名。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SM05zvmibH7KMMEiaf2ribSfRDkm3qEvzXXKmdIgVPt64giaMWW2XLmbAicQkzJkN8mVbPQ8eJhCyqZGO830q8nPfXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.23478260869565218&quot; data-w=&quot;230&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先打开 Firefox 浏览器(暂时不用 Chrome )，访问银行 A 的 /auth获得授权：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SM05zvmibH7KMMEiaf2ribSfRDkm3qEvzXXdYfPwib3H2qyUia1ANagJicPu2L3jice545e2RCf8qqv0pOaVfO3spW6dA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9563543003851092&quot; data-w=&quot;779&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后通过点击&lt;strong&gt;转账&lt;/strong&gt;按钮发送请求 http://bank.com/transfer?number=15000&amp;amp;to=Bob 进行转账操作：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SM05zvmibH7KMMEiaf2ribSfRDkm3qEvzXXRgbT4ba5WsicK8EGBWejv5KgrwF2Xyhua6ClkrVWagQPrNvtC5nSpNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9563543003851092&quot; data-w=&quot;779&quot;/&gt;&lt;span/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户收到诱惑进入了 hack 网站，hack 网站首页有一个发往银行A的请求 http://bank.com/transfer?number=150000&amp;amp;to=Jack ,这个请求可以放在 iframe、img、script 等的 src 里面。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SM05zvmibH7KMMEiaf2ribSfRDkm3qEvzXXIzibLWia7VfokpsIMYDZL2WqC6JCtJvpfjwfteegiavSqfEtAicBmrTR3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9029126213592233&quot; data-w=&quot;824&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到请求携带 cookie，并成功转账，这样一次 CSRF 攻击就完成了。当然这是一次简单的 GET 请求的攻击，POST 请求攻击可以通过自动提交表单实现，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;form action=&lt;span&gt;&quot;bank.com/transfer&quot;&lt;/span&gt; method=POST&amp;gt;&lt;br/&gt;    &amp;lt;input &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;hidden&quot;&lt;/span&gt; name=&lt;span&gt;&quot;number&quot;&lt;/span&gt; value=&lt;span&gt;&quot;150000&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;input &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;hidden&quot;&lt;/span&gt; name=&lt;span&gt;&quot;to&quot;&lt;/span&gt; value=&lt;span&gt;&quot;Jack&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;&amp;lt;/form&amp;gt;&lt;br/&gt;&amp;lt;script&amp;gt; document.forms[0].submit(); &amp;lt;/script&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面可以看出，CSRF 攻击主要特点是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;发生在第三方域名(hack.com)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;攻击者只能使用 cookie 而拿不到具体的 cookie。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对以上特点，我们就能进行对应的防范了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CSRF 防范方法&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CSRF 防范方法通常有以下几种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;阻止不同域的访问&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;同源检测。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Samesite Cookie。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;提交时要求附加本域才能获取的信息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;添加 CSRF Token。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;双重 Cookie验证。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;同源检测 - 通过 Origin 和 Referer 确定来源域名&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对第一个特点进行域名检查，HTTP 请求时会携带这两个 Header，用于标记来源域名，如果请求来源不是本域，直接进行拦截。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SM05zvmibH7KMMEiaf2ribSfRDkm3qEvzXXlJibxqeXpu6fJHdQRZ8FW5utpnFZTCHx9H8dTOIANadJvSjia8vmozDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.8895631067961165&quot; data-w=&quot;824&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这两个 Header 也是可以不携带的，所以我们的策略是校验如果两个 Header 不存在或者存在但不是本域则阻拦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改 transferRouter 代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const csrfGuard = require(&lt;span&gt;&#x27;../middleware/csrfGuard&#x27;&lt;/span&gt;)&lt;br/&gt;/* GET users listing. */&lt;br/&gt;router.get(&lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, csrfGuard, &lt;span&gt;function&lt;/span&gt;(req, res, next) {&lt;br/&gt;  const { query } = req;&lt;br/&gt;  const { userId } = req.cookies;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(userId){&lt;br/&gt;    res.send({&lt;br/&gt;      status: &lt;span&gt;&#x27;transfer success&#x27;&lt;/span&gt;,&lt;br/&gt;      transfer: query.number&lt;br/&gt;    })&lt;br/&gt;  }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;    next()&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;router.get(&lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;(req, res, next) {&lt;br/&gt;  res.send({&lt;br/&gt;    status: &lt;span&gt;&#x27;error&#x27;&lt;/span&gt;,&lt;br/&gt;    transfer: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;csrfGuard.js:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;module.exports = &lt;span&gt;function&lt;/span&gt;(req, res, next){&lt;br/&gt;  const [Referer, Origin] = [req.get(&lt;span&gt;&#x27;Referer&#x27;&lt;/span&gt;), req.get(&lt;span&gt;&#x27;Origin&#x27;&lt;/span&gt;)]&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(Referer &amp;amp;&amp;amp; Referer.indexOf(&lt;span&gt;&#x27;bank.com&#x27;&lt;/span&gt;) &amp;gt; 0){&lt;br/&gt;    next();&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(Origin &amp;amp;&amp;amp; Origin.indexOf(&lt;span&gt;&#x27;bank.com&#x27;&lt;/span&gt;) &amp;gt; 0){&lt;br/&gt;    next();&lt;br/&gt;  }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;    next(&lt;span&gt;&#x27;route&#x27;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SM05zvmibH7KMMEiaf2ribSfRDkm3qEvzXXiaO77jicqhauYicMhXJPficiac0JL1f38H4jkjC4TPcPktDFSB8vaYRVodQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9029126213592233&quot; data-w=&quot;824&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;Samesite Cookie&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在敏感 cookie 上携带属性 Samesite：Strict 或 Lax，可以避免在第三方不同域网站上携带 cookie，具体原因可以参考阮一峰老师的Cookie 的 SameSite 属性。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// authRouter.js&lt;br/&gt;router.get(&lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;(req, res, next) {&lt;br/&gt;  res&lt;br/&gt;  .cookie(&lt;span&gt;&#x27;userId&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;ce032b305a9bc1ce0b0dd2a&#x27;&lt;/span&gt;, { expires: new Date(Date.now() + 900000), sameSite: &lt;span&gt;&#x27;lax&#x27;&lt;/span&gt; })&lt;br/&gt;  res.end(&lt;span&gt;&#x27;ok&#x27;&lt;/span&gt;)&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看 bank.com cookie:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SM05zvmibH7KMMEiaf2ribSfRDkm3qEvzXX4yv4IWQUD5vYgyw5ia5o36aQpyKsqyiayhktWogNhkBkXEkW5lPwiamdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7662203913491246&quot; data-w=&quot;971&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再次访问 hack.com，发现转账链接并未携带 cookie：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SM05zvmibH7KMMEiaf2ribSfRDkm3qEvzXXbdQrkiaEBNTkVqaAVRdqAr8FRzmKIlOfyqwIRHlSprwFDlHrkwaaJFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7662203913491246&quot; data-w=&quot;971&quot;/&gt;&lt;span/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就达到了防范的目的，兼容性 目前来看还可以，虽然没有达到完美覆盖，但大部分浏览器也都支持了&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;PS: 前面之所以没有使用 Chrome 浏览器做实验，是因为从 Chrome 80 版本起，Samesite 被默认设置为了 Lax，而 Firefox 仍然为 None。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;添加 CSRF Token&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先服务器生成一个动态的 token，传给用户，用户再次提交或者请求敏感操作时，携带此 token，服务端校验通过才返回正确结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改写 indexRouter，使其返回 token 给页面：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var express = require(&lt;span&gt;&quot;express&quot;&lt;/span&gt;);&lt;br/&gt;var router = express.Router();&lt;br/&gt;const jwt = require(&lt;span&gt;&quot;jsonwebtoken&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;router.get(&lt;span&gt;&quot;/&quot;&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt; (req, res, next) {&lt;br/&gt;    res.render(&lt;span&gt;&quot;index&quot;&lt;/span&gt;, { title: &lt;span&gt;&quot;Express&quot;&lt;/span&gt;, token: jwt.sign({&lt;br/&gt;      username: &lt;span&gt;&#x27;ming&#x27;&lt;/span&gt;&lt;br/&gt;    }, &lt;span&gt;&#x27;key&#x27;&lt;/span&gt;, {&lt;br/&gt;      expiresIn: &lt;span&gt;&#x27;1d&#x27;&lt;/span&gt;&lt;br/&gt;    }) });&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;module.exports = router;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端页面：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// index.ejs&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;  &amp;lt;h2&amp;gt;&lt;br/&gt;    转账&lt;br/&gt;  &amp;lt;/h2&amp;gt;&lt;br/&gt;  &amp;lt;span id=&lt;span&gt;&#x27;token&#x27;&lt;/span&gt; data-token=&amp;lt;%= token %&amp;gt;&amp;gt;&amp;lt;/span&amp;gt;&lt;br/&gt;  &amp;lt;script&amp;gt;&lt;br/&gt;    const h2 = document.querySelector(&lt;span&gt;&#x27;h2&#x27;&lt;/span&gt;);&lt;br/&gt;    const tokenElem = document.querySelector(&lt;span&gt;&#x27;#token&#x27;&lt;/span&gt;);&lt;br/&gt;    const token = tokenElem.dataset.token;&lt;br/&gt;    h2.addEventListener(&lt;span&gt;&#x27;click&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;      fetch(&lt;span&gt;&#x27;/transfer?number=15000&amp;amp;to=Bob&amp;amp;token=&#x27;&lt;/span&gt; + token).&lt;span&gt;then&lt;/span&gt;(res=&amp;gt;{&lt;br/&gt;        console.log(res.json());&lt;br/&gt;      })&lt;br/&gt;    })&lt;br/&gt;  &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将 transferRouter 的验证中间件改成 token 验证：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const tokenVerify = require(&lt;span&gt;&#x27;../middleware/tokenVerify&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;router.get(&lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, tokenVerify, &lt;span&gt;function&lt;/span&gt;(req, res, next) {&lt;br/&gt;  const { query } = req;&lt;br/&gt;  const { userId } = req.cookies;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(userId){&lt;br/&gt;    res.send({&lt;br/&gt;      status: &lt;span&gt;&#x27;transfer success&#x27;&lt;/span&gt;,&lt;br/&gt;      transfer: query.number&lt;br/&gt;    })&lt;br/&gt;  }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;    next()&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JWT 验证：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const jwt = require(&lt;span&gt;&quot;jsonwebtoken&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;module.exports = &lt;span&gt;function&lt;/span&gt;(req, res, next){&lt;br/&gt;  const { token } = req.query;&lt;br/&gt;  jwt.verify(token,&lt;span&gt;&#x27;key&#x27;&lt;/span&gt;, (err, decode)=&amp;gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(err){&lt;br/&gt;      next(&lt;span&gt;&#x27;route&#x27;&lt;/span&gt;)&lt;br/&gt;    }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;      console.log(decode);&lt;br/&gt;      next()&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;携带 token 正常访问成功：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SM05zvmibH7KMMEiaf2ribSfRDkm3qEvzXXRehOj3AtACJHicY7UWGmiaqqQTqOGj7fWHI2kQuIug68SDEtycy9Q2gQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.8465909090909091&quot; data-w=&quot;880&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;钓鱼网站拿不到 token 所以攻击失败：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SM05zvmibH7KMMEiaf2ribSfRDkm3qEvzXXiaO77jicqhauYicMhXJPficiac0JL1f38H4jkjC4TPcPktDFSB8vaYRVodQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9029126213592233&quot; data-w=&quot;824&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;以上为加深理解而写的代码，而在生产环境中，node 可以使用 csurf中间件来防御 csrf 攻击&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;双重Cookie验证&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置一个专用 cookie，因为攻击者拿不到 cookie，所以将 cookie 种到域名的同时，访问敏感操作也需要携带，攻击者带不上 cookie，就达到了防范的目的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// authRouter.js&lt;br/&gt;const randomString = require(&lt;span&gt;&#x27;random-string&#x27;&lt;/span&gt;);&lt;br/&gt;/* GET users listing. */&lt;br/&gt;router.get(&lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;(req, res, next) {&lt;br/&gt;  res&lt;br/&gt;  .cookie(&lt;span&gt;&#x27;userId&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;ce032b305a9bc1ce0b0dd2a&#x27;&lt;/span&gt;, { expires: new Date(Date.now() + 900000) })&lt;br/&gt;  .cookie(&lt;span&gt;&#x27;csrfcookie&#x27;&lt;/span&gt;, randomString(), { expires: new Date(Date.now() + 900000) })&lt;br/&gt;  res.end(&lt;span&gt;&#x27;ok&#x27;&lt;/span&gt;)&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bank.com 银行转账页面：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &amp;lt;script&amp;gt;&lt;br/&gt;    const h2 = document.querySelector(&lt;span&gt;&#x27;h2&#x27;&lt;/span&gt;);&lt;br/&gt;    const csrfcookie = getCookie(&lt;span&gt;&#x27;csrfcookie&#x27;&lt;/span&gt;)&lt;br/&gt;    h2.addEventListener(&lt;span&gt;&#x27;click&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;      fetch(&lt;span&gt;&#x27;/transfer?number=15000&amp;amp;to=Bob&amp;amp;csrfcookie=&#x27;&lt;/span&gt; + csrfcookie).&lt;span&gt;then&lt;/span&gt;(res =&amp;gt; {&lt;br/&gt;        console.log(res.json());&lt;br/&gt;      })&lt;br/&gt;    })&lt;br/&gt;  &amp;lt;/script&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证中间件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// doubleCookie.js &lt;br/&gt;module.exports = &lt;span&gt;function&lt;/span&gt;(req, res, next){&lt;br/&gt;  const queryCsrfCookie = req.query.csrfcookie&lt;br/&gt;  const realCsrfCookie = req.cookies.csrfcookie;&lt;br/&gt;  console.log(queryCsrfCookie, realCsrfCookie);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(queryCsrfCookie === realCsrfCookie){&lt;br/&gt;    next()&lt;br/&gt;  }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;    next(&lt;span&gt;&#x27;route&#x27;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;银行 bank.com:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SM05zvmibH7KMMEiaf2ribSfRDkm3qEvzXX7CJMrymIdsxwc3JnKOygSru2RektqeIia3WVRhMV9p5dmYt3ZOulnhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7662203913491246&quot; data-w=&quot;971&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 hack.com 拿不到 csrfcookie 所以验证不通过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法也是很有效的，比如请求库 axios 就是用的这种方式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里大家是不是已经明白了 CSRF 攻击的原因所在，并可以提出针对性的解决方案了呢，防范关键其实就是防止其他人冒充你去做只有你能做的敏感操作，与此同时希望大家对于这类抽象性的问题可以自己动手敲一下，模拟一遍，用造重复轮子的方法去理解，动手比动眼管用的多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上过程和代码仅仅为帮助学习并做演示使用，如果用于生产力还是需要更成熟的解决方案。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt; 强力推荐前端面试刷题神器&lt;/strong&gt;&lt;span/&gt;&lt;/center&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/ttJazfuZaRhicyXjTlZhd1BYzPSicArYzVjZeXNfvbSXIEBKCC5IUq8iacDUbwtooY4Jqz2G6MrRVoqRkXoocO01w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.5555555555555556&quot; data-w=&quot;639&quot;/&gt;&lt;/figure&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3NzIzMDY0NA==&amp;amp;mid=2247489495&amp;amp;idx=2&amp;amp;sn=c1299551dd5bf4ec8e18ea6880f3a82b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ttJazfuZaRiaibmffk3MM8pQDGeMgP3avSPSia3K9AFfOhSaa7rADybxYm0MksaiaqsZy1hH4KiaAtMfSwsZBeLBBBg/640?wx_fmt=png&quot; title=&quot;![精彩文章回顾,点击直达&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5238095238095238&quot; data-w=&quot;945&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;figcaption&gt;&lt;span/&gt;精彩文章回顾,点击直达&lt;/figcaption&gt;&lt;/figure&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ttJazfuZaRiaLn2kDibyZPS4qzOXvOgvu5llnTZUodVhKpd6X19rnKTAiaxBHibyicwRia7XUBJWdgSyNuPuOQQmya2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.257847533632287&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ttJazfuZaRhwoteJKscOG5NksdJXO1Unl0iaoGCuHnfHS1BQlXCa5FsLHuicQBNiaicLrluClictIQZpCHIAbR2e5Yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7272727272727273&quot; data-w=&quot;198&quot;/&gt;&lt;span/&gt;&lt;/figure&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>abe65041ce666a68346d15728f868baf</guid>
<title>机器学习 KNN 算法</title>
<link>https://toutiao.io/k/wdedm1k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;seo&quot;&gt;
        &lt;p class=&quot;content&quot;&gt;
                            **本节内容：**
[TOC]
## 0.分类算法
|   算法种类  |  KNN   |  朴素贝叶斯 | 决策树 | 支持向量机 | 神经网络 |
| --- | --- |  --- | --- | --- | --- |
|  优点  |  1.简单易用&amp;lt;br/&amp;gt;2.模型训练时间短&amp;lt;br/&amp;gt;3.预测效果好&amp;lt;br/&amp;gt;4.对异常值不敏感&amp;lt;br/&amp;gt;5.无数据输入假定   |    1.接收大量数据训练和查询时所具备的高速度，支持增量式训练&amp;lt;br/&amp;gt;2.对分类器实际学习的解释相对简单  |  1.很容易解释一个受训模型，算法将最为重要的判断因素都很好的安排在了靠近树的根部位置&amp;lt;br/&amp;gt;2.能够同时处理分类数据和数值数据&amp;lt;br/&amp;gt;3.很容易处理变量之间的相互影响&amp;lt;br/&amp;gt;4.适合小规模数据  | 1.通过将分类输入转化为数值输入，可以令支持向量同时支持分类数据和数值数据&amp;lt;br/&amp;gt;2.适合大规模数据 | 1.能够处理复杂的非线性函数，并且能发现不同输入间的依赖关系&amp;lt;br/&amp;gt;2.支持增量式训练 |
|  缺点  |   1.对内存要求较高&amp;lt;br/&amp;gt;2.预测阶段可能很慢&amp;lt;br/&amp;gt;3.对不相关的功能和数据规模敏感&amp;lt;br/&amp;gt;4.计算复杂度搞、空间复杂度高  |  1.无法处理基于特征组合所产生的变化结果  | 1.不擅长对数值数据进行预测&amp;lt;br/&amp;gt;2.不支持增量式训练 | 1.针对每个数据集的最佳核变函数及其相应的参数都是不一样的，而且每当遇到新的数据集都必须重新确定这些函数及其参数&amp;lt;br/&amp;gt;2.黑盒技术，由于存在高维空间的变换，SVM的分类过程更加难以解释 | 1.黑盒方法，无法确定推导过程&amp;lt;br/&amp;gt;2.选择训练数据的比率与问题相适应的网络规模方面，没有明确的规则可以遵循（选择过高的训练数据比率有可能导致网络对噪声数据产生过度归纳的现象，而选择过低的训练比率，则意味着除了已知数据，网络有可能不会再进一步学习了） |

## 1.KNN算法概述

* KNN是最简单的分类算法之一，也是最常见的分类算法之一
* KNN算法是&amp;lt;strong style=&quot;color:red&quot;&amp;gt;有监督学习&amp;lt;/strong&amp;gt;中的分类算法
* KNN算法和&amp;lt;strong style=&quot;color:red&quot;&amp;gt;无监督学习算法K-means&amp;lt;/strong&amp;gt;有些相像，但是却有本质区别
* 使用数据范围：&amp;lt;strong style=&quot;color:red&quot;&amp;gt;数值型和标称型&amp;lt;/strong&amp;gt;
* 通常K是不大于20的整数

## 2.KNN算法介绍

KNN全称为 K Nearest Neighbors，意思是K个最近的邻居。从名字可知，K的取值是至关重要的。
KNN原理：当预测一个新的值x的时候，根据它距离最近的K个点是什么类别来判断x属于哪个类别。

&amp;lt;strong style=&quot;color:green&quot;&amp;gt;【敲黑板，划重点】&amp;lt;/strong&amp;gt;

如图，绿色的点是我们要预测的那个点。
假设K=3，那么KNN算法就会找到与它（绿色）距离最近的三个点（为了方便查看，此处用虚线圆圈圈出来），看看哪种类别多一些，比如这个例子中是蓝色三角形多一些，所以绿色的点就被归类为蓝色三角形。
![](https://img.kancloud.cn/5c/e5/5ce5cfa231bb9bb5aa0b112d00c252dc_844x378.png)

但是，当K=5时，判断结果就不一样了。
这次，圈内的红色圆更多一些，所以绿色的点就被归类为红色圆。
![](https://img.kancloud.cn/40/e3/40e3fa587dae22899b7d5a631370bb09_919x380.png)

综上，我们知道，KNN算法中，K的取值是至关重要的。那我们该如何去选取K值，又如何计算点之间的距离呢？

### 2.1 距离计算
度量空间中点的距离，有几种常见的度量方式：
* 曼哈顿距离计算
* 欧氏距离计算

![](https://img.kancloud.cn/ad/24/ad24b44cfd26a52c70e9a166d67aaf1e_853x461.png)

通常情况下，KNN算法种所使用的是欧式距离：
![](https://img.kancloud.cn/92/bc/92bccbc67e309d34d92ec1631fb9645c_191x32.png)
推演到多维空间，则公式变成：
有两个元素A和B，每个元素拥有n维属性，
A (x1, x2, x3, ..., xn)&amp;#13;
B (y1, y2, y3, ..., yn)
则距离公式变为：
![](https://img.kancloud.cn/7e/1c/7e1cdf4db830bacb3e8eb0d363e2575c_469x56.png)

此时，我们知道了如何计算元素间距离。
而KNN算法的最简单粗暴的方式，就是将所有点距离进行计算，然后保存并排序，然后筛选前面K个值看看哪些类别比较多，说白了，也就是个top K的问题。

但是，通常我们也会接触一些数据结构来辅助获取top K，比如最大堆（有兴趣可以自行百度：[https://blog.csdn.net/cdnight/article/details/11650983](https://blog.csdn.net/cdnight/article/details/11650983)）

### 2.2 K值选择

K值的选择是直接影响到我们分类结果的，那么该如何去确定K值呢？

此时，我们就会采用&amp;lt;strong style=&quot;color:red&quot;&amp;gt;交叉验证&amp;lt;/strong&amp;gt;（将样本数据按照一定比例，拆分出训练集和验证集，比如6：4比例），然后从选取一个较小的K值开始，不断增加K的值，然后计算验证集合的方差，最终找到一个比较合适的K值。

通常，通过交叉验证计算方差后，你会得到大致类似于下图：
![](https://img.kancloud.cn/54/b1/54b1e6fced957d00abdbfc508c53897b_805x374.png)

* 当你增大K的时候，一般错误率会先降低，因为有周围更多的样本可以借鉴了，分类效果会变好；
* 和K-means不一样，当K值更大的时候，KNN错误率会更好
    * 比如说你一共就35个样本，当你K增大到30的时候，KNN基本就没意义了。

所以选择K值的时候可以选择一个较大的临界K值，当它继续增大或者减小的时候，错误率都会上升。如图中的K=10

### 2.3特征归一化的必要性
首先举例如下，我用一个人身高(cm)与脚码（尺码）大小来作为特征值，类别为男性或者女性。我们现在如果有5个训练样本，分布如下：
A \[(179,42),男\] 
B \[(178,43),男\] 
C \[(165,36)女\] 
D \[(177,42),男\]
E \[(160,35),女\]

通过上述训练样本，我们看出问题了吗？

很容易看到第一维身高特征是第二维脚码特征的4倍左右，那么在进行距离度量的时候，&amp;lt;strong style=&quot;color:red;&quot;&amp;gt;我们就会偏向于第一维特征。&amp;lt;/strong&amp;gt;这样造成俩个特征并不是等价重要的，最终可能会导致距离计算错误，从而导致预测错误。
&amp;lt;br/&amp;gt;
口说无凭，举例如下：
现在我来了一个测试样本 F(167,43)，让我们来预测他是男性还是女性，我们采取k=3来预测。

下面我们用欧式距离分别算出F离训练样本的欧式距离，然后选取最近的3个，多数类别就是我们最终的结果，计算如下：
![](https://img.kancloud.cn/25/c1/25c1d1cf0dee349f1370ce6a957b9ec6_520x294.png)

由计算可以得到，最近的前三个分别是C,D,E三个样本，那么由C,E为女性，D为男性，女性多于男性得到我们要预测的结果为**女性**。

&amp;lt;strong style=&quot;color:green&quot;&amp;gt;Q：&amp;lt;/strong&amp;gt;这样问题就来了，一个女性的脚43码的可能性，远远小于男性脚43码的可能性，那么为什么算法还是会预测F为女性呢？
&amp;lt;strong style=&quot;color:green&quot;&amp;gt;A：&amp;lt;/strong&amp;gt;那是因为由于各个特征量纲的不同，在这里导致了身高的重要性已经远远大于脚码了，这是不客观的。所以我们应该让每个特征都是同等重要的！这也是我们要归一化的原因！

&amp;lt;strong style=&quot;color:red;&quot;&amp;gt;归一化公式如下：&amp;lt;/strong&amp;gt;
![](https://img.kancloud.cn/6a/07/6a0758d42769952f70d43ede24c8a69f_1251x402.png)

## 3.KNN特点

&amp;lt;strong style=&quot;color:green&quot;&amp;gt;KNN是一种非参、惰性的算法模型。&amp;lt;/strong&amp;gt;
* 非参
    *  并不是说该模型不需要参数，而是意味着这个模型不会对数据做出任何的假设，与之相对应的是线性回归（我们总会先假设线性回归是一条直线）。
    *  也就是说KNN建立的模型结构是根据数据来决定的，这也比较符合现实的情况，毕竟在现实中的情况往往与理论上的假设是不相符的。
* 惰性
    *  逻辑回归需要先对数据进行大量训练，最后才会得到一个算法模型。
    * KNN算法却不需要，它没有明确的训练数据的过程，或者说这个过程很快。

## 4.优点 &amp;amp; 缺点？？？

### 4.1优点：
    1. 简单易用，相比其他算法，KNN算是比较简洁明了的算法。即使没有很高的数学基础也能搞清楚它的原理
    2. 模型训练时间快（KNN算法是惰性的）
    3. 预测效果好
    4. 对异常值不敏感
### 4.2缺点：
    1. 对内存要求较高，因为该算法存储了所有训练数据
    2. 预测阶段可能很慢
    3. 对不相关的功能和数据规模敏感

## 5.何时选择KNN算法？？？
从sklearn给出的图来解释：
![](https://img.kancloud.cn/58/77/58773152509f9db3e5016d3dcb125068_1600x997.png)

## 6.sklearn KNN参数介绍
`
def  KNeighborsClassifier(n_neighbors = 5, weights=&#x27;uniform&#x27;, algorithm = &#x27;&#x27;, leaf_size = &#x27;30&#x27;, p = 2, metric = &#x27;minkowski&#x27;, metric_params = None, n_jobs = None )
`

* n_neighbors：KNN的K值
* weights：最普遍的KNN算法无论距离如何，权重都一样，但有时我们想要特殊化一下数据，比如距离近的点，权重设置更高一些
    * &#x27;uniform&#x27;：不管远近权重都一样，就是最普通的KNN算法形式
    * &#x27;distance&#x27;：权重和距离成反比，距离预测目标越近拥有越高的权重
* algorithm：在 sklearn 中，要构建 KNN 模型有三种构建方式。暴力法适合数据量较小的方式，否则效率会比较低。如果数据量比较大一般会选择 KD 树构建 KNN 模型，而当 KD树也比较慢的时候，则可以试试球树来构建 KNN 。依次递进关系：&amp;lt;strong style=&quot;color:red&quot;&amp;gt;暴力法 -&amp;gt; KD树 -&amp;gt; 球树&amp;lt;/strong&amp;gt;
    * &#x27;brute&#x27;：蛮力实现（暴力法），直接计算距离存储比较的方式
    * &#x27;kd_tree&#x27;：采用 kd 树构建 KNN 模型
    * &#x27;ball_tree&#x27;：采用球树构建
    * &#x27;auto&#x27;：默认参数，自动选择合适的方法构建模型

 不过，当数据量较小或者比较稀疏时，无论选择哪个最后都会使用 &#x27;brute&#x27;

* leaf_size：如果是选择蛮力实现，则该值可以忽略，当时用KD树或者球树，该值是停止建子树的叶子节点数量的阈值，默认30，但如果数据量增多这个参数需要增大，否则速度过慢不说，还容易过拟合。
* &amp;lt;strong style=&quot;color:red&quot;&amp;gt;p：和metric结合使用，当metric参数是 &quot;minkowski&quot;的时候，p=1为曼哈顿距离，p=2为欧式距离。默认p=2&amp;lt;/strong&amp;gt;
* &amp;lt;strong style=&quot;color:red&quot;&amp;gt;metric：指定距离度量方法，一般都是使用欧式距离。&amp;lt;/strong&amp;gt;
    * &#x27;euclidean&#x27;：欧式距离
    * &#x27;manhattan&#x27;：曼哈顿距离
    * &#x27;chebyshev&#x27;：切比雪夫距离
    * &#x27;minkowski&#x27;：闵可夫斯基距离，默认参数
* n_jobs：指定多少个CPU进行运算，默认是-1，即全部都运算。

## 7.KNN代码示例

我们直接采用sklearn自带的鸢尾花数据集进行KNN分类：

### 7.1 交叉验证确定K值
```python
from sklearn.datasets import load_iris&amp;#13;
from sklearn.model_selection  import cross_val_score&amp;#13;
import matplotlib.pyplot as plt&amp;#13;
from sklearn.neighbors import KNeighborsClassifier&amp;#13;
&amp;#13;
#读取鸢尾花数据集&amp;#13;
iris = load_iris()&amp;#13;
x = iris.data&amp;#13;
y = iris.target&amp;#13;
k_range = range(1, 31)&amp;#13;
k_error = []&amp;#13;
#循环，取k=1到k=31，查看误差效果&amp;#13;
for k in k_range:&amp;#13;
    knn = KNeighborsClassifier(n_neighbors=k)&amp;#13;
    #cv参数决定数据集划分比例，这里是按照5:1划分训练集和测试集&amp;#13;
    scores = cross_val_score(knn, x, y, cv=6, scoring=&#x27;accuracy&#x27;)&amp;#13;
    k_error.append(1 - scores.mean())&amp;#13;
&amp;#13;
#画图，x轴为k值，y值为误差值&amp;#13;
plt.plot(k_range, k_error)&amp;#13;
plt.xlabel(&#x27;Value of K for KNN&#x27;)&amp;#13;
plt.ylabel(&#x27;Error&#x27;)&amp;#13;
plt.show()
```
运行结果如下：
![](https://img.kancloud.cn/5f/dd/5fdd32cd194264afd5de42b10fdc2aae_640x480.png)

从图中，我们可以明显看出K值取多少时误差最小，即K=11。
在实际问题中，如果数据集比较大，那为减少训练时间，K的取值范围可以缩小。

### 7.2 模型预测

```python
import matplotlib.pyplot as plt&amp;#13;
from numpy import *&amp;#13;
from matplotlib.colors import ListedColormap&amp;#13;
from sklearn import neighbors, datasets&amp;#13;
&amp;#13;
n_neighbors = 11&amp;#13;
&amp;#13;
# 导入一些要鸢尾花数据&amp;#13;
iris = datasets.load_iris()&amp;#13;
 # 我们只采用前两个feature,方便画图在二维平面显示&amp;#13;
x = iris.data[:, :2] 
y = iris.target&amp;#13;
&amp;#13;
&amp;#13;# 网格中的步长&amp;#13;
h = .02  
&amp;#13;
# 创建彩色的图&amp;#13;
cmap_light = ListedColormap([&#x27;#FFAAAA&#x27;, &#x27;#AAFFAA&#x27;, &#x27;#AAAAFF&#x27;])&amp;#13;
cmap_bold = ListedColormap([&#x27;#FF0000&#x27;, &#x27;#00FF00&#x27;, &#x27;#0000FF&#x27;])&amp;#13;
&amp;#13;
&amp;#13;
#weights是KNN模型中的一个参数，上述参数介绍中有介绍，这里绘制两种权重参数下KNN的效果图&amp;#13;
for weights in [&#x27;uniform&#x27;, &#x27;distance&#x27;]:&amp;#13;
    # 创建了一个knn分类器的实例，并拟合数据。&amp;#13;
    clf = neighbors.KNeighborsClassifier(n_neighbors, weights=weights)&amp;#13;
    clf.fit(x, y)&amp;#13;
&amp;#13;
    # 绘制决策边界。为此，我们将为每个分配一个颜色&amp;#13;
    # 来绘制网格中的点 [x_min, x_max]x[y_min, y_max].&amp;#13;
    x_min, x_max = x[:, 0].min() - 1, x[:, 0].max() + 1&amp;#13;
    y_min, y_max = x[:, 1].min() - 1, x[:, 1].max() + 1&amp;#13;
    xx, yy = np.meshgrid(np.arange(x_min, x_max, h),&amp;#13;
                         np.arange(y_min, y_max, h))&amp;#13;
    Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])&amp;#13;
&amp;#13;
    # 将结果放入一个彩色图中&amp;#13;
    Z = Z.reshape(xx.shape)&amp;#13;
    plt.figure()&amp;#13;
    plt.pcolormesh(xx, yy, Z, cmap=cmap_light)&amp;#13;
&amp;#13;
    # 绘制训练点&amp;#13;
    plt.scatter(x[:, 0], x[:, 1], c=y, cmap=cmap_bold)&amp;#13;
    plt.xlim(xx.min(), xx.max())&amp;#13;
    plt.ylim(yy.min(), yy.max())&amp;#13;
    plt.title(&quot;3-Class classification (k = %i, weights = &#x27;%s&#x27;)&quot;&amp;#13;
              % (n_neighbors, weights))&amp;#13;
&amp;#13;
plt.show()
```
结果如图所示：
![](https://img.kancloud.cn/4a/97/4a97983a10b5a5a4955defec807bf3f4_1280x960.png)

## 8.KNN与K-means异同？？？

* 相同点：
    * K值都是重点
    * 都需要计算平面中点的距离（核心都是通过计算空间中点的距离来实现目的）
* 不同点：
    * 目的不同：
        * KNN最终目的是分类
        * K-means目的是给所有距离相近的点分配一个类别，也就是聚类

&amp;lt;strong style=&quot;color:green&quot;&amp;gt;【敲黑板，划重点】&amp;lt;/strong&amp;gt;
就是画一个圈，
&amp;lt;strong style=&quot;color:red&quot;&amp;gt;KNN是让进来圈子的人变成自己人，&amp;lt;/strong&amp;gt;
&amp;lt;strong style=&quot;color:red&quot;&amp;gt;K-means是让原本在圈内的人归成一类人。&amp;lt;/strong&amp;gt;

## 9.KNN（k-近邻）算法的一般流程

（1）收集数据：可以使用任何方法。
（2）准备数据：距离计算所需要的的数值，最好是结构化的数据格式。
（3）分析数据：可以使用任何方法。
（4）训练算法：此步骤不适用k-近邻算法。
（5）测试算法：计算错误率。
（6）使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理。

## 参考文献
*  [一文搞懂k近邻（k-NN）算法](https://zhuanlan.zhihu.com/p/26029567)
*  [《Machine Learning in Action》 美.Perter Harrington著](http://www.java1234.com/a/javabook/javabase/2018/0618/11382.html?__cf_chl_jschl_tk__=1a9fd8cd05c65e779bf06b71c939ce301af6ba6f-1612414161-0-AS1KkYGWerV7qo3F4MC63eSztes9afmW8sVm1pUj0AA3CXfq5v_PHxGsg6jMvWKM9W4mfnJSCtYBsDQCjdTCBGKfDYhHQLuGBoCBxtLUvJVspQh1LAh0Vt-3fESV6P7AnGZLz1cm4bmFVXSAUPq75GxsqqySPmykRUQ2OEG9Xl3cleceh0Errob0UWroT0YJOQMNV_d7N7EeAvfH8DqesOBHzr_ju1v-skh5JI-kku4QIhpOqxJdgT3PYbnKYjukuJq3axyb7MaX_KaIB3oHk2nRzr8h7cdtUCqQKo7XTx1KSDfYMd60S-jZnK_l363Au8zU9k9N4dXKtNrOiME1no8ElxNb1pzF7G72Gk5ceuze)
                    &lt;/p&gt;
        
    &lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>575b483db3ebe8537c9038fc407cbb88</guid>
<title>面试中 LRU / LFU 的青铜与王者</title>
<link>https://toutiao.io/k/o9kubh1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;markdown-body entry-content container-lg&quot; itemprop=&quot;text&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/7ef1f80f565008a419e31adb3407bbae52fef7d1b66d7315f70ee62b7f77bf40/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f302e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/7ef1f80f565008a419e31adb3407bbae52fef7d1b66d7315f70ee62b7f77bf40/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f302e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_0.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;&lt;a id=&quot;user-content-面试中-lru--lfu-的青铜与王者&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#面试中-lru--lfu-的青铜与王者&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;面试中 LRU / LFU 的青铜与王者&lt;/h1&gt;
&lt;p&gt;已经 0202 年了，大厂面试手撸算法题已经是标配。第一轮就遇到手撸 LRU / LFU 的几率还是挺大的。LeetCode 上&lt;a href=&quot;https://leetcode.com/problems/lru-cache/&quot; rel=&quot;nofollow&quot;&gt;146. LRU Cache&lt;/a&gt; 和 &lt;a href=&quot;https://leetcode.com/problems/lfu-cache/&quot; rel=&quot;nofollow&quot;&gt;460. LFU Cache&lt;/a&gt;，LRU 是 Medium 难度，LFU 是 Hard 难度，面试官眼里认为这 2 个问题是最最最基础的。这篇文章就来聊聊面试中 LRU / LFU 的青铜与王者。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;缓存淘汰算法不仅仅只有 LRU / LFU 这两种，还有很多种，&lt;strong&gt;TLRU&lt;/strong&gt; (Time aware least recently used)，&lt;strong&gt;PLRU&lt;/strong&gt; (Pseudo-LRU)，&lt;strong&gt;SLRU&lt;/strong&gt; (Segmented LRU)，&lt;strong&gt;LFRU&lt;/strong&gt; (Least frequent recently used)，&lt;strong&gt;LFUDA&lt;/strong&gt; (LFU with dynamic aging)，&lt;strong&gt;LIRS&lt;/strong&gt; (Low inter-reference recency set)，&lt;strong&gt;ARC&lt;/strong&gt; (Adaptive Replacement Cache)，&lt;strong&gt;FIFO&lt;/strong&gt; (First In First Out)，&lt;strong&gt;MRU&lt;/strong&gt; (Most recently used)，&lt;strong&gt;LIFO&lt;/strong&gt; (Last in first out)，&lt;strong&gt;FILO&lt;/strong&gt; (First in last out)，&lt;strong&gt;CAR&lt;/strong&gt; (Clock with adaptive replacement) 等等。感兴趣的同学可以把这每一种都用代码实现一遍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-倔强青铜&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#倔强青铜&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;倔强青铜&lt;/h2&gt;
&lt;p&gt;面试官可能就直接拿出 LeetCode 上这 2 道题让你来做的。在笔者拿出标准答案之前，先简单介绍一下 LRU 和 LFU 的概念。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/9c0f7cf01c4a8a8c4c33d4277ed93d27bb7c46203bf4524f5f95456028c223fb/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f315f2e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/9c0f7cf01c4a8a8c4c33d4277ed93d27bb7c46203bf4524f5f95456028c223fb/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f315f2e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_1_.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。如上图，要插入 F 的时候，此时需要淘汰掉原来的一个页面。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/7f84aa263e95469060a623d8890bc261c1eb0bf02722cfdc831842ea1e59312b/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f325f302e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/7f84aa263e95469060a623d8890bc261c1eb0bf02722cfdc831842ea1e59312b/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f325f302e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_2_0.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据 LRU 的策略，每次都淘汰最近最久未使用的页面，所以先淘汰 A 页面。再插入 C 的时候，发现缓存中有 C 页面，这个时候需要把 C 页面放到首位，因为它被使用了。以此类推，插入 G 页面，G 页面是新页面，不在缓存中，所以淘汰掉 B 页面。插入 H 页面，H 页面是新页面，不在缓存中，所以淘汰掉 D 页面。插入 E 的时候，发现缓存中有 E 页面，这个时候需要把 E 页面放到首位。插入 I 页面，I 页面是新页面，不在缓存中，所以淘汰掉 F 页面。&lt;/p&gt;
&lt;p&gt;可以发现，&lt;strong&gt;LRU 更新和插入新页面都发生在链表首，删除页面都发生在链表尾&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;LRU 要求查询尽量高效，O(1) 内查询。那肯定选用 map 查询。修改，删除也要尽量 O(1) 完成。搜寻常见的数据结构，链表，栈，队列，树，图。树和图排除，栈和队列无法任意查询中间的元素，也排除。所以选用链表来实现。但是如果选用单链表，删除这个结点，需要 O(n) 遍历一遍找到前驱结点。所以选用双向链表，在删除的时候也能 O(1) 完成。&lt;/p&gt;
&lt;p&gt;由于 Go 的 container 包中的 list 底层实现是双向链表，所以可以直接复用这个数据结构。定义 LRUCache 的数据结构如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&quot;container/list&quot;&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
    &lt;span class=&quot;pl-c1&quot;&gt;Cap&lt;/span&gt;  &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;
    &lt;span class=&quot;pl-c1&quot;&gt;Keys&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;list.&lt;span class=&quot;pl-smi&quot;&gt;Element&lt;/span&gt;
    &lt;span class=&quot;pl-c1&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;list.&lt;span class=&quot;pl-smi&quot;&gt;List&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;pair&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
    &lt;span class=&quot;pl-c1&quot;&gt;K&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Constructor&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;capacity&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;{
        &lt;span class=&quot;pl-c1&quot;&gt;Cap&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;capacity&lt;/span&gt;,
        &lt;span class=&quot;pl-c1&quot;&gt;Keys&lt;/span&gt;: &lt;span class=&quot;pl-en&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;list.&lt;span class=&quot;pl-smi&quot;&gt;Element&lt;/span&gt;),
        &lt;span class=&quot;pl-c1&quot;&gt;List&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;list&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;New&lt;/span&gt;(),
    }
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要解释 2 个问题，list 中的值存的是什么？pair 这个结构体有什么用？&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
&lt;span class=&quot;pl-c&quot;&gt;// Next and previous pointers in the doubly-linked list of elements.&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;// To simplify the implementation, internally a list l is implemented&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;// as a ring, such that &amp;amp;l.root is both the next element of the last&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;// list element (l.Back()) and the previous element of the first list&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;// element (l.Front()).&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;Element&lt;/span&gt;

&lt;span class=&quot;pl-c&quot;&gt;// The list to which this element belongs.&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;List&lt;/span&gt;

&lt;span class=&quot;pl-c&quot;&gt;// The value stored with this element.&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt;{}
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 container/list 中，这个双向链表的每个结点的类型是 Element。Element 中存了 4 个值，前驱和后继结点，双向链表的头结点，value 值。这里的 value 是 interface 类型。笔者在这个 value 里面存了 pair 这个结构体。这就解释了 list 里面存的是什么数据。&lt;/p&gt;
&lt;p&gt;为什么要存 pair 呢？单单指存 v 不行么，为什么还要存一份 key ？原因是在 LRUCache 执行删除操作的时候，需要维护 2 个数据结构，一个是 map，一个是双向链表。在双向链表中删除淘汰出去的 value，在 map 中删除淘汰出去 value 对应的 key。如果在双向链表的 value 中不存储 key，那么再删除 map 中的 key 的时候有点麻烦。如果硬要实现，需要先获取到双向链表这个结点 Element 的地址。然后遍历 map，在 map 中找到存有这个 Element 元素地址对应的 key，再删除。这样做时间复杂度是 O(n)，做不到 O(1)。所以双向链表中的 Value 需要存储这个 pair。&lt;/p&gt;
&lt;p&gt;LRUCache 的 Get 操作很简单，在 map 中直接读取双向链表的结点。如果 map 中存在，将它移动到双向链表的表头，并返回它的 value 值，如果 map 中不存在，返回 -1。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Get&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Keys&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;]; &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;List&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;MoveToFront&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Value&lt;/span&gt;.(&lt;span class=&quot;pl-smi&quot;&gt;pair&lt;/span&gt;).&lt;span class=&quot;pl-c1&quot;&gt;V&lt;/span&gt;
}
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LRUCache 的 Put 操作也不难。先查询 map 中是否存在 key，如果存在，更新它的 value，并且把该结点移到双向链表的表头。如果 map 中不存在，新建这个结点加入到双向链表和 map 中。最后别忘记还需要维护双向链表的 cap，如果超过 cap，需要淘汰最后一个结点，双向链表中删除这个结点，map 中删掉这个结点对应的 key。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Put&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) {
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Keys&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;]; &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;pair&lt;/span&gt;{&lt;span class=&quot;pl-c1&quot;&gt;K&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;V&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt;}
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;List&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;MoveToFront&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;)
} &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;List&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;PushFront&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;pair&lt;/span&gt;{&lt;span class=&quot;pl-c1&quot;&gt;K&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;V&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt;})
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Keys&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;] &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;
}
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;List&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Len&lt;/span&gt;() &lt;span class=&quot;pl-c1&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Cap&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;List&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Back&lt;/span&gt;()
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;List&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Remove&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;)
&lt;span class=&quot;pl-en&quot;&gt;delete&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Keys&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Value&lt;/span&gt;.(&lt;span class=&quot;pl-smi&quot;&gt;pair&lt;/span&gt;).&lt;span class=&quot;pl-c1&quot;&gt;K&lt;/span&gt;)
}
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结，LRU 是由一个 map 和一个双向链表组成的数据结构。map 中 key 对应的 value 是双向链表的结点。双向链表中存储 key-value 的 pair。双向链表表首更新缓存，表尾淘汰缓存。如下图：&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/ae31d6bd4789c29f8ba7561474c12c58b05a47d886b98510e0405bfbe394100f/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f392e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/ae31d6bd4789c29f8ba7561474c12c58b05a47d886b98510e0405bfbe394100f/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f392e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_9.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;提交代码以后，成功通过所有测试用例。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/bc5fd8aaa35b5e887ac5a6e09fe8cde4e60b0d5156b61c7f9414448a092ed95a/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f345f2e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/bc5fd8aaa35b5e887ac5a6e09fe8cde4e60b0d5156b61c7f9414448a092ed95a/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f345f2e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_4_.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LFU 是 Least Frequently Used 的缩写，即最不经常最少使用，也是一种常用的页面置换算法，选择访问计数器最小的页面予以淘汰。如下图，缓存中每个页面带一个访问计数器。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/e846f7dcdc16fc7c90b5917a0bcb1d9722b7fb8dbcbb0df00751f2f5f43cb1c5/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f332e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/e846f7dcdc16fc7c90b5917a0bcb1d9722b7fb8dbcbb0df00751f2f5f43cb1c5/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f332e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_3.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据 LFU 的策略，每访问一次都要更新访问计数器。当插入 B 的时候，发现缓存中有 B，所以增加访问计数器的计数，并把 B 移动到访问计数器从大到小排序的地方。再插入 D，同理先更新计数器，再移动到它排序以后的位置。当插入 F 的时候，缓存中不存在 F，所以淘汰计数器最小的页面的页面，所以淘汰 A 页面。此时 F 排在最下面，计数为 1。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/041aa6c31e6106a837fc634f0d968b8037a0ffb9e79b8af41426b8e3f3769885/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f385f2e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/041aa6c31e6106a837fc634f0d968b8037a0ffb9e79b8af41426b8e3f3769885/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f385f2e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_8_.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里有一个比 LRU 特别的地方。如果淘汰的页面访问次数有多个相同的访问次数，选择最靠尾部的。如上图中，A、B、C 三者的访问次数相同，都是 1 次。要插入 F，F 不在缓存中，此时要淘汰 A 页面。F 是新插入的页面，访问次数为 1，排在 C 的前面。也就是说相同的访问次数，按照新旧顺序排列，淘汰掉最旧的页面。这一点是和 LRU 最大的不同的地方。&lt;/p&gt;
&lt;p&gt;可以发现，&lt;strong&gt;LFU 更新和插入新页面可以发生在链表中任意位置，删除页面都发生在表尾&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;LFU 同样要求查询尽量高效，O(1) 内查询。依旧选用 map 查询。修改和删除也需要 O(1) 完成，依旧选用双向链表，继续复用 container 包中的 list 数据结构。LFU 需要记录访问次数，所以每个结点除了存储 key，value，需要再多存储 frequency 访问次数。&lt;/p&gt;
&lt;p&gt;还有 1 个问题需要考虑，一个是如何按频次排序？相同频次，按照先后顺序排序。如果你开始考虑排序算法的话，思考方向就偏离最佳答案了。排序至少 O(nlogn)。重新回看 LFU 的工作原理，会发现它只关心最小频次。其他频次之间的顺序并不关心。所以不需要排序。用一个 min 变量保存最小频次，淘汰时读取这个最小值能找到要删除的结点。相同频次按照先后顺序排列，这个需求还是用双向链表实现，双向链表插入的顺序体现了结点的先后顺序。相同频次对应一个双向链表，可能有多个相同频次，所以可能有多个双向链表。用一个 map 维护访问频次和双向链表的对应关系。删除最小频次时，通过 min 找到最小频次，然后再这个 map 中找到这个频次对应的双向链表，在双向链表中找到最旧的那个结点删除。这就解决了 LFU 删除操作。&lt;/p&gt;
&lt;p&gt;LFU 的更新操作和 LRU 类似，也需要用一个 map 保存 key 和双向链表结点的映射关系。这个双向链表结点中存储的是 key-value-frequency 三个元素的元组。这样通过结点中的 key 和 frequency 可以反过来删除 map 中的 key。&lt;/p&gt;
&lt;p&gt;定义 LFUCache 的数据结构如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&quot;container/list&quot;&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;LFUCache&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
&lt;span class=&quot;pl-c1&quot;&gt;nodes&lt;/span&gt;    &lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;list.&lt;span class=&quot;pl-smi&quot;&gt;Element&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;lists&lt;/span&gt;    &lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;list.&lt;span class=&quot;pl-smi&quot;&gt;List&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;capacity&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;min&lt;/span&gt;      &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
&lt;span class=&quot;pl-c1&quot;&gt;key&lt;/span&gt;       &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;     &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Constructor&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;capacity&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;LFUCache&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;LFUCache&lt;/span&gt;{&lt;span class=&quot;pl-c1&quot;&gt;nodes&lt;/span&gt;: &lt;span class=&quot;pl-en&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;list.&lt;span class=&quot;pl-smi&quot;&gt;Element&lt;/span&gt;),
&lt;span class=&quot;pl-c1&quot;&gt;lists&lt;/span&gt;:    &lt;span class=&quot;pl-en&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;list.&lt;span class=&quot;pl-smi&quot;&gt;List&lt;/span&gt;),
&lt;span class=&quot;pl-c1&quot;&gt;capacity&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;capacity&lt;/span&gt;,
&lt;span class=&quot;pl-c1&quot;&gt;min&lt;/span&gt;:      &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;,
}
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LFUCache 的 Get 操作涉及更新 frequency 值和 2 个 map。在 nodes map 中通过 key 获取到结点信息。在 lists 删除结点当前 frequency 结点。删完以后 frequency ++。新的 frequency 如果在 lists 中存在，添加到双向链表表首，如果不存在，需要新建一个双向链表并把当前结点加到表首。再更新双向链表结点作为 value 的 map。最后更新 min 值，判断老的 frequency 对应的双向链表中是否已经为空，如果空了，min++。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LFUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Get&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;nodes&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;]
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
}
&lt;span class=&quot;pl-s1&quot;&gt;currentNode&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Value&lt;/span&gt;.(&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;node&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;lists&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;currentNode&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt;].&lt;span class=&quot;pl-en&quot;&gt;Remove&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;currentNode&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;++&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;_&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;lists&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;currentNode&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt;]; &lt;span class=&quot;pl-c1&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;lists&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;currentNode&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt;] &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;list&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;New&lt;/span&gt;()
}
&lt;span class=&quot;pl-s1&quot;&gt;newList&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;lists&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;currentNode&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt;]
&lt;span class=&quot;pl-s1&quot;&gt;newNode&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;newList&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;PushFront&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;currentNode&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;nodes&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;] &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;newNode&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;currentNode&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;lists&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;currentNode&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;].&lt;span class=&quot;pl-en&quot;&gt;Len&lt;/span&gt;() &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;++&lt;/span&gt;
}
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;currentNode&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LFU 的 Put 操作逻辑稍微多一点。先在 nodes map 中查询 key 是否存在，如果存在，获取这个结点，更新它的 value 值，然后手动调用一次 Get 操作，因为下面的更新逻辑和 Get 操作一致。如果 map 中不存在，接下来进行插入或者删除操作。判断 capacity 是否装满，如果装满，执行删除操作。在 min 对应的双向链表中删除表尾的结点，对应的也要删除 nodes map 中的键值。&lt;/p&gt;
&lt;p&gt;由于新插入的页面访问次数一定为 1，所以 min 此时置为 1。新建结点，插入到 2 个 map 中。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LFUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Put&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) {
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;capacity&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt;
}
&lt;span class=&quot;pl-c&quot;&gt;// 如果存在，更新访问次数&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;currentValue&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;nodes&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;]; &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;currentNode&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;currentValue&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Value&lt;/span&gt;.(&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;node&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;currentNode&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Get&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt;
}
&lt;span class=&quot;pl-c&quot;&gt;// 如果不存在且缓存满了，需要删除&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;capacity&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;len&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;nodes&lt;/span&gt;) {
&lt;span class=&quot;pl-s1&quot;&gt;currentList&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;lists&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;min&lt;/span&gt;]
&lt;span class=&quot;pl-s1&quot;&gt;backNode&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;currentList&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Back&lt;/span&gt;()
&lt;span class=&quot;pl-en&quot;&gt;delete&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;nodes&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;backNode&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Value&lt;/span&gt;.(&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;node&lt;/span&gt;).&lt;span class=&quot;pl-c1&quot;&gt;key&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;currentList&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Remove&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;backNode&lt;/span&gt;)
}
&lt;span class=&quot;pl-c&quot;&gt;// 新建结点，插入到 2 个 map 中&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;currentNode&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;node&lt;/span&gt;{
&lt;span class=&quot;pl-c1&quot;&gt;key&lt;/span&gt;:       &lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;,
&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;:     &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt;,
&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;,
}
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;_&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;lists&lt;/span&gt;[&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;]; &lt;span class=&quot;pl-c1&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;lists&lt;/span&gt;[&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;list&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;New&lt;/span&gt;()
}
&lt;span class=&quot;pl-s1&quot;&gt;newList&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;lists&lt;/span&gt;[&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;]
&lt;span class=&quot;pl-s1&quot;&gt;newNode&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;newList&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;PushFront&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;currentNode&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;nodes&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;] &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;newNode&lt;/span&gt;
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结，LFU 是由两个 map 和一个 min 指针组成的数据结构。一个 map 中 key 存的是访问次数，对应的 value 是一个个的双向链表，此处双向链表的作用是在相同频次的情况下，淘汰表尾最旧的那个页面。另一个 map 中 key 对应的 value 是双向链表的结点，结点中比 LRU 多存储了一个访问次数的值，即结点中存储 key-value-frequency 的元组。此处双向链表的作用和 LRU 是类似的，可以根据 map 中的 key 更新双向链表结点中的 value 和 frequency 的值，也可以根据双向链表结点中的 key 和 frequency 反向更新 map 中的对应关系。如下图：&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/623944d557b3778f1cb84da23afbd7805c5a9df6c1b25fd71ad206771693e02e/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31305f312e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/623944d557b3778f1cb84da23afbd7805c5a9df6c1b25fd71ad206771693e02e/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31305f312e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_10_1.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;提交代码以后，成功通过所有测试用例。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/ccd04b23b7bbc7b8ed04e9cf24bcf1ccb4d65f41ecc6e8962330678ede39d66f/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f352e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/ccd04b23b7bbc7b8ed04e9cf24bcf1ccb4d65f41ecc6e8962330678ede39d66f/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f352e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_5.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-荣耀黄金&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#荣耀黄金&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;荣耀黄金&lt;/h2&gt;
&lt;p&gt;面试中如果给出了上面青铜的答案，可能会被追问，“还有没有其他解法？” 虽然目前青铜的答案已经是最优解了，但是面试官还想考察多解。&lt;/p&gt;
&lt;p&gt;先考虑 LRU。数据结构上想不到其他解法了，但从打败的百分比上，看似还有常数的优化空间。笔者反复思考，觉得可能导致运行时间变长的地方是在 interface{} 类型推断，其他地方已无优化的空间。手写一个双向链表提交试试，代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
&lt;span class=&quot;pl-c1&quot;&gt;head&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;Node&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;keys&lt;/span&gt;       &lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;Node&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;capacity&lt;/span&gt;   &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
&lt;span class=&quot;pl-c1&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;val&lt;/span&gt;   &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;prev&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;Node&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;ConstructorLRU&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;capacity&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;{&lt;span class=&quot;pl-c1&quot;&gt;keys&lt;/span&gt;: &lt;span class=&quot;pl-en&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;Node&lt;/span&gt;), &lt;span class=&quot;pl-c1&quot;&gt;capacity&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;capacity&lt;/span&gt;}
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Get&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;keys&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;]; &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Remove&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;val&lt;/span&gt;
}
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Put&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) {
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;keys&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;]; &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Remove&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt;
} &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;Node&lt;/span&gt;{&lt;span class=&quot;pl-c1&quot;&gt;key&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;val&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt;}
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;keys&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;] &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;)
}
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;len&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;keys&lt;/span&gt;) &lt;span class=&quot;pl-c1&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;capacity&lt;/span&gt; {
&lt;span class=&quot;pl-en&quot;&gt;delete&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;keys&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;tail&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;key&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Remove&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;tail&lt;/span&gt;)
}
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;Node&lt;/span&gt;) {
&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;head&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;head&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;
}
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;tail&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt;
}
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Remove&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;Node&lt;/span&gt;) {
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;head&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt;
}
&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt;
}
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;tail&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prev&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prev&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt;
}
&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prev&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prev&lt;/span&gt;
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;提交以后还真的 100% 了。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/e27f7e7bf5b2a90252f98a26a4d171c791d9949b1cf5feac2954e8a657c62ebf/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f362e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/e27f7e7bf5b2a90252f98a26a4d171c791d9949b1cf5feac2954e8a657c62ebf/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f362e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_6.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上述代码实现的 LRU 本质并没有优化，只是换了一个写法，没有用 container 包而已。&lt;/p&gt;
&lt;p&gt;LFU 的另外一个思路是利用 &lt;a href=&quot;https://algs4.cs.princeton.edu/24pq/&quot; rel=&quot;nofollow&quot;&gt;Index Priority Queue&lt;/a&gt; 这个数据结构。别被名字吓到，Index Priority Queue = map + Priority Queue，仅此而已。&lt;/p&gt;
&lt;p&gt;利用 Priority Queue 维护一个最小堆，堆顶是访问次数最小的元素。map 中的 value 存储的是优先队列中结点。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&quot;container/heap&quot;&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;LFUCache&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
&lt;span class=&quot;pl-c1&quot;&gt;capacity&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;pq&lt;/span&gt;       &lt;span class=&quot;pl-smi&quot;&gt;PriorityQueue&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;hash&lt;/span&gt;     &lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;Item&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;counter&lt;/span&gt;  &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Constructor&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;capacity&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;LFUCache&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;lfu&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;LFUCache&lt;/span&gt;{
&lt;span class=&quot;pl-c1&quot;&gt;pq&lt;/span&gt;:       &lt;span class=&quot;pl-smi&quot;&gt;PriorityQueue&lt;/span&gt;{},
&lt;span class=&quot;pl-c1&quot;&gt;hash&lt;/span&gt;:     &lt;span class=&quot;pl-en&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;Item&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;capacity&lt;/span&gt;),
&lt;span class=&quot;pl-c1&quot;&gt;capacity&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;capacity&lt;/span&gt;,
}
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;lfu&lt;/span&gt;
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Get 和 Put 操作要尽量的快，有 2 个问题需要解决。当访问次数相同时，如何删除掉最久的元素？当元素的访问次数发生变化时，如何快速调整堆？为了解决这 2 个问题，定义如下的数据结构：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-c&quot;&gt;// An Item is something we manage in a priority queue.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;     &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;// The value of the item; arbitrary.&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;key&lt;/span&gt;       &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;// The priority of the item in the queue.&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;count&lt;/span&gt;     &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;// use for evicting the oldest element&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;// The index is needed by update and is maintained by the heap.Interface methods.&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;// The index of the item in the heap.&lt;/span&gt;
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;堆中的结点存储这 5 个值。count 值用来决定哪个是最老的元素，类似一个操作时间戳。index 值用来 re-heapify 调整堆的。接下来实现 PriorityQueue 的方法。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-c&quot;&gt;// A PriorityQueue implements heap.Interface and holds Items.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;PriorityQueue&lt;/span&gt; []&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;Item&lt;/span&gt;

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;PriorityQueue&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Len&lt;/span&gt;() &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt; { &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;len&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;) }

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;PriorityQueue&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Less&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;bool&lt;/span&gt; {
&lt;span class=&quot;pl-c&quot;&gt;// We want Pop to give us the highest, not lowest, priority so we use greater than here.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt;].&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;j&lt;/span&gt;].&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt;].&lt;span class=&quot;pl-c1&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;j&lt;/span&gt;].&lt;span class=&quot;pl-c1&quot;&gt;count&lt;/span&gt;
}
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt;].&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;j&lt;/span&gt;].&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;PriorityQueue&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Swap&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) {
&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt;], &lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;j&lt;/span&gt;] &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;j&lt;/span&gt;], &lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt;]
&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt;].&lt;span class=&quot;pl-c1&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;j&lt;/span&gt;].&lt;span class=&quot;pl-c1&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;j&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;PriorityQueue&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Push&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt;{}) {
&lt;span class=&quot;pl-s1&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;len&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;x&lt;/span&gt;.(&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;Item&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;n&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;)
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;PriorityQueue&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Pop&lt;/span&gt;() &lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt;{} {
&lt;span class=&quot;pl-s1&quot;&gt;old&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;len&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;old&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;old&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;]
&lt;span class=&quot;pl-s1&quot;&gt;old&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt;  &lt;span class=&quot;pl-c&quot;&gt;// avoid memory leak&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;// for safety&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;old&lt;/span&gt;[&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;pl-s1&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;]
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;
}

&lt;span class=&quot;pl-c&quot;&gt;// update modifies the priority and value of an Item in the queue.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;PriorityQueue&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;update&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;Item&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;frequency&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) {
&lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;count&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;frequency&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;heap&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Fix&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;pq&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;index&lt;/span&gt;)
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 Less() 方法中，frequency 从小到大排序，frequency 相同的，按 count 从小到大排序。按照优先队列建堆规则，可以得到，frequency 最小的在堆顶，相同的 frequency，count 最小的越靠近堆顶。&lt;/p&gt;
&lt;p&gt;在 Swap() 方法中，记得要更新 index 值。在 Push() 方法中，插入时队列的长度即是该元素的 index 值，此处也要记得更新 index 值。update() 方法调用 Fix() 函数。Fix() 函数比先 Remove() 再 Push() 一个新的值，花销要小。所以此处调用 Fix() 函数，这个操作的时间复杂度是 O(log n)。&lt;/p&gt;
&lt;p&gt;这样就维护了最小 Index Priority Queue。Get 操作非常简单：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LFUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Get&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;capacity&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
}
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;hash&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;]; &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;++&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;pq&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;update&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;counter&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;
}
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 hashmap 中查询 key，如果存在，counter 时间戳累加，调用 Priority Queue 的 update 方法，调整堆。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LFUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Put&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) {
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;capacity&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt;
}
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;++&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;// 如果存在，增加 frequency，再调整堆&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;hash&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;]; &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;pq&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;update&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;frequency&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;counter&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt;
}
&lt;span class=&quot;pl-c&quot;&gt;// 如果不存在且缓存满了，需要删除。在 hashmap 和 pq 中删除。&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;len&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;pq&lt;/span&gt;) &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;capacity&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;heap&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Pop&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;pq&lt;/span&gt;).(&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;Item&lt;/span&gt;)
&lt;span class=&quot;pl-en&quot;&gt;delete&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;hash&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;key&lt;/span&gt;)
}
&lt;span class=&quot;pl-c&quot;&gt;// 新建结点，在 hashmap 和 pq 中添加。&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;Item&lt;/span&gt;{
&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt;,
&lt;span class=&quot;pl-c1&quot;&gt;key&lt;/span&gt;:   &lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;,
&lt;span class=&quot;pl-c1&quot;&gt;count&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;counter&lt;/span&gt;,
}
&lt;span class=&quot;pl-s1&quot;&gt;heap&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Push&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;pq&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;hash&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;] &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;item&lt;/span&gt;
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用最小堆实现的 LFU，Put 时间复杂度是 O(capacity)，Get 时间复杂度是 O(capacity)，不及 2 个 map 实现的版本。巧的是最小堆的版本居然打败了 100%。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/219181a78bc25e9a1b321ae932f6c7133230ebc2421f9f2d9cd3c78cc2793d51/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f372e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/219181a78bc25e9a1b321ae932f6c7133230ebc2421f9f2d9cd3c78cc2793d51/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f372e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_7.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;提交以后，LRU 和 LFU 都打败了 100%。上述代码都封装好了，&lt;a href=&quot;https://github.com/halfrost/LeetCode-Go/tree/master/template&quot;&gt;完整代码&lt;/a&gt;在 LeetCode-Go 中，讲解也更新到了 《LeetCode Cookbook》第三章的&lt;a href=&quot;https://books.halfrost.com/leetcode/ChapterThree/LRUCache/&quot; rel=&quot;nofollow&quot;&gt;第三节 LRUCache&lt;/a&gt;和&lt;a href=&quot;https://books.halfrost.com/leetcode/ChapterThree/LFUCache/&quot; rel=&quot;nofollow&quot;&gt;第四节 LFUCache&lt;/a&gt;中。LRU 的最优解是 map + 双向链表，LFU 的最优解是 2 个 map + 多个双向链表。其实热身刚刚结束，接下来才是本文的&lt;strong&gt;重点&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-最强王者&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#最强王者&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;最强王者&lt;/h2&gt;
&lt;p&gt;在面试者回答出黄金级的问题了以后，面试官可能会继续追问一个更高级的问题。“如何实现一个高并发且线程安全的 LRU 呢？”。遇到这个问题，上文讨论的代码模板就失效了。要想做到高并发，需要考虑 2 点，第一点内存分配与回收 GC 一定要快，最好是 Zero GC 开销，第二点执行操作耗时最少。详细的，由于要做到高并发，瞬间的 TPS 可能会很大，所以要最快的分配内存，开辟新的内存空间。垃圾回收也不能慢，否则内存会暴涨。针对 LRU / LFU 这个问题，执行的操作是 get 和 set，耗时需要最少。耗时高了，系统吞吐率会受到严重影响，TPS 上不去了。再者，在高并发的场景中，一定会保证线程安全。这里就需要用到锁。最简单的选用读写锁。以下举例以 LRUCache 为例。LFUCache 原理类似。（以下代码先给出改造新增的部分，最后再给出完整版）&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
    sync.&lt;span class=&quot;pl-smi&quot;&gt;RWMutex&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Get&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;RLock&lt;/span&gt;()
&lt;span class=&quot;pl-k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;RUnlock&lt;/span&gt;()

……
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Put&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) {
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Lock&lt;/span&gt;()
  &lt;span class=&quot;pl-k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Unlock&lt;/span&gt;()
  
……
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码虽然能保证线程安全，但是并发量并不高。因为在 Put 操作中，写锁会阻碍读锁，这里会锁住。接下来的优化思路很清晰，拆分大锁，让写锁尽可能的少阻碍读锁。一句话就是将锁颗粒化。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/a613987b7fbca4852abbfcc12b5eabc11a1a82a04dd71b49d54fb4e96514ec7e/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32372e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/a613987b7fbca4852abbfcc12b5eabc11a1a82a04dd71b49d54fb4e96514ec7e/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32372e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_27.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如上图，将一个大的临界区拆分成一个个小的临界区。代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
    sync.&lt;span class=&quot;pl-smi&quot;&gt;RWMutex&lt;/span&gt;
    &lt;span class=&quot;pl-c1&quot;&gt;shards&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCacheShard&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;LRUCacheShard&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
  &lt;span class=&quot;pl-c1&quot;&gt;Cap&lt;/span&gt;  &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;Keys&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;list.&lt;span class=&quot;pl-smi&quot;&gt;Element&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;list.&lt;span class=&quot;pl-smi&quot;&gt;List&lt;/span&gt;
sync.&lt;span class=&quot;pl-smi&quot;&gt;RWMutex&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Get&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;GetShard&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;
}
&lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;RLock&lt;/span&gt;()
&lt;span class=&quot;pl-k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;RUnlock&lt;/span&gt;()

……
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Put&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) {
  &lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;GetShard&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Lock&lt;/span&gt;()
&lt;span class=&quot;pl-k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Unlock&lt;/span&gt;()

……
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;GetShard&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;bool&lt;/span&gt;) (&lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCacheShard&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;bool&lt;/span&gt;) {
&lt;span class=&quot;pl-s1&quot;&gt;hasher&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;sha1&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;New&lt;/span&gt;()
&lt;span class=&quot;pl-s1&quot;&gt;hasher&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Write&lt;/span&gt;([]&lt;span class=&quot;pl-smi&quot;&gt;byte&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;))
&lt;span class=&quot;pl-s1&quot;&gt;shardKey&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;fmt&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Sprintf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&quot;%x&quot;&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;hasher&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Sum&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt;))[&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;]

&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;lock&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;RLock&lt;/span&gt;()
&lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;shards&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;shardKey&lt;/span&gt;]
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;lock&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;RUnlock&lt;/span&gt;()

&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;create&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt;
}

&lt;span class=&quot;pl-c&quot;&gt;//only time we need to write lock&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;lock&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Lock&lt;/span&gt;()
&lt;span class=&quot;pl-k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;lock&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Unlock&lt;/span&gt;()
&lt;span class=&quot;pl-c&quot;&gt;//check again in case the group was created in this short time&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;shards&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;shardKey&lt;/span&gt;]
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt;
}

&lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCacheShard&lt;/span&gt;{
&lt;span class=&quot;pl-c1&quot;&gt;Keys&lt;/span&gt;: &lt;span class=&quot;pl-en&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;list.&lt;span class=&quot;pl-smi&quot;&gt;Element&lt;/span&gt;),
&lt;span class=&quot;pl-c1&quot;&gt;List&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;list&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;New&lt;/span&gt;(),
}
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;shards&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;shardKey&lt;/span&gt;] &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt;
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上述的改造，利用哈希把原来的 LRUCache 分为了 256 个分片(2^8)。并且写锁锁住只发生在分片不存在的时候。一旦分片被创建了，之后都是读锁。这里依旧是小瓶颈，继续优化，消除掉这里的写锁。优化代码很简单，在创建的时候创建所有分片。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;New&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;capacity&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;shards&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;]&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCacheShard&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;256&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;256&lt;/span&gt;; &lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;++&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;shards&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;fmt&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Sprintf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&quot;%02x&quot;&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt;)] &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCacheShard&lt;/span&gt;{
&lt;span class=&quot;pl-c1&quot;&gt;Cap&lt;/span&gt;:  &lt;span class=&quot;pl-s1&quot;&gt;capacity&lt;/span&gt;,
&lt;span class=&quot;pl-c1&quot;&gt;Keys&lt;/span&gt;: &lt;span class=&quot;pl-en&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;]&lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;list.&lt;span class=&quot;pl-smi&quot;&gt;Element&lt;/span&gt;),
&lt;span class=&quot;pl-c1&quot;&gt;List&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;list&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;New&lt;/span&gt;(),
}
}
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;{
&lt;span class=&quot;pl-c1&quot;&gt;shards&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;shards&lt;/span&gt;,
}
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Get&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;GetShard&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;RLock&lt;/span&gt;()
&lt;span class=&quot;pl-k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;RUnlock&lt;/span&gt;()

……
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Put&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) {
  &lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;GetShard&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Lock&lt;/span&gt;()
&lt;span class=&quot;pl-k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Unlock&lt;/span&gt;()

……
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;GetShard&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int&lt;/span&gt;) (&lt;span class=&quot;pl-s1&quot;&gt;shard&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;LRUCacheShard&lt;/span&gt;) {
  &lt;span class=&quot;pl-s1&quot;&gt;hasher&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;sha1&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;New&lt;/span&gt;()
  &lt;span class=&quot;pl-s1&quot;&gt;hasher&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Write&lt;/span&gt;([]&lt;span class=&quot;pl-smi&quot;&gt;byte&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;key&lt;/span&gt;))
  &lt;span class=&quot;pl-s1&quot;&gt;shardKey&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt;  &lt;span class=&quot;pl-s1&quot;&gt;fmt&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Sprintf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&quot;%x&quot;&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;hasher&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Sum&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt;))[&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;]
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;shards&lt;/span&gt;[&lt;span class=&quot;pl-s1&quot;&gt;shardKey&lt;/span&gt;]
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里，大的临界区已经被拆分成细颗粒度了。在细粒度的锁内部，还包含双链表结点的操作，对结点的操作涉及到锁竞争。成熟的缓存系统如 memcached，使用的是全局的 LRU 链表锁，而 Redis 是单线程的所以不需要考虑并发的问题。回到 LRU，每个 Get 操作需要读取 key 值对应的 value，需要读锁。与此同时，Get 操作也涉及到移动最近最常使用的结点，需要写锁。Set 操作只涉及写锁。需要注意的一点，Get 和 Set 先后执行顺序非常关键。例如，先 get 一个不存在的 key，返回 nil，再 set 这个 key。如果先 set 这个 key，再 get 这个key，返回的就是不是 nil，而是对应的 value。所以在保证锁安全(不发生死锁)的情况下，还需要保证每个操作时序的正确性。能同时满足这 2 个条件的非带缓冲的 channel 莫属。先来看看消费 channel 通道里面数据的处理逻辑：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;CLRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;doMove&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;list.&lt;span class=&quot;pl-smi&quot;&gt;Element&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;bool&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Value&lt;/span&gt;.(&lt;span class=&quot;pl-smi&quot;&gt;Pair&lt;/span&gt;).&lt;span class=&quot;pl-c1&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;MoveToFront&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;list&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;MoveToFront&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;
}
&lt;span class=&quot;pl-s1&quot;&gt;newel&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;list&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;PushFront&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Value&lt;/span&gt;.(&lt;span class=&quot;pl-smi&quot;&gt;Pair&lt;/span&gt;))
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;bucket&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Value&lt;/span&gt;.(&lt;span class=&quot;pl-smi&quot;&gt;Pair&lt;/span&gt;).&lt;span class=&quot;pl-c1&quot;&gt;key&lt;/span&gt;).&lt;span class=&quot;pl-en&quot;&gt;update&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Value&lt;/span&gt;.(&lt;span class=&quot;pl-smi&quot;&gt;Pair&lt;/span&gt;).&lt;span class=&quot;pl-c1&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;newel&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还值得一提的是，get 和 set 的写操作有 2 种类型，一种是 MoveToFront，另外一种是当结点不存在的时候，需要先创建一个新的结点，并移动到头部。这个操作即 PushFront。笔者这里在结点中加入了 cmd 标识，默认值是 MoveToFront。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/105e79950970ab0ba56a77457c037db7a6bea80a2e9295e624d6ff857e037a9b/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32362e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/105e79950970ab0ba56a77457c037db7a6bea80a2e9295e624d6ff857e037a9b/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32362e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_26.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前为止，下一步的优化思路确定使用带缓冲的 channel 了。用几个呢？答案是用 2 个。除去上面讨论的写入操作，还要管理 remove 操作。由于 LRU 逻辑的特殊性，它保证了移动结点和移除结点一定分开在双链表两端。也就是说在双链表两边同时操作，相互不影响。双链表的临界区范围可以进一步的缩小，可以缩小到结点级。最终方案就定下来了。用 2 个带缓冲的 channel，分别处理移动结点和删除结点，这两个 channel 可以在同一个协程中一起处理，互不影响。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;CLRUCache&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;worker&lt;/span&gt;() {
&lt;span class=&quot;pl-k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;close&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;control&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;select&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;movePairs&lt;/span&gt;:
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;goto&lt;/span&gt; clean
}
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;doMove&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;) &lt;span class=&quot;pl-c1&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;list&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Len&lt;/span&gt;() &lt;span class=&quot;pl-c1&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;cap&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;list&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Back&lt;/span&gt;()
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;list&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Remove&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;)
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;bucket&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Value&lt;/span&gt;.(&lt;span class=&quot;pl-smi&quot;&gt;Pair&lt;/span&gt;).&lt;span class=&quot;pl-c1&quot;&gt;key&lt;/span&gt;).&lt;span class=&quot;pl-en&quot;&gt;delete&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Value&lt;/span&gt;.(&lt;span class=&quot;pl-smi&quot;&gt;Pair&lt;/span&gt;).&lt;span class=&quot;pl-c1&quot;&gt;key&lt;/span&gt;)
}
&lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;deletePairs&lt;/span&gt;:
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;list&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Remove&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;control&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;control&lt;/span&gt;:
&lt;span class=&quot;pl-k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;control&lt;/span&gt;.(&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt;) {
&lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;clear&lt;/span&gt;:
&lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;_&lt;/span&gt;, &lt;span class=&quot;pl-s1&quot;&gt;bucket&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;buckets&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;bucket&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;clear&lt;/span&gt;()
}
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;list&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;New&lt;/span&gt;()
&lt;span class=&quot;pl-s1&quot;&gt;msg&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt;{}{}
}
}
}
clean:
&lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;select&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;deletePairs&lt;/span&gt;:
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;list&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Remove&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;el&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;default&lt;/span&gt;:
&lt;span class=&quot;pl-en&quot;&gt;close&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;deletePairs&lt;/span&gt;)
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt;
}
}
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终完整的代码放在&lt;a href=&quot;https://github.com/halfrost/LeetCode-Go/blob/master/template/CLRUCache.go&quot;&gt;这里&lt;/a&gt;了。最后简单的跑一下 Benchmark 看看性能如何。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下性能测试部分是面试结束后，笔者测试的。面试时写完代码，并没有当场 Benchmark。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight highlight-source-go&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;bench&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;BenchmarkGetAndPut1&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;none&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;benchmem&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;cpuprofile&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;cpuprofile&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;memprofile&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;memprofile&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;goos: &lt;span class=&quot;pl-s1&quot;&gt;darwin&lt;/span&gt;
goarch: &lt;span class=&quot;pl-s1&quot;&gt;amd64&lt;/span&gt;
pkg: &lt;span class=&quot;pl-s1&quot;&gt;github&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;halfrost&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;LeetCode&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;Go&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;template&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;BenchmarkGetAndPut1&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;8&lt;/span&gt;            &lt;span class=&quot;pl-c1&quot;&gt;368578&lt;/span&gt;              &lt;span class=&quot;pl-c1&quot;&gt;2474&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;ns&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;op&lt;/span&gt;             &lt;span class=&quot;pl-c1&quot;&gt;530&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;op&lt;/span&gt;         &lt;span class=&quot;pl-c1&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;allocs&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;op&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;PASS&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;ok&lt;/span&gt;      &lt;span class=&quot;pl-s1&quot;&gt;github&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;halfrost&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;LeetCode&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;Go&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;template&lt;/span&gt;        &lt;span class=&quot;pl-c1&quot;&gt;1.022&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;s&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BenchmarkGetAndPut2 只是简单的全局加锁，会有死锁的情况。可以看到方案一的性能还行，368578 次循环平均出来的结果，平均一次 Get/Set 需要 2474 ns，那么 TPS 大约是 300K/s，可以满足一般高并发的需求。&lt;/p&gt;
&lt;p&gt;最后看看这个版本下的 CPU 消耗情况，符合预期：&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/5ecd831a4e396f0a97ea06450f122fe6341c770b2d081b3dc968fdfed8178b22/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31315f302e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/5ecd831a4e396f0a97ea06450f122fe6341c770b2d081b3dc968fdfed8178b22/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31315f302e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_11_0.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内存分配情况，也符合预期：&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/c0e9704489c36624872081a3fec97c2647a9a760d2e423204d9cd14ff551ca4b/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31325f302e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/c0e9704489c36624872081a3fec97c2647a9a760d2e423204d9cd14ff551ca4b/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31325f302e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_12_0.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;至此，你已经是王者了。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-荣耀王者&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#荣耀王者&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;荣耀王者&lt;/h2&gt;
&lt;p&gt;这里是附加题部分。面试官问到这里就和 LRU/LFU 直接关系不大了，更多的考察的是如何设计一个高并发的 Cache。笔者之所以在这篇文章最后提一笔，是想给读者扩展思维。面试官会针对你给出的高并发版的 LRU 继续问，“你觉得你写的这个版本缺点在哪里？和真正的 Cache 比，还有哪些欠缺？”&lt;/p&gt;
&lt;p&gt;在上一节“最强王者”中，粗略的实现了一个高并发的 LRU。但是这个方案还不是最完美的。当高并发高到一个临界值的时候，即 Get 请求的速度达到 Go 内存回收速度的几百倍，几万倍的时候。bucket 分片被清空，试图访问该分片中的 key 的 goroutine 开始分配内存，而先前的内存仍未完全释放，从而导致内存使用量激增和 OOM 崩溃。所以这种方法的性能不能随内核数量很好地扩展。&lt;/p&gt;
&lt;p&gt;另外这种粗略的方式是以缓存数目作为 Cap 的，没有考虑每个 value 的大小。以缓存数目作为基准，是没法限制住内存大小的。如果高负载的业务，设置大的 Cap，极端的讲，每个 value 都非常大，几十个 MB，整体内存消耗可能上百 GB。如果是低负载的业务，设置很小的 Cap，极端情况，每个 value 特别小。总内存大小可能在 1KB。这样看，内存上限和下限浮动太大了，无法折中限制。&lt;/p&gt;
&lt;p&gt;欠缺的分为 2 部分，一部分是功能性，一部分是性能。功能性方面欠缺 TTL，持久化。TTL 是过期时间，到时间需要删除 key。持久化是将缓存中的数据保存至文件中，或者启动的时候从文件中读取。&lt;/p&gt;
&lt;p&gt;性能方面欠缺的是高效的 hash 算法，高命中率，内存限制，可伸缩性。&lt;/p&gt;
&lt;p&gt;高效的 hash 算法指的是类似 AES Hash，针对 CPU 是否支持 AES 指令集进行了判断，当 CPU 支持 AES 指令集的时候，它会选用 AES Hash 算法。一些高效的 hash 算法用汇编语言实现的。&lt;/p&gt;
&lt;p&gt;高命中率方面，可以参考 &lt;a href=&quot;https://dgraph.io/blog/refs/bp_wrapper.pdf&quot; rel=&quot;nofollow&quot;&gt;BP-Wrapper: A System Framework Making Any
Replacement Algorithms (Almost) Lock Contention Free&lt;/a&gt; 这篇论文，在这篇论文里面提出了 2 种方式：prefetching 和 batching。简单说一下 batching 的方式。在等待临界区之前，先填满 ring buffer。如该论文所述，借用 ring buffer 这种方式，几乎没有开销，从而大大降低了竞争。实现 ring buffer 可以考虑使用 sync.Pool 而不是其他的数据结构（切片，带区互斥锁等），原因是性能优势主要是由于线程本地存储的内部使用，而其他的数据结构没有这相关的 API。&lt;/p&gt;
&lt;p&gt;内存限制。无限大的缓存实际上是不可能的。高速缓存必须有大小限制。如何制定一套高效的淘汰的策略就变的很关键。LRU 这个淘汰策略好么？针对不同的使用场景，LRU 并不是最好的，有些场景下 LFU 更加适合。这里有一篇论文 &lt;a href=&quot;https://dgraph.io/blog/refs/TinyLFU%20-%20A%20Highly%20Efficient%20Cache%20Admission%20Policy.pdf&quot; rel=&quot;nofollow&quot;&gt;TinyLFU: A Highly Efficient Cache Admission Policy&lt;/a&gt;，这篇论文中讨论了一种高效缓存准入策略。TinyLFU 是一种与淘汰无关的准入策略，目的是在以很少的内存开销来提高命中率。主要思想是仅在新的 key 的估计值高于正要被逐出的 key 的估计值时才允许进入 Cache。当缓存达到容量时，每个新的 key 都应替换缓存中存在的一个或多个密钥。并且，传入 key 的估值应该比被淘汰出去的 key 估值高。否则新的 key 禁止进入缓存中。这样做也为了保证高命中率。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/aea2a216dd890be7ed435800b15a8270babd0272d9cc3b0d6360d89772924ca0/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32355f302e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/aea2a216dd890be7ed435800b15a8270babd0272d9cc3b0d6360d89772924ca0/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32355f302e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_25_0.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在将新 key 放入 TinyLFU 中之前，还可以使用 bloom 过滤器首先检查该密钥是否之前已被查看过。仅当 key 在布隆过滤器中已经存在时，才将其插入 TinyLFU。这是为了避免长时间不被看到的长尾键污染 TinyLFU。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/704b61dad0c72d3c3a74177c18bbcc4a5e23d7b72aa9e4e18d1f5331b90bcf41/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32332e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/704b61dad0c72d3c3a74177c18bbcc4a5e23d7b72aa9e4e18d1f5331b90bcf41/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32332e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_23.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于到底选择 LRU 还是 LFU 还是 LRU + LFU ，这个话题比较大，展开讨论又可以写好几篇新文章了。感兴趣的读者可以看看这篇论文，&lt;a href=&quot;https://dgraph.io/blog/refs/Adaptive%20Software%20Cache%20Management.pdf&quot; rel=&quot;nofollow&quot;&gt;Adaptive Software Cache Management&lt;/a&gt; ，从标题上看，自适应的软件缓存管理，就能看出它在探讨了这个问题。论文的基本思想是在主缓存段之前放置一个 LRU “窗口”，并使用爬山技术自适应地调整窗口大小以最大化命中率。&lt;a href=&quot;https://github.com/ben-manes/caffeine&quot;&gt;A high performance caching library for Java 8 — Caffeine&lt;/a&gt; 已经取得了很好的效果。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/40db8628871a8e147705bd477795890abaa604983e2b5c245a3df8ebba0eceb4/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32322e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/40db8628871a8e147705bd477795890abaa604983e2b5c245a3df8ebba0eceb4/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32322e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_22.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可伸缩性方面，选择合适的缓存大小，可以避免 &lt;a href=&quot;https://dzone.com/articles/false-sharing&quot; rel=&quot;nofollow&quot;&gt;False Sharing&lt;/a&gt;，在多核系统中，其中不同的原子计数器（每个8字节）位于同一高速缓存行（通常为64字节）中。对这些计数器之一进行的任何更新都会导致其他计数器被标记为无效。这将强制为拥有该高速缓存的所有其他核心重新加载高速缓存，从而在高速缓存行上创建写争用。为了实现可伸缩性，应该确保每个原子计数器完全占用完整的缓存行。因此，每个内核都在不同的缓存行上工作。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/b05803e27a4c10b4f7691ffb60d173215423941c87058ad13875efb9a5380348/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32342e706e67&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/b05803e27a4c10b4f7691ffb60d173215423941c87058ad13875efb9a5380348/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32342e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_24.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后看看 Go 实现的几个开源 Cache 库。关于这些 Cache 的源码分析，本篇文章就不展开了。(有时间可能会单独再开一篇文章详解)。感兴趣的读者可以自己查阅源码。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/allegro/bigcache&quot;&gt;bigcache&lt;/a&gt;，BigCache 根据 key 的哈希将数据分为 shards。每个分片都包含一个映射和一个 ring buffer。每当设置新元素时，它都会将该元素追加到相应分片的 ring buffer 中，并且缓冲区中的偏移量将存储在 map 中。如果同一元素被 Set 多次，则缓冲区中的先前条目将标记为无效。如果缓冲区太小，则将其扩展直到达到最大容量。每个 map 中的 key 都是一个 uint32 hash，其值是一个 uint32 指针，指向该值与元数据信息一起存储的缓冲区中的偏移量。如果存在哈希冲突，则 BigCache 会忽略前一个键并将当前键存储到映射中。预先分配较少，较大的缓冲区并使用 map[uint32]uint32 是避免承担 GC 扫描成本的好方法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/coocood/freecache&quot;&gt;freecache&lt;/a&gt;，FreeCache 通过减少指针数量避免了 GC 开销。 无论其中存储了多少条目，都只有 512 个指针。通过 key 的哈希值将数据集分割为 256 个段。将新 key 添加到高速缓存时，将使用 key 哈希值的低八位来标识段 ID。每个段只有两个指针，一个是存储 key 和 value 的 ring buffer，另一个是用于查找条目的索引 slice。数据附加到 ring buffer 中，偏移量存储到排序 slice 中。如果 ring buffer 没有足够的空间，则使用修改后的 LRU 策略从 ring buffer 的开头开始，在该段中淘汰 key。如果条目的最后访问时间小于段的平均访问时间，则从 ring buffer 中删除该条目。要在 Get 的高速缓存中查找条目，请在相应插槽 slot 中的排序数组中执行二进制搜索。此外还有一个加速的优化，使用 key 的哈希的 LSB 9-16 选择一个插槽 slot。将数据划分为多个插槽 slot 有助于减少在缓存中查找键时的搜索空间。每个段都有自己的锁，因此它支持高并发访问。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/golang/groupcache&quot;&gt;groupCache&lt;/a&gt;，groupcache 是​​一个分布式的缓存和缓存填充库，在许多情况下可以替代 memcached。在许多情况下甚至可以用来替代内存缓存节点池。groupcache 实现原理和本文在上一章节中实现的方式是一摸一样的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/VictoriaMetrics/fastcache&quot;&gt;fastcache&lt;/a&gt;，fastcache 并没有缓存过期的概念。仅在高速缓存大小溢出时才从高速缓存中淘汰 key 值。key 的截止期限可以存储在该值内，以实现缓存过期。fastcache 缓存由许多 buckets 组成，每个 buckets 都有自己的锁。这有助于扩展多核 CPU 的性能，因为多个 CPU 可以同时访问不同的 buckets。每个 buckets 均由一个 hash（key）-&amp;gt;（key，value）的映射和 64KB 大小的字节 slice（块）组成，这些字节 slice 存储已编码的（key，value）。每个 buckets 仅包含 chunksCount 个指针。例如，64GB 缓存将包含大约 1M 指针，而大小相似的 map[string][]byte 将包含 1B指针，用于小的 key 和 value。这样做可以节约巨大的 GC 开销。与每个 bucket 中的单个 chunk 相比，64KB 大小的 chunk 块减少了内存碎片和总内存使用量。如果可能，将大 chunk 块分配在堆外。这样做可以减少了总内存使用量，因为 GC 无需要 GOGC 调整即可以更频繁地收集未使用的内存。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dgraph-io/ristretto&quot;&gt;ristretto&lt;/a&gt;，ristretto 拥有非常优秀的缓存命中率。淘汰策略采用简单的 LFU，性能与 LRU 相当，并且在搜索和数据库跟踪上具有更好的性能。存入策略采用 TinyLFU 策略，它几乎没有内存开销（每个计数器 12 位）。淘汰策略根据代价值判断，任何代价值大的 key 都可以淘汰多个代价值较小的 key（代价值可以是自定义的衡量标准）。&lt;/p&gt;
&lt;p&gt;以下是这几个库的性能曲线图：&lt;/p&gt;
&lt;p&gt;在一小时内对 CODASYL 数据库的引用：&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/151e787801a41414167b70144115dce7901df2e40f0cb200a64d4b7c7947dd45/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31352e737667&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/151e787801a41414167b70144115dce7901df2e40f0cb200a64d4b7c7947dd45/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31352e737667&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_15.svg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在商业站点上运行的数据库服务器，该服务器在商业数据库之上运行 ERP 应用程序：&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/29d9c85774962b3c969798488f3053ec2f18b0e86b6c927dfa6b0d54c7890bb4/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31362e737667&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/29d9c85774962b3c969798488f3053ec2f18b0e86b6c927dfa6b0d54c7890bb4/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31362e737667&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_16.svg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;循环访问模式：&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/392a158e88b52230ef80269bfbeb2a3116324a87c5ed15c2174e1b0a3b47b29a/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31372e737667&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/392a158e88b52230ef80269bfbeb2a3116324a87c5ed15c2174e1b0a3b47b29a/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31372e737667&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_17.svg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大型商业搜索引擎响应各种 Web 搜索请求而启动的磁盘读取访问：&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/2b7195d90cbfd7689ccd439aaf18f5eee7e1b2d5657c3ecba1927dc247ed95ce/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31382e737667&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/2b7195d90cbfd7689ccd439aaf18f5eee7e1b2d5657c3ecba1927dc247ed95ce/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31382e737667&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_18.svg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;吞吐量：&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/2a86c20b4a4f412877642b6090b7c27b76dce76020b3ab00199d3b19e13a752d/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31392e737667&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/2a86c20b4a4f412877642b6090b7c27b76dce76020b3ab00199d3b19e13a752d/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f31392e737667&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_19.svg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/aef7013bbfc29f945ce7a6cc6ca5efabdb46916c5f3cb1c61820facca0042dc9/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32302e737667&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/aef7013bbfc29f945ce7a6cc6ca5efabdb46916c5f3cb1c61820facca0042dc9/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32302e737667&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_20.svg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/2f95703e7578ebb9759c145186a3604de428a00492682c0589272e7e341630b4/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32312e737667&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/2f95703e7578ebb9759c145186a3604de428a00492682c0589272e7e341630b4/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f3134365f32312e737667&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img.halfrost.com/Blog/ArticleImage/146_21.svg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-推荐阅读&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#推荐阅读&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://dgraph.io/blog/refs/bp_wrapper.pdf&quot; rel=&quot;nofollow&quot;&gt;BP-Wrapper: A System Framework Making Any
Replacement Algorithms (Almost) Lock Contention Free&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://dgraph.io/blog/refs/Adaptive%20Software%20Cache%20Management.pdf&quot; rel=&quot;nofollow&quot;&gt;Adaptive Software Cache Management&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://dgraph.io/blog/refs/TinyLFU%20-%20A%20Highly%20Efficient%20Cache%20Admission%20Policy.pdf&quot; rel=&quot;nofollow&quot;&gt;TinyLFU: A Highly Efficient Cache Admission Policy&lt;/a&gt;
&lt;a href=&quot;http://web.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-02-6.pdf&quot; rel=&quot;nofollow&quot;&gt;LIRS: An Efficient Low Inter-reference Recency Set Replacement Policy to Improve Buffer Cache Performance&lt;/a&gt;
&lt;a href=&quot;https://www.usenix.org/event/fast03/tech/full_papers/megiddo/megiddo.pdf&quot; rel=&quot;nofollow&quot;&gt;ARC: A Self-Tuning, Low Overhead Replacement Cache&lt;/a&gt;&lt;/p&gt;
&lt;/article&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>