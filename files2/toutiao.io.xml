<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>96fbe25d32bca208be385a3fa9f5274c</guid>
<title>一文带你了解推荐系统之标签体系</title>
<link>https://toutiao.io/k/nyb3xq7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8e928ab8df37c1f72a3a48c9d08688c1</guid>
<title>如何构建业务数据分析体系</title>
<link>https://toutiao.io/k/2zcuj5x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;关注微信公众号：一个数据人的自留地&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;作者介绍&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;@小宇&lt;/p&gt;&lt;p&gt;专注流量数据分析，就职过360和58。&lt;/p&gt;&lt;p&gt;主要负责流量分析和商业变现等相关数据分析工作。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;00&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;BEGIN&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;提及 “体系” 二字，我的脑海里浮现出老板说的 “对于工作的规划要从全局出发，内容要全面、要成体系！” 那么对于一个数据分析师而言我们的体系是什么？&lt;span&gt;是&lt;/span&gt; “目标监控体系？”，是 “运营分析体系？” ，还是 “APP 指标体系？” 到底该如何构建数据分析体系赋能业务呢？今天就来跟大家聊聊体系构建的话题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;构建业务数据分析体系，对于分析师同学有两个方面的要求：&lt;strong&gt;&lt;span&gt;第一，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;要了解业务模式&lt;/strong&gt;&lt;/span&gt;，能够解释数据背后的业务含义，找到业务的问题点、提升点，驱动业务向前发展；&lt;strong&gt;&lt;span&gt;第二，不&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;能只做数据、图表的堆砌&lt;/strong&gt;&lt;/span&gt;，需要根据业务的流程链路有目标、有逻辑、有顺序的分模块分专题展现数据。满足这两个方面的要求才是真正意义上的数据分析体系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面结合我的工作场景，给大家讲讲业务数据分析体系搭建的基本思路。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;明确业务逻辑&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分析师同学要明确自己服务的业务是什么？业务逻辑是什么？业务核心是什么？在业务的基础上构建分析体系，才能让分析结果更接地气，更好的应用到业务中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以流量外采业务为例，梳理业务逻辑（如下图）：各业务线发起流量需求 → 多渠道进行流量采买 → 流量引入落地页 → 落地页产生流量转化 → 流量变现、效果转化，这一系列步骤决定采买目标是否达成。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5143229166666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jWg3EibnYW99HMiaRAAMb2HRjYkyV0woQK8dVicwN4CX6Y3PGVWdgqzKyYufW1vhu54NxOJcpAmxlxyicoDabpc2sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;拆解分析模块&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;明确了业务逻辑后，根据目标和事件顺序进行分析模块拆解，明确各个目标分析的专题及关注核心。流量外采业务拆解分析模块如下：&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4734982332155477&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jWg3EibnYW99HMiaRAAMb2HRjYkyV0woQK86cqUgRnvJ5CkqHVRhAC3mG4VoG9icq6XicEW2JFEqicaougnZIuGBmIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;849&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;采买效率&lt;/strong&gt;&lt;/span&gt;关注核心：有多少预算？现在以什么样的价格买了多少流量？当前出价能否实现目标最大化？预算、价格、采买流量无论调节哪一项，只有三者维持平衡，才能实现流量供给相对稳定。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;广告填充&lt;/strong&gt;&lt;/span&gt;直接影响流量变现。因此，在保证广告主预算合理消耗、效果满足预期的前提下，不断提升页面广告填充率，从而提升流量变现效率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;用户行为&lt;/strong&gt;&lt;/span&gt;既能够决定收入转化又能够决定效果转化。细致研究收入、效果转化用户在单页面中有哪些行为、访问了几层页面、点—面—点—转化/跳出的访问路径是什么。根据转化用户特征优化产品策略从而帮助业务提升流量转化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以上各个模块的优化目的是为了达成共同的业务目标，&lt;strong&gt;&lt;span&gt;目标达成&lt;/span&gt;&lt;/strong&gt;的数据监控基础且重要。收入、效果、投入产出的数据表现直观的描述了业务现状和目标达成情况，及时的&lt;span&gt;监控&lt;/span&gt;目标达成有助于业务稳定健康发展。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;确定分析指标&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;确定了分析模块后，开始选定各个模块的分析指标，指标基本分为：结果量、转化率两类。结果量描述规模和目标达成，转化率描述效果。根据业务路径选取关键节点的转化和重要结果达成作为分析指标。按照路径的先后顺序列出指标，形成了核心数据看板，完成了数据体系的搭建。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于流量外采业务分析模块，可拆解出如下数据看板：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5452609158679447&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jWg3EibnYW99HMiaRAAMb2HRjYkyV0woQKV0Vnk2GmIAjlSVLgTNO6r54IoOBIjxdWdvcNIbevOZYBrTv26QnVcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;939&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;04&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;洞察走势与业务同步发展&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了清晰业务结构、模块拆解，数据看板就可以跟踪业务走势。在跟踪的时候，首先关注的是：目标达成情况。目标达成决定了后续一系列行动判断，根据业务走势的波动情况定位异常问题、发现业务提升点。产品、运营同学根据数据结论制定每个阶段的行动计划，同时分析师也要不断变换分析视角与业务联动实现同步发展。&lt;/p&gt;&lt;p&gt;如下示例：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5183673469387755&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jWg3EibnYW99HMiaRAAMb2HRjYkyV0woQKX1gNZCN9h0N6ZUgTCnCmoUicS9wlCtTRZicicNzc16MWwWTveoXZcQB5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;735&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;根据业务阶段性动作，明确阶段核心，定制专题分析方向：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;05&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;驱动业务增长&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;驱动业务增长是高阶数据分析要实现的目标之一。想要改善业务，就必须了解业务细节，发现问题，找出关键点，给出科学合理的优化方案，推动方案落地，才能实现业务增长。其中发现问题&lt;span&gt;、找关键点&lt;/span&gt;、优化方案、推动落地都属于数据驱动的范畴。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如流量采买业务中需求与供给匹配的问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.47050359712230216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jWg3EibnYW99HMiaRAAMb2HRjYkyV0woQKicmNXnr0zDKicicCN0OPCia8Tqx0lBm7HCr0uAF2jvScoAWM80xRqKE3kA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;695&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4943502824858757&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jWg3EibnYW99HMiaRAAMb2HRjYkyV0woQKhylJwcTTBeibfmv4qJSl7bQLJticau9ocwAbxQ2IZaiay9rQicsIz9wb3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;具体应该如何分配流量？这就找到了数据分析在项目中可以为项目实践提供价值的地方。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;根据规划求解的原理解决业务中流量分配的问题，具体方法参见《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxMzAxNzEwNQ==&amp;amp;mid=2648095269&amp;amp;idx=1&amp;amp;sn=f934858a0e4091ee92e52527d9ebad31&amp;amp;chksm=8f9f2d5bb8e8a44d79af3c47c8db438e2bcb32f6bf72148a8bb08188289e289c33508cb0d0ae&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;规划求解应用—预算分配&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;规划求解应用—预算分配&lt;/a&gt;》。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37729357798165136&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jWg3EibnYW99HMiaRAAMb2HRjYkyV0woQKWcNMcp95HzH9nuvibc9hewicZf4iapTZfOLJbMDeEicSgaBxkdMeP34ClQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;872&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;项目实践测试的过程中，分析师需要不断跟进评估实验效果、推全后复盘项目的目标达成和可迭代升级的内容。实现全流程的参与、评估、决策才能称之为数据分析驱动业务增长。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;06&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;形成数据体系&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;构建数据分析体系的本质是：满足业务需求，解决业务问题，驱动业务增长。在满足需求、发现问题、解决问题、&lt;span&gt;跟进&lt;/span&gt;项目、落地复盘的过程中分析师同学要不断的提炼总结，进而形成自己的数据分析体系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;它可以是个思维导图，可以是个表格，也可以是个文档。无论哪种形式只要实现了数据分析体系本质，发挥了它应有的作用&lt;span&gt;，落&lt;/span&gt;&lt;span&gt;在了&lt;/span&gt;&lt;span&gt;具体业务&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;，就是一个优秀的业务数据分析体系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;回到流量采买业务的示例，总结提炼形成的数据体系如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6572199730094467&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jWg3EibnYW99HMiaRAAMb2HRjYkyV0woQKian7iciaILAw2twccPZZNkiaaGOtwRibILTtZ8Euz23bEcqicz32dtnFhSNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;741&quot;/&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;现实中，很多分析师同学掌握了专业的统计分析方法、分析工具、算法模型，但在与业务配合的过程中，总是很关注自己的理论深度、难度、专业度，却忽略了与业务的贴合度，因此&lt;span&gt;分析结构&lt;/span&gt;就没有办法形成体系化的分析结构，分析技能也只能停留在初级水平。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;用专业的方法服务个性化需求，将分析结果推广至业务中，只要这样才能真正的实现分析师价值，同时你也从初级成长为高级。&lt;/p&gt;&lt;p&gt;&lt;span&gt;希望对你有所启发！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jWg3EibnYW9ibAUWI7stk9Kiaq14L7AJ6C1xJZWuVcLxtgibUBppKquBclraqDj9W3gTKeibZE18BpQXCJE2TianfycA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据人交流和学习的社区，关注我们，掌握专业数据知识、结识更多的数据小伙伴。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;带你探索数据的神奇奥秘&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>15fa99d986622da92597511ab7e6abbf</guid>
<title>[译] 编程高手是如何练成的？</title>
<link>https://toutiao.io/k/7c85i29</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body detail-content&quot;&gt;&amp;#13;
                &amp;#13;
                &lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;http://download.broadview.com.cn/Original/2102c71e14027d3e8c3a&quot;/&gt;&amp;#13;
&lt;/p&gt;&lt;p&gt;每个人都有成长的渴望，也都会遇到成长的瓶颈。下面这个问题是一个读者问我的：&lt;br/&gt;如何才能训练成为一个编程高手？&amp;#13;
&lt;/p&gt;&lt;p&gt;先简单说下这个读者的背景：工作 3 年多，目前在大厂做后台开发，身边有不少编程高手，是他想要追赶的目标。&lt;br/&gt;最近半年时间，他花了一些精力在研究源码和底层原理上，但总觉得这些知识和实际工作衔接不好，提升很慢，学习动力也越来越差，希望我能给点建议。&lt;br/&gt;我和他语音聊了半个小时，讲了一些我个人以及身边同事的案例。交流下来后，双方都有所启发。所以再次整理下，分享给大家。&amp;#13;
&lt;/p&gt;&lt;p&gt;— 1 —&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;何谓 “编程高手” ？&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;我觉得能分成这样 3 类：&lt;/p&gt;&amp;#13;
&lt;p&gt;第 1 类：天赋和成就都很高的人中龙凤，比如能一个人写出 WPS 的求伯君、一个人开发出电子邮件 Foxmail 的张小龙，对开源领域影响很大的章亦春等人。&lt;/p&gt;&amp;#13;
&lt;p&gt;第 2 类：有不错的口碑同时广为人知的技术大牛，他们一般在知名公司的重要岗位任职过，对技术纯真热爱，同时热衷分享，比如耗子哥、阮一峰、尤雨溪等人。&lt;/p&gt;&amp;#13;
&lt;p&gt;第 3 类：工作中被我们视为崇拜对象、未来有希望企及的高 P 或者架构师。&lt;/p&gt;&amp;#13;
&lt;p&gt;前面两类不在我的圈层射程内（除了跟耗子哥在亚马逊有过一面之缘以外），因此本文主要聊下第 3 类人。这个也是绝大部分读者最关心的、同时可以设定为超越对象的群体。&lt;br/&gt;这样就有了一个新问题：既然想成为第 3 类人，那如何给第 3 类人下一个相对准确且具象的定义呢？（如果目标都是模糊的，就难言超越了）&lt;br/&gt;这其实是一个很有意思的问题，每个人的答案可能都不一样，因为「编程水平的高与低」本身就是一个相对的概念。&lt;br/&gt;我先说一下我的看法。&lt;br/&gt;刚毕业那会，我眼中的编程高手是我的同事 - 超哥，他是亚马逊的架构师，团队里面技术级别最高的人（后来他做到了亚马逊中国首架的位置，现在也算圈内比较知名的大牛了）。&lt;br/&gt;超哥是那种能搞定一个复杂项目（跨多个系统），从架构设计、到编码、到自动化测试、再到运维工具、甚至写文档都非常全面的人。显然是我这个刚毕业的菜鸟极其崇拜的大佬。&lt;br/&gt;再后来，我工作了四五年，走向了技术管理路线，因为带团队的原因，我又多了一个新视角来审视编程厉害的人。&lt;br/&gt;对比所谓的 PPT 架构师、以及讲到技术原理就满嘴跑火车而编码能力却稀松平常的人，我倾向给「编程高手」下一个更务实的定义：那就是实际工作中，能做到高效率、高质量、且稳定输出的人。看似容易，实则很难。我对这个定义的详细解读如下：&amp;#13;
&lt;/p&gt;&lt;p&gt;高效率：编程效率能做到团队中的 Top，对于复杂需求或者复杂问题能够快速理解，具备将复杂工作拆解成一系列简单子问题并搞定这些问题的人。他们能从实际场景出发，有造轮子的能力，也有不造轮子的觉悟。&lt;/p&gt;&amp;#13;
&lt;p&gt;高质量：编程质量能做到团队中的 Top，设计方案的合理性、编码的严谨性、测试方法、监控运维方案等，都能思考全面的人。&lt;/p&gt;&amp;#13;
&lt;p&gt;稳定输出：给高效率和高质量增加的限定。我觉得只有量变引起质变，真正形成了自己的方法论，能持续搞定一类问题，而不是单个问题的人才算是高手。&lt;/p&gt;&amp;#13;
&lt;p&gt;也许你会说要同时做到这 3 点太难了，但是实际工作中，一定有人能做到某个点或者某几点，那么以他们作为这一点的标杆即可。&lt;br/&gt;因为所谓的「编程高手」不过是我们设定的一个目标而已，你清楚这个目标是什么就足够了，不一定非得安在同一个人身上。&amp;#13;
&lt;/p&gt;&lt;p&gt;— 2 —&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;如何理解 “底层知识” 的价值？&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;要成为一个编程高手，底层知识是必不可少的。这是一句正确的废话，就不展开解释了。&lt;br/&gt;读者真正的问题在于：如何将底层知识和实际工作衔接起来，做到相辅相成？&lt;br/&gt;先看一个具体的例子。对于简历中写自己做过性能优化的候选人，我面试时比较喜欢问：你是如何定位性能瓶颈并完成调优的？如果再次碰到此类问题，你的详细思路是什么？&lt;br/&gt;很显然，这是一个系统性的工程问题，能同时对技术深度和宽度进行考察。&lt;br/&gt;不仅仅是应用层的代码，还包括所使用的框架、中间件、虚拟机、网络甚至操作系统等等。有性能指标等基础性的知识，有监控和压测工具的运用，还有成体系的排查思路和优化方法等等。&lt;br/&gt;如果是编程低手，他们的答案通常有这几类：&amp;#13;
&lt;/p&gt;&lt;p&gt;1、性能指标都不清楚，遇到问题也不知道该用什么工具，这一类人应用层都不达标。&lt;/p&gt;&amp;#13;
&lt;p&gt;2、初步定位到一个疑似瓶颈点后，就着手优化，最终解决的只是一个浅层次的性能瓶颈问题，根本原因并未触达到。&lt;/p&gt;&amp;#13;
&lt;p&gt;3、能定位到根本原因，但是对于解决方案的合理性缺少深入思考，不追求极致，最终只是用了曲线的方案再次隐藏了性能问题。&lt;/p&gt;&amp;#13;
&lt;p&gt;通过这个例子，我其实想说明两点：&lt;/p&gt;&amp;#13;
&lt;p&gt;1、不具备底层知识，你的视野根本就触达不到底层的东西，思维以及能力永远只能停留在应用层面，能解决的问题有限。&lt;/p&gt;&amp;#13;
&lt;p&gt;2、读源码、学习各种原理，所有这些都只是学习和巩固知识的过程，真正体现编程水平的是实际解决问题的能力，因此如何将知识变成有效的经验？这个才是关键，做不到要么是实践不够，要么是压根没研究明白。&lt;/p&gt;&amp;#13;
&lt;p&gt;然后，我们再回到问题身上：究竟如何才能做到底层知识和实际工作的衔接呢？如果衔接不好，那问题出在哪个环节？&lt;br/&gt;大家可以先思考下：过往工作中那些对你编程能力帮助很大的经历，你认为你能获得提升最关键的因素是什么？是底层知识的储备吗？&lt;br/&gt;细想一下一定不是，而是发现问题的能力。（注意：我说的是最关键的因素，并不是否认底层知识的储备不重要）&lt;br/&gt;大家可以去观察一个工作中很常见的现象：同一个问题你能看到哪一层？而编程高手又能看到哪一层？谁能更快地贴近问题的本质？谁又能衍生出一系列的问题？这其实就是「发现问题」的能力体现。&lt;br/&gt;只有当你意识到它是一个值得深挖的问题时，才会有一层一层的思考，一层一层的分析。&lt;br/&gt;那应该如何提高这方面的能力呢？其实就是思考力的提升过程，除了观察和刻意练习，我想不出更好的建议。多看高手是怎么做的？遇到问题时自己多问几个为什么？多反思自己的思路是否正确？日积月累水平自然会提高。&lt;br/&gt;当你具备了发现问题的能力，就相当于给知识和经验之间架起了一座桥梁，真正做到相辅相成以及互相驱动。&amp;#13;
&lt;/p&gt;&lt;p&gt;— 3 —&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;成为 “编程高手” 的几点建议&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;编程作为一门实践性的学科，多动手解决问题是最基本的要求了，解决问题越多、越难，能力提升越快。&lt;br/&gt;而在这个过程中，如果有知识输入（底层知识的储备），还有思考的加成（发现问题的能力），编程水平的提升会更加迅速。&lt;br/&gt;我带过的团队里面，还有一类人总说自己技术进步很慢，工作没有挑战。但是当团队遇到一个技术难题时，他根本没有意愿去做深入了解，嘴上说热爱技术、渴望成长，但是却看不到行动，这种人是永远成为不了编程高手的。&lt;br/&gt;真正的热爱来源于行动上的投入，不是找借口，不是追求舒服，这是很重要的一个区别。&amp;#13;
&lt;/p&gt;&lt;p&gt;编程高手是如何练成的？这样看来，它其实是一个体力、脑力、心力的修仙之路。&lt;/p&gt;&amp;#13;
&lt;h1 id=&quot;h1-u56FEu4E66u63A8u8350&quot;&gt;&lt;a name=&quot;图书推荐&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;图书推荐&lt;/h1&gt;&lt;p&gt;▊&lt;a title=&quot;《程序员修炼之道：通向务实的最高境界（第2版）》&quot; href=&quot;http://www.broadview.com.cn/book/6274&quot;&gt;《程序员修炼之道：通向务实的最高境界（第2版）》&lt;/a&gt;&lt;br/&gt;[美] David，Thomas，Andrew，Hunt 著&amp;#13;
&lt;/p&gt;&lt;p&gt;云风 译&lt;/p&gt;&amp;#13;
&lt;p&gt;本书之所以在全球范围内广泛传播，被一代代开发者奉为圭臬，盖因它可以创造出真正的价值：或编写出更好的软件，或探究出编程的本质，而所有收获均不依赖于特定语言、框架和方法。&lt;/p&gt;&amp;#13;
&lt;p&gt;时隔20年的新版，经过全面的重新选材、组织和编写，覆盖哲学、方法、工具、设计、解耦、并发、重构、需求、团队等务实话题的最佳实践及重大陷阱，以及易于改造、复用的架构技术。本书极具洞察力与趣味性，适合从初学者到架构师的各阶层读者潜心研读或增广见闻。&lt;/p&gt;&amp;#13;
&amp;#13;
            &lt;/div&gt;&amp;#13;
&amp;#13;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b8098f7a4e62d5eaf5f99730867ae331</guid>
<title>用 Pandas 计算日志中事件的时间间隔</title>
<link>https://toutiao.io/k/o73tkeh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/attachment/18c599fbfd924453b429eaabacf6dc21/w600&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通常我们需要对日志数据清洗出一些事件间隔的特征，给数据分析或者机器学习建模提供数据支持。&lt;/p&gt;

&lt;p&gt;假设我们有一些事件日志，这些日志记录了用户在App中事件类型、时间戳、用户ID等其他一些数据，像下面这样:&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;data = &quot;&quot;&quot;user_id,event_time,event_type
100003,2021-01-18 01:06:00,onLaunch
100001,2021-01-19 08:30:00,onLaunch
100003,2021-01-20 02:39:00,onLaunch
100003,2021-01-20 08:15:00,onLaunch
100002,2021-01-20 10:05:00,onLaunch
100001,2021-01-20 14:40:00,onLaunch
100001,2021-01-20 18:05:00,onLaunch
100002,2021-01-21 21:11:00,onLaunch
100003,2021-01-22 10:05:00,onLaunch
100001,2021-01-23 09:18:00,onLaunch
100003,2021-01-23 17:35:00,onLaunch
100001,2021-01-25 16:49:00,onLaunch
100003,2021-01-26 12:13:00,onLaunch
100001,2021-01-27 19:56:00,onLaunch&quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们把日志读取到 Pandas 的内存表 DataFrame 中．真实环境可以通过 &lt;code&gt;read_sql&lt;/code&gt; 或者 &lt;code&gt;read_csv&lt;/code&gt; 等方法读取数据源&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;import pandas as pd
ldata = [x.split(&#x27;,&#x27;) for x in data.split(&#x27;\n&#x27;)]
df = pd.DataFrame(ldata[1:], columns=ldata[0])
df[&#x27;event_time&#x27;] =  pd.to_datetime(df[&#x27;event_time&#x27;])
df.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th/&gt;
      &lt;th&gt;user_id&lt;/th&gt;
      &lt;th&gt;event_time&lt;/th&gt;
      &lt;th&gt;event_type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;100003&lt;/td&gt;
      &lt;td&gt;2021-01-18 01:06:00&lt;/td&gt;
      &lt;td&gt;onLaunch&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;100001&lt;/td&gt;
      &lt;td&gt;2021-01-19 08:30:00&lt;/td&gt;
      &lt;td&gt;onLaunch&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;100003&lt;/td&gt;
      &lt;td&gt;2021-01-20 02:39:00&lt;/td&gt;
      &lt;td&gt;onLaunch&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;100003&lt;/td&gt;
      &lt;td&gt;2021-01-20 08:15:00&lt;/td&gt;
      &lt;td&gt;onLaunch&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;100002&lt;/td&gt;
      &lt;td&gt;2021-01-20 10:05:00&lt;/td&gt;
      &lt;td&gt;onLaunch&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们希望提取出每个用户的启动次数（&lt;code&gt;lifetime_launchs&lt;/code&gt;）、昨日启动次数(&lt;code&gt;yesterday_launchs&lt;/code&gt;) 以及距离上次登录的天数 (&lt;code&gt;days_since_last_launch&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;使用 pandas，我们按照用户和日期进行汇总，得到每个用户每天的启动次数。&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;user_launchs = (df.set_index(&#x27;event_time&#x27;)
               .groupby([&#x27;user_id&#x27;, pd.Grouper(freq=&#x27;D&#x27;)])
               .size()
               .rename(&#x27;launchs&#x27;))
user_launchs
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;user_id  event_time
100001   2021-01-19    1
         2021-01-20    2
         2021-01-23    1
         2021-01-25    1
         2021-01-27    1
100002   2021-01-20    1
         2021-01-21    1
100003   2021-01-18    1
         2021-01-20    2
         2021-01-22    1
         2021-01-23    1
         2021-01-26    1
Name: launchs, dtype: int64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，这里只有有启动的日志，日期不连续，为了提取出上面的特征，我们需要填充没有启动的日期.
把用户放到一个连续的时间轴上.&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;# 创建一个日期范围作为 DataFrame 的索引
dates = pd.date_range(df.event_time.min().date(),
                      df.event_time.max().date(),
                      freq=&#x27;1D&#x27;)

# 取出去重的用户ID
users = df[&#x27;user_id&#x27;].unique()


# 通过用户和日期交叉创建出一个 MultiIndex
idx = pd.MultiIndex.from_product([users, dates], names=[&#x27;user_id&#x27;, &#x27;event_time&#x27;])

# 索引建索引
user_launchs = user_launchs.reindex(idx)

user_launchs.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;user_id  event_time
100003   2021-01-18    1.0
         2021-01-19    NaN
         2021-01-20    2.0
         2021-01-21    NaN
         2021-01-22    1.0
Name: launchs, dtype: float64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们构建了一个连续的时间序列．现在可以提取我们需要的特征了.&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;# 为空的数据行把空填充0,并转成 DataFrame
user_launchs = user_launchs.fillna(0).to_frame()
user_launchs.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th&gt;launchs&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;user_id&lt;/th&gt;
      &lt;th&gt;event_time&lt;/th&gt;
      &lt;th/&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th rowspan=&quot;5&quot; valign=&quot;top&quot;&gt;100003&lt;/th&gt;
      &lt;th&gt;2021-01-18&lt;/th&gt;
      &lt;td&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-19&lt;/th&gt;
      &lt;td&gt;0.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-20&lt;/th&gt;
      &lt;td&gt;2.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-21&lt;/th&gt;
      &lt;td&gt;0.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-22&lt;/th&gt;
      &lt;td&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;通过&lt;code&gt;shift&lt;/code&gt;方法向下移动一行作为下一行的前一天，给 user_launchs 增加 &lt;code&gt;launchs_yesterday&lt;/code&gt; 字段&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;user_launchs[&#x27;launchs_yesterday&#x27;] = user_launchs.groupby(level=&#x27;user_id&#x27;)[&#x27;launchs&#x27;].shift(1)
user_launchs.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th&gt;launchs&lt;/th&gt;
      &lt;th&gt;launchs_yesterday&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;user_id&lt;/th&gt;
      &lt;th&gt;event_time&lt;/th&gt;
      &lt;th/&gt;
      &lt;th/&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th rowspan=&quot;5&quot; valign=&quot;top&quot;&gt;100003&lt;/th&gt;
      &lt;th&gt;2021-01-18&lt;/th&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-19&lt;/th&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-20&lt;/th&gt;
      &lt;td&gt;2.0&lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-21&lt;/th&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;2.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-22&lt;/th&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;滚动的累计出当前日期下每个用户的总启动次数，给 user_launchs 增加 &lt;code&gt;lifetime_launchs&lt;/code&gt; 字段．&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;user_launchs[&#x27;lifetime_launchs&#x27;] = (user_launchs
                                  .groupby(level=&#x27;user_id&#x27;)
                                  .launchs.cumsum()
                                  .groupby(level=&#x27;user_id&#x27;).shift(1))
user_launchs.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th&gt;launchs&lt;/th&gt;
      &lt;th&gt;launchs_yesterday&lt;/th&gt;
      &lt;th&gt;lifetime_launchs&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;user_id&lt;/th&gt;
      &lt;th&gt;event_time&lt;/th&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th rowspan=&quot;5&quot; valign=&quot;top&quot;&gt;100003&lt;/th&gt;
      &lt;th&gt;2021-01-18&lt;/th&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-19&lt;/th&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-20&lt;/th&gt;
      &lt;td&gt;2.0&lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-21&lt;/th&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;2.0&lt;/td&gt;
      &lt;td&gt;3.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-22&lt;/th&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;3.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;user_launchs.groupby(level=&#x27;user_id&#x27;).cumsum().groupby([&#x27;user_id&#x27;, &#x27;launchs&#x27;]).cumcount()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;user_id  event_time
100003   2021-01-18    0
         2021-01-19    1
         2021-01-20    0
         2021-01-21    1
         2021-01-22    0
         2021-01-23    0
         2021-01-24    1
         2021-01-25    2
         2021-01-26    0
         2021-01-27    1
100001   2021-01-18    0
         2021-01-19    0
         2021-01-20    0
         2021-01-21    1
         2021-01-22    2
         2021-01-23    0
         2021-01-24    1
         2021-01-25    0
         2021-01-26    1
         2021-01-27    0
100002   2021-01-18    0
         2021-01-19    1
         2021-01-20    0
         2021-01-21    0
         2021-01-22    1
         2021-01-23    2
         2021-01-24    3
         2021-01-25    4
         2021-01-26    5
         2021-01-27    6
dtype: int64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;距离上次登录的天数 (&lt;code&gt;days_since_last_launch&lt;/code&gt;)&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;user_launchs[&#x27;days_since_last_launch&#x27;] = (user_launchs
                                        .groupby(level=&#x27;user_id&#x27;)
                                        .cumsum()
                                        .groupby([&#x27;user_id&#x27;, &#x27;launchs&#x27;])
                                        .cumcount()
                                        .groupby(level=&#x27;user_id&#x27;).shift(1))
user_launchs.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th&gt;launchs&lt;/th&gt;
      &lt;th&gt;launchs_yesterday&lt;/th&gt;
      &lt;th&gt;lifetime_launchs&lt;/th&gt;
      &lt;th&gt;days_since_last_launch&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;user_id&lt;/th&gt;
      &lt;th&gt;event_time&lt;/th&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th rowspan=&quot;5&quot; valign=&quot;top&quot;&gt;100003&lt;/th&gt;
      &lt;th&gt;2021-01-18&lt;/th&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-19&lt;/th&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-20&lt;/th&gt;
      &lt;td&gt;2.0&lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-21&lt;/th&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;2.0&lt;/td&gt;
      &lt;td&gt;3.0&lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-22&lt;/th&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;3.0&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;类似的，我们还可以滚动的创建 &lt;code&gt;launchs_last_n_days&lt;/code&gt;&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;for n in [7, 14]: 
    col = &#x27;launchs_last_{}_days&#x27;.format(n)
    user_launchs[col] = (user_launchs
                        .groupby(level=&#x27;user_id&#x27;)
                        .launchs
                        .apply(lambda d: d.rolling(n).sum().shift(1)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给空值填充 &lt;code&gt;0&lt;/code&gt;, 并格式化为 integer 类型&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;user_launchs.fillna(0).applymap(int)
&lt;/code&gt;&lt;/pre&gt;

&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th&gt;launchs&lt;/th&gt;
      &lt;th&gt;launchs_yesterday&lt;/th&gt;
      &lt;th&gt;lifetime_launchs&lt;/th&gt;
      &lt;th&gt;days_since_last_launch&lt;/th&gt;
      &lt;th&gt;launchs_last_7_days&lt;/th&gt;
      &lt;th&gt;launchs_last_14_days&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;user_id&lt;/th&gt;
      &lt;th&gt;event_time&lt;/th&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th rowspan=&quot;10&quot; valign=&quot;top&quot;&gt;100003&lt;/th&gt;
      &lt;th&gt;2021-01-18&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-19&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-20&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-21&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-22&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-23&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-24&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-25&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-26&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-27&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th rowspan=&quot;10&quot; valign=&quot;top&quot;&gt;100001&lt;/th&gt;
      &lt;th&gt;2021-01-18&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-19&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-20&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-21&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-22&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-23&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-24&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-25&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-26&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-27&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th rowspan=&quot;10&quot; valign=&quot;top&quot;&gt;100002&lt;/th&gt;
      &lt;th&gt;2021-01-18&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-19&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-20&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-21&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-22&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-23&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-24&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-25&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-26&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2021-01-27&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;是不是很神奇&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4cd9d0b868239025d4061db08b50c960</guid>
<title>为什么说 TypeScript 是开发大型前端项目的必备语言</title>
<link>https://toutiao.io/k/eivpxcf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么说 TypeScript 是开发大型前端项目的必备语言&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;怎么忍心怪你犯了错，是我给你自由过了火。-- 张信哲《过火》&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能很多软件工程师都或多或少知道或了解 TypeScript（简写 TS），使用过 TypeScript 的前端开发者们也出奇一致的对 TypeScript 抱有好感。如果你在搜索引擎里搜索 TypeScript，会发现几乎铺天盖地都是称赞或表扬 TS 的文章，例如 《TypeScript 让你不会想用回 JavaScript》、《TypeScript 真香系列》、《再不拥抱TypeScript你就老了！》。根据最新的 《2020 State of JS 调研报告》，TypeScript 的受欢迎度（Popularity）以及满意度（Satisfaction）都在逐年增加，包括本文作者在内的 “TS 粉”（在 State of JS 中回答 “会继续使用”）的开发者甚至超过了 70%（如下图）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vh4PtSfBxFMiagajmVjiaNAjY1doibjKtKggmnmCLLDOzyHq3eEu0glyvnWfBo2USeiaBbRkgmF5zZIc6icf2Y6SMgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4935185185185185&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;typescript-2020-stateofjs-survey&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总而言之，TS 如今在前端领域具有不可撼动的核心地位，是非常重要的前端工程开发工具。TS 是微软在拥抱开源项目之后为软件行业作出的突出贡献之一。然而，TypeScript 既不能提高 JavaScript 代码在浏览器中的运行效率，又不像 React、Vue 前端框架那样可以提高开发人员的生产力，更不能让你开发的前端页面变得好看而吸引人。那究竟是什么让它成为如此广受欢迎的 “真香语言” 呢，是什么让它令前端人员爱不释手呢？如果你带有这样类似的疑问，请继续阅读接下来的内容，本文将详细解释利用 TS 开发大型前端项目的优势。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;TS 简介&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vh4PtSfBxFMiagajmVjiaNAjY1doibjKtKgv97MOxVJq2N7n7cB8VEW1aibbMmaQX2icNXUicK6kFPGEhhjibG2icKia30Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;1&quot; data-w=&quot;474&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;typescript-es6&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypeScript 诞生于微软（Microsoft），由 C# 首席架构师、.NET（dotnet）创立者 Anders Hejlsberg 设计开发。TypeScript 简单来说就是强类型系统的 JavaScript。它是 JS 的超集（Superset），也就是说，TS 支持 JS 中所有语法，并且还扩展了很多面向对象编程（OOP）的一些功能。TypeScript 首个公开版本 0.8 于 2012 年 10 月发布，并受到了 GNOME 之父 Miguel de Icaza 的称赞，不过他指出 TypeScript 的最大缺点是它缺乏成熟的 IDE 支持，例如当时唯一能支持 TS 只有运行在 Windows 上的 Visual Studio，因此 Mac 和 Linux 使用者无法有效使用 TS 编写项目。不过，这个缺点很快被克服了。1 年之后，很多编辑器，例如 Eclipse、Sublime、Vim 等，都开始支持 TypeScript 语法。如今，绝大多数主流编辑器都能有效支持 TypeScript。而有了 TypeScript 的加持，你在 IDE 中就可以爽快的享受 TS 特有的自动完成（Autocomplete）以及类型提示（Typing Hint），以便于编写可靠而高质量的代码。正如官网中对 TypeScript 的一句话介绍：“Typed JavaScript at Any Scale”。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面向接口编程&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypeScript 的设计理念来自于面向接口编程（IOP），一种基于抽象类型约定（Abstract Type Constraint）的程序设计模式。要真正了解 TypeScript，首先得了解面向接口编程的概念和原理。最初引入 IOP 概念的论文《面向接口编程》发表于 2004 年，它属于面向对象编程（OOP）体系的一部分，是更为先进和独立的编程思想。作为 OOP 体系的一部分，IOP 更加强调规则和约束，以及接口类型方法的约定，从而让开发人员尽可能的关注更抽象的程序逻辑，而不是在更细节的实现方式上浪费时间。很多大型项目采用的都是 IOP 的编程模式。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vh4PtSfBxFMiagajmVjiaNAjY1doibjKtKg64B7kj440jIicGeka9NpehEnTO07G1AibsNV0znB7HpA2vGBHuS6WYAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.8033980582524272&quot; data-w=&quot;824&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;typescript-iop&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图是 IOP 编程模式的示意图，在  Java 或 C# 这样的 OOP 语言中，随处可见这样的处理方式。类型（Class）的方法（Method）由接口（Interface）来约定，而类型中需要实现（Implement）接口中定义的抽象方法。例如 &lt;code&gt;IService&lt;/code&gt; 接口定义了 &lt;code&gt;Request(url)&lt;/code&gt;、&lt;code&gt;Auth(usr, pwd)&lt;/code&gt; 方法，而这个接口不管这两个方法如何实现，只是将方法的名称、参数与返回值定义下来，而具体的实现，即就是实现该功能的核心代码，将在 &lt;code&gt;Service&lt;/code&gt; 这个类中完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样注重抽象方法约定的设计模式对于构建大型项目来说具有非常大的优势。首先，它不要求编程人员在程序开发早期或设计系统阶段编写任何核心代码，从而编程人员可以将主要精力放在架构设计以及业务逻辑，避免浪费过多时间在思考具体实现上。其次，由于 IOP 中多了接口这一抽象层，避免将核心代码细节暴露给开发者，不熟悉该模块的开发者可以从文档、名称、参数、返回值等来快速推断程序逻辑，这大大的降低了程序复杂性以及维护成本。最后，IOP 可以让编程变得更灵活，它天生支持多态（Polymorphic），可以作为 OOP 中类继承（Class Inheritance）的有效替代。可能很多初学者会抱怨说这种设计理念让编程变得臃肿，但不得不说这种附加的约束能够让大型项目在面对复杂性和多变性时显得更加稳定和反脆弱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读者可能会问，这跟 TypeScript 有什么关系？其实，如果你用 TS 编写过大型项目，应该能够意识到 IOP 这种理念在 TS 中发挥的作用。接下来，本文将介绍 TS 的一些核心概念，这将有助于读者进一步理解 TS 的特性以及它为何适合大型项目。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;TS 核心概念&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;基本语法&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前也提到，TS 是 JS 的超集，也就是说 JS 的语法 TS 全部都包括，而且在此基础上还添加了类型系统。类型的定义主要是以 “变量或属性名称后面加冒号跟类型来制定的，即 &lt;code&gt;&amp;lt;variable/attribute&amp;gt;: &amp;lt;type&amp;gt;&lt;/code&gt;。下面分别用 JavaScript 和 TypeScript 的代码举例说明。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// JS&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; strVal = &lt;span&gt;&#x27;string-value&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; objVal = {&lt;br/&gt;  &lt;span&gt;key&lt;/span&gt;: &lt;span&gt;&#x27;string-value&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; func = &lt;span&gt;&lt;span&gt;param&lt;/span&gt; =&amp;gt;&lt;/span&gt; param * &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 TS 中类似的写法是这样。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// TS&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; strVal: &lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&#x27;string-value&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; IObject {&lt;br/&gt;  key: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  value: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; objVal: IObject = {&lt;br/&gt;  key: &lt;span&gt;&#x27;string-value&#x27;&lt;/span&gt;,&lt;br/&gt;  value: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Func = &lt;span&gt;(&lt;span&gt;param: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; func: Func = &lt;span&gt;(&lt;span&gt;param: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; param * &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到区别了么？首先你可能会注意到 JS 要比 TS 简洁得多。这很自然，因为 TS 加入了类型系统，必然会增加一些额外的约束代码。JS 是弱类型动态语言，类型之间可以自由转换，显得非常灵活。然而由这种灵活和自由度产生的编码快感只能持续短短一段时间，当项目不断发展，变量类型变多，模块间的交互关系变得复杂之后，这种自由度带来的麻烦很可能是灾难级的。坊间传言 “动态一时爽，重构火葬场” 说的就是这个道理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能也会注意到，对象变量 &lt;code&gt;objVal&lt;/code&gt; 被接口 &lt;code&gt;IObject&lt;/code&gt; 约束（它是用 &lt;code&gt;interface&lt;/code&gt; 这个关键词来定义的），其中规定了它要求的属性以及相应的类型，因此在对其赋值或取值时不能随意处理。同理，函数（Function）也可以用关键词 &lt;code&gt;type&lt;/code&gt; 来定义，这里定义了函数类型 &lt;code&gt;Func&lt;/code&gt; 的参数名、参数类型，以及返回的结果类型。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;基础类型&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟其他主流编程语言一样，TypeScript 同样有基础数据类型。其中大部分跟 JavaScript 的基础数据类型一致，另外还添加了一些 TS 特有的类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基础类型列表如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型名称&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;th&gt;例子&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;布尔值&lt;/td&gt;&lt;td&gt;&lt;code&gt;const a: boolean = true;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;数值&lt;/td&gt;&lt;td&gt;&lt;code&gt;const a: number = 1;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;字符串&lt;/td&gt;&lt;td&gt;&lt;code&gt;const a: string = &#x27;text&#x27;;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Array&lt;/td&gt;&lt;td&gt;数组，不定长度，相同类型&lt;/td&gt;&lt;td&gt;&lt;code&gt;const a: string[] = [&#x27;a&#x27;, &#x27;b&#x27;];&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Tuple&lt;/td&gt;&lt;td&gt;元组，固定长度，可以不同类型&lt;/td&gt;&lt;td&gt;&lt;code&gt;const a: [string, number] = [&#x27;a&#x27;, 1];&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Enum&lt;/td&gt;&lt;td&gt;枚举&lt;/td&gt;&lt;td&gt;官网例子&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Unknown&lt;/td&gt;&lt;td&gt;不确定&lt;/td&gt;&lt;td&gt;官网例子&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Any&lt;/td&gt;&lt;td&gt;任意类&lt;/td&gt;&lt;td&gt;官网例子&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Void&lt;/td&gt;&lt;td&gt;无类型&lt;/td&gt;&lt;td&gt;官网例子&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Null and Undefined&lt;/td&gt;&lt;td&gt;空值&lt;/td&gt;&lt;td&gt;官网例子&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Never&lt;/td&gt;&lt;td&gt;用于只抛错的函数等&lt;/td&gt;&lt;td&gt;官网例子&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Object&lt;/td&gt;&lt;td&gt;对象，表示非基础类型&lt;/td&gt;&lt;td&gt;官网例子&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;接口与字面类型&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TS 中除了基础类型以外，还可以自定义项目中需要的类型。这种自定义类型在 TS 中通常用接口（Interface）或字面类型（Literal Type）来定义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口是 TypeScript 中非常重要的核心概念。接口的定义方法非常简单，在 TS 代码里用 &lt;code&gt;interface&lt;/code&gt; 关键词加接口名，后跟花括号 &lt;code&gt;{...}&lt;/code&gt;，并在花括号中定义这个接口包含的属性以及属性对应的类型，可以是基础类型，也可以是接口（Interface）、类（Class）、类型（Type）。请注意到，函数也是类型的一种。下面用代码举例说明。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Client {&lt;br/&gt;  host: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  port?: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  username?: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  password?: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  connect: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;  disconnect: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; ResponseData {&lt;br/&gt;  code: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  error?: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  message: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  data: &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; Service {&lt;br/&gt;  name?: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  client: Client;&lt;br/&gt;  request: &lt;span&gt;(&lt;span&gt;url: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; ResponseData;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是接口定义代码，下面看一下如何使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; client: Client = {&lt;br/&gt;  host: &lt;span&gt;&#x27;localhost&#x27;&lt;/span&gt;,&lt;br/&gt;  connect: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;connecting to remote server&#x27;&lt;/span&gt;); &lt;br/&gt;  },&lt;br/&gt;  disconnect: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { &lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;disconnecting from remote server&#x27;&lt;/span&gt;); &lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; service: Service = {&lt;br/&gt;  name: &lt;span&gt;&#x27;Mock Service&#x27;&lt;/span&gt;,&lt;br/&gt;  client,&lt;br/&gt;  request: &lt;span&gt;(&lt;span&gt;url: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;      code: &lt;span&gt;200&lt;/span&gt;,&lt;br/&gt;      message: &lt;span&gt;&#x27;success&#x27;&lt;/span&gt;,&lt;br/&gt;      data: url,&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个模拟客户端服务定义的非常简单的代码。可以注意到，接口定义了后面实例（Instance）&lt;code&gt;client&lt;/code&gt;、&lt;code&gt;service&lt;/code&gt; 的属性（Attributes，有些文章会称作 “字段 Field”）和方法（Methods），该接口约束下的实例必须包含对应要求的属性和正确类型，否则在编译时（Compile Time）就会报错。接口中属性名后面带一个问号 &lt;code&gt;?&lt;/code&gt; 是代表该属性是可选的（Optional）。因此，模块或功能首先由接口来定义，将大框架考虑好之后再实现接口中的核心逻辑，这也就满足了面向接口编程中的设计模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而字面类型（Literal Type）主要是简化一些比较简单的自定义类型。其定义方式同样非常简单，限于篇幅就不展开讲解。感兴趣的读者可以到官网文档深入了解。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;鸭子类型&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了基础类型、接口、字面类型之后，我们可以开始着手用 TS 写一些可靠的代码了。不过为了加深对 TS 类型系统的理解，我们需要了解什么情况下，接口与实例的绑定是合法的？TypeScript 中的类型合法性检测方法是如何规定？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypeScript 采用了所谓的 “鸭子类型”（Duck Typing）策略。所谓鸭子类型，就是当两个类型具有相同的属性以及方法时，它们就可以看作是同一类型。例如，狗既能吃饭又能拉屎，还有两个眼睛一张嘴；人同样也是既能吃饭又能拉屎，还有两个眼睛一张嘴。单从这些属性来看，狗跟人是同一类型。但很显然这个结论是荒唐的。人类可以说话，狗却不能；狗可以摇尾巴，而人却不能。但如果一个外星人到地球来访问，TA 很可能会将人和狗分为一类，因为它们既能吃饭又能拉屎，还有两个眼睛一张嘴（误）。不过外星人通过选择性的观测两种生物，可以快速的将它们进行归类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，鸭子类型在类型约束的同时，又带有一些灵活性，代码显得灵活而精简，不会因为严格的约束条件而让代码变得臃肿。TypeScript 用这种方式来校验类型合法性，可以提升编写 TS 的体验感，绕开了传统 OOP 语言（例如 Java、C#）死板的类型约束，让写 TS 变得轻松而有趣。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;其他&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限于篇幅原因，本文不打算详解所有 TS 的特性。不过，TS 中有很多其他实用的特性，例如联合类型、枚举、泛型、命名空间 等，希望进一步了解或使用 TS 的读者可以到官方文档深入了解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用 TS 构建大型项目&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大型项目，你首先联想到的是什么？对于不同领域的开发工程师来说，可能有不同的理解。不过单就软件行业来看，一个软件开发项目被称作 “大型项目”（Large Project），通常意味着将涉及大量的功能模块，从而具有较高系统复杂性（Complexity）。一个大型项目的成功，除了满足传统项目管理中的周期、预算控制以外，还需要注重质量，从软件工程角度看来就是可靠性（Robustness）、稳定性（Stability）、可维护性（Maintainability）、可扩展性（Scalability）等等。就像建筑工程一样，你一定不希望自己设计的建筑是摇摇欲坠的，你需要它尽可能的稳固，在狂风暴雨下屹立不倒，同时可以灵活修缮维护。而为了保障这些非功能性需求或者质量要求，必须要有一些明确的规范和标准，在建筑工程里也许是工程图纸、精密测量等，而在软件工程里则是代码规范（Coding Standard）、设计模式（Design Patterns）、流程规范（Process Standard）、系统架构（System Architecture）、单元测试（Unit Testing）等等。其中的代码规范和设计模式尤为重要，因为这是整个软件系统的基础。没有代码，将没有软件程序；而没有好的代码规范和设计模式，将没有好的代码，也就没有可靠的软件程序，有的只是源源不断的程序 Bug 和系统崩溃。TypeScript 可以在代码规范和设计模式上极大的提高代码质量，进而增强系统的可靠性、稳定性和可维护性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;代码规范&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码风格经常是前端项目的痛点，这个可以用 JavaScript 风格检测工具 ESLint 来规范。但是，ESLint 无法解决类型方面带来的问题。只有 TypeScript 可以静态检测在类型层面上可能出现的问题。如果用 TS 来编写前端项目，我会建议对所有可能的变量和方法都用类型约束。而且尽可能不要用 &lt;code&gt;any&lt;/code&gt; 类型，因为 &lt;code&gt;any&lt;/code&gt; 类型可以涵盖所有其他类型，相当于没有类型，这也失去了类型系统的意义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟纯 JS 相比，TS 虽然多了一些额外的类型声明代码，但它却因此而获得了更好的可读性、可理解性和可预测性，因此也会更加稳定和可靠。如果你是从 JS 转到 TS 的初学者，请尽可能克制住不要用 &lt;code&gt;any&lt;/code&gt;，这会毁了你的规范和标准。如果你是前后端分离的架构而且在用纯 JS 写前端，在没有明确且可靠的后端接口数据结构约定时，你可能会被迫使写很多类型判断的代码，这跟在静态语言中用反射（Reflect）一样会污染整个代码风格。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TS 其实就是在 JS 上多了一个静态类型系统，没有什么其他的魔法。但就是这个 “小小的” 的附加功能让代码变得规范和可维护，从而成为大型前端项目的首选。很多高级前端工程师都喜欢用 React 或 Angular 来构建大型项目，就是因为它们能支持 TS。不过近期发布的 Vue 3 也及时的加入了 TS 的支持，让它能够胜任大型项目的开发。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;目录结构&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在你编写大型前端项目时，推荐使用声明文件（Declaration Files）来管理接口或其他自定义类型。声明文件一般是 &lt;code&gt;&amp;lt;module_name&amp;gt;.d.ts&lt;/code&gt; 的形式，在这类文件中只定义模块中的类型，没有任何实际的实现逻辑。声明文件可以单独放在一个目录里，我喜欢命名为 &lt;code&gt;interfaces&lt;/code&gt;，意思就是接口。这样，就可以充分将抽象类型、方法、属性等与实际内容分开。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下例子是一个集成了 TS 的 Vue 项目目录。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;.&lt;br/&gt;├── babel.config.js   // Babel 编译配置文件&lt;br/&gt;├── jest.config.ts   // 单元测试配置文件&lt;br/&gt;├── package.json    // 项目配置文件&lt;br/&gt;├── public       // 公共资源&lt;br/&gt;├── src         // 源代码目录&lt;br/&gt;│   ├── App.vue     // 主应用&lt;br/&gt;│   ├── assets     // 静态资源&lt;br/&gt;│   ├── components   // 组件&lt;br/&gt;│   ├── constants    // 常量&lt;br/&gt;│   ├── i18n      // 国际化&lt;br/&gt;│   ├── interfaces   // 声明文件目录&lt;br/&gt;│   │   ├── components  // 组件声明&lt;br/&gt;│   │   ├── index.d.ts  // 主声明&lt;br/&gt;│   │   ├── layout   // 布局声明&lt;br/&gt;│   │   ├── store    // 状态管理声明&lt;br/&gt;│   │   └── views    // 页面声明&lt;br/&gt;│   ├── layouts     // 布局&lt;br/&gt;│   ├── main.ts     // 主入口&lt;br/&gt;│   ├── router     // 路由&lt;br/&gt;│   ├── shims-vue.d.ts // 兼容 Vue 声明文件&lt;br/&gt;│   ├── store      // 状态管理&lt;br/&gt;│   ├── styles     // CSS/SCSS 样式&lt;br/&gt;│   ├── &lt;span&gt;test&lt;/span&gt;      // 测试&lt;br/&gt;│   ├── utils      // 公共方法&lt;br/&gt;│   └── views      // 页面&lt;br/&gt;└── tsconfig.json    // TS 配置文件&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中可以看到，&lt;code&gt;interfaces&lt;/code&gt; 这个目录跟其他模块在同一级，而其子目录则是其他模块所对应的类型声明。编写代码前，尽量先创建并设计声明文件内容，设计好之后再到实际的模块下完成实现。当然，这个 “定义 -&amp;gt; 实现“ 是一个不断迭代的过程，可能实现过程中发现有类型设计问题，可以回到声明文件中完善定义，再到实现代码里进行优化。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;设计模式&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ES6 出来之前，JavaScript 的类型系统是比较难以理解的，主要原因之一就是它难以掌握的原型继承模式。在 ES6 之前，要实现一个传统 OOP 中的工厂方法，都显得举步维艰。不过，ES6 的出现缓解了前端工程师的痛点。ES6 引入了 &lt;code&gt;class&lt;/code&gt; 语法糖来实现传统的 OOP 的类创建与继承。不过这在 TypeScript 看来，只是 “小打小闹”。虽然 ES6 中的 &lt;code&gt;class&lt;/code&gt; 让 JS 拥有了一部分封装的能力，但在构建大型项目或系统模块时还显得力不从心。缺少类型系统，尤其是泛型，是 JS 的一个致命弱点。而 TS 不仅有 ES6 种 &lt;code&gt;class&lt;/code&gt; 的所有功能，还有接口、泛型、装饰器等功能来实现各种灵活而强大的框架级系统。泛型（Generics）通常是框架类库的必备特性，它可以让一个类或方法变得更通用。我建议在大型项目中广泛的使用接口、泛型等特性来抽象你的代码和逻辑，从而提取出重复代码，并在整体上对项目进行优化。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何学习 TS&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文的主要目的是鼓励开发者用 TypeScript 构建大型前端项目，而并不是一个参考指南。因此，本篇文章不会详细介绍如何从头开始创建 TS 项目，或如何运用各种 TS 特性来编写代码。在阅读过本文之后的读者如果对 TS 有深入研究的兴趣，需要阅读更多 TS 参考文章来深入理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于初学者来说，本文将给出一些途径来帮助你快速掌握 TS。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;官方文档&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方文档是最权威的参考指南，直接从官方文档上手是最系统也是最有效的学习途径。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;仔细阅读 TypeScript 官方文档，包括 Get Started、Hand Book、Tutorials 等等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果不习惯阅读英文文档，可以去 TypeScript 中文网 查看文档。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;技术文章&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TS 已经发展了很多年，在网上介绍 TS 的技术文章已经汗牛充栋，这里只介绍一些比较有帮助的博客文章。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Typescript 最佳实践&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一份不可多得的 TS 学习指南&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结合实例学习 Typescript&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可能是你需要的 React + TypeScript 50 条规范和经验&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;实践项目&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“实践出真理”，在学习过程中，理论和实践始终是分不开的。如果能将所学知识运用在实际项目中，不仅会加深印象，还可以亲自体会新技术带来的好处以及它还存在的缺点。你可以尝试以下实践项目的途径。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从头开始创建一个 TypeScript 项目，用脚手架工具 Vue CLI、create-react-app 等搭建 TS 项目；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;学习成熟的 TS 项目，例如 Ant Design、Nest、Angular 等，了解声明文件的组织方式；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;学习开源项目 DefinitelyTyped，理解并实践如何让老 JS 项目支持 TS。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拥抱 TypeScript 是现代前端工程的主流。任何一个前端工程师都需要学习 TS，这有助于拓宽你的知识技能，以及加强自己的专业度和职业背景。不过，我们必须意识到，拥抱 TS 并不是终点。如果你研究过前端发展的历史，你会发现 TypeScript 的盛行是前端工程化、模块化和规模化的结果，是前端需求变得越来越复杂的必然产物。TS 只是用后端工程知识解决前端工程问题的一个有效解决方案。TypeScript  之父巧妙的将 C# 的经验移植到了 JavaScript，由此诞生了 TypeScript，革命性的解放了前端工程师的生产力。而这个解决方案会持续多久，我们无法预测。但可以确定，前端工程将继续发展，各种新技术也将层出不穷。作为一个软件工程师，你需要不断学习，这样才能不被后浪拍死在沙滩上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vh4PtSfBxFMiagajmVjiaNAjY1doibjKtKgdekL1CkulljibBibufDUwN3TLK9mwb2iaww8M2NqhCNftLWcGVcmW7Q0A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.9828125&quot; data-w=&quot;640&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;typescript-abandon&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>