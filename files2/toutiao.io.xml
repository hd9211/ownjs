<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>fb2df63f5523c5e3b48401b0b93f2078</guid>
<title>IndexedDB 快速入门</title>
<link>https://toutiao.io/k/7hbxp47</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-header&quot;&gt;&lt;h1 class=&quot;title&quot;&gt;IndexedDB 快速入门&lt;/h1&gt;&lt;p class=&quot;meta&quot;&gt;冯宇 Posted at — Aug 7, 2021
&lt;span class=&quot;meta&quot; id=&quot;busuanzi_container_page_pv&quot;&gt;阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;markdown&quot;&gt;&lt;p&gt;&lt;strong&gt;注：如果你只是想快速体验一下 IndexedDB，建议直接去使用 &lt;a href=&quot;https://jsstore.net/&quot;&gt;JsStore&lt;/a&gt; 。它基本上完全隐藏了 IndexedDB 繁琐的技术细节，提供的接口也更加人性化，同时还有更高级的特性（如 sql join、upsert、webworker 等）。&lt;/strong&gt;&lt;/p&gt;&lt;h2 id=&quot;indexeddb-简介&quot;&gt;IndexedDB 简介&lt;/h2&gt;&lt;p&gt;作为前端开发工程师，你可能已经习惯了使用一些前端的存储方案，如 LocalStorage, Session Storage, Cookie 之类等等。而这些存储在存储结构简单、数据量小的场景中非常好用，但是遇到大规模结构化存储的场景中就不那么好用了。为此，诞生了一种新的存储标准 IndexedDB，用于在前端解决大规模量结构化数据存储的场景。如服务端数据缓存至前端加速，前端日志缓存记录等。&lt;/p&gt;&lt;p&gt;本文将介绍 IndexedDB 快速入门的相关内容，至于高级使用，仍建议详细阅读 IndexedDB 的&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;性能评测可参考： &lt;a href=&quot;https://zhuanlan.zhihu.com/p/104536473&quot;&gt;https://zhuanlan.zhihu.com/p/104536473&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;indexeddb-的兼容性&quot;&gt;IndexedDB 的兼容性&lt;/h2&gt;&lt;p&gt;如今 IndexedDB 几乎在现代化的浏览器都已经实现，因此可以放心大胆的在产品环境使用。截至本文撰写时间，当前 IndexedDB 的浏览器兼容性参考如下:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;imgs/indexeddb1.png&quot; alt=&quot;IndexedDB 兼容性概览&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;数据来源: &lt;a href=&quot;https://caniuse.com/indexeddb&quot;&gt;https://caniuse.com/indexeddb&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;indexeddb-的存储容量限制&quot;&gt;IndexedDB 的存储容量限制&lt;/h2&gt;&lt;p&gt;IndexedDB 的最大存储容量通常是动态的，通常&lt;strong&gt;全局限制&lt;/strong&gt;为当前磁盘空间的 50%，如浏览器安装分区容量为 500GB，则 IndexedDB 最大可能占用空间为 250GB —— 这对于前端存储来几乎是足够的&lt;/p&gt;&lt;p&gt;还有另一个限制称为&lt;strong&gt;组限制&lt;/strong&gt;——这被定义为全局限制的 20％，但它至少有 10 MB，最大为 2GB。 每个源都是一组（源组）的一部分。 每个 eTLD+1 域都有一个组。 例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;mozilla.org&lt;/code&gt;——组 1，源 1&lt;/li&gt;&lt;li&gt;&lt;code&gt;www.mozilla.org&lt;/code&gt;——组 1，源 2&lt;/li&gt;&lt;li&gt;&lt;code&gt;joe.blogs.mozilla.org&lt;/code&gt;——组 1，源 3&lt;/li&gt;&lt;li&gt;&lt;code&gt;firefox.com&lt;/code&gt; ——组 2，源 4&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在这个组中，mozilla.org、www.mozilla.org和joe.blogs.mozilla.org可以聚合使用最多20％的全局限制。 firefox.com 单独最多使用 20％。&lt;/p&gt;&lt;p&gt;达到限制后有两种不同的反应：&lt;/p&gt;&lt;p&gt;组限制也称为“硬限制”：它不会触发源回收。
全局限制是一个“软限制”，因为其有可能释放一些空间并且这个操作可能持续。&lt;/p&gt;&lt;h2 id=&quot;indexeddb-安全性&quot;&gt;IndexedDB 安全性&lt;/h2&gt;&lt;p&gt;IndexedDB 使用同源原则，这意味着它把存储空间绑定到了创建它的站点的源（典型情况下，就是站点的域或是子域），所以它不能被任何其他源访问。&lt;/p&gt;&lt;h2 id=&quot;indexeddb-简易示例&quot;&gt;IndexedDB 简易示例&lt;/h2&gt;&lt;p&gt;IndexedDB 的 API 是基于事件响应全异步性的，使用的时候需要监听对应的事件完成操作。一个基本的创建数据库的操作实例如下:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;// 如果被打开的数据库不存在，则会自动创建
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;window&lt;/span&gt;.&lt;span&gt;indexedDB&lt;/span&gt;.&lt;span&gt;open&lt;/span&gt;(&lt;span&gt;&quot;MyTestDatabase&quot;&lt;/span&gt;);

&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Why didn&#x27;t you allow my web app to use IndexedDB?!&quot;&lt;/span&gt;);
};

&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;db&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;

  &lt;span&gt;// 在不使用 db 的时候尽可能 close掉，否则无法打开一个更高版本的 db，表现形式为 hang 死，无法接收到 onsuccess 事件
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// 注意 close() 函数不会立即中断已经在运行中的 transaction
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// 但是不能再用这个实例创建新的transaction，否则会抛异常
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;close&lt;/span&gt;();
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;数据库的版本号&quot;&gt;数据库的版本号&lt;/h3&gt;&lt;p&gt;&lt;code&gt;open()&lt;/code&gt; 函数可以传一个可选的 &lt;code&gt;version&lt;/code&gt; 参数指定版本号，当 version 比当前 &lt;code&gt;db.version&lt;/code&gt; 高时，会触发 &lt;code&gt;onupgradeneeded&lt;/code&gt; 事件，同时，会更新 &lt;code&gt;db.version&lt;/code&gt; 属性：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;window&lt;/span&gt;.&lt;span&gt;indexedDB&lt;/span&gt;.&lt;span&gt;open&lt;/span&gt;(&lt;span&gt;&quot;MyTestDatabase&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;);

&lt;span&gt;// 该事件仅在较新的浏览器中实现了
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onupgradeneeded&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 保存 IDBDataBase 接口
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;db&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;

  &lt;span&gt;// 为该数据库创建一个对象仓库
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// 注意 createObjectStore() 只能在 onupgradeneeded 事务中运行
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;createObjectStore&lt;/span&gt;(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, { &lt;span&gt;keyPath&lt;/span&gt;: &lt;span&gt;&quot;myKey&quot;&lt;/span&gt; });
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了防止在其他标签页中打开高版本的数据库 hang 住的情况，一种做法可以参考如下:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;openReq&lt;/span&gt; = &lt;span&gt;mozIndexedDB&lt;/span&gt;.&lt;span&gt;open&lt;/span&gt;(&lt;span&gt;&quot;MyTestDatabase&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;);

&lt;span&gt;openReq&lt;/span&gt;.&lt;span&gt;onblocked&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 如果其他的一些页签加载了该数据库，在我们继续之前需要关闭它们
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;请关闭其他由该站点打开的页签！&quot;&lt;/span&gt;);
};

&lt;span&gt;openReq&lt;/span&gt;.&lt;span&gt;onupgradeneeded&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 其他的数据已经被关闭，一切就绪
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;createObjectStore&lt;/span&gt;(&lt;span&gt;/* ... */&lt;/span&gt;);
  &lt;span&gt;useDatabase&lt;/span&gt;(&lt;span&gt;db&lt;/span&gt;);
};

&lt;span&gt;openReq&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;db&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;
  &lt;span&gt;useDatabase&lt;/span&gt;(&lt;span&gt;db&lt;/span&gt;);
  &lt;span&gt;return&lt;/span&gt;;
};

&lt;span&gt;function&lt;/span&gt; &lt;span&gt;useDatabase&lt;/span&gt;(&lt;span&gt;db&lt;/span&gt;) {
  &lt;span&gt;// 当由其他页签请求了版本变更时，确认添加了一个会被通知的事件处理程序。
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// 这里允许其他页签来更新数据库，如果不这样做，版本升级将不会发生知道用户关闭了这些页签。
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;onversionchange&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;close&lt;/span&gt;();
    &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;A new version of this page is ready. Please reload or close this tab!&quot;&lt;/span&gt;);
  };

  &lt;span&gt;// 处理数据库
&lt;/span&gt;&lt;span/&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;一个基本的存储示例&quot;&gt;一个基本的存储示例&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;dbName&lt;/span&gt; = &lt;span&gt;&quot;the_name&quot;&lt;/span&gt;;

&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;indexedDB&lt;/span&gt;.&lt;span&gt;open&lt;/span&gt;(&lt;span&gt;dbName&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;);

&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 错误处理
&lt;/span&gt;&lt;span/&gt;};
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onupgradeneeded&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;db&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;

  &lt;span&gt;// 建立一个对象仓库来存储我们客户的相关信息，我们选择 ssn 作为键路径（key path）
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// 因为 ssn 可以保证是不重复的
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;createObjectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;, { &lt;span&gt;keyPath&lt;/span&gt;: &lt;span&gt;&quot;ssn&quot;&lt;/span&gt; });

  &lt;span&gt;// 建立一个索引来通过姓名来搜索客户。名字可能会重复，所以我们不能使用 unique 索引
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;createIndex&lt;/span&gt;(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, &lt;span&gt;&quot;name&quot;&lt;/span&gt;, { &lt;span&gt;unique&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt; });

  &lt;span&gt;// 使用邮箱建立索引，我们向确保客户的邮箱不会重复，所以我们使用 unique 索引
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;createIndex&lt;/span&gt;(&lt;span&gt;&quot;email&quot;&lt;/span&gt;, &lt;span&gt;&quot;email&quot;&lt;/span&gt;, { &lt;span&gt;unique&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; });

  &lt;span&gt;// 使用事务的 oncomplete 事件确保在插入数据前对象仓库已经创建完毕
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;.&lt;span&gt;oncomplete&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;// 将数据保存到新创建的对象仓库
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;var&lt;/span&gt; &lt;span&gt;customerObjectStore&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;, &lt;span&gt;&quot;readwrite&quot;&lt;/span&gt;).&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;);
    &lt;span&gt;customerData&lt;/span&gt;.&lt;span&gt;forEach&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;customer&lt;/span&gt;) {
      &lt;span&gt;// add 函数在 keyPath 冲突时会抛异常，如果期望直接覆盖，请使用 put 函数
&lt;/span&gt;&lt;span/&gt;      &lt;span&gt;customerObjectStore&lt;/span&gt;.&lt;span&gt;add&lt;/span&gt;(&lt;span&gt;customer&lt;/span&gt;);
    });
  };
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;关于索引&lt;/strong&gt;: IndexedDB 的索引会自动按照由小到大的顺序自动进行排列(有点像 HBase 的 RowKey 设计)，同时可以支持多个字段联合索引，如: objectStore.createIndex(“f1-f2”, [“f1”, “f2”]); 对于要想使用类似于 SQL 中的 where 条件查询，则必须预先在对应的字段创建索引才能实现。另外由于 IndexedDB API 并不提供类似于 Order By 的功能，因此只能使用 cursor 的遍历方向来替代。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;基本-curd-示例&quot;&gt;基本 CURD 示例&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;// ========= 增加数据 ============
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// 在所有数据添加完毕后的处理
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;transaction&lt;/span&gt;.&lt;span&gt;oncomplete&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;All done!&quot;&lt;/span&gt;);
};

&lt;span&gt;transaction&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 不要忘记错误处理！
&lt;/span&gt;&lt;span/&gt;};

&lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;transaction&lt;/span&gt;.&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;);
&lt;span&gt;customerData&lt;/span&gt;.&lt;span&gt;forEach&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;customer&lt;/span&gt;) {
  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;add&lt;/span&gt;(&lt;span&gt;customer&lt;/span&gt;);
  &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;// event.target.result === customer.ssn;
&lt;/span&gt;&lt;span/&gt;  };
});

&lt;span&gt;// =========== 删除数据 ==================
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;
  .&lt;span&gt;transaction&lt;/span&gt;([&lt;span&gt;&quot;customers&quot;&lt;/span&gt;], &lt;span&gt;&quot;readwrite&quot;&lt;/span&gt;)
  .&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;)
  .&lt;span&gt;delete&lt;/span&gt;(&lt;span&gt;&quot;444-44-4444&quot;&lt;/span&gt;);
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 删除成功！
&lt;/span&gt;&lt;span/&gt;};

&lt;span&gt;// =========== 读取数据 ==================
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;transaction&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;([&lt;span&gt;&quot;customers&quot;&lt;/span&gt;]);
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;transaction&lt;/span&gt;.&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;);
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;444-44-4444&quot;&lt;/span&gt;);
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 错误处理!
&lt;/span&gt;&lt;span/&gt;};
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 对 request.result 做些操作！
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Name for SSN 444-44-4444 is &quot;&lt;/span&gt; + &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;.&lt;span&gt;name&lt;/span&gt;);
};

&lt;span&gt;// 简化示例，和上面等效
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;db&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;).&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;).&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;444-44-4444&quot;&lt;/span&gt;).&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (
  &lt;span&gt;event&lt;/span&gt;
) {
  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Name for SSN 444-44-4444 is &quot;&lt;/span&gt; + &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;.&lt;span&gt;name&lt;/span&gt;);
};

&lt;span&gt;// 使用游标
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;).&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;);

&lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;openCursor&lt;/span&gt;().&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;
  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;cursor&lt;/span&gt;) {
    &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Name for SSN &quot;&lt;/span&gt; + &lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;key&lt;/span&gt; + &lt;span&gt;&quot; is &quot;&lt;/span&gt; + &lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;value&lt;/span&gt;.&lt;span&gt;name&lt;/span&gt;);
    &lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;continue&lt;/span&gt;();
  } &lt;span&gt;else&lt;/span&gt; {
    &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;No more entries!&quot;&lt;/span&gt;);
  }
};

&lt;span&gt;// 使用 index 索引数据
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// 首先，确定你已经在 request.onupgradeneeded 中创建了索引:
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// objectStore.createIndex(&quot;name&quot;, &quot;name&quot;);
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// 否则你将得到 DOMException。
&lt;/span&gt;&lt;span/&gt;
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; = &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;index&lt;/span&gt;(&lt;span&gt;&quot;name&quot;&lt;/span&gt;);

&lt;span&gt;index&lt;/span&gt;.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;Donna&quot;&lt;/span&gt;).&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Donna&#x27;s SSN is &quot;&lt;/span&gt; + &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;.&lt;span&gt;ssn&lt;/span&gt;);
};

&lt;span&gt;// =========== 更新数据 ==================
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;([&lt;span&gt;&quot;customers&quot;&lt;/span&gt;], &lt;span&gt;&quot;readwrite&quot;&lt;/span&gt;).&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;);
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;444-44-4444&quot;&lt;/span&gt;);
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 错误处理
&lt;/span&gt;&lt;span/&gt;};
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 获取我们想要更新的数据
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;data&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;

  &lt;span&gt;// 更新你想修改的数据
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;data&lt;/span&gt;.&lt;span&gt;age&lt;/span&gt; = &lt;span&gt;42&lt;/span&gt;;

  &lt;span&gt;// 把更新过的对象放回数据库
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;requestUpdate&lt;/span&gt; = &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;put&lt;/span&gt;(&lt;span&gt;data&lt;/span&gt;);
  &lt;span&gt;requestUpdate&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;// 错误处理
&lt;/span&gt;&lt;span/&gt;  };
  &lt;span&gt;requestUpdate&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;// 完成，数据已更新！
&lt;/span&gt;&lt;span/&gt;  };
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;关于搜索查询&quot;&gt;关于搜索查询&lt;/h2&gt;&lt;p&gt;通过上述的示例，可以看到其实 IndexedDB 存储其实是文档型数据库的套路，并且自身的 API 并不支持像 SQL 那样复杂功能多样的查询功能，因此在使用前必须好好设计存储结构，务必确保自己的查询条件不至于太复杂难以实现，这里列出一些常见的查询示例与 SQL 的对照(所有需要用到的 index 需要事先创建好，这里不再赘述):&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;// select * from table order by field desc
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;index&lt;/span&gt;(&lt;span&gt;&quot;field&quot;&lt;/span&gt;).&lt;span&gt;openCursor&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;&quot;prev&quot;&lt;/span&gt;);

&lt;span&gt;// select * from table where field between 1 and 10
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;index&lt;/span&gt;(&lt;span&gt;&quot;field&quot;&lt;/span&gt;).&lt;span&gt;openCursor&lt;/span&gt;(&lt;span&gt;IDBKeyRange&lt;/span&gt;.&lt;span&gt;bound&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;));

&lt;span&gt;// select distinct on (f1, f2) * from table
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// 需要预先创建f1, f2的联合索引: objectStore.createIndex(&quot;f1-f2&quot;, [&quot;f1&quot;, &quot;f2&quot;], { unique: false });
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;index&lt;/span&gt;(&lt;span&gt;&quot;f1-f2&quot;&lt;/span&gt;).&lt;span&gt;openCursor&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;&quot;nextunique&quot;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;条件搜索主要使用&lt;code&gt;openCursor(keyRange, direction)&lt;/code&gt;函数，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IDBKeyRange&quot;&gt;IDBKeyRange&lt;/a&gt; 参数表示查询的范围，类似于&lt;code&gt;where&lt;/code&gt;的功能，而&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/direction&quot;&gt;direction&lt;/a&gt; 决定游标遍历的方向，因此可以实现简单的&lt;code&gt;order by&lt;/code&gt;的功能。但是特别注意对于联合索引，每个字段也都是按照&lt;code&gt;asc&lt;/code&gt;顺序排序的，因此没办法通过 direction 实现类似于&lt;code&gt;order by f1 asc, f2 desc, f3 desc&lt;/code&gt;这样的排序，使用前务必设计好存储结构。&lt;/p&gt;&lt;p&gt;还需要注意无论&lt;code&gt;nextunique&lt;/code&gt;还是&lt;code&gt;prevunique&lt;/code&gt;，由于它们内部对于相同 value 的排序都是从小到大的，因此它们返回的内容都是一样的，例如:&lt;/p&gt;&lt;p&gt;假设创建&lt;code&gt;objectStore.createIndex(&quot;f1-f2&quot;, [&quot;f1&quot;, &quot;f2&quot;], { unique: false })&lt;/code&gt;索引，无论&lt;code&gt;openCursor&lt;/code&gt;的 direction 参数是&lt;code&gt;nextunique&lt;/code&gt;还是&lt;code&gt;prevunique&lt;/code&gt;，都只会筛选出&lt;code&gt;{&quot;f1&quot;:&quot;a&quot;,&quot;f2&quot;:&quot;b&quot;,&quot;f3&quot;:&quot;c&quot;}&lt;/code&gt;这条结果，cursor 的遍历顺序只会影响这条记录出现的次序而已。&lt;/p&gt;&lt;h2 id=&quot;promise&quot;&gt;Promise&lt;/h2&gt;&lt;p&gt;IndexedDB API 本身并不提供 Promise 接口，如果你的场景确实需要用到 Promise，可以考虑自己简单封装下:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;resolve&lt;/span&gt;, &lt;span&gt;reject&lt;/span&gt;) {
  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;window&lt;/span&gt;.&lt;span&gt;indexedDB&lt;/span&gt;.&lt;span&gt;open&lt;/span&gt;(&lt;span&gt;&quot;MyTestDatabase&quot;&lt;/span&gt;);

  &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;reject&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;);
  }

  &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;db&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;getReq&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;
      .&lt;span&gt;transaction&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;)
      .&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;)
      .&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;444-44-4444&quot;&lt;/span&gt;)

    &lt;span&gt;getReq&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;resolve&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;.&lt;span&gt;name&lt;/span&gt;);
    };

    &lt;span&gt;getReq&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;reject&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果需要大量使用 Promise，可以考虑使用第三方类库&lt;a href=&quot;https://www.npmjs.com/package/idb&quot;&gt;idb&lt;/a&gt;或更精简的版本&lt;a href=&quot;https://www.npmjs.com/package/idb-keyval&quot;&gt;idb-keyval&lt;/a&gt;，它们将 IndexedDB 的 API 进行了 Promise 的封装，其中&lt;a href=&quot;https://www.npmjs.com/package/idb-keyval&quot;&gt;idb-keyval&lt;/a&gt;对 KV 对这种存储结构进行了更简化的封装调用，对于自己的场景只有简单的 KV 存储这种场景可以考虑使用&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4d5636bfda27716b709e5f03be48c443</guid>
<title>Java 进阶：从整体上观察面向对象</title>
<link>https://toutiao.io/k/d5zzykx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、面向对象&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;面向对象是Java编程中最核心的思想，基本特征：继承、封装、多态。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、特征之封装&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;将结构、数据、操作封装在对象实体中，使用时可以不关注对象内部结构，只能访问开放权限的功能入口，从而降低程序耦合程度，提供安全性和可持续维护性。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Concept01&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Student student = &lt;span&gt;new&lt;/span&gt; Student(&lt;span&gt;&quot;张三&quot;&lt;/span&gt;,&lt;span&gt;&quot;高三&quot;&lt;/span&gt;,&lt;span&gt;29f&lt;/span&gt;);&lt;br/&gt;        student.conclusion();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String grade ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Float score ;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt;&lt;span&gt;(String name, String grade, Float score)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.grade = grade;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.score = score;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;conclusion&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;姓名：&quot;&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;.getName());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;年级：&quot;&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;.getGrade());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;分数：&quot;&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;.getGrade());&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.getScore() &amp;gt;= &lt;span&gt;100.0f&lt;/span&gt;){&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;评语：本学期优等生&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;评语：本学期潜力股&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;案例描述Student的学期总结，通过构造方法构建具体的学生对象，并且只通过conclusion方法获取学生学期评价。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、特征之继承&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;子类除了提供自身的能力之外，还可以通过继承的方式获取父类开放的属性和方法，以增强自身的功能。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Concept02&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 判断 Digital 是 Phone 父类&lt;/span&gt;&lt;br/&gt;        System.out.println(Digital&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;isAssignableFrom&lt;/span&gt;(&lt;span&gt;Phone&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Digital&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Phone&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Digital&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里通过isAssignableFrom方法判断Digital是Phone父类。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、特征之多态&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;不同主体类对同一个动作给出不同的实现方式，多态也是Java描述设计模式的常用手段，最直接的作用就是程序解耦。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Concept03&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Animal animalDog = &lt;span&gt;new&lt;/span&gt; Dog();&lt;br/&gt;        Animal animalCat = &lt;span&gt;new&lt;/span&gt; Cat();&lt;br/&gt;        animalDog.voice();&lt;br/&gt;        animalCat.voice();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;voice&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Animal ... voice&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;voice&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Dog ... Wang wang&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;voice&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Cat ... Meow meow&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通常动物都有发出声音的能力，但是不同动物声音不同，这里基于多态实现，不同动物的声音特征。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、关系图谱&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在了解面向对象之后，还需要理解一下基础的关系模型，在实际的业务中都是基于这些基础的关系解决场景问题。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、继承与实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;继承关系：强调属性和方法从父类向子类的传承。实现关系：强调描述抽象和具体实现的逻辑。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 继承&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;classA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;classB&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;classA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;interfaceA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;interfaceB&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;interfaceA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 实现&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;classC&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;interfaceA&lt;/span&gt;,&lt;span&gt;interfaceB&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.37073170731707317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCp2RA5msCibTSo4dpYP8blibdg8u4iaTKknBD8PdpHIFeQjC0Wx7icgjqDmibVASTEkoSwS8apFdXdM8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;820&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、依赖与关联&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;依赖关系：常用来描述方法局部变量或者入参，即类的方法中调用了另一个类。关联关系：类的成员变量是另一个类，比如常见的一对一，一对多关系。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 依赖&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RelyA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RelyB&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;depend&lt;/span&gt; &lt;span&gt;(RelyA rely)&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 关联&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AssociateA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AssociateB&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; AssociateA associateA ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35960591133004927&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCp2RA5msCibTSo4dpYP8blibScn5TqWrXZL8tD5gRQBUIiaDsibWia4wib00Cw70gicBdatAiabUJsDZcpZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、组合与聚合&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;聚合关系：描述整体与部分的关系，但是部分不需要依赖整体存在。组合关系：描述整体与部分的关系，但是部分需要依赖整体存在。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 聚合&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ElementA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ElementB&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Aggregation&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ElementA elementA ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ElementB elementB ;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 组合&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PortionA&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PortionB&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Composition&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PortionA portionA ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PortionB portionB ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3117408906882591&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCp2RA5msCibTSo4dpYP8blib0OdSWJPrr8jrOYjBq3UM6QTc4w2BBLic3kgS1YwHt2BfISTXSJjXG1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;988&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、模式与原则&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在面对复杂业务时，可以时常参考设计模式和基本原则，以此设计合理的业务结构，实现代码的高内聚低耦合，但是在一些特定场景下，也要果断的突破这些模板或原则，可以更好的支撑业务。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、设计模式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;创建模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;抽象对象实例化的创建过程，对不同类型的对象提供高效的管理方式与合理的创建手段。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;结构模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;设计类的组装模式，合理的对象结构，有利于支持业务的持续迭代，结构会直接影响代码的可持续维护性。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;代理模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;外观模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;适配器模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;装饰者模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组合模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;享元模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;桥梁模式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;行为模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;行为模式涉及对象职责定义，通信协作，和最具体的业务逻辑实现，明确程序运行时的流程轨迹。&lt;/p&gt;&lt;p&gt;可以基于继承或实现的方式控制不同类的行为职责，即顶层抽象控制行为，下层逐级做具体逻辑实现；或者直接聚合管理责任对象，做统一分配。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;观察者模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模版方法模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;策略模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命令模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调停者模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;备忘录模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解释器模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;迭代器模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;状态模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;责任链模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;访问者模式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;2、基本原则&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;开闭原则：在做代码结构设计时，应该考虑对扩展开放，对修改关闭，抽象思维搭建结构，具体实现扩展细节。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;单一职责：一个类应该只负责一项职责；减少代码一处变更引起的程序大规模改动情况，降低类的复杂度；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接口隔离：每一个接口应该是一种角色；尽量避免具体实现类中用不到但是又必须实现的方法；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;依赖倒转：上层模块不应该依赖下层模块，抽象逻辑不应该依赖具体细节，即中心思想是面向接口编程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;里氏替换：继承时遵循里氏替换原则，子类中尽量不要重写父类的方法，可以扩展父类的功能；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;迪米特原则：最少知道原则即类对象对其依赖的类知道的越少越好，以此降低耦合程度；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;组合/聚合复用：新对象应使用部分已有的对象，使其成为新对象组成部分，实现已有功能的复用，以此降低单个类的复杂程度。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;span&gt;四、业务应用&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在业务开发中，很多复杂的逻辑都是基于面向对象的思想做的设计和具体实现，但是在实际上业务是不断变化的，所以不管是常用的Mvc模式，或者领域设计，只要经过多个版本迭代，多人参与的开发，到最后代码在逻辑层面都会让人着迷。&lt;/p&gt;&lt;p&gt;也就是常说的一种现象：新人重构，老人不断修复问题，然而铁打的问题，流水的开发，但凡经历过重构的同学都知道，所谓的大规模重构很难彻底解决问题，甚至这是个循环动作。所以业务代码更多是在那个版本周期内是合理的，站在一个开发的角度，这里也可以理解为笔者个人角度，通常从下面几个角度去思考具体的业务开发：&lt;/p&gt;&lt;p&gt;这是个人认为业务工程中最重要的基础，不管业务如何复杂，都离不开与之相应的数据增删改查，所以对常规基础操作做好统一代码风格管理，这样有助于别人快速理解整体结构和逻辑。&lt;/p&gt;&lt;p&gt;这里风格指：接口命名，参数，组件，中间件等统一，以持久层为例，避免多个组件混用的情况，如果是周期相对较长的项目，经常看到单是分页查询的实现逻辑都有多种情况。&lt;/p&gt;&lt;p&gt;易变是业务本身的特点，所以高度复用的业务代码本身就存在很大的限制，例如常见的很多方法，为了适配各种场景，不断扩展入参，然后有些特殊业务也会进行特殊传参。&lt;/p&gt;&lt;p&gt;还有一些开发常说的，能用一个接口实现，绝对不使用两个接口，看似很有个性，实际已经走在挖坑的路上，多个功能请求同一个接口，即意味着任何接口的改动都要考虑很多逻辑的适配。&lt;/p&gt;&lt;p&gt;所以从上层向下看，不必过度考虑复用，从下向上看，底层的改动相对较少，应该考虑复用。&lt;/p&gt;&lt;p&gt;从项目生命周期的角度思考，业务是一个迭代的过程，不需要过度前卫的设计，项目的生命周期是多久没人知道，最稳妥的做法是快速迭代，产品和技术工程能快速稳定的支撑业务发展即可。&lt;/p&gt;&lt;p&gt;经典的业务分层管理是快速迭代的基本支撑，例如常用的Mvc模式，在复杂的业务场景下可以再次细化管理，或者向领域设计靠近。&lt;/p&gt;&lt;p&gt;业务可以理解为流程管理，小的流程通常service中可以直接处理，但是复杂流程则十分讲究设计，一个基础思想就是分段管理，比较经典的案例就是下单：构建结算页面时初始化订单-支付时订单提交-支付成功才会执行订单。&lt;/p&gt;&lt;p&gt;逻辑上的细节要持续追求严谨，业务实现手段和思路适当放宽，流程经得起考验，底层实现合理的复用，组件选择上应该站在高纬度，就基本足以。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、源代码地址&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https://github.com/cicadasmile/java-base-parent&lt;br/&gt;GitEE·地址&lt;br/&gt;https://gitee.com/cicadasmile/java-base-parent&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d6368afec53aa59cd0dd5553ff6ffa9c</guid>
<title>蚂蚁集团万级规模 K8s 集群 Etcd 高可用建设之路</title>
<link>https://toutiao.io/k/0yu4k5h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;蚂蚁集团运维着可能是全球最大的 K8s 集群：K8s 官方以 5k node 作为 K8s 规模化的顶峰，而蚂蚁集团事实上运维着规模达到 10k node 规模的 K8s 集群。一个形象的比喻就是，如果官方以及跟着官方的 K8s 使用者能想象到的 K8s 的集群规模是泰山，那么蚂蚁集团在官方的解决方案之上已经实现了一个珠穆朗玛峰，引领了 K8s 规模化技术的提升。 &lt;/p&gt;

&lt;p&gt;这个量级的差异，不仅仅是量的差异，更是 K8s 管理维护的质的提升。能维护有如此巨大挑战巨量规模的 K8s 集群，其背后原因是蚂蚁集团付出了远大于 K8s 官方的优化努力。&lt;/p&gt;

&lt;p&gt;所谓万丈高楼平地起，本文着重讨论下蚂蚁集团的在 K8s 的基石 --- etcd 层面做出的高可用建设工作：只有 etcd 这个基石稳当了，K8s 这栋高楼大厦才保持稳定性，有 tidb 大佬黄东旭朋友圈佐证【图片已获黄总授权】。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gw.alipayobjects.com/mdn/sofastack/afts/img/A*cbuiSovI2zYAAAAAAAAAAAAAARQnAQ&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;面临的挑战&lt;/h3&gt;

&lt;p&gt;etcd 首先是 K8s 集群的 KV 数据库。 
从数据库的角度来看，K8s 整体集群架构各个角色如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;etcd 集群的数据库&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kube-apiserver etcd 的 API 接口代理、数据缓存层&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kubelet 数据的生产者和消费者&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kube-controller-manager 数据的消费者和生产者&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kube-scheduler 数据的消费者和生产者&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;etcd 本质是一个 KV 数据库，存储了 K8s 自身资源 、用户自定义的 CRD 以及 K8s 系统的 event 等数据。每种数据的一致性和数据安全性要求不一致，如 event 数据的安全性小于 K8s 自身的资源数据以及 CRD 数据。&lt;/p&gt;

&lt;p&gt;K8s 的早期拥护者在推广 K8s 时，宣称其比 OpenStack 的优势之一是 K8s 没有使用消息队列，其延迟比 OpenStack 低。这其实是一个误解，无论是 etcd 提供的 watch 接口，还是 K8s client 包中的 informer 机制，无不表明 K8s 是把 etcd 当做了消息队列，K8s 消息的载体很多，譬如 K8s event。&lt;/p&gt;

&lt;p&gt;从消息队列的角度来看，K8s 整体集群架构各个角色如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;etcd 消息路由器&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kube-apiserver etcd 生产者消息代理和消息广播【或者成为次级消息路由器、消费者代理】&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kubelet 消息的生产者和消费者&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kube-controller-manager 消息的消费者和生产者&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kube-scheduler 消息的消费者和生产者&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;etcd 是推模式的消息队列。etcd 是 K8s 集群的 KV 数据库和消息路由器，充当了 OpenStack 集群中的 MySQL 和 MQ 两个角色，这样的实现貌似简化了集群的结构，但其实不然。在 large scale 规模 K8s 集群中，一般经验，首先都会使用一个单独 etcd 集群存储 event 数据：把 KV 数据和一部分 MQ 数据物理隔离开，实现了 KV 和 MQ 角色的部分分离。 如 参考文档 2 中提到美团 “针对 etcd 的运营，通过拆分出独立的 event 集群降低主库的压力”。&lt;/p&gt;

&lt;p&gt;当 K8s 集群规模扩大时，etcd 承载着 KV 数据剧增、event 消息暴增以及消息写放大的三种压力。
为了证明所言非虚，特引用部分数据为佐证：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;etcd KV 数据量级在 100 万以上；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;etcd event 数据量在 10 万以上；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;etcd 读流量压力峰值在 30 万 pqm 以上，其中读 event 在 10k qpm 以上；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;etcd 写流量压力峰值在 20 万 pqm 以上，其中写 event 在 15k qpm 以上；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;etcd CPU 经常性飙升到 900% 以上；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;etcd 内存 RSS 在 60 GiB 以上；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;etcd 磁盘使用量可达 100 GiB 以上；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;etcd 自身的 goroutine 数量 9k 以上；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;etcd 使用的用户态线程达 1.6k 以上；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;etcd gc 单次耗时常态下可达 15ms。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用 Go 语言实现的 etcd 管理这些数据非常吃力，无论是 CPU、内存、gc、goroutine 数量还是线程使用量，基本上都接近 go runtime 管理能力极限：经常在 CPU profile 中观测到 go runtime 和 gc 占用资源超过 50% 以上。&lt;/p&gt;

&lt;p&gt;蚂蚁的 K8s 集群在经历高可用项目维护之前，当集群规模突破 7 千节点规模时，曾出现如下性能瓶颈问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;etcd 出现大量的读写延迟，延迟甚至可达分钟级；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kube-apiserver 查询 pods / nodes / configmap / crd 延时很高，导致 etcd oom；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;etcd list-all pods 时长可达 30 分钟以上；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2020 年 etcd 集群曾因 list-all 压力被打垮导致的事故就达好几起；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;控制器无法及时感知数据变化，如出现 watch 数据延迟可达 30s 以上。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果说这种状况下的 etcd 集群是在刀锋上跳舞， 此时的整个 K8s 集群就是一个活火山：稍不留神就有可能背个 P 级故障， 彼时的整个 K8s master 运维工作大概是整个蚂蚁集团最危险的工种之一。&lt;/p&gt;

&lt;h3&gt;高可用策略&lt;/h3&gt;

&lt;p&gt;实现一个分布式系统高可用能力的提升，大概有如下手段：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;提升自身稳定性与性能；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;精细管理上游流量；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;保证服务下游服务 SLO。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;etcd 经过社区与各方使用者这么多年的锤炼，其自身的稳定性足够。蚂蚁人能做到的，无非是使出周扒皮的本事，提高集群资源整体利用率，scale out 和 scale up 两种技术手段双管齐下，尽可能的提升其性能。&lt;/p&gt;

&lt;p&gt;etcd 自身作为 K8s 的基石，其并无下游服务。如果说有，那也是其自身所使用的物理 node 环境了。下面分别从 etcd 集群性能提升、请求流量管理等角度阐述我们在 etcd 层面所做出的高可用能力提升工作。&lt;/p&gt;

&lt;h3&gt;文件系统升级&lt;/h3&gt;

&lt;p&gt;在山窝里飞出金凤凰，诚非易事。让 etcd 跑的更快这件事，没有什么手段比提供一个高性能的机器更短平快地见效了。&lt;/p&gt;

&lt;h4&gt;1.使用 NVMe ssd&lt;/h4&gt;

&lt;p&gt;etcd 自身 = etcd 程序 + 其运行环境。早期 etcd 服务器使用的磁盘是 SATA 盘，经过简单地测试发现 etcd 读磁盘速率非常慢，老板豪横地把机器鸟枪换炮 --- 升级到使用了 NVMe SSD 的 f53 规格的机器：etcd 使用 NVMe ssd 存储 boltdb 数据后，随机写速率可提升到 70 MiB/s 以上。&lt;/p&gt;

&lt;p&gt;参考文档 2 中提到美团 “基于高配的 SSD 物理机器部署可以达到日常 5 倍的高流量访问”，可见提升硬件性能是大厂的首选，能折腾机器千万别浪费人力。&lt;/p&gt;

&lt;h4&gt;2.使用 tmpfs&lt;/h4&gt;

&lt;p&gt;NVMe ssd 虽好，理论上其读写极限性能跟内存比还是差一个数量级。我们测试发现使用 tmpfs【未禁止 swap out】替换 NVMe ssd 后，etcd 在读写并发的情况下性能仍然能提升 20% 之多。考察 K8s 各种数据类型的特点后，考虑到 event 对数据的安全性要求不高但是对实时性要求较高的特点，我们毫不犹豫的把 event etcd 集群运行在了 tmpfs 文件系统之上，将 K8s 整体的性能提升了一个层次。&lt;/p&gt;

&lt;h4&gt;3.磁盘文件系统&lt;/h4&gt;

&lt;p&gt;磁盘存储介质升级后，存储层面能够进一步做的事情就是研究磁盘的文件系统格式。目前 etcd 使用的底层文件系统是 ext4 格式，其 block size 使用的是默认的 4 KiB。我们团队曾对 etcd 进行单纯的在单纯写并行压测时发现，把文件系统升级为 xfs，且 block size 为 16 KiB【在测试的 KV size 总和 10 KiB 条件下】时，etcd 的写性能仍然有提升空间。&lt;/p&gt;

&lt;p&gt;但在读写并发的情况下，磁盘本身的写队列几乎毫无压力，又由于 etcd 3.4 版本实现了并行缓存读，磁盘的读压力几乎为零，这就意味着：继续优化文件系统对 etcd 的性能提升空间几乎毫无帮助。自此以后单节点 etcd scale up 的关键就从磁盘转移到了内存：优化其内存索引读写速度。&lt;/p&gt;

&lt;h4&gt;4.磁盘透明大页&lt;/h4&gt;

&lt;p&gt;在现代操作系统的内存管理中，有 huge page 和 transparent huge page 两种技术，不过一般用户采用 transparent huge page 实现内存 page 的动态管理。在 etcd 运行环境，关闭 transparent huge page 功能，否则 RT 以及 QPS 等经常性的监控指标会经常性的出现很多毛刺，导致性能不平稳。&lt;/p&gt;

&lt;h3&gt;etcd 调参&lt;/h3&gt;

&lt;p&gt;MySQL 运维工程师常被人称为 “调参工程师”，另一个有名的 KV 数据库 RocksDB 也不遑多让，二者可调整的参数之多到了令人发指的地方：其关键就在于针对不同存储和运行环境需要使用不同的参数，才能充分利用硬件的性能。etcd 随不及之，但也不拉人后，预计以后其可调整参数也会越来越多。&lt;/p&gt;

&lt;p&gt;etcd 自身也对外暴露了很多参数调整接口。除了阿里集团 K8s 团队曾经做出的把 freelist 由 list 改进为 map 组织形式优化外，目前常规的 etcd 可调整参数如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;write batch&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;compaction&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;1.write batch&lt;/h4&gt;

&lt;p&gt;像其他常规的 DB 一样，etcd 磁盘提交数据时也采用了定时批量提交、异步写盘的方式提升吞吐，并通过内存缓存的方式平衡其延时。具体的调整参数接口如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;batch write number 批量写 KV 数目，默认值是 10k；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;batch write interval 批量写事件间隔，默认值是 100 ms。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;etcd batch 这两个默认值在大规模 K8s 集群下是不合适的，需要针对具体的运行环境调整之，避免导致内存使用 OOM。一般地规律是，集群 node 数目越多，这两个值就应该成比例减小。&lt;/p&gt;

&lt;h4&gt;2.compaction&lt;/h4&gt;

&lt;p&gt;etcd 自身由于支持事务和消息通知，所以采用了 MVCC 机制保存了一个 key 的多版本数据，etcd 使用定时的 compaction 机制回收这些过时数据。etcd 对外提供的压缩任务参数如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;compaction interval 压缩任务周期时长；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;compaction sleep interval 单次压缩批次间隔时长，默认 10 ms；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;compaction batch limit 单次压缩批次 KV 数目，默认 1000。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（1）压缩任务周期&lt;/p&gt;

&lt;p&gt;K8s 集群的 etcd compaction 可以有两种途径进行 compaction：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;etcd 另外提供了 comapct 命令和 API 接口，K8s kube-apiserver 基于这个 API 接口也对外提供了 compact 周期参数；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;etcd 自身会周期性地执行 compaction；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;etcd 对外提供了自身周期性 compaction 参数调整接口，这个参数的取值范围是 (0, 1 hour]；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其意义是：etcd compaction 即只能打开不能关闭，如果设置的周期时长大于 1 hour，则 etcd 会截断为 1 hour。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;蚂蚁 K8s 团队在经过测试和线下环境验证后，目前的压缩周期取值经验是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在 etcd 层面把 compaction 周期尽可能地拉长，如取值 1 hour，形同在 etcd 自身层面关闭 compaction，把 compaction interval 的精细调整权交给 K8s kube-apiserver；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 K8s kube-apiserver 层面，根据线上集群规模取值不同的 compaction interval。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;之所以把 etcd compaction interval 精细调整权调整到 kube-apiserver 层面，是因为 etcd 是 KV 数据库，不方便经常性地启停进行测试，而 kube-apiserver 是 etcd 的缓存，其数据是弱状态数据，相对来说启停比较方便，方便调参。至于 compaction interval 的取值，一条经验是：集群 node 越多 compaction interval 取值可以适当调大。&lt;/p&gt;

&lt;p&gt;compaction 本质是一次写动作，在大规模集群中频繁地执行 compaction 任务会影响集群读写任务的延时，集群规模越大，其延时影响越明显，在 kube-apiserver 请求耗时监控上表现就是有频繁出现地周期性的大毛刺。&lt;/p&gt;

&lt;p&gt;更进一步，如果平台上运行的任务有很明显的波谷波峰特性，如每天的 8:30 am ~ 21:45 pm 是业务高峰期，其他时段是业务波峰期，那么可以这样执行 compaction 任务：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在 etcd 层面设定 compaction 周期是 1 hour；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 kube-apiserver 层面设定 comapction 周期是 30 minutes；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 etcd 运维平台上启动一个周期性任务：当前时间段在业务波谷期，则启动一个 10 minutes 周
期的 compaction 任务。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其本质就是把 etcd compaction 任务交给 etcd 运维平台，当发生电商大促销等全天无波谷的特殊长周期时间段时，就可以在平台上紧急关闭 compaction 任务，把 compaction 任务对正常的读写请求影响降低到最低。&lt;/p&gt;

&lt;p&gt;（2）单次压缩&lt;/p&gt;

&lt;p&gt;即使是单次压缩任务，etcd 也是分批执行的。因为 etcd 使用的存储引擎 boltdb 的读写形式是多读一写：可以同时并行执行多个读任务，但是同时刻只能执行一个写任务。&lt;/p&gt;

&lt;p&gt;为了防止单次 compaction 任务一直占用 boltdb 的读写锁，每次执行一批固定量【compaction batch limit】的磁盘 KV 压缩任务后，etcd 会释放读写锁 sleep 一段时间【compaction sleep interval】。&lt;/p&gt;

&lt;p&gt;在 v3.5 之前，compaction sleep interval 固定为 10 ms，在 v3.5 之后 etcd 已经把这个参数开放出来方便大规模 K8s 集群进行调参。类似于 batch write 的 interval 和 number，单次 compaction 的 sleep interval 和 batch limit 也需要不同的集群规模设定不同的参数，以保证 etcd 平稳运行和 kube-apiserver 的读写 RT 指标平稳无毛刺。 &lt;/p&gt;

&lt;h3&gt;运维平台&lt;/h3&gt;

&lt;p&gt;无论是 etcd 调参，还是升级其运行的文件系统，都是通过 scale up 的手段提升 etcd 的能力。还有两种 scale up 手段尚未使用：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通过压测或者在线获取 etcd 运行 profile，分析 etcd 流程的瓶颈，然后优化代码流程提升性能；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过其他手段降低单节点 etcd 数据量。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过代码流程优化 etcd 性能，可以根据 etcd 使用方的人力情况进行之，更长期的工作应该是紧跟社区，及时获取其版本升级带来的技术红利。通过降低 etcd 数据规模来获取 etcd 性能的提升则必须依赖 etcd 使用方自身的能力建设了。&lt;/p&gt;

&lt;p&gt;我们曾对 etcd 的单节点 RT 与 QPS 性能与 KV 数据量的关系进行过 benchmark 测试，得到的结论是：当 KV 数据量增加时，其 RT 会随之线性增加，其 QPS 吞吐则会指数级下降。这一步测试结果带来的启示之一即是：通过分析 etcd 中的数据组成、外部流量特征以及数据访问特点，尽可能地降低单 etcd 节点的数据规模。&lt;/p&gt;

&lt;p&gt;目前蚂蚁的 etcd 运维平台具有如下数据分析功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;longest N KV --- 长度最长的 N 个 KV&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;top N KV --- 段时间内访问次数最多的 N 个 KV&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;top N namespace --- KV 数目最多的 N 个 namespace &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;verb + resoure --- 外部访问的动作和资源统计&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;连接数 --- 每个 etcd 节点的长连接数目&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;client 来源统计 --- 每个 etcd 节点的外部请求来源统计&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;冗余数据分析 --- etcd 集群中近期无外部访问的 KV 分布&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据数据分析结果，可以进行如下工作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;客户限流&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;负载均衡&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;集群拆分&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;冗余数据删除&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;业务流量精细分析&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;1.集群拆分&lt;/h4&gt;

&lt;p&gt;前文提到，etcd 集群性能提升的一个经典手段就是把 event 数据独立拆分到一个独立的 etcd 集群，因为 event 数据是 K8s 集群一中量级比较大、流动性很强、访问量非常高的数据，拆分之后可以降低 etcd 的数据规模并减轻 etcd 单节点的外部客户端流量。&lt;/p&gt;

&lt;p&gt;一些经验性的、常规性的 etcd 拆分手段有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;pod/cm&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;node/svc&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;event, lease&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些数据拆分后，大概率能显著提升 K8s 集群的 RT 与 QPS，但是更进一步的数据拆分工作还是有必要的。依据数据分析平台提供的热数据【top N KV】量级以及外部客户访问【verb + resource】情况，进行精细分析后可以作为 etcd 集群拆分工作的依据。&lt;/p&gt;

&lt;h4&gt;2.客户数据分析&lt;/h4&gt;

&lt;p&gt;针对客户数据的分析分为 longest N KV 分析、top N namespace。&lt;/p&gt;

&lt;p&gt;一个显然成立的事实是：单次读写访问的 KV 数据越长，则 etcd 响应时间越长。通过获取客户写入的 longest N KV 数据后，可以与平台使用方研究其对平台的使用方法是否合理，降低业务对 K8s 平台的访问流量压力和 etcd 自身的存储压力。&lt;/p&gt;

&lt;p&gt;一般地，K8s 平台每个 namespace 都是分配给一个业务单独使用。前面提到 K8s 可能因为 list-all 压力导致被压垮，这些数据访问大部分情况下都是 namespace 级别的 list-all。从平台获取 top N namespace 后，重点监控这些数据量级比较大的业务的 list-all 长连接请求，在 kube-apiserver 层面对其采取限流措施，就可以基本上保证 K8s 集群不会被这些长连接请求打垮，保证集群的高可用。&lt;/p&gt;

&lt;h4&gt;3.冗余数据分析&lt;/h4&gt;

&lt;p&gt;etcd 中不仅有热数据，还有冷数据。这些冷数据虽然不会带来外部流量访问压力，但是会导致 etcd 内存索引锁粒度的增大，进而导致每次 etcd 访问 RT 时延增加和整体 QPS 的下降。&lt;/p&gt;

&lt;p&gt;近期通过分析某大规模【7k node 以上】 K8s 集群 etcd 中的冗余数据，发现某业务数据在 etcd 中存储了大量数据，其数据量大却一周内没有访问过一次，与业务方询问后获悉：业务方把 K8s 集群的 etcd 当做其 crd 数据的冷备使用。与业务方沟通后把数据从 etcd 中迁移掉后，内存 key 数目立即下降 20% 左右，大部分 etcd KV RT P99 延时立即下降 50% ~ 60% 之多。&lt;/p&gt;

&lt;h4&gt;4.负载均衡&lt;/h4&gt;

&lt;p&gt;K8s 平台运维人员一般都有这样一条经验：etcd 集群如果发生了启停，需要尽快对所有 K8s kube-apiserver 进行一次重启，以保证 kube-apiserver 与 etcd 之间连接数的均衡。其原因有二：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;kube-apiserver 在启动时可以通过随机方式保证其与 etcd 集群中某个节点建立连接，但 etcd 发生启停后，kube-apiserver 与 etcd 之间的连接数并无规律，导致每个 etcd 节点承担的客户端压力不均衡；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kube-apiserver 与 etcd 连接数均衡时，其所有读写请求有 2/3 概率是经过 follower 转发到 leader，保证整体 etcd 集群负载的均衡，如果连接不均衡则集群性能无法评估。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过 etcd 运维平台提供的每个 etcd 的连接负载压力，可以实时获取集群连接的均衡性，进而决定运维介入的时机，保证 etcd 集群整体的健康度。&lt;/p&gt;

&lt;p&gt;其实最新的 etcd v3.5 版本已经提供了 etcd 客户端和 etcd 节点之间的自动负载均衡功能，但这个版本才发布没多久，目前最新版本的 K8s 尚未支持这个版本，可以及时跟进 K8s 社区对这个版本的支持进度以及时获取这一技术红利，减轻平台运维压力。 &lt;/p&gt;

&lt;h3&gt;未来之路&lt;/h3&gt;

&lt;p&gt;通过一年多的包括 kube-apiserver 和 etcd 在内的 K8s 高可用建设，目前 K8s 集群已经稳定下来，一个显著的特征是半年内 K8s 集群没有发生过一次 P 级故障，但其高可用建设工作不可能停歇 --- 作为全球 K8s 规模化建设领导力象限的蚂蚁集团正在挑战 node 量级更大规模的 K8s 集群，这一工作将推动 etcd 集群建设能力的进一步提升。&lt;/p&gt;

&lt;p&gt;前面提到的很多 etcd 能力提升工作都是围绕其 scale up 能力提升展开的，这方面的能力还需要更深层次的加强：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;etcd 最新 feature 地及时跟进，及时把社区技术进步带来的开源价值转换为蚂蚁 K8s 平台上的客户价值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.及时跟进阿里集团在 etcd compact 算法优化、etcd 单节点多 multiboltdb 的架构优化以及 kube-apiserver 的服务端数据压缩等 etcd 优化工作【见参考文档 1】，对兄弟团队的工作进行借鉴和反馈，协同作战共同提升&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;跟进蚂蚁自身 K8s 平台上 etcd 的性能瓶颈，提出我们自己的解决方案，在提升我们平台的技术价值的同时反哺开源&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;除了关注 etcd 单节点性能的提升，我们下一步的工作将围绕分布式 etcd 集群这一 scale out 方向展开。前面提到的 etcd 集群拆分工作，其本质就是通过分布式 etcd 集群的方式提升 etcd 集群整体的性能：该集群的数据划分方式是依据 K8s 业务层面的数据类型进行的。&lt;/p&gt;

&lt;p&gt;该工作可以进一步拓展为：不区分 KV 的业务意义，从单纯的 KV 层面对把数据根据某种路由方式把数据写入后端多 etcd 子集群，实现 etcd 集群整体的冷热负载均衡。&lt;/p&gt;

&lt;p&gt;分布式 etcd 集群的实现有两种方式：proxyless 和 proxy based：proxy based etcd 分布式集群的请求链路是 client[kube-apiserver] -&amp;gt; proxy -&amp;gt; etcd server，而谓的 proxyless 分布式 etcd 集群的请求链路是 client[kube-apiserver] -&amp;gt; etcd server。&lt;/p&gt;

&lt;p&gt;proxy based etcd 分布式集群的好处是可以直接基于 etcd 社区提供的 etcd proxy 进行开发，后期亦可回馈社区，实现其开源价值、技术价值和客户价值的统一。但经过测试：按照测试发现，kube-apiserver 经过 proxy 向 etcd 发起读写请求后 RT  和 QPS 降低 20% ~ 25%。所以下一步的工作重点是开发 proxyless etcd 集群。&lt;/p&gt;

&lt;p&gt;目前的拆分后的 etcd 分布式集群本质或者 67% 的概率是 proxy based 分布式集群：kube-apiserver 的请求大概有三分之二的概率是经过 follower 转发到 leader，此处的 follower 本质就是一个 proxy。如果 kube-apiserver 所有请求都是与 leader 直连后被处理，理论上当前的 K8s 集群的 RT 和 QPS 就有 67% * 20% ≈ 13.4% 的性能收益。&lt;/p&gt;

&lt;p&gt;proxyless etcd 分布式集群的缺点是如果把 proxy 的路由逻辑放入 kube-apiserver 中，会造成 kube-apiserver 版本升级成本增加，但相比于至少 20% 【将来通过 etcd 集群规模扩充这个收益肯定会更大】的收益，这个仅仅影响了 kube-apiserver 单个组件的版本升级的成本是值得的。&lt;/p&gt;

&lt;p&gt;除了 multiple etcd clusters 的思路外，数据中间件团队基于 OBKV 之上实现了 etcd  V3 API ，算是另一种比较好的技术路线，颇类似于本文开头黄东旭提到的在 tikv 之上 etcd  V3 API 接口层，可以称之为类 etcd 系统，目前相关工作也在推进中。&lt;/p&gt;

&lt;p&gt;总之，随着我们 K8s 规模越来越大，蚂蚁集团 etcd 整体工作的重要性就日益凸显。 如果说前期 etcd 的高可用建设之路是在泥泞小道上蹒跚前行，那么以后的 etcd 高可用建设之路必是康庄大道 --- 道路越走越宽广！&lt;/p&gt;

&lt;h4&gt;参看文档&lt;/h4&gt;

&lt;p&gt;参考文档 1：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.kubernetes.org.cn/9284.html&quot;&gt;https://www.kubernetes.org.cn/9284.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考文档 2：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://tech.meituan.com/2020/08/13/openstack-to-kubernetes-in-meituan.html&quot;&gt;https://tech.meituan.com/2020/08/13/openstack-to-kubernetes-in-meituan.html&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;作者简介&lt;/h4&gt;

&lt;p&gt;于雨（github @AlexStocks），dubbogo 社区负责人，一个有十一年服务端基础架构和中间件研发一线工作经验的程序员。&lt;/p&gt;

&lt;p&gt;陆续参与和改进过 Redis/Pika/Pika-Port/etcd/Muduo/Dubbo/dubbo-go/Sentinel-go 等知名项目，目前在蚂蚁金服可信原生部蚂蚁大规模 K8s 集群调度团队从事容器编排工作，参与维护全球规模最大的 Kubernetes 生产集群之一，致力于打造规模化、金融级、可信的云原生基础设施。&lt;/p&gt;

&lt;p&gt;欢迎对 Serverless 自动伸缩技术、自适应混合部署技术以及 Kata/Nanovisor 等安全容器技术感兴趣的同行或者 2022 届应届毕业生加入我们。&lt;/p&gt;

&lt;p&gt;联系邮箱 &lt;a href=&quot;mailto:xiaoyun.maoxy@antgroup.com&quot;&gt;xiaoyun.maoxy@antgroup.com&lt;/a&gt; 或者 &lt;a href=&quot;mailto:yuyu.zx@antgroup.com&quot;&gt;yuyu.zx@antgroup.com&lt;/a&gt;。&lt;/p&gt;

&lt;h3&gt;本周推荐阅读&lt;/h3&gt;



&lt;p&gt;更多文章请扫码关注“金融级分布式架构”公众号&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gw.alipayobjects.com/mdn/sofastack/afts/img/A*5aK0RYuH9vgAAAAAAAAAAAAAARQnAQ&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ac14c4b9298e7a43c4d0a98c1d07b436</guid>
<title>容器三把斧之 namespace 原理与实现</title>
<link>https://toutiao.io/k/1uwmeyu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;&lt;span&gt;namespace介绍&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;namespace（命名空间）&lt;/code&gt; 是Linux提供的一种内核级别环境隔离的方法，很多编程语言也有 namespace 这样的功能，例如C++，Java等，编程语言的 namespace 是为了解决项目中能够在不同的命名空间里使用相同的函数名或者类名。而Linux的 namespace 也是为了实现资源能够在不同的命名空间里有相同的名称，譬如在 &lt;code&gt;A命名空间&lt;/code&gt; 有个pid为1的进程，而在 &lt;code&gt;B命名空间&lt;/code&gt; 中也可以有一个pid为1的进程。&lt;/p&gt;&lt;p&gt;有了 &lt;code&gt;namespace&lt;/code&gt; 就可以实现基本的容器功能，著名的 &lt;code&gt;Docker&lt;/code&gt; 也是使用了 namespace 来实现资源隔离的。&lt;/p&gt;&lt;p&gt;Linux支持6种资源的 &lt;code&gt;namespace&lt;/code&gt;，分别为（文档）：&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Parameter&lt;/th&gt;&lt;th&gt;Linux Version&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Mount namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWNS&lt;/td&gt;&lt;td&gt;Linux 2.4.19&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UTS namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWUTS&lt;/td&gt;&lt;td&gt;Linux 2.6.19&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IPC namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWIPC&lt;/td&gt;&lt;td&gt;Linux 2.6.19&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PID namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWPID&lt;/td&gt;&lt;td&gt;Linux 2.6.24&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Network namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWNET&lt;/td&gt;&lt;td&gt;Linux 2.6.24&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;User namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWUSER&lt;/td&gt;&lt;td&gt;Linux 2.6.23&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;在调用 &lt;code&gt;clone()&lt;/code&gt; 系统调用时，传入以上的不同类型的参数就可以实现复制不同类型的namespace。比如传入 &lt;code&gt;CLONE_NEWPID&lt;/code&gt; 参数时，就是复制 &lt;code&gt;pid命名空间&lt;/code&gt;，在新的 &lt;code&gt;pid命名空间&lt;/code&gt; 里可以使用与其他 &lt;code&gt;pid命名空间&lt;/code&gt; 相同的pid。代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; _GNU_SOURCE&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sched.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;char&lt;/span&gt; child_stack[&lt;span&gt;5000&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;child&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;* arg)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Child - %d\n&quot;&lt;/span&gt;, getpid());&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Parent - fork child\n&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; pid = clone(child, child_stack+&lt;span&gt;5000&lt;/span&gt;, CLONE_NEWPID, &lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (pid == &lt;span&gt;-1&lt;/span&gt;) {&lt;br/&gt;        perror(&lt;span&gt;&quot;clone:&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    waitpid(pid, &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Parent - child(%d) exit\n&quot;&lt;/span&gt;, pid);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Parent - fork child&lt;br/&gt;Parent - child(9054) &lt;span&gt;exit&lt;/span&gt;&lt;br/&gt;Child - 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从运行结果可以看出，在子进程的 &lt;code&gt;pid命名空间&lt;/code&gt; 里当前进程的pid为1，但在父进程的 &lt;code&gt;pid命名空间&lt;/code&gt; 中子进程的pid却是9045。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;namespace实现原理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;为了让每个进程都可以从属于某一个namespace，Linux内核为进程描述符添加了一个 &lt;code&gt;struct nsproxy&lt;/code&gt; 的结构，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;task_struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;/* namespaces */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;nsproxy&lt;/span&gt; *&lt;span&gt;nsproxy&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;nsproxy&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;atomic_t&lt;/span&gt; count;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;uts_namespace&lt;/span&gt;  *&lt;span&gt;uts_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;ipc_namespace&lt;/span&gt;  *&lt;span&gt;ipc_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;mnt_namespace&lt;/span&gt;  *&lt;span&gt;mnt_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_namespace&lt;/span&gt;  *&lt;span&gt;pid_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;user_namespace&lt;/span&gt; *&lt;span&gt;user_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;net&lt;/span&gt;            *&lt;span&gt;net_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从 &lt;code&gt;struct nsproxy&lt;/code&gt; 结构的定义可以看出，Linux为每种不同类型的资源定义了不同的命名空间结构体进行管理。比如对于 &lt;code&gt;pid命名空间&lt;/code&gt; 定义了 &lt;code&gt;struct pid_namespace&lt;/code&gt; 结构来管理 。由于 namespace 涉及的资源种类比较多，所以本文主要以 &lt;code&gt;pid命名空间&lt;/code&gt; 作为分析的对象。&lt;/p&gt;&lt;p&gt;我们先来看看管理 &lt;code&gt;pid命名空间&lt;/code&gt; 的 &lt;code&gt;struct pid_namespace&lt;/code&gt; 结构的定义：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_namespace&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;kref&lt;/span&gt; &lt;span&gt;kref&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pidmap&lt;/span&gt; &lt;span&gt;pidmap&lt;/span&gt;[&lt;span&gt;PIDMAP_ENTRIES&lt;/span&gt;];&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; last_pid;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;task_struct&lt;/span&gt; *&lt;span&gt;child_reaper&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;kmem_cache&lt;/span&gt; *&lt;span&gt;pid_cachep&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; level;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_namespace&lt;/span&gt; *&lt;span&gt;parent&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;ifdef&lt;/span&gt; CONFIG_PROC_FS&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;vfsmount&lt;/span&gt; *&lt;span&gt;proc_mnt&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为 &lt;code&gt;struct pid_namespace&lt;/code&gt; 结构主要用于为当前 &lt;code&gt;pid命名空间&lt;/code&gt; 分配空闲的pid，所以定义比较简单：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;kref&lt;/code&gt; 成员是一个引用计数器，用于记录引用这个结构的进程数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;pidmap&lt;/code&gt; 成员用于快速找到可用pid的位图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;last_pid&lt;/code&gt; 成员是记录最后一个可用的pid&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;level&lt;/code&gt; 成员记录当前 &lt;code&gt;pid命名空间&lt;/code&gt; 所在的层次&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;parent&lt;/code&gt; 成员记录当前 &lt;code&gt;pid命名空间&lt;/code&gt; 的父命名空间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;由于 &lt;code&gt;pid命名空间&lt;/code&gt; 是分层的，也就是说新创建一个 &lt;code&gt;pid命名空间&lt;/code&gt; 时会记录父级 &lt;code&gt;pid命名空间&lt;/code&gt; 到 &lt;code&gt;parent&lt;/code&gt; 字段中，所以随着 &lt;code&gt;pid命名空间&lt;/code&gt; 的创建，在内核中会形成一颗 &lt;code&gt;pid命名空间&lt;/code&gt; 的树，如下图（图片来源）：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7692307692307693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J74NbeVUdkM6eOh9r4NC48Kf8z17iaicxOZKQNUthUYx2NBictpiaIUdZIF6BPC7Ty4XI3GyUAYGvTvhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;598&quot;/&gt;&lt;figcaption&gt;pid-namespace&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;第0层的 &lt;code&gt;pid命名空间&lt;/code&gt; 是 &lt;code&gt;init&lt;/code&gt; 进程所在的命名空间。如果一个进程所在的 &lt;code&gt;pid命名空间&lt;/code&gt; 为 &lt;code&gt;N&lt;/code&gt;，那么其在 &lt;code&gt;0 ~ N 层pid命名空间&lt;/code&gt; 都有一个唯一的pid号。也就是说 &lt;code&gt;高层pid命名空间&lt;/code&gt; 的进程对 &lt;code&gt;低层pid命名空间&lt;/code&gt; 的进程是可见的，但是 &lt;code&gt;低层pid命名空间&lt;/code&gt; 的进程对 &lt;code&gt;高层pid命名空间&lt;/code&gt; 的进程是不可见的。&lt;/p&gt;&lt;p&gt;由于在 &lt;code&gt;第N层pid命名空间&lt;/code&gt; 的进程其在 &lt;code&gt;0 ~ N层pid命名空间&lt;/code&gt; 都有一个唯一的pid号，所以在进程描述符中通过 &lt;code&gt;pids&lt;/code&gt; 成员来记录其在每个层的pid号，代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;task_struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_link&lt;/span&gt; &lt;span&gt;pids&lt;/span&gt;[&lt;span&gt;PIDTYPE_MAX&lt;/span&gt;];&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;enum&lt;/span&gt; pid_type {&lt;br/&gt;    PIDTYPE_PID,&lt;br/&gt;    PIDTYPE_PGID,&lt;br/&gt;    PIDTYPE_SID,&lt;br/&gt;    PIDTYPE_MAX&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;upid&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; nr;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_namespace&lt;/span&gt; *&lt;span&gt;ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;hlist_node&lt;/span&gt; &lt;span&gt;pid_chain&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;atomic_t&lt;/span&gt; count;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;hlist_head&lt;/span&gt; &lt;span&gt;tasks&lt;/span&gt;[&lt;span&gt;PIDTYPE_MAX&lt;/span&gt;];&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;rcu_head&lt;/span&gt; &lt;span&gt;rcu&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; level;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;upid&lt;/span&gt; &lt;span&gt;numbers&lt;/span&gt;[1];&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_link&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;hlist_node&lt;/span&gt; &lt;span&gt;node&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid&lt;/span&gt; *&lt;span&gt;pid&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这几个结构的关系如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5994623655913979&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J74NbeVUdkM6eOh9r4NC48KicZDODa01icT37hqUoqJYhtiaUHDRjuzIFSKqa0v0dj6woKv60F77w9Uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;figcaption&gt;pid-namespace-structs&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们主要关注 &lt;code&gt;struct pid&lt;/code&gt; 这个结构，&lt;code&gt;struct pid&lt;/code&gt; 有个类型为 &lt;code&gt;struct upid&lt;/code&gt; 的成员 &lt;code&gt;numbers&lt;/code&gt;，其定义为只有一个元素的数组，但是其实是一个动态的数据，它的元素个数与 &lt;code&gt;level&lt;/code&gt; 的值一致，也就是说当 &lt;code&gt;level&lt;/code&gt; 的值为5时，那么 &lt;code&gt;numbers&lt;/code&gt; 成员就是一个拥有5个元素的数组。而每个元素记录了其在每层 &lt;code&gt;pid命名空间&lt;/code&gt; 的pid号，而 &lt;code&gt;struct upid&lt;/code&gt; 结构的 &lt;code&gt;nr&lt;/code&gt; 成员就是用于记录进程在不同层级 &lt;code&gt;pid命名空间&lt;/code&gt; 的pid号。&lt;/p&gt;&lt;p&gt;我们通过代码来看看怎么为进程分配pid号的，在内核中是用过 &lt;code&gt;alloc_pid()&lt;/code&gt; 函数分配pid号的，代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;struct pid *&lt;span&gt;alloc_pid&lt;/span&gt;&lt;span&gt;(struct pid_namespace *ns)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid&lt;/span&gt; *&lt;span&gt;pid&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;enum&lt;/span&gt; pid_type type;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i, nr;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_namespace&lt;/span&gt; *&lt;span&gt;tmp&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;upid&lt;/span&gt; *&lt;span&gt;upid&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    pid = kmem_cache_alloc(ns-&amp;gt;pid_cachep, GFP_KERNEL);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!pid)&lt;br/&gt;        &lt;span&gt;goto&lt;/span&gt; out;&lt;br/&gt;&lt;br/&gt;    tmp = ns;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = ns-&amp;gt;level; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--) {&lt;br/&gt;        nr = alloc_pidmap(tmp);    &lt;span&gt;// 为当前进程所在的不同层级pid命名空间分配一个pid&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nr &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;goto&lt;/span&gt; out_free;&lt;br/&gt;&lt;br/&gt;        pid-&amp;gt;numbers[i].nr = nr;   &lt;span&gt;// 对应i层namespace中的pid数字&lt;/span&gt;&lt;br/&gt;        pid-&amp;gt;numbers[i].ns = tmp;  &lt;span&gt;// 对应i层namespace的实体&lt;/span&gt;&lt;br/&gt;        tmp = tmp-&amp;gt;parent;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    get_pid_ns(ns);&lt;br/&gt;    pid-&amp;gt;level = ns-&amp;gt;level;&lt;br/&gt;    atomic_set(&amp;amp;pid-&amp;gt;count, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (type = &lt;span&gt;0&lt;/span&gt;; type &amp;lt; PIDTYPE_MAX; ++type)&lt;br/&gt;        INIT_HLIST_HEAD(&amp;amp;pid-&amp;gt;tasks[type]);&lt;br/&gt;&lt;br/&gt;    spin_lock_irq(&amp;amp;pidmap_lock);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = ns-&amp;gt;level; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--) {&lt;br/&gt;        upid = &amp;amp;pid-&amp;gt;numbers[i];&lt;br/&gt;        &lt;span&gt;// 把upid连接到全局pid中, 用于快速查找pid&lt;/span&gt;&lt;br/&gt;        hlist_add_head_rcu(&amp;amp;upid-&amp;gt;pid_chain,&lt;br/&gt;                &amp;amp;pid_hash[pid_hashfn(upid-&amp;gt;nr, upid-&amp;gt;ns)]);&lt;br/&gt;    }&lt;br/&gt;    spin_unlock_irq(&amp;amp;pidmap_lock);&lt;br/&gt;&lt;br/&gt;out:&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; pid;&lt;br/&gt;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码中，那个 &lt;code&gt;for (i = ns-&amp;gt;level; i &amp;gt;= 0; i--)&lt;/code&gt; 就是通过 &lt;code&gt;parent&lt;/code&gt; 成员不断向上检索为不同层级的 &lt;code&gt;pid命名空间&lt;/code&gt; 分配一个唯一的pid号，并且保存到对应的 &lt;code&gt;nr&lt;/code&gt; 字段中。另外，还会把进程所在各个层级的pid号添加到全局pid哈希表中，这样做是为了通过pid号快速找到进程。&lt;/p&gt;&lt;p&gt;现在我们来看看怎么通过pid号快速找到一个进程，在内核中 &lt;code&gt;find_get_pid()&lt;/code&gt; 函数用来通过pid号查找对应的 &lt;code&gt;struct pid&lt;/code&gt; 结构，代码如下（find_get_pid() -&amp;gt; find_vpid() -&amp;gt; find_pid_ns()）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;struct pid *&lt;span&gt;find_get_pid&lt;/span&gt;&lt;span&gt;(&lt;span&gt;pid_t&lt;/span&gt; nr)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid&lt;/span&gt; *&lt;span&gt;pid&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    rcu_read_lock();&lt;br/&gt;    pid = get_pid(find_vpid(nr));&lt;br/&gt;    rcu_read_unlock();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; pid;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;struct pid *&lt;span&gt;find_vpid&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nr)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; find_pid_ns(nr, current-&amp;gt;nsproxy-&amp;gt;pid_ns);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;struct pid *&lt;span&gt;find_pid_ns&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nr, struct pid_namespace *ns)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;hlist_node&lt;/span&gt; *&lt;span&gt;elem&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;upid&lt;/span&gt; *&lt;span&gt;pnr&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    hlist_for_each_entry_rcu(pnr, elem,&lt;br/&gt;            &amp;amp;pid_hash[pid_hashfn(nr, ns)], pid_chain)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pnr-&amp;gt;nr == nr &amp;amp;&amp;amp; pnr-&amp;gt;ns == ns)&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; container_of(pnr, struct pid,&lt;br/&gt;                    numbers[ns-&amp;gt;level]);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过pid号查找 &lt;code&gt;struct pid&lt;/code&gt; 结构时，首先会把进程pid号和当前进程的 &lt;code&gt;pid命名空间&lt;/code&gt; 传入到 &lt;code&gt;find_pid_ns()&lt;/code&gt; 函数，而在 &lt;code&gt;find_pid_ns()&lt;/code&gt; 函数中通过全局pid哈希表来快速查找对应的 &lt;code&gt;struct pid&lt;/code&gt; 结构。获取到 &lt;code&gt;struct pid&lt;/code&gt; 结构后就可以很容易地获取到进程对应的进程描述符，例如可以通过 &lt;code&gt;pid_task()&lt;/code&gt; 函数来获取 &lt;code&gt;struct pid&lt;/code&gt; 结构对应进程描述符，由于代码比较简单，这里就不再分析了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a88b3969972adb4e9f02e096971c026b</guid>
<title>除了这点技术，其它什么也不会啊</title>
<link>https://toutiao.io/k/x4pf7co</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;长按二维码向我转账&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;人生如梦，一樽还酹江月&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>