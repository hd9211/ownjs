<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0126231042525cf7983337ea5e9eb42e</guid>
<title>优质网站同好者周刊（第 072 期） | 倾城博客</title>
<link>https://toutiao.io/k/i7tdmsy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%88%86%E4%BA%AB&quot;&gt;&lt;code&gt;分享&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B9%BF%E5%91%8A&quot;&gt;&lt;code&gt;广告&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%9B%BE%E7%89%87&quot;&gt;&lt;code&gt;图片&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：portfolio, free portfolios, gallery, free image hosting, upload picture, upload images free, free gallery, free album, image gallery, photo hosting sites, professional portfolios&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Simple, fast, free portfolios. No login required, just upload images and go.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/folio.ink.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Folio.ink, free fast and easy portfolios.&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://folio.ink/&quot;&gt;Folio.ink&lt;/a&gt; 为广告素材提供免费图片托管，它的创建是一种快速、有效的方式，可以在精美的演示文稿中共享一组图像。它是为完成这项工作而设计的，无需登录，只需上传即可，并且&lt;strong&gt;完全免费&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;Folio.ink 使用非常简单、方便：图片上传完毕（支持批量），即会生成&lt;strong&gt;在线链接&lt;/strong&gt;，您可以通过各种渠道，将其分享给他人。值得一提的是，Folio 支持各种设置，如展示过渡动画、何时过期、播放是否轮询、页面主题颜色、是否公开到作品集等，而且支持编辑、删除。于我而言，这是很棒的功能。有分享了两张图，感兴趣的朋友，可以&lt;a href=&quot;https://folio.ink/W6kojQ&quot;&gt;点击链接 🔗 查看&lt;/a&gt;，以感受 Folio 之设计。&lt;/p&gt;&lt;p&gt;Folio.ink 是安全的：用于托管数字作品集和艺术作品的干净简单的解决方案。每个作品集都有一个无法猜测的唯一 ID。作品集还可以通过密码保护增加安全性。&lt;/p&gt;&lt;p&gt;Folio.ink 适用于当今创意的数字投递产品组合：它旨在为创意人员提供一种创建作品集的方法，其中包含他们最佳作品的浓缩示例，针对不同的机会。一个连接创意人员并为他们提供支持他们忙碌工作的工具的微型投资组合平台。&lt;/p&gt;&lt;p&gt;公开分享您的创作，并从他人那里寻找灵感。从对当今世界各地的事件、文化和人们的新观点中获得启发。&lt;a href=&quot;https://nicelinks.site/redirect?url=https://folio.ink/explore&quot;&gt;Folio.ink 精选&lt;/a&gt;，支持您探索的公共作品集。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62bda70d0c61c703d774759b&quot;&gt;倾城之链 - Folio.ink, free fast and easy portfolios.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/IDE&quot;&gt;&lt;code&gt;IDE&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%A1%86%E6%9E%B6&quot;&gt;&lt;code&gt;框架&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E6%BA%90&quot;&gt;&lt;code&gt;开源&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;一款帮助你快速搭建本地和云端 IDE 的框架。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/opensumi.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - OpenSumi | OpenSumi 框架&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;： &lt;a href=&quot;https://nicelinks.site/redirect?url=https://opensumi.com/&quot;&gt;OpenSumi&lt;/a&gt;，一款帮助你快速搭建本地和云端 IDE 的框架。OpenSumi 框架，早期由阿里集团淘系工程团队及蚂蚁集团体验技术部、研发效能团队联合发起，共同研发的 IDE 标准化研发框架。它基于 TypeScript + React 进行编码，实现了包含资源管理器、编辑器、调试、Git 面板、搜索面板等核心功能模块，开发者只要基于起步项目进行简单配置，便可以快速地搭建属于自己的本地或云端 IDE 产品。的框架。OpenSumi 自身兼容 VS Code 插件生态（思考），主流 VS Code 插件，均可无缝在基于 OpenSumi 研发的产品中运行，同时，框架也为开发者提供多种低成本，高定制的视图定制能力，能满足 IDE 场景下绝大多数的视图定制场景。它具有以下能力特性：&lt;/p&gt;&lt;h3 id=&quot;轻松集成&quot;&gt;&lt;a href=&quot;#%E8%BD%BB%E6%9D%BE%E9%9B%86%E6%88%90&quot; aria-label=&quot;轻松集成 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;轻松集成&lt;/h3&gt;&lt;p&gt;提供面向容器场景、Electron 场景和纯前端场景的快速集成解决方案，助力业务快速落地。&lt;/p&gt;&lt;h3 id=&quot;高拓展性&quot;&gt;&lt;a href=&quot;#%E9%AB%98%E6%8B%93%E5%B1%95%E6%80%A7&quot; aria-label=&quot;高拓展性 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;高拓展性&lt;/h3&gt;&lt;p&gt;提供从 VS Code 插件、OpenSumi 插件到 OpenSumi 模块三层业务解决方案，完美支持业务定制需求。&lt;/p&gt;&lt;h3 id=&quot;ui-自定义&quot;&gt;&lt;a href=&quot;#ui-%E8%87%AA%E5%AE%9A%E4%B9%89&quot; aria-label=&quot;ui 自定义 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;UI 自定义&lt;/h3&gt;&lt;p&gt;提供可任意定制的布局系统，支持从简单的视图配置到布局模板研发的各类场景，支持从插件注入自定义视图。&lt;/p&gt;&lt;p&gt;除此之外，在该团队所写的推介文章中谈到，OpenSumi 是一款面向垂直领域，低门槛、高性能、高定制性的双端（Web 及 Electron）IDE 研发的框架。它的特点主要体现在下面几点内容：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;全面的视图定制能力&lt;/strong&gt;：OpenSumi 模块扩展 + OpenSumi 插件扩展 + VS Code 插件扩展；&lt;/li&gt;&lt;li&gt;&lt;strong&gt;丰富的垂直领域研发支撑经验&lt;/strong&gt;：小程序研发场景，云端一体化研发链路，纯前端搭建；&lt;/li&gt;&lt;li&gt;&lt;strong&gt;完整的 VS Code 的插件能力支持&lt;/strong&gt;：设计之初就是要兼容 VS Code 插件生态，并制定定期适配计划；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;与 VS Code 主要针对的 ToC 用户群不同， OpenSumi 与 &lt;a href=&quot;https://nicelinks.site/post/62bd55770c61c703d7747593&quot;&gt;Theia&lt;/a&gt; 类似，所针对的用户群是 ToB；当然，完全可以基于 &lt;a href=&quot;https://nicelinks.site/post/5af55777979f626ea3d37917&quot;&gt;Vs Code&lt;/a&gt; 二次开发，来定制属于 IDE，但门槛及成本相对较高。基于 &lt;code&gt;Theia&lt;/code&gt; 或阿里所开源的 &lt;code&gt;OpenSumi&lt;/code&gt;，对那些需要通过 IDE 框架，搭建自有的 CloudIDE / 本地 IDE 产品而又没有充足技术研发能力的中小企业，是一个简单、便捷的开发选项。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62bd60520c61c703d7747595&quot;&gt;倾城之链 - OpenSumi | OpenSumi 框架&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/IDE&quot;&gt;&lt;code&gt;IDE&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E6%BA%90&quot;&gt;&lt;code&gt;开源&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BC%96%E8%BE%91%E5%99%A8&quot;&gt;&lt;code&gt;编辑器&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Theia is an open-source cloud   desktop IDE framework implemented in TypeScript.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/theia-ide.org.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Theia - Cloud and Desktop IDE Platform&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://theia-ide.org/&quot;&gt;Theia&lt;/a&gt;，开放、灵活、可扩展的云和桌面 IDE 平台。它是由 Eclipse 基金会，基于现代 Web 技术，打造的云端及桌面 IDE 框架，该产品完全开源的，由多元化开发者社区进行开发。Theia 具有以下功能特征：&lt;/p&gt;&lt;h3 id=&quot;云和桌面&quot;&gt;&lt;a href=&quot;#%E4%BA%91%E5%92%8C%E6%A1%8C%E9%9D%A2&quot; aria-label=&quot;云和桌面 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;云和桌面&lt;/h3&gt;&lt;p&gt;不确定您是否需要网络版或桌面版或两者兼而有之？使用 Theia，您可以开发一个 IDE 并在浏览器中运行它，或者作为本地桌面应用程序从单一来源运行。&lt;/p&gt;&lt;h3 id=&quot;可扩展&quot;&gt;&lt;a href=&quot;#%E5%8F%AF%E6%89%A9%E5%B1%95&quot; aria-label=&quot;可扩展 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;可扩展&lt;/h3&gt;&lt;p&gt;Theia 以模块化方式设计，允许扩展者和采用者自定义和扩展各个方面。这远远超出了“仅仅添加扩展”，因为 Eclipse Theia 允许您构建完全定制的或白标产品。&lt;/p&gt;&lt;h3 id=&quot;供应商中立&quot;&gt;&lt;a href=&quot;#%E4%BE%9B%E5%BA%94%E5%95%86%E4%B8%AD%E7%AB%8B&quot; aria-label=&quot;供应商中立 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;供应商中立&lt;/h3&gt;&lt;p&gt;Theia 是真正的供应商中立，由多元化社区开发。与其他“开源”项目不同，Theia 实际上托管在开源基金会，保护它免受违背社区利益的单一供应商决策的影响。&lt;/p&gt;&lt;h3 id=&quot;现代科技&quot;&gt;&lt;a href=&quot;#%E7%8E%B0%E4%BB%A3%E7%A7%91%E6%8A%80&quot; aria-label=&quot;现代科技 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;现代科技&lt;/h3&gt;&lt;p&gt;Theia 基于最先进的基于 Web 的技术堆栈。它通过 LSP 和 DAP 提供语言支持。此外，它可以托管 VS Code 扩展并提供完整的终端访问。&lt;/p&gt;&lt;p&gt;Theia 团队，相信 VS Code 是一款出色的产品。因此， Theia 包含许多设计决策，甚至直接支持 VS Code 扩展。在 Theia 官网，列出了与 VS Code 最显著的区别：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Theia 的架构更加模块化，允许更多的定制；&lt;/li&gt;&lt;li&gt;Theia 从一开始就设计为在桌面和云上运行；&lt;/li&gt;&lt;li&gt;Theia 是在供应商中立的开源基金会下开发的。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Theia 是一个可扩展的平台，用于使用最先进的 Web 技术，开发成熟的多语言云和桌面 IDE 类产品。从外界视角来看，这是 Theia 与 Vs Code 最主要的不同：前者主要为 ToB 用户，后者则致力于 ToC 用户。当然，完全可以基于 &lt;a href=&quot;https://nicelinks.site/post/5af55777979f626ea3d37917&quot;&gt;Vs Code&lt;/a&gt; 二次开发，来定制属于 IDE，但门槛及成本相对较高。基于 Theia 或阿里所开源的 OpenSumi，对那些需要通过 IDE 框架，搭建自有的 CloudIDE / 本地 IDE 产品而又没有充足技术研发能力的中小企业，是一个简单、便捷的开发选项。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62bd55770c61c703d7747593&quot;&gt;倾城之链 - Theia - Cloud and Desktop IDE Platform&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E8%BF%90%E7%BB%B4&quot;&gt;&lt;code&gt;运维&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/npm&quot;&gt;&lt;code&gt;npm&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E6%BA%90&quot;&gt;&lt;code&gt;开源&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Build Battle-Hardened Node.js Applications.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/pm2.io.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - PM2 - Home&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;： &lt;a href=&quot;https://nicelinks.site/redirect?url=https://pm2.io/&quot;&gt;pm2&lt;/a&gt; ，是具有内置&lt;strong&gt;负载均衡器&lt;/strong&gt;的 Node.js 应用程序的生产流程管理器。您可以基于它，来部署、管理、维护您的 Node.js 应用程序，并提高其性能。它允许您使应用程序永远保持活动状态，在不停机的情况下重新加载它们，并促进常见的系统管理任务。pm2 适用于 Linux（稳定）和 macOS（稳定）和 Windows（稳定）。从 Node.js 12.X 开始支持所有 Node.js 版本。在生产模式下，安启动应用程序非常简单：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 安装 pm2
npm install pm2 -g

# 启动应用
pm2 start app.js
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;您可以像这样，启动任何应用程序（Node.js、Python、Ruby、$PATH 中的二进制文件）；应用程序启动后，您可以通过命令行，轻松管理它们：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 列出所有正在运行的应用程序
pm2 list

# 运行如下命令，管理应用程序
pm2 stop     &amp;lt;app_name|namespace|id|&#x27;all&#x27;|json_conf&amp;gt;
pm2 restart  &amp;lt;app_name|namespace|id|&#x27;all&#x27;|json_conf&amp;gt;
pm2 delete   &amp;lt;app_name|namespace|id|&#x27;all&#x27;|json_conf&amp;gt;

# 查看监控日志、自定义指标、应用程序信息
pm2 monit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了启动、持久化、管理应用之外，pm2 还具有非常多功能特性：&lt;/p&gt;&lt;h3 id=&quot;集群模式nodejs-负载平衡和零停机重新加载&quot;&gt;&lt;a href=&quot;#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8Fnodejs-%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E5%92%8C%E9%9B%B6%E5%81%9C%E6%9C%BA%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD&quot; aria-label=&quot;集群模式nodejs 负载平衡和零停机重新加载 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;集群模式：Node.js 负载平衡和零停机重新加载&lt;/h3&gt;&lt;p&gt;Cluster 模式是启动 Node.js 应用程序时的一种特殊模式，它启动多个进程并在它们之间平衡 HTTP/TCP/UDP 查询。这提高了整体性能（在 16 核机器上提高了 10 倍）和可靠性（在出现未处理错误的情况下更快的套接字重新平衡）。在集群模式下启动一个 Node.js 应用程序，它将利用所有可用的 CPU。&lt;/p&gt;&lt;h3 id=&quot;维护升级不需要停机&quot;&gt;&lt;a href=&quot;#%E7%BB%B4%E6%8A%A4%E5%8D%87%E7%BA%A7%E4%B8%8D%E9%9C%80%E8%A6%81%E5%81%9C%E6%9C%BA&quot; aria-label=&quot;维护升级不需要停机 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;维护升级，不需要停机&lt;/h3&gt;&lt;p&gt;Hot Reload 允许在不停机的情况下更新应用程序。&lt;/p&gt;&lt;h3 id=&quot;基于终端的监控&quot;&gt;&lt;a href=&quot;#%E5%9F%BA%E4%BA%8E%E7%BB%88%E7%AB%AF%E7%9A%84%E7%9B%91%E6%8E%A7&quot; aria-label=&quot;基于终端的监控 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;基于终端的监控&lt;/h3&gt;&lt;p&gt;监控直接从命令行启动的所有进程：&lt;code&gt;pm2 monit&lt;/code&gt;。&lt;/p&gt;&lt;h3 id=&quot;容器支持&quot;&gt;&lt;a href=&quot;#%E5%AE%B9%E5%99%A8%E6%94%AF%E6%8C%81&quot; aria-label=&quot;容器支持 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;容器支持&lt;/h3&gt;&lt;p&gt;使用名为 &lt;code&gt;pm2-runtime&lt;/code&gt; 的 Node 替换命令，在强化的生产环境中运行您的 Node.js 应用程序。可以无缝使用它：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;RUN npm install pm2 -g
CMD [ &quot;pm2-runtime&quot;, &quot;npm&quot;, &quot;--&quot;, &quot;start&quot; ]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;启动脚本生成&quot;&gt;&lt;a href=&quot;#%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90&quot; aria-label=&quot;启动脚本生成 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;启动脚本生成&lt;/h3&gt;&lt;p&gt;PM2 可以生成和配置启动脚本，以在每次服务器重新启动时，保持 PM2 和您的进程处于活动状态。&lt;/p&gt;&lt;p&gt;值得一提的是，pm2 在 github 开源，免费可用；如果您使用 PM2 管理应用程序，PM2+（收费） 可以轻松监控和管理跨服务器的应用程序。当然，您也可以基于 &lt;a href=&quot;https://nicelinks.site/post/5b7036890f8719053c094d68&quot;&gt;Docker&lt;/a&gt; 或 &lt;a href=&quot;https://nicelinks.site/post/5b2cad0a34c03342fda0f37e&quot;&gt;K8S&lt;/a&gt; 来部署您的服务，相比之下，更倾心基于 pm2 这种方案。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62bc60e90c61c703d7747590&quot;&gt;倾城之链 - PM2 - Home&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Github&quot;&gt;&lt;code&gt;Github&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E6%BA%90&quot;&gt;&lt;code&gt;开源&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%8F%AF%E8%A7%86%E5%8C%96&quot;&gt;&lt;code&gt;可视化&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;View and compare GitHub star history of open source projects&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/star-history.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - GitHub Star History&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://star-history.com&quot;&gt;GitHub Star History&lt;/a&gt;，用来可视化查看 &lt;a href=&quot;https://nicelinks.site/tags/Github&quot;&gt;GitHub&lt;/a&gt; 仓库 Star 历史图。您可以基于此工具，将生成的 &lt;strong&gt;LIVE 图表&lt;/strong&gt;，以非常便捷的方式，添加到您的 GitHub README，从而展示给访问者。它具有以下功能特征：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;独特的素描 xkcd 感觉图；&lt;/li&gt;&lt;li&gt;一键生成高品质图表图片；&lt;/li&gt;&lt;li&gt;支持基于日期或时间线的多种图表查看模式；&lt;/li&gt;&lt;li&gt;将实时图表嵌入 GitHub 自述文件或其他网站（如我们在顶部嵌入的那个）；&lt;/li&gt;&lt;li&gt;以及各种有用的功能：&lt;ul&gt;&lt;li&gt;切换回购可见性；&lt;/li&gt;&lt;li&gt;输入 repo 的快捷方式；&lt;/li&gt;&lt;li&gt;在 Twitter 上快速分享；&lt;/li&gt;&lt;li&gt;支持输入多个 repos；&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;您可以下载该图表（图片或 &lt;code&gt;CSV&lt;/code&gt;），还可以基于 Markdown 格式，嵌入实时图表在您的网站或 GitHub README；此外，它提供了 Chrome 免费扩展。值得一提的是，&lt;a href=&quot;https://nicelinks.site/redirect?url=https://star-history.com&quot;&gt;star-history&lt;/a&gt; 是用现代技术栈构建（&lt;a href=&quot;https://nicelinks.site/post/5b1a221c0526c920d6dfaada&quot;&gt;Vue&lt;/a&gt; + &lt;a href=&quot;https://nicelinks.site/post/6010e1b10c71de1fb957b64e&quot;&gt;Vite&lt;/a&gt; + &lt;a href=&quot;https://nicelinks.site/post/5fd20cb4c06d6302c1907ec7&quot;&gt;TailwindCSS&lt;/a&gt;，&lt;a href=&quot;https://nicelinks.site/post/62989af00f40a860b1599de2&quot;&gt;pnpm&lt;/a&gt;），该项目在 Github 开源，感兴趣的朋友可以了解下。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62bb3c660c61c703d774758e&quot;&gt;倾城之链 - GitHub Star History&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Linux&quot;&gt;&lt;code&gt;Linux&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B7%A5%E5%85%B7&quot;&gt;&lt;code&gt;工具&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%BD%AF%E4%BB%B6&quot;&gt;&lt;code&gt;软件&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Darling — macOS translation layer for Linux&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.darlinghq.org.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Darling |   run macOS software on Linux&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.darlinghq.org/&quot;&gt;Darling&lt;/a&gt; 是一个翻译层，可让您在 &lt;a href=&quot;https://nicelinks.site/tags/Linux&quot;&gt;Linux&lt;/a&gt; 上运行 macOS 软件。它具有以下功能特征：&lt;/p&gt;&lt;h3 id=&quot;快速的&quot;&gt;&lt;a href=&quot;#%E5%BF%AB%E9%80%9F%E7%9A%84&quot; aria-label=&quot;快速的 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;快速的&lt;/h3&gt;&lt;p&gt;Darling 直接运行 macOS 软件，无需使用硬件模拟器。&lt;/p&gt;&lt;h3 id=&quot;自由的&quot;&gt;&lt;a href=&quot;#%E8%87%AA%E7%94%B1%E7%9A%84&quot; aria-label=&quot;自由的 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;自由的&lt;/h3&gt;&lt;p&gt;与 Linux 一样，Darling 是免费的开源软件。 它在 GitHub 上公开开发，并根据 GNU GPL 许可证版本 3 分发。&lt;/p&gt;&lt;h3 id=&quot;兼容的&quot;&gt;&lt;a href=&quot;#%E5%85%BC%E5%AE%B9%E7%9A%84&quot; aria-label=&quot;兼容的 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;兼容的&lt;/h3&gt;&lt;p&gt;Darling 实现了一个完整的达尔文环境。Mach、dyld、launchd — 应有尽有。&lt;/p&gt;&lt;h3 id=&quot;便于使用&quot;&gt;&lt;a href=&quot;#%E4%BE%BF%E4%BA%8E%E4%BD%BF%E7%94%A8&quot; aria-label=&quot;便于使用 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;便于使用&lt;/h3&gt;&lt;p&gt;Darling 为您完成大部分设置。坐下来享受使用您最喜爱的软件的乐趣。&lt;/p&gt;&lt;h3 id=&quot;原生的&quot;&gt;&lt;a href=&quot;#%E5%8E%9F%E7%94%9F%E7%9A%84&quot; aria-label=&quot;原生的 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;原生的&lt;/h3&gt;&lt;p&gt;该团队的目标是：将在 Darling 下运行的应用程序完全集成到 Linux 桌面体验中，使它们看起来、感觉和行为都像原生 Linux 应用程序一样。&lt;/p&gt;&lt;p&gt;Darling，适用于 Linux 的 Darwin/macOS 仿真层；这个名字是“Darwin”和“Linux”的组合。Darwin 是 macOS 和 iOS 所基于的核心操作系统。该项目在 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://github.com/darlinghq/darling&quot;&gt;Github 开源&lt;/a&gt;，感兴趣的朋友可深入了解。值得一提的是，Wine 可以让你在 Linux 上运行 Windows 软件，而 Darling 也可以为 macOS 软件做同样的事情。另一个类似的项目是 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://anbox.io/&quot;&gt;Anbox&lt;/a&gt;，用于 Android 应用程序。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62b849413cc95e702564e0d5&quot;&gt;倾城之链 - Darling | run macOS software on Linux&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;本期文末寄语&quot;&gt;&lt;a href=&quot;#%E6%9C%AC%E6%9C%9F%E6%96%87%E6%9C%AB%E5%AF%84%E8%AF%AD&quot; aria-label=&quot;本期文末寄语 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;本期文末寄语&lt;/h2&gt;&lt;p&gt;致虚极，守静笃；万物并作，吾以观复。夫物芸芸，各复归其根。归根曰静，静曰复命。复命曰常，知常曰明。不知常，妄作凶。知常容，容乃公，公乃全，全乃天，天乃道，道乃久，没身不殆。── 春秋末期人 · 老子李耳《道德经》第十六章&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;&lt;h3 id=&quot;您可能感兴趣的文章&quot;&gt;&lt;a href=&quot;#%E6%82%A8%E5%8F%AF%E8%83%BD%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0&quot; aria-label=&quot;您可能感兴趣的文章 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;您可能感兴趣的文章&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>14c897271e5770c3b838c143029e610d</guid>
<title>推荐一款 JSON 可视化工具神器！</title>
<link>https://toutiao.io/k/rsgjy5z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-tool=&quot;mdnice编辑器&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25380710659898476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/R3InYSAIZkEnEAbic5bVLStf0msXUiaOWI6U6wYlLEibyPQxQ9JDv9AFdpbZZxnR46bmx8XHhUqaSm7XRnl7ib3cvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JSON Hero 是一个简单实用的 JSON 工具，通过简介美观的 UI 及增强的额外功能，使得阅读和理解 JSON 文档变得更容易、直观。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;支持多种视图以便查看 JSON：列视图、树视图、JSON 视图等 列视图是受 macOS Finder 启发创建的一种浏览 JSON 文档的新方法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6683673469387755&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/R3InYSAIZkEnEAbic5bVLStf0msXUiaOWI6RJvKMtaMfLXcEJU3HzegVXYObR5HMQFMicNKvZ2GRdTJHeFW15xZuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;784&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;项目地址：&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;https://github.com/jsonhero-io/jsonhero-web&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;安装&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要在本地运行 JSON Hero，首先 clone 源代码，并安装相关依赖项：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;git &lt;span&gt;clone&lt;/span&gt; https://github.com/jsonhero-io/jsonhero-web.git&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; jsonhero-web&lt;br/&gt;npm install&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后运行以下命令启动，打开 &lt;/span&gt;&lt;code&gt;&lt;span&gt;http://localhost:8787&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 即可使用：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;npm start&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前往 &lt;/span&gt;&lt;code&gt;&lt;span&gt;https://jsonhero.io/&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 并将 JSON 文件拖拽到网站上，或在提供的表单中粘贴 JSON 或 JSON url&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内容预览&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JSON Hero 会自动推断字符串的内容，并对选择的值提供有用的预览和属性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;日期和时间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6632258064516129&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/R3InYSAIZkEnEAbic5bVLStf0msXUiaOWIicTgZvWjXDTPqKg2j3HFWiaqt4HeMgqYwe8Ru1ee6ucMakfF8coRP9eg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;775&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;图片网址&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7235142118863049&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/R3InYSAIZkEnEAbic5bVLStf0msXUiaOWIBsOvLw93Mdfv5C4O7jXbulWDCCM87HibzNDzWtOb5TTku0SmLshfTvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;网站网址&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6555269922879178&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/R3InYSAIZkEnEAbic5bVLStf0msXUiaOWItpv5YQyrA2yibzVyibiagNmP7dvicdtjhtbkVwYwXqTdM0X7NZ310nwBgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;JSON URL&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6662337662337663&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/R3InYSAIZkEnEAbic5bVLStf0msXUiaOWIlnsbS00XsVnMfsyibLRUuKRqPCSMmcKxicibFdghy4ChV7ic920Xxsj1Bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;770&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;树状视图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个也是用的最多的，树状图结构可以很清晰的展示，看一组图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6438213914849429&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuclJXaGAtE9mNoQzK8A2sV1SqbKDAKT331N9griaeOsMG3FT4bMWBmkq1HQ1kQf0xV5O2oPkde1GPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;963&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同时支持对JSON数据中的数据进行搜索：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-ratio=&quot;0.6447124304267161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/eQPyBffYbuclJXaGAtE9mNoQzK8A2sV1wYJPTEw6PxNPnMQvJJiaxOBYHH2MaawIzQ5KhvDyhVjEs8217DeThEA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1078&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;重点来了！&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当你完成数据编辑或者审核后，需要分享给前端，不必复制全部数据，只需要生成指定链接即可，这个很方便。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48802083333333335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuclJXaGAtE9mNoQzK8A2sV1UPXElia3lBfnibibBAsFib6bEl0pBicP75mBmkT9z52SG55F1osLSLwN0Pg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整体来讲，JSON Hero 支持多种试图查看JSON数据，同时支持VS Code 等扩展，相信对经常处理JSON的小伙伴来说，是一款很给力的工具。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;我们创建了一个高质量的技术交流群，与优秀的人在一起，自己也会优秀起来，赶紧&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxODcyNjEzNQ==&amp;amp;mid=2247554212&amp;amp;idx=4&amp;amp;sn=609c66e339d7345ab00205da2abb8f9e&amp;amp;chksm=9bd3b93caca4302ad7fd37133fb45f526d4268914a5f65839285adbd5dc7c77b057168f4a8d5&amp;amp;scene=21&amp;amp;token=2077530613&amp;amp;lang=zh_CN#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;点击加群&lt;/a&gt;，享受一起成长的快乐。另外，如果你最近想跳槽的话，年前我花了2周时间收集了一波大厂面经，节后准备跳槽的可以&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxODcyNjEzNQ==&amp;amp;mid=2247553608&amp;amp;idx=4&amp;amp;sn=990e8a0f112e82cbc8051c4e50de32a6&amp;amp;chksm=9bd3bfd0aca436c6f2d2921212ecfee430b9f4bc549e6eaf823786cae54e0bb1b5bd75a2f94d&amp;amp;scene=21&amp;amp;token=2077530613&amp;amp;lang=zh_CN#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;点击这里领取&lt;/a&gt;！&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;··································&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;你好，我是程序猿DD，10年开发老司机、阿里云MVP、腾讯云TVP、出过书创过业、国企4年互联网6年&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;从普通开发到架构师、再到合伙人。一路过来，给我最深的感受就是一定要不断学习并关注前沿。只要你能坚持下来，多思考、少抱怨、勤动手，就很容易实现弯道超车！&lt;/span&gt;&lt;span&gt;所以，不要问我现在干什么是否来得及。如果你看好一个事情，一定是坚持了才能看到希望，而不是看到希望才去坚持。相信我，只要坚持下来，你一定比现在更好！&lt;/span&gt;&lt;span&gt;如果你还没什么方向，可以先关注我，&lt;/span&gt;&lt;span&gt;这里会经常分享一些前沿资讯，帮你积累弯道超车的资本。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxODcyNjEzNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/R3InYSAIZkFgVUuoib3ib7u92WFR247awDicxibIsB4H6gy610wyzicNVf03JIPC63Tu4lHV3iaAc4vDiczQr57kJDJew/0?wx_fmt=png&quot; data-nickname=&quot;程序猿DD&quot; data-alias=&quot;didispace&quot; data-signature=&quot;关注最前沿的技术资讯，为弯道超车做好准备！&quot; data-from=&quot;2&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzU5Mjc5NTIzMA==&amp;amp;mid=2247487180&amp;amp;idx=1&amp;amp;sn=b26c66a8c9f7aa50b16286fab1f546e3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点击领取2022最新10000T学习资料&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;点击领取2022最新&lt;strong&gt;10000T&lt;/strong&gt;学习资料&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8933a836ee81d64f72d3450042f84999</guid>
<title>go-zero微服务实战系列（八、如何处理每秒上万次的下单请求）</title>
<link>https://toutiao.io/k/qz3rxp6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前几篇的文章中，我们花了很大的篇幅介绍如何利用缓存优化系统的读性能，究其原因在于我们的产品大多是一个读多写少的场景，尤其是在产品的初期，可能多数的用户只是过来查看商品，真正下单的用户非常少。但随着业务的发展，我们就会遇到一些高并发写请求的场景，秒杀抢购就是最典型的高并发写场景。在秒杀抢购开始后用户就会疯狂的刷新页面让自己尽早的看到商品，所以秒杀场景同时也是高并发读场景。那么应对高并发读写场景我们怎么进行优化呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;处理热点数据&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;秒杀的数据通常都是热点数据，处理热点数据一般有几种思路：一是优化，二是限制，三是隔离。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;优化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化热点数据最有效的办法就是缓存热点数据，我们可以把热点数据缓存到内存缓存中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;限制&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限制更多的是一种保护机制，当秒杀开始后用户就会不断地刷新页面获取数据，这时候我们可以限制单用户的请求次数，比如一秒钟只能请求一次，超过限制直接返回错误，返回的错误尽量对用户友好，比如 &quot;店小二正在忙&quot; 等友好提示。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;隔离&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;秒杀系统设计的第一个原则就是将这种热点数据隔离出来，不要让1%的请求影响到另外的99%，隔离出来后也更方便对这1%的请求做针对性的优化。具体到实现上，我们需要做服务隔离，即秒杀功能独立为一个服务，通知要做数据隔离，秒杀所调用的大部分是热点数据，我们需要使用单独的Redis集群和单独的Mysql，目的也是不想让1%的数据有机会影响99%的数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;流量削峰&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对秒杀场景，它的特点是在秒杀开始那一刹那瞬间涌入大量的请求，这就会导致一个特别高的流量峰值。但最终能够抢到商品的人数是固定的，也就是不管是100人还是10000000人发起请求的结果都是一样的，并发度越高，无效的请求也就越多。但是从业务角度来说，秒杀活动是希望有更多的人来参与的，也就是秒杀开始的时候希望有更多的人来刷新页面，但是真正开始下单时，请求并不是越多越好。因此我们可以设计一些规则，让并发请求更多的延缓，甚至可以过滤掉一些无效的请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;削峰本质上是要更多的延缓用户请求的发出，以便减少和过滤掉一些无效的请求，它遵从请求数要尽量少的原则。我们最容易想到的解决方案是用消息队列来缓冲瞬时的流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑的将消息推送出去，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5710344827586207&quot; data-type=&quot;png&quot; data-w=&quot;1450&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg0XYBQg88KXMU6QB5gvYUugicBe7JyM4Tas7eFFNIqR3JNmHK6eucaosv16rdJB5dJgIibUguFicz2Gg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用消息队列异步处理后，那么秒杀的结果是不太好同步返回的，所以我们的思路是当用户发起秒杀请求后，同步返回响应用户 &quot;秒杀结果正在计算中...&quot; 的提示信息，当计算完之后我们如何返回结果给用户呢？其实也是有多种方案的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一是在页面中采用轮询的方式定时主动去服务端查询结果，例如每秒请求一次服务端看看有没有处理结果，这种方式的缺点是服务端的请求数会增加不少。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;二是主动push的方式，这种就要求服务端和客户端保持长连接了，服务端处理完请求后主动push给客户端，这种方式的缺点是服务端的连接数会比较多。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个问题就是如果异步的请求失败了该怎么办？我觉得对于秒杀场景来说，失败了就直接丢弃就好了，最坏的结果就是这个用户没有抢到而已。如果想要尽量的保证公平的话，那么失败了以后也可以做重试。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何保证消息只被消费一次&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka是能够保证&quot;At Least Once&quot;的机制的，即消息不会丢失，但有可能会导致重复消费，消息一旦被重复消费那么就会造成业务逻辑处理的错误，那么我们如何避免消息的重复消费呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们只要保证即使消费到了重复的消息，从消费的最终结果来看和只消费一次的结果等同就好了，也就是保证在消息的生产和消费的过程是幂等的。什么是幂等呢？如果我们消费一条消息的时候，要给现有的库存数量减1，那么如果消费两条相同的消息就给库存的数量减2，这就不是幂等的。而如果消费一条消息后处理逻辑是将库存的数量设置为0，或者是如果当前库存的数量为10时则减1，这样在消费多条消息时所得到的结果就是相同的，这就是幂等的。说白了就是一件事无论你做多少次和做一次产生的结果都是一样的，那么这就是幂等性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在消息被消费后，把唯一id存储在数据库中，这里的唯一id可以使用用户id和商品id的组合，在处理下一条消息之前先从数据库中查询这个id看是否被消费过，如果消费过就放弃。伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;isConsume := getByID(id)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; isConsume {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;  &lt;br/&gt;} &lt;br/&gt;process(message)&lt;br/&gt;save(id)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种方式是通过数据库中的唯一索引来保证幂等性，不过这个要看具体的业务，在这里不再赘述。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码实现&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个秒杀流程图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3975&quot; data-type=&quot;png&quot; data-w=&quot;2400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg0XYBQg88KXMU6QB5gvYUugkgSfyjrfxrU3ejqEMibu85J6KsqTbAoUq19F5JeBFOp9ibqxJQXFES7A/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用kafka作为消息队列，所以要先在本地安装kafka，我使用的是mac可以用homebrew直接安装，kafka依赖zookeeper也会自动安装&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;brew install kafka&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完后通过brew services start启动zookeeper和kafka，kafka默认侦听在9092端口&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;brew services start zookeeper&lt;br/&gt;&lt;br/&gt;brew services start kafka&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;seckill-rpc的SeckillOrder方法实现秒杀逻辑，我们先限制用户的请求次数，比如限制用户每秒只能请求一次，这里使用go-zero提供的PeriodLimit功能实现，如果超出限制直接返回&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;code, _ := l.limiter.Take(strconv.FormatInt(in.UserId, &lt;span&gt;10&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; code == limit.OverQuota {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, status.Errorf(codes.OutOfRange, &lt;span&gt;&quot;Number of requests exceeded the limit&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着查看当前抢购商品的库存，如果库存不足就直接返回，如果库存足够的话则认为可以进入下单流程，发消息到kafka，这里kafka使用go-zero提供的kq库，非常简单易用，为秒杀新建一个Topic，配置初始化和逻辑如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;Kafka:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;Addrs:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;:9092&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;SeckillTopic:&lt;/span&gt; &lt;span&gt;seckill-topic&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;KafkaPusher: kq.NewPusher(c.Kafka.Addrs, c.Kafka.SeckillTopic)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;p, err := l.svcCtx.ProductRPC.Product(l.ctx, &amp;amp;product.ProductItemRequest{ProductId: in.ProductId})&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; p.Stock &amp;lt;= &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, status.Errorf(codes.OutOfRange, &lt;span&gt;&quot;Insufficient stock&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;kd, err := json.Marshal(&amp;amp;KafkaData{Uid: in.UserId, Pid: in.ProductId})&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err := l.svcCtx.KafkaPusher.Push(&lt;span&gt;string&lt;/span&gt;(kd)); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;seckill-rmq消费seckill-rpc生产的数据进行下单操作，我们新建seckill-rmq服务，结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;tree ./rmq&lt;br/&gt;&lt;br/&gt;./rmq&lt;br/&gt;├── etc&lt;br/&gt;│   └── seckill.yaml&lt;br/&gt;├── internal&lt;br/&gt;│   ├── config&lt;br/&gt;│   │   └── config.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;│   └── service&lt;br/&gt;│       └── service.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;└── seckill.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt; directories, &lt;span&gt;4&lt;/span&gt; files&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依然是使用kq初始化启动服务，这里我们需要注册一个ConsumeHand方法，该方法用以消费kafka数据&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;srv := service.NewService(c)&lt;br/&gt;queue := kq.MustNewQueue(c.Kafka, kq.WithHandle(srv.Consume))&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; queue.Stop()&lt;br/&gt;&lt;br/&gt;fmt.Println(&lt;span&gt;&quot;seckill started!!!&quot;&lt;/span&gt;)&lt;br/&gt;queue.Start()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Consume方法中，消费到数据后先反序列化，然后调用product-rpc查看当前商品的库存，如果库存足够的话我们认为可以下单，调用order-rpc进行创建订单操作，最后再更新库存&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *Service)&lt;/span&gt; &lt;span&gt;Consume&lt;/span&gt;&lt;span&gt;(_ &lt;span&gt;string&lt;/span&gt;, value &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  logx.Infof(&lt;span&gt;&quot;Consume value: %s\n&quot;&lt;/span&gt;, value)&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; data KafkaData&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err := json.Unmarshal([]&lt;span&gt;byte&lt;/span&gt;(value), &amp;amp;data); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  }&lt;br/&gt;  p, err := s.ProductRPC.Product(context.Background(), &amp;amp;product.ProductItemRequest{ProductId: data.Pid})&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; p.Stock &amp;lt;= &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  _, err = s.OrderRPC.CreateOrder(context.Background(), &amp;amp;order.CreateOrderRequest{Uid: data.Uid, Pid: data.Pid})&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    logx.Errorf(&lt;span&gt;&quot;CreateOrder uid: %d pid: %d error: %v&quot;&lt;/span&gt;, data.Uid, data.Pid, err)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  }&lt;br/&gt;  _, err = s.ProductRPC.UpdateProductStock(context.Background(), &amp;amp;product.UpdateProductStockRequest{ProductId: data.Pid, Num: &lt;span&gt;1&lt;/span&gt;})&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    logx.Errorf(&lt;span&gt;&quot;UpdateProductStock uid: %d pid: %d error: %v&quot;&lt;/span&gt;, data.Uid, data.Pid, err)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// TODO notify user of successful order placement&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建订单过程中涉及到两张表orders和orderitem，所以我们要使用本地事务进行插入，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *customOrdersModel)&lt;/span&gt; &lt;span&gt;CreateOrder&lt;/span&gt;&lt;span&gt;(ctx context.Context, oid &lt;span&gt;string&lt;/span&gt;, uid, pid &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  _, err := m.ExecCtx(ctx, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(ctx context.Context, conn sqlx.SqlConn)&lt;/span&gt; &lt;span&gt;(sql.Result, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    err := conn.TransactCtx(ctx, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(ctx context.Context, session sqlx.Session)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;      _, err := session.ExecCtx(ctx, &lt;span&gt;&quot;INSERT INTO orders(id, userid) VALUES(?,?)&quot;&lt;/span&gt;, oid, uid)&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;      }&lt;br/&gt;      _, err = session.ExecCtx(ctx, &lt;span&gt;&quot;INSERT INTO orderitem(orderid, userid, proid) VALUES(?,?,?)&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, uid, pid)&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;    })&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订单号生成逻辑如下，这里使用时间加上自增数进行订单生成&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; num &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;genOrderID&lt;/span&gt;&lt;span&gt;(t time.Time)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  s := t.Format(&lt;span&gt;&quot;20060102150405&quot;&lt;/span&gt;)&lt;br/&gt;  m := t.UnixNano()/&lt;span&gt;1e6&lt;/span&gt; - t.UnixNano()/&lt;span&gt;1e9&lt;/span&gt;*&lt;span&gt;1e3&lt;/span&gt;&lt;br/&gt;  ms := sup(m, &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;  p := os.Getpid() % &lt;span&gt;1000&lt;/span&gt;&lt;br/&gt;  ps := sup(&lt;span&gt;int64&lt;/span&gt;(p), &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;  i := atomic.AddInt64(&amp;amp;num, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  r := i % &lt;span&gt;10000&lt;/span&gt;&lt;br/&gt;  rs := sup(r, &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;  n := fmt.Sprintf(&lt;span&gt;&quot;%s%s%s%s&quot;&lt;/span&gt;, s, ms, ps, rs)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; n&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sup&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int64&lt;/span&gt;, n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  m := fmt.Sprintf(&lt;span&gt;&quot;%d&quot;&lt;/span&gt;, i)&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(m) &amp;lt; n {&lt;br/&gt;    m = fmt.Sprintf(&lt;span&gt;&quot;0%s&quot;&lt;/span&gt;, m)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; m&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后分别启动product-rpc、order-rpc、seckill-rpc和seckill-rmq服务还有zookeeper、kafka、mysql和redis，启动后我们调用seckill-rpc进行秒杀下单&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;grpcurl -plaintext -d &#x27;{&quot;user_id&quot;: 111, &quot;product_id&quot;: 10}&#x27; 127.0.0.1:9889 seckill.Seckill.SeckillOrder&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在seckill-rmq中打印了消费记录，输出如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;span&gt;&quot;@timestamp&quot;&lt;/span&gt;:&lt;span&gt;&quot;2022-06-26T10:11:42.997+08:00&quot;&lt;/span&gt;,&lt;span&gt;&quot;caller&quot;&lt;/span&gt;:&lt;span&gt;&quot;service/service.go:35&quot;&lt;/span&gt;,&lt;span&gt;&quot;content&quot;&lt;/span&gt;:&lt;span&gt;&quot;Consume value: {\&quot;uid\&quot;:111,\&quot;pid\&quot;:10}\n&quot;&lt;/span&gt;,&lt;span&gt;&quot;level&quot;&lt;/span&gt;:&lt;span&gt;&quot;info&quot;&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候查看orders表中已经创建了订单，同时商品库存减一&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13726993865030676&quot; data-type=&quot;png&quot; data-w=&quot;2608&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg0XYBQg88KXMU6QB5gvYUugpRWNCPictlNEBzGanMtmxtVt7HGkmic9bVoj2E4WwGWy6MSRAQ2ULviag/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结束语&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质上秒杀是一个高并发读和高并发写的场景，上面我们介绍了秒杀的注意事项以及优化点，我们这个秒杀场景相对来说比较简单，但其实也没有一个通用的秒杀的框架，我们需要根据实际的业务场景进行优化，不同量级的请求优化的手段也不尽相同。这里我们只展示了服务端的相关优化，但对于秒杀场景来说整个请求链路都是需要优化的，比如对于静态数据我们可以使用CDN做加速，为了防止流量洪峰我们可以在前端设置答题功能等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望本篇文章对你有所帮助，谢谢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;每周一、周四更新&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;代码仓库: https://github.com/zhoushuguang/lebron&lt;/em&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;项目地址&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/zeromicro/go-zero&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎使用 &lt;code&gt;go-zero&lt;/code&gt; 并 &lt;strong&gt;star&lt;/strong&gt; 支持我们！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;微信交流群&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注『&lt;strong&gt;微服务实践&lt;/strong&gt;』公众号并点击 &lt;strong&gt;交流群&lt;/strong&gt; 获取社区群二维码。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2ODU1MTI0OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg0AVP4WUKYKGFYXampCduKtGgGQgTibaEGvORjtq7icd3EOiaSMb6LeZY2k77dJFOibf914CUs3JTwMLA/0?wx_fmt=png&quot; data-nickname=&quot;微服务实践&quot; data-alias=&quot;zeromicro&quot; data-signature=&quot;分享微服务的原理和最佳实践，讲透服务治理的底层原理，带你细读 go-zero 源码。go-zero 是一个集成了各种工程实践的 web 和 rpc 框架，旨在缩短从需求到上线的距离。公众号文章勘误在知乎号：万俊峰Kevin&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>01169cf44ac3f52e0b238aa5637e38eb</guid>
<title>有关 Vue 源码的简单实现，做一个属于自己的 min-vue</title>
<link>https://toutiao.io/k/37d4dui</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;vue-study&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;自己实现的mini-vue仓库：https://github.com/maolovecoding/mini-vue2-stage&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; &lt;strong&gt;建议克隆代码观看，效果更佳。&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;实现了Vue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现了响应式数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现了模板编译&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现了ast转render&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;render执行生成虚拟dom&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虚拟dom转真实dom渲染页面&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;响应式数据和页面渲染结合 数据改变可自动更新视图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现同步更新数据，异步更新视图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;优雅降级&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;10.实现nextTick 11. 实现了mixin，目前只支持生命周期的合并&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码中注释很多，觉得不习惯的可以一边看一边删除多余的注释。&lt;/strong&gt; &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.194078947368421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKnhUKymHVOTFYkfiaCmanaxibpiaLBItJibYdApmoxF7fbW4OFiar8DuYdgGxZCODUBmnY1b3xvIMgvXsw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;608&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9422657952069716&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKnhUKymHVOTFYkfiaCmanaxibQO05KjMLwuxy5ptGaPuTJZ8euIet7lgQp02ACcTa0Lib8tH8Ow0jEDw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;918&quot;/&gt; &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0698224852071005&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKnhUKymHVOTFYkfiaCmanaxibHEC0fMXOa75fSvqBuawnIrSKzKCWosPVHJyrPYvialffflBV6fWDyMw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;845&quot;/&gt; &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1350210970464134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKnhUKymHVOTFYkfiaCmanaxibgGcL8S5pdflbJnaj2s7gpCyl77ch7tT3ctNxXsxkUEsJf2j5n9VkSw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;711&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;vue的常见源码实现&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;rollup环境搭建&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;安装rollup及其插件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm i rollup rollup-plugin-babel @babel/core @babel/preset-env rollup-plugin-node-resolve -D&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编写配置文件 rollup.config.js&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个可以直接使用es module&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// rollup默认可以导出一个对象 作为打包的配置文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; babel &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;rollup-plugin-babel&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; resolve &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;rollup-plugin-node-resolve&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 入口&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;input&lt;/span&gt;: &lt;span&gt;&quot;./src/index.js&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;// 出口&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;output&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;// 生成的文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;file&lt;/span&gt;: &lt;span&gt;&quot;./dist/vue.js&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 全局对象 Vue 在global(浏览器端就是window)上挂载一个属性 Vue&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&quot;Vue&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 打包方式 esm commonjs模块 iife自执行函数 umd 统一模块规范 -&amp;gt; 兼容cmd和amd&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;format&lt;/span&gt;: &lt;span&gt;&quot;umd&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 打包后和源代码做关联&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;sourcemap&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;plugins&lt;/span&gt;: [&lt;br/&gt;    babel({&lt;br/&gt;      &lt;span&gt;// 排除第三方模块&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;exclude&lt;/span&gt;: &lt;span&gt;&quot;node_modules/**&quot;&lt;/span&gt;,&lt;br/&gt;    }),&lt;br/&gt;    &lt;span&gt;// 自动找文件夹下的index文件&lt;/span&gt;&lt;br/&gt;    resolve()&lt;br/&gt;  ],&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;babel.config.js&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// babel config&lt;/span&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports =  {&lt;br/&gt;  &lt;span&gt;// 预设&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;presets&lt;/span&gt;: [&lt;span&gt;&quot;@babel/preset-env&quot;&lt;/span&gt;],&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编写脚本&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&quot;scripts&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;dev&quot;&lt;/span&gt;: &lt;span&gt;&quot;rollup -cw&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;-c表示使用配置文件，-w表示监控文件变化。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;element.outerHTML&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;outerHTML&lt;/code&gt;属性获取描述元素（包括其后代）的序列化HTML片段。它也可以设置为用从给定字符串解析的节点替换元素。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;app&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;h2&lt;/span&gt;&amp;gt;&lt;/span&gt;{{name}}&lt;span&gt;&amp;lt;/&lt;span&gt;h2&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;{{age}}&lt;span&gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    console.log(document.querySelector(&quot;#app&quot;).outerHTML)&lt;br/&gt;    /*&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;app&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;h2&lt;/span&gt;&amp;gt;&lt;/span&gt;{{name}}&lt;span&gt;&amp;lt;/&lt;span&gt;h2&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;{{age}}&lt;span&gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  */&lt;br/&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;核心流程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;vue的核心流程：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;创造响应式数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模板编译 生成 ast&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ast 转为render函数 后续每次数据更新 只执行render函数(不需要再次进行ast的转换)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;render函数执行 生成 vNode节点（会使用到响应式数据）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据vNode 生成 真实dom 渲染页面&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据更新 重新执行render&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据劫持&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Vue2中使用的是Object.definedProperty&lt;/strong&gt;，&lt;strong&gt;Vue3中直接使用Proxy了&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;模板编译为ast&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vue2中使用的是正则表达式进行匹配，然后转换为ast树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模板引擎 性能差 需要正则匹配 替换 vue1.0 没有引入虚拟dom的改变，vue2 采用虚拟dom 数据变化后比较虚拟dom的差异 最后更新需要更新的地方， 核心就是我们需要将模板变成我们的js语法 通过js语法生成虚拟dom，语法之间的转换 需要先变成抽象语法树AST 再组装为新的语法，这里就是把template语法转为render函数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ast转render&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把生成的ast语法树，通过字符串拼接等方式转为render函数。render函数内部主要用到：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;_c函数：创建元素虚拟dom节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;_v函数：创建文本虚拟dom节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;_s函数：将函数内的变量字符串化&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;render函数生成真实dom&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用render函数，会生成虚拟dom，然后把虚拟dom转为真实DOM，挂载到页面即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回忆流程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;核心流程：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;数据处理成响应式，在 initState中处理的（针对对象来说主要是definedProperty，数组则是重写七个方法）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模板编译：先把模板转成ast语法树，再把语法树生成&lt;strong&gt;render函数&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用render函数，可能会进行变量的取值操作(_s函数内有变量)，产生对应的虚拟dom&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虚拟dom渲染为真实dom，挂载到页面即可&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;完成了，虚拟和真实dom的渲染，也完成了响应式数据的处理，接下来需要进行视图和响应式数据的关联，在渲染页面的时候，收集依赖数据。&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用观察者模式实现依赖收集&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步更新策略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mixin的实现原理&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;模板的依赖收集&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要完成依赖的收集，很明显的就是，我们要如何得知，此模板在此次渲染的时候，用到了那些响应式数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以给模板中的属性，增加一个&lt;strong&gt;收集器（dep）&lt;/strong&gt;。这个收集器，是给每个属性单独增加的。页面渲染的时候，我们把渲染逻辑封装到watcher中。（其实就是手动更新视图的那两个方法app._update(app._render())）。让dep记住这个watcher即可，在属性变化了以后，可以找到对应的dep中存放的watcher，然后执行重新渲染页面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里面我们用到的方式其实就是&lt;strong&gt;观察者模式&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * watcher 进行实际的视图渲染&lt;br/&gt; * 每个组件都有自己的watcher，可以减少每次更新页面的部分&lt;br/&gt; * 给每个属性都增加一个dep，目的就是收集watcher&lt;br/&gt; * 一个视图（组件）可能有很多属性，多个属性对应一个视图 n个dep对应1个watcher&lt;br/&gt; * 一个属性也可能对应多个视图（组件）&lt;br/&gt; * 所以 dep 和 watcher 是多对多关系&lt;br/&gt; * &lt;br/&gt; * 每个属性都有自己的dep，属性就是被观察者&lt;br/&gt; * watcher就是观察者（属性变化了会通知观察者进行视图更新）-&amp;gt; 观察者模式&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Watcher&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先让watcher收集dep，如果dep已经收集过，则不会再次收集。当dep被收集的时候，我们也会让dep反向收集当前的watcher。实现二者的双向收集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在响应式数据发送改变的时候，通知dep的观察者（watcher）进行视图更新。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5452453987730062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKnhUKymHVOTFYkfiaCmanaxiblTQo4ezlReRfj4xTlwoEFGbjpEPwDXLzzNSkkuXThibMlHvL8MSS47Q/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1304&quot;/&gt;&lt;figcaption&gt;image-20220415105750259&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;视图同步渲染&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，已经完成了响应式数据和视图的绑定，在数据发生改变的情况下，视图会同步更新。也就是说，我们更新了两次响应式数据，也会更新两次视图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6230366492146597&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKnhUKymHVOTFYkfiaCmanaxibXk3yKYCN1BVaLWDgMkosvecHObibFvO3QGwssQRmNf5pMEFrhFNw73Q/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;573&quot;/&gt;&lt;figcaption&gt;image-20220415110028536&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下，更新两次视图是没有问题的，但是此时两次数据的更新发生在一次同步代码中，我们应该让视图的更新是异步的，这样在一次操作更新多个数据的情况下，也只会渲染一次视图，提高渲染速率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么我们的想法就是合并更新，在所有的更新数据做完以后，在刷新页面。也就是批处理，事件环。&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;事件环&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的期望就是，同步代码执行完毕之后，在执行视图的渲染（作为异步任务）。把更新操作延迟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法就是使用一个队列维护需要更新的watcher，第一次更新属性值的时候，就开启一个定时器，清空所有的watcher。后续的数据改变的操作，都不会再次开启定时器，只是会把需要更新的watcher再次入队列。（当然watcher我们会先去重）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这个清空操作是在同步代码执行完毕后才会执行的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// watcher queue 本次需要更新的视图队列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; queue = [];&lt;br/&gt;&lt;span&gt;// watcher 去重  {0:true,1:true}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; has = {};&lt;br/&gt;&lt;span&gt;// 批处理 也可以说是防抖&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; pending = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 不管执行多少次update操作，但是我们最终只执行一轮刷新操作&lt;br/&gt; * @param {*} watcher&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;queueWatcher&lt;/span&gt;(&lt;span&gt;watcher&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; id = watcher.id;&lt;br/&gt;  &lt;span&gt;// 去重&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!has[id]) {&lt;br/&gt;    queue.push(watcher);&lt;br/&gt;    has[id] = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(queue);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!pending) {&lt;br/&gt;      &lt;span&gt;// 刷新队列 多个属性刷新 其实执行的只是第一次 合并刷新了&lt;/span&gt;&lt;br/&gt;      setTimeout(flushSchedulerQueue, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;      pending = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 刷新调度队列 且清理当前的标识 has pending 等都重置&lt;br/&gt; * 先执行第一批的watcher，如果刷新过程中有新的watcher产生，再次加入队列即可&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;flushSchedulerQueue&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; flushQueue = [...queue];&lt;br/&gt;  queue = [];&lt;br/&gt;  has = {};&lt;br/&gt;  pending = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 刷新视图 如果在刷新过程中 还有新的watcher 会重新放到queueWatcher中&lt;/span&gt;&lt;br/&gt;  flushQueue.forEach(&lt;span&gt;(&lt;span&gt;watcher&lt;/span&gt;) =&amp;gt;&lt;/span&gt; watcher.run()); &lt;span&gt;// run 就是执行render&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;nextTick&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;原理：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们数据的更新和视图的更新不再是同步，导致我们在同步获取视图最新的dom元素时，可能出现获取的元素和视图实际显示的元素不一致的情况。于是出现了 &lt;strong&gt;nextTick方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上：nextTick方法内部也是维护了一个异步回调队列，开启一个定时器，每次调用该方法传入回调，都是把回调函数放入队列，并不是每次调用nextTick方法都开启一个定时器（比较销毁性能）。再放入第一个回调函数的时候，开启定时器，后续的回调函数只放入队列而不会再次开启定时器了，。所以nextTick不是创建了异步任务，而是将这个任务维护到了队列而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;nextTick方法是同步还是异步？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把任务（回调）放到队列是同步，实际执行任务是异步。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 任务队列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; callbacks = [];&lt;br/&gt;&lt;span&gt;// 是否等待任务刷新&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; waiting = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 刷新异步回调函数队列&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;flushCallbacks&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; cbs = [...callbacks];&lt;br/&gt;  callbacks = [];&lt;br/&gt;  waiting = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  cbs.forEach(&lt;span&gt;(&lt;span&gt;cb&lt;/span&gt;) =&amp;gt;&lt;/span&gt; cb());&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 异步批处理&lt;br/&gt; * 是先执行内部的回调 还是用户的？ 用个队列 排序&lt;br/&gt; * &lt;span&gt;@param &lt;span&gt;{Function}&lt;/span&gt; &lt;/span&gt;cb 回调函数&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;nextTick&lt;/span&gt;(&lt;span&gt;cb&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 使用队列维护nextTick中的callback方法&lt;/span&gt;&lt;br/&gt;  callbacks.push(cb);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!waiting) {&lt;br/&gt;    setTimeout(flushCallbacks, &lt;span&gt;0&lt;/span&gt;); &lt;span&gt;// 刷新&lt;/span&gt;&lt;br/&gt;    waiting = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;vue的nextTick&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，vue的nextTick方法，内部并没有直接使用原生的某一个异步api（比如promise，setTimeout等）。而是采用优雅降级的方法。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;内部先采用的是promise（ie不兼容）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有一个和Promise等价的 &lt;span&gt;MutationObserve&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;。也是异步微任务。（此API是H5的，只能在浏览器中使用）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;考虑ie浏览器专享的 setImmediate API。性能比settimeout好一些&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后直接上setTimeout&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**采用优雅降级的目的，**还是为了用户可以尽快看见页面的渲染。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 优雅降级  Promise -&amp;gt; MutationObserve -&amp;gt; setImmediate -&amp;gt; setTimeout(需要开线程 开销最大)&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; timerFunc = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;Promise&lt;/span&gt;) {&lt;br/&gt;  timerFunc = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.resolve().then(flushCallbacks);&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (MutationObserver) {&lt;br/&gt;  &lt;span&gt;// 创建并返回一个新的 MutationObserver 它会在指定的DOM发生变化时被调用（异步执行callback）。&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; observer = &lt;span&gt;new&lt;/span&gt; MutationObserver(flushCallbacks);&lt;br/&gt;  &lt;span&gt;// TODO 创建文本节点的API 应该封装 为了方便跨平台&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; textNode = &lt;span&gt;document&lt;/span&gt;.createTextNode(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;observer-----------------&quot;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;// 监控文本值的变化&lt;/span&gt;&lt;br/&gt;  observer.observe(textNode, {&lt;br/&gt;    &lt;span&gt;characterData&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  });&lt;br/&gt;  timerFunc = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; (textNode.textContent = &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (setImmediate) {&lt;br/&gt;  &lt;span&gt;// IE平台&lt;/span&gt;&lt;br/&gt;  timerFunc = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; setImmediate(flushCallbacks);&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  timerFunc = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; setTimeout(flushCallbacks, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于vue3，肯定就不需要这种方式了，在不兼容ie的情况下，可以直接使用promise了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9860031104199067&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKnhUKymHVOTFYkfiaCmanaxibvjBaBGSsVaEjhIshGiajntrV8glDqMetgjQT0s4Y4LJcWKFCsQktWcQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;643&quot;/&gt;&lt;figcaption&gt;image-20220415150046818&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过一次次处理，现在是可以在视图更新以后再去拿最新的dom了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然：对于更改值放在取值的下面，那么获取到的肯定还是旧的dom值。vue也是如此的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKnhUKymHVOTFYkfiaCmanaxib1ibcic8V57aBqWQD4z8SHV45gY30C8ysicNVr9NSfrawjsaWgSu8oeib3Q/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;625&quot;/&gt;&lt;figcaption&gt;image-20220415150347883&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;mixin的实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue的mixin，可以实现全局混入和局部混入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全局混入对所有组件实例都生效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;暂时我实现了生命周期的混入，对于data等其他特殊选项的合并还未处理。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于混入的生命周期，无论是一个还是多个相同的生命周期，最终我们都转为使用数组包裹，每个数组元素都是混入进来的生命周期。在创建组件实例的时候，把传入的选项和全局的Vue.options选项进行合并到实例上，实现混入效果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4041411042944785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKnhUKymHVOTFYkfiaCmanaxibtnqIMogVX59xOVS1CjLNkat2jbldbMejAiaT9aohXWfH8rZ6OPruKJQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1304&quot;/&gt;&lt;figcaption&gt;image-20220415220542253&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;https://github.com/maolovecoding/mini-vue2-stage&lt;em/&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver&lt;em/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9881ad0673bd9ca6092c3d54090330d6</guid>
<title>基于Impala的高性能数仓实践之执行引擎模块</title>
<link>https://toutiao.io/k/xs34jb6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;hr/&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;本系列文章将结合实际开发和使用经验，聊聊可以从哪些方面对数仓查询引擎进行优化&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Impala是Cloudera开发和开源的数仓查询引擎，以性能优秀著称。除了Apache Impala开源项目，业界知名的Apache Doris和StarRocks、SelectDB项目也跟Impala有千丝万缕的联系。笔者所在的网易数帆大数据团队，是最早一批将其作为分析型数仓查询引擎的团队，目前正基于Impala打造有数高性能数仓引擎。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文章大致可以分为这几个部分：首先会对简单介绍下Impala的架构和元数据管理，以便后续内容展开；接着从执行引擎，存储优化，物化视图，数据缓存和虚拟数仓等维度进行探讨。本文为执行引擎篇。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;Impala简介&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Impala集群包含一个Catalog Server (Catalogd)、一个Statestore Server (Statestored) 和若干个Impala Daemon (Impalad)。Catalogd主要负责元数据的获取和DDL的执行，Statestored主要负责消息/元数据的广播，Impalad主要负责查询的接收和执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVCw5GFOGvPoVVrB05jNbAN9sprsNqGtd3D9C7Y4dDywFibWG2iaA90yz1ichvj6RDTIIcFeh8vTaHfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Impalad又可配置为coordinator only、 executor only 或coordinator and executor（默认）三种模式。Coordinator角色的Impalad负责查询的接收、计划生成、查询的调度等，Executor角色的Impalad负责数据的读取和计算。默认配置下每个Impalad既是Coordinator又是Executor。生产环境建议做好角色分离，即每个Impalad要么是Coordinator要么是Executor。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.1 元数据管理&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Impala的元数据缓存在catalogd和各个Coordinator角色的Impalad中。Catalogd中的缓存是最新的，各个Coordinator都缓存的是Catalogd内元数据的一个复本。元数据由Catalogd向外部系统获取，并通过Statestored 传播给各个Coordinator。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以Hive表为例，Catalogd中的元数据分别从Hive Metastore（HMS）和HDFS NameNode（NN）获取。从HMS获取的信息包括元数据信息和统计信息两部分，元数据信息指有哪些库和表，表定义，列类型等，对应“show databases，show tables，show create table xxx，show ”等操作。统计信息包括表的大小，行数，分区和各列的信息等，对应“show table stats xx，show column stats xx”等操作。从NN获取的是文件粒度的信息，包括文件存储位置，副本和文件块信息等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.2 管理服务器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;管理服务器是有数高性能数仓增加的Impala模块，提供集群粒度的SQL查看界面，持久化保存历史查询信息并展示，SQL审计，查询错误和查询性能分析，自动进行统计信息计算等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.25390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVCw5GFOGvPoVVrB05jNbANQzLtNKfkMN7A4K680OFxYet2CbfDpyaOa3jicRrGYZwnDFbFL99ZwGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;执行引擎（Execute Engine）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.1 执行模型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在执行模型这块，目前主要有动态代码生成（code generation或just in time/JIT）和向量化计算两个流派，Impala主要是基于JIT进行性能优化，对于向量化引擎，Impala社区版目前并没有相关规划，有数高性能数仓团队也有计划对其进行向量化改造。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在具体实现上，Impala属于改进版的火山模型，官方论文描述为&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;180&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;The execution model is the traditional Volcano‑style with Exchange operators. Processing is performed batch‑at‑a‑time: each GetNext() call operates over batches of rows, similar to&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;即在传统的火山模型的基础上加入Exchange操作符，用于进行不同执行节点的数据交换。&lt;/span&gt;&lt;span&gt;每次会获取一批记录而不是一条记录。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不管是JIT还是矢量化，其目的都是尽可能地减少执行引擎核心代码流程的调用次数并提高函数执行效率，这对于需要处理海量记录时非常重要。Impala通过每次获取一批记录来减少调用次数，再利用JIT技术来生成针对特定类型数据的执行流程函数，提高每次调用的效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更进一步，Impala采用数据流水线（streaming pipelined）执行机制，充分利用计算资源进行并发执行。在Impala 4.0版本，完整支持了executor节点的多线程执行模型，进一步提高并发能力，压榨计算资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;动态代码生成原理及优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JIT技术与静态编译技术相反，其是在具体的查询运行之前才进行代码编译，此时，查询中需要处理的列类型，用到的算子和函数都已经确定，可以为该查询生成特定版本的处理函数。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVCw5GFOGvPoVVrB05jNbANl23PlILqHtOqFWQf7BC1EZ6XaBbSGN6Owap5euPO3Gtel5nM9KurGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;左侧是通用的从文件读取记录（tuple）并解析的行数，外层一个for循环用于对每一列进行处理，内层的switch用于判断列的类型并调用特定的解析函数。如果我们已经知道该记录由三列组成，类型分别为int，bool和int，那么JIT技术就可以生成如图右侧的函数版本，不需要for循环，也不需要switch判断，显然，执行效率更高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来说，Impala使用LLVM来进行JIT优化，生成对于某个具体查询最优的函数实现。其优化项具体包括移除条件分支（Removing conditionals，如上所示）、移除内存加载和内联虚函数调用等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启用动态代码生成时，在查询执行前需要先动态生成其执行代码，因此有一定的时间消耗，对于小查询，动态代码生成可能是有害的，生成代码的时间都有可能超过SQL执行时间。Impala提供了DISABLE_CODEGEN_ROWS_THRESHOLD参数，默认为50000，如果SQL需要处理的记录数小于该值，则不会使用动态代码生成进行执行优化。Impala 4.0版本对JIT进行了进一步优化，采用异步化改造来避免生成JIT代码对查询性能的影响，当编译未完成时使用原函数，完成后无缝切换成优化后的函数代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.2 计算资源&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Impala属于SQL on Hadoop的一种，基于MPP（Massively Parallel Processing，即大规模并行处理）架构，正常情况下，查询涉及的各种操作均在内存中完成的，因此，可用内存的多少及对其的利用效率，对Impala查询性能有极大影响。同样地，作为一个OLAP查询引擎，可用的CPU资源对查询性能也至关重要。Impala虽提供了少数CPU相关配置项，如num_threads_per_core 等，但对CPU使用的控制能力较差。本小节后续仅介绍内存资源相关，CPU计算后续另开一篇单独介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Impala资源池&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Impala有比较丰富的资源使用限制方式，称为准入控制。其中资源池（resource pool）是Impala进行并发控制的主要手段，可以决定某个查询是否会被拒绝，或执行，或排队。其主要有两种控制方式，一种是手动设置最大并发数控制，超过阈值的请求会进行排队，可以设置允许排队的最大请求数和排队时长，超过阈值的请求直接返回失败；另一种是基于内存的并发控制，下面进行重点介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;基于内存的并发控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Impala集群支持通过fair-scheduler.xml设置多个资源池并规定其最大可用内存（maxResources），再通过llama-site.xml为每个资源池设置请求级别的内存限制，包括内存分配上下限max-query-mem-limit和min-query-mem-limit，及clamp-mem-limit-query-option。除了通过资源池相关配置控制请求的内存使用，还可以通过MEM_LIMIT请求选项设置内存限制。而clamp-mem-limit-query-option就是设置是否允许MEM_LIMIT设置的内存突破资源池内存配置的限制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要注意的是，max-query-mem-limit，min-query-mem-limit和MEM_LIMIT设置的是请求在每个executor节点允许申请的最大内存，请求申请的总内存还需要乘上执行该请求的executor节点个数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若Impala通过预估发现查询所需的内存资源超过集群总内存资源，该查询会被拒绝；若总资源满足，但由于部分资源已被其他查询占用，则会将其放入请求队列，待可用资源满足查询要求时再按查询提交的先后顺序调度执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若预估的内存资源超过了设置的max-query-mem-limit，则以max-query-mem-limit为准，若小于min-query-mem-limit，则以min-query-mem-limit为准。假设查询请求设置了MEM_LIMIT，需先判断clamp-mem-limit-query-option的值，若为true，则仍然受max-query-mem-limit，min-query-mem-limit约束。下面举个例子进行说明：&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;229&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;假设一个Impala集群有5个executor节点，集群配置了一个最大可用内存为100GB的资源池。查询请求的内存上下限为10GB和2GB，若clamp-mem-limit-query-option为true，Impala为某个查询请求A预估的内存为14GB（或设置了MEM_LIMIT为14GB），则查询A在每个executor最多只能分配10GB内存。若clamp-mem-limit-query-option为false，查询A最多可分配14GB内存。&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;假设clamp-mem-limit-query-option为true，则该资源池最多只能同时执行2个查询A这样的请求（2 * 5 * 10GB）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上面的例子可知Impala的准入控制会在每个executor为查询请求预留所需的内存，因此，所预留的内存应该尽可能接近实际所需内存，预留过少会导致查询失败或中间结果溢出，预留过多会导致集群资源没有被充分利用。在内存资源管理的精确性方面，Impala还有较多需优化的点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;准入控制存在的问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）集群同步&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Impala进行准入控制的载体是coordinator节点，由于一个集群至少有2个及以上的coordinator节点，但准入控制是针对整个集群的。Impala通过statestore的impala-request-queue topic机制在coordinator间周期性地同步每个coordinator上的查询并发和内存使用情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Impala采用去中心化的设计来实现准入控制，而不是通过一个中心节点来统一决策，虽然在性能和可用性上有优势，但是这会导致coordinator获取的其他coordinator信息过旧的问题，尤其是在查询并发度较高时，会导致准入控制模块做出错误的决策。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）内存预估精度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Impala需要基于统计信息来评估查询需要消耗多少内存，因为统计信息里面会记录表的记录数，列的类型和大小等。没有统计信息，就无法正确评估内存消耗，也就无法以较优的方式执行该查询。（统计信息相关的详细描述见下一小节）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但就算是有统计信息，仍有可能依然没法正确估算需消耗的内存量。如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.68203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVCw5GFOGvPoVVrB05jNbANNjichG8QQFpbv3MRAiaq42U1GFLcrQgHcwSDESe6xShSiceaSB2t9nEibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图第一张的&quot;Mem Usage&quot;和&quot;Mem Estimate&quot;分别表示查询实际消耗和预估消耗的总内存，可见明显差别。上图下面两张为通过compute incremental stats/compute stats前后通过explain看到的内存预估情况，可见每个节点均22MB（共67个executor节点），即该查询内存预估不精确不是因为没有统计信息导致的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据溢出（spill to disk）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;内存不够怎么办？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果因为集群同步延迟或内存预估低于实际所需内存，导致查询执行过程中消耗的内存超过准入控制的计算值，此时数据溢出功能可以派上用场。数据溢出是Impala一种兜底机制，避免因中间结果集过大导致内存不足，进而引起查询失败。当然，并不是所有情况的内存不足都会启用数据溢出，能够进行数据溢出的算子主要包括group by，order by，join，distinct和union；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据溢出机制的用处在于，能够最大限度避免查询失败。OLAP场景由于SQL复杂度远高于OLTP，耗时也明显更长，查询失败的代价更大。其带来的问题是因为需要将中间结果写盘并读取，SQL查询性能会明显下降，因此，应该通过查询优化尽可能避免数据溢出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关闭数据溢出&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有两种方法可以关闭数据溢出，均是通过query option来设置，分别是SCRATCH_LIMIT和DISABLE_UNSAFE_SPILLS。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SCRATCH_LIMIT用于设置溢出目录的大小，当设为0时，即关闭了数据溢出特性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DISABLE_UNSAFE_SPILLS更加智能，用于禁止不安全的数据溢出。Impala认为下列情况属于不安全的溢出：查询中存在没有统计信息的表，或没有为join设置hint，或对分区表进行insert ... select操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;优化资源分配效率&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）集中式准入控制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从Impala社区了解到，目前Impala在开发新的准入控制实现，预计后续会提供集中式的准入控制方案，详见 Single Admission Controller per Cluster；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）降低准入信息同步延时&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽可以通过statestore_update_frequency_ms缩短topic更新周期来缓解，但无法从根本上解决。除此之外，在Impala部署时，还应该控制coordinator的数量，对于50个节点以下的集群，一般情况下配置2个coordinator实现高可用即可；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）丰富统计信息类型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至于为什么在有统计信息情况下预估还是不够精确，原因也很好理解，即统计信息本身过于粗粒度，缺乏像直方图这样细粒度的数据统计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;基于历史查询的内存估算优化（HBO）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从前述的例子可知，有数的Impala版本通过管理服务器保存了Impala执行过的历史查询信息，其中就包括了查询的实际内存使用量。在BI场景，报表SQL会重复执行，往往一天一次或数次，完全可以将该SQL第一次执行的内存使用量作为后面几次的内存预估值。进一步，可以提取同类SQL查询模板，计算该模板下SQL的最大及平均内存使用量作为内存预估值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，由于BI报表的SQL都来源于事先创建的数据模型，可以预先计算数据模型SQL的内存消耗，在执行该模型对应的报表SQL时，模型部分的内存消耗无需再次计算，直接代入即可。基于此，我们完成了方案设计和功能实现，下图为一个查询开启HBO优化前后的内存估算值变化&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.362381363244176&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVCw5GFOGvPoVVrB05jNbANNWomicIlpbuMmDFo9Mc5PsUzS96HvOAu0foXQnCDUluz4z51wcd1Vbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1159&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图为将HBO用在某业务集群上启用前后的效果对比。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.13359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVCw5GFOGvPoVVrB05jNbANViaykDHZFc7d32TUJPwenQExrremzXHftiaiaygovTTvaoju93y06oRcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.134375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVCw5GFOGvPoVVrB05jNbAN67Ribft1LUe4IZichAYJj49MvZefY4bWWbYYlUhvj1nObsBULtXCbviaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.3 基于代价优化（CBO）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CBO与RBO（基于规则优化）都是传统的执行计划优化方式。CBO主要基于索引和统计信息等元数据来选择更优的执行计划。传统的商业数仓和OLTP系统有健全的索引系统，并且会自动计算表的统计信息。因此，CBO往往能够较充分发挥。但目前开源的分析型数仓查询引擎（下称OLAP），做得并不好，以Impala为例，自身并没有索引系统，主要依赖底层的存储系统，虽提供了统计信息计算的命令，但不会自动进行统计信息计算。在此，我们先介绍其对统计信息的使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;统计信息的用途&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Impala中，统计信息主要用于准入控制和确定Join方式等场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;确定Join方式包括Join的先后顺序和Join的方法，Join方式有shuffle和broadcast两种。如下文描述：&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;232&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;Impala does not consider all possible join orderings, focusing instead on the subset of left deep join plans. This usually means joins are arranged in a long chain where the left input is preferred to be larger than the right input.&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;三个及以上的表进行Join时，一般选择将结果集最小的Join先算掉，对于两表Join，若是大表和小表，由于Impala使用Hash Join，采用大表左（probe table），小表在右（build table）的方式，将小表broadcast到大表分片所在的各个executor节点，若是大表跟大表，则采用shuffle的方式，两表都会进行Hash分片，各个executor节点对两表相同Hash值的分片进行Join。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果SQL中的表缺失了统计信息，如查询所涉及的记录数，所涉及的各列的大小等，则无法准确预估该SQL的内存消耗，导致准入控制模块出现误判，生产环境中常会出现因executor节点可用内存不足导致查询排队的情况，但其实此时内存是够的，这里有多方面的原因，比如该查询SQL所需内存预估值过大，或已经在执行的查询的配额过大等。相反的，如果预估所需内存过小，则可能导致查询在执行过程中因为executor节点无法分配所需内存而导致SQL执行失败。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同样的，如果没有统计信息，也就无法判断两表参与Join的记录数和大小，出现大小表Join时大表被广播的情况。在Impala中，两表Join，没有统计信息的表会被放在右边，所以，对大表做统计信息计算显得更加重要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除此之外，统计信息用于调优前文提到的动态代码生成。上文提到的&lt;/span&gt;&lt;span&gt;DISABLE_CODEGEN_ROWS_THRESHOLD&lt;/span&gt;&lt;span&gt;参数需要在有统计信息的情况下使用，无统计信息，意味着不知道需要处理多少条记录，该参数也就无法生效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;统计信息计算&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Impala为什么不像MySQL等数据库一样自动计算和更新表统计信息呢？个人认为，主要是不好做，MySQL自动进行统计信息更新的方式是监测表中的记录，如果更新的记录数超过设定的阈值，则自动触发更新。当Impala对接Hive表时，往往仅用于查询而不是数据产出，数据产出由Spark或Hive负责，因此也就无法自动感知表中数据的变化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果能够及时感知Hive表的数据变化情况，那么就有办法驱动统计信息更新。Impala可以通过订阅有数大数据开发及管理平台的数据产出日志，感知Hive表的数据变化。具体的统计信息计算由Impala管理服务器执行。Impala 3.4版本下，表和列的统计信息字段如下所示。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[localhost:21000] &amp;gt; show table stats t1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Query: show table stats t1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;+-------+--------+------+--------+&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;| #Rows | #Files | Size | Format |&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;+-------+--------+------+--------+&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;| -1    | 1      | 33B  | TEXT   |&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;+-------+--------+------+--------+&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Returned 1 row(s) in 0.02s&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[localhost:21000] &amp;gt; show column stats t1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Query: show column stats t1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;+--------+--------+------------------+--------+----------+----------+&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;| Column | Type   | #Distinct Values | #Nulls | Max Size | Avg Size |&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;+--------+--------+------------------+--------+----------+----------+&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;| id     | INT    | -1               | -1     | 4        | 4        |&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;| s      | STRING | -1               | -1     | -1       | -1       |&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;+--------+--------+------------------+--------+----------+----------+&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Returned 2 row(s) in 1.71s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进行统计信息计算的“compute stats”命令本质是通过两条SQL分别获取表/分区和列粒度的信息：即为上述两个查询结果中的为“-1”的字段进行赋值，如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVCw5GFOGvPoVVrB05jNbANld7u5ibCdkfiaQtnP4CThS0D4Mb9iaZaWxkiaTztnEqbQwrI4SxwfNGTag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两个SQL均需在全表扫描的基础上进行聚合操作。对于大表，这需要消耗可观的计算资源，而且，若表中的列个数非常多，则统计信息的存储空间也是需要考虑的因素（需要持久化到HMS元数据库中，并缓存在catalogd和impalad）。对于分区表，一般使用“compute incremental stats”每次仅计算一个分区，但有时仍会因为统计信息过大而出错，这是由于超过了增量统计信息计算的“inc_stats_size_limit_bytes”参数设定值导致：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;org.apache.impala.common.AnalysisException: Incremental stats size estimate exceeds 200.00MB.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考Impala的文档，统计信息计算可以进行如下优化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从性能优化角度，统计信息显然是越精细越好。但在OLAP这种大数据量场景下，越精细意味着越庞大的统计信息计算和存储开销，使用何种粒度的统计信息是个需要权衡的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.4 查询的分布式执行&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在大数据场景下，单靠单台服务器执行分析型查询操作显然过于单薄，所以分析型数仓一般基于MPP（Massively Parallel Processing，即大规模并行处理）架构，Impala就是基于MPP，可以将一个查询分为多个片段分布式执行。在Impala上，分布式执行又可分为节点间和节点内。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了能够在分布式执行的同时，能够对不同业务或不同类型的SQL进行隔离，避免相互影响，有数的Impala版本进一步引入了虚拟数仓概念，能够有效的进行资源隔离，同时有兼顾资源的有效利用。对于虚拟数仓，我们会在后续单独写一篇文章进行介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;节点间并行&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在“Impala简介”小节提到，Impala有多个executor节点，在确定执行计划时，Impala会充分考虑并发执行该查询，尽可能将需要扫描的数据分成range分发到各executor节点上执行，并响应对数据进行查询所需的算子进行分布式计算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，在数据量足够大的情况下，增加executor节点数可以提升查询性能。若executor所在服务器的计算资源充足，可以考虑同一台服务器上部署多个executor节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;节点内并行&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Impala还可以通过MT_DOP参数配置查询在executor节点内的执行并发线程数。对于统计信息计算产生的SQL，Impala自动将MT_DOP设置为4以提升计算性能。相比节点间并行，节点内并行通过query option设置，更加灵活可控。在Impala 3.4及之前版本，MT_DOP不够完善，无法支持分布式Join等操作，从Impala 4.0开始，MT_DOP已支持绝大部分算子。我们在TPCH和TPCDS场景下的测试数据表明，将MT_DOP设置为16的性能明显好于不设置或将其设置为1时的性能，绝对性能有数倍提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;合理配置并行数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;显然，查询的执行并行度不是越高越好，需要考虑Impala集群的查询并发数以及executor节点的计算资源可用量。一般建议executor节点所在服务器的计算资源和网络资源的利用率应该小于80%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于节点内并行，需要考虑impala profile输出对性能的影响，在配置高MT_DOP时，应启用精简模式的profile-v2（gen_experimental_profile=true），防止profile过大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.5 查询重试和改写&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;查询重试&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查询出错的原因有很多，比如执行该查询的任意一个executor不可用（宕机或网络隔离等），或因排队过久导致执行超时，或因元数据过旧导致执行出错等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Impala 4.0版本，引入了查询透明重试的特性，该特性会判断引起查询出错的原因，目前支持对因executor不可用而出错的查询进行自动重试，无需用户/客户端参与。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;元数据过旧重试&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因元数据过旧导致执行出错是Impala特有的错误场景，最典型的错误形如：“Failed to open HDFS file .....”。有数的Impala版本还支持对该类错误进行透明重试，coordinator节点通过匹配错误关键字识别错误类型。在重试前会解析HDFS文件路径获取库名和表名，并获取当前该表的元数据版本，重试时若元数据版本未变化，这会将对应的表元数据失效掉，重新加载元数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对元数据错误进行查询重试，是一种把错误内部化的一种优化方式。元数据过旧是由于Impala出于性能考虑对其进行了缓存，对用户来说元数据缓存应该是黑盒的，因缓存过旧导致的错误，不应该直接暴露给使用者，应该在系统设计时消化掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;SQL改写&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;常规改写&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Impala提供了表达式级别的改写优化，改写规则主要包括常量折叠、通用表达式提取和，全部规则如下所示：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;List&amp;lt;ExprRewriteRule&amp;gt; rules = new ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      // BetweenPredicates must be rewritten to be executable. Other non-essential&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      // expr rewrites can be disabled via a query option. When rewrites are enabled&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      // BetweenPredicates should be rewritten first to help trigger other rules.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      rules.add(BetweenToCompoundRule.INSTANCE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      //between转大小比较&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      // Binary predicates must be rewritten to a canonical form for both Kudu predicate&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      // pushdown and Parquet row group pruning based on min/max statistics.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      rules.add(NormalizeBinaryPredicatesRule.INSTANCE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      //规范化二元谓语，如“5 + 3 = id&quot;改为&quot;id = 5 + 3&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      if (queryCtx.getClient_request().getQuery_options().enable_expr_rewrites) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        rules.add(FoldConstantsRule.INSTANCE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        //常量折叠，如&quot;1 + 1&quot;改为&quot;2&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        rules.add(NormalizeExprsRule.INSTANCE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        //规范化表达式，如&quot;id = 0 OR false&quot;改为&quot;FALSE OR id = 0&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        rules.add(ExtractCommonConjunctRule.INSTANCE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        //通用表达式提取，如&quot;(int_col &amp;lt; 10 and bigint_col &amp;lt; 10) or &quot; + &quot;(string_col = &#x27;10&#x27; and int_col &amp;lt; 10)&quot;改为&quot;int_col &amp;lt; 10 AND ((bigint_col &amp;lt; 10) OR (string_col = &#x27;10&#x27;))&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // Relies on FoldConstantsRule and NormalizeExprsRule.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        rules.add(SimplifyConditionalsRule.INSTANCE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        //简化条件判断，场景覆盖较广，包括if、case等等，如&quot;if(true, id, id+1)&quot;改为&quot;id&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        rules.add(EqualityDisjunctsToInRule.INSTANCE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        //or转in，如&quot;int_col = 1 or int_col = 2&quot;改为&quot;int_col IN (1, 2)&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        rules.add(NormalizeCountStarRule.INSTANCE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        //count(常量)转为count(*)，如&quot;count(1)&quot;改为&quot;count(*)&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        rules.add(SimplifyDistinctFromRule.INSTANCE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        //简化条件判断（is distinct, &amp;lt;, &amp;gt;, &amp;lt;=&amp;gt;等）语句，如&quot;if(bool_col &amp;lt;=&amp;gt; bool_col, 1, 2)&quot;改为&quot;1&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        rules.add(SimplifyCastStringToTimestamp.INSTANCE);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        //简化将字符串转为时间戳，如&quot;cast(unix_timestamp(date_string_col) as timestamp)&quot;改为&quot;CAST(date_string_col AS TIMESTAMP)&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      exprRewriter_ = new ExprRewriter(rules);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面的代码可知，大部分的改写规则需要通过ENABLE_EXPR_REWRITES 这个query option开启。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;定制改写&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有数的Impala版本在上述基础上，结合BI工具和业务属性进行针对性的优化，有助于提升BI查询性能。其中一项优化是简化时间比较表达式。举例如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SELECT TO_DATE(CAST(`t1`.`dt` AS TIMESTAMP)) `d0`,`t2`.`itemname` `d1`,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;COUNT(DISTINCT `t1`.`user_id`) `m0`&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;FROM `music_dws`.`dws_log_music_xxx_aggr_di` `t1`&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;WHERE (((TO_DATE(CAST(`t1`.`dt` AS TIMESTAMP)) &amp;gt;= CAST(&#x27;2021-01-01&#x27; AS TIMESTAMP)) AND (TO_DATE(CAST(`t1`.`dt` AS TIMESTAMP)) &amp;lt; CAST(&#x27;2022-01-01&#x27; AS TIMESTAMP)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;已知t1表为按天分区，dt为分区字段，结构为&#x27;yyyy-mm-dd&#x27;，那么在此条件下，可以将dt字段与时间字符串进行比较，去掉CAST AS TIMESTAMP和TO_DATE操作，上述SQL可改写为：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SELECT `t1`.`dt` `d0`,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; `t2`.`itemname` `d1`,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;COUNT(DISTINCT `t1`.`user_id`) `m0`&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;FROM `music_dws`.`dws_log_music_xxx_aggr_di` `t1`&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;WHERE (`t1`.`dt` &amp;gt;= &#x27;2021-01-01&#x27;) AND (`t1`.`dt` &amp;lt; &#x27;2022-01-01&#x27;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;高级改写&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面Impala原生支持的改写规则可以看出，其支持的改写规则都比较初级，实现上是将SQL拆解为SelectList、FromClause、WhereClause、GroupByExpr和OrderByExpr等片段后，对各片段进行改写。并没有对SQL进行整体的，跨片段的改写。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有数的Impala版本还可进一步对SQL整体进行改写优化，其中最为重要的是基于物化视图的SQL透明改写，我们会在后续单独写一篇文章进行介绍。除了物化视图改写，还有其他一些优化手段，如左连接（left join）消除等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;左连接消除&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般来说，BI软件基于某个数仓模型（宽表，星型，雪花型等）创建报告，其中包括一张或多张报表，举一个网易云音乐使用有数BI报表模型为例，SQL形如：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SELECT `t1`.`os`, other select list&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;FROM `music_impala`.`left_join_table1` `t1`&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LEFT JOIN `music_impala`.`left_join_table2` `t2` ON ((`t1`.`is_new` = `t2`.`is_new`) AND (`t1`.`anchor_id` = `t2`.`anchor_id`) AND (`t1`.`app_ver` = `t2`.`app_ver`) AND (`t1`.`os` = `t2`.`os`) AND (TO_DATE(CAST(`t1`.`dt` AS TIMESTAMP)) = `t2`.`report_date`))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LEFT JOIN `music_impala`.`left_join_table3` `t3` ON ((`t1`.`is_new` = `t3`.`is_new`) AND (`t1`.`anchor_id` = `t3`.`anchor_id`) AND (`t1`.`app_ver` = `t3`.`app_ver`) AND (`t1`.`os` = `t3`.`os`) AND (TO_DATE(CAST(`t1`.`dt` AS TIMESTAMP)) = `t3`.`report_date`))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LEFT JOIN `music_iplay`.`left_join_table4` `t4` ON ((`t1`.`dt` = `t4`.`dt`) AND (`t1`.`anchor_id` = CAST(`t4`.`anchor_id` AS VARCHAR(255))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以认为，该模型是将下面&lt;span&gt;这4个数仓表通过左连接打宽成一个逻辑大宽表。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;music_impala.left_join_table1、&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;music_impala.left_join_table2、&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;music_impala.left_join_table3&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;music_impala.left_join_table4`&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面是产生的一个报表的列表筛选器组件产生的SQL。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SELECT `t1`.`os` `d0`&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;FROM `music_impala`.`left_join_table1` `t1`&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LEFT JOIN `music_impala`.`left_join_table2` `t2` ON ((`t1`.`is_new` = `t2`.`is_new`) AND (`t1`.`anchor_id` = `t2`.`anchor_id`) AND (`t1`.`app_ver` = `t2`.`app_ver`) AND (`t1`.`os` = `t2`.`os`) AND (TO_DATE(CAST(`t1`.`dt` AS TIMESTAMP)) = `t2`.`report_date`))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LEFT JOIN `music_impala`.`left_join_table3` `t3` ON ((`t1`.`is_new` = `t3`.`is_new`) AND (`t1`.`anchor_id` = `t3`.`anchor_id`) AND (`t1`.`app_ver` = `t3`.`app_ver`) AND (`t1`.`os` = `t3`.`os`) AND (TO_DATE(CAST(`t1`.`dt` AS TIMESTAMP)) = `t3`.`report_date`))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LEFT JOIN `music_iplay`.`left_join_table4` `t4` ON ((`t1`.`dt` = `t4`.`dt`) AND (`t1`.`anchor_id` = CAST(`t4`.`anchor_id` AS VARCHAR(255))))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;GROUP BY `t1`.`os`&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LIMIT 20000&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于BI软件来说，基于模型产生该SQL非常合理。但考虑到模型是逻辑的大宽表，在Impala层面，可以对SQL进行改写以优化查询性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该筛选器用于在报告中对music_impala.left_join_table1的os字段进行选择，且模型中各表Join的条件（ON和WHERE）均没有对os字段进行过滤性操作。在这种情况下，如果在select list中没有对os字段进一步做SUM/AVG/COUNT等聚合操作（可以是MIN/MAX/DISTINCT等聚合操作），那么可以去掉left join算子，改写成如下形式：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SELECT `t1`.`os` `d0`&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;FROM `music_impala`.`left_join_table1` `t1`&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;GROUP BY `t1`.`os`&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;LIMIT 20000&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;3&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文简单说明了Impala的系统架构和元数据管理，介绍了我们内部版本引入的集中式管理服务器。重点介绍了在分析型数仓技术中执行引擎这块的主要技术点和常见优化方法，并结合Impala展开进行了分析，包括动态代码生成、基于准入控制的资源管理、基于统计信息的代价计算、查询并行执行、SQL优化和错误重试等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下一篇我们会重点分析由云原生数仓Snowflake引入的虚拟数仓特性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101582&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;作者简介&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p hm_fix=&quot;322:369&quot;&gt;&lt;span&gt;荣廷，网易杭研数据库开发专家。10年数据库和存储开发经验，2013年起一直从事数据库内核和数据库云服务相关工作，现为杭研数据库内核团队负责人；专注于数据库内核技术和分布式系统架构，乐于挑战和解决疑难问题；负责网易MySQL分支InnoSQL的开发和优化工作，大幅提升了线上业务的MySQL数据库服务质量；主导并推动MGR、MyRocks等新方案在考拉海购、云音乐、传媒等业务场景大规模使用；累计申请10+技术发明专利（已授权8个），《MySQL 内核：InnoDB 存储引擎 卷1》作者之一。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNTUxNTI1Ng==&amp;amp;mid=2247488577&amp;amp;idx=1&amp;amp;sn=dcab0fc848e21cc37ad93a1719246878&amp;amp;chksm=972ee4d6a0596dc0aed48ff60c6a91427ede3cc275890f5d6b594ab7ac0868c191e665a1abbe&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;网易严选离线数仓质量建设实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;网易严选离线数仓质量建设实践&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNTUxNTI1Ng==&amp;amp;mid=2247488344&amp;amp;idx=1&amp;amp;sn=7a2d6441498a1a23cc4c61a109e2e735&amp;amp;chksm=972ee3cfa0596ad9f42a8a3a3c99285339beeb9500c8437cd9797b37bef92fd9ba8a55d6a38c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数据标准在网易的实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;数据标准在网易的实践&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNTUxNTI1Ng==&amp;amp;mid=2247488096&amp;amp;idx=1&amp;amp;sn=dcf01a173522aa5e95fbed9676e9af75&amp;amp;chksm=972ee2f7a0596be1b827cef9e0f01fe0ba9d99761c80ed89d80bc2c15a0a7a8253d5245a213d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;网易数帆数据生产力方法论&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;网易数帆数据生产力方法论&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNTUxNTI1Ng==&amp;amp;mid=2247485146&amp;amp;idx=1&amp;amp;sn=8db26a7b8971229a276ba930b3c1e025&amp;amp;chksm=972ef64da0597f5b33f4daa338ce9ee48d7fe386cdfe109d919470eec12cd2b12b69250098e4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;硬核干货 | 基于Impala的网易有数BI查询优化总结&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;硬核干货 | 基于Impala的有数BI查询优化总结&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNTUxNTI1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOV4Bfic2e5zqTMCl0XxmMuVq1XpDOBrbXicVB4KmrEXglsWcnMREoQXfX24sscdvQIR74ic3SiciaLoMFA/0?wx_fmt=png&quot; data-nickname=&quot;网易有数&quot; data-alias=&quot;Youdata_Netease&quot; data-signature=&quot;网易有数是网易数帆旗下大数据技术与服务品牌，以“数据价值”为导向，聚焦于企业 “看数”、“管数”、“用数”等业务场景，提供全链路大数据技术及产品服务，致力于盘活企业数据生产力，加速实现数字化转型。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-fileid=&quot;100003451&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sYBGQlzfEOXECeWKgyIia3c7bom7Ir4rh4qI4XdxuRW4lyHudFyglytmLrOM4yYOWs3XNqqj0XlXTEw8icZ2Eb1Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;317:401&quot;&gt;分享，点赞，在看，安排一下？&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>