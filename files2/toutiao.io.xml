<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b637af25d24ff623d32f475ec5c9ff3a</guid>
<title>Vite 使 Vue CLI 过时了吗？</title>
<link>https://toutiao.io/k/pczpcvm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.535&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0AMTMSp1sIj8sicIM61P0rOvv6uG5AZemHU8Wn0QIS7mIZZkANbuTwYvuWdSGvhVp11PwWy3yUBUzRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;文末福利资源更新&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Vue生态系统中有一个名为Vite的新构建工具，它的开发服务器比Vue CLI快10-100倍。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是否意味着Vue CLI已经过时了?在本文中，我将比较这两种构建工具，并说明它们的优缺点，以便你可以决定哪一种适合你的下一个项目。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Vue CLI概述&lt;/h2&gt;&lt;section&gt;&lt;span&gt;大多数Vue开发人员都知道，Vue CLI是使用标准构建工具和最佳实践配置快速建立基于Vue的项目的不可或缺的工具。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其主要功能包括：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;工程脚手架&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;带热模块重载的开发服务器&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;插件系统&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户界面&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;在本讨论中需要注意的是，Vue CLI是构建在Webpack之上的，因此开发服务器和构建功能和性能都将是Webpack的超集。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Vite概述&lt;/h2&gt;&lt;section&gt;&lt;span&gt;与Vue CLI类似，Vite也是一个提供基本项目脚手架和开发服务器的构建工具。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然而，Vite并不是基于Webpack的，它有自己的开发服务器，利用浏览器中的原生ES模块。这种架构使得Vite比Webpack的开发服务器快了好几个数量级。Vite采用Rollup进行构建，速度也更快。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Vite目前还处于测试阶段，看来Vite项目的目的并不是像Vue CLI那样的一体化工具，而是专注于提供一个快速的开发服务器和基本的构建工具。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Vite怎么这么快？&lt;/h2&gt;&lt;section&gt;&lt;span&gt;Vite开发服务器至少会比Webpack快10倍左右。对于一个基本的项目来说，与2.5秒相比，开发构建/重新构建的时间相差250ms。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在一个较大的项目中，这种差异会变得更加明显。Webpack开发服务器在构建/重新构建时可能会慢到25-30秒，有时甚至更慢。与此同时，Vite开发服务器可能会以恒定的250ms的速度为同一个项目提供服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这显然是开发经验和游戏规则改变的差异，Vite是如何做到这一点的？&lt;/span&gt;&lt;/section&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1607878348470&quot; data-category_id_list=&quot;48|26|49|1|55|8|47|5|7|24|37|11|50|54|53|42|29|43|16|51|36&quot; data-id=&quot;1607878348470&quot;/&gt;&lt;section&gt;&lt;span&gt;Webpack开发服务器架构&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Webpack的工作方式是，它通过解析应用程序中的每一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;require&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，将整个应用程序构建成一个基于JavaScript的捆绑包，并在运行时转换文件（例如Sass、TypeScript、SFC）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这都是在服务器端完成的，依赖的数量和改变后构建/重新构建的时间之间有一个大致的线性关系。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Vite开发服务器架构&lt;/h2&gt;&lt;section&gt;&lt;span&gt;Vite不捆绑应用服务器端。相反，它依赖于浏览器对JavaScript模块的原生支持（也就是ES模块，是一个比较新的功能）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;浏览器将在需要时通过HTTP请求任何JS模块，并在运行时进行处理。Vite开发服务器将按需转换任何文件（如Sass、TypeScript、SFC）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种架构避免了服务器端对整个应用的捆绑，并利用浏览器高效的模块处理，提供了一个明显更快的开发服务器。&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;提示：当你对应用程序进行code-split和tree-shake动时，Vite的速度会更快，因为它只加载它需要的模块，即使是在开发阶段。这与Webpack不同，在Webpack中，代码拆分只对生产包有利。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Vite的缺点&lt;/h2&gt;&lt;section&gt;&lt;span&gt;你可能已经明白了，Vite的主要特点是它的开发服务器快得离谱。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果没有这个功能，可能就不会再讨论了，因为与Vue CLI相比，它确实没有其他的功能，而且确实有一些缺点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于Vite使用了JavaScript模块，所以最好让依赖关系也使用JavaScript模块。虽然大多数现代JS包都提供了这一点，但一些老的包可能只提供CommonJS模块。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Vite可以将CommonJS转换为JavaSript模块，但在一些边缘情况下它可能无法做到。当然，它还需要支持JavaScript模块的浏览器。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;与Webpack/Vue CLI不同，Vite无法创建针对旧版浏览器、web components等的捆绑包。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而且，与Vue CLI不同，开发服务器和构建工具是不同的系统，导致在生产与开发中可能出现不一致的行为。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Vue CLI vs Vite总结&lt;/h2&gt;&lt;table data-tool=&quot;mdnice编辑器&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;Vue CLI 优点&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Vue CLI 缺点&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;经历过战斗考验，可靠&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;开发服务器速度与依赖数量成反比&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;与Vue 2兼容&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;可以捆绑任何类型的依赖关系&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;插件生态系统&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;可以针对不同的目标进行构建&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table data-tool=&quot;mdnice编辑器&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;Vite 优点&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Vite 缺点&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;开发服务器比Webpack快10-100倍&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;只能针对现代浏览器（ES2015+）&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;将code-splitting作为优先事项&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;与CommonJS模块不完全兼容&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;处于测试阶段，仅支持Vue 3&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;最小的脚手架不包括Vuex、路由器等&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;不同的开发服务器与构建工具&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;span&gt;那么判决结果是什么？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于有经验的Vue开发来说，Vite是一个很好的选择，因为它的开发服务器速度快得离谱，让Webpack看起来像史前时代。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，对于喜欢一些手把手的Vue新开发人员来说，或者，对于使用遗留模块和需要复杂构建的大型项目来说，Vue CLI很可能在目前仍然是必不可少的。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Vite的未来&lt;/h2&gt;&lt;section&gt;&lt;span&gt;虽然上面的比较主要集中在Vite和Vue CLI的现状上，但仍有几点需要考虑：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;仅当浏览器中的JavaScript模块支持得到改善时，Vite才会有所改善。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;随着JS生态系统的追赶，更多的软件包将支持JavaScript模块，减少Vite无法处理的边缘情况。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Vite仍处于测试阶段--功能可能会有变化。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有可能Vue CLI最终会结合Vite，这样你就不用再使用其中一个了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;值得注意的是，Vite并不是唯一一个利用浏览器中JavaScript模块的开发服务器项目。还有更著名的 &lt;strong&gt;Snowpack&lt;/strong&gt; 甚至可能会挤掉Vite的发展。时间会证明这一点&lt;br/&gt;Snowpack：https://www.snowpack.dev/&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原文：https://vuejsdevelopers.com/2020/12/07/vite-vue-cli/&lt;br/&gt;作者：Anthony Gore&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;粉丝福利&lt;/h4&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;144期留言+在看幸运用户：暂无&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;临走前留下，&lt;span&gt;今天的福利&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;福利1：&lt;/span&gt;&lt;span&gt;&lt;span&gt;《教你玩转手机摄影，随手拍出好照片》&lt;/span&gt;&lt;span&gt;获取资源请在公众号对话框中回复关键字：&lt;/span&gt;&lt;span&gt;FL04，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;如果没有关注请扫下面的二维码&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;福利2：&lt;/span&gt;&lt;span&gt;在看+留言&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;我随机抽取一位认真留言的小伙伴，给他发一个红包奖励&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;最近文章&lt;/h4&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;点赞 + 在看 + 留言，下一个幸运儿就是你！&lt;br/&gt;走心的分享更容易被抽中~&lt;/span&gt;&lt;br/&gt;&lt;span&gt;开奖时间 下期文末&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5555555555555556&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0APOE4dXIpvXLgmGfqHMfYFFGudrHkx4trR7YbXKKmNCd3fJRlY56qIUibCibq00k2kky5DdPxrJCyWA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-type=&quot;gif&quot; data-ratio=&quot;0.1732283464566929&quot; data-w=&quot;635&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/aVp1YC8UV0fXSy8oK0h6qL36nlWgib6lHDTj0Ykkiab2FufBJIumwMrDEBZ1wHteh6pzsQiaP4007ox4ichic8pNw3Q/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b64bf80481fe3bc166db8cd2eb43cbc8</guid>
<title>互联网已经干得很好的事情，不应该是区块链干的</title>
<link>https://toutiao.io/k/gm708zx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;万向区块链&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;gh_1b8639a25429&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;2015年, 中国万向控股开始在区块链技术领域布局，成立了中国首个非营利性区块链研究机构“万向区块链实验室”。2017年，在进一步整合资源的基础上，上海万向区块链股份公司正式成立。&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7bc4d3f0b84ef3d61e1b43565fc93ed5</guid>
<title>上新了 Spring，全新一代类型转换机制</title>
<link>https://toutiao.io/k/b04brot</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKLLXbx6ciciaw2Z7AwC5oAyBqRgicGZnrPKlZPP8tnwvdHTQ9vfOI6XfJfBkKlNMZze9ibYBtazkc4jhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍前言&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是YourBatman。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247490866&amp;amp;idx=1&amp;amp;sn=9f9dafce23d861dc93dc5600852ab017&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;上篇文章&lt;/a&gt; 介绍完了Spring类型转换早期使用的PropertyEditor详细介绍，关于PropertyEditor现存的资料其实还蛮少的，希望这几篇文章能弥补这块空白，贡献一份微薄之力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你也吐槽过PropertyEditor不好用，那么本文将对会有帮助。Spring自&lt;strong&gt;3.0版本&lt;/strong&gt;开始自建了一套全新类型转换接口，这就是本文的主要内容，接下来逐步展开。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：Spring自3.0后笑傲群雄，进入大一统。Java从此步入Spring的时代&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;版本约定&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Spring Framework：5.3.1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Boot：2.4.0&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5807200929152149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKLLXbx6ciciaw2Z7AwC5oAyBqdqKrF5SGs4mianXm7g31wsic9UP9HLPzc1ZYc72SZuWBtbicVhMtm0RBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍正文&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解新一代的转换接口之前，先思考一个问题：&lt;strong&gt;Spring为何要自己造一套轮子呢？&lt;/strong&gt;  一向秉承不重复造轮子原则的Spring，不是迫不得已的话是不会去动他人奶酪的，毕竟互利共生才能长久。类型转换，作为Spring框架的基石，扮演着异常重要的角色，因此对其可扩展性、可维护性、高效性均有很高要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于此，我们先来了解下PropertyEditor设计上到底有哪些缺陷/不足（不能满足现代化需求），让Spring“被迫”走上了自建道路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;PropertyEditor设计缺陷&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前提说明：本文指出它的设计缺陷，只讨论把它当做类型转换器在转换场景下存在的一些缺陷。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;职责不单一：该接口有非常多的方法，但只用到2个而已&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类型不安全：setValue()方法入参是Object，getValue()返回值是Object，依赖于约定好的类型&lt;strong&gt;强转&lt;/strong&gt;，不安全&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程不安全：依赖于setValue()后getValue()，实例是线程不安全的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语义不清晰：从语义上根本不能知道它是用于类型转换的组件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;只能用于String类型&lt;/strong&gt;：它只能进行&lt;strong&gt;String &amp;lt;-&amp;gt; 其它类型&lt;/strong&gt;的转换，而非更灵活的&lt;strong&gt;Object &amp;lt;-&amp;gt; Object&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PropertyEditor存在这五宗“罪”，让Spring决定自己设计一套全新API用于专门服务于类型转换，这就是本文标题所述：新一代类型转换Converter、ConverterFactory、GenericConverter。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;关于PropertyEditor在Spring中的详情介绍，请参见文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247490866&amp;amp;idx=1&amp;amp;sn=9f9dafce23d861dc93dc5600852ab017&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;3. 搞定收工，PropertyEditor就到这&lt;/a&gt;&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;新一代类型转换&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决PropertyEditor作为类型转换方式的设计缺陷，Spring 3.0版本重新设计了一套类型转换接口，有3个核心接口：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Converter&amp;lt;S, T&amp;gt;&lt;/code&gt;：Source -&amp;gt; Target类型转换接口，适用于1:1转换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ConverterFactory&amp;lt;S, R&amp;gt;&lt;/code&gt;：Source -&amp;gt; R类型转换接口，适用于1:N转换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;GenericConverter&lt;/code&gt;：更为通用的类型转换接口，适用于N:N转换&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;注意：就它没有泛型约束，因为是通用&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，还有一个条件接口&lt;code&gt;ConditionalConverter&lt;/code&gt;，可跟上面3个接口搭配组合使用，提供前置条件判断验证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这套接口，解决了PropertyEditor做类型转换存在的&lt;strong&gt;所有缺陷&lt;/strong&gt;，且具有非常高的灵活性和可扩展性。下面进入详细了解。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Converter&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将源类型S转换为目标类型T。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@FunctionalInterface&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Converter&lt;/span&gt;&amp;lt;&lt;span&gt;S&lt;/span&gt;, &lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;T &lt;span&gt;convert&lt;/span&gt;&lt;span&gt;(S source)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是个函数式接口，接口定义非常简单。适合1:1转换场景：可以将任意类型 转换为 任意类型。它的实现类非常多，部分截图如下：&lt;img data-ratio=&quot;0.6566523605150214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKLLXbx6ciciaw2Z7AwC5oAyBqFGPicXc9haFjAic18EAlarm7keKud1BA6pP00vjWLxQxljT0oKdBf0yA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;466&quot;/&gt;值得注意的是：几乎所有实现类的访问权限都是&lt;code&gt;default/private&lt;/code&gt;，只有少数几个是public公开的，下面我用代码示例来“近距离”感受一下。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;代码示例&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * Converter：1:1&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;----------------StringToBooleanConverter---------------&quot;&lt;/span&gt;);&lt;br/&gt;    Converter&amp;lt;String, Boolean&amp;gt; converter = &lt;span&gt;new&lt;/span&gt; StringToBooleanConverter();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// trueValues.add(&quot;true&quot;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// trueValues.add(&quot;on&quot;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// trueValues.add(&quot;yes&quot;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// trueValues.add(&quot;1&quot;);&lt;/span&gt;&lt;br/&gt;    System.out.println(converter.convert(&lt;span&gt;&quot;true&quot;&lt;/span&gt;));&lt;br/&gt;    System.out.println(converter.convert(&lt;span&gt;&quot;1&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// falseValues.add(&quot;false&quot;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// falseValues.add(&quot;off&quot;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// falseValues.add(&quot;no&quot;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// falseValues.add(&quot;0&quot;);&lt;/span&gt;&lt;br/&gt;    System.out.println(converter.convert(&lt;span&gt;&quot;FalSe&quot;&lt;/span&gt;));&lt;br/&gt;    System.out.println(converter.convert(&lt;span&gt;&quot;off&quot;&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;// 注意：空串返回的是null&lt;/span&gt;&lt;br/&gt;    System.out.println(converter.convert(&lt;span&gt;&quot;&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;----------------StringToCharsetConverter---------------&quot;&lt;/span&gt;);&lt;br/&gt;    Converter&amp;lt;String, Charset&amp;gt; converter2 = &lt;span&gt;new&lt;/span&gt; StringToCharsetConverter();&lt;br/&gt;    &lt;span&gt;// 中间横杠非必须，但强烈建议写上   不区分大小写&lt;/span&gt;&lt;br/&gt;    System.out.println(converter2.convert(&lt;span&gt;&quot;uTf-8&quot;&lt;/span&gt;));&lt;br/&gt;    System.out.println(converter2.convert(&lt;span&gt;&quot;utF8&quot;&lt;/span&gt;));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，正常输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;----------------StringToBooleanConverter---------------&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;----------------StringToCharsetConverter---------------&lt;br/&gt;UTF-&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;UTF-&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明：StringToBooleanConverter/StringToCharsetConverter访问权限都是default，外部不可直接使用。此处为了做示例用到一个小技巧 -&amp;gt; &lt;strong&gt;将Demo的报名调整为和转换器的一样，这样就可以直接访问&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注点：true/on/yes/1都能被正确转换为&lt;code&gt;true&lt;/code&gt;的，且对于英文字母来说一般都不区分大小写，增加了容错性（包括Charset的转换）。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;不足&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Converter用于解决1:1的任意类型转换，因此它必然存在一个不足：解决1:N转换问题需要写N遍，造成重复冗余代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;譬如：输入是字符串，它可以转为任意数字类型，包括byte、short、int、long、double等等，如果用Converter来转换的话每个类型都得写个转换器，想想都麻烦有木有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring早早就考虑到了该场景，提供了相应的接口来处理，它就是&lt;code&gt;ConverterFactory&amp;lt;S, R&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;ConverterFactory&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从名称上看它代表一个转换工厂：可以将对象S转换为R的所有&lt;strong&gt;子类型&lt;/strong&gt;，从而形成1:N的关系。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;该接口描述为xxxFactory是非常合适的，很好的表达了1:N的关系&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ConverterFactory&lt;/span&gt;&amp;lt;&lt;span&gt;S&lt;/span&gt;, &lt;span&gt;R&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt; &amp;lt;T extends R&amp;gt; &lt;span&gt;Converter&amp;lt;S, T&amp;gt; &lt;span&gt;getConverter&lt;/span&gt;&lt;span&gt;(Class&amp;lt;T&amp;gt; targetType)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它同样也是个函数式接口。该接口的实现类并不多，Spring Framework共提供了5个内建实现（访问权限全部为default）：&lt;img data-ratio=&quot;0.2555746140651801&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKLLXbx6ciciaw2Z7AwC5oAyBq7uvVOxvjHQHOVj9YVnbMp9rdZDxJ97s6JmvBy8Ul3fHQyM6WBUa3hQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;583&quot;/&gt;以StringToNumberConverterFactory为例看看实现的套路：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StringToNumberConverterFactory&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ConverterFactory&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Number&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt; &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T extends Number&amp;gt; &lt;span&gt;Converter&amp;lt;String, T&amp;gt; &lt;span&gt;getConverter&lt;/span&gt;&lt;span&gt;(Class&amp;lt;T&amp;gt; targetType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; StringToNumber&amp;lt;T&amp;gt;(targetType);&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 私有内部类：实现Converter接口。用泛型边界约束一类类型&lt;/span&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StringToNumber&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Number&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Converter&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt; targetType;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;StringToNumber&lt;/span&gt;&lt;span&gt;(Class&amp;lt;T&amp;gt; targetType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;.targetType = targetType;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;convert&lt;/span&gt;&lt;span&gt;(String source)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (source.isEmpty()) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; NumberUtils.parseNumber(source, &lt;span&gt;this&lt;/span&gt;.targetType);&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由点知面，ConverterFactory作为Converter的工厂，对Converter进行包装，从而达到屏蔽内部实现的目的，对使用者友好，这不正是工厂模式的优点么，符合xxxFactory的语义。但你需要清除的是，工厂内部实现其实也是通过众多if else之类的去完成的，本质上并无差异。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;代码示例&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * ConverterFactory：1:N&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;----------------StringToNumberConverterFactory---------------&quot;&lt;/span&gt;);&lt;br/&gt;    ConverterFactory&amp;lt;String, Number&amp;gt; converterFactory = &lt;span&gt;new&lt;/span&gt; StringToNumberConverterFactory();&lt;br/&gt;    &lt;span&gt;// 注意：这里不能写基本数据类型。如int.class将抛错&lt;/span&gt;&lt;br/&gt;    System.out.println(converterFactory.getConverter(Integer&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;convert&lt;/span&gt;(&quot;1&quot;).&lt;span&gt;getClass&lt;/span&gt;())&lt;/span&gt;;&lt;br/&gt;    System.out.println(converterFactory.getConverter(Double&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;convert&lt;/span&gt;(&quot;1.1&quot;).&lt;span&gt;getClass&lt;/span&gt;())&lt;/span&gt;;&lt;br/&gt;    System.out.println(converterFactory.getConverter(Byte&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;convert&lt;/span&gt;(&quot;0&lt;span&gt;x11&lt;/span&gt;&quot;).&lt;span&gt;getClass&lt;/span&gt;())&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，正常输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;----------------StringToNumberConverterFactory---------------&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;.&lt;span&gt;lang&lt;/span&gt;.&lt;span&gt;Integer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;.&lt;span&gt;lang&lt;/span&gt;.&lt;span&gt;Double&lt;/span&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;.&lt;span&gt;lang&lt;/span&gt;.&lt;span&gt;Byte&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注点：数字类型的字符串，是可以被转换为任意Java中的数字类型的，&lt;code&gt;String(1) -&amp;gt; Number(N)&lt;/code&gt;。这便就是ConverterFactory的功劳，它能处理这一类转换问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;不足&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然有了1:1、1:N，自然就有N:N。比如集合转换、数组转换、Map到Map的转换等等，这些N:N的场景，就需要借助下一个接口GenericConverter来实现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;GenericConverter&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是一个&lt;strong&gt;通用的&lt;/strong&gt;转换接口，用于在两个或多个类型之间进行转换。相较于前两个，这是&lt;strong&gt;最灵活&lt;/strong&gt;的SPI转换器接口，但也是&lt;strong&gt;最复杂&lt;/strong&gt;的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;GenericConverter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt; &lt;span&gt;Set&amp;lt;ConvertiblePair&amp;gt; &lt;span&gt;getConvertibleTypes&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;Object &lt;span&gt;convert&lt;/span&gt;&lt;span&gt;(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt; &lt;br/&gt; &lt;span&gt;// 普通POJO&lt;/span&gt;&lt;br/&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConvertiblePair&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt; sourceType;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt; targetType;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该接口并非函数式接口，虽然方法不多但稍显复杂。现对出现的几个类型做简单介绍：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ConvertiblePair&lt;/code&gt;：维护sourceType和targetType的POJO&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;getConvertibleTypes()方法返回此Pair的&lt;strong&gt;Set集合&lt;/strong&gt;。由此也能看出该转换器是可以支持N:N的（大多数情况下只写一对值而已，也有写多对的）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;TypeDescriptor&lt;/code&gt;：类型描述。该类专用于Spring的类型转换场景，用于描述from or to的类型&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;比单独的Type类型强大，内部借助了ResolvableType来解决泛型议题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GenericConverter的内置实现也比较多，部分截图如下：&lt;img data-ratio=&quot;0.6823308270676691&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKLLXbx6ciciaw2Z7AwC5oAyBqW7MoTAIE74V28lUEsXHrr3X5LwzOibfCnBv2N8C6Alrqcfq60BxLDjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;532&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;&lt;code&gt;ConditionalGenericConverter&lt;/code&gt;是GenericConverter和条件接口ConditionalConverter的组合，作用是在执行GenericConverter转换时增加一个&lt;strong&gt;前置条件判断&lt;/strong&gt;方法。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;转换器&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;th&gt;示例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;ArrayToArrayConverter&lt;/td&gt;&lt;td&gt;数组转数组Object[] -&amp;gt; Object[]&lt;/td&gt;&lt;td&gt;[&quot;1&quot;,&quot;2&quot;] -&amp;gt; [1,2]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ArrayToCollectionConverter&lt;/td&gt;&lt;td&gt;数组转集合 Object[] -&amp;gt; Collection&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CollectionToCollectionConverter&lt;/td&gt;&lt;td&gt;数组转集合 Collection -&amp;gt; Collection&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;StringToCollectionConverter&lt;/td&gt;&lt;td&gt;字符串转集合String -&amp;gt; Collection&lt;/td&gt;&lt;td&gt;1,2 -&amp;gt; [1,2]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;StringToArrayConverter&lt;/td&gt;&lt;td&gt;字符串转数组String -&amp;gt; Array&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MapToMapConverter&lt;/td&gt;&lt;td&gt;Map -&amp;gt; Map(需特别注意：key和value都支持转换才行)&lt;/td&gt;&lt;td&gt;略&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CollectionToStringConverter&lt;/td&gt;&lt;td&gt;集合转字符串Collection -&amp;gt; String&lt;/td&gt;&lt;td&gt;[1,2] -&amp;gt; 1,2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ArrayToStringConverter&lt;/td&gt;&lt;td&gt;委托给CollectionToStringConverter完成&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;「StreamConverter」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;集合/数组 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; Stream互转&lt;/td&gt;&lt;td&gt;集合/数组类型 -&amp;gt; Stream类型&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;「IdToEntityConverter」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;ID-&amp;gt;Entity的转换&lt;/td&gt;&lt;td&gt;传入任意类型ID -&amp;gt; 一个Entity实例&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;「ObjectToObjectConverter」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;很复杂的对象转换，任意对象之间&lt;/td&gt;&lt;td&gt;obj -&amp;gt; obj&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;「FallbackObjectToStringConverter」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;上个转换器的兜底，调用Obj.toString()转换&lt;/td&gt;&lt;td&gt;obj -&amp;gt; String&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：分割线下面的4个转换器比较特殊，字面上不好理解其实际作用，比较“高级”。它们如果能被运用在日常工作中可以&lt;strong&gt;事半功弎&lt;/strong&gt;，因此放在在下篇文章专门给你介绍&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面以CollectionToCollectionConverter为例分析此转换器的“复杂”之处：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionToCollectionConverter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ConditionalGenericConverter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConversionService conversionService;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CollectionToCollectionConverter&lt;/span&gt;&lt;span&gt;(ConversionService conversionService)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.conversionService = conversionService;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;br/&gt; &lt;span&gt;// 集合转集合：如String集合转为Integer集合&lt;/span&gt;&lt;br/&gt; &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;ConvertiblePair&amp;gt; &lt;span&gt;getConvertibleTypes&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Collections.singleton(&lt;span&gt;new&lt;/span&gt; ConvertiblePair(Collection&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;Collection&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是唯一构造器，必须传入ConversionService：元素与元素之间的转换是依赖于conversionService转换服务去完成的，最终完成集合到集合的转换。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CollectionToCollectionConverter：&lt;br/&gt;&lt;br/&gt; &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;matches&lt;/span&gt;&lt;span&gt;(TypeDescriptor sourceType, TypeDescriptor targetType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ConversionUtils.canConvertElements(sourceType.getElementTypeDescriptor(), targetType.getElementTypeDescriptor(), &lt;span&gt;this&lt;/span&gt;.conversionService);&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判断能否转换的依据：集合里的&lt;strong&gt;元素与元素之间&lt;/strong&gt;是否能够转换，底层依赖于&lt;code&gt;ConversionService#canConvert()&lt;/code&gt;这个API去完成判断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来再看&lt;strong&gt;最复杂&lt;/strong&gt;的转换方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CollectionToCollectionConverter：&lt;br/&gt;&lt;br/&gt; &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;convert&lt;/span&gt;&lt;span&gt;(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (source == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  Collection&amp;lt;?&amp;gt; sourceCollection = (Collection&amp;lt;?&amp;gt;) source;&lt;br/&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// 判断：这些情况下，将不用执行后续转换动作了，直接返回即可&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;boolean&lt;/span&gt; copyRequired = !targetType.getType().isInstance(source);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!copyRequired &amp;amp;&amp;amp; sourceCollection.isEmpty()) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; source;&lt;br/&gt;  }&lt;br/&gt;  TypeDescriptor elementDesc = targetType.getElementTypeDescriptor();&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (elementDesc == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !copyRequired) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; source;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  Collection&amp;lt;Object&amp;gt; target = CollectionFactory.createCollection(targetType.getType(),&lt;br/&gt;    (elementDesc != &lt;span&gt;null&lt;/span&gt; ? elementDesc.getType() : &lt;span&gt;null&lt;/span&gt;), sourceCollection.size());&lt;br/&gt;  &lt;span&gt;// 若目标类型没有指定泛型（没指定就是Object），不用遍历直接添加全部即可&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (elementDesc == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   target.addAll(sourceCollection);&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// 遍历：一个一个元素的转，时间复杂度还是蛮高的&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// 元素转元素委托给conversionService去完成&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; (Object sourceElement : sourceCollection) {&lt;br/&gt;    Object targetElement = &lt;span&gt;this&lt;/span&gt;.conversionService.convert(sourceElement,&lt;br/&gt;      sourceType.elementTypeDescriptor(sourceElement), elementDesc);&lt;br/&gt;    target.add(targetElement);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (sourceElement != targetElement) {&lt;br/&gt;     copyRequired = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (copyRequired ? target : source);&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该转换步骤稍微有点复杂，我帮你屡清楚后有这几个关键步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;快速返回：对于特殊情况，做快速返回处理&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;源集合为空，还转换个啥&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;目标集合没指定泛型，那就是Object，因此可以接纳一切，还转换个啥&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若目标元素类型是&lt;strong&gt;源&lt;/strong&gt;元素类型的子类型（或相同），就没有转换的必要了（copyRequired = false）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若源集合为空，或者目标集合&lt;strong&gt;没指定泛型&lt;/strong&gt;，也不需要做转换动作&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;若没有触发快速返回。给目标创建一个&lt;strong&gt;新集合&lt;/strong&gt;，然后把source的元素&lt;strong&gt;一个一个的&lt;/strong&gt;放进新集合里去，这里又分为两种处理case&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若新集合（目标集合）没有指定泛型类型（那就是Object），就直接putAll即可，并不需要做类型转换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若新集合（目标集合指定了泛型类型），就&lt;strong&gt;遍历&lt;/strong&gt;源集合委托&lt;code&gt;conversionService.convert()&lt;/code&gt;对元素一个一个的转&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;代码示例&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以CollectionToCollectionConverter做示范：&lt;code&gt;List&amp;lt;String&amp;gt; -&amp;gt; Set&amp;lt;Integer&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;----------------CollectionToCollectionConverter---------------&quot;&lt;/span&gt;);&lt;br/&gt;    ConditionalGenericConverter conditionalGenericConverter = &lt;span&gt;new&lt;/span&gt; CollectionToCollectionConverter(&lt;span&gt;new&lt;/span&gt; DefaultConversionService());&lt;br/&gt;    &lt;span&gt;// 将Collection转为Collection（注意：没有指定泛型类型哦）&lt;/span&gt;&lt;br/&gt;    System.out.println(conditionalGenericConverter.getConvertibleTypes());&lt;br/&gt;&lt;br/&gt;    List&amp;lt;String&amp;gt; sourceList = Arrays.asList(&lt;span&gt;&quot;1&quot;&lt;/span&gt;, &lt;span&gt;&quot;2&quot;&lt;/span&gt;, &lt;span&gt;&quot;2&quot;&lt;/span&gt;, &lt;span&gt;&quot;3&quot;&lt;/span&gt;, &lt;span&gt;&quot;4&quot;&lt;/span&gt;);&lt;br/&gt;    TypeDescriptor sourceTypeDesp = TypeDescriptor.collection(List&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;TypeDescriptor&lt;/span&gt;.&lt;span&gt;valueOf&lt;/span&gt;(&lt;span&gt;String&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;    TypeDescriptor targetTypeDesp = TypeDescriptor.collection(Set&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;TypeDescriptor&lt;/span&gt;.&lt;span&gt;valueOf&lt;/span&gt;(&lt;span&gt;Integer&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    System.out.println(conditionalGenericConverter.matches(sourceTypeDesp, targetTypeDesp));&lt;br/&gt;    Object convert = conditionalGenericConverter.convert(sourceList, sourceTypeDesp, targetTypeDesp);&lt;br/&gt;    System.out.println(convert.getClass());&lt;br/&gt;    System.out.println(convert);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，正常输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[java.util.Collection -&amp;gt; java.util.Collection]&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;.&lt;span&gt;util&lt;/span&gt;.&lt;span&gt;LinkedHashSet&lt;/span&gt;&lt;br/&gt;[1, 2, 3, 4]&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注点：target最终使用的是LinkedHashSet来存储，这结果和&lt;code&gt;CollectionFactory#createCollection&lt;/code&gt;该API的实现逻辑是相关（Set类型默认创建的是LinkedHashSet实例）。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;不足&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说它的优点是功能强大，能够处理复杂类型的转换（PropertyEditor和前2个接口都只能转换&lt;strong&gt;单元素&lt;/strong&gt;类型），那么缺点就是使用、自定义实现起来比较复杂。这不&lt;strong&gt;官方&lt;/strong&gt;也给出了使用指导意见：在Converter/ConverterFactory接口能够满足条件的情况下，可不使用此接口就不使用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;ConditionalConverter&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;条件接口，@since 3.2。它可以为Converter、GenericConverter、ConverterFactory转换增加一个&lt;strong&gt;前置判断条件&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ConditionalConverter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;matches&lt;/span&gt;&lt;span&gt;(TypeDescriptor sourceType, TypeDescriptor targetType)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该接口的实现，截图如下：&lt;img data-ratio=&quot;1.022887323943662&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKLLXbx6ciciaw2Z7AwC5oAyBqCYs4Ov0l3LER2OiazHmhJc53GTeJuqjJGTBxP2lgGRjf9hIamA2g2zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;可以看到，只有通用转换器GenericConverter和它进行了&lt;strong&gt;合体&lt;/strong&gt;。这也很容易理解，作为通用的转换器，加个前置判断将更加严谨和更安全。对于专用的转换器如Converter，它已明确规定了转换的类型，自然就不需要做前置判断喽。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文详细介绍了Spring新一代的类型转换接口，类型转换作为Spring的基石，其重要性可见一斑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PropertyEditor作为Spring早期使用“转换器”，因存在众多设计缺陷自Spring 3.0起被新一代转换接口所取代，主要有：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Converter&amp;lt;S, T&amp;gt;&lt;/code&gt;：Source -&amp;gt; Target类型转换接口，适用于1:1转换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ConverterFactory&amp;lt;S, R&amp;gt;&lt;/code&gt;：Source -&amp;gt; R类型转换接口，适用于1:N转换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;GenericConverter&lt;/code&gt;：更为通用的类型转换接口，适用于N:N转换&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下篇文章将针对于GenericConverter的几个特殊实现撰专文为你讲解，你也知道做难事必有所得，做难事才有可能破局、破圈，欢迎保持关注。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;✔✔✔推荐阅读✔✔✔&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【Spring类型转换】系列：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【Jackson】系列：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【数据校验Bean Validation】系列：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【新特性】系列：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【程序人生】系列：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有诸如【Spring配置类】【Spring-static】【Spring数据绑定】【Spring Cloud Netflix】【Feign】【Ribbon】【Hystrix】...更多原创专栏，关注&lt;code&gt;BAT的乌托邦&lt;/code&gt;回复&lt;code&gt;专栏&lt;/code&gt;二字即可全部获取，分享、成长，拒绝浅藏辄止。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;有些专栏&lt;strong&gt;已完结&lt;/strong&gt;，有些正在&lt;strong&gt;连载中&lt;/strong&gt;，期待你的关注、共同进步&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>32ccb72bc3f7f8dcb2e0eb6a2a4ff736</guid>
<title>Golang 语言怎么使用 Viper 管理配置信息？</title>
<link>https://toutiao.io/k/dx10rju</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;什么是 Viper？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Viper 是适用于 Go 应用程序（包括 Twelve-Factor App）的完整配置解决方案。它被设计为在应用程序中工作，并且可以处理所有类型的配置需求和格式。它支持：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以将 Viper 视为满足您所有应用程序配置需求的注册表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;为什么使用 Viper？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在构建现代应用程序时，您无需担心配置文件格式；您想专注于构建出色的软件。Viper 的出现就是为了在这方面给您提供帮助。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Viper 为您执行以下操作：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;查找，加载和反序列化 JSON，TOML，YAML，HCL，INI，envfile 或 Java properties 格式的配置文件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提供一种机制来为您的不同配置选项设置默认值。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提供一种机制来通过命令行参数覆盖指定的选项的值。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提供别名系统，以在不会破坏现有代码的情况下轻松重命名参数。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户提供了与默认值相同的命令行或配置文件时，可以容易地于区分它们的区别。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Viper 使用以下优先顺序。每个项目优先于其下面的项目：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;显式调用 Set 方法设置值&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;flag（命令行参数）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;env（环境变量）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;config（配置文件）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;key/value 存储&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;默认值&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;重要：&lt;/strong&gt;Viper 配置项的 Key 不区分大小写。正在讨论是否设置为可选项。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;怎么将配置项写入 Viper？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;安装&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go &lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt; github.com/spf13/viper&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;建立默认值&lt;/span&gt;&lt;/p&gt;&lt;p&gt;一个好的配置系统应该支持默认值。默认值对于 Key 不是必须的，但是如果未通过配置文件，环境变量，远程配置或标志（flag）设置 Key 的值，那么 Key 的默认值很有用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;示例：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.SetDefault(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ContentDir&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;content&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.SetDefault(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;LayoutDir&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;layouts&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.SetDefault(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Taxonomies&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;]&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;{&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;tag&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;tags&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;category&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;categories&quot;&lt;/span&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读取配置文件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Viper 需要最少的配置，以便它知道在哪里寻找配置文件。Viper 支持JSON，TOML，YAML，HCL，INI，envfile 和 Java Properties 格式的文件。Viper 可以搜索多个路径，但是当前单个 Viper 实例仅支持单个配置文件。Viper 不会默认使用任何配置搜索路径，而会将默认决定留给应用程序。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面是如何使用 Viper 搜索和读取配置文件的示例。不需要任何特定路径，但至少需要提供一个配置文件的预期路径（见代码 3-5 行）。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.SetConfigName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;config&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.SetConfigType(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yaml&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.AddConfigPath(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/etc/appname/&quot;&lt;/span&gt;)   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.AddConfigPath(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;$HOME/.appname&quot;&lt;/span&gt;)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.AddConfigPath(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;.&quot;&lt;/span&gt;)               &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;err := viper.ReadInConfig() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;panic&lt;/span&gt;(fmt.Errorf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Fatal error config file: %s \n&quot;&lt;/span&gt;, err))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;您可以处理未找到配置文件的特定情况，如下所示：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err := viper.ReadInConfig(); err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; _, ok := err.(viper.ConfigFileNotFoundError); ok {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注意 &lt;/strong&gt;[自 1.6]：您也可以有一个没有扩展名的文件， 并以编程方式指定格式。对于位于用户 $HOME 目录中的配置文件，没有任何扩展名，如 .bashrc&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;写入配置文件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;从配置文件中读取文件很有用，但有时您希望存储运行时所做的所有修改。为此，有一堆命令可用，每个命令都有自己的用途：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;WriteConfig - 将当前 viper 配置写入预定义路径并覆盖（如果存在）。如果没有预定义的路径，则返回错误。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SafeWriteConfig - 将当前 viper 配置写入预定义路径。如果没有预定义的路径，则返回错误。如果存在，不会覆盖当前配置文件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;WriteConfigAs - 将当前 viper 配置写入给定的文件路径。将覆盖给定的文件（如果存在）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SafeWriteConfigAs - 将当前 viper 配置写入给定的文件路径。如果存在，不会覆盖给定文件。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;根据经验，所有标有 safe 标记的方法都不会覆盖任何文件，而是直接创建（如果不存在），而默认行为是创建或截断。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一个小示例：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.WriteConfig() // writes current config to predefined path &lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;viper.AddConfigPath()&#x27;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;viper.SetConfigName&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.SafeWriteConfig()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.WriteConfigAs(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/path/to/my/.config&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.SafeWriteConfigAs(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/path/to/my/.config&quot;&lt;/span&gt;) // will &lt;span class=&quot;code-snippet__keyword&quot;&gt;error&lt;/span&gt; since it has already been written&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.SafeWriteConfigAs(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/path/to/my/.other_config&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;监控和重新读取配置文件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Viper 支持在运行时让应用程序实时读取配置文件的能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;需要重新启动服务器才能使配置生效的日子已经一去不复返了，viper 支持的应用程序可以在运行时读取对配置文件的更新，并且不会错过任何更新。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;只需告诉 viper 实例 watchConfig。您可以为 Viper 提供一个回调函数，在每次发生更改时运行的该函数。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;请确保在调用 WatchConfig() 之前添加了所有配置路径&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.&lt;span class=&quot;code-snippet__type&quot;&gt;WatchConfig&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.&lt;span class=&quot;code-snippet__type&quot;&gt;OnConfigChange&lt;/span&gt;(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(e fsnotify.Event)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__type&quot;&gt;Println&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Config file changed:&quot;&lt;/span&gt;, e.&lt;span class=&quot;code-snippet__type&quot;&gt;Name&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从 io.Reader 读取配置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Viper 预定义许多配置源（如文件、环境变量、命令行参数和远程 K/V 存储，但您不受他们的约束。您还可以实现自己所需的配置源，并提供给 viper。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.SetConfigType(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yaml&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; yamlExample = []&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;(`&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Hacker: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;name: steve&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;hobbies:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;- skateboarding&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;- snowboarding&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;- go&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;clothing:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  jacket: leather&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  trousers: denim&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;age: &lt;span class=&quot;code-snippet__number&quot;&gt;35&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;eyes : brown&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;beard: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;`)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.ReadConfig(bytes.NewBuffer(yamlExample))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.Get(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;name&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;覆盖设置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这些可能是来自命令行参数，也可以来自您自己的应用程序逻辑。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.Set(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Verbose&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.Set(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;LogFile&quot;&lt;/span&gt;, LogFile)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注册和使用别名&lt;/span&gt;&lt;/p&gt;&lt;p&gt;别名允许由多个键引用单个值&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.RegisterAlias(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;loud&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Verbose&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.Set(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;verbose&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.Set(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;loud&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;)   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.GetBool(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;loud&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.GetBool(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;verbose&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用环境变量&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Viper 完全支持环境变量。这使 Twelve-Factor App 开箱即用。有五种方法可以帮助使用 ENV：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用 ENV 变量时，必须认识到 Viper 将 ENV 变量视为对大小敏感。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Viper 提供了一种机制，用于尝试确保 ENV 变量是唯一的。通过使用 SetEnvPrefix，您可以告诉 Viper 在从环境变量读取时使用前缀。BindEnv 和AutomaticEnv 都将使用前缀。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;BindEnv 采用一个或多个参数。第一个参数是键名称，其余参数是要绑定到此键的环境变量的名称。如果提供了多个，它们将按指定顺序优先。环境变量的名称是大小写敏感。如果未提供 ENV 变量名称，则 Viper 将自动假定 ENV 变量与以下格式匹配：前缀 + &quot;_&quot; + 所有 CAPS 中的键名称。当您显式提供 ENV 变量名称（第二个参数）时，它不会自动添加前缀。例如，如果第二个参数为&quot;id&quot;，Viper 将查找 ENV 变量&quot;ID&quot;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用 ENV 变量时，需要注意的一个重要问题是每次访问该值时都会重新读取该值。调用 BindEnv 时，viper 不会固定该值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;AutomaticEnv 是一个强大的帮助器，尤其是当与SerenvPrefix 结合。调用时，viper 将会在发出 viper.Get 请求时&lt;span&gt;，&lt;/span&gt;随时检查环境变量。它将应用以下规则。如果使用 EnvPrefix 设置了前缀，它将检查一个环境变量的名称是否与键匹配。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;SetEnvKeyReplacer 允许您使用 strings.Replacer 对象将 Env 键在一定程度上重写。如果您想要使用 - 或者其它符号在 Get() 调用中，但希望环境变量使用 _ 分隔符，这非常有用。使用它的示例可以在 viper_test.go 中找到。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;或者，您也可以将 EnvKeyReplacer 与 NewWithOptions 工厂函数一起使用。与 SetEnvKeyReplacer 不同，它接受 StringReplacer 接口，允许您编写自定义字符串替换逻辑。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;默认情况下，空环境变量被视为未设置，并将回退到下一个配置源。若要将空环境变量视为已设置，请使用 AllowEmptyEnv 方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;环境变量-示例代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SetEnvPrefix(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;spf&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;BindEnv(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;id&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;os.Setenv(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;SPF_ID&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;13&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt; := Get(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;id&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用 Flags&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Viper 能够绑定到 flags。具体来说，viper 支持 Cobra 库中使用的 Pflags。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;与 BindEnv 一样，在调用绑定方法时，不会设置该值，而是在访问绑定方法时设置该值。这意味着您可以尽早绑定，即使在 init() 函数中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于单个 Flag，BindPFlag() 方法提供此功能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;serverCmd&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Flags&lt;/span&gt;()&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Int&lt;/span&gt;(&quot;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;port&lt;/span&gt;&quot;, 1138, &quot;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Port&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Application&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;on&lt;/span&gt;&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;viper&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.BindPFlag&lt;/span&gt;(&quot;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;port&lt;/span&gt;&quot;, &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;serverCmd&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Flags&lt;/span&gt;()&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Lookup&lt;/span&gt;(&quot;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;port&lt;/span&gt;&quot;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;您还可以绑定一组现有的 pflags（pflag.FlagSet）：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pflag.Int(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;flagname&quot;&lt;/span&gt;, 1234, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;help message for flagname&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pflag.Parse()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.BindPFlags(pflag.CommandLine)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;i := viper.GetInt(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;flagname&quot;&lt;/span&gt;) // retrieve values from viper instead of pflag&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 Viper 中使用 pflag 并不阻碍&lt;span&gt;其他包中&lt;/span&gt;使用标准库中的 flag 包。pflag 包可以通过导入这些 flags 来处理为 flag 包定义的 flags。这是通过调用一个&lt;span&gt;pflag 包提供的便利&lt;/span&gt;函数&lt;span&gt; AddGoFlagSet() &lt;/span&gt;实现的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;flag&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;github.com/spf13/pflag&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  flag.Int(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;flagname&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;1234&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;help message for flagname&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  pflag.CommandLine.AddGoFlagSet(flag.CommandLine)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  pflag.Parse()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  viper.BindPFlags(pflag.CommandLine)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  i := viper.GetInt(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;flagname&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;flag 接口&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果您不使用 Pflags，&lt;/span&gt;Viper 提供两个 Go 接口来绑定其他 flag 系统。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;FlagValue 表示单个 flag。这是一个说明如何实现此接口的非常简单的示例：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; myFlag &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(f myFlag)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;HasChanged&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; { &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(f myFlag)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; { &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-flag-name&quot;&lt;/span&gt; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(f myFlag)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ValueString&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; { &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-flag-value&quot;&lt;/span&gt; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(f myFlag)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ValueType&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; { &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;string&quot;&lt;/span&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一旦您的 flag 实现此接口，您只需告诉 Viper 将其绑定：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;viper&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.BindFlagValue&lt;/span&gt;(&quot;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;my-flag-name&lt;/span&gt;&quot;, &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;myFlag&lt;/span&gt;{})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;FlagValueSet&lt;span&gt; &lt;/span&gt;表示一组 flags。这是一个说明如何实现此接口的非常简单的示例：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; myFlagSet &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  flags []myFlag&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(f myFlagSet)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;VisitAll&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(fn &lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;(FlagValue)&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; _, flag := &lt;span class=&quot;code-snippet__keyword&quot;&gt;range&lt;/span&gt; flags {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    fn(flag)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一旦您的 flag 集合实现此接口，您只需告诉 Viper 绑定它：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fSet := myFlagSet{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  flags: []myFlag{myFlag{}, myFlag{}},&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.BindFlagValues(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-flags&quot;&lt;/span&gt;, fSet)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;远程 Key/Value 存储支持&lt;/span&gt;&lt;/p&gt;&lt;p&gt;若要在 Viper 中启用远程支持，请对 viper/remote 包进行空白导入：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; _ &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;github.com/spf13/viper/remote&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Viper 将读取从 Key/Value 存储（例如 etcd 或 Consul ）中的路径检索到的配置字符串（如JSON，TOML，YAML，HCL 或 envfile）。这些值优先级高于默认值，但会被从磁盘，命令行参数（flag）或环境变量检索的配置值覆盖。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Viper 使用 crypt 从 K / V 存储中检索配置，这意味着如果您具有正确的 gpg 密钥，您可以将配置值加密后存储，并可以自动将其解密。加密是可选的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;您可以将远程配置与本地配置结合使用，也可以独立使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;crypt 有一个命令行帮助程序，您可以用来将配置放入 K / V 存储中。crypt 默认使用在 http://127.0.0.1:4001 上的 etcd。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; go get github.com/bketelsen/crypt/bin/crypt&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; crypt &lt;span class=&quot;code-snippet__built_in&quot;&gt;set&lt;/span&gt; -plaintext /config/hugo.json /Users/hugo/settings/config.json&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;确认已设置值：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; crypt get -plaintext /config/hugo.json&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有关如何设置加密值或如何使用 Consul 的示例，请参见 crypt 文档。&lt;/p&gt;&lt;p&gt;https://github.com/bketelsen/crypt&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;远程 Key/Value 存储示例 - 未加密&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;etcd&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.AddRemoteProvider(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;etcd&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;http://127.0.0.1:4001&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/config/hugo.json&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.SetConfigType(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;json&quot;&lt;/span&gt;) // because there is no file extension in a stream of bytes, supported extensions are &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;json&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;toml&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yaml&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yml&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;properties&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;props&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;prop&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;env&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;dotenv&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;err := viper.ReadRemoteConfig()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Consul&lt;/span&gt;&lt;/p&gt;&lt;p&gt;您需要使用具有所需配置的 JSON 值设置 Consul 存储中的 key。例如，创建一个具有 JSON 值得 Consul key/value &lt;span&gt;存储的 &lt;/span&gt;key MY_CONSUL_KEY。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;port&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;8080&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;hostname&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;myhostname.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.AddRemoteProvider(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;consul&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;localhost:8500&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;MY_CONSUL_KEY&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.SetConfigType(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;json&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;err := viper.ReadRemoteConfig()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fmt.Println(viper.Get(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;port&quot;&lt;/span&gt;)) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fmt.Println(viper.Get(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;hostname&quot;&lt;/span&gt;)) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Firestore&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.AddRemoteProvider(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;firestore&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;google-cloud-project-id&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;collection/document&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.SetConfigType(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;json&quot;&lt;/span&gt;) // Config&#x27;s format: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;json&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;toml&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yaml&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yml&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;err := viper.ReadRemoteConfig()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;当然，您也可以使用 SecureRemoteProvider&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;远程 Key/Value 存储示例 - 加密&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.AddSecureRemoteProvider(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;etcd&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;http://127.0.0.1:4001&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/config/hugo.json&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/etc/secrets/mykeyring.gpg&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.SetConfigType(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;json&quot;&lt;/span&gt;) // because there &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; no file extension &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; a stream of bytes,  supported extensions are &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;json&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;toml&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yaml&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yml&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;properties&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;props&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;prop&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;env&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;dotenv&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;err := viper.ReadRemoteConfig()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;监控 etcd 中的更改 - 未加密&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// alternatively, you can &lt;span class=&quot;code-snippet__keyword&quot;&gt;create&lt;/span&gt; a &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; viper instance.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; runtime_viper = viper.New()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;runtime_viper.AddRemoteProvider(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;etcd&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;http://127.0.0.1:4001&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/config/hugo.yml&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;runtime_viper.SetConfigType(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yaml&quot;&lt;/span&gt;) // because there &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;file&lt;/span&gt; extension &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; a stream &lt;span class=&quot;code-snippet__keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;bytes&lt;/span&gt;, supported extensions &lt;span class=&quot;code-snippet__keyword&quot;&gt;are&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;json&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;toml&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yaml&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yml&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;properties&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;props&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;prop&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;env&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;dotenv&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// &lt;span class=&quot;code-snippet__keyword&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; remote config the &lt;span class=&quot;code-snippet__keyword&quot;&gt;first&lt;/span&gt; time.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;err := runtime_viper.ReadRemoteConfig()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// unmarshal config&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;runtime_viper.Unmarshal(&amp;amp;runtime_conf)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// &lt;span class=&quot;code-snippet__keyword&quot;&gt;open&lt;/span&gt; a goroutine &lt;span class=&quot;code-snippet__keyword&quot;&gt;to&lt;/span&gt; watch remote changes forever&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; func(){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      time.Sleep(time.Second * &lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;) // delay &lt;span class=&quot;code-snippet__keyword&quot;&gt;after&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;each&lt;/span&gt; request&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      // currently, &lt;span class=&quot;code-snippet__keyword&quot;&gt;only&lt;/span&gt; tested &lt;span class=&quot;code-snippet__keyword&quot;&gt;with&lt;/span&gt; etcd support&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      err := runtime_viper.WatchRemoteConfig()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          log.Errorf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;unable to read remote config: %v&quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          continue&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      // unmarshal &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; config &lt;span class=&quot;code-snippet__keyword&quot;&gt;into&lt;/span&gt; our runtime config struct. you can also &lt;span class=&quot;code-snippet__keyword&quot;&gt;use&lt;/span&gt; channel&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      // &lt;span class=&quot;code-snippet__keyword&quot;&gt;to&lt;/span&gt; implement a signal &lt;span class=&quot;code-snippet__keyword&quot;&gt;to&lt;/span&gt; notify the &lt;span class=&quot;code-snippet__keyword&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;of&lt;/span&gt; the changes&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      runtime_viper.Unmarshal(&amp;amp;runtime_conf)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;怎么在 Viper 中获取配置项？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 Viper 中，有几种&lt;span&gt;根据值的类型&lt;/span&gt;获取值的方法。存在以下功能和方法：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Get(key string) : interface{}&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GetBool(key string) : bool&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GetFloat64(key string) : float64&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GetInt(key string) : int&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GetIntSlice(key string) : []int&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GetString(key string) : string&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GetStringMap(key string) : map[string]interface{}&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GetStringMapString(key string) : map[string]string&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GetStringSlice(key string) : []string&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GetTime(key string) : time.Time&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GetDuration(key string) : time.Duration&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;IsSet(key string) : bool&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;AllSettings() : map[string]interface{}&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;认识到的一件重要事情是，每个 Get 函数&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;找&lt;/span&gt;&lt;span&gt;不到值&lt;/span&gt;，它将返回零值。为了检查给定键是否存在，提供了 IsSet() 方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;viper.GetString(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;logfile&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; viper.GetBool(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;verbose&quot;&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;verbose enabled&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;访问嵌套键&lt;/span&gt;&lt;/p&gt;&lt;p&gt;访问器方法还接受深度嵌套键的格式化路径。例如，如果加载了以下JSON文件：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;host&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;address&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;localhost&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;port&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;5799&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;datastore&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;metric&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;host&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;port&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;3099&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;warehouse&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;host&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;198.0.0.1&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;port&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;2112&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Viper 可以通过传递「.」&lt;span&gt;分隔键的路径&lt;/span&gt;来访问嵌套字段：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;GetString(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;datastore.metric.host&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;遵守上面建立的优先级规则；搜索路径将遍历其余配置注册表，直到找到为止。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如，在给定此配置文件的情况下，datastore.metric.host 和 datastore.metric.port 均已定义（并且可以被覆盖）。如果另外在默认设置中定义了 datastore.metric.protocol，Viper 也会找到它。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是，如果 datastore.metric 被直接赋值覆盖（通过 flag，环境变量，Set() 方法等），则 datastore.metric 的所有子键也都变为未定义状态，它们被较高的优先级配置遮蔽（&lt;span&gt;shadowed&lt;/span&gt;）了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Viper 可以使用路径中的数字访问数组索引。例如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;host&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;address&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;localhost&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ports&quot;&lt;/span&gt;: [&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__number&quot;&gt;5799&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__number&quot;&gt;6029&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;datastore&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;metric&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;host&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;port&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;3099&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;warehouse&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;host&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;198.0.0.1&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;port&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;2112&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;GetInt(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;host.ports.1&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后，如果存在与分隔的键路径匹配的键，则将返回其值。例如&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;datastore.metric.host&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;0.0.0.0&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;host&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;address&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;localhost&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;port&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;5799&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;datastore&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;metric&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;host&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;port&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;3099&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;warehouse&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;host&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;198.0.0.1&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;port&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;2112&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;GetString(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;datastore.metric.host&quot;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;提取子树&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在开发可重用模块时，提取配置的子集并传递给模块通常很有用。这样，模块可以实例化一次，就获取到不同的配置。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如，应用程序可能出于不同的目的使用多个不同的缓存存储：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;cache&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cache1:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;max&lt;/span&gt;-items: &lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    item-&lt;span class=&quot;code-snippet__keyword&quot;&gt;size&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;64&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cache2:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;max&lt;/span&gt;-items: &lt;span class=&quot;code-snippet__number&quot;&gt;200&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    item-&lt;span class=&quot;code-snippet__keyword&quot;&gt;size&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;80&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们可以将缓存名称传递给模块（例如 NewCache(&quot;缓存1&quot;)，但访问配置键需要奇怪的串联，并且与全局配置的分离更少。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此，与其这样做，我们不要将 Viper 实例传递给表示配置子集的构造函数：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cache1Config := viper.Sub(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;cache.cache1&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; cache1Config == &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;panic&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;cache configuration not found&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cache1 := NewCache(cache1Config)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;注意：始终检查 Sub 的返回值。如果找不到 Key，则返回 nil。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在内部，NewCache 函数可以直接处理 max-items 和 item-size 的键：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;NewCache&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(v *Viper)&lt;/span&gt;&lt;/span&gt; *&lt;span class=&quot;code-snippet__type&quot;&gt;Cache&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &amp;amp;&lt;span class=&quot;code-snippet__type&quot;&gt;Cache&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__type&quot;&gt;MaxItems&lt;/span&gt;: v.&lt;span class=&quot;code-snippet__type&quot;&gt;GetInt&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;max-items&quot;&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__type&quot;&gt;ItemSize&lt;/span&gt;: v.&lt;span class=&quot;code-snippet__type&quot;&gt;GetInt&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;item-size&quot;&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;生成的代码易于测试，因为它与主配置结构分离，并且更易于重用（出于同样的原因）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;反序列化&lt;/span&gt;&lt;/p&gt;&lt;p&gt;您还可以选择将所有值或特定值解析到 struct、map 和 etc。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有两种方法可以做到这一点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; config &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Port &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Name &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  PathMap &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`mapstructure:&quot;path_map&quot;`&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; C config&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;err := viper.Unmarshal(&amp;amp;C)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  t.Fatalf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;unable to decode into struct, %v&quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果要解析 Key 本身包含「.」（默认键分隔符）的配置，必须更改分隔符：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;v := viper.NewWithOptions(viper.KeyDelimiter(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;::&quot;&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;v.SetDefault(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;chart::values&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;]&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ingress&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;]&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;annotations&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;]&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;traefik.frontend.rule.type&quot;&lt;/span&gt;:                 &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;PathPrefix&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;traefik.ingress.kubernetes.io/ssl-redirect&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;true&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; config &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Chart &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Values &lt;span class=&quot;code-snippet__keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;]&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; C config&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;v.Unmarshal(&amp;amp;C)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Viper 还支持解析到嵌入结构体：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; config &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Module &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Enabled &lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    moduleConfig &lt;span class=&quot;code-snippet__string&quot;&gt;`mapstructure:&quot;,squash&quot;`&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; moduleConfig &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Token &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; C config&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;err := viper.Unmarshal(&amp;amp;C)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  t.Fatalf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;unable to decode into struct, %v&quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Viper 在内部使用 &lt;/p&gt;&lt;p&gt;github.com/mitchellh/mapstructure 解析值，默认情况下使用 mapstructure tag。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;序列化为字符串&lt;/span&gt;&lt;/p&gt;&lt;p&gt;您可能需要将 viper 中保存的所有设置序列化到字符串中，而不是将它们写入文件。您可以将您最喜爱的格式的序列化程序与 AllSettings() 返回的配置一起使用。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    yaml &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;gopkg.in/yaml.v2&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;yamlStringSettings&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; string {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;c&lt;/span&gt; := viper.&lt;span class=&quot;code-snippet__type&quot;&gt;AllSettings&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    bs, err := yaml.&lt;span class=&quot;code-snippet__type&quot;&gt;Marshal&lt;/span&gt;(&lt;span class=&quot;code-snippet__built_in&quot;&gt;c&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        log.&lt;span class=&quot;code-snippet__type&quot;&gt;Fatalf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;unable to marshal config to YAML: %v&quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; string(bs)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;05&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;使用单个 Viper 实例，还是使用多个 Viper 实例？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Viper 可以开箱即用。无需配置或初始化，就可以使用 Viper。由于大多数应用程序都希望使用单个中央存储库进行配置，因此 viper 包提供了此功能。它类似于单例模式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在上面的所有示例中，他们都以单例模式风格演示了使用 Viper 的使用方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用多个 Viper 实例&lt;/span&gt;&lt;/p&gt;&lt;p&gt;您还可以创建许多不同的 Viper 实例，供应用程序使用。每个都有其独特的配置和值集。每个都可以从不同的配置文件、Key/Value 存储等读取。Viper 包支持的所有函数都镜像为 Viper 上的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;x := viper.New()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;y := viper.New()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;x.SetDefault(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ContentDir&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;content&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;y.SetDefault(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ContentDir&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;foobar&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当使用多个 Viper 时，由用户管理不同的 Viper。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;06&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;使用 Viper 读取配置文件的模拟示例&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;模拟示例的项目目录：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;├── &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;configs&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   └── &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;├── &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.mod&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;├── &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.sum&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;└── &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.go&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;配置文件：&lt;/p&gt;&lt;p&gt;configs/config.yaml&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Server&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;RunMode&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;debug&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;HttpPort&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;8080&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;ReadTimeout&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;60&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;WriteTimeout&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;60&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用 Viper 读取配置文件中的内容，并解码到 struct 中：&lt;/p&gt;&lt;p&gt;main.go&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; ServerSetting &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  RunMode      &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  HttpPort     &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ReadTimeout  time.Duration&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  WriteTimeout time.Duration&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; server ServerSetting&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  vp := viper.New()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  vp.SetConfigName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;config&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  vp.SetConfigType(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yaml&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  vp.AddConfigPath(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;configs/&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  err := vp.ReadInConfig()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;panic&lt;/span&gt;(fmt.Errorf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Fatal error config file: %s\n&quot;&lt;/span&gt;, err))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  err = vp.UnmarshalKey(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Server&quot;&lt;/span&gt;, &amp;amp;server)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;panic&lt;/span&gt;(fmt.Errorf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;unable to decode into struct, %v&quot;&lt;/span&gt;, err))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.Printf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Server: %+v\n&quot;&lt;/span&gt;, server)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;07&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;总结&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本文是 Viper 开源库的 README 的中文翻译，文章内容介绍了什么是 Viper，Viper 包含哪些功能和 Viper 管理配置信息的不同方式的使用方法，以及不同方式之间的优先级顺序。翻译内容难免有不准确的地方，建议对照英文原稿阅读。文章结尾，还给出了一个使用 Viper 读取配置文件的模拟示例。截止发稿，Viper 的最新版本为 v1.7.1，并且作者目前正在收集使用反馈，为开发 v2.0 做准备。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.5405405405405406&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gf7zJ2NXUibHrBBNc13c09hsck0LRuBWagGRXUlOPE7Nto7kj7M5peJTpdZlgatE5HwOkQibCPDOjUC0FfcboIbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;370&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注微信公众号，发送关键字「资料」，免费获取 Go 语言学习资料。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2982791586998088&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gf7zJ2NXUibGbVGM5xO1ib6r186S7X2WosN3GweyuAWdrDywTvE0DYoE6xa1ndbatz9QkuGwSysTNCKVSzjV9Qcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2092&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;https://github.com/spf13/viper&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Viper v2 反馈：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;https://forms.gle/R6faU74qPRPAzchZ9&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bc833fec544aefcb4a5319e0500a2d29</guid>
<title>真的理解 Go interface 了吗？</title>
<link>https://toutiao.io/k/0nfqg7g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我想，对于各位使用面向对象编程的程序员来说，&quot;接口&quot;这个名词一定不陌生，比如java中的接口以及c++中的虚基类都是接口的实现。但是&lt;code&gt;golang&lt;/code&gt;中的接口概念与其他语言不同，有它自己的特点，下面我们就来一起解密。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;定义&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言中的接口是一组方法的签名，它是 Go 语言的重要组成部分。简单的说，interface是一组method签名的组合，我们通过interface来定义对象的一组行为。&lt;strong&gt;interface 是一种类型&lt;/strong&gt;，定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Person &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt;    Eat(food &lt;span&gt;string&lt;/span&gt;) &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的定义可以看出来用了 type 关键字，更准确的说 interface 是一种&lt;strong&gt;具有一组方法的类型&lt;/strong&gt;，这些方法定义了 interface 的行为。&lt;code&gt;golang&lt;/code&gt;接口定义不能包含变量，但是允许不带任何方法，这种类型的接口叫&lt;code&gt;empty interface&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果一个类型实现了一个&lt;code&gt;interface&lt;/code&gt;中所有方法，我们就可以说该类型实现了该&lt;code&gt;interface&lt;/code&gt;，所以我们我们的所有类型都实现了&lt;code&gt;empty interface&lt;/code&gt;，因为任何一种类型至少实现了0个方法。并且&lt;code&gt;go&lt;/code&gt;中并不像&lt;code&gt;java&lt;/code&gt;中那样需要显式关键字来实现&lt;code&gt;interface&lt;/code&gt;，只需要实现&lt;code&gt;interface&lt;/code&gt;包含的方法即可。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里先拿&lt;code&gt;java&lt;/code&gt;语言来举例，在&lt;code&gt;java&lt;/code&gt;中，我们要实现一个&lt;code&gt;interface&lt;/code&gt;需要这样声明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyWriter&lt;/span&gt; &lt;span&gt;implments&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;Writer&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就意味着对于接口的实现都需要显示声明，在代码编写方面有依赖限制，同时需要处理包的依赖，而在&lt;code&gt;Go&lt;/code&gt;语言中实现接口就是隐式的，举例说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; error &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Error() &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; RPCError &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Code    &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt; Message &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(e *RPCError)&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; fmt.Sprintf(&lt;span&gt;&quot;%s, code=%d&quot;&lt;/span&gt;, e.Message, e.Code)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码，并没有&lt;code&gt;error&lt;/code&gt;接口的影子，我们只需要实现&lt;code&gt;Error() string&lt;/code&gt;方法就实现了&lt;code&gt;error&lt;/code&gt;接口。在&lt;code&gt;Go&lt;/code&gt;中，实现接口的所有方法就隐式地实现了接口。我们使用上述 &lt;code&gt;RPCError&lt;/code&gt; 结构体时并不关心它实现了哪些接口，Go 语言只会在传递参数、返回参数以及变量赋值时才会对某个类型是否实现接口进行检查。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Go&lt;/code&gt;语言的这种写法很方便，不用引入包依赖。但是&lt;code&gt;interface&lt;/code&gt;底层实现的时候会动态检测也会引入一些问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;性能下降。使用interface作为函数参数，runtime 的时候会动态的确定行为。使用具体类型则会在编译期就确定类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不能清楚的看出struct实现了哪些接口，需要借助ide或其它工具。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;两种接口&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里大多数刚入门的同学肯定会有疑问，怎么会有两种接口，因为&lt;code&gt;Go&lt;/code&gt;语言中接口会有两种表现形式，使用&lt;code&gt;runtime.iface&lt;/code&gt;表示第一种接口，也就是我们上面实现的这种，接口中定义方法；使用&lt;code&gt;runtime.eface&lt;/code&gt;表示第二种不包含任何方法的接口，第二种在我们日常开发中经常使用到，所以在实现时使用了特殊的类型。从编译角度来看，golang并不支持泛型编程。但还是可以用&lt;code&gt;interface{}&lt;/code&gt;  来替换参数，而实现泛型。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;interface内部结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言根据接口类型是否包含一组方法将接口类型分成了两类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;runtime.iface&lt;/code&gt; 结构体表示包含方法的接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;runtime.eface&lt;/code&gt; 结构体表示不包含任何方法的 &lt;code&gt;interface{}&lt;/code&gt; 类型；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;runtime.iface&lt;/code&gt;结构体在&lt;code&gt;Go&lt;/code&gt;语言中的定义是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; eface &lt;span&gt;struct&lt;/span&gt; { &lt;span&gt;// 16 字节&lt;/span&gt;&lt;br/&gt; _type *_type&lt;br/&gt; data  unsafe.Pointer&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里只包含指向底层数据和类型的两个指针，从这个&lt;code&gt;type&lt;/code&gt;我们也可以推断出Go语言的任意类型都可以转换成&lt;code&gt;interface&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个用于表示接口的结构体是 &lt;code&gt;runtime.iface&lt;/code&gt;，这个结构体中有指向原始数据的指针 &lt;code&gt;data&lt;/code&gt;，不过更重要的是 &lt;code&gt;runtime.itab&lt;/code&gt; 类型的 &lt;code&gt;tab&lt;/code&gt; 字段。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; iface &lt;span&gt;struct&lt;/span&gt; { &lt;span&gt;// 16 字节&lt;/span&gt;&lt;br/&gt; tab  *itab&lt;br/&gt; data unsafe.Pointer&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们一起看看&lt;code&gt;interface&lt;/code&gt;中这两个类型：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;runtime_type&lt;/code&gt;是 Go 语言类型的运行时表示。下面是运行时包中的结构体，其中包含了很多类型的元信息，例如：类型的大小、哈希、对齐以及种类等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; _type &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; size       &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt; ptrdata    &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt; hash       &lt;span&gt;uint32&lt;/span&gt;&lt;br/&gt; tflag      tflag&lt;br/&gt; align      &lt;span&gt;uint8&lt;/span&gt;&lt;br/&gt; fieldAlign &lt;span&gt;uint8&lt;/span&gt;&lt;br/&gt; kind       &lt;span&gt;uint8&lt;/span&gt;&lt;br/&gt; equal      &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(unsafe.Pointer, unsafe.Pointer)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; gcdata     *&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt; str        nameOff&lt;br/&gt; ptrToThis  typeOff&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我只对几个比较重要的字段进行讲解：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;size&lt;/code&gt; 字段存储了类型占用的内存空间，为内存空间的分配提供信息；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;hash&lt;/code&gt; 字段能够帮助我们快速确定类型是否相等；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;equal&lt;/code&gt; 字段用于判断当前类型的多个对象是否相等，该字段是为了减少 Go 语言二进制包大小从 &lt;code&gt;typeAlg&lt;/code&gt; 结构体中迁移过来的)；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;runtime_itab&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;runtime.itab&lt;/code&gt;结构体是接口类型的核心组成部分，每一个 &lt;code&gt;runtime.itab&lt;/code&gt; 都占 32 字节，我们可以将其看成接口类型和具体类型的组合，它们分别用 &lt;code&gt;inter&lt;/code&gt; 和 &lt;code&gt;_type&lt;/code&gt; 两个字段表示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; itab &lt;span&gt;struct&lt;/span&gt; { &lt;span&gt;// 32 字节&lt;/span&gt;&lt;br/&gt; inter *interfacetype&lt;br/&gt; _type *_type&lt;br/&gt; hash  &lt;span&gt;uint32&lt;/span&gt;&lt;br/&gt; _     [&lt;span&gt;4&lt;/span&gt;]&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt; fun   [&lt;span&gt;1&lt;/span&gt;]&lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;inter&lt;/code&gt;和&lt;code&gt;_type&lt;/code&gt;是用于表示类型的字段，&lt;code&gt;hash&lt;/code&gt;是对&lt;code&gt;_type.hash&lt;/code&gt;的拷贝，当我们想将 &lt;code&gt;interface&lt;/code&gt; 类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型 &lt;code&gt;runtime._type&lt;/code&gt;是否一致，&lt;code&gt;fun&lt;/code&gt;是一个动态大小的数组，它是一个用于动态派发的虚函数表，存储了一组函数指针。虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以 &lt;code&gt;fun&lt;/code&gt; 数组中保存的元素数量是不确定的；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内部结构就做一个简单介绍吧，有兴趣的同学可以自行深入学习。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;空的interface（&lt;code&gt;runtime.eface&lt;/code&gt;）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前文已经介绍了什么是空的&lt;code&gt;interface&lt;/code&gt;，下面我们来看一看空的&lt;code&gt;interface&lt;/code&gt;如何使用。定义函数入参如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doSomething&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt;{    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个函数的入参是&lt;code&gt;interface&lt;/code&gt;类型，要注意的是，&lt;code&gt;interface&lt;/code&gt;类型不是任意类型，他与C语言中的&lt;code&gt;void *&lt;/code&gt;不同，如果我们将类型转换成了 &lt;code&gt;interface{}&lt;/code&gt; 类型，变量在运行期间的类型也会发生变化，获取变量类型时会得到 &lt;code&gt;interface{}&lt;/code&gt;，之所以函数可以接受任何类型是在 go 执行时传递到函数的任何类型都被自动转换成 &lt;code&gt;interface{}&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们可以才来一个猜想，既然空的 interface 可以接受任何类型的参数，那么一个 &lt;code&gt;interface{}&lt;/code&gt;类型的 slice 是不是就可以接受任何类型的 slice ？下面我们就来尝试一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;printStr&lt;/span&gt;&lt;span&gt;(str []&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, val := &lt;span&gt;range&lt;/span&gt; str {&lt;br/&gt;  fmt.Println(val)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt; names := []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;stanley&quot;&lt;/span&gt;, &lt;span&gt;&quot;david&quot;&lt;/span&gt;, &lt;span&gt;&quot;oscar&quot;&lt;/span&gt;}&lt;br/&gt; printStr(names)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面代码，会出现如下错误：&lt;code&gt;./main.go:15:10: cannot use names (type []string) as type []interface {} in argument to printStr&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我也是很疑惑，为什么&lt;code&gt;Go&lt;/code&gt;没有帮助我们自动把&lt;code&gt;slice&lt;/code&gt;转换成&lt;code&gt;interface&lt;/code&gt;类型的&lt;code&gt;slice&lt;/code&gt;，之前做项目就想这么用，结果失败了。后来我终于找到了答案，有兴趣的可以看看原文，这里简单总结一下：&lt;code&gt;interface&lt;/code&gt;会占用两个字长的存储空间，一个是自身的 methods 数据，一个是指向其存储值的指针，也就是 interface 变量存储的值，因而 slice []interface{} 其长度是固定的&lt;code&gt;N*2&lt;/code&gt;，但是 []T 的长度是&lt;code&gt;N*sizeof(T)&lt;/code&gt;，两种 slice 实际存储值的大小是有区别的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然这种方法行不通，那可以怎样解决呢？我们可以直接使用元素类型是interface的切片。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; dataSlice []&lt;span&gt;int&lt;/span&gt; = foo()&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; interfaceSlice []&lt;span&gt;interface&lt;/span&gt;{} = &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;interface&lt;/span&gt;{}, &lt;span&gt;len&lt;/span&gt;(dataSlice))&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i, d := &lt;span&gt;range&lt;/span&gt; dataSlice {&lt;br/&gt; interfaceSlice[i] = d&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;非空&lt;code&gt;interface&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Go&lt;/code&gt;语言实现接口时，既可以结构体类型的方法也可以是使用指针类型的方法。&lt;code&gt;Go&lt;/code&gt;语言中并没有严格规定实现者的方法是值类型还是指针，那我们猜想一下，如果同时使用值类型和指针类型方法实现接口，会有什么问题吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看这样一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Person &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; GetAge () &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; SetAge (&lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Man &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; Age &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(s Man)&lt;/span&gt; &lt;span&gt;GetAge&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; s.Age&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(s *Man)&lt;/span&gt; &lt;span&gt;SetAge&lt;/span&gt;&lt;span&gt;(age &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s.Age = age&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(p Person)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt; p.SetAge(&lt;span&gt;10&lt;/span&gt;)&lt;br/&gt; fmt.Println(p.GetAge())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; p := Man{}&lt;br/&gt; f(&amp;amp;p) &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上面的代码，大家对&lt;code&gt;f(&amp;amp;p)&lt;/code&gt;这里的入参是否会有疑问呢？如果不取地址，直接传过去会怎么样？试了一下，编译错误如下：&lt;code&gt;./main.go:34:3: cannot use p (type Man) as type Person in argument to f: Man does not implement Person (SetAge method has pointer receiver)&lt;/code&gt;。透过注释我们可以看到，因为&lt;code&gt;SetAge&lt;/code&gt;方法的&lt;code&gt;receiver&lt;/code&gt;是指针类型，那么传递给&lt;code&gt;f&lt;/code&gt;的是&lt;code&gt;P&lt;/code&gt;的一份拷贝，在进行&lt;code&gt;p&lt;/code&gt;的拷贝到&lt;code&gt;person&lt;/code&gt;的转换时，&lt;code&gt;p&lt;/code&gt;的拷贝是不满足&lt;code&gt;SetAge&lt;/code&gt;方法的&lt;code&gt;receiver&lt;/code&gt;是个指针类型，这也正说明一个问题&lt;strong&gt;go中函数都是按值传递&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子是因为发生了值传递才会导致出现这个问题。实际上不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Animal &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Walk()&lt;br/&gt; Eat()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Dog &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(d *Dog)&lt;/span&gt;&lt;span&gt;Walk&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;go&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(d *Dog)&lt;/span&gt;&lt;span&gt;Eat&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;eat shit&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d Animal = &amp;amp;Dog{&lt;span&gt;&quot;nene&quot;&lt;/span&gt;}&lt;br/&gt; d.Eat()&lt;br/&gt; d.Walk()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面定义了一个接口&lt;code&gt;Animal&lt;/code&gt;，接口定义了两个函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Walk()&lt;br/&gt;Eat()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着定义了一个结构体&lt;code&gt;Dog&lt;/code&gt;，他实现了两个方法，一个是值接受者，一个是指针接收者。我们通过接口类型的变量调用了定义的两个函数是没有问题的，如果我们改成这样呢：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d Animal = Dog{&lt;span&gt;&quot;nene&quot;&lt;/span&gt;}&lt;br/&gt; d.Eat()&lt;br/&gt; d.Walk()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样直接就会报错，我们只改了一部分，第一次将&lt;code&gt;&amp;amp;Dog{&quot;nene&quot;}&lt;/code&gt;赋值给了&lt;code&gt;d&lt;/code&gt;；第二次则将&lt;code&gt;Dog{&quot;nene&quot;}&lt;/code&gt;赋值给了&lt;code&gt;d&lt;/code&gt;。第二次报错是因为，&lt;code&gt;d&lt;/code&gt;没有实现&lt;code&gt;Animal&lt;/code&gt;。这正解释了上面的结论，所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一句话就是：&lt;strong&gt;如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类型断言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个&lt;code&gt;interface&lt;/code&gt;被多种类型实现时，有时候我们需要区分&lt;code&gt;interface&lt;/code&gt;的变量究竟存储哪种类型的值，&lt;code&gt;go&lt;/code&gt;可以使用&lt;code&gt;comma,ok&lt;/code&gt;的形式做区分 &lt;code&gt;value, ok := em.(T)&lt;/code&gt;：&lt;strong&gt;em 是 interface 类型的变量，T代表要断言的类型，value 是 interface 变量存储的值，ok 是 bool 类型表示是否为该断言的类型 T&lt;/strong&gt;。总结出来语法如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;目标类型的值&amp;gt;，&amp;lt;布尔参数&amp;gt; := &amp;lt;表达式&amp;gt;.( 目标类型 ) &lt;span&gt;// 安全类型断言&lt;/span&gt;&lt;br/&gt;&amp;lt;目标类型的值&amp;gt; := &amp;lt;表达式&amp;gt;.( 目标类型 )  &lt;span&gt;//非安全类型断言&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看个简单的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Dog &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d &lt;span&gt;interface&lt;/span&gt;{} = &lt;span&gt;new&lt;/span&gt;(Dog)&lt;br/&gt; d1,ok := d.(Dog)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !ok{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; fmt.Println(d1)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种就属于安全类型断言，更适合在线上代码使用，如果使用非安全类型断言会怎么样呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Dog &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d &lt;span&gt;interface&lt;/span&gt;{} = &lt;span&gt;new&lt;/span&gt;(Dog)&lt;br/&gt; d1 := d.(Dog)&lt;br/&gt; fmt.Println(d1)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就会发生错误如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;panic&lt;/span&gt;: &lt;span&gt;interface&lt;/span&gt; conversion: &lt;span&gt;interface&lt;/span&gt; {} is *main.Dog, not main.Dog&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断言失败。这里直接发生了 &lt;code&gt;panic&lt;/code&gt;，所以不建议线上代码使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看过&lt;code&gt;fmt&lt;/code&gt;源码包的同学应该知道，&lt;code&gt;fmt.println&lt;/code&gt;内部就是使用到了类型断言，有兴趣的同学可以自行学习。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面介绍了&lt;code&gt;interface&lt;/code&gt;的基本使用方法及可能会遇到的一些问题，下面出三个题，看看你们真的掌握了吗？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题一&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面代码，哪一行存在编译错误？（多选）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Student &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;&lt;span&gt;(x &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(x *&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := Student{}&lt;br/&gt; p := &amp;amp;s&lt;br/&gt; &lt;span&gt;// A B C D&lt;/span&gt;&lt;br/&gt; Set(s)&lt;br/&gt; Get(s)&lt;br/&gt; Set(p)&lt;br/&gt; Get(p)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：B、D；解析：我们上文提到过，&lt;code&gt;interface&lt;/code&gt;是所有&lt;code&gt;go&lt;/code&gt;类型的父类，所以&lt;code&gt;Get&lt;/code&gt;方法只能接口&lt;code&gt;*interface{}&lt;/code&gt;类型的参数，其他任何类型都不可以。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题二&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的运行结果是什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;PrintInterface&lt;/span&gt;&lt;span&gt;(val &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; val == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;this is empty interface&quot;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;this is non-empty interface&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; pointer *&lt;span&gt;string&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; PrintInterface(pointer)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：&lt;code&gt;this is non-empty interface&lt;/code&gt;。解析：这里的&lt;code&gt;interface{}&lt;/code&gt;是空接口类型，他的结构如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; eface &lt;span&gt;struct&lt;/span&gt; { &lt;span&gt;// 16 字节&lt;/span&gt;&lt;br/&gt; _type *_type&lt;br/&gt; data  unsafe.Pointer&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在调用函数&lt;code&gt;PrintInterface&lt;/code&gt;时发生了&lt;strong&gt;隐式的类型转换&lt;/strong&gt;，除了向方法传入参数之外，变量的赋值也会触发隐式类型转换。在类型转换时，&lt;code&gt;*string&lt;/code&gt;类型会转换成&lt;code&gt;interface&lt;/code&gt;类型，发生值拷贝，所以&lt;code&gt;eface struct{}&lt;/code&gt;是不为&lt;code&gt;nil&lt;/code&gt;，不过&lt;code&gt;data&lt;/code&gt;指针指向的&lt;code&gt;poniter&lt;/code&gt;为&lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题三&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的运行结果是什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Animal &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Walk()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Dog &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(d *Dog)&lt;/span&gt; &lt;span&gt;Walk&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;walk&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewAnimal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d *Dog&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; NewAnimal() == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;this is empty interface&quot;&lt;/span&gt;)&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;this is non-empty interface&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：&lt;code&gt;this is non-empty interface&lt;/code&gt;. 解析：这里的&lt;code&gt;interface&lt;/code&gt;是非空接口&lt;code&gt;iface&lt;/code&gt;，他的结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; iface &lt;span&gt;struct&lt;/span&gt; { &lt;span&gt;// 16 字节&lt;/span&gt;&lt;br/&gt; tab  *itab&lt;br/&gt; data unsafe.Pointer&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;d&lt;/code&gt;是一个指向nil的空指针，但是最后&lt;code&gt;return d&lt;/code&gt; 会触发&lt;code&gt;匿名变量 Animal = p&lt;/code&gt;值拷贝动作，所以最后&lt;code&gt;NewAnimal()&lt;/code&gt;返回给上层的是一个&lt;code&gt;Animal interface{}&lt;/code&gt;类型，也就是一个&lt;code&gt;iface struct{}&lt;/code&gt;类型。&lt;code&gt;p&lt;/code&gt;为nil，只是&lt;code&gt;iface&lt;/code&gt;中的data 为nil而已。但是&lt;code&gt;iface struct{}&lt;/code&gt;本身并不为nil.&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;interface&lt;/code&gt;在我们日常开发中使用还是比较多，所以学好它还是很必要，希望这篇文章能让你对&lt;code&gt;Go&lt;/code&gt;语言的接口有一个新的认识，这一篇到这里结束啦，我们下期见～～～。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;建了一个Golang交流群，欢迎大家的加入，第一时间观看优质文章，不容错过哦（公众号获取）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是asong，一名普普通通的程序猿，让gi我一起慢慢变强吧。我自己建了一个&lt;code&gt;golang&lt;/code&gt;交流群，有需要的小伙伴加我&lt;code&gt;vx&lt;/code&gt;,我拉你入群。欢迎各位的关注，我们下期见~~~&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/k5430ljpYPOmuIQZOVTBeKxpAj6UrBVNg9sYvXGwKkGS7YlMsW06Khia74N8U6J8VRaBd9WNIUCthcPH85fPnnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐往期文章：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>