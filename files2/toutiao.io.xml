<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3452460f0c78923f4029ddc7e6e09331</guid>
<title>2020 最全电子书搜索网站，找电子书不再愁</title>
<link>https://toutiao.io/k/qexzdh8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;苏生不惑第176 篇原创文章，将本公众号设为&lt;code&gt;星标&lt;/code&gt;，第一时间看最新文章。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前分享过找电影电视剧网站 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247484882&amp;amp;idx=1&amp;amp;sn=4b1e623d73ba540dd756ea8e028bca02&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;2020 最全百度网盘搜索，找电影资源不再愁&lt;/a&gt; ，今天再分享下找电子书资源网站。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;中文电子书&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://www.jiumodiary.com/  鸠摩搜书这个电子书搜索引擎比较知名，搜索结果支持 epub，TXT，PDF，mobi等格式。&lt;img data-ratio=&quot;0.8774928774928775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8DVnibnyvud9iboVd6TcTs0Q9scWKhs4dr2DJLy5zDbPwMibgxc37QPkxxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;http://www.toplinks.cc/s/  淘链客，主要收集文档类资源下载链接的聚合型搜索引擎网站，下载链接来自百度网盘、微盘、城通、蓝奏云等网盘及其他第三方网站。&lt;img data-ratio=&quot;0.4775613886536833&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8DjDSJNU1oI5Xa2bpQgfl7NwBibjDMFJlBjYsPtg9Szou8JLGDlMyTamw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1181&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://www.kgbook.com/  电子书分享平台苦瓜书盘是供网友交流适合电纸书阅读的6寸pdf及mobi格式电子书制作技术的网站。&lt;img data-ratio=&quot;0.5687203791469194&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8D5cxSavtibwm6yVpUugxvuVlt0ibiaZUG8hQnZ5eibhCU4djXsdBoftSwnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1055&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;http://www.banshujiang.cn/ 搬书匠供大量编程类电子书免费下载，根据语音，数据库，年份等分类整理。&lt;img data-ratio=&quot;0.5686653771760155&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8Dm1ggNuV1PRicRHjNOAicTka8txqn5NHFTE0t341zF29zVTzMVzUkmRSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1034&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;号称最大的电子书库epubee  http://cn.epubee.com/books/&lt;img data-ratio=&quot;0.41920590951061865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8DqUdjAPwAMF5cxoic8oFXbteB2jDDNr9ibEj2LRzlaOADdEicEvUSfJXTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1083&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;英文电子书&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;http://www.qcenglish.com/  一个英文电子书下载站七彩英语 ，支持PDF和TXT格式，提供2249本英文原版原著下载。&lt;br/&gt;&lt;img data-ratio=&quot;0.67570385818561&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8DnHZ0mwNTbNXsIcpORqWAna64TM4m4NLwaBRuXia5eNgjQUaIMwcEBmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;959&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;http://gen.lib.rus.ec/   一个文献在线查询和下载的公益网站Library Genesis ，主要是英文原版的电子书和期刊论文，据说藏书多达100万本，其中也有少量的中文资料 。&lt;img data-ratio=&quot;0.5547355473554736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8DYaKTSeicpmG27p1Aa22jqWYYf3IAbXeatxciaVJic4DXu45ialqubichFSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;813&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他类似网站还有 http://www.gutenberg.org/ ，http://manybooks.net，https://b-ok.cc/ 。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;在线图书馆&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://zh.booksc.org/  booksc是世界上最大的在线图书馆之一，拥有超过533万册书籍以及7752万个文献，大多是pdf、djvu、eupb格式，直接搜书名或文章题目即可搜索下载，无需注册，很方便。&lt;img data-ratio=&quot;0.4570610687022901&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8Dx5D7UkKOphtD85PBcVjciaFt0xYDomMMqTzQaxVLrZI7MBWJlXydKKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1048&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://pup6.yunzhan365.com/bookcase/kiru/index.html 北大出版社电子教材书架，目前提供 680 多册不同专业的教材，支持关键词搜索，也可以按学科进行筛选。&lt;img data-ratio=&quot;0.4806451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8D3eFuRuqYEcYw5j2qzWoXsxra1AFOU3x1f1C8L2N71qqx7DcweWXz5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;在线阅读效果不错。&lt;img data-ratio=&quot;0.4774193548387097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8DMsznjvmfC7NicuWXv0LfNTjBZDUjrib3ON92a4Fdf0CEq3QJ031L3JWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;http://www.ndlib.cn/ 数字图书馆推广工程汇集国内各省市图书馆，提供免费的图书、杂志、有声读物在线浏览，分类齐全，资源众多，可切换国内任一家图书馆。&lt;img data-ratio=&quot;0.5479951397326853&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8D1bhOdDVWLl2BWQPOnabEZGOvUznSkXYClfMNGXg5lgLdcbSYias2Vfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot;/&gt;与各大高校图书馆合作的全国图书馆参考咨询联盟 http://www.ucdrs.superlib.net/&lt;img data-ratio=&quot;0.32448733413751507&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8Dys92MWvjYQeF611u6R3AP1ic2hBpb6SvGS4NSqIX0k3JnCzicEHvMKlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;829&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;电子书网站导航&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://ebook.chongbuluo.com/ 虫部落集合了几十个电子书网站，切换到对应网站搜索即可。&lt;img data-ratio=&quot;0.5053852526926264&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8DuSsPhlZS6dvB3M2oyrgKP7AdBUU1tH29mrPHia7LweX8MDPYiclmrxQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1207&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://ebook.huzerui.com/  熊猫搜书聚合了 22 个高质量电子书搜索网站 ，提供 mobi、epud、pdf、txt，kindle等格式下载。&lt;img data-ratio=&quot;0.5429824561403509&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8DAtb2K4bOUaP04wuugxUMLPh0WGEzCdzPMBiaqyhZn1WrticdqYGA9Ttg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;http://shu.ziyuandi.cn  电子书资源帝，集合了上百个电子书网站。&lt;img data-ratio=&quot;0.5383211678832117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8DAteqPdqBJktVrs6cXd5kn6fGWgEld2ZFY3e43006Cs6bETUFDogflg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1096&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;油猴脚本&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于油猴脚本之前分享过很多了&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247485484&amp;amp;idx=1&amp;amp;sn=bbec1d0d3dcaa3bc1b875c35b6c05ad2&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;实用油猴脚本推荐，让你的谷歌浏览器更强大&lt;/a&gt;  ， 油猴脚本豆瓣资源下载大师让你 1 秒搞定豆瓣电影 | 音乐 | 图书下载 https://greasyfork.org/zh-CN/scripts/329484 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装脚本后在豆瓣图书 https://book.douban.com/subject/3674537/ 右侧可以看到推荐的搜索结果相当全面，包含在线阅读，图书搜索·，免费图书网站，在线听书，再也不用你一个个搜索了，之前文章也介绍过 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247484459&amp;amp;idx=1&amp;amp;sn=66715ed0a9bcfde1fd6f4a117899b4d5&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;搜不到你想看的书/音乐/电影？一个油猴脚本帮你搞定&lt;/a&gt;&lt;img data-ratio=&quot;0.6015473887814313&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8DWotaSZeic1uVpicJvV4Tib7liaBgdyuQPdWn8kyJIXfrCc0NibJfcw3jlEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1034&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;搜索引擎&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上面那么多网站还没找到，还有万能的谷歌，搜电子书时，在书名关键词后加上文件格式，如 pdf/epub/mobi/azw3/txt等  比如 &lt;code&gt;明朝那些事儿 filetype:pdf&lt;/code&gt;，搜出的结果都是PDF文件。&lt;img data-ratio=&quot;0.45161290322580644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8D7Pxa1081KQIfkJoSzeDJbnqvDt43xlicT5Syia98MxvYS8yjU24w6KJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每本书都有国际标准书号 isbn 号 ,比如 《乌合之众》为 9787801093660 https://book.douban.com/subject/1012611/ ，直接搜索 &lt;code&gt;inurl:9787801093660&lt;/code&gt; 可找到这本书。&lt;img data-ratio=&quot;0.7721674876847291&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8D2xHBp3fvzVlkicWkfdnZOBQOtc5zMv5jMrXoY4vhticblSfq8wtSMdWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后推荐个网站 一生必读的100 本书 https://www.100ben.net/ ，收录了世界名著，全球知名小说和传记等，可在线阅读。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8DUicF8Lo9URV5FaafziaMibq2LKsQmNPeubhWbeMjESIhUw45iaqruPkibew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt; &lt;/figcaption&gt;&lt;/figure&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;公众号后台回复关键词&lt;/th&gt;&lt;th&gt;用途&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;微信&lt;/td&gt;&lt;td&gt;获取你的微信好友头像拼图及查看微信撤回消息&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;b站&lt;/td&gt;&lt;td&gt;获取下载b站视频工具及找回被删b站视频方法&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;视频&lt;/td&gt;&lt;td&gt;获取下载腾讯，优酷，爱奇艺，微博视频工具及去除logo脚本&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;百度网盘&lt;/td&gt;&lt;td&gt;获取加速下载网盘文件方法及查找电影电视剧网站&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;朋友圈&lt;/td&gt;&lt;td&gt;获取发空白朋友圈方法和九宫格图片&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;微博&lt;/td&gt;&lt;td&gt;获取备份微博工具及分析微博账号数据&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;音乐&lt;/td&gt;&lt;td&gt;获取下载音乐工具及在线听歌网站&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;油猴&lt;/td&gt;&lt;td&gt;获取油猴脚本&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;谷歌&lt;/td&gt;&lt;td&gt;获取安装Chrome扩展方法&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;公众号&lt;/td&gt;&lt;td&gt;一键下载公众号所有文章&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;抖音&lt;/td&gt;&lt;td&gt;一键下载无水印抖音视频&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;公众号 苏生不惑&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sZeVtjGD4lH8prGfLII2KhQ22cCKEJ8DKmBJsu1cYeA3tEY4jjFATHPS5owMlB1opKjDpcYSfHHG2YqEZN7dow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;344&quot;/&gt;&lt;figcaption&gt;扫描二维码关注或搜索微信susheng_buhuo&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>96d454e19dd60e680dd9bf854ec6db51</guid>
<title>秒懂 JVM 的三大参数类型，就靠这十个小实验了</title>
<link>https://toutiao.io/k/tt5pijb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本实验的目的是讲解 JVM 的三大参数类型。在&lt;strong&gt;&lt;span&gt;JVM调优&lt;/span&gt;&lt;/strong&gt;中用到的最多的 XX 参数，而如何去查看和设置 JVM 的 XX 参数也是调优的基本功，本节以实验的方式讲解 JVM 参数的查看和设置。希望大家能有所启发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.5173501577287065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZywrrmKRHeJKroKlzr2XuUocDbKOZW9gbLy3OJTia6fXJ39MfYVZ7wBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;634&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;标配参数&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;常见标配参数&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;-version，获取JDK版本&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;-help，获取帮助&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;-showverision，获取JDK版本和帮助&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;动手实验 1 - 查看标配参数&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实验步骤：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28826151560178304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZKQ4OtEVouiaW3cwXw0ATyibYDSvgsiaUZqVkwaQrTVwIpTX1BciafzxsZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;673&quot;/&gt;&lt;figcaption&gt;实验 1-1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到Java JDK 版本为1.8.0_131&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -help&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48484848484848486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZb23ibPickXbDseZ5gcgkYtvN6MQePAuAV6ean09kXe9ByCkMaYpXn1Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;627&quot;/&gt;&lt;figcaption&gt;实验 1-2&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -showversion&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38461538461538464&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZmT8P23FXJzO5UkvPYdHrjFUx8NrNW11rFx8ibZc3HibEHYBTnJqcXsKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;689&quot;/&gt;&lt;figcaption&gt;实验 1-3&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;X 参数&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;X 参数简介&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们常用的&lt;code&gt;javac&lt;/code&gt;大家都知道是把java代码编译成 class 文 Java 文件，那么 class 文件怎么去执行呢？这里用到了三个X参数来说明 class 文件怎么在虚拟机里面跑起来的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-Xint：直接解释执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xcomp：先编译成本地代码再执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XMixed：混合模式（既有编译执行也有解释执行）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;动手实验 2 - 查看和配置X参数&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在WebIDE的控制台窗口执行Java -version 后，可以看到我的环境是混合模式执行java程序的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28826151560178304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZKQ4OtEVouiaW3cwXw0ATyibYDSvgsiaUZqVkwaQrTVwIpTX1BciafzxsZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;673&quot;/&gt;&lt;figcaption&gt;实验 2-1&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -Xint -version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在WebIDE的控制台窗口执行命令&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16984126984126985&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZtCHo1jtbDNOLGnq32tYUxMqohwW4psoiazsHRCzANkoE9ryyvFWF6iaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;figcaption&gt;实验 2-2&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -Xcomp -version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17801047120418848&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZEx34ibc3KZ06fA2VnhrSmk2kRDUoicX2Rsia1bKMmZniaSCu6slKibn9LSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;573&quot;/&gt;&lt;figcaption&gt;实验 2-3&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;XX 参数&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;XX  参数简介&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XX 参数有两种类型，一种是 Boolean 类型，另外一种是键值对类型。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Boolean 类型&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;公式：&lt;code&gt;-XX:+某个属性&lt;/code&gt; 或者，&lt;code&gt;-XX:-某个属性&lt;/code&gt; +表示开启了这个属性，-表示关闭了这个属性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;案例：&lt;code&gt;-XX:-PrintGCDetails&lt;/code&gt;，表示关闭了GC详情输出&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;key-value类型&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;公式：&lt;code&gt;-XX:属性key=属性value&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;案例：&lt;code&gt;-XX:属性metaspace=2000000&lt;/code&gt;，设置Java元空间的值为2000000。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;动手实验 3 - 查看参数是否开启&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本实验主要讲解如下内容：查看运行的 Java 程序 PrintGCDetails 参数是否开启&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;编写一个一直运行的 Java 程序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;查看该应用程序的进程 id&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;查看该进程的 GCDetail 参数是否开启&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;在 WebIDE 上右键单击菜单，选择 New File 创建新文件&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9572446555819477&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZQ2YAbGkiaGcHiaRAqODOQiap4d26ZX0HEFFahPLXhf4Twc3ibH47KrCJGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;421&quot;/&gt;&lt;figcaption&gt;New File&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建文件名为 demoXXparam.java&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9007352941176471&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZA2c6X4VfFF6sdXMjYN3HY955SxKEBTRia2X8b7PqU7V8MFtW9m3HTDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;272&quot;/&gt;&lt;figcaption&gt;demoXXparam.java&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;在 WebIDE 上编写 demoXXparam.java&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;demoXXparam&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;hello XX params&quot;&lt;/span&gt;);&lt;br/&gt;        Thread.sleep(Integer.MAX_VALUE);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;在 WebIDE 的控制台窗口编译 demoXXparam.java 代码&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;javac demoXXparam.java &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.29111531190926276&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZdEXuvzYqicS0NL6oelKmNT1NX02u3wWib3v6xDtnPZZRrXeS0IRM5cog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;529&quot;/&gt;&lt;figcaption&gt;编译代码&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译之后，会在当前文件夹产生我们所编写的  &lt;code&gt;demoXXparam&lt;/code&gt; 类的 &lt;code&gt;demoXXparam.class&lt;/code&gt; 字节码文件&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8361204013377926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZqwjZia0AulRLZxCVCO8d0UyyIvBUOraNHSAec6HXs7iamgeVLVbdHAmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;299&quot;/&gt;&lt;figcaption&gt;生产Class文件&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;在 WebIDE 上运行 demoXXparam 代码&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java demoXXparam&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4496124031007752&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZK8t6CVKWkuiaBj5ibP0mhIZzA7zErhROn7nLC019FpYuicD5XyfGubMWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;516&quot;/&gt;&lt;figcaption&gt;运行Java程序&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;hello XX params&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;在 WebIDE 中新开一个控制台窗口&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Terminal-&amp;gt;New Terminal&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5739484396200815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZUVibXkRicdcj5Sd7hibEMY5daGlFhFJA06oYWO82AutLgiaSaORa9AUyrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot;/&gt;&lt;figcaption&gt;开启新控制台窗口&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查看所有的运行的java程序，-l 表示打印出class文件的包名&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jps -l&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20344827586206896&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZrEiaVGy6ThUnbfvvZHMsALxN1K7mhep9JkTa9TSOn3UfialH9NwXXrJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;580&quot;/&gt;&lt;figcaption&gt;jps&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现&lt;code&gt;demoXXparam&lt;/code&gt;进程的id为 518&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查看 demoXXparam 程序是否开启了PrintGCDetails这个参数&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;PrintGCDetails：&lt;/strong&gt;  在发生垃圾回收时打印内存回收日志，并在进程退出时输出当前内存各区域分配情况&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jinfo -flag PrintGCDetails 518&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30337078651685395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZHvDksxNC21e3rDwia9PQfFfwezumDT9abiarc8VjT2s8etwJjSMeK8Ww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;623&quot;/&gt;&lt;figcaption&gt;jinfo&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-XX:-PrintGCDetails&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到  &lt;code&gt;-&lt;/code&gt;号表示关闭，所以当前 demo 程序没有开启 &lt;code&gt;PrintGCDetails&lt;/code&gt;参数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;动手实验 4  - 开启参数&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 WebIDE 控制台强制退出demoXXparam程序&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ctrl + c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;clear&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;然后以参数 &lt;code&gt;-XX:+PrintGCDetails&lt;/code&gt; 运行 demoXXparam 程序&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -XX:+PrintGCDetails demoXXparam&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28035714285714286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZYb42KXEGAkwvC67iaMfYGAqWsgPbJUbTiaF6icQbDlicjsj8dI3Pv7zJlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;560&quot;/&gt;&lt;figcaption&gt;实验 4&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;hello XX params&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查看demoXXparam进程的 id&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2311046511627907&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZo3QPgBenrKwxVGQicX7qQicGQCJga1cVM59SyFudDiakuUZZ8iajiaxSLCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;688&quot;/&gt;&lt;figcaption&gt;进程 id&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到demoXXparam进程 id 为 1225&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查看 demoXXparam 的配置参数 PrintGCDetails&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开一个新的控制台窗口，执行以下命令来查看进程为 1225 的 &lt;code&gt;PrintGCDetails&lt;/code&gt;参数是否开启&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jinfo -flag PrintGCDetails 1225&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2393538913362702&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZoKiciau8fAkdzibecl7Of5wvlXeGfSenRprXhUwFOyqXb9tbk1jicqwZfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;figcaption&gt;PrintGCDetails 参数&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到PrintGCDetails是开启的，&lt;code&gt;+&lt;/code&gt;号表示开启。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;动手实验 5 - Key-Value 类型参数值&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查看元空间的值&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jinfo -flag MetaspaceSize 526&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28189300411522633&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZz6Cb8Zc6KeqhHuguZ2NCkhPibSiblfmnTWkuOsrB6Bg5ga4lC2LpPeOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;486&quot;/&gt;&lt;figcaption&gt;MetaspaceSize 大小&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可以得出元空间的大小为 21 M。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;设置元空间的值为 128 M&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -XX:MetaspaceSize=128m demoXXparam   &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看元空间的大小&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    jinfo -flag MetaspaceSize 1062&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.14979757085020243&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZhDhGW7yjAdYKK4hOx3qibey566KP1vibyLveAVzWialDsWPd5WbA71zfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;494&quot;/&gt;&lt;figcaption&gt;调整元空间大小&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最常见的 -Xms 和 -Xmx 属于哪种参数？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-Xms参数代表-XX:InitialHeapSize ，初始化堆内存（默认只会用最大物理内存的64分1）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xmx:参数代表-XX:MaxHeapSize ，大堆内存（默认只会用最大物理内存的4分1）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;起了别名，但还是属于XX参数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;动手实验 6 - 设置 -XX:InitialHeapSize 和 -XX:MaxHeapSize 的值。&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -XX:InitialHeapSize=200m demoXXparam&lt;br/&gt;或者&lt;br/&gt;java -Xms200m demoXXparam&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看 InitialHeapSize 参数的值，大小为 200 M。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11092436974789915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZwG0NianRkwmDWQDjvib7b0s0BzXBrdhOaNDtiaZXpVQ7asLfBjWjAhaww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;595&quot;/&gt;&lt;figcaption&gt;设置 InitialHeapSize&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -XX:MaxHeapSize=200M demoXXparam&lt;br/&gt;或者&lt;br/&gt;java -Xmx200m demoXXparam&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看 MaxHeapSize 参数的值，大小为 200 M。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1166407465007776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZLCrRn7XmgRKZnmHlBAib226GQJ5GHdPF2JeyFOriax0cxKIoEzsTv6MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;643&quot;/&gt;&lt;figcaption&gt;设置 MaxHeapSize&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;扩展：查看 Java 程序已设置的所有参数值&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jinfo -flags &amp;lt;进程id&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18092307692307694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZH5eGmKNXINE0vxCqick59uibIw6NNia2GgRswk2nOTGA7jibnqyGkgH5lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1625&quot;/&gt;&lt;figcaption&gt;mark&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Non-Defalut VM flags 代表参数类型是JVM自带的参数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Command line 代表是用户自定义的参数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何查看出厂设置和自定义设置的XX配置项&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;动手实验 7 - 查看出厂默认设置的所有XX配置项&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -XX:+PrintFlagsInitial -version &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3917525773195876&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZdKhtzgVnfYw9AnPC4do9wTFStLM7VqLe75oM3dHgXnKBG4uZtiarE8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;873&quot;/&gt;&lt;figcaption&gt;PrintFlagsInitial&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;动手实验 8 - 查看 JVM 当前所有XX配置项&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -XX:+PrintFlagsFinal -version &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3385731559854897&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZh2SYB0rVUkZUTxIWOf9EASKZKulDGDbjyFxHXC9BhG5vXPpVgib2M2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;827&quot;/&gt;&lt;figcaption&gt;PrintFlagsFinal&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到几个关键信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;[Global flags]&lt;/code&gt;：全局参数，如果自定义修改了某个应用的参数，并不会修改全局参数&lt;/p&gt;&lt;p&gt;比如之前我们修改了MetaspaceSize为128m，但列表里面还是21m。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21217105263157895&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZ3r4UeluuXoMGGzdS1z0c89tGXet97r4jvrM6TqSMJCHCMWXg09gI7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;figcaption&gt;Global flags&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;:=&lt;/code&gt;：参数已被修改，如下图所示InitialHeapSize初始化堆内存参数已修改为264241152&lt;/p&gt;&lt;p&gt;总结如下：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3745583038869258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZ67RQ8BennibiabFnAwdxPLmDsHibNCMJ3RQ2u3lhPUqYzrnugYxqib6tww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;849&quot;/&gt;&lt;figcaption&gt;出厂设置和自定义参数设置&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;动手实验 9 - 运行程序时打印XX配置选项&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -XX:+PrintFlagsFinal -XX:+InitialHeapSize=150M demoXXparam&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到修改后的值为 157286400（150 M）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23616236162361623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZKtcFplFZzricpOl505sTnrt6XrXLTAOjI7JEDSJJZVx6Fbhicdz0BEkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;542&quot;/&gt;&lt;figcaption&gt;运行程序时打印XX配置选项&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;动手实验 10 - 查看 JVM 自动配置的或者用户手动设置的XX选项（非应用程序的）&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -XX:+PrintCommandLineFlags -version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会打印出如下参数：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19164265129682997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1ZZWTnvEcgvUOB9quHRjEZcUqI9bp1qwQWY4T9EId8yQ6Ak5ibsEOgo5lGMKiaiayeicYGNzs7sw23Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;figcaption&gt;JVM 自动配置的XX选项&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实验总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本节实验课学习了如何查看基本参数、X参数、XX参数和设置XX参数。以及用好jps和jinfo工具来查看进程和设置参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;JVM性能调优&lt;/strong&gt;&lt;/span&gt;还有很多要讲的，一篇是讲不完的，我会分成几篇来为大家讲述，形式主要以小实验的方式来为大家讲解。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>79d8a758d3fbfd40697644ebd7a29ef5</guid>
<title>Hugo 搭建静态博客与服务器部署</title>
<link>https://toutiao.io/k/4d8ur4w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot;&gt;
      &lt;p&gt;疫情期间，比较清闲，所以抽时间自学了一些计算机的知识。后来运气非常好地进入了某大厂实习，也运气非常好地实习转正了。考虑到个人发展与家庭的因素，最后决定放弃保研，提早成为一名社畜。不过之前准备实习面试，是直接背面经的，没啥实操经验，知道自己底子特别薄弱。所以趁着实习结束，还未正式入职的这段时间，好好补一补计算机基础。并将我学习到的一些东西记录在这里，希望可以养成及时记录的好习惯，以后无事也可翻看翻看。&lt;/p&gt;
&lt;h2 id=&quot;hugo简介&quot;&gt;Hugo简介&lt;/h2&gt;
&lt;p&gt;Hugo是由Go语言实现的静态网站生成器，据称是「The world’s fastest framework for building websites」。静态网页，可以理解为是由一系列&lt;code&gt;html&lt;/code&gt;文件和&lt;code&gt;css&lt;/code&gt;,&lt;code&gt;js&lt;/code&gt;等静态文件构成的。&lt;code&gt;Hugo&lt;/code&gt;负责把我们写的&lt;code&gt;markdown&lt;/code&gt;转换成&lt;code&gt;html&lt;/code&gt;的形式，我们直接拿着它生成的文件就可以直接发布了。&lt;/p&gt;
&lt;h2 id=&quot;hugo安装&quot;&gt;Hugo安装&lt;/h2&gt;
&lt;h3 id=&quot;1-二进制安装&quot;&gt;1. 二进制安装&lt;/h3&gt;
&lt;p&gt;这里强推&lt;code&gt;homebrew&lt;/code&gt;！Mac直接可以用以下命令安装：&lt;/p&gt;
&lt;p&gt;每次使用brew的时候都会自动更新，需要等待很长时间，可以配置环境变量关闭自动更新。&lt;/p&gt;
&lt;h4 id=&quot;临时关闭&quot;&gt;临时关闭&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;HOMEBREW_NO_AUTO_UPDATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# shell 关闭之后就不生效了&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&quot;永久关闭&quot;&gt;永久关闭&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt; 1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 2
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 3
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 4
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 5
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 6
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 7
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 8
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 9
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;10
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;11
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# bash&lt;/span&gt;
vi ~/.bash_profile
&lt;span class=&quot;c1&quot;&gt;# 添加&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;HOMEBREW_NO_AUTO_UPDATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; ~/.bash_profile


&lt;span class=&quot;c1&quot;&gt;# zsh&lt;/span&gt;
vi ~/.zshrc
&lt;span class=&quot;c1&quot;&gt;# 添加&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;HOMEBREW_NO_AUTO_UPDATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&quot;2-源码安装&quot;&gt;2. 源码安装&lt;/h3&gt;
&lt;p&gt;安装之前需要已经装好&lt;code&gt;Git&lt;/code&gt; 和 &lt;code&gt;Go&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt;1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;2
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;3
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;4
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;mkdir &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/src
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/src
git clone https://github.com/gohugoio/hugo.git
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; hugo
go install
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&quot;hugo快速开始&quot;&gt;Hugo快速开始&lt;/h2&gt;
&lt;p&gt;输入 &lt;code&gt;hugo version&lt;/code&gt;，如果显示出版本号，就说明你的&lt;code&gt;hugo&lt;/code&gt;已经安装好了！Just enjoy it!&lt;/p&gt;
&lt;h3 id=&quot;生成站点&quot;&gt;生成站点&lt;/h3&gt;
&lt;p&gt;期望在当前目录下快速生成站点&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt; 1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 2
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 3
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 4
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 5
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 6
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 7
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 8
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 9
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;10
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;11
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;12
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;13
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;14
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;hugo new site personal_blog

&lt;span class=&quot;c1&quot;&gt;# output&lt;/span&gt;
Congratulations! Your new Hugo site is created in /Users/bingoh/BlogContent/personal_blog.

Just a few more steps and you&lt;span class=&quot;err&quot;&gt;&#x27;&lt;/span&gt;re ready to go:

1. Download a theme into the same-named folder.
   Choose a theme from https://themes.gohugo.io/ or
   create your own with the &lt;span class=&quot;s2&quot;&gt;&quot;hugo new theme &amp;lt;THEMENAME&amp;gt;&quot;&lt;/span&gt; command.
2. Perhaps you want to add some content. You can add single files
   with &lt;span class=&quot;s2&quot;&gt;&quot;hugo new &amp;lt;SECTIONNAME&amp;gt;/&amp;lt;FILENAME&amp;gt;.&amp;lt;FORMAT&amp;gt;&quot;&lt;/span&gt;.
3. Start the built-in live server via &lt;span class=&quot;s2&quot;&gt;&quot;hugo server&quot;&lt;/span&gt;.

Visit https://gohugo.io/ &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; quickstart guide and full documentation.
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后就可以看到当前目录下，多了一个名为&lt;code&gt;personal_blog&lt;/code&gt;的文件。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt; 1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 2
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 3
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 4
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 5
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 6
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 7
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 8
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 9
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# 查看文件结构&lt;/span&gt;
personal_blog
├── archetypes
│   └── default.md
├── config.toml &lt;span class=&quot;c1&quot;&gt;# 更改配置&lt;/span&gt;
├── content &lt;span class=&quot;c1&quot;&gt;# 博客正文的内容&lt;/span&gt;
├── data
├── layouts &lt;span class=&quot;c1&quot;&gt;# html等展示文件&lt;/span&gt;
├── static &lt;span class=&quot;c1&quot;&gt;# js/css/font等静态文件&lt;/span&gt;
└── themes &lt;span class=&quot;c1&quot;&gt;# 下载的主题&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&quot;下载主题&quot;&gt;下载主题&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://themes.gohugo.io/&quot;&gt;Hugo Themes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这里下载你喜欢的主题吧！&lt;/p&gt;
&lt;p&gt;主题有自己的下载说明，以我下载的&lt;code&gt;even&lt;/code&gt;主题为例。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt;1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; personal_blog
git clone https://github.com/olOwOlo/hugo-theme-even themes/even
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;下载完成之后，发现&lt;code&gt;themes&lt;/code&gt;文件夹下多了个&lt;code&gt;even&lt;/code&gt;文件夹，里面有很多文件。一般作者都会在&lt;code&gt;README.md&lt;/code&gt;中作详细说明，这里就不多赘述。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;比如 even 要求将 themes/even/exampleSite/config.toml 文件复制到站点目录下！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;新建page&quot;&gt;新建PAGE&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;personal_blog&lt;/code&gt;文件夹下&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt;1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;2
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;3
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;hugo new post/your_file_name.md

&lt;span class=&quot;c1&quot;&gt;# example&lt;/span&gt;
hugo new post/first.md
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;发现&lt;code&gt;content&lt;/code&gt;下面多了一些文件&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt; 1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 2
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 3
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 4
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 5
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 6
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 7
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 8
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 9
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;10
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;11
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;12
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;content
└── post
    └── first.md
    
    
&lt;span class=&quot;c1&quot;&gt;# 打开first.md&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# output&lt;/span&gt;
---
title: &lt;span class=&quot;s2&quot;&gt;&quot;First&quot;&lt;/span&gt;
date: 2020-10-05T12:32:29+08:00
draft: &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;
---
在这里输入你的正文内容
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;title&lt;/code&gt;是文章标题&lt;/p&gt;
&lt;p&gt;&lt;code&gt;date&lt;/code&gt;是文章创建的日期&lt;/p&gt;
&lt;p&gt;&lt;code&gt;draft&lt;/code&gt;表示是否是草稿&lt;/p&gt;
&lt;p&gt;更多的参数，可以到&lt;code&gt;themes/even/archetypes/default.md&lt;/code&gt;中查看并设置！&lt;/p&gt;
&lt;h2 id=&quot;运行hugo&quot;&gt;运行hugo&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt;1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;2
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;3
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;4
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;5
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;6
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# personal_blog 目录下运行&lt;/span&gt;
hugo server --theme&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;even --buildDrafts

&lt;span class=&quot;c1&quot;&gt;# output&lt;/span&gt;
... 省略
Web Server is available at http://localhost:1313/ &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;bind&lt;/span&gt; address 127.0.0.1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;浏览器打开 &lt;code&gt;http://localhost:1313/&lt;/code&gt;，就可以看到新的站点啦！&lt;/p&gt;
&lt;h2 id=&quot;部署hugo&quot;&gt;部署hugo&lt;/h2&gt;
&lt;p&gt;我之前自己买了腾讯云的服务器和域名，并且关联好了域名和服务器，所以就直接部署在自己的服务器上了。如果没有服务器的话，直接部署在&lt;code&gt;github&lt;/code&gt;上也是完全ok的！&lt;/p&gt;
&lt;p&gt;我使用&lt;code&gt;宝塔面板&lt;/code&gt;来运维！真的是超级方便，一键部署，适合小白。&lt;a href=&quot;https://www.bt.cn&quot;&gt;链接：宝塔面板&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;按照指示在自己的服务器上部署好了之后，就可以直接用了！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;网站&lt;/code&gt; –&amp;gt;  &lt;code&gt;添加站点&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gjed4rt5clj31900u0gs8.jpg&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;hugo --theme&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;even -b https://www.binfromfd.com/ &lt;span class=&quot;c1&quot;&gt;# 发现生成 public 文件夹&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;将生成的&lt;code&gt;public&lt;/code&gt;文件夹，复制到网站的根目录下，访问你的网站！就可以看到啦！&lt;/p&gt;
&lt;h3 id=&quot;自动发布&quot;&gt;自动发布&lt;/h3&gt;
&lt;p&gt;将自己的代码放到&lt;code&gt;github&lt;/code&gt;仓库中，然后在服务器上开一个定时任务去拉取代码。&lt;/p&gt;
&lt;p&gt;宝塔：&lt;code&gt;计划任务&lt;/code&gt; –&amp;gt; &lt;code&gt;添加计划任务&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;添加一个&lt;code&gt;shell&lt;/code&gt;脚本&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt;1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;2
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~/blog &lt;span class=&quot;c1&quot;&gt;# 已经和git仓库关联&lt;/span&gt;
git pull
cp -rf ~/blog/public/. /www/wwwroot/www.binfromfd.cn/
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;之后，在自己电脑上写好代码之后&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;hugo --theme&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;even --baseUrl&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://www.binfromfd.cn/&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果md开头有&lt;code&gt;draft=true&lt;/code&gt;，说明是草稿文件，这里是不会生成文章的。可以令&lt;code&gt;draft=false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后&lt;code&gt;push&lt;/code&gt;到&lt;code&gt;git&lt;/code&gt;上就可以了。可以等定时任务的时间到了再执行，也可以直接在宝塔面板中执行脚本！&lt;/p&gt;

    &lt;/div&gt;

    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e517a18c9d68c1dbcde362a5818120d1</guid>
<title>Paxos 分布式必问的内容，没有之一</title>
<link>https://toutiao.io/k/fhmqfyd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;blockquote data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;Google Chubby 的作者 Mike Burrows 说过：There is only one consensus protocol, and that&#x27;s Paxos.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;amp;mid=2247483855&amp;amp;idx=1&amp;amp;sn=55a9c2c1eb28310e678c35df91d33818&amp;amp;chksm=9709820aa07e0b1c2c82f94bbbd530d6a60fdd78b3a3171b93aff3e755b8f501dc7f243e78ac&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;上文&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;上文&lt;/a&gt;我们已经详细的阐述了共识问题并介绍了一些共识算法，其中 Paxos 算法是 Leslie Lamport 于 1990 年提出的共识算法，不幸的是采用希腊民主议会的比喻很明显失败了，Lamport 像写小说一样，把一个复杂的数学问题弄成了一篇带有考古色彩的历史小说。根据 &lt;span&gt;Lamport 自己的描述&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;，三个审稿者都认为该论文尽管并不重要但还有些意思，只是应该把其中所有 Paxos 相关的故事背景删掉。Lamport 对这些缺乏幽默感的人感到生气，所以他不打算对论文做任何修改。&lt;/p&gt;&lt;p&gt;多年后，两个在 SRC(&lt;em&gt;Systems Research Center，DEC 于 1984 年创立，Lamport 也曾在此工作过&lt;/em&gt;)工作的人需要为他们正在构建的分布式系统寻找一些合适算法，而 Paxos 恰恰提供了他们想要的。Lamport 就将论文发给他们，他们也没觉得该论文有什么问题。&lt;/p&gt;&lt;p&gt;因此，Lamport 觉得论文重新发表的时间到了，&quot;&lt;span&gt;The Part-Time Parliament&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;&quot; 最终在 1998 年公开发表。&lt;/p&gt;&lt;p&gt;可是很多人抱怨这篇论文根本看不懂啊，人们只记住了那个奇怪的故事，而不是 Paxos 算法。Lamport 走到哪都要被人抱怨一通。于是他忍无可忍，2001 年重新发表了一篇关于 Paxos 的论文——&quot;&lt;span&gt;Paxos Made Simple&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;&quot;，这次论文中一个公式也没有，摘要也只有一句话：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The Paxos algorithm, when presented in plain English, is very simple.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;满满的都是嘲讽！&lt;/p&gt;&lt;p&gt;然而，可能是表述顺序的原因，这篇论文还是非常难以理解，于是人们写了一系列文章来解释这篇论文（重复造论文），以及在工程上如何实现它。&lt;/p&gt;&lt;p&gt;其中，个人认为讲解 Paxos 最好的&lt;span&gt;视频&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;来自于 Raft 算法作者 Diego Ongaro，本文采用 Diego 讲义中的图片来理解 Paxos 算法，也纠正了一个个人认为 Diego 笔误的地方。&lt;/p&gt;&lt;h2&gt;术语&lt;/h2&gt;&lt;h3&gt;基本概念&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Proposal Value：提案的值；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Proposal Number：提案编号；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Proposal：提案 = 提案编号 + 提案的值；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Chosen：批准，也叫选定。一旦某个值被 Chosen，后续 Paxos 都必须用该值进行交互。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;注：Proposal 有人叫“提议”有人叫“提案”，此处和维基百科里的翻译保持一致，叫“提案”。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;角色&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Proposer：提案发起者；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Acceptor：提案接收者；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Learner：提案学习者；&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;问题描述&lt;/h2&gt;&lt;p&gt;为了高可用性，一种常见的设计是用一个 master 节点来写，然后复制到各个 slave 节点。这种解决方法的问题在于，一旦 master 节点故障，整个服务将不可用或者数据不一致。&lt;/p&gt;&lt;p&gt;为了克服单点写入问题，于是有了多数派（Quorum）写，思路就是写入一半以上的节点。即，如果集群中有 N 个节点，客户端需要写入 W &amp;gt;= N/2 + 1 个节点。不需要主节点。这种方法可以容忍最多 (N-1)/2 个节点故障。&lt;/p&gt;&lt;p&gt;但是问题依然存在：每个接收者该如何决定是否接受这次请求的值呢？&lt;/p&gt;&lt;p&gt;如果我们接受第一次收到的值，那么当出现以下情况（Split Votes），则没有出现多数派，没有一个值被 Chosen，算法无法终止，这违反了&lt;strong&gt;活性（liveness）&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3663220088626292&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA1TpDib6CtZv9Tia2Gp0pdbmATgHuIXQjFGXNjbgib2jlP85GUK41HqIsh2ibRWxetUljwNTtPbDHduPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;677&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了解决 Split Votes 问题，我们允许接受多个不同的值，收到的&lt;strong&gt;每一个(every)&lt;/strong&gt;请求都接受，这时候新的问题出现了，如下，可能不止一个值被 Chosen，这违反了&lt;strong&gt;安全性（safety）&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4258064516129032&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA1TpDib6CtZv9Tia2Gp0pdbmAwufTZsNdasYibG5wF3555zibIJZZJpkvW0Dym2oWmlAKaJAfdSxFnzcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;930&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;注意，Paxos 强调：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Once a value has been chosen, future proposals must propose the same value.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;也就是说，我们讨论的 Basic-Paxos 只会 Chosen 一个值。基于此，就需要一个两阶段（2-phase）协议，对于已经 Chosen 的值，&lt;strong&gt;后面的提案&lt;/strong&gt;也要使用相同的值。&lt;/p&gt;&lt;p&gt;如下图这种情况，S3 直接拒绝 &lt;code&gt;red&lt;/code&gt; 值，因为 &lt;code&gt;blue&lt;/code&gt; 已经 Chosen，这样就可以保证成功。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.44135802469135804&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA1TpDib6CtZv9Tia2Gp0pdbmALBYCpjBATMiakHvoHK03ic9VPrVuC1mRyHv0B2nqJ1c5ibEnBTwVB65Kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种方式我们需要对提案进行排序。如果你熟悉分布式系统，应该能想到 &quot;&lt;span&gt;Time, Clocks and the Ordering of Events in a Distributed System&lt;sup&gt;[5]&lt;/sup&gt;&lt;/span&gt;&quot; 这篇论文，我们不能用时间来判断提案的先后顺序。&lt;/p&gt;&lt;h2&gt;Proposal Number&lt;/h2&gt;&lt;p&gt;一种简单的方式就是每个请求一个唯一的编号，例如：&lt;code&gt;&amp;lt;seq_id, server_id&amp;gt;&lt;/code&gt;，为了排序 &lt;code&gt;seq_id&lt;/code&gt; 是自增的；同时为了避免崩溃重启，必须能在本地持久化存储。&lt;/p&gt;&lt;h2&gt;Paxos&lt;/h2&gt;&lt;p&gt;现在我们终于可以开始描述 Paxos 算法了。&lt;/p&gt;&lt;p&gt;如上所述，Paxos 是一个两阶段算法。我们把第一个阶段叫做准备（Prepare）阶段，第二个阶段叫做接受（Accept）阶段。分别对应两轮 RPC。&lt;/p&gt;&lt;h3&gt;第一轮 Prepare RPCs：&lt;/h3&gt;&lt;h3&gt;请求（也叫 Prepare 阶段）：&lt;/h3&gt;&lt;p&gt;Proposer 选择一个提案编号 n，向所有的 Acceptor 广播 &lt;code&gt;Prepare(n)&lt;/code&gt; 请求。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;这里 Prepare（n）不包含提案的值。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;伪代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c++&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;send PREPARE(++n)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;响应（也叫 PROMISE 阶段）：&lt;/h3&gt;&lt;p&gt;Acceptor 接收到 &lt;code&gt;Prepare（n)&lt;/code&gt; 请求，此时有两种情况：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;如果 n 大于之前接受到的所有 Prepare 请求的编号，则返回 &lt;code&gt;Promise()&lt;/code&gt; 响应，并承诺将不会接收编号小于 n 的提案。如果有提案被 Chosen 的话，&lt;code&gt;Promise()&lt;/code&gt; 响应还应包含前一次提案编号和对应的值。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;否则（即 n 小于等于 Acceptor 之前收到的最大编号）忽略，但常常会回复一个拒绝响应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;所以，Acceptor 需要持久化存储 max_n、accepted_N 和 accepted_VALUE&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;伪代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c++&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;if (n &amp;gt; max_n)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    max_n = n     // save highest n we&#x27;ve seen so far&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (proposal_accepted == true) // was a proposal already accepted?&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        respond: PROMISE(n, accepted_N, accepted_VALUE)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    else&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        respond: PROMISE(n)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;else&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    do not respond (or respond with a &quot;fail&quot; message)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;第二轮 Accept RPCs：&lt;/h3&gt;&lt;h3&gt;请求（也叫 PROPOSE 阶段）：&lt;/h3&gt;&lt;p&gt;当 Proposer 收到&lt;strong&gt;超过半数 Acceptor&lt;/strong&gt; 的 &lt;code&gt;Promise()&lt;/code&gt; 响应后，Proposer 向&lt;strong&gt;多数派&lt;/strong&gt;的 Acceptor 发起 &lt;code&gt;Accept(n, value)&lt;/code&gt; 请求并带上提案编号和值。（注：这里讲义的算法流程图是向所有的 Acceptor 发起 &lt;code&gt;Accept()&lt;/code&gt; 请求，鄙人认为应该改为向多数派 Acceptor 发起。）&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注意：Proposer 不一定是将 &lt;code&gt;Accept()&lt;/code&gt; 请求发给有应答的多数派 Acceptors，可以再选另一个多数派 Acceptors 广播 &lt;code&gt;Accept()&lt;/code&gt; 请求。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关于值 value 的选择：&lt;/strong&gt;如果前面的 Promise 响应有返回 &lt;code&gt;accepted_VALUE&lt;/code&gt;，那就使用这个值作为 value。如果没有返回 &lt;code&gt;accepted_VALUE&lt;/code&gt;，那可以自由决定提案值 value。&lt;/p&gt;&lt;p&gt;伪代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c++&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;did I receive PROMISE responses from a majority of acceptors?&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;if yes&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    do any responses contain accepted values (from other proposals)?&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if yes&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        val = accepted_VALUE    // value from PROMISE message with the highest accepted ID&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if no&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        val = VALUE     // we can use our proposed value&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    send Accept(ID, val) to at least a majority of acceptors&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;响应（也叫 ACCEPT 阶段）：&lt;/h3&gt;&lt;p&gt;Acceptor 收到 &lt;code&gt;Accept()&lt;/code&gt; 请求，在这期间如果 Acceptor 没有对比 n 更大的编号另行 Promise，则接受该提案。&lt;/p&gt;&lt;p&gt;伪代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c++&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;if (n &amp;gt;= max_n) // is the n the largest I have seen so far?&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    proposal_accepted = true     // note that we accepted a proposal&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    accepted_N = n             // save the accepted proposal number&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    accepted_VALUE = VALUE       // save the accepted proposal data&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    respond: Accepted(N, VALUE) to the proposer and all learners&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;else&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    do not respond (or respond with a &quot;fail&quot; message)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;一些例子&lt;/h2&gt;&lt;h3&gt;情况 1：提案已 Chosen&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hBL5R2neMA1TpDib6CtZv9Tia2Gp0pdbmAFLHW7YtjGYoR5q8zOM0TtgZu4rZfqVGhZ3zgKpPwA5wUDiaiaibT540hg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;S1 收到客户端提案请求 X，于是 S1 向 S1-S3 发起 &lt;code&gt;Prepare(3.1)&lt;/code&gt; 请求，&lt;code&gt;PROMISE()&lt;/code&gt; 响应返回没有提案被 Chosen&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;由于 S1-S3 没有任何提案被 Chosen，S1 继续向 S1-S3 发送 &lt;code&gt;Accept(3.1, X)&lt;/code&gt; 请求，提案被成功 Chosen&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;在提案被 Chosen 后，S5 收到客户端提案值为 Y 的请求，向 S3-S5 发送 &lt;code&gt;Prepare(4.5)&lt;/code&gt; 请求，由于编号 4 &amp;gt; 3 会收到提案值为 X 已经被 Chosen 的 &lt;code&gt;PROMISE()&lt;/code&gt; 响应&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;于是 S5 &lt;strong&gt;将提案值 Y 替换成 X&lt;/strong&gt;，向 S1-S3 发送 &lt;code&gt;Accept(4.5, X)&lt;/code&gt; 请求，提案再次被 Chosen&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;情况 2：提案未 Chosen，Proposer 可见&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hBL5R2neMA1TpDib6CtZv9Tia2Gp0pdbmAuXFDZnlOib2cGCdibulib6Uibza88vxwI44QoEVxNlMHkLP3WpENGOP1bA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;情况 2 和情况 1 类似，在 S3 Chosen 了提案后，S5 收到来自 S3 的 &lt;code&gt;PROMISE()&lt;/code&gt; 响应包含了已经 Chosen 的提案值 X，所以同样会将提案值替换成 X，最终所有 Acceptor 对 X 达成共识。&lt;/p&gt;&lt;p&gt;注意上面的伪代码：&lt;code&gt;do any responses contain accepted values&lt;/code&gt;，也就是说只要有一个 Acceptor 在 &lt;code&gt;Promise()&lt;/code&gt; 响应中返回了提案值，就要用它来替换提案值。&lt;/p&gt;&lt;h3&gt;情况 3：提案未提交，Proposer 不可见&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.34375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hBL5R2neMA1TpDib6CtZv9Tia2Gp0pdbmA0rcnVVjqUyZzohzCcqZ6LCKPfibKKayuLaETGYUianMtxWz1WBQALkXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;情况 3 中，提案只被 S1 Chosen，S3 还未 Chosen 该提案，S3-S5 的 &lt;code&gt;Promise()&lt;/code&gt; 响应中没有任何提案信息，所以 S5 自行决定提案值为 Y，发送 &lt;code&gt;Accept(4.5, Y)&lt;/code&gt; 请求。&lt;/p&gt;&lt;p&gt;由于此时 S3 承诺的提案编号 n 变为了 4 且 4 大于 3，所以 S3 不再接受 S1 后续的 &lt;code&gt;Accept(3.1, X)&lt;/code&gt; 请求。提案值 X 被阻止，而提案值 Y 最终被 Chosen。&lt;/p&gt;&lt;h2&gt;活锁&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.29609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hBL5R2neMA1TpDib6CtZv9Tia2Gp0pdbmAlXdeQTANN6poUJMN8C0ATqg2xwK9O7MQQtLpia0covyJbGsgA5tMg9w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如图：当 Proposer 在第一轮 Prepare 发出请求，还没来得及后续的第二轮 Accept 请求，紧接着第二个 Proposer 在第一阶段也发出编号更大的请求。如果这样无穷无尽，Acceptor 始终停留在决定顺序号的过程上，那大家谁也成功不了。&lt;/p&gt;&lt;p&gt;解决活锁最简单的方式就是引入&lt;strong&gt;随机超时&lt;/strong&gt;，这样可以让某个 Proposer 先进行提案，减少一直互相抢占的可能。&lt;/p&gt;&lt;h2&gt;结语&lt;/h2&gt;&lt;p&gt;Paxos 只从一个或多个值中选择一个值，如果需要重复运行 Paxos 来创建复制状态机，我们称之为 multi-Paxos，但如果每个命令都通过一个Basic Paxos算法实例来达到一致，会产生大量开销。对于 multi-Paxos 可以做一些优化，我们在下篇文章中讨论 Paxos 的变种。&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; Lamport 自己的描述: &lt;em&gt;http://lamport.azurewebsites.net/pubs/pubs.html#lamport-paxos&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; The Part-Time Parliament: &lt;em&gt;https://lamport.azurewebsites.net/pubs/lamport-paxos.pdf&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; Paxos Made Simple: &lt;em&gt;https://lamport.azurewebsites.net/pubs/paxos-simple.pdf&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; 视频: &lt;em&gt;https://www.youtube.com/watch?v=JEpsBg0AO6o&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[5]&lt;/code&gt; Time, Clocks and the Ordering of Events in a Distributed System: &lt;em&gt;http://lamport.azurewebsites.net/pubs/time-clocks.pdf&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;后台回复 &lt;strong&gt;&lt;span&gt;学习资料&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;领取学习视频&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.511002444987775&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39zWmaics1nAAwT4NCD77uDcf6vcXE1DAHybibTY0V3XDmf4YX1q9qYibIwz9xmRVTkEvTjP87gaKEZrQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如有收获，点个在看，诚挚感谢&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c23827a6cb896912062951846399ff1e</guid>
<title>Redis 6.0 如何实现大幅度的性能提升？</title>
<link>https://toutiao.io/k/ji0jw42</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;导读: Redis可以轻松支撑100k+ QPS，离不开基于Reactor模型的I/O Multiplexing，In-memory操作，以及单线程执行命令避免竞态消耗。尽管性能已经能满足大多数应用场景，但是如何继续在迭代中继续优化，以及在多核时代利用上多线程的优势，也是大家关注的重点。我们知道性能优化在系统资源层面可以从I/O以及CPU上入手，对于Redis而言，其功能不过度依赖CPU计算能力，即不是CPU密集型的应用，而In-memory的操作也绕开了通常会拖慢性能的磁盘I/O，所以在Redis 6.0版本中，作者Antirez从网络I/O入手，引入Threaded I/O辅助读写，在一些场景下实现了大幅度的性能提升。本文将介绍Redis的事件模型，分析Threaded I/O是如何帮助提升性能，以及其实现的原理。&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者：朱杰坤 @ Shopee&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：&lt;/span&gt;&lt;span&gt;https://jiekun.dev/posts/2020-09-20-redis-6-0%E6%96%B0feature%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-threaded-i-o/&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Introduction&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis从6.0版本开始引入了Threaded I/O，目的是为了提升执行命令前后的网络I/O性能。本文会先从Redis的主流程开始分析，讲解网络I/O发生在哪里，以及现有的网络I/O模型，然后介绍Threaded I/O的新模型、实现以及生效场景，最后会进行场景测试，对比Threaded I/O关闭与开启，以及启用Threaded I/O与在单实例上搭建集群的性能差异。如果你已经了解过Redis的循环流程，可以直接跳至&lt;strong&gt;Threaded I/O相关&lt;/strong&gt;的部分；如果你只关心新功能的实际提升，可以跳至&lt;strong&gt;性能测试&lt;/strong&gt;部分查看。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Redis是如何运行的&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;事件循环&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;main&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis的入口位于server.c下，&lt;code&gt;main()&lt;/code&gt;方法流程如图所示。&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1flHOHZw6RtQhSq5yr610xncleFgIkMibibjmw8ShwScljE5XzKJ3cVKM5xZUJ4QEA2p4CaQ94KGCGHOeINaBWIQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;在&lt;code&gt;main()&lt;/code&gt;方法中Redis首先需要做的是&lt;strong&gt;初始化各种库以及服务配置&lt;/strong&gt;。具体举例：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;crc64_init()&lt;/code&gt;会初始化一个crc校验用的Lookup Table&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;getRandomBytes()&lt;/code&gt;为&lt;code&gt;hashseed&lt;/code&gt;填充随机元素作为初始化值，用作哈希表的seed&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;initServerConfig()&lt;/code&gt;中执行了大量对&lt;code&gt;server&lt;/code&gt;对象属性的初始化操作：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始化&lt;code&gt;server.runid&lt;/code&gt;，如&lt;code&gt;16e05f486b8d41e79593a35c8b96edaff101c194&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取当前的时区信息，存放至&lt;code&gt;server.timezone&lt;/code&gt;中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初始化&lt;code&gt;server.next_client_id&lt;/code&gt;值，使得连接进来的客户端id从1开始自增&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ACLInit()&lt;/code&gt;是对Redis 6.0新增的ACL系统的初始化操作，包括初始化用户列表、ACL日志、默认用户等信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过&lt;code&gt;moduleInitModulesSystem()&lt;/code&gt;和&lt;code&gt;tlsInit()&lt;/code&gt;初始化模块系统和SSL等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化结束后，开始&lt;strong&gt;读取用户的启动参数&lt;/strong&gt;，和大多数配置加载过程类似，Redis也通过字符串匹配等分析用户输入的&lt;code&gt;argc&lt;/code&gt;和&lt;code&gt;argv[]&lt;/code&gt;，这个过程中可能会发生：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取到配置文件路径，修改&lt;code&gt;server.configfile&lt;/code&gt;的值，后续用于加载配置文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取到启动选项参数，如&lt;code&gt;loadmodule&lt;/code&gt;和对应的Module文件路径，保存至&lt;code&gt;options&lt;/code&gt;变量中&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析完参数之后，执行&lt;code&gt;loadServerConfig()&lt;/code&gt;，&lt;strong&gt;读取配置文件并与命令行参数options的内容进行合并&lt;/strong&gt;，组成一个&lt;code&gt;config&lt;/code&gt;变量，并且逐个将name和value设置进configs列表中。对于每个config，有对应的switch-case的代码，例如对于&lt;code&gt;loadmodule&lt;/code&gt;，会执行&lt;code&gt;queueLoadModule()&lt;/code&gt;方法，以完成真正的配置加载：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!strcasecmp(argv[&lt;span&gt;0&lt;/span&gt;],&lt;span&gt;&quot;logfile&quot;&lt;/span&gt;) &amp;amp;&amp;amp; argc == &lt;span&gt;2&lt;/span&gt;) {   &lt;br/&gt;            ... &lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!strcasecmp(argv[&lt;span&gt;0&lt;/span&gt;],&lt;span&gt;&quot;loadmodule&quot;&lt;/span&gt;) &amp;amp;&amp;amp; argc &amp;gt;= &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;            queueLoadModule(argv[&lt;span&gt;1&lt;/span&gt;],&amp;amp;argv[&lt;span&gt;2&lt;/span&gt;],argc&lt;span&gt;-2&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!strcasecmp(argv[&lt;span&gt;0&lt;/span&gt;],&lt;span&gt;&quot;sentinel&quot;&lt;/span&gt;)) {&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到&lt;code&gt;main&lt;/code&gt;方法的流程，Redis会开始打印启动的日志，执行&lt;code&gt;initServer()&lt;/code&gt;方法，服务根据配置项，继续&lt;strong&gt;为&lt;code&gt;server&lt;/code&gt;对象初始化内容&lt;/strong&gt;，例如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建事件循环结构体&lt;code&gt;aeEventLoop&lt;/code&gt;（定义在ae.h），赋值给&lt;code&gt;server.el&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据配置的db数目，分配大小为&lt;code&gt;sizeof(redisDb) * dbnum&lt;/code&gt;的内存空间，&lt;code&gt;server.db&lt;/code&gt;保存这块空间的地址指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个db都是一个redisDb结构，将这个结构中的保存key、保存过期时间等的字典初始化为空dict&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此后就是一些根据不同运行模式的初始化，例如常规模式运行时会记录常规日志、加载磁盘持久化的数据；而在sentinel模式运行时记录哨兵日志，不加载数据等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在所有准备操作都完成后，&lt;strong&gt;Redis开始陷入&lt;code&gt;aeMain()&lt;/code&gt;的事件循环，在这个循环中会不断执行&lt;code&gt;aeProcessEvents()&lt;/code&gt;处理发生的各种事件，直到Redis结束退出&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;两种事件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis中存在有两种类型的事件：&lt;strong&gt;时间事件&lt;/strong&gt;、&lt;strong&gt;文件事件&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;时间事件也就是到了一定时间会发生的事件&lt;/strong&gt;，在Redis中它们被记录成一个链表，每次创建新的时间事件的时候，都会在链表头部插入一个&lt;code&gt;aeTimeEvent&lt;/code&gt;节点，其中保存了该事件会在何时发生，需要调用什么样的方法处理。遍历整个链表我们可以知道离最近要发生的时间事件还有多久，因为链表里面的节点按照自增id顺序排列，而在发生时间的维度上时乱序的。&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1flHOHZw6RtQhSq5yr610xncleFgIkMiblh6ZM1KZt2iatQJibysjykib6q1lv6OtwL4xUhjSKgTg5GHxLGic3oJY4g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;文件事件可以看作I/O引起的事件&lt;/strong&gt;，客户端发送命令会让服务端产生一个读I/O，对应一个读事件；同样当客户端等待服务端消息的时候需要变得可写，让服务端写入内容，因此会对应一个写事件。&lt;code&gt;AE_READABLE&lt;/code&gt;事件会在客户端建立连接、发送命令或其他连接变得可读的时候发生，而&lt;code&gt;AE_WRITABLE&lt;/code&gt;事件则会在客户端连接变得可写的时候发生。&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1flHOHZw6RtQhSq5yr610xncleFgIkMibwYcyibOg2mn3avCicqLTs1VPlLdRIfl2EEzGT01q1iaZAQAF0WCXpoxXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件事件的结构简单很多，&lt;code&gt;aeFileEvent&lt;/code&gt;记录了这是一个可读事件还是可写事件，对应的处理方法，以及用户数据。&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1flHOHZw6RtQhSq5yr610xncleFgIkMibZI4VofS5dUckAJKDVKNeb0z1H8xaSabI0htAP4PsbSL7wDWGiaURSXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果同时发生了两种事件，Redis会优先处理&lt;code&gt;AE_READABLE&lt;/code&gt;事件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;aeProcessEvents&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;aeProcessEvents()&lt;/code&gt;方法处理已经发生和即将发生的各种事件&lt;/strong&gt;。&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1flHOHZw6RtQhSq5yr610xncleFgIkMibmqSJ7PZ1B5TQsVQ80mjByng0HvEjH0bTe0ibBOrkA94QbwHV4Rra7Hg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;aeMain()&lt;/code&gt;循环进入&lt;code&gt;aeProcessEvents()&lt;/code&gt;后，Redis首先检查下一次的时间事件会在什么时候发生，在还没有时间事件发生的这段时间内，可以调用多路复用的API &lt;code&gt;aeApiPoll()&lt;/code&gt;阻塞并等待文件事件的发生。如果没有文件事件发生，那么超时后返回0，否则返回已发生的文件事件数量&lt;code&gt;numevents&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在有文件事件可处理的情况下，Redis会调用&lt;code&gt;AE_READABLE&lt;/code&gt;事件的&lt;code&gt;rfileProc&lt;/code&gt;方法以及&lt;code&gt;AE_WRITABLE&lt;/code&gt;事件的&lt;code&gt;wfileProc&lt;/code&gt;方法进行处理：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!invert &amp;amp;&amp;amp; fe-&amp;gt;mask &amp;amp; mask &amp;amp; AE_READABLE) {&lt;br/&gt;                fe-&amp;gt;rfileProc(eventLoop,fd,fe-&amp;gt;clientData,mask);&lt;br/&gt;                fired++;&lt;br/&gt;                fe = &amp;amp;eventLoop-&amp;gt;events[fd];&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (fe-&amp;gt;mask &amp;amp; mask &amp;amp; AE_WRITABLE) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!fired || fe-&amp;gt;wfileProc != fe-&amp;gt;rfileProc) {&lt;br/&gt;                    fe-&amp;gt;wfileProc(eventLoop,fd,fe-&amp;gt;clientData,mask);&lt;br/&gt;                    fired++;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在完成前面的处理后，Redis会继续调用&lt;code&gt;processTimeEvents()&lt;/code&gt;处理时间事件。遍历整个时间事件链表，如果此时已经过了一段时间（阻塞等待或处理文件事件耗时），有时间事件发生，那么就调用对应时间事件的&lt;code&gt;timeProc&lt;/code&gt;方法，将所有已经过时的时间事件处理掉：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (te-&amp;gt;when &amp;lt;= now) {&lt;br/&gt;            ...&lt;br/&gt;            retval = te-&amp;gt;timeProc(eventLoop, id, te-&amp;gt;clientData);&lt;br/&gt;            ...&lt;br/&gt;            processed++;&lt;br/&gt;            ...&lt;br/&gt;        }&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果执行了文件事件之后还没有到最近的时间事件发生点，那么本次&lt;code&gt;aeMain()&lt;/code&gt;循环中将没有时间事件被执行，进入下一次循环。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;命令执行前后发生了什么&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在客户端连接上Redis的时候，通过执行&lt;code&gt;connSetReadHandler(conn, readQueryFromClient)&lt;/code&gt;，设置了当读事件发生时，使用&lt;code&gt;readQueryFromClient()&lt;/code&gt;作为读事件的Handler。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在收到客户端的命令请求时，Redis进行一些检查和统计后，调用&lt;code&gt;read()&lt;/code&gt;方法将连接中的数据读取进&lt;code&gt;client.querybuf&lt;/code&gt;消息缓冲区中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;readQueryFromClient&lt;/span&gt;&lt;span&gt;(connection *conn)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    nread = connRead(c-&amp;gt;conn, c-&amp;gt;querybuf+qblen, readlen);&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;connRead&lt;/span&gt;&lt;span&gt;(connection *conn, &lt;span&gt;void&lt;/span&gt; *buf, &lt;span&gt;size_t&lt;/span&gt; buf_len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; conn-&amp;gt;type-&amp;gt;read(conn, buf, buf_len);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;connSocketRead&lt;/span&gt;&lt;span&gt;(connection *conn, &lt;span&gt;void&lt;/span&gt; *buf, &lt;span&gt;size_t&lt;/span&gt; buf_len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; ret = read(conn-&amp;gt;fd, buf, buf_len);&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后进入&lt;code&gt;processInputBuffer(c)&lt;/code&gt;开始读取输入缓冲区中的消息，最后进入&lt;code&gt;processCommand(c)&lt;/code&gt;开始处理输入的命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在命令执行得到结果后，首先会存放在&lt;code&gt;client.buf&lt;/code&gt;中，并且调用调用&lt;code&gt;addReply(client *c, robj *obj)&lt;/code&gt;方法，将这个&lt;code&gt;client&lt;/code&gt;对象追加到&lt;code&gt;server.clients_pending_write&lt;/code&gt;列表中。此时当次的命令，或者说&lt;code&gt;AE_READABLE&lt;/code&gt;事件就已经基本处理完毕了，除了一些额外的统计数据、后处理以外，不会再进行发送响应消息的动作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1flHOHZw6RtQhSq5yr610xncleFgIkMibm9QHC1EKhwKibMyyL1EHZkg2FQB3ib3WDxw7ofk6Zxd9niaLhlsLBT0nQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在当前&lt;code&gt;aeProcessEvents()&lt;/code&gt;方法结束后，进入&lt;strong&gt;下一次的循环&lt;/strong&gt;，第二次循环调用I/O多路复用接口等待文件事件发生前，Redis会检查&lt;code&gt;server.clients_pending_write&lt;/code&gt;是否有客户端需要进行回复，若有，遍历指向各个待回复客户端的&lt;code&gt;server.clients_pending_write&lt;/code&gt;列表，逐个将客户端从中删除，并将待回复的内容通过&lt;code&gt;writeToClient(c,0)&lt;/code&gt;回复出去&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;writeToClient&lt;/span&gt;&lt;span&gt;(client *c, &lt;span&gt;int&lt;/span&gt; handler_installed)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    nwritten = connWrite(c-&amp;gt;conn,c-&amp;gt;buf+c-&amp;gt;sentlen,c-&amp;gt;bufpos-c-&amp;gt;sentlen);&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;connWrite&lt;/span&gt;&lt;span&gt;(connection *conn, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *data, &lt;span&gt;size_t&lt;/span&gt; data_len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; conn-&amp;gt;type-&amp;gt;write(conn, data, data_len);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;connSocketWrite&lt;/span&gt;&lt;span&gt;(connection *conn, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *data, &lt;span&gt;size_t&lt;/span&gt; data_len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; ret = write(conn-&amp;gt;fd, data, data_len);&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Threaded I/O模型&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;I/O问题与Threaded I/O的引入&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要说Redis会有什么性能问题，那么从I/O角度，由于它没有像其他Database一样使用磁盘，所以不存在磁盘I/O的问题。在数据进入缓冲区前及从缓冲区写至Socket时，存在一定的网络I/O，特别是写I/O对性能影响比较大。以往我们会考虑做管道化来减小网络I/O的开销，或者将Redis部署成Redis集群来提升性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Redis 6.0之后，由于Threaded I/O的引入，Redis开始支持对网络读写的线程化，让更多的线程参与进这部分动作中，同时保持命令的单线程执行。这样的改动从某种程度上说可以既提升性能，但又避免将命令执行线程化而需要引入锁或者其他方式解决并行执行的竞态问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Threaded I/O在做什么&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在老版本的实现中，Redis将不同client的命令执行结果保存在各自的&lt;code&gt;client.buf&lt;/code&gt;中，然后把待回复的&lt;code&gt;client&lt;/code&gt;存放在一个列表里，最后在事件循环中逐个将&lt;code&gt;buf&lt;/code&gt;的内容写至对应Socket。对应在新版本中，Redis使用多个线程完成这部分操作。&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1flHOHZw6RtQhSq5yr610xncleFgIkMiboqLicJXkNtZvuGlWvYjEFxnvbXo6fpgh2IUriadibpHL2jahgTZUaTQlg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对读操作，Redis同样地为&lt;code&gt;server&lt;/code&gt;对象新增了一个&lt;code&gt;clients_pending_read&lt;/code&gt;属性，当读事件来临时，判断是否满足线程化读的条件，如果满足，那么执行延迟读操作，将这个&lt;code&gt;client&lt;/code&gt;对象添加到&lt;code&gt;server.clients_pending_read&lt;/code&gt;列表中。和写操作一样，留到下一次事件循环时使用多个线程完成读操作。&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1flHOHZw6RtQhSq5yr610xncleFgIkMibwgHK4icQibmia1Z9WO8mcRUdM9DJ9Brzf3kI7PSciaPp1TaKEibawg3ickicQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Threaded I/O的实现与限制&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Init阶段&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Redis启动时，如果满足对应参数配置，会进行I/O线程初始化的操作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;initThreadedIO&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    server.io_threads_active = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.io_threads_num == &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.io_threads_num &amp;gt; IO_THREADS_MAX_NUM) {&lt;br/&gt;        serverLog(LL_WARNING,&lt;span&gt;&quot;Fatal: too many I/O threads configured. &quot;&lt;/span&gt;&lt;br/&gt;                             &lt;span&gt;&quot;The maximum number is %d.&quot;&lt;/span&gt;, IO_THREADS_MAX_NUM);&lt;br/&gt;        &lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis会进行一些常规检查，配置数是否符合开启多线程I/O的要求。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; server.io_threads_num; i++) {&lt;br/&gt;        io_threads_list[i] = listCreate();&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个长度为线程数的&lt;code&gt;io_threads_list&lt;/code&gt;列表，列表的每个元素都是另一个列表L，L将会用来存放对应线程待处理的多个&lt;code&gt;client&lt;/code&gt;对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (i == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于主线程，初始化操作到这里就结束了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;        &lt;span&gt;pthread_t&lt;/span&gt; tid;&lt;br/&gt;        pthread_mutex_init(&amp;amp;io_threads_mutex[i],&lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;        io_threads_pending[i] = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        pthread_mutex_lock(&amp;amp;io_threads_mutex[i]); &lt;span&gt;/* Thread will be stopped. */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pthread_create(&amp;amp;tid,&lt;span&gt;NULL&lt;/span&gt;,IOThreadMain,(&lt;span&gt;void&lt;/span&gt;*)(&lt;span&gt;long&lt;/span&gt;)i) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            serverLog(LL_WARNING,&lt;span&gt;&quot;Fatal: Can&#x27;t initialize IO thread.&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        io_threads[i] = tid;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;io_threads_mutex&lt;/code&gt;是一个互斥锁列表，&lt;code&gt;io_threads_mutex[i]&lt;/code&gt;即第&lt;code&gt;i&lt;/code&gt;个线程的锁，用于后续阻塞I/O线程操作，初始化之后将其暂时锁定。然后再对每个线程执行创建操作，&lt;code&gt;tid&lt;/code&gt;即其指针，保存至&lt;code&gt;io_threads&lt;/code&gt;列表中。新的线程会一直执行&lt;code&gt;IOThreadMain&lt;/code&gt;方法，我们将它放到最后讲解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Reads/Writes&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多线程的读写主要在&lt;code&gt;handleClientsWithPendingReadsUsingThreads()&lt;/code&gt;和&lt;code&gt;handleClientsWithPendingWritesUsingThreads()&lt;/code&gt;中完成，因为两者几乎是对称的，所以这里只对读操作进行讲解，有兴趣的同学可以检查一下写操作有什么不同的地方以及为什么。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;handleClientsWithPendingReadsUsingThreads&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!server.io_threads_active || !server.io_threads_do_reads) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; processed = listLength(server.clients_pending_read);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (processed == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (tio_debug) &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%d TOTAL READ pending clients\n&quot;&lt;/span&gt;, processed);&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，Redis会进行常规检查，是否启用线程化读写并且启用线程化读（只开启前者则只有写操作是线程化），以及是否有等待读取的客户端。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;    listIter li;&lt;br/&gt;    listNode *ln;&lt;br/&gt;    listRewind(server.clients_pending_read,&amp;amp;li);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; item_id = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;        client *c = listNodeValue(ln);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; target_id = item_id % server.io_threads_num;&lt;br/&gt;        listAddNodeTail(io_threads_list[target_id],c);&lt;br/&gt;        item_id++;&lt;br/&gt;    }&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里将&lt;code&gt;server.clients_pending_read&lt;/code&gt;的列表转化为方便遍历的链表，然后将列表的每个节点（&lt;code&gt;*client&lt;/code&gt;对象）以类似Round-Robin的方式分配个各个线程，线程执行各个client的读写顺序并不需要保证，命令抵达的先后顺序已经由&lt;code&gt;server.clients_pending_read/write&lt;/code&gt;列表记录，后续也会按这个顺序执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;    io_threads_op = IO_THREADS_OP_READ;&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置状态标记，标识当前处于多线程读的状态。由于标记的存在，Redis的Threaded I/O瞬时只能处于读或写的状态，不能部分线程读，部分写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; server.io_threads_num; j++) {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = listLength(io_threads_list[j]);&lt;br/&gt;        io_threads_pending[j] = count;&lt;br/&gt;    }&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为每个线程记录下各自需要处理的客户端数量。当不同线程读取到自己的pending长度不为0时，就会开始进行处理。注意&lt;code&gt;j&lt;/code&gt;从1开始，意味着&lt;code&gt;0&lt;/code&gt;的主线程的pending长度一直为0，因为主线程马上要在这个方法中同步完成自己的任务，不需要知道等待的任务数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1flHOHZw6RtQhSq5yr610xncleFgIkMibmpOBrgM3iaib9oib1ITm9CBtO2uk3GHmDvmibd0sVNBu6GFP9Bicy03FiaaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;    listRewind(io_threads_list[&lt;span&gt;0&lt;/span&gt;],&amp;amp;li);&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;        client *c = listNodeValue(ln);&lt;br/&gt;        readQueryFromClient(c-&amp;gt;conn);&lt;br/&gt;    }&lt;br/&gt;    listEmpty(io_threads_list[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主线程此时将自己要处理的client处理完。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pending = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; server.io_threads_num; j++)&lt;br/&gt;            pending += io_threads_pending[j];&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pending == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (tio_debug) &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;I/O READ All threads finshed\n&quot;&lt;/span&gt;);&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;陷入循环等待，&lt;code&gt;pending&lt;/code&gt;等于各个线程剩余任务数之和，当所有线程都没有任务的时候，本轮I/O处理结束。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(listLength(server.clients_pending_read)) {&lt;br/&gt;        ln = listFirst(server.clients_pending_read);&lt;br/&gt;        client *c = listNodeValue(ln);&lt;br/&gt;        c-&amp;gt;flags &amp;amp;= ~CLIENT_PENDING_READ;&lt;br/&gt;        listDelNode(server.clients_pending_read,ln);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (c-&amp;gt;flags &amp;amp; CLIENT_PENDING_COMMAND) {&lt;br/&gt;            c-&amp;gt;flags &amp;amp;= ~CLIENT_PENDING_COMMAND;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (processCommandAndResetClient(c) == C_ERR) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        processInputBuffer(c);&lt;br/&gt;    }&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经在各自线程中将&lt;code&gt;conn&lt;/code&gt;中的内容读取至对应client的&lt;code&gt;client.querybuf&lt;/code&gt;输入缓冲区中，所以可以遍历&lt;code&gt;server.clients_pending_read&lt;/code&gt;列表，串行地进行命令执行操作，同时将&lt;code&gt;client&lt;/code&gt;从列表中移除。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;    server.stat_io_reads_processed += processed;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; processed;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;处理完成，将处理的数量加到统计属性上，然后返回。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;IOThreadMain&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面还有每个线程具体的工作内容没有解释，它们会一直陷在&lt;code&gt;IOThreadMain&lt;/code&gt;的循环中，等待执行读写的时机。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;IOThreadMain&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt; *myid)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; id = (&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)myid;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; thdname[&lt;span&gt;16&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;snprintf&lt;/span&gt;(thdname, &lt;span&gt;sizeof&lt;/span&gt;(thdname), &lt;span&gt;&quot;io_thd_%ld&quot;&lt;/span&gt;, id);&lt;br/&gt;    redis_set_thread_title(thdname);&lt;br/&gt;    redisSetCpuAffinity(server.server_cpulist);&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;照常执行一些初始化内容。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;1000000&lt;/span&gt;; j++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (io_threads_pending[id] != &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (io_threads_pending[id] == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            pthread_mutex_lock(&amp;amp;io_threads_mutex[id]);&lt;br/&gt;            pthread_mutex_unlock(&amp;amp;io_threads_mutex[id]);&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;        serverAssert(io_threads_pending[id] != &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (tio_debug) &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;[%ld] %d to handle\n&quot;&lt;/span&gt;, id, (&lt;span&gt;int&lt;/span&gt;)listLength(io_threads_list[id]));&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程会检测自己的待处理的client列表长度，当等待队列长度大于0时往下执行，否则会到死循环起点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里利用互斥锁，让主线程有机会加锁，使得I/O线程卡在执行&lt;code&gt;pthread_mutex_lock()&lt;/code&gt;，达到让I/O线程停止工作的效果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;        listIter li;&lt;br/&gt;        listNode *ln;&lt;br/&gt;        listRewind(io_threads_list[id],&amp;amp;li);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;            client *c = listNodeValue(ln);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (io_threads_op == IO_THREADS_OP_WRITE) {&lt;br/&gt;                writeToClient(c,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (io_threads_op == IO_THREADS_OP_READ) {&lt;br/&gt;                readQueryFromClient(c-&amp;gt;conn);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                serverPanic(&lt;span&gt;&quot;io_threads_op value is unknown&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将&lt;code&gt;io_threads_list[i]&lt;/code&gt;的客户端列表转化为方便遍历的链表，逐个遍历，借助&lt;code&gt;io_threads_op&lt;/code&gt;标志判断当前是要执行多线程读还是多线程写，完成对自己要处理的客户端的操作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;        listEmpty(io_threads_list[id]);&lt;br/&gt;        io_threads_pending[id] = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (tio_debug) &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;[%ld] Done\n&quot;&lt;/span&gt;, id);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;清空自己要处理的客户端列表，并且将自己的待处理数量修改为0，结束本轮操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Limitation&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过查看代码，使用上Threaded I/O的启用受以下条件影响：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;配置项&lt;code&gt;io-threads&lt;/code&gt;需要大于1，否则会继续使用单线程操作读写I/O&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置项&lt;code&gt;io-threads-do-reads&lt;/code&gt;控制读I/O是否使用线程化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于延迟读取，由&lt;code&gt;postponeClientRead()&lt;/code&gt;方法控制。方法中除了配置要求外，还需要当前client不能是主从模型的角色，也不能处于已经等待下次事件循环线程化读取（&lt;code&gt;CLIENT_PENDING_READ&lt;/code&gt;）的状态。在这个方法中&lt;code&gt;client&lt;/code&gt;对象会被添加到等待队列中，并且将client的状态改为&lt;code&gt;CLIENT_PENDING_READ&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于多线程写I/O，由&lt;code&gt;handleClientsWithPendingWritesUsingThreads()&lt;/code&gt;中的&lt;code&gt;stopThreadedIOIfNeeded()&lt;/code&gt;方法加以限制。除了对应配置项要满足要求外，&lt;code&gt;server.clients_pending_write&lt;/code&gt;的长度需要大于等于配置线程数的两倍，例如配置使用6线程，当写队列长度小于12时会继续使用单线程I/O。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;I/O线程在&lt;code&gt;initThreadedIO()&lt;/code&gt;被创建前，互斥锁处于加锁状态，因此线程不能进行实际的任务处理。&lt;code&gt;server&lt;/code&gt;对象的&lt;code&gt;io_threads_active&lt;/code&gt;属性默认会处于关闭状态，在进行首次多线程写之前才会被开启。这意味着服务启动后的读操作仍然会使用单线程读，产生执行结果到写的pending list中，在第二次循环中，服务判断是否有配置启用TIO，将&lt;code&gt;server.io_threads_active&lt;/code&gt;属性打开，然后进行多线程写操作，从下一次循环开始TIO才能被作用于读操作上。上一点说过写I/O会有配置和队列长度判定，在判定不需要TIO写时，会重新把&lt;code&gt;server.io_threads_active&lt;/code&gt;关闭，意味着尽管你已经在配置文件里面打开TIO读，但是Redis仍然会根据负载时不时跳过使用它。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;性能测试&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们编译了unstable版本的Redis进行性能测试，测试工具为Redis自带的redis-benchmark，统计输出的RPS值作为参考。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Server实例: AWS / m5.2xlarge / 8 vCPU / 32 GB&lt;br/&gt;Benchmark Client实例: AWS / m5.2xlarge / 8 vCPU / 32 GB&lt;br/&gt;Command: redis-benchmark -h 172.xx.xx.62 -p 6379 -c 100 -d 256 -t get,&lt;span&gt;set&lt;/span&gt; -n 10000000 --threads 8&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Threaded I/O off vs. Threaded I/O on&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们对比了原有的单线程I/O以及开启2线程/4线程的Threaded I/O时的表现，结果如图所示。&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1flHOHZw6RtQhSq5yr610xncleFgIkMibXcfbsoOBQTVrnyfFrPnhkoKZHooELsjgb2ZibtUE2uFJKhR1EhAQfBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;在开启&lt;code&gt;io-threads-do-reads&lt;/code&gt;选项的情况下，Threaded I/O作用于读操作，也能让性能有进一步提升，但是没有将写I/O线程化提升明显。另外我们还尝试使用了大体积Payload（&lt;code&gt;-d 8192&lt;/code&gt;）进行测试，得出结果的提升百分比并没有太大差异。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Threaded I/O vs. Redis Cluster&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以往开发者会通过在单台实例上部署Redis Cluster来尝试让Redis使用上更多的CPU资源，我们也尝试对比了一下这种情景下的表现。&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1flHOHZw6RtQhSq5yr610xncleFgIkMibdROe77VAGl5MMtyz6caYhyYn28A7lka9wRdQGziaib983MtY1dCibOhMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;在新版本中，redis-benchmark也得到了更新，开始支持对Redis Cluster的测试，通过开启&lt;code&gt;--cluster&lt;/code&gt;参数即可检测集群模式和配置。我们在这一组对比测试中看到单实例构建集群的强大性能，在实际测试中，3个进程的CPU使用率均在80%-90%，说明仍有提升的空间。当改用测试参数&lt;code&gt;-c 512&lt;/code&gt;时，集群能够跑出超过40万RPS的成绩。尽管测试与实际使用会有所区别，并且我们在构建集群的时候选择了不附带Slave，但是仍然能看出来在几种模型中，构建Cluster能真正使用上多线程进行网络I/O、命令执行，对性能的提升也是最大的。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结与思考&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 6.0引入的Threaded I/O，将Socket读写延迟和线程化，在网络I/O的方向上给Redis带来了一定的性能提升，并且使用门槛比较低，用户无需做太多的变更，即可在不影响业务的情况下白嫖空闲的线程资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一方面，从测试结果上看，这部分的提升可能还难以让处于Redis 5甚至Redis 3版本的用户有足够的动力进行升级，特别是考虑到很多业务场景中Redis的性能并没有差到成为瓶颈，而且新版本的福利也未经过大规模验证，势必会影响到企业级应用中更多用户关注的服务稳定性。同时，TIO的提升对比集群性能似乎还有一定的差距，这可能更加会让原本就处于集群架构的企业用户忽略这个功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但无论如何，用户肯定乐于见到更多的新功能、更多优化提升出现在Redis上。在保持一贯稳定性的前提下，本次的版本可以说是Redis从诞生至今最大的更新，不只有Threaded I/O，包括RESP3、ACLs和SSL，我们期待这些新Feature能够在更多的应用场景下得到推广、验证和使用，也希望未来的版本能够给用户带来更多的惊喜和更好的体验。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Further Reading: Understanding Redis&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一位从来没有使用过C/类C语言的开发者，Redis简洁的代码和详尽的注释为我阅读和理解其实现提供了极大的帮助。在文末我想要分享一下自己学习Reids的一些途径、工具和方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;README.md&lt;/code&gt;应该是我们了解Redis的入口，而不是全局搜索&lt;code&gt;main()&lt;/code&gt;方法。请关注&lt;code&gt;Redis internals&lt;/code&gt;小节下的内容，这里介绍了Redis的代码结构，Redis每个文件都是一个“general idea”，其中&lt;code&gt;server.c&lt;/code&gt;和&lt;code&gt;network.c&lt;/code&gt;的部分逻辑和代码在本文已经介绍过了，持久化相关的&lt;code&gt;aof.c&lt;/code&gt;和&lt;code&gt;rdb.c&lt;/code&gt;、数据库相关的&lt;code&gt;db.c&lt;/code&gt;、Redis对象相关的&lt;code&gt;object.c&lt;/code&gt;、复制相关的&lt;code&gt;replication.c&lt;/code&gt;等都值得留意。其他包括Redis的命令是以什么样的形式编码的，也能在&lt;code&gt;README.md&lt;/code&gt;中找到答案，这样可以方便我们进一步阅读代码时快速定位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Documentation主页&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;和&lt;span&gt;redis-doc repo&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;是Redis文档的集合处，请注意后者的&lt;code&gt;topics&lt;/code&gt;目录下有非常多有趣的主题，我对“有趣”的定义是像这样的文章：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Redis Cluster Specification&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Redis server-assisted client side caching&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为开发者，在深入学习的阶段，这些内容能让大家从“使用”变为“了解”，然后发现Redis原来能做更多的事情。所以如果缺乏时间阅读和调试源码，将&lt;code&gt;topics&lt;/code&gt;下的60多篇文档看一遍，大概是了解Redis最快的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，如果你能看到这里，兴许也会对Redis的源码有那么一点兴趣。因为本身并不了解C语言，所以我可能会选择借助一个IDE，在&lt;code&gt;main()&lt;/code&gt;打上断点，然后流程的起点开始看，实际上我也确实是这么做的。另外几个代码的关键点，其实也在本文中出现过：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main()&lt;/code&gt;，起点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;initServer()&lt;/code&gt;，初始化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;aeMain()&lt;/code&gt;，事件循环&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;readQueryFromClient()&lt;/code&gt;，读事件的Handler&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;processInputBuffer()&lt;/code&gt;，命令处理的入口&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果像本文一样想了解Network的内容，可以在&lt;code&gt;aeMain()&lt;/code&gt;处打断点，然后关注中&lt;code&gt;network.c&lt;/code&gt;中的方法；如果想关注具体命令相关的内容，可以在&lt;code&gt;processInputBuffer()&lt;/code&gt;处打断点，然后关注&lt;code&gt;$command.c&lt;/code&gt;或者类似文件中的方法，&lt;code&gt;README.md&lt;/code&gt;文件里也已经介绍过命令方法的命名格式，定位非常容易。其余经常出现的其他动作，例如持久化、复制等，大概会出现在命令执行的前后，或者时间事件内，也可能在&lt;code&gt;beforeSleep()&lt;/code&gt;中。&lt;code&gt;server.h&lt;/code&gt;中定义的&lt;code&gt;redisServer&lt;/code&gt;和&lt;code&gt;client&lt;/code&gt;是Redis中两个非常重要的结构，在业务上很多内容都是转化为对它们的属性的相关操作，要特别留意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此以外，Antirez曾经在&lt;span&gt;Youtube&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;上发布过一些开发的录播视频，&lt;span&gt;RedisLab&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;则有一些相对冷门使用场景的实践介绍，这些会比上面的其他学习来得更轻松些，最大的难处可能就是听懂演讲者们的口音，特别是Antirez本人，万幸Youtube的字幕功能非常强大，能解决不少麻烦。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Documentation主页: &lt;em&gt;https://redis.io/documentation&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;redis-doc repo: &lt;em&gt;https://github.com/redis/redis-doc&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Redis Cluster Specification: &lt;em&gt;https://github.com/redis/redis-doc/blob/master/topics/cluster-spec.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;Redis server-assisted client side caching: &lt;em&gt;https://github.com/redis/redis-doc/blob/master/topics/cluster-spec.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Youtube: &lt;em&gt;https://www.youtube.com/user/antirez&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;RedisLab: &lt;em&gt;https://www.youtube.com/c/Redislabs/videos&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>