<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1e22e4414b07b7f0d29b33c0799106a1</guid>
<title>2022 年别再焦虑啦！加入我们！</title>
<link>https://toutiao.io/k/obimloc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e2942b7d42e782caaadd68dae1a38228</guid>
<title>Go 原生并发原语和最佳实践</title>
<link>https://toutiao.io/k/rdpao5x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 编程语言是用并发作为一等公民创建的。它是一种语言，通过抽象出语言中并发原语1背后的并行性细节，您可以轻松编写高度并行的程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大多数语言都将并行化作为标准库的一部分，或者期望开发者生态系统提供并行化库。通过在 Go 语言中包含并发原语，你可以编写并行性的程序，而无需了解编写并行代码的来龙去脉。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、并发（Concurrent）设计&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 的设计者非常重视并发设计，将其作为一种方法论，这种方法论的基础是交流关键信息，而不是阻塞和共享这些信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对并发设计的强调允许应用程序代码正确地按顺序或并行执行，而无需设计和实现并行化，这是常态。并发设计的想法并不新鲜，事实上一个很好的例子是从瀑布式开发到敏捷开发，这实际上是向并发工程实践（早期迭代、可重复过程）的转变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发设计是关于编写“正确”程序与编写“并行”程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 中构建并发程序时要问的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我是否堵塞在临界区？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;是否有更正确（如以 Go 为中心）的方式来编写此代码？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我可以通过通信来提高代码的功能性和可读性吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果其中任何一个是 Yes，那么你应该重新考虑你的设计，考虑用 Go 的最佳实践。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Communicating Sequential Processes (CSP)&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言的一部分的基础来自 Hoare 的一篇论文，该论文讨论了语言需要将并发视为语言的一部分而不是事后的想法。该论文提出了一种线程安全队列，它允许应用程序中不同进程之间的数据通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你通读这篇论文，你会发现Go 中的  &lt;code&gt;channel&lt;/code&gt; 原语与论文中对原语的描述非常相似，实际上这来自 Rob Pike 之前基于 CSP 构建语言的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Pike 的一次演讲中，他将真正的问题确定为“需要一种方法来编写并发软件，以指导我们的设计和实现。”他接着说并发编程不是让程序并行化以更快地运行，而是“利用流程和通信的力量来设计优雅、响应迅速、可靠的系统。”&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;通过通信实现并发&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从 Go 的创建者那里听到的最常见的短语之一是：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Don’t communicate by sharing memory, share memory by communicating. - Rob Pike&lt;/p&gt;&lt;p&gt;即：不要通过共享内存来通信，而是通过通信来共享内存。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种观点反映了 Go 是基于 CSP 的事实，并且该语言具有用于在线程之间通信的本机原语（goroutine）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的代码是使用通信而不是使用 mutex 来管理对共享资源的访问的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Adapted from https://github.com/devnw/ttl&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// a TTL cache implementation for Go.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;readwriteloop&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;  incoming &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{},&lt;br/&gt;)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt;   &lt;span&gt;// Create a channel to send data to.&lt;/span&gt;&lt;br/&gt;  outgoing = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{})&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;    incoming &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{},&lt;br/&gt;    outgoing &lt;span&gt;chan&lt;/span&gt;&amp;lt;- &lt;span&gt;interface&lt;/span&gt;{},&lt;br/&gt;    )&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(outgoing)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// `value` is the shared &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// resource or critical section.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; value &lt;span&gt;interface&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// incoming is the channel where data is&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// sent to set the shared resource.&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; v, ok := &amp;lt;-incoming:&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;// Exit the go routine.&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Write the data to the shared resource.&lt;/span&gt;&lt;br/&gt;        value = v.v&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// outgoing is the channel that &lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// the shared resource on request&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; outgoing &amp;lt;- value:&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }(incoming, outgoing)&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; outgoing&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们看一下代码，看看它做了什么。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;请注意，这没有使用 &lt;code&gt;sync&lt;/code&gt; 包或任何阻塞函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此代码仅使用 Go 并发原语 &lt;code&gt;go&lt;/code&gt;,&lt;code&gt;select&lt;/code&gt;和&lt;code&gt;chan&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;共享资源的所有权由 goroutine 管理。（第 17 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;即使该方法包含一个 goroutine，对共享资源的访问也不会并行发生。（第 30 和 34 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该 &lt;code&gt;select&lt;/code&gt; 语句用于检查读取或写入请求。（第 24 和 34 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 incoming 会更新该值。（第 24 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 goroutine 外部读取的通道使用共享资源的当前值执行对 outgoing 写入。（第 34 行）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于单个 goroutine 本身没有并行性，因此可以通过返回的只读通道安全地访问共享资源 。事实上，&lt;code&gt;select&lt;/code&gt; 这里使用该语句提供了许多好处。选择原语部分对此进行了更详细的介绍。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;堵塞 vs 通信&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堵塞：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;暂停临界区读/写的进程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要了解阻塞的&lt;strong&gt;必要性&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要了解如何避免竞争和死锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存元素由多个进程/线程直接共享&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通信：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据要求共享临界区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当有事情要做时，进程开始工作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存元素是通过通信共享，而不是直接共享的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、Go 原生并发原语&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Goroutine&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是 Goroutine？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;goroutine 是轻量级的线程。一旦 goroutine 从父 goroutine 中分离出来，它就会被移交给 Go 运行时执行。然而，与&amp;amp;in不同的是，bash这些进程被安排在 Go 运行时中执行，而不必并行执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2294455066921606&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowRmDVNKzB72JQwjiaFbUqiaz6lwnibYdtV5HkMD8hIKGgIaVR6NeIpWYGZAheTjDXlLVgWCGgOat49VA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;Goroutine 拆分示例&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里“调度”的区别很重要，因为 Go 运行时多路复用 goroutine 的执行，以提高操作系统调度之上的性能。这意味着无法对 goroutine 何时执行做出任何假设。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Goroutine 的泄露&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由 &lt;code&gt;go&lt;/code&gt; 原语创建的 goroutine 很轻量，但重要的是要知道它们&lt;strong&gt;不是&lt;/strong&gt;免费的。清理 goroutine 对于确保在 Go 运行时中正确收集资源非常重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应该花时间在设计上考虑清理。确保长时间运行的 goroutine 在发生故障时正确退出。同样重要的是不要创建无数的 goroutine。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成一个 goroutine 很简单，因此很容易无节制的生成新的 goroutine，生成的每个 goroutine 的最小开销约为 2kb。如果你的代码创建了太多 goroutine，并且每个 goroutine 都有很大的开销，那么栈空间可能不够。这在生产环境中调试起来非常困难，因为很难判断堆栈在哪里溢出以及堆栈在哪里泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当发生堆栈溢出时，运行时将 panic，程序将退出，每个 goroutine 都会将堆栈信息打印到标准错误。这会在日志中产生大量噪音并且不是很有用。不仅堆栈信息没有用，而且还会输出大量数据（每个 goroutine 的日志，包括它的标识符和状态）。这也很难调试，因为通常操作系统上的日志缓冲区可能太小而无法容纳所有堆栈信息。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：公平地说，我只在应用程序使用&lt;strong&gt;超过 400,000 个&lt;/strong&gt;大型 goroutine 的生产环境中看到这种情况。这可能很少见，对于大多数应用程序来说都不是问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TL;DR：设计 goroutines 时要考虑到最终结果，以便它们在完成时正确停止。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Goroutine 中的 panic&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，Go 应用程序中的 panic 是违反最佳实践的，应该避免。代替 panic，你应该返回并处理函数中的错误。但是，如果有必要使用  &lt;code&gt;panic&lt;/code&gt;，必须知道，在 goroutine 如果没有 defer 的 recover，panic 会导致整个应用程序崩溃。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;最佳实践：&lt;/strong&gt;不要 Panic！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这在生产环境中非常难以调试，因为它需要&lt;code&gt;stderr&lt;/code&gt;重定向到文件，因为你的应用程序很可能作为守护进程运行。如果你有一个日志聚合器并且它被设置为监控标准错误或文件日志，这会更容易。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果不确定，可以在 goroutine 增加 defer/recover&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; r := &lt;span&gt;recover&lt;/span&gt;(); r != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// Handle Panic HERE&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Channels&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go 中的 Channel 是什么？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源自 Hoare (1977) 的 Communicating Sequential Processes 论文通道是 Go 中的一种通信机制，它支持以线程安全的方式传输数据。它可用于安全有效地在并行 goroutine 之间进行通信，而无需 mutex。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道将构建并行代码的困难抽象到 Go 运行时，并提供了一种在 goroutine 之间进行通信的简单方法。从本质上讲，通道的最简单形式是数据队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 Rob Pike 的话来说：“Channels orchestrate; mutexes serialize.”&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通道在 Go 中是如何工作的？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，通道是阻塞的。这意味着，如果你尝试从通道读取，它将阻止该 goroutine 的处理，直到有要读取的内容（即数据发送到通道）。同样，如果你尝试写入通道并且没有数据消费者（即从通道读取），它将阻止该 goroutine 的处理，直到有消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 中，围绕通道有一些非常重要的行为。Go 运行时被设计为非常高效，因此如果有一个 goroutine 在读取或写入通道上被阻塞，则运行时将在等待执行某些操作时使 goroutine 休眠。一旦通道有生产者或消费者，它将唤醒阻塞的 goroutine 并继续处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解这一点非常重要，因为它允许你通过使用通道显式地利用系统的 CPU 争用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 一个 nil 通道总是堵塞&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关闭 Channel&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 完成后，最好关闭它。这通过 &lt;code&gt;close&lt;/code&gt; 实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时可能无法关闭通道，因为它会在应用程序的其他地方引起 panic（即往关闭的通道写入）。在这种情况下，当通道超出作用范围时，它将被垃圾收集。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Create the channel&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Do something with the channel&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Close the channel&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;close&lt;/span&gt;(ch)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果通道被限制在同一个作用域（即函数），你可以使用 &lt;code&gt;defer&lt;/code&gt;关键字来保证函数返回时通道是关闭的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Create the channel&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(ch) &lt;span&gt;// Close the channel when func returns&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Do something with the channel&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个通道关闭时，不允许再写入。注意关闭通道的方式非常重要，因为如果你尝试写入已关闭的通道，运行时将 panic。因此，过早关闭通道可能会产生意想不到的副作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道关闭后，它将不再阻塞读取。这意味着所有阻塞在通道上的 goroutine 都将被唤醒并继续处理。读取时返回的零值将是通道类型的值，读取返回的第二个值将是 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Create the channel&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Do something with the channel&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Close the channel&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;close&lt;/span&gt;(ch)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Read from closed channel&lt;/span&gt;&lt;br/&gt;  data, ok := &amp;lt;-ch&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;    &lt;span&gt;// Channel is closed&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在上面的示例中关闭了通道，则 &lt;code&gt;ok&lt;/code&gt;参数将是 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;  只读 channel 不能关闭&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Channels 类型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 中有几种不同类型的通道。它们每个都有各自的优点和缺点。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;无缓冲 Channels&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Unbuffered channels are the simplest type of channel.&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要创建无缓冲通道，请调用 make 函数，并提供通道类型。不要在第二个参数中提供大小值，如上例所示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无缓冲通道默认是阻塞的，并且会阻塞 goroutine 直到有东西要读取或写入。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓冲 Channels&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Buffered channels are the other primary type of channel.&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要创建缓冲通道，调用 make 函数，提供通道类型和缓冲区大小。上面的示例将创建一个缓冲区大小为 10 的通道。如果你尝试写入已满的通道，它将阻塞 goroutine，直到缓冲区中有空间。如果你试图从一个空的通道中读取，它将阻塞 goroutine，直到有东西要读取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果你想写入通道并且缓冲区有可用空间，则它不会阻塞 goroutine。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 通常，仅在真的需要时才使用缓冲通道。最佳实践是使用无缓冲通道。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;只读和只写 Channels&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道的一个有趣用例是拥有一个仅用于读取或写入的通道。当你有一个需要从通道读取但你不希望该 goroutine 写入时，这很有用，反之亦然。这对于下面描述的所有者模式特别有用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是创建只读或只写通道的语法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Define the variable with var&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; writeOnly &lt;span&gt;chan&lt;/span&gt;&amp;lt;- &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; readOnly &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  mychan := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Assign the channel to the variable&lt;/span&gt;&lt;br/&gt;  readOnly = mychan&lt;br/&gt;  writeOnly = mychan&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;箭头指示通道的方向。&lt;code&gt;chan&lt;/code&gt;前面的箭头表示数据流进入通道，而 &lt;code&gt;chan&lt;/code&gt; 后面的箭头表示数据流流出通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只读通道的一个示例是&lt;code&gt;time.Tick&lt;/code&gt; 函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Tick is a convenience wrapper for NewTicker providing access to the ticking&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// channel only&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Tick&lt;/span&gt;&lt;span&gt;(d Duration)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;Time&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此方法返回一个只读通道，&lt;code&gt;time&lt;/code&gt;包以指定的时间间隔在内部写入该通道。这种模式确保了时钟滴答的实现逻辑与&lt;code&gt;time&lt;/code&gt;包隔离，因为用户不需要往通道写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你需要写入通道但你知道 goroutine 不需要从中读取时，只写通道非常有用。下面描述的所有者模式就是一个很好的例子 。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Channels 的设计注意事项&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计注意事项包括：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;哪个作用域拥有 channel？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非所有者有什么能力？&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;完全所有权&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只读&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只写&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;channel 将如何清理？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;哪个 goroutine 负责清理 channel？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;所有者模式&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Owner Pattern 是 Go 中的一种常见设计模式，用于确保通道的所有权由创建或拥有 goroutine 正确管理。这允许 goroutine 管理通道的整个生命周期并确保正确关闭通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是 Go 中所有者模式的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewTime&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Time&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  tchan := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; time.Time)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(tchan &lt;span&gt;chan&lt;/span&gt;&amp;lt;- time.Time)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(tchan)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; tchan &amp;lt;- time.Now():&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }(tchan)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; tchan&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好处:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;NewTime 控制通道实例化和清理（第 2 行和第 5 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过定义只读/只写边界避免乱用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;限制行为不一致的可能性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于此示例的重要说明。上下文 &lt;code&gt;ctx&lt;/code&gt; 传递给函数 &lt;code&gt;NewTime&lt;/code&gt;并用于指示 goroutine 停止。&lt;code&gt;tchan&lt;/code&gt; 通道是普通的无缓冲通道，但以只读方式返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当传递给内部 goroutine 时，&lt;code&gt;tchan&lt;/code&gt;通道作为只写通道传递。因为内部 goroutine 提供了一个只写通道，所以它有责任在完成时关闭通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;select&lt;/code&gt; 语句，&lt;code&gt;time.Now()&lt;/code&gt; 调用仅在从通道读取时执行。这确保&lt;code&gt;time.Now()&lt;/code&gt; 调用的执行与从通道读取同步。这种类型的模式有助于抢先减少 CPU 周期。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;循环 Channels&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从通道读取的一种方法是使用&lt;code&gt;for&lt;/code&gt;循环。这在某些情况下可能很有用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;var&lt;/span&gt; tchan &amp;lt;-&lt;span&gt;chan&lt;/span&gt; time.Time&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; t := &lt;span&gt;range&lt;/span&gt; tchan {&lt;br/&gt;    fmt.Println(t)&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我不推荐这种方法有几个原因。首先，不能保证通道会关闭（打破循环）。其次，循环不遵守上下文，这意味着如果取消上下文，循环将永远不会退出。&lt;strong&gt;第二点特别重要，因为没有优雅的方式来退出 goroutine。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我建议不要在通道上循环，而是使用以下模式，在该模式中使用带有&lt;code&gt;select&lt;/code&gt;语句的无限循环。这种模式确保检查上下文，如果它被取消，循环退出，同时还允许循环仍然从通道中读取。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;var&lt;/span&gt; tchan &amp;lt;-&lt;span&gt;chan&lt;/span&gt; time.Time&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done(): &lt;span&gt;// Graceful exit&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; t, ok := &amp;lt;-tchan: &lt;span&gt;// Read from the time ticker&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; !ok { &lt;span&gt;// Channel closed, exit&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;      fmt.Println(t)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下文会详细讨论这个。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;转发 Channels&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在适当的情况下，将通道从一个转发到另一个也是一种有用的模式。这是使用&lt;code&gt;&amp;lt;- &amp;lt;-&lt;/code&gt;运算符完成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是将一个通道转发到另一个通道的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;forward&lt;/span&gt;&lt;span&gt;(ctx context.Context, from &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  to := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; to &amp;lt;- &amp;lt;-from: &lt;span&gt;// Forward from into the to channel&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }()&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; to&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 使用此模式，你无法检测&lt;code&gt;from&lt;/code&gt;通道何时关闭。这意味着&lt;code&gt;from&lt;/code&gt;通道将不断地向 &lt;code&gt;to&lt;/code&gt; 通道发送数据，并且内部 goroutine 将永远不会退出，从而导致大量零值数据和 goroutine 泄漏。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据你的使用场景，这可能是可取的，但是，重要的是要注意，当你需要检测关闭的通道时，这种模式不是一个好方式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Select 语句&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select&lt;/code&gt; 语句允许在 Go 应用程序中管理多个通道，并可用于触发操作、管理数据或以其他方式创建逻辑并发流。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; data, ok := &amp;lt;- incoming: &lt;span&gt;// Data Read&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; outgoing &amp;lt;- data: &lt;span&gt;// Data Write&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;default&lt;/span&gt;: &lt;span&gt;// Non-blocking default action&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// ... &lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：&lt;code&gt;select&lt;/code&gt; 本质上是&lt;em&gt;随机&lt;/em&gt;的。这意味着如果有多个通道准备好同时读取或写入，该&lt;code&gt;select&lt;/code&gt;语句将随机选择一个 case 语句来执行。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试 Select 语句&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;select 语句的随机性会使测试 select 语句有点棘手，尤其是在测试以确保上下文取消正确退出例程时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个如何使用统计测试来测试 select 语句的示例，其中测试执行的次数确保测试失败的统计可能性很低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此测试通过在并行例程中运行相同的已取消上下文 100 次来工作，其中两个上下文中只有一个已被取消。在这种情况下，总会有一个通道的消费者，因此每次循环运行时，都有 50% 的可能性会执行 context case。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过运行 100 次，有 50% 的机会选择触发上下文情况，测试将无法检测到所有 100 个测试的上下文取消的可能性非常非常低。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;带上下文的 Work 取消&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在构建 Go 应用程序的早期，用户构建具有&lt;code&gt;done&lt;/code&gt;通道的应用程序，他们将在其中创建一个看起来像这样的通道：&lt;code&gt;done := make(chan struct{})&lt;/code&gt;，这是一种非常简单的方法，可以向 goroutine 发出它应该退出的信号，因为你所要做的就是关闭通道并将其用作退出信号。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Example of a simple done channel&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  done := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt;&lt;br/&gt;    &lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; doWork(done)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Exit anything using the done channel&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(done)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Do some more work&lt;/span&gt;&lt;br/&gt;  }()&lt;br/&gt;&lt;br/&gt;  &amp;lt;-done&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doWork&lt;/span&gt;&lt;span&gt;(done &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-done:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;: &lt;br/&gt;      &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式变得如此普遍，以至于 Go 团队创建了context 包 作为替代。该包提供了一个接口&lt;code&gt;context.Context&lt;/code&gt;，可用于向 goroutine 发出信号，告知它在&lt;code&gt;Done&lt;/code&gt; 方法返回的只读通道返回时退出 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doWork&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;default&lt;/span&gt;: &lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，他们还提供了一些用于创建分层上下文、超时上下文和可以取消的上下文的方法。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;context.WithCancel&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;返回 &lt;code&gt;context.Context&lt;/code&gt;以及&lt;code&gt;context.CancelFunc&lt;/code&gt;，可用于取消上下文的函数字面值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;context.WithTimeout&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;与&lt;code&gt;WithCancel&lt;/code&gt;返回一致，但具有超时，将在指定&lt;code&gt;time.Duration&lt;/code&gt;时间过去后取消上下文。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;context.WithDeadline&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;与 WithCancel 返回一致，但有一个截止日期，将在指定的时间过去后取消上下文。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;：接受上下文的函数的第一个参数应该 &lt;strong&gt;始终&lt;/strong&gt; 是 context，并且应该命名为 &lt;code&gt;ctx&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://benjiv.com/go-native-concurrency-primitives/。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d86ba15fe055b12ff6a79ad76e1b8879</guid>
<title>赵学敏：京东商品图谱构建与实体对齐</title>
<link>https://toutiao.io/k/nrwlirv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-backh=&quot;156&quot; data-backw=&quot;561&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;561&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;187&quot; data-fileid=&quot;100072688&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiatBXkeQWuUGBmUQ4xiahXXVm7Ohkcwd798zgEzw4l4EBMjUqNd5HtdBibHyicSCVfIIpG0ZkFwdSsFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;256&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4421864050455501&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaVOpUgibtUfuPKEm8HfWk4Yjk7FC0PJ9tUeG6hhM56NcLg3SMnXKXessgGBw7MiaJK9JL2yv44tzrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1427&quot;/&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: -10px; margin-left: -8px; max-width: 100%; width: 18px; height: 18px; border-top: 8px solid rgb(54, 65, 173); border-left: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-style=&quot;max-width: 100%; width: 543.333px; background: rgb(247, 247, 247); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;分享嘉宾：赵学敏&lt;/span&gt;&lt;span&gt;博士&lt;/span&gt;&lt;span&gt; 京东科技&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;编辑整理&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;蔡丽萍 &lt;/span&gt;&lt;span&gt;TRS&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;出品平台：DataFunTalk&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; width: 18px; height: 18px; border-bottom: 8px solid rgb(54, 65, 173); border-right: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;在电商企业采购和运营过程中，如果要想掌握商品的实时价格等行情信息，就需要对齐各个电商网站的商品。由于各个电商网站的运营体系不同，网站的类目体系、商品属性等等往往存在很大差异，需要将这些实体信息进行统一的对齐和匹配。此外，还需要考虑在数以亿级的商品体量下，商品信息有各种错误的情况下如何提升算法效果。本文将介绍商品图谱构建与表示、实体对齐等技术在电商领域的一些具体实践和应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要内容包括：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;背景介绍&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkt4MqTg4elflfU3VaMmVaZ8vOTAGUxdF5DTvEctYODANaHviaVZbiaTDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们团队的主要研究方向包括语音识别、自然语言处理、人机对话、知识图谱，负责将这些AI相关的研究落地于京东科技内外部的各种产品中，提高京东科技的机构品牌影响力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkAic6ukLW7M7pRdTmc1UT8GJFibq6tJTCbaVeU76OBPMbr0LDaibyYBRaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在知识图谱方向上，我们围绕金融图谱、商品图谱、药品图谱都有一些具体工作以及落地的应用。我们依托平台内部的一些能力，像大规模图谱处理库、机器学习平台等，为上层的各种应用提供知识图谱底座以及相关算法能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpk8jBNPxhVDpYqoicfibmVXqFovcWjxFpJFiboibYtKScEACqdLOHVqhuE4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天分享的内容是商品图谱当中的一个具体应用。商品图谱是以京东海量的商品为中心，全面沉淀相关的商品知识。构建图谱时区分概念层和实例层：概念层主要是沉淀一些抽象概念，比如品类与属性之间的关系；具体的实例，如属性值或者是商品SKU都会放在实例层。此外，我们还在持续推进商品图谱和通用百科图谱打通的工作，进而更好地为上层的应用提供相关的知识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpk6ytuVx9gdiazUxMHY3Kc0YUU8NooPdVnI5pVc31H1yhxtoWj5Kkahbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在商品图谱中，实体对齐包含商品对齐、属性对齐、属性值对齐，我们的应用中最关心的是商品之间的对齐，尤其是跨电商平台商品之间的对齐。有了这些商品对齐的结果，采销团队可以对京东商品的价格竞争力等等有一个全面的了解。跨电商渠道的商品对齐面临的最大问题是，因为各个电商渠道的运营体系完全不一样，会导致同一商品的具体描述有较大差异。同时，因为执行的运营标准也不一致，像京东自营商品的属性信息要更全一些，但是很多第三方商家的商品属性就有很多缺失，会把关键的信息直接放到标题中。此外，因为电商平台的商品都是海量数据，大数据下也会对算法的选型产生影响。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;技术进展&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 实体对齐任务介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkqwGHkZPTJIiacMcloXjzniaJ15vkWCxgjJc912d0j5WkVll3KdicOWOzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们这里的实体对齐任务是知识图谱中的实体对齐。在很多论文中具体把任务定义为：两个不同的图谱KG1、KG2，当中的实体有一定的对应关系，在已知一些对齐样本的情况下，去预测图谱中其它实体的对齐关系。图谱一般以（E，R，T）表示。E为实体，R为关系，T为图谱中的三元组。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkfDC8MkzEkFLficlV0Siaa2VfJk8iauyB5W0eiac1DfdiaJCRahaxsYrCDEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相关论文中常见的数据集有两个，都是百科图谱对齐的数据集。其中DBP15K是一个跨语言的百科图谱对齐数据集，DWY100K是三个不同来源的百科网站图谱对齐的数据集。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkylweekT7bAhKicCOv2nURmB0bZpibiay5V1dtXCnCc2Hw0meowfapyKbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多图谱对齐算法都以图谱表示学习为基础来实现，先对知识图谱当中的所有实体进行编码，从而提取实体的图谱特征。之前的研究一般采用分布式图表示学习，像TransE及其各种改进算法。目前更多的论文使用了图神经网络GNN。计算得到实体的图谱特征后，会将特征传入对齐模块。对齐模块常用的做法有两种，一种是拉近已知对齐实体特征向量在高维空间中的距离；另一种是使用一些复杂匹配模型，去学习预测实体间的对齐关系。目前主要工作都围绕着图谱编码和对齐模型两个部分展开。具体到评价指标，会把实体对齐看成是一个排序任务，使用搜索排序的相关指标进行评价，如TopK命中率，即统计前K个得分最高的预测结果中，是否包含有正确的对齐实体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 实体对齐算法技术趋势&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpk9XYHyp3eX70DITKahGef09JxHyHNibzxuickOicfkTKxnH1uHMsV2Nt0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近几年图谱对齐的论文有很多，这里可能只列举到一小部分。图谱编码的算法从19年开始，几乎都用到了GNN图神经网络，之前更多的是TransE的各种改进。一方面是图神经网络表达能力比较强，另一方面是因为TransE模型是基于链接预测等任务设计的，而图神经网络可以针对实体对齐任务设计相应的特征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在对齐算法部分，现在采用的对齐算法越来越复杂。除了最开始简单的向量对齐之外，更多的实体特征可以被引入，比如：图谱中的关系表示、邻接节点的匹配关系等等。同时也可以引入匹配模块，专门学习实体对之间的交互特征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们还发现越来越多的论文融合了图谱以外的语义信息，如实体的属性、文本描述等，这和实际应用场景是非常契合的。因为实际应用中图谱里面的实体一般也有一些对应的一些文本描述，甚至是多模态的信息比如图像等等，这些信息都可以加以利用。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;商品图谱中的实体对齐&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 商品图谱对齐需要考虑的问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkB63h8sP8vDBQ5N78dsWwOibwP1vFD3u9ia7Qa2sakfWrBNWeF23NHosw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;商品图谱实体对齐需要解决的问题，包含以下三个方面：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 线上预测流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkOEFicL7tMfwg7aV18RH5kHjFTic0lleSHbWOAm7N3PIbMw4CtL0WubdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是我们目前线上采用的预测流程。我们的任务是将商城A的商品数据和商城B的商品数据进行对齐。如果我们把这个任务看成搜索或者匹配过程的话，我们实际上是以商城A的商品信息作为查询条件，在商城B的所有商品中查找要匹配的商品，同时对查询的候选结果进行排序。当然这个过程也可以反过来，把商城B的商品信息作为查询条件。在我们具体应用中，一般是京东商品和别的渠道商品进行对齐。我们能获取到的京东商品数量远远大于其他渠道的商品数量，所以一般把其他渠道的商品作为查询条件，京东商品作为搜索的候选集，这样可以加速查询匹配的过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对齐可以分成四步：召回、精排、粗排、重排。重排实际上是结果的后处理，主要是根据一些校验规则过滤一些bad case。在匹配之前，我们会预先做一些图谱schema的对齐工作，包括商品类目的对齐、属性的对齐等等。粗排和精排都使用了有监督模型，确保排序结果的准确率，对于属性值缺失的情况，会应用属性抽取模型补齐商品属性，强化商品自身的结构化信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 数据集构建和业务评价方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkdd5yz09oiaphkGNo456peo8Cs3hDicBCL48YJXFyxiaJX1VJcYaeN4erA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面提到粗排和精排都使用了有监督模型，模型训练需要一些正负例的数据。&lt;/span&gt;&lt;span&gt;正例数据是互相匹配的商品pair，正例数据的获取是先通过简单的无监督商品相似度模型得到初步的候选集，再结合一些规则过滤后，通过众包标注确认是否匹配而得到的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;负例数据是不匹配的商品pair。理论上我们可以通过随机采样轻易地获得，但这样得到负例样本非常容易区分，不利于提高我们模型的鲁棒性。我们希望能够尽可能得到一些比较对抗性比较强负例，也就是很相似但又不匹配的样本。我们可以利用电商网站中SPU和SKU的概念去构建大量对抗性的负例。比如我们打开京东app要购买一个手机，通常在一个手机商品的页面上，有很多不同配置的手机，比如内存大小颜色不同。SPU就是同一款商品的概念，SKU就是配置具体到不能再区分的单品。一般情况下同一款SPU下，不同SKU的商品之间仅在个别属性上有区别，这样的商品作为负例的话，对于模型区分的难度是很大的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在具体业务中，我们可以离线评价模型的算法性能指标，比如使用之前提到的TOPK命中率，但在线上业务中，TOPK命中率作为指标就不适合了。这是因为TOPK命中率只是把测试集中的商品样本作为候选，但在线上检测时，面对的是全量的商品库，数量要大得多，同时还存在很多难以区分的商品。所以，我们线上是通过商品检出率和检出商品的准确率两个指标评价模型的效果。我们以京东商品作为查询条件为例，如果能在其他渠道的网站中能找到对应商品，那么我们统计有对应商品的京东商品数量，然后计算这部分京东商品在全部京东商品当中的比例，这个比例就是商品检出率。理论上两个商品库都可以以此方式分别计算检出率，我们的实验结果显示，两个商品库的检出率指标往往是正相关的，我们计算一个就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;检出商品的准确率，是将检出的商品匹配结果进行抽样后，然后标注计算正确结果的比例得到的。随着线上商品上架下架，以及随机采样的差异，检出准确率会有一定范围的波动，我们会调整模型检出阈值等，将准确率稳定在一定范围内。在准确率稳定的情况下，就可以通过比较模型的检出率来评估模型的效果了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. 召回与粗排部分&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkcviccV7LnaU9N2KFpmKBMtK6J4iammO4xd0OKORKc5RyDAUmj8cYZrMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们用到的精排模型是深度图谱对齐模型，模型的运算量比较大，为提高运算效率，候选的商品数量应控制在一定范围内，比如100以内。而召回是通过简单的规则如判断是否为同一品牌的商品等等实现的，召回商品的数量还是很多。因此，需要在中间加入粗排模型，我们使用了一个文本匹配的模型作为粗排模型。该模型训练时，把商品的标题作为输入，然后通过Bert编码得到编码结果后计算两个商品向量的余弦距离来进行匹配的。为了加速，我们将模型进行了蒸馏，提升模型的编码速度。另外，我们还使用了向量索引进一步加速粗排的过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5. 精排算法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkDawqx0PjGwvgX0PAOj531tCzb7Cy8qlMQLcbUfWHZRC6rYXGcicMHBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最开始使用的精排算法也是基于文本匹配来实现的。粗排用到的匹配模型只考虑了标题。人工对比商品时，我们会去比较商品的关键属性，比如笔记本电脑，我们会去看CPU型号是否匹配，内存大小、屏幕大小等等是否一致。除了将标题进行编码外，属性值也要进行编码，然后分别在两个商品之间进行特征匹配。因为商品的属性很多，需要提取关键属性，我们采用attention机制去自动学习各个属性的权重。因为关键属性可能不止一个，我们会保留属性匹配特征的多个加权结果，类似于Transformer里面的Multi-Head机制。对于空值属性，我们使用Mask将其权重直接设置为0。最后再基于关键属性和标题的交互匹配特征计算两个商品之间的相似度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上模型的缺点有两个：一是需要预先将属性进行对齐；二是训练集当中商品样本在商品库当中只占据很小的比例，很多商品属性值在训练阶段都没有见过。因此我们希望引入图谱表示学习对整体的商品库进行建模，从而增强模型的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkoCUNXPB8heRLIZzl6G6iaOwhv17ep4r0bViaB8fgXkNMFFIibykRNMDyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是现在线上使用的图谱匹配模型的框架。我们会预先将商品SKU和对应的属性值组织为图结构，SKU与属性值之间的关系为对应属性类别。另外，已知的一些属性值的对齐关系、品类的对齐关系也放在图谱当中。因此图谱当中主要是两个类型的节点，商品SKU节点和属性值节点，其中SKU节点将商品标题作为该节点的文本描述内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了图谱本身的结构化信息外，模型会融合非结构化的信息如文本等。很多论文将文本编码结果直接作为GNN的输入特征，我们曾经尝试将文本编码器直接放在GNN前面去进行训练，但这样做模型的训练速度非常慢，效果也不及预期。目前的做法分为两步：先预训练一个文本编码器，然后将编码结果作为GNN模块和匹配模块的输入特征。另外，这个文本编码器同时还作为粗排模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图谱模型与前面的文本匹配模型相比，有以下优势：首先，该模型可以建模更复杂的商品关系。将商品和属性构建为图谱后，商品和商品之间的关系、属性和属性之间的关系都可以被建模；其次，可以通过图谱的结构化表示，引入商品在商品库中的全局信息。最后，图谱对齐模型并没有假定两个图谱各自的关系需要事先对齐，在本应用中，也无需预先进行属性的对齐操作，在训练过程中可以自动实现对齐。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6. 处理大规模图谱&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkdeS8NF1bIXN6CiaGrDfnHSmTWekzBvzyffaRvTQHo7Lx51bkpAWqh1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商品图谱的数量一般比较大，我们考虑使用Inductive模型进行训练。传统的GCN等模型都是Transductive模型，需要全部节点参与训练才能得到embedding表示。当节点数量很多时，会因为显存或是内存的限制而无法进行训练。此外，在网络结构发生改变时，模型会直接失效，新加入的节点都需要重新训练才能得到对应的图谱表示。这在实际业务场景中是不可接受的，因为商品会经常有上架下架的操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们采用了Inductive模型，该模型会不断聚合邻接节点的信息去更新目标节点的图谱表示。具体是基于图谱采样来实现的，比如：先查询得到图中红色节点的所有邻接节点，当节点的邻接节点非常多时，要对邻接节点进行采样，控制运算量。图神经网络一般会训练多层的表示特征，每一层节点的表示由上一层的邻接节点的表示聚合而来。经过多层的表示之后，也就集成了多跳的邻接节点信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7. 图谱表示学习&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkMcJKhk6Vy1hF8Mibge1ha3Dw0zTLNkibuz6B7yNSm4usyk88B838OdVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在介绍我们的模型前，我们简单回顾一下图神经网络模型。主流的图神经网络模型，都可以用Message Passing框架来进行描述，具体分为以下几步：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第一步：邻接节点决定向目标节点发送什么样的特征，也就是图中的Message函数，这个过程在图谱当中的每条边上单独执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第二步：目标节点聚合收到的邻接节点的Message特征，也就是图中的Aggregate函数，这个过程在图谱当中的每个节点上单独执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第三步：目标节点根据邻接节点消息聚合结果，以及节点自身的特征，更新节点在网络下一层中的特征表示。也就是图中的Update函数，也是图谱中每个节点都执行一遍。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这也是很多图深度学习框架如DGL等设计其API的基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkHfPMbXlGUHOiaicj9rpEYXnJYWsuKFhOfnVJjQHX1wdxImDTtnzXg2qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在商品图谱中，图谱表示学习必须要考虑到实体之间的关系，我们构建的图中，大部分实体关系都是商品属性类别。前面的模型也提到，并不是所有的属性都对商品匹配有帮助，需要提取关键属性。我们采用的做法是设计特定的Aggregate聚合函数，使得聚合邻接节点的Message的时候，各个邻接节点的重要性权重由每条边上的Relation来决定。Message函数和Update函数我们直接使用线性变换来实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在公式中，mj是目标节点i收到邻接节点j的消息，聚合消息时，会有两个权重：第一个权重αij是根据邻接节点j和目标节点i的消息向量mj和mi拼接后计算得到的。在具体图谱中，这个权重代表了标题和属性值的匹配相关度，通常在标题中出现的属性值重要程度越高。第二个权重βij是根据节点连接边上的关系类型计算得到的，每个关系类型也用一个向量进行表示，然后基于这个关系向量去计算得分。两个权重相乘后，最终得到每个邻接节点在Aggregate函数中的权重。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8. 图谱匹配算法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkzs2g6Dp8bpEGicf4PG2G7CoB6wdE3gEYriaaKrjAmdEpbGhEiabQI0hOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在一开始采用了向量对齐的方式实现图谱对齐，我们使用L1距离作为两个向量距离的度量。在Embedding Loss的影响之下，正样本之间的距离会越来越近，而负样本之间会保持一定的距离γ。与前面的文本匹配模型相比，本模型的检出率相对提升了150%以上。但是该模型有一个缺点，强行拉进两个图谱某些样本之间的距离，会破坏原始图谱表示。另外，这个模型利用到的文本信息、邻近节点信息都要少一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpk3RIurvzwz1BGicGSian8LGwY2m4OlDNvq3xybK92rXGKBDy1t68FQ9yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是我们后来使用的匹配模型，除了将候选实体直接进行匹配外，还要利用邻接节点的匹配信息。这其实是基于一个假设，如果两个图谱当中的实体互相匹配的话，它们的邻接节点往往也有很多节点也存在匹配关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体实现的时候，我们除了用到每个节点的GNN表示外，还要利用邻接节点的GNN表示进行匹配。提取两个向量的匹配特征时，主要是计算向量之间的余弦距离，得到两个向量的相似度得分。因为每个节点的邻接节点有很多个，两个节点的邻接节点两两计算会形成一个矩阵。我们需要对矩阵的关键信息进行提取，对于每个邻接节点来说，与之对应匹配的邻接节点一般也只有一个。这样的话，我们通过Max Pooling就可以提取出最匹配的邻接节点的相似度得分，这个Max Pooling在行、列方向都会进行。另外，不是所有的邻接节点都对最终是否对齐的判定有帮助，在Aggregate过程中得到的邻接节点的权重，可以在这个地方用于确定邻接节点的权重，这个权重与前一步邻接节点的相似度得分Max Pooling结果进行相乘。最后，为了进一步提取邻接节点相似度得分的关键信息，我们使用Kernel pooling，它既保留了关键信息，又没有引入过多噪声。最终预测得分要同时融合Kernel Pooling提取的邻接节点匹配特征、两个节点的GNN表示的余弦相似度特征、两个节点文本表示的余弦相似度特征计算得到。与向量对齐模型相比，本模型的检出率又有进一步提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;9. 商品属性抽取&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkPG0QDAd9KvUhzNSH0gJ5u2TWdLdIH4hTUKeNNfkAkwurYmNmAuibzqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多第三方卖家的商品属性填值没有那么规范，会存在很多商品属性的缺失或者错误。如右侧图片所示：CPU型号等关键信息都集中放在一些选项卡或者标题当中，没有放在具体属性里面。因此我们要预先对商品进行属性值抽取。商品属性的补全可以大大提升模型的检出率，重点品类的检出率能提升3到5倍。我们使用序列标注模型实现在商品标题当中的属性值提取。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpklSN3N1mTDILOwdPhdLYunLYrFfMoWnBQdBOrzp6H2fo2syuW4V4DIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商品属性抽取是一个典型的NER任务，因为商品的属性通常比较多，为了加快计算我们把整个属性抽取分为两步：第一步是预测商品标题中有哪些潜在的属性值；第二步，再去预测这些潜在属性值的类别。在商品属性提取时，使用商品的品类信息对于效果提升有一定帮助，品类的embedding特征会帮助我们在标题中要关注哪些字段。另外，我们根据已知的属性值，通过匹配的方式能在标题中找到一些候选的片段，利用这些候选片段可以提升属性抽取的召回率。商品属性预测也是一个比较大的话题，具体细节就不展开了。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;总结与展望&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 总结 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;本次分享介绍了通过融合了文本表示和图谱结构化表示的实体对齐模型，在电商领域中实现了商品之间的对齐任务，并利用商品属性抽取进一步提升了图谱对齐的检出率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 展望 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来的工作会考虑以下几个方面：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;05&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;精彩问答&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;数据schema对齐过程中，schema数据是人工对齐的吗？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;A：schema对齐目前是采用无监督的方式。因为商品数量比较大，通过简单的无监督模型，效果已经比较好了。也可以结合人工审核去提升schema对齐的准确率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span/&gt;&lt;span&gt;标注过程是需要人工的吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：&lt;/span&gt;&lt;span&gt;匹配结果标注是需要人工参与的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;正负样本的选取过程中，它的比例是如何确定的？负样本的生成，有什么策略？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：负样本的生成主要利用SPU下的不同的SKU来生成，每个正样本都会针对性的生成负样本，正样本商品所在SPU中，其它的SKU商品都可以作为负例，这类负例样本的对抗性更强。也有随机抽取、batch内计算相似度采样等方式。现在正负样本比例是1比10，这个比例是根据实验确定的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;表示学习和对齐的模型中，属性是怎么学习的？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：商品属性会有对应的embedding向量表示，这个embedding在训练过程中是参与优化的。在初始化的时候，我们会通过BERT编码计算所有对应属性值embedding向量，然后平均后作为属性初始化的embedding值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;实体对齐的效率和性能会不会受到实体节点数量的影响?超大规模的节点对整个性能会有多大的影响呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：目前处理速度要慢一些，我们做了几百个品类的对齐，对齐过程需要几个小时，运算量还是很大的，接下来会进一步优化处理效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;数值型的数据是如何在知识图谱中使用的呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：&lt;/span&gt;&lt;span&gt;目前没有单独处理数值型数据，会统一把这类数据当作文本数据来处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;商品实体对齐过程中结构信息占比有多大？它对实验效果有多大影响？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：这个可以对比图谱对齐和文本匹配模型的实验效果：与未使用结构化信息的文本匹配模型相比，使用结构化信息的向量对齐模型检出率相对提升150%以上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;不同品类的对齐用哪些属性有啥策略，这些是人工定义的还是自动生成的？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：目前没有对类别进行特殊的处理，所有商品类别都在一个模型中进行训练。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q&lt;/span&gt;&lt;span&gt;：图注意力网络如何融入边的信息，通过边的信息来影响邻近节点的权重？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：如前文介绍，我们有α和β两个系数，α可以看成标题和属性的匹配程度，β是根据属性类别，也就是边的类型来判断属性相似度。这个权重一方面会在聚合邻近节点时用到，另一方面在最后邻近节点匹配时也会用到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;模型上线部署时，模型推理效率的问题是怎么解决的呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：通过粗排模型减少候选的数量。此外，在文本编码时，可以预先去缓存一些高频属性值编码，这样在第二步训练时这部分内容可以直接作为输入，就不再单独计算了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;请问老师schema构建的过程中，有用propagate这种本体构建工具吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：没有用到。因为大部分数据是商品和属性之间关系，这个关系是商城中天然的结构化的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;正负样本的比例不均衡的话，如何消除样本对结果的影响？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：目前正负样本的比例是经过实验得到的。如果负样本很多的话，确实会对召回率、检出率会产生影响，需要在业务上和效果上需要一个平衡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;在使用图结构融合时，有没有试过把两个实体的多个属性拼接成文本，转化成文本相似匹配的方式去做？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：尝试过类似的模型，因为这种模型可以提前交互文本匹配特征，效果也不错，但是商品属性太多，有时候会影响计算效率。另外图神经网络的优势是可以融入结构化的信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;商品关系里面会有除了属性以外的其他关系吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：我们还用到了属性对齐关系，品类归属关系等等。另外SPU关系也用到了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;在RGCN模型训练中，如果图数据比较小，会影响embedding的效果吗？多大规模的数据训练会比较好呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：我们没有使用RGCN模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;在训练过程中，如果图数据会比较小的话，该怎么处理？因为TransE等模型对于大规模数据效果比较好，但是小样本数据训练的话，该怎么去处理呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：小样本的情况下，仅通过图的结构化信息是很难保证效果的，可以把优化的重点放到额外信息利用上，比如文本信息等等，这时候可以利用BERT等预训练的模型。对于图谱本身而言，样本数量少的话，很难达到预期效果。在小样本的情况下，文本信息可能要更重要一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;在这个训练过程中，如果结构信息不强的长尾实体，即：3元组比较小、比较少。这类长尾实体的匹配，您有什么好的解决办法吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：对于结构信息不强的长尾实体，要设法对其进行信息补全，比如我们做的商品属性抽取的工作就是补全结构化信息。另外还是尽可能利用到额外的信息提升效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;在实体匹配的过程中，会提前去看文本的匹配效果吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：会提前看。我们使用的粗排模型就是文本匹配模型，同时还作为图神经网络模型的初始化输入，直接影响最终效果。为了在粗排阶段不损失性能，我们训练粗排模型，使得Top100命中率达到一个比较高的效果，比如99%以上，也就是粗排的前100结果中基本都能包含正确结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;今天的分享就到这里，谢谢大家。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在文末分享、点赞、在看，给个3连击呗~&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享嘉宾：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;289&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;289&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaVOpUgibtUfuPKEm8HfWk4YEI5V9Vhibica4xQ7KlJWLRbbvic2tOMWzcoZcDicnCH37R26MJ27jtKTXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关于我们：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;DataFun：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;专注于大数据、人工智能技术应用的分享与交流。发起于2017年，在北京、上海、深圳、杭州等城市举办超过100+线下和100+线上沙龙、论坛及峰会，已邀请近1000位专家和学者参与分享。其公众号 DataFunTalk 累计生产原创文章500+，百万+阅读，12万+精准粉丝。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1NTMyOTI4Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgiaIKm4YqA09u83TvzKbfsabjfX1TLzaXLAK9MWmC4qI6cuTBJnxygZLZPU49O8g6j8QI9264NMqQ/0?wx_fmt=png&quot; data-nickname=&quot;DataFunTalk&quot; data-alias=&quot;datafuntalk&quot; data-signature=&quot;专注于大数据、人工智能技术应用的分享与交流。致力于成就百万数据科学家。定期组织技术分享直播，并整理大数据、推荐/搜索算法、广告算法、NLP 自然语言处理算法、智能风控、自动驾驶、机器学习/深度学习等技术应用文章。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;🧐&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;，给个&lt;strong&gt;3连击&lt;/strong&gt;呗！&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7be2e3add4835845b57b35b30a35a013</guid>
<title>支付系统架构设计详解</title>
<link>https://toutiao.io/k/5tx1zgw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6b3530ca5238439892c1bee9749010a9</guid>
<title>深度剖析 Vue3 的调度系统</title>
<link>https://toutiao.io/k/6d7kip2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h1&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;什么是调度？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调度这一概念最开始应该来自于操作系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;strong&gt;计算机资源的有限性，必须按照一定的原则&lt;/strong&gt;，选择任务来占用资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统引入调度，&lt;strong&gt;目的是解决计算机资源的分配问题&lt;/strong&gt;，因为任务是源源不断的，但 CPU 不能同时执行所有的任务。如：对部分优先级高的任务（如：用户交互需要立即反馈），需要先占用资源/ 运行，这就是一个优先级的调度。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI2MjcxNTQ0Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/jQmwTIFl1V0dLQzNJW15CVaCoNjposvTpccciaj05o5nPiaqfLRRfTQiaYFYPN41Etrrqt8jPOWukPmJWt3lYxwuA/0?wx_fmt=png&quot; data-nickname=&quot;全栈修仙之路&quot; data-alias=&quot;FerRoad&quot; data-signature=&quot;专注分享 TS、Vue3、前端架构和源码解析等技术干货。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Vue 的调度是什么？有什么不同？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue 的调度，行为上也是&lt;strong&gt;按照一定的原则&lt;/strong&gt;，选择任务来占用资源/执行。但同样的行为，目的却是不一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为，Vue 并不需要解决计算机资源分配的问题（操作系统解决）。Vue 利用调度算法，&lt;strong&gt;保证 Vue 组件渲染过程的正确性以及 API 的执行顺序的正确性&lt;/strong&gt;（不好理解的话可以先看下文）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Vue3 的 API 设计中，存在着各种的异步回调 API 设计，如：组件的生命周期，watch API 的回调函数等。这些回调函数，并不是立即执行的，它们都作为任务（Job），&lt;strong&gt;需要按照一定的规则/顺序去执行&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;部分规则如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;watch 的 callback 函数，需要在组件更新前调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组件 DOM 的更新，需要在响应式数据（Vue 模板依赖的  ref、reactive、data 等数据的变化）更新之后&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;父组件需要先更新，子组件后更新&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Mounted 生命周期，需要在组件挂载之后执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;updated 生命周期，需要在组件更新之后执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;……&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue 的 API 设计中就制定了这份规则，&lt;strong&gt;在什么时候应该执行什么任务，而这个规则在代码中的实现，就是调度算法&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;学习 Vue 调度的目的&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue 不是调度算法发明者，相反，Vue是&lt;strong&gt;调度算法的使用者和受益者&lt;/strong&gt;。这些设计，都是基于先人的探索沉淀，再结合自身需求改造出来的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端技术的更新迭代速度非常快，&lt;strong&gt;但是这些优秀的设计，却是不变的&lt;/strong&gt;，这也就是我们学习这些优秀设计的目的，能够做到，以不变应万变。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;调度算法基本介绍&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调度算法有两个基本数据结构：&lt;strong&gt;队列（queue），任务（Job）&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16769836803601576&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OibzJoI7k4IKL5awZDP0m9hsMSF4picBmWTIjRDMBOEKA5h12eNTxPuu6PEKbF34Zx4LGEiahsKwSf62SwNCR5Mtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1777&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;入队：将任务加入队列，等待执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;出队：将任务取出队列，立即执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调度算法有很多种，它们都有不同的目的，但它们的基本数据结构都相同，&lt;strong&gt;不同点在于入队和出队的方式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是两种常见的调度算法&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先来先服务(FCFS)：先入队的 Job 先执行。这种算法常见于，Job 平等、没有优先级的场景。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;优先级调度算法：优先级高的 Job 先执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2880470280862182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OibzJoI7k4IKL5awZDP0m9hsMSF4picBmWyXhEH3ibjJectiaiaIwtyibibNpZ11hkXmkTnG3NZ00RTn8foEZVbuAtqSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1531&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;调度算法里面一点关于 Vue 的东西都没有，如何跟 Vue 扯上关系？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调度算法是对整个调度过程的抽象，算法无需关心任务（Job）的内容是什么，它作为 Vue3 的一种基础设施，起到了&lt;strong&gt;解耦&lt;/strong&gt;的作用（如果暂时还理解不了这句话，下一小节还有解释）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;调度算法只调度执行的顺序，不负责具体的执行&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 Vue 是如何利用调度算法，来实现自身 API 的正确调度的呢？我们在文章后面会详细描述&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Vue3 调度算法的使用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue3 的调度算法，与上面提到的算法，大致相同，只是适配了 Vue 的一些细节&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue 有 3 个队列，分别为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;组件 DOM 更新&lt;/strong&gt;（不是组件的数据 data 更新）&lt;strong&gt;前队列&lt;/strong&gt;，后面也称为 Pre 队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;组件 DOM 更新&lt;/strong&gt;（不是组件的数据 data 更新）&lt;strong&gt;队列&lt;/strong&gt;，后面也称为 queue 队列 / 组件异步更新队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;组件 DOM 更新&lt;/strong&gt;（不是组件的数据 data 更新）&lt;strong&gt;后队列&lt;/strong&gt;，后面也称为 Post 队列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49464788732394366&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OibzJoI7k4IKL5awZDP0m9hsMSF4picBmWyu3G9NgRRCnyRJCjdPPVniapNIzELR6rTRSO9T3XEKcOU8icbTLUDY4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1775&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3 个队列的部分特性对比（大概看看即可，后面会详细介绍）：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;Pre 队列&lt;/th&gt;&lt;th&gt;queue 队列&lt;/th&gt;&lt;th&gt;Post 队列&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;队列作用&lt;/td&gt;&lt;td&gt;执行组件 DOM 更新之前的任务&lt;/td&gt;&lt;td&gt;执行组件 DOM 更新&lt;/td&gt;&lt;td&gt;执行组件 DOM 更新之后的任务&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;出队方式&lt;/td&gt;&lt;td&gt;先进先出&lt;/td&gt;&lt;td&gt;允许插队，按 id 从小到大执行&lt;/td&gt;&lt;td&gt;允许插队，按 id 从小到大执行&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个调度过程中，&lt;strong&gt;只有入队过程，是由我们自己控制，整个队列的执行（如何出队），都由队列自身控制&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此：调度算法对外暴露的 API，也只有入队 API：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;queuePreFlushCb：加入 Pre 队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;queueJob：加入 queue 队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;queuePostFlushCb：加入 Post 队列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是用法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; job1 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 假设这里是父组件的 DOM 更新逻辑&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;父组件 DOM 更新 job 1&#x27;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;job1.id = &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;// 设置优先级，Vue 规定是 id 越小，优先级越高&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; job2 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 假设这里是子组件的 DOM 更新逻辑&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;子组件 DOM 更新 job 2&#x27;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;job2.id = &lt;span&gt;2&lt;/span&gt;  &lt;span&gt;// 设置优先级&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 加入 queue 队列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// job 2 先加入，但是会在 job 1 之后执行，因为 id 小的，优先级更高&lt;/span&gt;&lt;br/&gt;queueJob(job2)&lt;br/&gt;queueJob(job1)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 加入 Post 队列&lt;/span&gt;&lt;br/&gt;queuePostFlushCb(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 假设这里是 updated 生命周期&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;执行 updated 生命周期 1&#x27;&lt;/span&gt;)&lt;br/&gt;})&lt;br/&gt;&lt;span&gt;// 加入 Post 队列&lt;/span&gt;&lt;br/&gt;queuePostFlushCb(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 假设这里是 updated 生命周期&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;执行 updated 生命周期 2&#x27;&lt;/span&gt;)&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 加入 Pre 队列&lt;/span&gt;&lt;br/&gt;queuePreFlushCb(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 假设这里是 watch 的回调函数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;执行 watch 的回调函数 1&#x27;&lt;/span&gt;)&lt;br/&gt;})&lt;br/&gt;&lt;span&gt;// 加入 Pre 队列&lt;/span&gt;&lt;br/&gt;queuePreFlushCb(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 假设这里是 watch 的回调函数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;执行 watch 的回调函数 2&#x27;&lt;/span&gt;)&lt;br/&gt;})&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;所有响应式数据更新完毕&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 所有响应式数据更新完毕&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 执行 watch 的回调函数 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 执行 watch 的回调函数 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 父组件 DOM 更新 job 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 子组件 DOM 更新 job 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 执行 updated 生命周期 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 执行 updated 生命周期 2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;队列使用上非常的简单，只要往对应的队列，传入 job 函数即可。队列会&lt;strong&gt;在当前浏览器任务的所有 js 代码执行完成后&lt;/strong&gt;,才开始&lt;strong&gt;依次执行 Pre 队列、queue 列、Post 队列&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;调度算法是对整个调度过程的抽象&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们应该能更好的理解这句话，队列只是根据其自身的队列性质（先进先出 or 优先级），选择一个 Job 执行，队列不关心 Job 的内容是什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的设计，&lt;strong&gt;可以极大的减少 Vue API 和 队列间耦合&lt;/strong&gt;，队列不知道 Vue API 的存在，即使 Vue 未来新增新的异步回调的 API，也不需要修改队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述例子中：我们大概可以看出，Vue3 是如何使用调度 API，去控制各种类型的异步回调的执行时机的。对于不同的异步回调 API，&lt;strong&gt;会根据 API 设计的执行时机，使用不同的队列&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;watch 的回调函数，默认是在组件 DOM 更新之前执行，因此使用 Pre 队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组件 DOM 更新，使用 queue 队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;updated 生命周期需要在组件 DOM 更新之后执行，因此使用的是 Post 队列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.962059620596206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OibzJoI7k4IKL5awZDP0m9hsMSF4picBmWXmqhdibuv58gWCeib0A58LUibXu4gIJLDAlBpnuERugusAzG3y2Mh2lAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;738&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文不会过多的介绍 Job 的具体内容的实现（不同的 API，Job 的内容都是不一样的），而是&lt;strong&gt;专注于调度机制的内部实现&lt;/strong&gt;，接下来我们的深入了解 Vue 的调度机制内部。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;名词约定&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从一个例子中，理解用到的各种名词：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;{{count}}&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&#x27;add&#x27;&lt;/span&gt;&amp;gt;&lt;/span&gt;Add&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;setup&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;=&lt;span&gt;&#x27;ts&#x27;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ref } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;vue&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; count = ref(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  count.value = count.value + &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;// template 依赖 count，修改后会触 queueJob(instance.update)&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;响应式数据更新&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指模板依赖的 &lt;strong&gt;ref、reactive、组件 data&lt;/strong&gt; 等响应式数据的变化&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里指点击按钮触发的 click 回调中，响应式数据 count.value 被修改&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;组件 DOM 更新&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上是调用 &lt;code&gt;instance.update&lt;/code&gt; 函数，该函数会对比&lt;strong&gt;组件 data 更新前的 VNode&lt;/strong&gt; 和&lt;strong&gt;组件 data 更新后的 VNode&lt;/strong&gt;，对比之间的差异，修改差异部分的 DOM。该过程叫 patch，比较 vnode 的方法叫 &lt;strong&gt;diff 算法&lt;/strong&gt;（因为这里没有篇幅展开，因此大概看看记住  &lt;code&gt;instance.update&lt;/code&gt; 的特点即可）&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;instance&lt;/code&gt; 是指 Vue 内部的组件实例，我们直接使用接触不到该实例。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;instance.update&lt;/code&gt; 是&lt;strong&gt;深度更新&lt;/strong&gt;，即除了会更新组件本身，还会递归调用子组件的 &lt;code&gt;instance.update&lt;/code&gt; ，因此，这个过程会更新整个组件树。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;instance.update&lt;/code&gt; 会&lt;strong&gt;更新该组件的属性&lt;/strong&gt;（如果父组件的传入发生变化），然后更新它对应的 DOM&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;**响应式数据更新 ≠ 组件 DOM **更新，响应式数据更新，只是变量值的改变，此时还没修改 DOM，但会立即执行 &lt;code&gt;queueJob(instance.update)&lt;/code&gt;，将组件 DOM 更新任务，加入到队列。&lt;strong&gt;即数据修改是立即生效的，但 DOM 修改是延迟执行&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3516666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OibzJoI7k4IKL5awZDP0m9hsMSF4picBmWM0V00iaWKrmjezt9Z1rnD4jTuT2MCiaRZ9FWtQBibGMpZW1Lx2v5XHvoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;调度细节&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一个表格总结 3 个调度过程中的一些细节&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;Pre 队列&lt;/th&gt;&lt;th&gt;queue 队列&lt;/th&gt;&lt;th&gt;Post 队列&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;队列作用&lt;/td&gt;&lt;td&gt;执行组件 DOM 更新之前的任务&lt;/td&gt;&lt;td&gt;执行组件 DOM 更新&lt;/td&gt;&lt;td&gt;执行组件 DOM 更新之后的任务&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;任务去重&lt;/td&gt;&lt;td&gt;去重&lt;/td&gt;&lt;td&gt;去重&lt;/td&gt;&lt;td&gt;去重&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;出队方式&lt;/td&gt;&lt;td&gt;先进先出&lt;/td&gt;&lt;td&gt;允许插队，按 id 从小到大执行&lt;/td&gt;&lt;td&gt;允许插队，按 id 从小到大执行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;任务有效性&lt;/td&gt;&lt;td&gt;任务全部有效&lt;/td&gt;&lt;td&gt;组件卸载时，对应的任务失效&lt;/td&gt;&lt;td&gt;任务全部有效&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;删除任务&lt;/td&gt;&lt;td&gt;不需要&lt;/td&gt;&lt;td&gt;特殊情况需要删除任务&lt;/td&gt;&lt;td&gt;不需要&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Job 递归&lt;/td&gt;&lt;td&gt;默认允许&lt;/td&gt;&lt;td&gt;默认允许&lt;/td&gt;&lt;td&gt;默认允许&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们一个个细节进行解析：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;任务去重&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次修改响应式变量（即修改相应的响应式数据），都会将&lt;strong&gt;组件 DOM 更新 Job&lt;/strong&gt;加入队列。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 当组件依赖的响应式变量被修改时，会立即调用 queueJob&lt;/span&gt;&lt;br/&gt;queueJob(instance.update)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那当我们同时修改多次，同一个组件依赖的响应式变量时，会多次调用 queueJob。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是一个简单的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;{{count}}&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&#x27;add&#x27;&lt;/span&gt;&amp;gt;&lt;/span&gt;Add&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;setup&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;=&lt;span&gt;&#x27;ts&#x27;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ref } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;vue&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; count = ref(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  count.value = count.value + &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;// template 依赖 count，修改后会触 queueJob(instance.update)&lt;/span&gt;&lt;br/&gt;  count.value = count.value + &lt;span&gt;2&lt;/span&gt;  &lt;span&gt;// template 依赖 count，修改后会触 queueJob(instance.update)&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;count.value 前后两次被修改，&lt;strong&gt;会触发两次 queueJob&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了防止多次重复地执行更新，需要在入队的时候，对 Job 进行去重（伪代码）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;queueJob&lt;/span&gt;(&lt;span&gt;job: SchedulerJob&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 去重判断&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!queue.includes(job)) {&lt;br/&gt;   &lt;span&gt;// 入队&lt;/span&gt;&lt;br/&gt;    queue.push(job)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他队列的入队函数也有类似的去重逻辑。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;优先级机制&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有 queue 队列和 Post 队列，是有优先级机制的，&lt;strong&gt;job.id 越小，越先执行&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为什么需要优先级队列？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;queue 队列和 Post 队列使用优先级的原因各不相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来逐一分析：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;queue 队列的优先级机制&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;queue 队列的 Job，是执行组件的 DOM 更新。在 Vue 中，&lt;strong&gt;组件并不都是相互独立的，它们之前存在父子关系&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;必须先更新父组件，才能更新子组件&lt;/strong&gt;，因为父组件可能会传参给子组件（作为子组件的属性）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图展示的是，父组件和子组件及其属性更新先后顺序：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5016987542468856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OibzJoI7k4IKL5awZDP0m9hsMSF4picBmWFKHYw4xAZFsDkopNSn3YprBeqle85fLBMt0OnN4Njd9uSW5KfdZBdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1766&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;父组件 DOM 更新前，才会修改子组件的 props&lt;/strong&gt;，因此，必须要先执行父组件 DOM 更新，子组件的 props 才是正确的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此：&lt;strong&gt;父组件优先级 &amp;gt; 子组件优先级&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如何保证父组件优先级更高？即如何保证父组件的 Job.id 更小？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们上一小节说过，组件 DOM 更新，会深度递归更新子组件。组件创建的过程也一样，也会深度递归创建子组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是一个组件树示意图，其创建顺序如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6425661914460286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OibzJoI7k4IKL5awZDP0m9hsMSF4picBmWTrcZVpHtvS4K2k6RzQ9oY3Syu7SS6IicT3tvjxJL3ichZrXQj7Hy7w6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;982&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;深度创建组件，即按树的深度遍历的顺序创建组件。深度遍历，一定是先遍历父节点，再遍历子节点&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，从图中也能看出，&lt;strong&gt;父组件的序号，一定会比子组件的序号小，使用序号作为 Job.id 即可保证父组件优先级一定大于子组件&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里我们可以感受一下深度遍历在处理依赖顺序时的巧妙作用，前辈们总结出来的算法，竟有如此的妙用。&lt;/p&gt;&lt;p&gt;我们学习源码，学习算法，就是学习这些设计。&lt;/p&gt;&lt;p&gt;当我们以后在项目中，遇到依赖谁先执行的问题，会想起深度遍历这个算法。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要实现 queue 队列 Job 的优先级，我们只需要实现插队功能即可：（伪代码）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;queueJob&lt;/span&gt;(&lt;span&gt;job: SchedulerJob&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 去重判断&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ( !queue.includes(job) ) {&lt;br/&gt;    &lt;span&gt;// 没有 id 放最后&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (job.id == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      queue.push(job)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// 二分查找 job.id，计算出需要插入的位置&lt;/span&gt;&lt;br/&gt;      queue.splice(findInsertionIndex(job.id), &lt;span&gt;0&lt;/span&gt;, job)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Post 队列的优先级机制&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先回顾一下我们常常使用到的 Post 队列的 Job，都有哪些：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mounted、updated 等生命周期，它们有个共同特点，就是需要等 DOM 更新后，再执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;watchPostEffect API，用户手动设置 watch 回调在 DOM 更新之后执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这些用户设定的回调之间，并没有依赖关系&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那为什么 Post 队列还需要优先级呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为有一种内部的 Job，要提前执行，它的作用是，&lt;strong&gt;更新模板引用&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为用户编写的回调函数中，可能会使用到模板引用，因此&lt;strong&gt;必须要在用户编写的回调函数执行前，把模板引用的值更新&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&#x27;add&#x27;&lt;/span&gt; &amp;gt;&lt;/span&gt;count: {{ count }}&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;v-if&lt;/span&gt;=&lt;span&gt;&quot;count % 2&quot;&lt;/span&gt; &lt;span&gt;:ref&lt;/span&gt;=&lt;span&gt;&quot;divRef&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;count 为偶数&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;v-else&lt;/span&gt; &lt;span&gt;:ref&lt;/span&gt;=&lt;span&gt;&quot;divRef&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;count 为奇数&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;setup&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;=&lt;span&gt;&#x27;ts&#x27;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; {onUpdated, ref} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;vue&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; count = ref(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  count.value = count.value + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; divRef = ref&amp;lt;HTMLElement&amp;gt;()&lt;br/&gt;&lt;br/&gt;onUpdated(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;onUpdated&#x27;&lt;/span&gt;, divRef.value?.innerHTML)&lt;br/&gt;})&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;响应式变量 count 为奇数或偶数时，divRef.value 指向的 DOM 节点是不一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;必须要在用户写的 updated 生命周期执行前，先更新 divRef，否则就会取到错误的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，更新模板引用的 Job，&lt;code&gt;job.id = -1&lt;/code&gt;，会先执行&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而其他用户设定的 job，没有设置 job.id，会加入到队列末尾，在最后执行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;失效任务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当组件被卸载（unmounted）时，其对应的 Job 会失效，因为不需要再更新该组件了&lt;/strong&gt;。失效的任务，在取出队列时，不会被执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有 queue 队列的 Job，会失效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是一个失效案例的示意图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5581661891117479&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OibzJoI7k4IKL5awZDP0m9hsMSF4picBmWhDA3AlM4O30SOaFSrpIJRicZqHr80TPk9GhuCGe9OqlqnHZLXHDIUPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1745&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;点击按钮，count.value 改变&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;count 响应式变量改变，会立即 queueJob 将子组件 Job 加入队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;emit 事件，父组件 hasChild.value 改变&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hasChild 响应式变量改变，会立即 queueJob 将父组件 Job 加入队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;父组件有更高优先级，先执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新父组件 DOM，子组件由于 v-if，被卸载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子组件卸载时，将其 Job 失效，&lt;code&gt;Job.active = false&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要实现失效任务不执行，非常简单，参考如下实现（伪代码）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;const&lt;/span&gt; job of queue){&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(job.active !== &lt;span&gt;false&lt;/span&gt;){&lt;br/&gt;        job()&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;删除任务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组件 DOM 更新（instance.update），是&lt;strong&gt;深度更新&lt;/strong&gt;，会递归的对所有子组件执行 &lt;code&gt;instance.update&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，&lt;strong&gt;在父组件深度更新完成之后，不需要再重复更新子组件&lt;/strong&gt;，更新前，需要将组件的 Job 从队列中删除&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图是任务删除的示意图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6168284789644013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OibzJoI7k4IKL5awZDP0m9hsMSF4picBmW9q4s4aG2IRB2ibzCicgyQAecOpUmWgiaFFvpSsHbZyibcCh8JZvDoaOib8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1545&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一个组件 DOM 更新时，会先把该组件的 Job，从队列中删除。因为即将更新该组件，就不需要再排队执行了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要实现删除 Job，非常简单：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;invalidateJob&lt;/span&gt;(&lt;span&gt;job&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 找到 job 的索引&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; i = queue.indexOf(job)&lt;br/&gt;  &lt;span&gt;// 删除 Job&lt;/span&gt;&lt;br/&gt;  queue.splice(i, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 在 instance.udpate 中删除当前组件的 Job&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; job = instance.update = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span/&gt;)&lt;/span&gt;{&lt;br/&gt;    invalidateJob(job)&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 组件 DOM 更新&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;删除和失效，都是不执行该 Job，它们有什么使用上的区别？&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;失效&lt;/th&gt;&lt;th&gt;删除&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;场景&lt;/td&gt;&lt;td&gt;组件卸载时，将 Job 设置为失效，Job 从队列中取出时，不再执行&lt;/td&gt;&lt;td&gt;组件更新时，删除该组件在队列中的 Job&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;能否再次&lt;br/&gt;加入队列&lt;/td&gt;&lt;td&gt;不能，会被去重&lt;/td&gt;&lt;td&gt;可以再次加入队列&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;意义&lt;/td&gt;&lt;td&gt;被卸载的组件，无论它依赖的响应式变量如何更新，该组件都不会更新了&lt;/td&gt;&lt;td&gt;删除任务，是因为已经更新过了，不需要重复更新。&lt;br/&gt;如果依赖的响应式变量再次被修改，仍然需要加入队列，等待更新&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Job 递归&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;递归这个特性，是 vue 调度中比较复杂的情况。如果暂时理解不了的，可以先继续往下看，不必过于扣细节。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Job 递归，就是 Job &lt;strong&gt;在更新组件 DOM 的过程中&lt;/strong&gt;，依赖的响应式变量发生变化，又调用 &lt;code&gt;queueJob&lt;/code&gt; &lt;strong&gt;把自身的 Job 加入到队列中&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为什么会需要递归？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先做个类比，应该就大概明白了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你刚拖好地，你儿子就又把地板踩脏了，你只有重新再拖一遍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你一直拖，儿子一直踩，就是无限递归了。。。这时候就应该把儿子打一顿。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在组件 DOM 更新（instance.update）的过程中，可能会导致自身依赖的响应式变量改变，从而调用 queueJob，将自身 Job 加入到队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于响应式数据被改变（因为脏了），需要&lt;strong&gt;整个组件重新更新&lt;/strong&gt;（所以需要重新拖地）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图就是一个组件 DOM 更新过程中，导致响应式变量变化的例子：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5431614349775785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OibzJoI7k4IKL5awZDP0m9hsMSF4picBmWI8t7Z68fBiaO2HibEH6UdSpIsArs1FUFMquC11ssUMAaziaiae2MJvBqzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1784&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;父组件刚更新完，子组件由于属性更新，&lt;strong&gt;立即触发 watch&lt;/strong&gt;，emit 事件，修改了父组件的 loading 响应式变量，导致父组件需要重新更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（watch 一般情况下，是加入到 Pre 队列等待执行，但在组件 DOM 更新时，watch也是加入队列，但会立即执行并清空 Pre 队列，暂时先记住有这个小特性即可）&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Job 的结构是怎样的？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Job 的数据结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; SchedulerJob &lt;span&gt;extends&lt;/span&gt; Function {&lt;br/&gt;  id?: &lt;span&gt;number&lt;/span&gt;   &lt;span&gt;// 用于对队列中的 job 进行排序，id 小的先执行&lt;/span&gt;&lt;br/&gt;  active?: &lt;span&gt;boolean&lt;/span&gt;&lt;br/&gt;  computed?: &lt;span&gt;boolean&lt;/span&gt;&lt;br/&gt;  allowRecurse?: &lt;span&gt;boolean&lt;/span&gt;   &lt;span&gt;// 表示 effect 是否允许递归触发本身&lt;/span&gt;&lt;br/&gt;  ownerInstance?: ComponentInternalInstance  &lt;span&gt;// 仅仅用在开发环境，用于递归超出次数时，报错用的&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;job 本身是一个函数&lt;/strong&gt;，并且带有有一些属性。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;id，表示优先级，用于实现队列插队，id 小的先执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;active：表示 Job 是否有效，失效的 Job 不执行。如组件卸载会导致 Job 失效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;allowRecurse：是否允许递归&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他属性，我们可以先不关注，因为跟调度机制的核心逻辑无关。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;队列的结构是怎样的？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;queue 队列的数据结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; queue: SchedulerJob[] = []&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;队列的执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 按优先级排序&lt;/span&gt;&lt;br/&gt;queue.sort(&lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; getId(a) - getId(b))&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (flushIndex = &lt;span&gt;0&lt;/span&gt;; flushIndex &amp;lt; queue.length; flushIndex++) {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; job = queue[flushIndex]&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (job &amp;amp;&amp;amp; job.active !== &lt;span&gt;false&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;// 执行 Job 函数，并带有 Vue 内部的错误处理，用于格式化错误信息，给用户更好的提示&lt;/span&gt;&lt;br/&gt;        callWithErrorHandling(job, &lt;span&gt;null&lt;/span&gt;, ErrorCodes.SCHEDULER)&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 清空 queue 队列&lt;/span&gt;&lt;br/&gt;    flushIndex = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    queue.length = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前的图示讲解中，为了更好的理解队列，会把 Job 的执行，画成取出队列并执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在真正写代码中，队列的执行，是不会把 Job 从 queue 中取出的，而是遍历所有的 Job 并执行，在最后清空整个 queue。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;加入队列&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;queueJob&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 queue 队列的 Job，加入队列的实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;queueJob&lt;/span&gt;(&lt;span&gt;job: SchedulerJob&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;br/&gt;    (!queue.length ||&lt;br/&gt;      &lt;span&gt;// 去重判断&lt;/span&gt;&lt;br/&gt;      !queue.includes(&lt;br/&gt;        job,&lt;br/&gt;        &lt;span&gt;// isFlushing 表示正在执行队列&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// flushIndex 当前正在执行的 Job 的 index&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// queue.includes 函数的第二个参数，是表示从该索引开始查找&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 整个表达式意思：如果允许递归，则当前正在执行的 Job，不加入去重判断&lt;/span&gt;&lt;br/&gt;        isFlushing &amp;amp;&amp;amp; job.allowRecurse ? flushIndex + &lt;span&gt;1&lt;/span&gt; : flushIndex&lt;br/&gt;      ))&lt;br/&gt;  ) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (job.id == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// 没有 id 的加入到队列末尾&lt;/span&gt;&lt;br/&gt;      queue.push(job)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// 在指定位置加入 job&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// findInsertionIndex 是使用二分查找，找出合适的插入位置&lt;/span&gt;&lt;br/&gt;      queue.splice(findInsertionIndex(job.id), &lt;span&gt;0&lt;/span&gt;, job)&lt;br/&gt;    }&lt;br/&gt;    queueFlush()   &lt;span&gt;// 作用会在后面说&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有几个特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;去重&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;处理递归，如果允许递归，则正在运行的 job，不加入去重判断&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;优先级实现，按 id 从小到大，在队列合适的位置插入 Job；如果没有 id，则放到最后&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;queueCb&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Pre 队列和 Post 队列的实现也大致相同&lt;/strong&gt;，只不过是没有优先级机制（Post 队列的优先级在执行时处理）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;queueCb&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;  cb: SchedulerJobs,&lt;br/&gt;  activeQueue: SchedulerJob[] | &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;  pendingQueue: SchedulerJob[],&lt;br/&gt;  index: &lt;span&gt;number&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!isArray(cb)) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;br/&gt;      !activeQueue ||&lt;br/&gt;      &lt;span&gt;// 去重判断&lt;/span&gt;&lt;br/&gt;      !activeQueue.includes(cb, cb.allowRecurse ? index + &lt;span&gt;1&lt;/span&gt; : index)&lt;br/&gt;    ) {&lt;br/&gt;      pendingQueue.push(cb)&lt;br/&gt;    }&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// if cb is an array, it is a component lifecycle hook which can only be&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// triggered by a job, which is already deduped in the main queue, so&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// we can skip duplicate check here to improve perf&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 翻译：如果 cb 是一个数组，它只能是在一个 job 内触发的组件生命周期 hook（而且这些 cb 已经去重过了，可以跳过去重判断）&lt;/span&gt;&lt;br/&gt;    pendingQueue.push(...cb)&lt;br/&gt;  }&lt;br/&gt;  queueFlush()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;queuePreFlushCb&lt;/span&gt;(&lt;span&gt;cb: SchedulerJob&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;queuePostFlushCb&lt;/span&gt;(&lt;span&gt;cb: SchedulerJobs&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来说，加入队列函数，核心逻辑就都是如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;queueJob&lt;/span&gt;(&lt;span/&gt;)&lt;/span&gt;{&lt;br/&gt;    queue.push(job)&lt;br/&gt;    queueFlush()  &lt;span&gt;// 作用会在后面说&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个基础上，另外再加上一些去重判断、和优先级而已。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为什么组件异步队列 queue 跟 Pre 队列、Post 队列的入队方式还不一样呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为一些细节上的处理不一致&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;queue 队列有优先级&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;而 Pre 队列、Post 队列的入参，可能是数组&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但其实我们也不需要过分关心这些细节，因为我们学习源码，其实是为了学习它的优良设计，我们把设计学到就好了，在现实的项目中，我们几乎不会遇到一模一样的场景，因此&lt;strong&gt;掌握整体设计，比抠细节更重要&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那么 queueFlush 有什么作用呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;queueFlush 的作用，就好像是你第一个到饭堂打饭，阿姨在旁边坐着，你得提醒阿姨该给你打饭了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;队列其实并不是一直都在执行的，&lt;strong&gt;当列队为空之后，就会停止&lt;/strong&gt;，&lt;strong&gt;等到又有新的 Job 进来的时候，队列才会开始执行&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;queueFlush 在这里的作用，就是告诉队列可以开始执行了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看看 queueFlush 的实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; isFlushing = &lt;span&gt;false&lt;/span&gt;  &lt;span&gt;// 标记队列是否正在执行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; isFlushPending = &lt;span&gt;false&lt;/span&gt; &lt;span&gt;// 标记队列是否等待执行&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;queueFlush&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 如果不是正在执行队列 / 等待执行队列&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!isFlushing &amp;amp;&amp;amp; !isFlushPending) {&lt;br/&gt;    &lt;span&gt;// 用于标记为等待执行队列&lt;/span&gt;&lt;br/&gt;    isFlushPending = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 在下一个微任务执行队列&lt;/span&gt;&lt;br/&gt;    currentFlushPromise = resolvedPromise.then(flushJobs)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行队列的方法，是 flushJob。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;queueFlush 是&lt;strong&gt;队列执行时机的实现&lt;/strong&gt; —— &lt;strong&gt;flushJob 会在下一个微任务时执行&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为什么执行时机为下一个微任务？为什么不能是 setTimeout(flushJob, 0)&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们目的，是延迟执行 queueJob，&lt;strong&gt;等所有组件数据都更新完&lt;/strong&gt;，再执行组件 DOM 更新（instance.update）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要达到这一目的：我们只需要等在下一个浏览器任务，执行 queueJob 即可&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为，响应式数据的更新，&lt;strong&gt;都在当前的浏览器任务中&lt;/strong&gt;。当 queueJob 作为微任务执行时，就表明上一个任务一定已经完成了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在浏览器中，&lt;strong&gt;微任务比宏任务有更高的优先级&lt;/strong&gt;，因此 queueJob 使用微任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;浏览器事件循环示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5483247422680413&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OibzJoI7k4IKL5awZDP0m9hsMSF4picBmWpXtDwKiaPic7OXWCqiaOPxEibKAacE1ZOJjogkztWuEszdpFCa7P0xOgkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1552&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次循环，浏览器只会取一个宏任务执行，而微任务则是执行全部，在微任务执行 queueJob，能在最快时间执行队列，并且接下来浏览器就会执行渲染页面，更新UI。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;否则，如果 queueJob 使用宏任务，极端情况下，可能会有多个宏任务在 queueJob 之前，而每次事件循环，只会取一个宏任务，则 queueJob 的执行时机会在非常的后，这对用户体验来说是有一定的伤害的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们已经把下图蓝色部分都解析完了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5070257611241218&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OibzJoI7k4IKL5awZDP0m9hsMSF4picBmWJlTfic2XkXjhibhEjoxTub9EBs0K0qEZiclAZwuGicIMLLr67jWCpmSnlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1708&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;剩下的是红色部分，即函数 flushJob 部分的实现了：&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;队列的执行 flushJob&lt;/span&gt;&lt;/h1&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;flushJobs&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 等待状态设置为 false &lt;/span&gt;&lt;br/&gt;  isFlushPending = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 标记队列为正在执行状态&lt;/span&gt;&lt;br/&gt;  isFlushing = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 执行 Pre 队列&lt;/span&gt;&lt;br/&gt;  flushPreFlushCbs()&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 根据 job id 进行排序，从小到大&lt;/span&gt;&lt;br/&gt;  queue.sort(&lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; getId(a) - getId(b))&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 用于检测是否是无限递归，最多 100 层递归，否则就报错，只会开发模式下检查&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; check = __DEV__&lt;br/&gt;    ? &lt;span&gt;(&lt;span&gt;job: SchedulerJob&lt;/span&gt;) =&amp;gt;&lt;/span&gt; checkRecursiveUpdates(seen!, job)&lt;br/&gt;    : NOOP&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 循环组件异步更新队列，执行 job&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (flushIndex = &lt;span&gt;0&lt;/span&gt;; flushIndex &amp;lt; queue.length; flushIndex++) {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; job = queue[flushIndex]&lt;br/&gt;      &lt;span&gt;// 仅在 active 时才调用 job&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (job &amp;amp;&amp;amp; job.active !== &lt;span&gt;false&lt;/span&gt;) {&lt;br/&gt;          &lt;br/&gt;        &lt;span&gt;// 检查无限递归&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (__DEV__ &amp;amp;&amp;amp; check(job)) {&lt;br/&gt;          &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 调用 job，带有错误处理&lt;/span&gt;&lt;br/&gt;        callWithErrorHandling(job, &lt;span&gt;null&lt;/span&gt;, ErrorCodes.SCHEDULER)&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 收尾工作，重置这些用于标记的变量&lt;/span&gt;&lt;br/&gt;    flushIndex = &lt;span&gt;0&lt;/span&gt;  &lt;span&gt;// 将队列执行的 index 重置&lt;/span&gt;&lt;br/&gt;    queue.length = &lt;span&gt;0&lt;/span&gt; &lt;span&gt;// 清空队列&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 执行 Post 队列&lt;/span&gt;&lt;br/&gt;    flushPostFlushCbs()&lt;br/&gt;&lt;br/&gt;    isFlushing = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    currentFlushPromise = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;     &lt;br/&gt;    &lt;span&gt;// 如果还有 Job，继续执行队列&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Post 队列运行过程中，可能又会将 Job 加入进来，会在下一轮 flushJob 执行&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;br/&gt;      queue.length ||&lt;br/&gt;      pendingPreFlushCbs.length ||&lt;br/&gt;      pendingPostFlushCbs.length&lt;br/&gt;    ) {&lt;br/&gt;      flushJobs()&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;flushJob 主要执行以下内容：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;执行 Pre 队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行queue 队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行 Post 队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;循环重新执行所有队列，直到所有队列都为空&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;执行 queue 队列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;queue 队列执行对应的是这一部分：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 循环组件异步更新队列，执行 job&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (flushIndex = &lt;span&gt;0&lt;/span&gt;; flushIndex &amp;lt; queue.length; flushIndex++) {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; job = queue[flushIndex]&lt;br/&gt;      &lt;span&gt;// 仅在 active 时才调用 job&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (job &amp;amp;&amp;amp; job.active !== &lt;span&gt;false&lt;/span&gt;) {&lt;br/&gt;          &lt;br/&gt;        &lt;span&gt;// 检查无限递归&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (__DEV__ &amp;amp;&amp;amp; check(job)) {&lt;br/&gt;          &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 调用 job，带有错误处理&lt;/span&gt;&lt;br/&gt;        callWithErrorHandling(job, &lt;span&gt;null&lt;/span&gt;, ErrorCodes.SCHEDULER)&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 收尾工作，重置这些用于标记的变量&lt;/span&gt;&lt;br/&gt;    flushIndex = &lt;span&gt;0&lt;/span&gt;  &lt;span&gt;// 将队列执行的 index 重置&lt;/span&gt;&lt;br/&gt;    queue.length = &lt;span&gt;0&lt;/span&gt; &lt;span&gt;// 清空队列&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;循环遍历 queue，运行 Job，直到 queue 为空&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;queue 队列执行期间，可能会有新的 Job 入队，同样会被执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49935316946959896&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OibzJoI7k4IKL5awZDP0m9hsMSF4picBmWdVdRDONnbZDR8hVNtAu1hj0ylPINsrGAReJI2PHPH5hRRzwbAJPXnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1546&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;执行 Pre 队列&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;flushPreFlushCbs&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 有 Job 才执行&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (pendingPreFlushCbs.length) {&lt;br/&gt;    &lt;span&gt;// 执行前去重，并赋值到 activePreFlushCbs&lt;/span&gt;&lt;br/&gt;    activePreFlushCbs = [...new Set(pendingPreFlushCbs)]&lt;br/&gt;    &lt;span&gt;// pendingPreFlushCbs 清空&lt;/span&gt;&lt;br/&gt;    pendingPreFlushCbs.length = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 循环执行 Job&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;br/&gt;      preFlushIndex = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;      preFlushIndex &amp;lt; activePreFlushCbs.length;&lt;br/&gt;      preFlushIndex++&lt;br/&gt;    ) {&lt;br/&gt;      &lt;span&gt;// 开发模式下，校验无限递归的情况&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (&lt;br/&gt;        __DEV__ &amp;amp;&amp;amp;&lt;br/&gt;        checkRecursiveUpdates(seen!, activePreFlushCbs[preFlushIndex])&lt;br/&gt;      ) {&lt;br/&gt;        &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// 执行 Job&lt;/span&gt;&lt;br/&gt;      activePreFlushCbs[preFlushIndex]()&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 收尾工作&lt;/span&gt;&lt;br/&gt;    activePreFlushCbs = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    preFlushIndex = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;      &lt;br/&gt;    &lt;span&gt;// 可能递归，再次执行 flushPreFlushCbs，如果队列为空就停止&lt;/span&gt;&lt;br/&gt;    flushPreFlushCbs()&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Job 最开始是在 pending 队列中的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;flushPreFlushCbs 执行时，将 pending 队列中的 Job 去重，并改为 active 队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;循环执行 active 队列的 Job&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重复 flushPreFlushCbs，直到队列为空&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5246768507638073&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OibzJoI7k4IKL5awZDP0m9hsMSF4picBmWOnd7gZkSnSe3j8fNgICiawXbibFHRrKib49RzjIBgMK12ibm8nK2djShtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1702&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;执行 Post 队列&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;flushPostFlushCbs&lt;/span&gt;(&lt;span&gt;seen?: CountMap&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 队列为空则结束&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (pendingPostFlushCbs.length) {&lt;br/&gt;    &lt;span&gt;// 去重&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; deduped = [...new Set(pendingPostFlushCbs)]&lt;br/&gt;    pendingPostFlushCbs.length = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// #1947 already has active queue, nested flushPostFlushCbs call&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 特殊情况，发生了递归，在执行前 activePostFlushCbs 可能已经有值了，该情况可不必过多关注&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (activePostFlushCbs) {&lt;br/&gt;      activePostFlushCbs.push(...deduped)&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    activePostFlushCbs = deduped&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (__DEV__) {&lt;br/&gt;      seen = seen || &lt;span&gt;new&lt;/span&gt; Map()&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 优先级排序&lt;/span&gt;&lt;br/&gt;    activePostFlushCbs.sort(&lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; getId(a) - getId(b))&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 循环执行 Job&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;br/&gt;      postFlushIndex = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;      postFlushIndex &amp;lt; activePostFlushCbs.length;&lt;br/&gt;      postFlushIndex++&lt;br/&gt;    ) {&lt;br/&gt;      &lt;span&gt;// 在开发模式下，检查递归次数，最多 100 次递归&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (&lt;br/&gt;        __DEV__ &amp;amp;&amp;amp;&lt;br/&gt;        checkRecursiveUpdates(seen!, activePostFlushCbs[postFlushIndex])&lt;br/&gt;      ) {&lt;br/&gt;        &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// 执行 Job&lt;/span&gt;&lt;br/&gt;      activePostFlushCbs[postFlushIndex]()&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 收尾工作&lt;/span&gt;&lt;br/&gt;    activePostFlushCbs = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    postFlushIndex = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Job 最开始是在 pending 队列中的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;flushPostFlushCbs 执行时，将 pending 队列中的 Job 去重，然后跟 active 队列合并&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;循环执行 active 队列的 Job&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.555682467161622&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OibzJoI7k4IKL5awZDP0m9hsMSF4picBmWgKCJORfota72veKeQiaN22uAbLe8XsLsYeiahjXgM00Cuuw3TqQpOsDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1751&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为什么在队列最后没有像 Pre 队列那样，再次执行 flushPostFlushCbs？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Post 队列的 Job 执行时，可能会将 Job 继续加入到队列（Pre 队列，组件异步更新队列，Post 队列都可能）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新加入的 Job，会在下一轮 flushJob 中执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// postFlushCb 可能又会将 Job 加入进来，如果还有 Job，继续执行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (&lt;br/&gt;  queue.length ||&lt;br/&gt;  pendingPreFlushCbs.length ||&lt;br/&gt;  pendingPostFlushCbs.length&lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;// 执行下一轮队列任务&lt;/span&gt;&lt;br/&gt;  flushJobs()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>