<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>91e7a13707e627392261990e7be27daf</guid>
<title>资料 | ThoughtWorks 技术雷达第 23 期.pdf</title>
<link>https://toutiao.io/k/7mdyut5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7207b9ab5a64afbda98591815971f720</guid>
<title>[推荐] 图解常见的九种设计模式</title>
<link>https://toutiao.io/k/pjsjgsi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在软件工程中，设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。根据模式的目的来划分的话，GoF（Gang of Four）设计模式可以分为以下 3 种类型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYORsOE5icFY5emqIg38W1BFcLLHCtQy8reE1enw9uibroWMVxZlQUqw9g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.33055555555555555&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、创建型模式：用来描述 “如何创建对象”，它的主要特点是 “将对象的创建和使用分离”。包括单例、原型、工厂方法、抽象工厂和建造者 5 种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、结构型模式：用来描述如何将类或对象按照某种布局组成更大的结构。包括代理、适配器、桥接、装饰、外观、享元和组合 7 种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、行为型模式：用来识别对象之间的常用交流模式以及如何分配职责。包括模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录和解释器 11 种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来阿宝哥将结合一些生活中的场景并通过精美的配图，来向大家介绍 9 种常用的设计模式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一、建造者模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建造者模式（Builder Pattern）将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一辆小汽车 🚗 通常由 &lt;strong&gt;发动机、底盘、车身和电气设备&lt;/strong&gt; 四大部分组成。汽车电气设备的内部构造很复杂，简单起见，我们只考虑三个部分：引擎、底盘和车身。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYYVUo8Masic9yq0JzwWjiaUtXcd8csBBBK3ysEJXLVH6qoVZbnlElSC6w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.24814814814814815&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在现实生活中，小汽车也是由不同的零部件组装而成，比如上图中我们把小汽车分成引擎、底盘和车身三大部分。下面我们来看一下如何使用建造者模式来造车子。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Car {&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; engine: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; chassis: &lt;span&gt;string&lt;/span&gt;, &lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; body: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;  &lt;/span&gt;) {}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; CarBuilder {&lt;br/&gt;  engine!: &lt;span&gt;string&lt;/span&gt;; &lt;span&gt;// 引擎&lt;/span&gt;&lt;br/&gt;  chassis!: &lt;span&gt;string&lt;/span&gt;; &lt;span&gt;// 底盘&lt;/span&gt;&lt;br/&gt;  body!: &lt;span&gt;string&lt;/span&gt;; &lt;span&gt;// 车身&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  addChassis(chassis: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.chassis = chassis;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  addEngine(engine: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.engine = engine;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  addBody(body: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.body = body;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  build() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Car(&lt;span&gt;this&lt;/span&gt;.engine, &lt;span&gt;this&lt;/span&gt;.chassis, &lt;span&gt;this&lt;/span&gt;.body);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，我们定义一个 &lt;code&gt;CarBuilder&lt;/code&gt; 类，并提供了 &lt;code&gt;addChassis&lt;/code&gt;、&lt;code&gt;addEngine&lt;/code&gt; 和 &lt;code&gt;addBody&lt;/code&gt; 3 个方法用于组装车子的不同部位，当车子的 3 个部分都组装完成后，调用 &lt;code&gt;build&lt;/code&gt; 方法就可以开始造车。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; car = &lt;span&gt;new&lt;/span&gt; CarBuilder()&lt;br/&gt;  .addEngine(&lt;span&gt;&#x27;v12&#x27;&lt;/span&gt;)&lt;br/&gt;  .addBody(&lt;span&gt;&#x27;镁合金&#x27;&lt;/span&gt;)&lt;br/&gt;  .addChassis(&lt;span&gt;&#x27;复合材料&#x27;&lt;/span&gt;)&lt;br/&gt;  .build();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 应用场景及案例&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要生成的产品对象的属性相互依赖，需要指定其生成顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - node-sql-query：https://github.com/dresende/node-sql-query&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、工厂模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在现实生活中，工厂是负责生产产品的，比如牛奶、面包或礼物等，这些产品满足了我们日常的生理需求。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYYozbev3whOjKiciaF6TnbB1nHA5U8oT5pmPebv7XtWas0V0s8kXWQibcQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.35648148148148145&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在众多设计模式当中，有一种被称为工厂模式的设计模式，它提供了创建对象的最佳方式。工厂模式可以分为：&lt;strong&gt;简单工厂模式、工厂方法模式和抽象工厂模式&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 简单工厂&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单工厂模式又叫 &lt;strong&gt;静态方法模式&lt;/strong&gt;，因为工厂类中定义了一个静态方法用于创建对象。简单工厂让使用者不用知道具体的参数就可以创建出所需的 ”产品“ 类，即使用者可以直接消费产品而不需要知道产品的具体生产细节。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYUWltia1zbFdvpxcrGHC0CEjTT0iacxdXxW3AVicYb2J4TYCsTNsicR7SEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4861111111111111&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，阿宝哥模拟了用户购车的流程，小王和小秦分别向 BMW 工厂订购了 BMW730 和 BMW840 型号的车型，接着工厂会先判断用户选择的车型，然后按照对应的模型进行生产并在生产完成后交付给用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用简单工厂来描述 BMW 工厂生产指定型号车子的过程。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMW {&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; run(): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; BMW730 &lt;span&gt;extends&lt;/span&gt; BMW {&lt;br/&gt;  run(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;BMW730 发动咯&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; BMW840 &lt;span&gt;extends&lt;/span&gt; BMW {&lt;br/&gt;  run(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;BMW840 发动咯&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; BMWFactory {&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; produceBMW(model: &lt;span&gt;&quot;730&quot;&lt;/span&gt; | &lt;span&gt;&quot;840&quot;&lt;/span&gt;): BMW {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (model === &lt;span&gt;&quot;730&quot;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW730();&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW840();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，我们定义一个 &lt;code&gt;BMWFactory&lt;/code&gt; 类，该类提供了一个静态的 &lt;code&gt;produceBMW()&lt;/code&gt; 方法，用于根据不同的模型参数来创建不同型号的车子。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; bmw730 = BMWFactory.produceBMW(&lt;span&gt;&quot;730&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw840 = BMWFactory.produceBMW(&lt;span&gt;&quot;840&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;bmw730.run();&lt;br/&gt;bmw840.run();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;工厂类负责创建的对象比较少：由于创建的对象比较少，不会造成工厂方法中业务逻辑过于复杂。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端只需知道传入工厂类静态方法的参数，而不需要关心创建对象的细节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 工厂方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工厂方法模式（Factory Method Pattern）又称为工厂模式，也叫多态工厂（Polymorphic Factory）模式，它属于类创建型模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象， &lt;strong&gt;这样做的目的是将产品类的实例化操作延迟到工厂子类中完成&lt;/strong&gt;，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYKUYSgZ69oEMWbx3nEAUw2Weg0iacMyKMfyiaCjiciaFyU18qskQvchSicUQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4824074074074074&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，阿宝哥模拟了用户购车的流程，小王和小秦分别向 BMW 730 和 BMW 840 工厂订购了 BMW730 和 BMW840 型号的车子，接着工厂按照对应的模型进行生产并在生产完成后交付给用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，我们来看一下如何使用工厂方法来描述 BMW 工厂生产指定型号车子的过程。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMWFactory {&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; produceBMW(): BMW;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; BMW730Factory &lt;span&gt;extends&lt;/span&gt; BMWFactory {&lt;br/&gt;  produceBMW(): BMW {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW730();&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; BMW840Factory &lt;span&gt;extends&lt;/span&gt; BMWFactory {&lt;br/&gt;  produceBMW(): BMW {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW840();&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，我们分别创建了 &lt;code&gt;BMW730Factory&lt;/code&gt; 和 &lt;code&gt;BMW840Factory&lt;/code&gt; 两个工厂类，然后使用这两个类的实例来生产不同型号的车子。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; bmw730Factory = &lt;span&gt;new&lt;/span&gt; BMW730Factory();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw840Factory = &lt;span&gt;new&lt;/span&gt; BMW840Factory();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw730 = bmw730Factory.produceBMW();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw840 = bmw840Factory.produceBMW();&lt;br/&gt;&lt;br/&gt;bmw730.run();&lt;br/&gt;bmw840.run();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 抽象工厂&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。&lt;strong&gt;但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYH3bye09dUCBvakibGmEJd8XJKG22mqwlFGibnAtW3OzsN9YWGiaIGQiaew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4898148148148148&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，阿宝哥模拟了用户购车的流程，小王向 BMW 工厂订购了 BMW730，工厂按照 730 对应的模型进行生产并在生产完成后交付给小王。而小秦向同一个 BMW 工厂订购了 BMW840，工厂按照 840 对应的模型进行生产并在生产完成后交付给小秦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用抽象工厂来描述上述的购车过程。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMWFactory {&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; produce730BMW(): BMW730;&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; produce840BMW(): BMW840;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; ConcreteBMWFactory &lt;span&gt;extends&lt;/span&gt; BMWFactory {&lt;br/&gt;  produce730BMW(): BMW730 {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW730();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  produce840BMW(): BMW840 {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW840();&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; bmwFactory = &lt;span&gt;new&lt;/span&gt; ConcreteBMWFactory();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw730 = bmwFactory.produce730BMW();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw840 = bmwFactory.produce840BMW();&lt;br/&gt;&lt;br/&gt;bmw730.run();&lt;br/&gt;bmw840.run();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统中有多于一个的产品族，而每次只使用其中某一产品族。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、单例模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单例模式（Singleton Pattern）是一种常用的模式，有一些对象我们往往只需要一个，比如全局缓存、浏览器中的 window 对象等。单例模式用于保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYCwmXHgibyIcuia9UpgZTBEUL1HBdHfdfNayicOJRwbqRZYMOIMH8fK7TQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.39537037037037037&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，阿宝哥模拟了借车的流程，小王临时有急事找阿宝哥借车子，阿宝哥家的车子刚好没用，就借给小王了。当天，小秦也需要用车子，也找阿宝哥借车，因为阿宝哥家里只有一辆车子，所以就没有车可借了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于车子来说，它虽然给生活带来了很大的便利，但养车也需要一笔不小的费用（车位费、油费和保养费等），所以阿宝哥家里只有一辆车子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发软件系统时，如果遇到创建对象时耗时过多或耗资源过多，但又经常用到的对象，我们就可以考虑使用单例模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用 TypeScript 来实现单例模式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Singleton {&lt;br/&gt;  &lt;span&gt;// 定义私有的静态属性，来保存对象实例&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; singleton: Singleton;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;constructor&lt;/span&gt;(&lt;span/&gt;) {}&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 提供一个静态的方法来获取对象实例&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; getInstance(): Singleton {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!Singleton.singleton) {&lt;br/&gt;      Singleton.singleton = &lt;span&gt;new&lt;/span&gt; Singleton();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Singleton.singleton;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; instance1 = Singleton.getInstance();&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; instance2 = Singleton.getInstance();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(instance1 === instance2); &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要频繁实例化然后销毁的对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建对象时耗时过多或耗资源过多，但又经常用到的对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、适配器模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际生活中，也存在适配器的使用场景，比如：港式插头转换器、电源适配器和 USB 转接口。&lt;strong&gt;而在软件工程中，适配器模式的作用是解决两个软件实体间的接口不兼容的问题&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体就可以一起工作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicY87zR7joPTDTaflpOc37uVYctCgwjzVyPry3AVUW2ubVNUdp0X7ib0Ug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4527777777777778&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Logger {&lt;br/&gt;  info(message: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; CloudLogger {&lt;br/&gt;  sendToServer(message: &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; AliLogger &lt;span&gt;implements&lt;/span&gt; CloudLogger {&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; sendToServer(message: &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.info(message);&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.info(&lt;span&gt;&#x27;This Message was saved with AliLogger&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; CloudLoggerAdapter &lt;span&gt;implements&lt;/span&gt; Logger {&lt;br/&gt;  &lt;span&gt;protected&lt;/span&gt; cloudLogger: CloudLogger;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt; (&lt;span&gt;cloudLogger: CloudLogger&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.cloudLogger = cloudLogger;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; info(message: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.cloudLogger.sendToServer(message, &lt;span&gt;&#x27;info&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; NotificationService {&lt;br/&gt;  &lt;span&gt;protected&lt;/span&gt; logger: Logger;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt; (&lt;span&gt;logger: Logger&lt;/span&gt;) {    &lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.logger = logger;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; send(message: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.logger.info(&lt;span&gt;`Notification sended: &lt;span&gt;${message}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，因为 &lt;code&gt;Logger&lt;/code&gt; 和 &lt;code&gt;CloudLogger&lt;/code&gt; 这两个接口不匹配，所以我们引入了 &lt;code&gt;CloudLoggerAdapter&lt;/code&gt; 适配器来解决兼容性问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;(&lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; aliLogger = &lt;span&gt;new&lt;/span&gt; AliLogger();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; cloudLoggerAdapter = &lt;span&gt;new&lt;/span&gt; CloudLoggerAdapter(aliLogger);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; notificationService = &lt;span&gt;new&lt;/span&gt; NotificationService(cloudLoggerAdapter);&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; notificationService.send(&lt;span&gt;&#x27;Hello semlinker, To Cloud&#x27;&lt;/span&gt;);&lt;br/&gt;})();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 应用场景及案例&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - axios-mock-adapter：https://github.com/ctimmerm/axios-mock-adapter&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五、观察者模式 &amp;amp; 发布订阅模式&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 观察者模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;观察者模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在观察者模式中有两个主要角色：Subject（主题）和 Observer（观察者）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYicKmbjTUWZYRg7bzOP6ZPlhC8dAhEwia3pqtReHMnCZF6R3TTeWnJOkA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.531062124248497&quot; data-w=&quot;998&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，Subject（主题）就是阿宝哥的 TS 专题文章，而观察者就是小秦和小王。由于观察者模式支持简单的广播通信，当消息更新时，会自动通知所有的观察者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用 TypeScript 来实现观察者模式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Observer {&lt;br/&gt;  notify: &lt;span&gt;Function&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; ConcreteObserver &lt;span&gt;implements&lt;/span&gt; Observer{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;&lt;span&gt;private&lt;/span&gt; name: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {}&lt;br/&gt;&lt;br/&gt;  notify() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.name}&lt;/span&gt; has been notified.`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Subject { &lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; observers: Observer[] = [];&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; addObserver(observer: Observer): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(observer, &lt;span&gt;&quot;is pushed!&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.observers.push(observer);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; deleteObserver(observer: Observer): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;remove&quot;&lt;/span&gt;, observer);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; n: &lt;span&gt;number&lt;/span&gt; = &lt;span&gt;this&lt;/span&gt;.observers.indexOf(observer);&lt;br/&gt;    n != &lt;span&gt;-1&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.observers.splice(n, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; notifyObservers(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;notify all the observers&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.observers);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.observers.forEach(&lt;span&gt;&lt;span&gt;observer&lt;/span&gt; =&amp;gt;&lt;/span&gt; observer.notify());&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; subject: Subject = &lt;span&gt;new&lt;/span&gt; Subject();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; xiaoQin = &lt;span&gt;new&lt;/span&gt; ConcreteObserver(&lt;span&gt;&quot;小秦&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; xiaoWang = &lt;span&gt;new&lt;/span&gt; ConcreteObserver(&lt;span&gt;&quot;小王&quot;&lt;/span&gt;);&lt;br/&gt;subject.addObserver(xiaoQin);&lt;br/&gt;subject.addObserver(xiaoWang);&lt;br/&gt;subject.notifyObservers();&lt;br/&gt;&lt;br/&gt;subject.deleteObserver(xiaoQin);&lt;br/&gt;subject.notifyObservers();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1.3 应用场景及案例&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个对象的行为依赖于另一个对象的状态。或者换一种说法，当被观察对象（目标对象）的状态发生改变时 ，会直接影响到观察对象的行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RxJS Subject：https://github.com/ReactiveX/rxjs/blob/master/src/internal/Subject.ts&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RxJS Subject 文档：https://rxjs.dev/guide/subject&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 发布订阅模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在软件架构中，发布/订阅是一种消息范式，&lt;strong&gt;消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，然后分别发送给不同的订阅者。&lt;/strong&gt; 同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在发布订阅模式中有三个主要角色：Publisher（发布者）、 Channels（通道）和 Subscriber（订阅者）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYsZibrw2DBibCXudiabAmSCg3nNZectclZZCib795MH2z8lt14YMKsKtuFQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.40185185185185185&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，Publisher（发布者）是阿宝哥，Channels（通道）中 Topic A 和 Topic B 分别对应于 TS 专题和 Deno 专题，而 Subscriber（订阅者）就是小秦、小王和小池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用 TypeScript 来实现发布订阅模式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; EventHandler = &lt;span&gt;(&lt;span&gt;...args: &lt;span&gt;any&lt;/span&gt;[]&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; EventEmitter {&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; c = &lt;span&gt;new&lt;/span&gt; Map&amp;lt;&lt;span&gt;string&lt;/span&gt;, EventHandler[]&amp;gt;();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 订阅指定的主题&lt;/span&gt;&lt;br/&gt;  subscribe(topic: &lt;span&gt;string&lt;/span&gt;, ...handlers: EventHandler[]) {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; topics = &lt;span&gt;this&lt;/span&gt;.c.get(topic);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!topics) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.c.set(topic, topics = []);&lt;br/&gt;    }&lt;br/&gt;    topics.push(...handlers);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 取消订阅指定的主题&lt;/span&gt;&lt;br/&gt;  unsubscribe(topic: &lt;span&gt;string&lt;/span&gt;, handler?: EventHandler): &lt;span&gt;boolean&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!handler) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.c.delete(topic);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; topics = &lt;span&gt;this&lt;/span&gt;.c.get(topic);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!topics) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; index = topics.indexOf(handler);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (index &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    topics.splice(index, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (topics.length === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.c.delete(topic);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 为指定的主题发布消息&lt;/span&gt;&lt;br/&gt;  publish(topic: &lt;span&gt;string&lt;/span&gt;, ...args: &lt;span&gt;any&lt;/span&gt;[]): &lt;span&gt;any&lt;/span&gt;[] | &lt;span&gt;null&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; topics = &lt;span&gt;this&lt;/span&gt;.c.get(topic);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!topics) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; topics.map(&lt;span&gt;&lt;span&gt;handler&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; handler(...args);&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (e) {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.error(e);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; eventEmitter = &lt;span&gt;new&lt;/span&gt; EventEmitter();&lt;br/&gt;eventEmitter.subscribe(&lt;span&gt;&quot;ts&quot;&lt;/span&gt;, &lt;span&gt;(&lt;span&gt;msg&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`收到订阅的消息：&lt;span&gt;${msg}&lt;/span&gt;`&lt;/span&gt;) );&lt;br/&gt;&lt;br/&gt;eventEmitter.publish(&lt;span&gt;&quot;ts&quot;&lt;/span&gt;, &lt;span&gt;&quot;TypeScript发布订阅模式&quot;&lt;/span&gt;);&lt;br/&gt;eventEmitter.unsubscribe(&lt;span&gt;&quot;ts&quot;&lt;/span&gt;);&lt;br/&gt;eventEmitter.publish(&lt;span&gt;&quot;ts&quot;&lt;/span&gt;, &lt;span&gt;&quot;TypeScript发布订阅模式&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;作为事件总线，来实现不同组件间或模块间的通信。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BetterScroll - EventEmitter：https://github.com/ustbhuangyi/better-scroll/blob/dev/packages/shared-utils/src/events.ts&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247486413&amp;amp;idx=1&amp;amp;sn=f9a2d3a0f7f89817ce0f5abb4a2698ed&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;EventEmitter 在插件化架构的应用&lt;/a&gt;：https://mp.weixin.qq.com/s/N4iw3bi0bxJ57J8EAp5ctQ&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;六、策略模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;策略模式（Strategy Pattern）定义了一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活、可维护、可扩展。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYJbJ6yQpSoG7PMzibnyoAia1NvIeWVVIauojkxNu9o2Qa7GN0T2nmliaHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.512962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前在一些主流的 Web 站点中，都提供了多种不同的登录方式。比如账号密码登录、手机验证码登录和第三方登录。为了方便维护不同的登录方式，我们可以把不同的登录方式封装成不同的登录策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用策略模式来封装不同的登录方式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好地理解以下代码，我们先来看一下对应的 UML 类图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYl5SX5hwrg3Tj5LPGQwh4eVsNKuEcXo8MX1mbgUPcAq5C8PNIxm3KMg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.38981481481481484&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Strategy {&lt;br/&gt;  authenticate(...args: &lt;span&gt;any&lt;/span&gt;): &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Authenticator {&lt;br/&gt;  strategy: &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span/&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.strategy = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  setStrategy(strategy: &lt;span&gt;any&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.strategy = strategy;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  authenticate(...args: &lt;span&gt;any&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.strategy) {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;尚未设置认证策略&#x27;&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.strategy.authenticate(...args);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; WechatStrategy &lt;span&gt;implements&lt;/span&gt; Strategy {&lt;br/&gt;  authenticate(wechatToken: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (wechatToken !== &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;无效的微信用户&#x27;&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;微信认证成功&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; LocalStrategy &lt;span&gt;implements&lt;/span&gt; Strategy {&lt;br/&gt;  authenticate(username: &lt;span&gt;string&lt;/span&gt;, password: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (username !== &lt;span&gt;&#x27;abao&#x27;&lt;/span&gt; &amp;amp;&amp;amp; password !== &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;账号或密码错误&#x27;&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;账号和密码认证成功&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; auth = &lt;span&gt;new&lt;/span&gt; Authenticator();&lt;br/&gt;&lt;br/&gt;auth.setStrategy(&lt;span&gt;new&lt;/span&gt; WechatStrategy());&lt;br/&gt;auth.authenticate(&lt;span&gt;&#x27;123456&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;auth.setStrategy(&lt;span&gt;new&lt;/span&gt; LocalStrategy());&lt;br/&gt;auth.authenticate(&lt;span&gt;&#x27;abao&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3 应用场景及案例&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - passport-local：https://github.com/jaredhanson/passport-local&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - passport-oauth2：https://github.com/jaredhanson/passport-oauth2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - zod：https://github.com/vriad/zod/blob/master/src/types/string.ts&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;七、职责链模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;职责链模式是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYK5Ro2JicfYmoq4dRHeibldSgicBR1tfHmmjf1GFX43B3Ijn8jHv855dWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4305555555555556&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在公司中不同的岗位拥有不同的职责与权限。以上述的请假流程为例，当阿宝哥请 1 天假时，只要组长审批就可以了，不需要流转到主管和总监。如果职责链上的某个环节无法处理当前的请求，若含有下个环节，则会把请求转交给下个环节来处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日常的软件开发过程中，对于职责链来说，一种常见的应用场景是中间件，下面我们来看一下如何利用职责链来处理请求。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好地理解以下代码，我们先来看一下对应的 UML 类图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYz2cnpExp89LOgLVLq0HgyDqUSFqVXgiaAKs5VX0vicYnd1CC4Sq51ulg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.5805555555555556&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; IHandler {&lt;br/&gt;  addMiddleware(h: IHandler): IHandler;&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(url: &lt;span&gt;string&lt;/span&gt;, callback: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractHandler &lt;span&gt;implements&lt;/span&gt; IHandler {&lt;br/&gt;  next!: IHandler;&lt;br/&gt;  addMiddleware(h: IHandler) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.next = h;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.next;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(url: &lt;span&gt;string&lt;/span&gt;, callback: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.next) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.next.get(url, callback);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 定义Auth中间件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Auth &lt;span&gt;extends&lt;/span&gt; AbstractHandler {&lt;br/&gt;  isAuthenticated: &lt;span&gt;boolean&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;username: &lt;span&gt;string&lt;/span&gt;, password: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.isAuthenticated = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (username === &lt;span&gt;&#x27;abao&#x27;&lt;/span&gt; &amp;amp;&amp;amp; password === &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.isAuthenticated = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(url: &lt;span&gt;string&lt;/span&gt;, callback: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.isAuthenticated) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.get(url, callback);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;Not Authorized&#x27;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 定义Logger中间件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Logger &lt;span&gt;extends&lt;/span&gt; AbstractHandler {&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(url: &lt;span&gt;string&lt;/span&gt;, callback: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;/GET Request to: &#x27;&lt;/span&gt;, url);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.get(url, callback);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Route &lt;span&gt;extends&lt;/span&gt; AbstractHandler {&lt;br/&gt;  URLMaps: {[key: &lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;any&lt;/span&gt;};&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span/&gt;) {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.URLMaps = {&lt;br/&gt;      &lt;span&gt;&#x27;/api/todos&#x27;&lt;/span&gt;: [{ title: &lt;span&gt;&#x27;learn ts&#x27;&lt;/span&gt; }, { title: &lt;span&gt;&#x27;learn react&#x27;&lt;/span&gt; }],&lt;br/&gt;      &lt;span&gt;&#x27;/api/random&#x27;&lt;/span&gt;: &lt;span&gt;Math&lt;/span&gt;.random(),&lt;br/&gt;    };&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(url: &lt;span&gt;string&lt;/span&gt;, callback: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;.get(url, callback);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.URLMaps.hasOwnProperty(url)) {&lt;br/&gt;      callback(&lt;span&gt;this&lt;/span&gt;.URLMaps[url]);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; route = &lt;span&gt;new&lt;/span&gt; Route();&lt;br/&gt;route.addMiddleware(&lt;span&gt;new&lt;/span&gt; Auth(&lt;span&gt;&#x27;abao&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;)).addMiddleware(&lt;span&gt;new&lt;/span&gt; Logger());&lt;br/&gt;&lt;br/&gt;route.get(&lt;span&gt;&#x27;/api/todos&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;JSON&lt;/span&gt;.stringify({ data }, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;route.get(&lt;span&gt;&#x27;/api/random&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(data);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可处理一个请求的对象集合应被动态指定。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有多个对象可以处理一个请求，哪个对象处理该请求运行时自动确定，客户端只需要把请求提交到链上即可。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;八、模板方法模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模板方法模式由两部分结构组成：抽象父类和具体的实现子类。&lt;strong&gt;通常在抽象父类中封装了子类的算法框架，也包括实现一些公共方法以及封装子类中所有方法的执行顺序&lt;/strong&gt;。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYNOdjfUEPciaNfMYZpJCCXRHjOoPAAC7wc8qLibIKIyWzcbUshQyW6QuQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.34629629629629627&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，阿宝哥通过使用不同的解析器来分别解析 CSV 和 Markup 文件。虽然解析的是不同的类型的文件，但文件的处理流程是一样的。这里主要包含读取文件、解析文件和打印数据三个步骤。针对这个场景，我们就可以引入模板方法来封装以上三个步骤的处理顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用模板方法来实现上述的解析流程。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好地理解以下代码，我们先来看一下对应的 UML 类图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYLXjUAXclQXQ508iabWJhUgAfSR8aD4icKD2JbRjSK0klfVXnowCP1UsA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.524&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; fs &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;fs&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DataParser {&lt;br/&gt;  data: &lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;  out: &lt;span&gt;any&lt;/span&gt; = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 这就是所谓的模板方法&lt;/span&gt;&lt;br/&gt;  parse(pathUrl: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.readFile(pathUrl);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.doParsing();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.printData();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  readFile(pathUrl: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.data = fs.readFileSync(pathUrl, &lt;span&gt;&#x27;utf8&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; doParsing(): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;  &lt;br/&gt;  printData() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;this&lt;/span&gt;.out);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; CSVParser &lt;span&gt;extends&lt;/span&gt; DataParser {&lt;br/&gt;  doParsing() {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.out = &lt;span&gt;this&lt;/span&gt;.data.split(&lt;span&gt;&#x27;,&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; MarkupParser &lt;span&gt;extends&lt;/span&gt; DataParser {&lt;br/&gt;  doParsing() {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.out = &lt;span&gt;this&lt;/span&gt;.data.match(&lt;span&gt;/&amp;lt;\w+&amp;gt;.*&amp;lt;\/\w+&amp;gt;/gim&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; csvPath = &lt;span&gt;&#x27;./data.csv&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; mdPath = &lt;span&gt;&#x27;./design-pattern.md&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; CSVParser().parse(csvPath);&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; MarkupParser().parse(mdPath);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;九、参考资源&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;维基百科 - 设计模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java设计模式：23种设计模式全面解析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Design Patterns Everyday&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d073a2764d4084b6a06c7240b0a44f59</guid>
<title>[推荐] 《我想进大厂》之 JVM 夺命连环 10 问</title>
<link>https://toutiao.io/k/swi8lo6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;作者： 科技缪缪（本文来自作者投稿）&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 说说 JVM 的内存布局？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlaX1kzmfeFkqNiaDiar0WVkM9WqfBbh6BW3EmEgTCVCW4XbhYQGBzhSXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java 虚拟机主要包含几个区域：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;堆&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：堆是 Java 虚拟机中最大的一块内存，是线程共享的内存区域，基本上所有的对象实例数组都是在堆上分配空间。堆区细分为 Young&lt;/span&gt;&lt;span&gt; 区年轻代和 Old 区老年代，其中年轻代又分为 Eden、S0、S1 3个部分，他们默认的比例是 8:1:1 的大小。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;栈&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：栈是线程私有的内存区域，每个方法执行的时候都会在栈创建一个栈帧，方法的调用过程就对应着栈的入栈和出栈的过程。每个栈帧的结构又包含局部变量表、操作数栈、动态连接、方法返回地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;局部变量表用于存储方法参数和局部变量。当第一个方法被调用的时候，它的参数会被传递至从0开始的连续的局部变量表中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;操作数栈用于一些字节码指令从局部变量表中传递至操作数栈，也用来准备方法调用的参数以及接收方法返回结果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;动态连接用于将符号引用表示的方法转换为实际方法的直接引用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;元数据&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在 Java1.7 之前，包含方法区的概念，常量池就存在于方法区（永久代）中，而方法区本身是一个逻辑上的概念，在1.7之后则是把常量池移到了堆内，1.8之后移出了永久代的概念(方法区的概念仍然保留)，实现方式则是现在的元数据。它包含类的元信息和运行时常量池。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;class 文件就是类和接口的定义信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;运行时常量池就是类和接口的常量池运行时的表现形式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;本地方法栈&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要用于执行本地 native 方法的区域。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;程序计数器&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：也是线程私有的区域，用于记录当前线程下虚拟机正在执行的字节码的指令地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 知道 new 一个对象的过程吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.40390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlOvda0KYHkCicWv9Libm8FpZgRKScK30oQxYPNIOsfMgjEvMmq8Isb6Rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当虚拟机遇见 &lt;strong&gt;new &lt;/strong&gt;关键字时候，实现判断当前类是否已经加载。如果类没有加载，首先执行类的加载机制，加载完成后再为对象分配空间、初始化等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先&lt;strong&gt;校验当前类是否被加载&lt;/strong&gt;，如果没有加载，执行类加载机制；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;加载&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：就是从字节码加载成二进制流的过程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;验证&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：当然加载完成之后，当然需要校验 class 文件是否符合虚拟机规范，跟我们接口请求一样，第一件事情当然是先做个参数校验了；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;准备&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为静态变量、常量赋默认值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;解析&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：把常量池中符号引用(以符号描述引用的目标)替换为直接引用(指向目标的指针或者句柄等)的过程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始化&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：执行 static 代码块 (cinit) 进行初始化，如果存在父类，先对父类进行初始化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：静态代码块是绝对线程安全的，只能隐式被 Java 虚拟机在类加载过程中初始化调用！(此处该有问题：&lt;strong&gt;static 代码块线程安全吗？&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当类加载完成之后，紧接着就是对象分配内存空间和初始化的过程：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先为对象分配合适大小的内存空间；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接着为实例变量赋默认值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设置对象的头信息，对象 hashcode、GC 分代年龄、元数据信息等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;执行构造函数 (init) 初始化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 知道双亲委派模型吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类加载器自顶向下分为：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Bootstrap ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（启动类加载器）：默认会去加载 JAVA_HOME/lib 目录下的 jar；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Extention ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（扩展类加载器）：默认去加载 JAVA_HOME/lib/ext 目录下的 jar；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Application ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（应用程序类加载器）：比如我们的 Web 应用，会加载 Web 程序中 ClassPath 下的类；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;User ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（用户自定义类加载器）：由用户自己定义。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当我们在加载类的时候，首先都会向上询问自己的父加载器是否已经加载。如果没有则依次向上询问；如果没有加载，则从上到下依次尝试是否能加载当前类，直到加载成功。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.64609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlZKccYiccqpOGYdIUwltUNPmmyib6Gz2W6IWH6FCIIxojeQpyjXpw6T5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4. 说说有哪些垃圾回收算法？&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;标记-清除&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;统一标记出需要回收的对象，标记完成之后统一回收所有被标记的对象。而由于标记的过程需要遍历所有的 GC ROOT，清除的过程也要遍历堆中所有的对象，所以标记-清除算法的效率低下，同时也带来了内存碎片的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;复制算法&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决性能的问题，复制算法应运而生。它将内存分为大小相等的两块区域，每次使用其中的一块。当一块内存使用完之后，将还存活的对象拷贝到另外一块内存区域中，然后把当前内存清空。这样性能和内存碎片的问题得以解决。但是同时带来了另外一个问题，可使用的内存空间缩小了一半！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，诞生了我们现在的常见的&lt;strong&gt;年轻代+老年代&lt;/strong&gt;的内存结构：Eden+S0+S1 组成。因为根据 IBM 的研究显示，98%的对象都是朝生夕死，所以实际上存活的对象并不是很多，完全不需要用到一半内存浪费，所以默认的比例是 8:1:1。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样，在使用的时候只使用 Eden 区和 S0、S1 中的一个，每次都把存活的对象拷贝另外一个未使用的 Survivor 区，同时清空 Eden 和使用的 Survivor，这样下来内存的浪费就只有10%了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果最后未使用的 Survivor 放不下存活的对象，这些对象就进入 Old 老年代了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：所以有一些初级点的问题会问你，为什么要分为 Eden 区和2个 Survior 区？有什么作用？就是为了节省内存和解决内存碎片的问题。这些算法都是为了解决问题而产生的，如果理解原因你就不需要死记硬背了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;标记-整理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对老年代再用复制算法显然不合适，因为进入老年代的对象都存活率比较高了，这时候再频繁的复制对性能影响就比较大，而且也不会再有另外的空间进行兜底。所以针对老年代的特点，通过&lt;strong&gt;标记-整理&lt;/strong&gt;算法，标记出所有的存活对象，让所有存活的对象都向一端移动，然后清理掉边界以外的内存空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5. 什么是 GC ROOT？有哪些 GC ROOT？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面提到的标记的算法，怎么标记一个对象是否存活？简单的通过引用计数法，给对象设置一个引用计数器，每当有一个地方引用他，就给计数器+1，反之则计数器-1，但是这个简单的算法&lt;strong&gt;无法解决循环引用的问题&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java 通过可达性分析算法来达到标记存活对象的目的，定义一系列的 GC ROOT 为起点。从起点开始向下开始搜索，搜索走过的路径称为引用链。当一个对象到 GC ROOT没有任何引用链相连的话，则对象可以判定是可以被回收的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而可以作为 GC ROOT 的对象包括：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;栈中引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;静态变量、常量引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;本地方法栈 native 方法引用的对象。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;6. 垃圾回收器了解吗？年轻代和老年代都有哪些垃圾回收器？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.41953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlS2swjribk4EibNmDPwGf1o5gqeRbkSdEKic67pibPqMEDGPf857pP2G1YA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;年轻代的垃圾收集器包含有 Serial、ParNew、Parallell。老年代则包括 Serial Old 老年代版本、CMS、Parallel Old 老年代版本和 JDK11 中全新的 G1 收集器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Serial&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：单线程版本收集器，进行垃圾回收的时候会 STW（Stop The World），也就是进行垃圾回收的时候其他的工作线程都必须暂停。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;ParNew&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Serial 的多线程版本，用于和 CMS 配合使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Parallel Scavenge&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：可以并行收集的多线程垃圾收集器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Serial Old&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Serial 的老年代版本，也是单线程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Parallel Old&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Parallel Scavenge 的老年代版本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;CMS（Concurrent Mark Sweep）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：CMS 收集器是以获取最短停顿时间为目标的收集器。相对于其他的收集器 STW 的时间更短暂，可以并行收集是它的特点，同时它基于&lt;strong&gt;标记-清除&lt;/strong&gt;算法。整个 GC 过程分为4步：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：标记 GC ROOT 能关联到的对象，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：从 GCRoots 的直接关联对象开始遍历整个对象图的过程，不需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;重新标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为了修正并发标记期间，因用户程序继续运作而导致标记产生改变的标记，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发清除&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：清理删除掉标记阶段判断的已经死亡的对象，不需要 STW。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从整个过程来看，并发标记和并发清除的耗时最长，但是不需要停止用户线程。而初始标记和重新标记的耗时较短，但是需要停止用户线程。总体而言，整个过程造成的停顿时间较短，大部分时候是可以和用户线程一起工作的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;G1（Garbage First）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：G1 收集器是 JDK9 的默认垃圾收集器，不再区分年轻代和老年代进行回收。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;7. G1的原理了解吗？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.54453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlclwUSgRl1TKmdLvuBoicahRpa48GWyMADXRrVQhAiaryF7LPkLCC1TeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G1 作为 JDK9 之后的服务端默认收集器，不再区分年轻代和老年代进行垃圾回收。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;把内存划分为多个 Region，每个 Region 的大小可以通过 &lt;strong&gt;-XX：G1HeapRegionSize&lt;/strong&gt; 设置，大小为1~32M。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于大对象的存储则衍生出 &lt;strong&gt;Humongous &lt;/strong&gt;的概念。超过 Region 大小一半的对象会被认为是大对象，而超过整个 Region 大小的对象被认为是超级大对象，将会被存储在连续的 N 个 Humongous Region 中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G1 在进行回收的时候会在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先回收收益最大的 Region。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G1 的回收过程分为以下四个步骤：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：标记 GC ROOT 能关联到的对象，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：从 GCRoots 的直接关联对象开始遍历整个对象图的过程，扫描完成后还会重新处理并发标记过程中产生变动的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最终标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：短暂暂停用户线程，再处理一次，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;筛选回收&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：更新 Region 的统计数据，对每个 Region 的回收价值和成本排序，根据用户设置的停顿时间制定回收计划。再把需要回收的 Region 中存活对象复制到空的 Region，同时清理旧的 Region。需要 STW。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总的来说除了并发标记之外，其他几个过程也还是需要短暂的 STW。G1 的目标是在停顿和延迟可控的情况下尽可能提高吞吐量。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;8. 什么时候会触发 YGC 和 FGC？对象什么时候会进入老年代？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当一个新的对象来申请内存空间的时候，如果 Eden 区无法满足内存分配需求，则触发 YGC。使用中的 Survivor 区和 Eden 区存活对象送到未使用的 Survivor 区。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果 YGC 之后还是没有足够空间，则直接进入老年代分配。如果老年代也无法分配空间，触发 FGC，FGC 之后还是放不下则报出 OOM 异常。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.03125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlDlicFGn9Z2ic9ABVnrxWE9qzl4p4QOrbWyeZ1nEYqxGibianVicET1BqnLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;YGC 之后，存活的对象将会被复制到未使用的 Survivor 区。如果 S 区放不下，则直接晋升至老年代。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而对于那些一直在 Survivor 区来回复制的对象，通过 &lt;strong&gt;-XX：MaxTenuringThreshold&lt;/strong&gt; 配置交换阈值，默认15次。如果超过次数同样进入老年代。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，还有一种动态年龄的判断机制，不需要等到 MaxTenuringThreshold 就能晋升老年代。如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;9. 频繁 FullGC 怎么排查？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种问题最好的办法就是结合有具体的例子举例分析，如果没有就说一般的分析步骤。发生 FGC 有可能是内存分配不合理，比如 Eden 区太小，导致对象频繁进入老年代，这时候通过启动参数配置就能看出来，另外有可能就是存在内存泄露，可以通过以下的步骤进行排查：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1. &lt;strong&gt;jstat -gcutil&lt;/strong&gt; 或者查看 gc.log 日志，查看内存回收情况。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.35078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlNzhFQZlnLpOEIWkoPIgE4pPQYFcZ8OVdAu4ibOBtawqVJOaLficd7icXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;S0、S1 分别代表两个 Survivor 区占比；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;E 代表 Eden 区占比，图中可以看到使用了78%；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;O 代表老年代，M 代表元空间，YGC 发生54次，YGCT 代表 YGC 累计耗时，GCT 代表 GC 累计耗时。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.196875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSllkLHHPvwzafVdDDsvk6lPxdJPUQ5M2uV0Cch5HD8LfnjWrjBGPJj0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[GC&lt;/span&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;span&gt;[FGC&lt;/span&gt;&lt;span&gt; 开头代表垃圾回收的类型；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;PSYoungGen: 6130K-&amp;gt;6130K(9216K)] 12274K-&amp;gt;14330K(19456K), 0.0034895 secs&lt;/span&gt;&lt;span&gt; 代表 YGC 前后内存使用情况；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Times: user=0.02 sys=0.00, real=0.00 secs&lt;/span&gt;&lt;span&gt;：user 表示用户态消耗的 CPU 时间，sys 表示内核态消耗的 CPU 时间，real 表示各种墙时钟的等待时间；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这两张图只是举例并没有关联关系。比如你从图里面看能到是否进行 FGC、FGC 的时间花费多长；GC 后老年代，年轻代内存是否有减少；得到一些初步的情况来做出判断。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. dump 出内存文件在具体分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如通过 jmap 命令 &lt;strong&gt;jmap -dump:format=b,file=dumpfile pid&lt;/strong&gt;。&lt;/span&gt;&lt;span&gt;导出之后再&lt;/span&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;span&gt;Eclipse Memory Analyze&lt;/span&gt;&lt;span&gt;r &lt;/span&gt;&lt;span&gt;等工具进行分析，定位到代码、&lt;/span&gt;&lt;span&gt;修复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里还会可能存在一个提问的点，比如 &lt;strong&gt;CPU 飙高，同时 FGC 怎么办&lt;/strong&gt;？办法比较类似：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;找到当前进程的 pid，&lt;strong&gt;top -p pid -H&lt;/strong&gt; 查看资源占用，找到问题线程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;printf “%x\n” pid&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，把线程 pid 转为16进制，比如 0x32d；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;jstack pid|grep -A 10 0x32d &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;查看线程的堆栈日志，还找不到问题继续下一步；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;dump 出内存文件用 MAT 等工具进行分析，定位到代码、修复。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;10. JVM调优有什么经验吗？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要明白一点，所有的调优的目的都是为了用更小的硬件成本达到更高的吞吐，JVM 的调优也是一样。通过对垃圾收集器和内存分配的调优达到性能的最佳。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;简单的参数含义&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，需要知道几个主要的参数含义。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlLWMnkcBxCTMcdsOu97iaiaSbOv87f3heq6PbIWTnZOtQIaEy96HZxj8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-Xms&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 设置初始堆的大小，&lt;strong&gt;-Xmx &lt;/strong&gt;设置最大堆的大小；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:NewSize&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 年轻代大小，&lt;strong&gt;-XX:MaxNewSize&lt;/strong&gt; 年轻代最大值，&lt;strong&gt;-Xmn&lt;/strong&gt; 则是相当于同时配置 -XX:NewSize 和 -XX:MaxNewSize 为一样的值；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:NewRatio&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 设置年轻代和年老代的比值。如果为3，表示年轻代与老年代比值为 1:3，默认值为2；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:SurvivorRatio&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 年轻代和两个 Survivor 的比值。默认值为8，代表比值为 8:1:1；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:PretenureSizeThreshold&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 当创建的对象超过指定大小时，直接把对象分配在老年代；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:MaxTenuringThreshold&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 设定对象在 Survivor 复制的最大年龄阈值，超过阈值转移到老年代；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:MaxDirectMemorySize&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 当 Direct ByteBuffer 分配的堆外内存到达指定大小后，即触发 Full GC。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;调优&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;为了打印日志方便排查问题最好开启GC日志。开启GC日志对性能影响微乎其微，但是能帮助我们快速排查定位问题。&lt;strong&gt;-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:gc.log&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一般设置 &lt;strong&gt;-Xms=-Xmx&lt;/strong&gt;。这样可以获得固定大小的堆内存，减少 GC 次数和耗时，可以使得堆相对稳定；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 让 JVM 在发生内存溢出的时候自动生成内存快照，方便排查问题；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;-Xmn&lt;/strong&gt; 设置新生代的大小。太小会增加 YGC，太大会减小老年代大小，一般设置为&lt;strong&gt;整个堆的1/4到1/3&lt;/strong&gt;；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;设置 &lt;strong&gt;-XX:+DisableExplicitGC &lt;/strong&gt;禁止系统 System.gc()。防止手动误触发 FGC 造成问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651482823&amp;amp;idx=1&amp;amp;sn=cd623fbfa900f1217b34d34f980b2e82&amp;amp;chksm=bd2506b88a528faea643840bb2613ae67252085c24faaba2359006cc37335dc4fe042f1ca66d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;关于 JVM 内存的 N 个问题&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651488039&amp;amp;idx=1&amp;amp;sn=b812f2bd8b3e0e7edfdb2bb6c050894e&amp;amp;chksm=bd2513588a529a4e02c41f59fa78adc2c064b48b112a5120d53687b8ee84aff87524acecb479&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;JVM 史上最最最完整深入解析&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651486318&amp;amp;idx=1&amp;amp;sn=a0bf7b6896cc30cff1581243193200fc&amp;amp;chksm=bd2514118a529d0769979c50eaac2c8b5fef25cb8fdf550d9e24534d211700d0bd6befae2b64&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Spring Boot项目优化和JVM调优&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好文章，我&lt;/span&gt;&lt;span&gt;在看&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d5a87b0043a2faec24f11385810b6d6d</guid>
<title>[推荐] 技术选型：为什么批处理我们却选择了 Flink</title>
<link>https://toutiao.io/k/0n78gha</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;最近接手了一个改造多平台日志服务的需求，经过梳理，我认为之前服务在设计上存在缺陷。经过一段时间的技术方案调研，最终我们决定选择使用 Flink 重构该服务。&lt;/p&gt;&lt;p&gt;目前重构后的服务已成功经受了国庆节流量洪峰的考验，今日特来总结回顾，和大家分享一下经验。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;业务需求及背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在了解改造服务的需求前，我们首先要明确，要解决什么问题以及目前的服务是如何解决的。&lt;/p&gt;&lt;p&gt;当前的业务逻辑还是比较清晰的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;采集同一时段不同数据源的日志；&lt;/li&gt;&lt;li&gt;对采集的数据进行处理；&lt;/li&gt;&lt;li&gt;将处理后的数据上传到指定位置，供客户下载。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们面临的痛点和难点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;日志的数据量比较大：每小时未压缩的日志数据量有 50 多个 G，节假日等特殊时间节点，日志量会翻倍。&lt;/li&gt;&lt;li&gt;目前服务使用单机进行处理，速度比较慢，扩容不方便。&lt;/li&gt;&lt;li&gt;目前服务处理数据时需要清洗字段，按时间排序，统计某字段的频率等步骤。这些步骤都属于 ETL 中的常规操作，但是目前是以代码的形式实现的，我们想以配置形式减少重复编码，尽量更加简单、通用。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;方案1：我们需要一个数据库吗?&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;针对以上业务需求，有同学提出：“我们可以把所有原始数据放到数据库中，后续的 ETL 可以通过 SQL 实现。”&lt;/p&gt;&lt;p&gt;如果你一听到&quot;数据库&quot;想到的就是 Pg、Mysql、Oracle 等，觉得这个方案不具有可行性，那你就错了。数据库的类型和维度是非常丰富的，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2046f993e1c0a87adb39d2d697e87749_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;811&quot; data-rawheight=&quot;618&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-2046f993e1c0a87adb39d2d697e87749_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;811&quot; data-rawheight=&quot;618&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-2046f993e1c0a87adb39d2d697e87749_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2046f993e1c0a87adb39d2d697e87749_b.jpg&quot;/&gt;&lt;figcaption&gt;△数据库行业全景图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;按业务负载特征，关系型数据库可分为 OLTP 数据库（交易型）和 OLAP 数据库（分析型) ：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;OLTP，Online Transaction Processing。OLTP 数据库最大的特点是支持事务，增删查改等功能强大，适合需要被频繁修改的&quot;热数据&quot;。我们耳熟能详的 Mysql、Pg 等都属于这一类。缺点就是由于支持事务，插入时比较慢。拿来实现我们的需求显然是不合适的。&lt;/li&gt;&lt;li&gt;OLAP，Online Analytical Processing，数据分析为主。不支持事务，或者说是对事务的支持有限。OLAP 的场景是：大多数是读请求，数据总是以相当大的批(&amp;gt; 1000 rows)进行写入，不修改已添加的数据。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;方案 1 小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;OLAP 的使用场景符合我们的需求，为此我们还专门去调研了一下 ClickHouse。但是有一个因素让我们最终放弃了使用 OLAP。请注意，数据库存储的数据都是二维的，有行和列两个维度。但是日志只有行一个维度。如果说为了把日志存入数据库把每行日志都切分，那统计字段的需求也就顺手实现了，又何必存到数据呢?&lt;/p&gt;&lt;p&gt;所以，OLAP 使用场景隐含的一个特点是：存入的数据需要被多维度反复分析的。这样才有把数据存入数据库的动力，像我们当前的需求对日志进行简单的变形后仍旧以文本日志的形式输出，使用 OLAP 是不合适的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;方案2：Hive 为什么不行?&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;看到这，熟悉大数据的同学可能会觉得我们水平很 Low，因为业务需求归根到底就是三个字：批处理。 &lt;/p&gt;&lt;p&gt;那我们为什么第一时间没有考虑上大数据呢？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b2359f08971047d09d069c415a66dab9_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;740&quot; data-rawheight=&quot;417&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-b2359f08971047d09d069c415a66dab9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;740&quot; data-rawheight=&quot;417&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-b2359f08971047d09d069c415a66dab9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b2359f08971047d09d069c415a66dab9_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 大数据处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;大数据确实如雷贯耳，但现在我们的日志处理这块大部分都是用 Golang 实现的，团队内的其他业务用了 Python、Lua、C，就是没有用过到 Java。而目前大数据都是基于 JVM 开发的。Golang 调用这些服务没有一个好用的客户端。&lt;/p&gt;&lt;p&gt;所以基于团队目前的技术储备，大数据才没有成为我们的首选。但是从目前的状况来看大数据是最优解了。那么我们该选用大数据的什么组件实现需求呢?&lt;/p&gt;&lt;p&gt;放弃使用数据库直接使用 HDFS 存储日志文件，应该是毋庸置疑的。&lt;/p&gt;&lt;p&gt;我们需求是离线批处理数据，对时效性没有要求，MapReduce 和 Hive 都能满足需求。但是 MapReduce 与 Hive 相比，Hive 在 MapReduce 上做了一层封装并且支持 SQL。看起来 Hive 是非常合适的。&lt;/p&gt;&lt;p&gt;那为什么最终放弃了 Hive 呢?&lt;/p&gt;&lt;ul&gt;&lt;li&gt;机器资源问题。公司其他团队已经有一套 HDFS 的设施，只用来做存储，Hadoop 的 MapReduce 这个组件根本没跑起来。那套 HDFS 部署的机器资源比较紧张，他们担心我们使用 MapReduce 和 Hive 跑计算，会影响现在 HDFS 的性能; 我们想审批一批新的机器，重新使用 Ambari 搭建一套 Hadoop，却被告知没那么多闲置的机器资源。而且我们即便申请下来了机器，只跑目前服务也跑不满，机器资源大部分也会被闲置，也有浪费资源的嫌疑。&lt;/li&gt;&lt;li&gt;存储分离是趋势。在调研中我们发现，像 Hadoop 这样把存储和计算放到一起的已经比较&quot;落伍&quot;了。Hadoop 存储分离，需要修改源码，目前没有开源实现，只是云厂商和各个大数据公司有相关商业产品。从这个角度讲，即便我们自己搞定了机器资源搭一套 Hadoop，也只不过是拾人牙慧罢了。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4a36a4acf61b6fb5522c4202e55e7735_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;504&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-4a36a4acf61b6fb5522c4202e55e7735_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;504&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-4a36a4acf61b6fb5522c4202e55e7735_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4a36a4acf61b6fb5522c4202e55e7735_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 大数据生态图，图片来源于小枣君&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;方案 2 小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;再合适的技术方案不能落地也是空谈。但是技术方案想要落地时，已经不是一个单纯的技术问题了，资源限制，团队限制等都需要考虑在内。&lt;/p&gt;&lt;p&gt;一个优秀的技术方案立足于解决当下的问题，并且能放眼未来勾画蓝图，这样大家觉得 &quot;有利可图&quot;，才愿意跟你一起折腾。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;方案3：为什么我们放弃了 Spark?&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;通用的计算引擎&lt;/b&gt;&lt;/p&gt;&lt;p&gt;虽然使用 HDFS 的团队不赞成在他们的机器上跑 Hive，但是我们把日志数据存到他们的 HDFS 上还是没问题的。在已知 &quot;存储和分离是趋势&quot; 是前提的基础下，&quot;我们到底需要什么&quot; 这个问题已经有答案了。&lt;/p&gt;&lt;p&gt;我们需要的是一个通用的计算引擎。存储已经剥离给 HDFS 了，所以我们只需要找一个工具，帮我们处理 ETL 就可以了。Spark 和 Flink 正是这样的场景。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Spark 与 Flink 初次交锋&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Spark 和 Flink 之间，我们毫不犹豫地选择了 Spark。原因非常简单：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Spark 适合批处理。Spark 当初的设计目标就是用来替换 MapReduce。而 Spark 流处理的能力是后来加上去的。所以用 Spark 进行批处理，可谓得心应手。&lt;/li&gt;&lt;li&gt;Spark 成熟度高。Spark 目前已经发布到 3.0，而 Flink 尚在 Flink 1.x 阶段。Flink 向来以流处理闻名，虽然被国内某云收购后开始鼓吹 &quot;流批一体&quot;，但是线上效果还是有待检验的。&lt;/li&gt;&lt;li&gt;Scala 的加持。Spark 大部分是用 Scala 实现的。Scala 是一门多范式的编程语言，并且与 Haskell 有很深的渊源。Haskell 是一门大名鼎鼎的函数式编程语言。对于函数式编程语言，想必大多数程序猿都有一种 &quot;虽不能至，然心向往之&quot; 的情结。现在使用 Spark 能捎带着耍一耍函数式编程语言 Scala，岂不妙哉？&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cab5f3da76c389c723b5cdfbcfc32b77_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;753&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-cab5f3da76c389c723b5cdfbcfc32b77_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;753&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-cab5f3da76c389c723b5cdfbcfc32b77_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-cab5f3da76c389c723b5cdfbcfc32b77_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Scala&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;挥泪斩 Spark&lt;/b&gt;&lt;/p&gt;&lt;p&gt;前文已经交代过了，我们否决掉 Hive 的一个重要因素是没有足够的机器资源。所以我们把 Spark 直接部署到云平台上。&lt;/p&gt;&lt;p&gt;对于我司的云平台要补充一些细节。&lt;/p&gt;&lt;p&gt;我们的云平台是基于 K8S 二次开发的，目前还在迭代当中，因此&quot;Spark on K8S&quot; 的运行模式我们暂时用不了。在这样的情况下，我们采用了 &quot;Spark Standalone&quot; 的模式。Standalone 模式，也就是Master Slaver 模式，类似于 Nginx 那样的架构，Master 节点负责接收分发任务，Slaver 节点负责&quot;干活&quot;。&lt;/p&gt;&lt;p&gt;等到我们在云平台上以 &quot;Spark Standalone&quot; 模式部署好了，跑了几个测试 Case 发现了新问题。我们的云平台与办公网络是隔离的，如果办公网络想访问云平台的某个 Docker 容器，需要配置域名。而 Spark 的管理页面上很多 URL 的 domain 是所在机器的 IP，容器的 IP 是虚拟 IP，容器重启后IP 就会改变。具体如图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-814f1110cacc77ebd8cff4ebee4be9fd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;301&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-814f1110cacc77ebd8cff4ebee4be9fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;301&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-814f1110cacc77ebd8cff4ebee4be9fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-814f1110cacc77ebd8cff4ebee4be9fd_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 部署在云平台的 spark&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Spark 的管理平台非常重要，因为能从这上面看到当前各个节点运行情况，任务的异常信息等，现在很多链接不能访问，不利于我们对 Spark 任务进行问题排查和调优。基于这个原因，我们最终放弃了 Spark。&lt;/p&gt;&lt;p&gt;&lt;b&gt;方案 3 小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Spark 你真的很优秀，擅长批处理，如此成熟，还有函数式的基因 。。。这些优点早让我倾心不已。&lt;/p&gt;&lt;p&gt;Spark 你真的是个好人，如果不是云平台的限制，我一定选择你。&lt;/p&gt;&lt;p&gt;Spark，对不起。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;方案4：Flink，真香！&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;给 Spark 发完好人卡后，我们看一看新欢 Flink。不客气的说，Flink 初期时很多实现都是抄的 Spark，所以二者的很多概念相似。所以 Flink 同样有 Standalone 模式，我们在部署阶段没遇到任何问题。&lt;/p&gt;&lt;p&gt;在跑了几个 Flink 测试 Case 后，我们由衷的感叹 Flink 真香。&lt;/p&gt;&lt;p&gt;放弃 Spark 时我们的痛点在于 &quot;部署在云平台上的 Spark 服务的管理界面很多功能无法使用&quot;，而 Flink 的管理平台完全没有这个问题。除此之外，Flink 管理平台的 &quot;颜值&quot; 和功能都是 Spark 无法比拟的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;管理平台颜值对比&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-81f492437b2251f815d5ecc50871e4c5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;155&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-81f492437b2251f815d5ecc50871e4c5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;155&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-81f492437b2251f815d5ecc50871e4c5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-81f492437b2251f815d5ecc50871e4c5_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Spark管理平台页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5c6ba1581fc95f0f3415440f80d516d0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;487&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-5c6ba1581fc95f0f3415440f80d516d0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;487&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-5c6ba1581fc95f0f3415440f80d516d0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5c6ba1581fc95f0f3415440f80d516d0_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Flink管理平台页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;对比之下，Spark 的页面完全是个&quot;黄脸婆&quot;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Flink 管理平台功能&lt;/b&gt;&lt;/p&gt;&lt;p&gt;由于 Spark 的功能很多不能使用，所以就不重点和 Flink 做比较了。这里只说 Flink 几个让人眼前一亮的功能。&lt;/p&gt;&lt;p&gt;部署了 Flink 或 Spark 服务后，该如何下发计算任务呢? 一般是通过 bin 目录下的一个名称中包含 submit 的可执行程序。那如果想把 Flink 或 Spark 做成微服务，通过 http 接口去下发任务呢?&lt;/p&gt;&lt;p&gt;Spark1.0 的时候支持 http，2.0时这个功能基本上废掉了，很多参数不支持了，把 http 这个功能交由 jobService 一个第三方开源组件去实现。这个 jobService 的开源组件对云平台的支持也非常不友好。所以在我们看来，Spark 通过 Http 下发任务的路子基本被堵死了。&lt;/p&gt;&lt;p&gt;反观 Flink，管理平台的接口是 Restful 的，不仅支持 Http 下发计算任务，还可以通过相关接口查看任务状态和获取异常或返回值。&lt;/p&gt;&lt;p&gt;Flink 的任务分为几个不同的阶段，每个不同的阶段有不同的颜色。这样仅从颜色就可以判断出当前 Flink 任务执行的大致情况。如下图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4b93584c342c4241557a8a73b9236757_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;232&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-4b93584c342c4241557a8a73b9236757_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;232&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-4b93584c342c4241557a8a73b9236757_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-4b93584c342c4241557a8a73b9236757_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Flink管理平台页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在任务详情页面，会有任务分解图和任务执行耗时表格，这两个结合起来能够知道当然 Flink 任务是如何分解的，是否出现数据倾斜的情况，哪个步骤耗时最多，是否有优化的空间。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5fbdbc218db74ca27303a7c0de607018_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;390&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-5fbdbc218db74ca27303a7c0de607018_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;390&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-5fbdbc218db74ca27303a7c0de607018_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5fbdbc218db74ca27303a7c0de607018_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-82e9fa77f69d496a517d722ebba0de46_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;510&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-82e9fa77f69d496a517d722ebba0de46_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;510&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-82e9fa77f69d496a517d722ebba0de46_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-82e9fa77f69d496a517d722ebba0de46_b.jpg&quot;/&gt;&lt;figcaption&gt; △ 管理平台页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这就是做批处理技术选型时候的心路历程，随笔记了下来，希望对大家有所帮助。&lt;/p&gt;&lt;p&gt;&lt;b&gt;推荐阅读：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/583/%25E5%25A6%2582%25E4%25BD%2595%25E9%2580%2589%25E6%258B%25A9%25E9%2580%2582%25E5%2590%2588%25E8%2587%25AA%25E5%25B7%25B1%25E7%25BD%2591%25E7%25AB%2599%25E7%259A%2584%25E9%2598%25B2%25E7%259B%2597%25E9%2593%25BE.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-56c5b7b098e6252cc7acb7a601428c09_180x120.jpg&quot; data-image-width=&quot;960&quot; data-image-height=&quot;640&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;如何选择适合自己网站的防盗链&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic2.zhimg.com/v2-56c5b7b098e6252cc7acb7a601428c09_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/577/HTTP%252F3%2520%25E6%259D%25A5%25E4%25BA%2586%25EF%25BC%258C%25E4%25BD%25A0%25E4%25BA%2586%25E8%25A7%25A3%25E5%25AE%2583%25E4%25B9%2588%25EF%25BC%259F.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-cddf6e4c200fe6cc94c4b8edfdae7521_180x120.jpg&quot; data-image-width=&quot;1080&quot; data-image-height=&quot;523&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;HTTP/3 来了，你了解它么？&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic2.zhimg.com/v2-cddf6e4c200fe6cc94c4b8edfdae7521_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>42e632bf561d1ae352a0e3f4e6f1f96a</guid>
<title>[推荐] 面试官：你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景</title>
<link>https://toutiao.io/k/vhisgi9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;数据分析与开发&lt;/span&gt;&lt;span&gt;加星标，提升数据技能&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt; 转自：小林Coding&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;生活中用到的锁，用途都比较简单粗暴，上锁基本是为了防止外人进来、电动车被偷等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但生活中也不是没有 BUG 的，比如加锁的电动车在「广西 - 窃·格瓦拉」面前，锁就是形同虚设，只要他愿意，他就可以轻轻松松地把你电动车给「顺走」，不然打工怎么会是他这辈子不可能的事情呢？牛逼之人，必有牛逼之处。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.94&quot; data-type=&quot;jpeg&quot; data-w=&quot;350&quot; title=&quot;&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZflJahXjfiaG4OvTA9DA2Uibznd2ictPmdiaM9Nic6dqJ1kXd2FMiaYRWL9h8n8RZ6vuttsAAI77TerIqiaA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;那在编程世界里，「锁」更是五花八门，多种多样，每种锁的加锁开销以及应用场景也可能会不同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何用好锁，也是程序员的基本素养之一了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高并发的场景下，如果选对了合适的锁，则会大大提高系统的性能，否则性能会降低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，知道各种锁的开销，以及应用场景是很有必要的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，就谈一谈常见的这几种锁：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8525345622119815&quot; data-type=&quot;png&quot; data-w=&quot;868&quot; title=&quot;&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZflJahXjfiaG4OvTA9DA2UibzWMw2wvbFNhIHe3XrOZB6C8NZ3LFK5tF4twWs9UCEYR4kUEjUN00Qbg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;多线程访问共享资源的时候，避免不了资源竞争而导致数据错乱的问题，所以我们通常为了解决这一问题，都会在访问共享资源之前加锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最常用的就是互斥锁，当然还有很多种不同的锁，比如自旋锁、读写锁、乐观锁等，不同种类的锁自然适用于不同的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果选择了错误的锁，那么在一些高并发的场景下，可能会降低系统的性能，这样用户体验就会非常差了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，为了选择合适的锁，我们不仅需要清楚知道加锁的成本开销有多大，还需要分析业务场景中访问的共享资源的方式，再来还要考虑并发访问共享资源时的冲突概率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对症下药，才能减少锁对高并发性能的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那接下来，针对不同的应用场景，谈一谈「&lt;strong&gt;互斥锁、自旋锁、读写锁、乐观锁、悲观锁&lt;/strong&gt;」的选择和使用。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;span&gt;互斥锁与自旋锁：谁更轻松自如？&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，&lt;strong&gt;既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的&lt;/strong&gt;。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.178147268408551&quot; data-type=&quot;png&quot; data-w=&quot;842&quot; title=&quot;&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZflJahXjfiaG4OvTA9DA2UibzKwEMKCNn2DoRsgWyvZsfzPARRpvfdc3ywicDNAmVrIFE6icduenBnxgw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那这个开销成本是什么呢？会有&lt;strong&gt;两次线程上下文切换的成本&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程的上下文切换的是什么？当两个线程是属于同一个进程，&lt;strong&gt;因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，&lt;strong&gt;如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自旋锁是通过 CPU 提供的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CAS&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数（&lt;em&gt;Compare And Swap&lt;/em&gt;），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般加锁的过程，包含两个步骤：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CAS 函数就把这两个步骤合并成一条硬件级指令，形成&lt;strong&gt;原子指令&lt;/strong&gt;，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 循环等待实现，不过最好是使用 CPU 提供的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;PAUSE&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。&lt;strong&gt;需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：&lt;strong&gt;当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;&lt;span&gt;读写锁：读和写还有优先级区分？&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，&lt;strong&gt;读写锁适用于能明确区分读操作和写操作的场景&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读写锁的工作原理是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;知道了读写锁的工作原理后，我们可以发现，&lt;strong&gt;读写锁在读多写少的场景，能发挥出优势&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取读锁。如下图：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9092592592592592&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZflJahXjfiaG4OvTA9DA2UibzGiaX1mvYx5jzfQaYsG9hYbicIzos7M9SkKz0wWMoxBk9RwyguyWwtricA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;而写优先锁是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取读锁。如下图：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.975&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZflJahXjfiaG4OvTA9DA2UibzskMiariaXsTzJYibmXK6vGf9fWOlJI6oSaB0ibBIp40Gia5V0VsWclRvttw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;&lt;span&gt;乐观锁与悲观锁：做事的心态有何不同？&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;悲观锁做事比较悲观，它认为&lt;strong&gt;多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：&lt;strong&gt;先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现&lt;strong&gt;乐观锁全程并没有加锁，所以它也叫无锁编程&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里举一个场景例子：在线文档。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交改动，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务端要怎么验证是否冲突了呢？通常方案如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以&lt;strong&gt;只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&amp;amp;mid=2650867608&amp;amp;idx=1&amp;amp;sn=31304a1e4fdf1723a769967cfbbec729&amp;amp;chksm=8b67e0ddbc1069cb14cce449afb8982d2c4c0536f7baabf64b7a54c629e8d684a3b6646d4a1a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一次由 Redis 分布式锁造成的重大事故&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&amp;amp;mid=2650865251&amp;amp;idx=1&amp;amp;sn=29cd4dffb55976653d21b60229ae0214&amp;amp;chksm=8b661926bc119030627cbff9a84c12eeed72310808e07181cb06a8765c3d03b46c6d2af7c791&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;通俗讲解分布式锁，看完不懂算作者输&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&amp;amp;mid=2650865371&amp;amp;idx=1&amp;amp;sn=99e6e48b44cfef32445b00360223649b&amp;amp;chksm=8b66199ebc1190885b93da29f8d294951377dfa0a5e7d9219fedddb3d50503d7770567533d4e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊一聊数据库中的锁&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关注「数据分析与开发」加星标，提升数据技能&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DmibiaFiaAI4B3YpcZYPicgc9JTMiaACNXE5A9FePsKgBic7LNlibx2fwVycTN4Wq47TzYXTNnP2PCKCVAGibNmzDnD0zg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>