<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1e22e4414b07b7f0d29b33c0799106a1</guid>
<title>2022 年别再焦虑啦！加入我们！</title>
<link>https://toutiao.io/k/obimloc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2aa0d8d3970d4f13536c35303c1ed0a5</guid>
<title>深度剖析 Seata TCC 模式</title>
<link>https://toutiao.io/k/usoli0i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;什么是 TCC&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCC 是分布式事务中的二阶段提交协议，它的全称为 Try-Confirm-Cancel，即资源预留（Try）、确认操作（Confirm）、取消操作（Cancel），他们的具体含义如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Try：对业务资源的检查并预留；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Confirm：对业务处理进行提交，即 commit 操作，只要 Try 成功，那么该步骤一定成功；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Cancel：对业务处理进行取消，即回滚操作，该步骤回对 Try 预留的资源进行释放。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCC 是一种侵入式的分布式事务解决方案，以上三个操作都需要业务系统自行实现，对业务系统有着非常大的入侵性，设计相对复杂，但优点是 TCC 完全不依赖数据库，能够实现跨数据库、跨应用资源管理，对这些不同数据访问通过侵入式的编码方式实现一个原子操作，更好地解决了在各种复杂业务场景下的分布式事务问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7768924302788844&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBbl9iatc1Cuh6qWgTib3aicMGFkfHFULpKNYeRjLJeqWIUiaCUv6MIge8TQXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1004&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Seata TCC 模式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata TCC 模式跟通用型 TCC 模式原理一致，我们先来使用 Seata TCC 模式实现一个分布式事务：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设现有一个业务需要同时使用服务 A 和服务 B 完成一个事务操作，我们在服务 A 定义该服务的一个 TCC 接口：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同样，在服务 B 定义该服务的一个 TCC 接口：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TccActionTwo&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@TwoPhaseBusinessAction&lt;/span&gt;(name = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;DubboTccActionTwo&quot;&lt;/span&gt;, commitMethod = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;commit&quot;&lt;/span&gt;, rollbackMethod = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;rollback&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;prepare&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(BusinessActionContext actionContext, @BusinessActionContextParameter(paramName = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;b&quot;&lt;/span&gt;)&lt;/span&gt; String b)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;commit&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(BusinessActionContext actionContext)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;rollback&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(BusinessActionContext actionContext)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在业务所在系统中开启全局事务并执行服务 A 和服务 B 的 TCC 预留资源方法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@GlobalTransactional&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; doTransactionCommit() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tccActionOne.prepare(&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;one&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tccActionTwo.prepare(&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;two&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上就是使用 Seata TCC 模式实现一个全局事务的例子，可以看出，TCC 模式同样使用 @GlobalTransactional 注解开启全局事务，而服务 A 和服务 B 的 TCC 接口为事务参与者，Seata 会把一个 TCC 接口当成一个 Resource，也叫 TCC Resource。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCC 接口可以是 RPC，也可以是 JVM 内部调用，意味着一个 TCC 接口，会有发起方和调用方两个身份，以上例子，TCC 接口在服务 A 和服务 B 中是发起方，在业务所在系统中是调用方。如果该 TCC 接口为 Dubbo RPC，那么调用方就是一个 dubbo:reference，发起方则是一个 dubbo:service。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8055555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblib91IzAYbpYyyUcn2rMdPxmxAkvYicApr9jIiaAicCPTHNw4r2pw8VKcnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata 启动时会对 TCC 接口进行扫描并解析，如果 TCC 接口是一个发布方，则在 Seata 启动时会向 TC 注册 TCC Resource，每个 TCC Resource 都有一个资源 ID；如果 TCC 接口时一个调用方，Seata 代理调用方，与 AT 模式一样，代理会拦截 TCC 接口的调用，即每次调用 Try 方法，会向 TC 注册一个分支事务，接着才执行原来的 RPC 调用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当全局事务决议提交/回滚时，TC 会通过分支注册的的资源 ID 回调到对应参与者服务中执行 TCC Resource 的 Confirm/Cancel 方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Seata 如何实现 TCC 模式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从上面的 Seata TCC 模型可以看出，TCC 模式在 Seata 中也是遵循 TC、TM、RM 三种角色模型的，如何在这三种角色模型中实现 TCC 模式呢？我将其主要实现归纳为资源解析、资源管理、事务处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;资源解析&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;资源解析即是把 TCC 接口进行解析并注册，前面说过，TCC 接口可以是 PRC，也可以是 JVM 内部调用，在 Seata TCC 模块中中一个 remoting 模块，该模块专门用于解析具有 TwoPhaseBusinessAction 注解的 TCC 接口资源：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8501742160278746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblxIvRqlftiaiacrEPl5pEpnqIokjUia87qlp43aZm2TXupVBPXvibdV38Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RemotingParser 接口主要有 isRemoting、isReference、isService、getServiceDesc 等方法，默认的实现为 DefaultRemotingParser，其余各自的 RPC 协议解析类都在 DefaultRemotingParser 中执行，Seata 目前已经实现了对 Dubbo、HSF、SofaRpc、LocalTCC 的 RPC 协议的解析，同时具备 SPI 可扩展性，未来欢迎大家为 Seata 提供更多的 RPC 协议解析类。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Seata 启动过程中，有个 GlobalTransactionScanner 注解进行扫描，会执行以下方法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;io.seata.spring.util.TCCBeanParserUtils#isTccAutoProxy&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;该方法目的是判断 bean 是否已被 TCC 代理，在过程中会先判断 bean 是否是一个 Remoting bean，如果是则调用 getServiceDesc 方法对 remoting bean 进行解析，同时判断如果是一个发起方，则对其进行资源注册：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;io.seata.rm.tcc.remoting.parser.DefaultRemotingParser#parserRemotingServiceInfo&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; RemotingDesc parserRemotingServiceInfo(Object bean, String beanName, RemotingParser remotingParser) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    RemotingDesc remotingBeanDesc = remotingParser.getServiceDesc(bean, beanName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (remotingBeanDesc == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    remotingServiceMap.put(beanName, remotingBeanDesc);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Class&amp;lt;?&amp;gt; interfaceClass = remotingBeanDesc.getInterfaceClass();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Method[] methods = interfaceClass.getMethods();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (remotingParser.isService(bean, beanName)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Object targetBean = remotingBeanDesc.getTargetBean();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Method m : methods) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                TwoPhaseBusinessAction twoPhaseBusinessAction = m.getAnnotation(TwoPhaseBusinessAction.&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (twoPhaseBusinessAction != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    TCCResource tccResource = new TCCResource();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setActionName(twoPhaseBusinessAction.name());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setTargetBean(targetBean);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setPrepareMethod(m);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setCommitMethodName(twoPhaseBusinessAction.commitMethod());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setCommitMethod(interfaceClass.getMethod(twoPhaseBusinessAction.commitMethod(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                                         twoPhaseBusinessAction.commitArgsClasses()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setRollbackMethodName(twoPhaseBusinessAction.rollbackMethod());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setRollbackMethod(interfaceClass.getMethod(twoPhaseBusinessAction.rollbackMethod(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                                           twoPhaseBusinessAction.rollbackArgsClasses()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setCommitArgsClasses(twoPhaseBusinessAction.commitArgsClasses());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setRollbackArgsClasses(twoPhaseBusinessAction.rollbackArgsClasses());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setPhaseTwoCommitKeys(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.getTwoPhaseArgs(tccResource.getCommitMethod(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                                           twoPhaseBusinessAction.commitArgsClasses()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    tccResource.setPhaseTwoRollbackKeys(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.getTwoPhaseArgs(tccResource.getRollbackMethod(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                                             twoPhaseBusinessAction.rollbackArgsClasses()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    DefaultResourceManager.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;().registerResource(tccResource);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; new FrameworkException(t, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;parser remoting service error&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (remotingParser.isReference(bean, beanName)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        remotingBeanDesc.setReference(&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; remotingBeanDesc;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上方法，先调用解析类 getServiceDesc 方法对 remoting bean 进行解析，并将解析后的 remotingBeanDesc 放入 本地缓存 remotingServiceMap 中，同时调用解析类 isService 方法判断是否为发起方，如果是发起方，则解析 TwoPhaseBusinessAction 注解内容生成一个 TCCResource，并对其进行资源注册。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;资源管理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1、资源注册&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata TCC 模式的资源叫 TCCResource，其资源管理器叫 TCCResourceManager，前面讲过，当解析完 TCC 接口 RPC 资源后，如果是发起方，则会对其进行资源注册：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;io.seata.rm.tcc.TCCResourceManager#registerResource&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;registerResource&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Resource resource)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TCCResource tccResource = (TCCResource)resource;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tccResourceCache.put(tccResource.getResourceId(), tccResource);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;super&lt;/span&gt;.registerResource(tccResource);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCCResource 包含了 TCC 接口的相关信息，同时会在本地进行缓存。继续调用父类 registerResource 方法（封装了通信方法）向 TC 注册，TCC 资源的 resourceId 是 actionName，actionName 就是 @TwoParseBusinessAction 注解中的 name。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2、资源提交/回滚&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;io.seata.rm.tcc.TCCResourceManager#branchCommit&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; BranchStatus branchCommit(BranchType branchType, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; xid, long branchId, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; resourceId,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                 &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; applicationData) throws TransactionException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TCCResource tccResource = (TCCResource)tccResourceCache.get(resourceId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (tccResource == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShouldNeverHappenException(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.format(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;TCC resource is not exist, resourceId: %s&quot;&lt;/span&gt;, resourceId));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; targetTCCBean = tccResource.getTargetBean();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Method commitMethod = tccResource.getCommitMethod();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (targetTCCBean == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; || commitMethod == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShouldNeverHappenException(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.format(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;TCC resource is not available, resourceId: %s&quot;&lt;/span&gt;, resourceId));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        BusinessActionContext businessActionContext = getBusinessActionContext(xid, branchId, resourceId,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                                               applicationData);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ret = commitMethod.invoke(targetTCCBean, args);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; result ? BranchStatus.PhaseTwo_Committed : BranchStatus.PhaseTwo_CommitFailed_Retryable;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; msg = &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.format(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;commit TCC resource error, resourceId: %s, xid: %s.&quot;&lt;/span&gt;, resourceId, xid);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        LOGGER.error(msg, t);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; BranchStatus.PhaseTwo_CommitFailed_Retryable;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当 TM 决议二阶段提交，TC 会通过分支注册的的资源 ID 回调到对应参与者（即 TCC 接口发起方）服务中执行 TCC Resource 的 Confirm/Cancel 方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;资源管理器中会根据 resourceId 在本地缓存找到对应的 TCCResource，同时根据 xid、branchId、resourceId、applicationData 找到对应的 BusinessActionContext 上下文，执行的参数就在上下文中。最后，执行 TCCResource 中获取 commit 的方法进行二阶段提交。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二阶段回滚同理类似。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;事务处理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面讲过，如果 TCC 接口时一个调用方，则会使用 Seata TCC 代理对调用方进行拦截处理，并在处理调用真正的 RPC 方法前对分支进行注册。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;执行方法 io.seata.spring.util.TCCBeanParserUtils#isTccAutoProxy 除了对 TCC 接口资源进行解析，还会判断 TCC 接口是否为调用方，如果是调用方则返回 true：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;io.seata.spring.annotation.GlobalTransactionScanner#wrapIfNecessary&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1905940594059406&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblNdcVQC7ZQTVyUBvWK2qQYJ2mXib19r6h7hn3ERdbkMibZOVBicMcMZhGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2424&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如图，当 GlobalTransactionalScanner 扫描到 TCC 接口调用方（Reference）时，会使 TccActionInterceptor 对其进行代理拦截处理，TccActionInterceptor 实现 MethodInterceptor。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 TccActionInterceptor 中还会调用 ActionInterceptorHandler 类型执行拦截处理逻辑，事务相关处理就在 ActionInterceptorHandler#proceed 方法中：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; proceed(Method method, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;[] &lt;span class=&quot;code-snippet__built_in&quot;&gt;arguments&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; xid, TwoPhaseBusinessAction businessAction,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      Callback&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;&amp;gt; targetCallback) throws Throwable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    BusinessActionContext actionContext = getOrCreateActionContextAndResetToArguments(method.getParameterTypes(), &lt;span class=&quot;code-snippet__built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; branchId = doTccActionLogStore(method, &lt;span class=&quot;code-snippet__built_in&quot;&gt;arguments&lt;/span&gt;, businessAction, actionContext);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; targetCallback.execute();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            BusinessActionContextUtil.reportContext(actionContext);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上，在执行 TCC 接口一阶段之前，会调用 doTccActionLogStore 方法分支注册，同时还会将 TCC 相关信息比如参数放置在上下文，上面讲的资源提交/回滚就会用到这个上下文。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;如何控制异常&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 TCC 模型执行的过程中，还可能会出现各种异常，其中最为常见的有空回滚、幂等、悬挂等。下面我讲下 Seata 是如何处理这三种异常的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;如何处理空回滚&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是空回滚？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;空回滚指的是在一个分布式事务中，在没有调用参与方的 Try 方法的情况下，TM 驱动二阶段回滚调用了参与方的 Cancel 方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么空回滚是如何产生的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7925824175824175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblb5C8gBNTaD94MDQZanBsvUPvicnibaQ7jb9cic8ibYzsnBWeUiciaFib21HzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1456&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如上图所示，全局事务开启后，参与者 A 分支注册完成之后会执行参与者一阶段 RPC 方法，如果此时参与者 A 所在的机器发生宕机，网络异常，都会造成 RPC 调用失败，即参与者 A 一阶段方法未成功执行，但是此时全局事务已经开启，Seata 必须要推进到终态，在全局事务回滚时会调用参与者 A 的 Cancel 方法，从而造成空回滚。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要想防止空回滚，那么必须在 Cancel 方法中识别这是一个空回滚，Seata 是如何做的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata 的做法是新增一个 TCC 事务控制表，包含事务的 XID 和 BranchID 信息，在 Try 方法执行时插入一条记录，表示一阶段执行了，执行 Cancel 方法时读取这条记录，如果记录不存在，说明 Try 方法没有执行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;如何处理幂等&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;幂等问题指的是 TC 重复进行二阶段提交，因此 Confirm/Cancel 接口需要支持幂等处理，即不会产生资源重复提交或者重复释放。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么幂等问题是如何产生的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7977839335180056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBbl7JzkibThAicvzkwwShb0DkaCGBKXY4hvEF7UlwOAhVjAfkrWwvOl4xBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1444&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如上图所示，参与者 A 执行完二阶段之后，由于网络抖动或者宕机问题，会造成 TC 收不到参与者 A 执行二阶段的返回结果，TC 会重复发起调用，直到二阶段执行结果成功。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata 是如何处理幂等问题的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同样的也是在 TCC 事务控制表中增加一个记录状态的字段 status，该字段有有 3 个值，分别为：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;tried：1&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;committed：2&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;rollbacked：3&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二阶段 Confirm/Cancel 方法执行后，将状态改为 committed 或 rollbacked 状态。当重复调用二阶段 Confirm/Cancel 方法时，判断事务状态即可解决幂等问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;如何处理悬挂&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;悬挂指的是二阶段 Cancel 方法比 一阶段 Try 方法优先执行，由于允许空回滚的原因，在执行完二阶段 Cancel 方法之后直接空回滚返回成功，此时全局事务已结束，但是由于 Try 方法随后执行，这就会造成一阶段 Try 方法预留的资源永远无法提交和释放了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么悬挂是如何产生的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7988980716253443&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4MfwdbrwE6d4mBXw77t7OtKMBVRlRBblFPZGKcAX6icRxb2NNicibataztZkSxDuaKywrgkWFNb8aOL6DdKEGXKQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1452&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如上图所示，在执行参与者 A 的一阶段 Try 方法时，出现网路拥堵，由于 Seata 全局事务有超时限制，执行 Try 方法超时后，TM 决议全局回滚，回滚完成后如果此时 RPC 请求才到达参与者 A，执行 Try 方法进行资源预留，从而造成悬挂。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Seata 是怎么处理悬挂的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 TCC 事务控制表记录状态的字段 status 中增加一个状态：&lt;/span&gt;&lt;span&gt;suspended：&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当执行二阶段 Cancel 方法时，如果发现 TCC 事务控制表有相关记录，说明二阶段 Cancel 方法优先一阶段 Try 方法执行，因此插入一条 status=4 状态的记录，当一阶段 Try 方法后面执行时，判断 status=4 ，则说明有二阶段 Cancel 已执行，并返回 false 以阻止一阶段 Try 方法执行成功。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>78da6ae5067e8c9dc1298f8faaf612c4</guid>
<title>从数据库评估差异，看全球化长期主义之路</title>
<link>https://toutiao.io/k/r980b51</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89204&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;&lt;span&gt;2. 从数据库评估方式看发展差异&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正如前面所讲，近些年来国内外数据库行业发展迅猛，有越来越多企业、资本、人才投入其中。那么在火热的发展浪潮中，如何对行业、企业、产品、技术有个理性的评估，就至关重要。这不仅有利于数据库厂商预判行业趋势、企业发展定位、产品演进路径、技术发力方向，也有利于广大数据库从业者做出符合自己的发展之路。在这方面，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;国内外有很多机构、组织有着自己的评估方式，而且国内外的评估差异也非常明显&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。下面就谈谈对国内外对数据库评估差异的个人理解。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1).海外评估&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;在海外对数据库的评估，已经有较为成熟的实践。有很多公司、组织或科研机构参与到数据库的评估之中。这里可大致分为三类：一是以 Gartner、Forrester、IDC 为代表的 IT 研究与评估机构，它们会定期发布数据库领域的研究报告；二是以 DB-Engines 为代表的第三方组织，会持续更新排名全球数据库发展现状。三是以卡内基梅隆大学为代表的科研机构，会收录全球数据库信息供学术分析；上述三类公司或组织，其评估角度各有不同，但其合集基本覆盖了从数据库技术、产品、生态、商业等多个侧面。下面详细展开说明下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot; hm_fix=&quot;261:273&quot;&gt;&lt;strong&gt;&lt;span&gt; IT研究与评估机构代表：Gartner&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.002439024390244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xZOm0XATx0WZ7nrYHEteSXSogm0F0ibHm5dHXOXhy9Ciafn2b8V8g4XXGkoapciaJrR8I5cSHsdSyqtNJSptqAbYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;820&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Gartner，是全球最具权威的 IT 研究与顾问咨询公司，成立于 1979 年，总部设在美国康涅狄克州斯坦福，其研究范围覆盖全部 IT 产业。其在 2006 年提出魔力象限模型，用以描述特定领域全球最权威和最具影响力的厂商综合能力评估报告，是头部厂商产品能力的对标。一般情况下，企业 IT 决策者可通过这一分析报告甄别厂商能力，为采购、招标等提供一定的依据佐证。其评选标准包括全球市场份额、产品能力、客户反馈等。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Gartner 魔力象限的评估标准，也是在与时俱进、不断调整。早前 Gartner 主要是根据产品营收选取前 20 个厂商进入年度的云数据库市场的魔力象限，2021 年的评估标准中移除了这一限制，而是采用一种 Market Momentum Index（市场动向指数）来评估，旨在让受到用户欢迎的中小数据库企业有机会入选。于是我们在 2021 年的魔力象限中看到，诸如 SingleStore、Couchbase、Exasol、MariaDB、Cockroach Labs 等数据库新势力首次上榜。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2021 年中国数据库厂商阿里云（Alibaba Cloud）再次进入领导者象限，华为云（HUAWEI CLOUD）进入特定领域者象限（NICHE PLAYERS），是国内入选的仅有两家企业。2020 年还在魔力象限的腾讯云数据库此次缺席，席位被北美的新势力独角兽占据。可见中国数据库厂商由于多数局限在中国市场还未能获得 Gartner 的足够重视，根据非正式渠道得知 Gartner，Forrester，IDC 等三大分析机构已经注意到中国数据库市场的快速发展，将在未来 3-5 年单独强化对中国数据库市场和数据库厂商的评估，包括中国新锐数据库厂商在全球市场的表现。在全球市场的表现，始终是数据库厂商证明自己技术领先性的关键战场。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我们来看 Gartner 具体在市场动向指数上，统计主要来自哪些方向：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了上述在市场动向指数方面进入 Top 20 之外，还有几个必须满足的条件：至少满足 Gartner 定义的 7 个 Use Case 中的 3 个（Traditional transactions，Traditional data warehouse，Logical data warehouse，Augmented transaction processing，Event stream processing，Data science exploration/deep learning，Operational intelligence ）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot; hm_fix=&quot;261:273&quot;&gt;&lt;strong&gt;&lt;span&gt; 第三方机构代表：DB-Engine 数据流行度评估&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;DB-Engine Overall Ranking （2022 年 1 月）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3463541666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xZOm0XATx0WZ7nrYHEteSXSogm0F0ibHm08Os28rklwg4kcLk3TYkKPUZ8ESh3EK6UA7CzInA5JiciaeGPccibPiaHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1536&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前十位的数据库，有六个是开源的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1504424778761062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xZOm0XATx0WZ7nrYHEteSXSogm0F0ibHmTVaphpPaoNGokzeXQUenRzIKUMDrKeOOGD7XWCXcZiaclvxNQRPzic0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;904&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;DB-Engines 由于主要统计海外市场的信息，可以看到，在前 100 名关系型数据库厂商里面，仅有 TiDB 和阿里云的两个产品入围。这从侧面也反映了纯海外市场中国数据库综合影响力和中国市场有很大差异。DB-Engines 是由三方机构维护的，收录全球数据库信息，并按照活跃度给予排名。其排名的数据主要来自下面五种因素：&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Google 及 Bing 搜索引擎的关键字搜索数量；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Google Trends 的搜索数量；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Indeed 网站中的职位搜索量；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LinkedIn 中提到关键字的个人资料数；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Stackoverflow 上相关的问题和关注者数。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;参考: https://db-engines.com/en/ranking&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot; hm_fix=&quot;261:273&quot;&gt;&lt;strong&gt;&lt;span&gt; 科研机构代表：dbdb.io（卡内基梅隆大学）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4829482948294829&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xZOm0XATx0WZ7nrYHEteSXSogm0F0ibHmbDk3kRKXnNDmrh1DH81eZlbYaMK8qVOtjxq6EU1fBvJibAEH6oOdnfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1818&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;dbdb.io，是卡内基梅隆大学维护的全球数据库信息库，其中收录了全球 700 多种数据库产品，其包含数据库的开发者、国家、起始年份、项目类型、开发语言、衍生来源、兼容性、适配系统、开源协议等多种信息。除上述信息外，还包括最近更新、浏览、修改等方面的统计，可以间接反映出数据库产品的活跃程度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述三类评估者，可以说覆盖从技术、产品、生态、商业多角度，可以全方位地了解。但上述这些平台，大家经常访问会有个发现，中国数据库厂商及产品非常少。以 Gartner 为例，在 2021 年的报告中，仅收录了阿里、华为两家中国厂商。其背后原因还是Gartner更加注重商业部分，而国内企业出海不多，而对国内市场的情况海外研究机构又了解有限。而从 DB-Engines 来看，前 100 名仅仅有 PingCAP，阿里两家中国公司，DB- Engine 更多信息也是来自海外的搜索、社交媒体，招聘、论坛类信息，缺少对中国境内的搜索，社交媒体，论坛等信息，三个机构都只能以中国数据库厂商的海外影响力为主，也提示中国数据库厂商应该放眼海外，避免内卷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2).国内评估&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;从国内情况来看，长期以来一直缺乏对数据库的评估体系。之前也曾有过信创目录等政策引导性评估，但其更多是作为政府采购决策参考，公众参与度、认知度不高。不过值得欣喜的是，国内已经有三方机构主动担负其这一职能，希望从更多角度对国内产品做了全面的评估。这一机构就是墨天轮，其维护的墨天轮数据库排行榜，以月为周期多角度评估国内数据库并加以排名。就在不久前，其还发布墨天轮魔力象限，仿照 Gartner 做法来做象限分析。可以说墨天轮社区填补国内这一领域空白，为其点赞。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46033057851239667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xZOm0XATx0WZ7nrYHEteSXSogm0F0ibHmpnxk0AyBaOCCCoEDHCJy95anua9nvAUIC5TEGhjcqFNKTiaFGXNIesA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1210&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从 2021 年的最终排名看，PingCAP 作为开源分布式领导者连续 24 个月领先，但其领先优势开始受到华为 openGauss 数据库的挑战，老牌国产数据库达梦稳居第三，新晋开源的 OceanBase 也进入前五。当把这个前十位的名单与前面海外三类机构的名单比较时，会发现墨天轮的排行主要还是以中国数据库厂商在本土市场的表现为主。从评估维度来看，墨天轮社区在不断改进，其评估指标已较为全面。其排名因素包括如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n64&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;搜索引擎：引入百度、必应、谷歌以及微信公众号文章（搜狗）当月搜索条目数，每个搜索引擎权重不同，如百度、公众号文章较高，最后按整体占比计算得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;趋势指数：引入百度指数、360 趋势数据，通过搜索数据库关键字得到当月指数或趋势，计算得到每个数据库的平均指数，最后按整体占比计算得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;三方评测：引入了包括信通院大数据产品能力评测、电信行业能力评测、TPC 组织评测等，旨在体现数据库产品在特定场景下的基准达标，以及性能和稳定性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;生态：引入生态体系指标，包含社区平台、高校合作、培训认证、开放文档、代码开源、介质下载共六个维度，以体现厂商对数据库产品的可持续发展战略，开放开源、人才培养和共建行业的理念。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;专利数：专利是自主可控的重要体现，这一指标指厂商在国家或国际平台上可以公开查询的专利数，以体现数据库产品的创新能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;论文数：论文指厂商在国际数据库顶会、国际论坛、国际期刊发表的论文，以体现厂商在前沿技术、学术领域的成就。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;招聘岗位数：引入 51JOB 相关招聘数据，根据数据库关键字搜索出每个数据库的岗位数量，体现企业对该数据库人才的需求热度，最后按整体占比计算得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;书籍：引入当当网相关书籍数据，根据数据库关键字搜索出每个数据库的书籍数量，最后按整体占比计算得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DB-Engines 上榜指数：指数据库产品在 DB-Engines 上榜，按排名先后依次降档得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Gartner 市场份额排行及魔力象限：根据 Gartner 发布的最新市场份额排名先后依次降档得分，最新的魔力象限统一得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;IDC 市场份额排行：根据 IDC 发布的最新市场份额排名先后依次降档得分。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89204&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;&lt;span&gt;3. 数据库评估体系的全球化之路&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从上述分析来看，海外与国内的数据库评估体系存在明显的割裂现象。海外评估体系，虽然较为全面，但对中国数据库厂商及产品涉及很少，了解很浅。究其原因，其一是由于海外对中国市场的重视程度不足，对中国的很多情况也不甚了解；二是由于大多数中国数据库厂商以中国市场为主，与海外评估机构在商业、技术生态上均存在较大距离；三则是语言、文化等因素，也在一定程度上妨碍了双方的了解。从国内的评估体系来看，起步较晚，发展势头不错，但同样存在类似问题。目前国内的评估体系中，均不包含海外产品，（甚至开源也不包含），其次针对国内产品受限于调查者身份，也很难深入到商业部分，甚至直达客户侧，同时也缺少对中国数据库厂商全球影响力的关注和解读。在技术趋势上，国内机构关注 OLTP，OLAP 等传统领域评估更多，而对云数据库、开源、数仓，AI 与自动化等数据库创新趋势相对较少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近些年来，国内数据库产业发展迅速，无论从技术、产品到资本层面，越来越多的厂商产品受到海外的关注。一些国际权威的评估机构已考虑为中国数据库独立评测，这也侧面验证了海外对中国数据库厂商的重视。国内数据库行业已逐渐从跟随者、参与者，向局部引领者角色转变。如何参与到全球化进程中，如何共享全球技术生态，如何发挥全球影响力，如何在全球商业布局等，未来都会成为中国数据库厂商需要面对的问题。从全球及国内来看，数据库行业各种势力正在加速洗牌。相较于海外四五十年的数据库发展来说，国内的数据库厂商还稍显稚嫩。但中国数据库厂商正赶上数据库产业变革的重大机遇期，借助开源和云计算，中国数据库有机会在全球市场占据一席之地。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;数据库评估体系同样需要与时俱进，海外评估机构会更多关注到国内的同时，国内评估机构也可以全球化技术视野和创新模式来看待数据库未来的发展。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;通过更多元的、更为创新的评估体系把握产业发展脉络，把握时代机遇，促进行业健康发展，最终也让中国的广大数据库企业用户受益。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.959375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/UpAsF3LicVxrIicia05puxLBia4Mjcs7icOXB056ZQLQpEFvQic4hBUsOQ5leb4R7qKUgag7YEKf9HpC6GMcjfGxcibNA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>39538a6bb8efdbdaf94656a49ac058f9</guid>
<title>虚数有物理意义：中科大潘建伟、南科大范靖云团队首次实验排除实数形式的标准量子力学</title>
<link>https://toutiao.io/k/d290ffc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;white-space: normal; max-width: 100%; letter-spacing: 0.544px; text-size-adjust: auto; background-color: rgb(255, 255, 255); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__0&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-top: 2em; padding-top: 0.5em; padding-bottom: 0.5em; max-width: 100%; border-style: solid none; text-decoration: inherit; border-top-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-top-width: 1px; border-bottom-width: 1px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__1&quot;&gt;&lt;section&gt;&lt;span&gt;机器之心报道&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;编辑：泽南、小舟&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;136&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;量子力学的理论能否只用实数构造？从理论上和实践上，研究人员都得出了否定的答案。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然在高中数学里，大家都接触过虚数这个概念，但它看起来总是那么反直觉：虚数这个名词是 17 世纪数学家笛卡尔提出的，因为当时的观念认为这不是真实存在的数字，其性质被定义为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrPuBTJQCxF7IF9RB4SsugqPs5m1WAguGGjatic1FUfMBB42ibU755a3Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是现如今，为了从根本上描述物质，虚数被证明是必不可少的。它们似乎融入了量子力学的结构，后者是描述分子、原子和亚原子粒子领域的基础理论。最近的两项新实验表明，遵循量子物理学规则的理论需要虚数来描述现实世界。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虚数由负数的平方根产生。它们经常作为数学工具出现在方程式中，以使计算更容易。但是我们可以实际测量的，关于世界的一切都是用实数来描述的，我们也习惯于正常的、非虚的数字。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在量子物理的范畴中其实也是如此。尽管虚数出现在理论的内部运作中，但所有可能的测量都会产生实数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虚数 i 是薛定谔方程必不可少的常数，由此观之，量子力学必须包含虚数。量子理论对复数（虚数和实数之和）的突出使用令其创始人，包括物理学家艾尔温 · 薛定谔（Erwin Schrödinger）感到不安。「从量子理论的早期开始，复数更多地被视为一种数学便利，而不是基本的构建模块，」南方科技大学的物理学家范靖云说道。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;部分物理学家试图仅使用实数来构建量子理论，而使用称为「实数量子力学」的版本来避免使用虚数。但是如果没有对这些理论进行实验测试，我们无法得知虚数在量子物理学中是否真的必要，或者只是一种有用的计算工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一种称为贝尔测量（Bell test）的实验解决了一个不同的量子难题，证明量子力学确实需要粒子之间的奇怪量子联系，也就是量子纠缠。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要了解标准量子理论和类似实数理论之间的区别，你可以思考限制在两个不同位置上的电子。在量子理论中，电子可以处于两个位置的「叠加」中——既不在这个位置，也不是在另一个位置，被观测到在哪只看概率。这种叠加被表示为包含两个维度的抽象空间中的一个点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但这不是普通的空间，也不容易想象。抽象空间中的每个维度都通过一个复数与现实世界中的一个位置相关联，该复数可用于计算在该位置找到电子的概率。随着电子的状态随时间变化，该点在抽象空间中移动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.563&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrBfsJ7tWN2BiaVnkRtcATwic1sxxw41lfjhskx7Tn6ATvqh0BSo39ISibQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具有两个真实维度的类比空间不足以捕捉该电子可以表现出的所有现象，因为它无法编码两个位置的所有可能叠加。然而，具有四个真实维度的空间能够完整指出电子行为的全部范围。这个事实可以概括为：任何单个量子系统的量子物理学都可以在一个真实空间中完全表示，该真实空间的维度数恰好是其抽象空间的两倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;维也纳量子光学和信息研究所的理论物理学家 Miguel Navascués 表示：「我们已开始思考这种实验是否也能反驳实数量子力学。」他和来自奥地利、西班牙和瑞士等国家的科学家在 12 月 15 日发表于《自然》杂志的论文《Quantum theory based on real numbers can be experimentally falsified》中制定了一项实验计划。该论文的一作是量子信息科学的理论物理学家 Marc-Olivier Renou。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文链接：https://www.nature.com/articles/s41586-021-04160-4&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实验计划中，研究人员将从两个不同的来源发送成对的纠缠粒子给三个不同的人，根据传统的物理术语命名为 Alice、Bob 和 Charlie。Alice 接收到一个粒子，并且可以使用她选择的各种设置对其进行测量，Charlie 也这样做。Bob 接收到两个粒子并执行一种特殊类型的测量来纠缠 Alice 和 Charlie 接收到的粒子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;没有虚数的实数量子理论将预测与标准量子物理学不同的结果，从而使实验能够区分哪个是正确的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7328699106256207&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrR7AJGpChFT5VVOfkUr9RMNFHwGuwibULwzWU0eicULTCFtUicvsmeXa1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1007&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;分离实数量子理论和复数量子理论的网络场景。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;范靖云及其同事使用光子和光粒子进行了这样的实验，他们在 1 月 24 日发表在物理学顶级期刊《物理评论快报》（Physical Review Letters，PRL）上的论文《Testing Real Quantum Theory in an Optical Quantum Network》中进行了报告。通过将 Alice、Charlie 和 Bob 的结果以多种度量方式进行比较，范靖云、Navascués 及其同事表明这些数据只能用包含复数的量子理论来描述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.259375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrpIkqt0ctGEHpCuUYzMXYJBM11bb7DwtXicn9kthnRhibyDCFVzNKNj3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文链接：https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.128.040402&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与此同时，中科大潘建伟团队基于相同的概念，使用由超导体制成的量子计算机进行了一项实验。这项研究也发现量子物理学需要复数，论文《Ruling Out Real-Valued Standard Formalism of Quantum Theory》也在近日的 PRL 上发表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.26640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrkcDXtYPOXPhYiasCTSTTlIgByjibia4DuadicNC4EK0JkdE4QCq49V6V0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文链接：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.128.040403&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;潘建伟、陆朝阳、朱晓波等和西班牙塞维利亚大学 Cabello 教授合作，利用超高精度超导量子线路实现确定性纠缠交换，以超过 43 个标准差的实验精度证明了实数无法完整描述标准量子力学，确立了复数的客观实在性。陈明城、王粲和刘丰铭是该论文的共同一作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中科大在新闻稿中介绍道：随着量子力学理论的发展，复数逐渐表现出某种直觉上的不可排除性。理论上，作为量子力学基石的薛定谔方程和海森堡对易关系其本身就是依赖于复数写出的。而在实验中，人们直接测量到了波函数的实部与虚部。这说明复数可能不是一个主观引入的计算符号，而是可以实验检测的物理实在。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.69453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicvJxpNs4WW5SJyiafXpnBLrf2CEBuq8uWN9Lfdp5ic1G8Av17N2uRsBThjspuzNo0dDDgb8YGyyIibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;在理论框架下，实数形式的界限为 7.66，而实验测试结果为 8.09，超过判据 43 个标准差。实验结论支持量子物理需要使用复数。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中科大表示，该实验证明了实数无法完整描述标准量子力学，确立了复数的客观实在性。该论文的作者之一、中国科学技术大学的量子物理学家陆朝阳说：「我们很好奇为什么复数是必要的，并且在量子力学中发挥着重要作用。」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 &lt;span&gt;Navascués&lt;/span&gt; 等人的实验方案提出不久后，潘建伟等人使用超导量子电路，范靖云等人使用线性光学，分别验证了理论。但并未参与这项研究的加州劳伦斯伯克利国家实验室的理论物理学家 Jerry Finkelstein 指出：结果并未排除所有避开虚数的理论。该研究只排除了某些基于实数的理论，即那些仍然遵循量子力学惯例的理论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过使用打破标准量子规则的理论，仍然可以在没有虚数的情况下解释实验结果。然而 Jerry Finkelstein 说：「虽然这些理论遇到一些概念问题时会变得『丑陋』，但如果你愿意忍受『丑陋』，那么你就可以拥有一套实数量子理论。」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尽管存在质疑，但许多物理学家一致认为：「复数对于量子理论是必要的」这一新发现令人信服。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;诚如美国国家标准技术研究所的物理学家 Krister Shalm 所说：「当你问量子力学『为什么会这样』时，这就已经很有趣了。而询问『量子理论是否可以更简单』，或者『它是否包含任何不必要的东西』这些都是更加有趣和发人深省的问题。」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;参考链接：&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://www.sciencenews.org/article/quantum-physics-imaginary-numbers-math-reality&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://www.nature.com/articles/d41586-021-03678-x&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://news.ustc.edu.cn/info/1055/78317.htm&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1028&quot; data-ratio=&quot;1.77734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicbHHfrYKw4Mswy4xNNmhEwl19xZSzicTNt91J7hZj8O6Tcicj9HIyPydasCuDr7hC6Gq6iaJsDmWEnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;© THE END &lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转载请联系本公众号获得授权&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投稿或寻求报道：content@jiqizhixin.com&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>16340e23d856953d1ca67eeb068a0fea</guid>
<title>延时消息常见实现方案</title>
<link>https://toutiao.io/k/6owg7au</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;延时消息（定时消息）指的在&lt;strong&gt;分布式异步消息场景&lt;/strong&gt; 下，生产端发送一条消息，希望在指定延时或者指定时间点被消费端消费到，而不是立刻被消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;延时消息适用的业务场景非常的广泛，在分布式系统环境下，延时消息的功能一般会在下沉到中间件层，通常是 MQ 中内置这个功能或者内聚成一个公共基础服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文旨在探讨常见延时消息的实现方案以及方案设计的优缺点。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;推荐下自己做的 Spring Boot 的实战项目：&lt;/p&gt;&lt;p&gt;https://github.com/YunaiV/ruoyi-vue-pro&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;这里讨论的外部存储指的是在 MQ 本身自带的存储以外又引入的其他的存储系统。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于外部存储的方案本质上都是一个套路，将 MQ 和 延时模块 区分开来，延时消息模块是一个独立的服务/进程。延时消息先保留到其他存储介质中，然后在消息到期时再投递到 MQ。当然还有一些细节性的设计，比如消息进入的延时消息模块时已经到期则直接投递这类的逻辑，这里不展开讨论。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.371875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfc1dvRZB2y2VdmzGRY4GbAdxOgl5Y9Cg538R2CgmGl6OL3pZR6Xp2DagGiaB7CFibGfTmeYfoHejpMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下述方案不同的是，采用了不同的存储系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于关系型数据库（如MySQL）延时消息表的方式来实现。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;`delay_msg`&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;`id`&lt;/span&gt; &lt;span&gt;bigint&lt;/span&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT,&lt;br/&gt;  &lt;span&gt;`delivery_time`&lt;/span&gt; DATETIME &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;投递时间&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`payloads`&lt;/span&gt; &lt;span&gt;blob&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;消息内容&#x27;&lt;/span&gt;,&lt;br/&gt;  PRIMARY &lt;span&gt;KEY&lt;/span&gt; (&lt;span&gt;`id`&lt;/span&gt;),&lt;br/&gt;  &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;`time_index`&lt;/span&gt; (&lt;span&gt;`delivery_time`&lt;/span&gt;)&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过定时线程定时扫描到期的消息，然后进行投递。定时线程的扫描间隔理论上就是你延时消息的最小时间精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocksDB 的方案其实就是在上述方案上选择了比较合适的存储介质。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocksDB 在笔者之前的文章中有聊过，LSM 树更适合大量写入的场景。滴滴开源的DDMQ中的延时消息模块 Chronos 就是采用了这个方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DDMQ 这个项目简单来说就是在 RocketMQ 外面加了一层统一的代理层，在这个代理层就可以做一些功能维度的扩展。延时消息的逻辑就是代理层实现了对延时消息的转发，如果是延时消息，会先投递到 RocketMQ 中 Chronos 专用的 topic 中。延时消息模块 Chronos 消费得到延时消息转储到 RocksDB，后面就是类似的逻辑了，定时扫描到期的消息，然后往 RocketMQ 中投递。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfc1dvRZB2y2VdmzGRY4GbAdLYrDpSP3EbF7Qh2kTxefxC6gAl7biaPm5LwKibxpykpUMTIia8o2n6ib1g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案老实说是一个比较重的方案。因为基于 RocksDB 来实现的话，从数据可用性的角度考虑，你还需要自己去处理多副本的数据同步等逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RocksDB LSM 树很适合消息场景的大量写入；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现方案较重，如果你采用这个方案，需要自己实现 RocksDB 的数据容灾逻辑；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来聊聊 Redis 的方案。下面放一个比较完善的方案。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;本方案来源于：基于Redis实现延时队列服务&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.553125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfc1dvRZB2y2VdmzGRY4GbAdNHqouibxRMZZunDsicWMTlQPk1nQQiaZC5uB2icl7q7W7YuSQZPcwsgyMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Messages Pool 所有的延时消息存放，结构为KV结构，key为消息ID，value为一个具体的message（这里选择Redis Hash结构主要是因为hash结构能存储较大的数据量，数据较多时候会进行渐进式rehash扩容，并且对于HSET和HGET命令来说时间复杂度都是O(1)）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Delayed Queue是16个有序队列（队列支持水平扩展），结构为ZSET，value 为 messages pool中消息ID，score为过期时间**（分为多个队列是为了提高扫描的速度）**&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Worker 代表处理线程，通过定时任务扫描 Delayed Queue 中到期的消息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案选用 Redis 存储在我看来有几点考虑，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Redis ZSET 很适合实现延时队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能问题，虽然 ZSET 插入是一个 O(logn) 的操作，但是Redis 基于内存操作，并且内部做了很多性能方面的优化。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这个方案其实也有需要斟酌的地方，上述方案通过创建多个 Delayed Queue 来满足对于并发性能的要求，但这也带来了多个 Delayed Queue 如何在多个节点情况下均匀分配，并且很可能出现到期消息并发重复处理的情况，是否要引入分布式锁之类的并发控制设计？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在量不大的场景下，上述方案的架构其实可以蜕化成主从架构，只允许主节点来处理任务，从节点只做容灾备份。实现难度更低更可控。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述几个方案中，都通过线程定时扫描的方案来获取到期的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定时线程的方案在消息量较少的时候，会浪费资源，在消息量非常多的时候，又会出现因为扫描间隔设置不合理导致延时时间不准确的问题。可以借助 JDK Timer 类中的思想，通过 wait-notify 来节省 CPU 资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取中最近的延时消息，然后wait(执行时间-当前时间)，这样就不需要浪费资源到达时间时会自动响应，如果有新的消息进入，并且比我们等待的消息还要小，那么直接notify唤醒，重新获取这个更小的消息，然后又wait，如此循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来讲讲目前自带延时消息功能的开源MQ，它们是如何实现的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 开源版本支持延时消息，但是只支持 18 个 Level 的延时，并不支持任意时间。只不过这个 Level 在 RocketMQ 中可以自定义的，所幸来说对普通业务算是够用的。默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18个level。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通俗的讲，设定了延时 Level 的消息会被暂存在名为&lt;code&gt;SCHEDULE_TOPIC_XXXX&lt;/code&gt;的topic中，并根据 level 存入特定的queue，queueId = delayTimeLevel – 1，&lt;strong&gt;即一个queue只存相同延时的消息，保证具有相同发送延时的消息能够顺序消费。&lt;/strong&gt; broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是整个实现方案的示意图，红色代表投递延时消息，紫色代表定时调度到期的延时消息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfc1dvRZB2y2VdmzGRY4GbAdNicL8V0ibsB2mnxp1xr6yLn8kibdbhr8CVicaWrzdquKialia8of5L8QLgiaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Level 数固定，每个 Level 有自己的定时器，开销不大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 Level 相同的消息放入到同一个 Queue 中，保证了同一 Level 消息的顺序性；不同 Level 放到不同的 Queue 中，保证了投递的时间准确性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过只支持固定的Level，将不同延时消息的排序变成了固定Level Topic 的追加写操作&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Level 配置的修改代价太大，固定 Level 不灵活&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CommitLog 会因为延时消息的存在变得很大&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 支持“任意时间”的延时消息，但实现方式和 RocketMQ 不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通俗的讲，Pulsar 的延时消息会直接进入到客户端发送指定的 Topic 中，然后在堆外内存中创建一个基于时间的优先级队列，来维护延时消息的索引信息。延时时间最短的会放在头上，时间越长越靠后。在进行消费逻辑时候，再判断是否有到期需要投递的消息，如果有就从队列里面拿出，根据延时消息的索引查询到对应的消息进行消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果节点崩溃，在这个 broker 节点上的 Topics 会转移到其他可用的 broker 上，上面提到的这个优先级队列也会被重建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 Pulsar 对于 Pulsar 延时消息的示意图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfc1dvRZB2y2VdmzGRY4GbAdwDtHpeftSR1wSjCibdLluEkW1gCKria5G9LuR1BL6qGXmk6DvyvlOBZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;乍一看会觉得这个方案其实非常简单，还能支持任意时间的消息。但是这个方案有几个比较大的问题&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内存开销：&lt;/strong&gt; 维护延时消息索引的队列是放在堆外内存中的，并且这个队列是以订阅组（Kafka中的消费组）为维度的，比如你这个 Topic 有 N 个订阅组，那么如果你这个 Topic 使用了延时消息，就会创建 N 个 队列；并且随着延时消息的增多，时间跨度的增加，每个队列的内存占用也会上升。（是的，在这个方案下，支持任意的延时消息反而有可能让这个缺陷更严重）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;故障转移之后延时消息索引队列的重建时间开销：&lt;/strong&gt; 对于跨度时间长的大规模延时消息，重建时间可能会到小时级别。（摘自 Pulsar 官方公 众号文章）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;存储开销&lt;/strong&gt; ：延时消息的时间跨度会影响到 Pulsar 中已经消费的消息数据的空间回收。打个比方，你的 Topic 如果业务上要求支持一个月跨度的延时消息，然后你发了一个延时一个月的消息，那么你这个 Topic 中底层的存储就会保留整整一个月的消息数据，即使这一个月中99%的正常消息都已经消费了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于前面第一点和第二点的问题，社区也设计了解决方案，在队列中加入时间分区，Broker 只加载当前较近的时间片的队列到内存，其余时间片分区持久化磁盘，示例图如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.59375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfc1dvRZB2y2VdmzGRY4GbAdL4LvmEI9OC3sE5nZibQYichH2hucUuex3xAw9fwwBgU48NDeuc09AZ7g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是目前，这个方案并没有对应的实现版本。可以在实际使用时，规定只能使用较小时间跨度的延时消息，来减少前两点缺陷的影响。另外，因为内存中存的并不是延时消息的全量数据，只是索引，所以可能要积压上百万条延时消息才可能对内存造成显著影响，从这个角度来看，官方暂时没有完善前两个问题也可以理解了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于第三个问题，估计是比较难解决的，需要在数据存储层将延时消息和正常消息区分开来，单独存储延时消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;QMQ提供任意时间的延时/定时消息，你可以指定消息在未来两年内(可配置)任意时间内投递。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把 QMQ 放到最后，是因为我觉得 QMQ 是目前开源 MQ 中延时消息设计最合理的。里面设计的核心简单来说就是 &lt;strong&gt;多级时间轮 + 延时加载 + 延时消息单独磁盘存储&lt;/strong&gt; 。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;如果对时间轮不熟悉的可以阅读笔者的这篇文章 从 Kafka 看时间轮算法设计&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;QMQ的延时/定时消息使用的是两层 hash wheel 来实现的。第一层位于磁盘上，每个小时为一个刻度(默认为一个小时一个刻度，可以根据实际情况在配置里进行调整)，每个刻度会生成一个日志文件(schedule log)，因为QMQ支持两年内的延时消息(默认支持两年内，可以进行配置修改)，则最多会生成 2 * 366 * 24 = 17568 个文件(如果需要支持的最大延时时间更短，则生成的文件更少)。&lt;strong&gt;第二层在内存中，当消息的投递时间即将到来的时候，会将这个小时的消息索引(索引包括消息在schedule log中的offset和size)从磁盘文件加载到内存中的hash wheel上，内存中的hash wheel则是以500ms为一个刻度&lt;/strong&gt; 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.55&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfc1dvRZB2y2VdmzGRY4GbAd9tPibicibnGGVicg9DZk0tUj5OcNZVtTjydBOxgtxm4lNP4DEKY7HDg4Xg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总结一下设计上的亮点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;时间轮算法适合延时/定时消息的场景，省去延时消息的排序，插入删除操作都是 O(1) 的时间复杂度；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过多级时间轮设计，支持了超大时间跨度的延时消息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过延时加载，内存中只会有最近要消费的消息，更久的延时消息会被存储在磁盘中，对内存友好；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;延时消息单独存储（schedule log），不会影响到正常消息的空间回收；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;推荐下自己做的 Spring Cloud 的实战项目：&lt;/p&gt;&lt;p&gt;https://github.com/YunaiV/onemall&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文汇总了目前业界常见的延时消息方案，并且讨论了各个方案的优缺点。希望对读者有所启发。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>