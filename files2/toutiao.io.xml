<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>57f56a1e4e38799eb7ab696d3c5f59d1</guid>
<title>我不能没有的 5 个 Vue.js 库</title>
<link>https://toutiao.io/k/l04ibvu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;1.Click Off to Close&lt;/h2&gt;&lt;section&gt;&lt;span&gt;有的时候，我们需要在用户点击元素之外的时候触发一个事件。最常见的用例是当你想通过点击关闭一个下拉框或对话框时。这是一个必不可少的包，几乎在我构建的每个应用中都会用到。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首选：&lt;strong&gt;vue-clickaway&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.343&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WYoaOn5t0AOUCI5wdH14guJwREX4cO5L1aIfJpkoe1cGNfW94R5KFticPvwr2lVHuLKChzxpbGU7HMNbiaiaZpt1w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;https://github.com/simplesmiler/vue-clickaway&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;我通常会将它安装在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;main.js&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中，以便在我的应用程序中使用。如果你只在一个或两个页面上使用它，你可能会想单独导入它。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你真的单独导入，请记住，指令需要在指令下暴露。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;✅ &lt;code&gt;&lt;span&gt;directives: { onClickaway }&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;而不是组件：&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❌ &lt;code&gt;&lt;span&gt;components: { onClickaway }&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;使其全局可用（在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;main.js&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中）：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { directive &lt;span&gt;as&lt;/span&gt; onClickaway } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;vue-clickaway&#x27;&lt;/span&gt;&lt;br/&gt;Vue.directive(&lt;span&gt;&#x27;on-clickaway&#x27;&lt;/span&gt;, onClickaway)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在模板中：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4517937219730942&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5LcD1ejkKgUBFYPyn8gmUb2dKB26G9zk4c2UCHl8xrn7ib5kIGKHcfM6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;想象一下，我有一个完整的选择框，其中包含 &lt;/span&gt;&lt;code&gt;&lt;span&gt;li&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 元素列表（此处未显示）。上面的按钮用于触发我的自定义选择框项目列表，当我在该元素外点击时，会触发一个关闭选项列表的方法。这比强迫用户始终单击元素右上角处的“X”按钮要好得多。我们只需将以下内容添加到按钮即可获得此功能：&lt;/span&gt;&lt;code&gt;&lt;span&gt;v-on-clickaway = &quot;closeMethodName&quot;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;你应该总是在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;close&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法中使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;vue-clickaway&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，而不是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;toggle&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法。我的意思是这个方法连接到&lt;/span&gt;&lt;code&gt;&lt;span&gt;v-on-clickaway&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 应该是这样的:&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;closeMethod() {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.showSomething = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而不是这样：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;toggleMethod() {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.showSomething = !&lt;span&gt;this&lt;/span&gt;.showSomething&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;如果你使用了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;toggle&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，那么每当你在该元素外点击时，无论你点击什么，它都会打开，然后一遍遍地关闭该元素。这很可能不是你想要的结果，所以请记住使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;close&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法来防止这种情况发生。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;2.Toasts (Notification Bar)&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首选：&lt;strong&gt;vue-toastification&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.495&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WYoaOn5t0AOUCI5wdH14guJwREX4cO5LiaZLPibbq2z5WWickAMysdSiafVfDl8XG6u6OxIYCb1Wvk7ZTCWG9NyKicQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;https://maronato.github.io/vue-toastification/&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;你有很多toast和类似通知的选择，但我是Maronato的vue-toastification的忠实粉丝。它提供了大量的选项来覆盖你的大部分边界情况，而且样式和动画导致了出色的用户体验，远远超过其他软件包。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Vue-toastification提供了几种在其文档中使用它的方法。你可以在组件级别，全局级别甚至在Vuex内执行此操作，如果你希望根据状态或与服务器相关的操作显示toasts。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;全局使用（在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;main.js&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中）：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; Toast &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;vue-toastification&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Toast styles&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&#x27;vue-toastification/dist/index.css&#x27;&lt;/span&gt;&lt;br/&gt;Vue.use(Toast, {&lt;br/&gt;  &lt;span&gt;transition&lt;/span&gt;: &lt;span&gt;&#x27;Vue-Toastification__bounce&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;maxToasts&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;newestOnTop&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: &lt;span&gt;&#x27;top-right&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;timeout&lt;/span&gt;: &lt;span&gt;2000&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;closeOnClick&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;pauseOnFocusLoss&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;pauseOnHover&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;draggable&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;draggablePercent&lt;/span&gt;: &lt;span&gt;0.7&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;showCloseButtonOnHover&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;hideProgressBar&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;closeButton&lt;/span&gt;: &lt;span&gt;&#x27;button&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;icon&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;rtl&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;你可以在每个组件中单独控制样式，但在上面的案例中，我通过将它导入 &lt;/span&gt;&lt;code&gt;&lt;span&gt;main.js&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，然后在那里设置我想使用的选项，使它在我的应用程序中到处可用，这使我不必每次都编写相同的选项属性。Vue-toastification有一个很好的在线演示，在这里你可以看到每个选项属性的结果，只需要复制粘贴你想要的选项，就像我上面做的那样。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;选项1：在组件（模板）中使用Toast&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; @&lt;span&gt;click&lt;/span&gt;=&lt;span&gt;&quot;showToast&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Show toast&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2710997442455243&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5LEmRKwLvrtluCHtfmE9F1IQ5SWMlyMS9Cz6MuAJp1GQpkgPKDfqD7XQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1173&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;选项2：在Vuex action中发现错误（或成功）时调用Toast&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4110738255033557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5Lb26KUYk2p31UlC5cjOHiaqOzOSEGOyU3Rr2micziaia2FKq69Oft6x8ibtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1192&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;你只需将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.error&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 改为 .success&lt;/span&gt;&lt;code&gt;&lt;span&gt;，&lt;/span&gt;&lt;/code&gt;&lt;span&gt;.info&lt;/span&gt;&lt;code&gt;&lt;span&gt;，&lt;/span&gt;&lt;/code&gt;&lt;span&gt;.warning 即可更改所需的Toast类型，也可以将其完全删除以作为默认的Toast通知。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Toasts可以让你根据实时状态的变化或者发生了不可预见的错误来显示消息，这大大改善了用户的体验。Toasts提供了比模态或丑陋的提示框更好的视觉指示，例如，用户必须提供一个额外的点击来关闭。用户会很感激你给他们一个视觉上的提示，让他们知道出了什么问题，防止他们盯着屏幕茫然地等待一些永远不会发生的事情。确认他们执行的操作是否成功完成也很有用。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1603699772392&quot; data-category_id_list=&quot;48|26|49|1|55|8|47|35|5|6|7|24|37|11|50|54|53|52|42|29|43|16|17|51|36&quot; data-id=&quot;1603699772392&quot;/&gt;&lt;span&gt;3.Tables&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首选：&lt;strong&gt;vue-good-table&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5Lial31Wn8ggKf3l3spzxP2Cd34YIKYpforxficM4te6bAM80diayIEw5dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;https://xaksis.github.io/vue-good-table&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;表格是许多Web应用程序的重要组成部分，选择错误的表格会让你陷入无尽的痛苦之中。尝试了很长的包选项列表后，我相信vue-good-table将解决你大部分的表需求。它不仅仅是为了好玩才叫“good-table”。它真的很好，提供了更多的选择和功能，超出了你的能力范围。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在以下情况下，我将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;:rows&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 数据绑定到名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getOrderHistory&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的Vuex getter。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7504159733777038&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5L6AjNcRAO3ibDHlA0xcx3teWr1tPQpQUc4HMhQSoATTy5818burKRcZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在本地 &lt;/span&gt;&lt;code&gt;&lt;span&gt;data()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中定义我的列：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1537822111388196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5L53rJJoEtdhTLX2jRicJFxqmhmy3AdCFUcY5NfeYKAgohEOcPyUGb0Lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1203&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;label&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是显示的列标题，而 &lt;/span&gt;&lt;code&gt;&lt;span&gt;field&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是我在Vuex getter中绑定的数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在上图中，我还使用了vue-good-table的一些自定义选项，比如设置我的日期的输入和输出格式(这让我可以把服务器提供的一个很长的时间戳改成对我的用户来说更易读的东西)。我还使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;formatFn&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来格式化我的价格，调用了一个我命名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;toLocale&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的单独方法，然后我通过绑定 &lt;/span&gt;&lt;code&gt;&lt;span&gt;tdClass&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 到我在 local &lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;style&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中设置的类来定制每个单元格的外观。Vue-good-table确实内置了无穷的可定制性，他们已经覆盖了非常广泛的边缘案例。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Vue-good-table还可以与自定义模板配合使用，因此你可以轻松地将按钮，选择框或您喜欢的其他任何东西注入到表格的单元格中。为此，你只需使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 定义应将其注入的位置。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要添加另一个自定义列，只需在你的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 标签后面添加一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;v-else-if&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（在上面的例子中是一个跨度），然后在那里添加第二个自定义模板的逻辑。无论你需要什么，vue-good-table都能满足你的需求。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;4.Date Picker&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首选：&lt;strong&gt;vue2-datepicker&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WYoaOn5t0AOUCI5wdH14guJwREX4cO5LKxHzrMFTuW7ZKibHYA9BE47iabFiaXmD8aUQYdA1kH137ibU6EhsBqlKgA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;https://mengxiong10.github.io/vue2-datepicker/index.html#Basic&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;啊，日期选择器，这是许多应用程序的重要组成部分。在这个列表中，日期选择器的选择比其他任何东西都多，但Mengxiong打造的vue2-datepicker是我不断回归的一个选择。它的风格简单，提供了广泛的选择日期和日期范围的选项，并被包装在一个光滑和用户友好的UI中。它甚至支持i18n语言和日期格式的本地化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;尽管包名为vue2-datepicker，但将这个包(或这里列出的其他包)添加到Vue 3.0应用程序中应该没有问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在组件或视图中导入，使其可以使用。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; DatePicker &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;vue2-datepicker&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// styles&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&#x27;vue2-datepicker/index.css&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在模板中：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42907385697538103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5Ljel0nBuHBhxUycYJtCQoh2MoaWN8gLYdvtSk5Dse68orTpbmsRPRBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;853&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;在这里，我使用的是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;range&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 选项，允许用户选择日期范围，并将用户输入的日期 &lt;/span&gt;&lt;code&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 以一个名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;dateRange&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的数据值绑定。然后，vue-good-table（如下）使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;dateRange&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对我的表的结果进行排序。我还使用事件选项 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@clear&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@input&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来触发重置表（resetList）或发送服务器请求表数据（searchDate）的方法。Vue2-datepicker提供了更多的选项和事件，以方便你的使用，但这些是我发现自己最经常使用的。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;5.User Ratings&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首选：&lt;strong&gt;vue-star-rating&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WYoaOn5t0AOUCI5wdH14guJwREX4cO5LKiakCO1BTJZzbOIg3Hlias1XwvjXord6CVlN3TqcO8I3ibqwoowKIrFvA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;https://github.com/craigh411/vue-star-rating&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;虽然你可能不会在每个项目中都使用这个功能，但对于任何需要用户评级元素的网站（比如Amazon或Rotten Tomatoes），vue-star-rating是我的首选。自己创建看似是一件微不足道的事情，但当你进入细节后，星级评定很快就会变得比你预期的要复杂。如果需要特殊功能，它可以让你使用自定义SVG形状，并且可以轻松自定义大小，间距和颜色。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过这些选项，可以很容易地将用户选择的评级 &lt;/span&gt;&lt;code&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 绑定到任何你想使用的地方，你可以通过一个prop将评级设置为可更改或只读。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你发现需要更多选择，请查看创建者的扩展软件包vue-rate-it。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在模板中（带有选项）：&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39558417663293466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5LiaLSVgFBdFosIKuKBgjMOfKK2CFf9xDiaIOMG1YfkprLicjgA1VmgI2lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1087&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;将其导入到组件或视图中：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3274745605920444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOUCI5wdH14guJwREX4cO5LzDdjibic2Sd4GjxjS7ia6Z99lsQy6Po1FBEOSe4hh5PGemCLltkg8mxow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1081&quot;/&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOPiaqWez1sKrh7Hffjoia7y8zkhic56DPic8FsoheTZljsrr5rpFMFcp7OgSZoOuuLKdXkWmhKibHia0fQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5c35229d123478a013caee58df401773</guid>
<title>13 张图彻底搞懂分布式系统服务注册与发现原理</title>
<link>https://toutiao.io/k/f9kkb5t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;引入服务注册与发现组件的原因&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看一个问题，假如现在我们要做一个商城项目，作为架构师的你应该怎样设计系统的架构？你心里肯定在想：这还不容易直接照搬淘宝的架构不就行了。但在现实的创业环境中一个项目可能是九死一生，如果一开始投入巨大的人力和财力，一旦项目失败损失就很大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一位有经验的架构师需要结合公司财力、人力投入预算等现状选择最适合眼下的架构才是王道。大型网站都是从小型网站发展而来，架构也是一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任何一个大型网站的架构都不是从一开始就一层不变的，而是随着用户量和数据量的不断增加不断迭代演进的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在架构不断迭代演进的过程中我们会遇到很多问题，&lt;strong&gt;技术发展的本质就是不断发现问题再解决问题，解决问题又发现问题&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;单体架构&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在系统建立之初可能不会有特别多的用户，将所有的业务打成一个应用包放在tomcat容器中运行，与数据库共用一台服务器，这种架构一般称之为单体架构。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8589743589743589&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1Yy1lpDpnSgrIUzMCUAShjPozEcMOJlPM9KEZoViblj0qF7TJs70DibHFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;780&quot;/&gt;&lt;figcaption&gt;单体架构-应用和数据库共同部署&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在初期这种架构的效率非常高，根据用户的反馈可以快速迭代上线。但是随着用户量增加，一台服务的内存和CPU吃紧，很容易造成瓶颈，新的问题来了怎么解决呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;应用与数据分离&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着用户请求量增加，一台服务器的内存和CPU持续飙升，用户请求响应时间变慢。这时候可以考虑将应用与数据库拆开，各自使用一台服务器，你看问题又解决了吧。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0881542699724518&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YoL2Pibpkhp9Wo5grIzjFXia28tSHKjqHia8W2Gh58wxBuCJdgJlNKDwHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;&lt;figcaption&gt;单体架构-应用和数据库分离&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;突然有一天扫地阿姨不小心碰了电线，其中一台服务器掉电了，用户所有的请求都报错，随之而来的是一系列投诉电话。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;集群部署&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单实例很容易造成单点问题，比如遇到服务器故障或者服务能力瓶颈，那怎么办？聪明的你肯定想到了，用集群呀。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8782287822878229&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YBIgyiasm5iamgdAvJEn18AR1xPlfjcicLIPibyR1bPpYEbncPS2xibOzYVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1084&quot;/&gt;&lt;figcaption&gt;应用集群部署&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集群部署是指将应用部署在多个服务器或者虚机上，用户通过服务均衡随机访问其中的一个实例，从而使多个实例的流量均衡，如果一个实例出现故障可以将其下线，其他实例不受影响仍然可以对外提供服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着用户数量快速增加，老板决定增加投入扩大团队规模。开发团队壮大后效率并没有得到显著的提高，以前小团队可以一周迭代上线一次，现在至少需要两到三周时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务逻辑越来越复杂，代码间耦合很严重，修改一行代码可能引入几个线上问题。架构师意识到需要进行架构重构。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;微服务架构&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当单体架构演进到一定阶段后开发测试的复杂性都会成本增加，团队规模的扩大也会使得各自工作耦合性更严重，牵一发而动全身就是这种场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单体架构遇到瓶颈了，微服务架构就横空出世了。微服务就是将之前的单体服务按照业务维度进行拆分，拆分粒度可大可小，拆分时机可以分节奏进行。最佳实践是先将一些独立的功能从单体中剥离出来抽成一个或多个微服务，这样可以保障业务的连续性和稳定性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8771929824561403&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YvlySHf3wnCtdbvSDx4JBV4YJJuXbvrF1DXmN3hMLBcHLGvOk4zFTEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1368&quot;/&gt;&lt;figcaption&gt;微服务架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图将一个商用应用拆分为六个独立微服务。六个微服务可以使用Docker容器化进行多实例部署。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构演化到这里遇到了一个难题，如果要查询用户所有的订单，用户服务可能会依赖订单服务，用户服务如何与订单服务交互呢？订单服务有多个实例该访问哪一个？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常有几种解决办法：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）服务地址硬编码&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务的地址写死在数据库或者配置文件，通过访问DNS域名进行寻址路由。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.68561872909699&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1Yw9zpILmDibILP43qdWrBaQuOiaLV5HlRssCmaMEV2yPzHY2ksgQ6FrQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1196&quot;/&gt;&lt;figcaption&gt;服务元数据硬编码&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务B的地址硬编码在数据库或者配置文件中，服务A首先需要拿到服务B的地址，然后通过DNS服务器解析获取其中一实例的真实地址，最后可以向服务B发起请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果遇到大促活动需要对服务实例扩容，大促完需要对服务实例进行下线，运维人员要做大量的手工操作，非常容易误操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）服务动态注册与发现&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务地址硬编码还有一个非常致命的问题，如果一台实例挂了，运维人员可能不能及时感知到，导致一部分用户的请求会异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入服务注册与发现组件可以很好解决上面遇到的问题，避免过多的人工操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构演进总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单体架构中一个应用程序就是一个服务包，包内的模块通过函数方法相互调用，模型足够简单，根本没有服务注册和发现一说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务架构中会将一个应用程序拆分为多个微服务，微服务会部署在不同的服务器、不同的容器、甚至多数据中心，微服务间要相互调用，服务注册和发现成为了一个不可或缺的组件。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务注册与发现基本原理&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务注册与发现是分为注册和发现两个关键的步骤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;服务注册&lt;/strong&gt;：服务进程在注册中心注册自己的元数据信息。通常包括主机和端口号，有时还有身份验证信息，协议，版本号，以及运行环境的信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;服务发现&lt;/strong&gt;：客户端服务进程向注册中心发起查询，来获取服务的信息。服务发现的一个重要作用就是提供给客户端一个可用的服务列表。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务注册&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务注册有两种形式：客户端注册和代理注册。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;客户端注册&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端注册是服务自己要负责注册与注销的工作。当服务启动后注册线程向注册中心注册，当服务下线时注销自己。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22934232715008432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YibU8A8rBNr7YzicTNU6vT2xhtzmDGb4yIZvU6xmK2CtRUadT3NIujl4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1186&quot;/&gt;&lt;figcaption&gt;客户端注册&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的缺点是注册注销逻辑与服务的业务逻辑耦合在一起，如果服务使用不同语言开发，那需要适配多套服务注册逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代理注册&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代理注册由一个单独的代理服务负责注册与注销。当服务提供者启动后以某种方式通知代理服务，然后代理服务负责向注册中心发起注册工作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.32371794871794873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YiavZKfZPwyWXibjiaWVtQP1mb8hFXKpX5KHibMtTbvFAQV0Nc5rwknLx8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1248&quot;/&gt;&lt;figcaption&gt;代理注册&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的缺点是多引用了一个代理服务，并且代理服务要保持高可用状态。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务发现&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务发现也分为客户端发现和代理发现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;客户端发现&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端发现是指客户端负责向注册中心查询可用服务地址，获取到所有的可用实例地址列表后客户端根据负载均衡算法选择一个实例发起请求调用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4648729446935725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1Y604U6SEL81XhRYpuubvaB1B89eZUNHYz0wnvVGrRqFIZB8yRGRIhyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1338&quot;/&gt;&lt;figcaption&gt;客户端发现&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式非常直接，客户端可以控制负载均衡算法。但是缺点也很明显，获取实例地址、负载均衡等逻辑与服务的业务逻辑耦合在一起，如果服务发现或者负载平衡有变化，那么所有的服务都要修改重新上线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代理发现&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代理发现是指新增一个路由服务负责服务发现获取可用的实例列表，服务消费者如果需要调用服务A的一个实例可以直接将请求发往路由服务，路由服务根据配置好的负载均衡算法从可用的实例列表中选择一个实例将请求转发过去即可，如果发现实例不可用，路由服务还可以自行重试，服务消费者完全不用感知。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3880407124681934&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YKK0I3aW4URJEb3uibncYDb70BQbRDsiasGw6WTuiaY0ARaeayY8p6xStQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1572&quot;/&gt;&lt;figcaption&gt;代理路由服务注册&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;心跳机制&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务有多个实例，其中一个实例出现宕机，注册中心是可以实时感知到，并且将该实例信息从列表中移出，也称为摘机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何实现摘机？业界比较常用的方式是通过心跳检测的方式实现，心跳检测有&lt;strong&gt;主动&lt;/strong&gt;和&lt;strong&gt;被动&lt;/strong&gt;两种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;被动检测&lt;/strong&gt;是指服务主动向注册中心发送心跳消息，时间间隔可自定义，比如配置5秒发送一次，注册中心如果在三个周期内比如说15秒内没有收到实例的心跳消息，就会将该实例从列表中移除。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5235294117647059&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1Ysqr2CSsoNpReXCmg2zFTLCMuyuibSheOibTQlDNO4mDuiapEzkAiaiaV6wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1020&quot;/&gt;&lt;figcaption&gt;心跳机制-被动检测&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图中服务A的实例2已经宕机不能主动给注册中心发送心跳消息，15秒之后注册就会将实例2移除掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主动检测&lt;/strong&gt;是注册中心主动发起，每隔几秒中会给所有列表中的服务实例发送心跳检测消息，如果多个周期内未发送成功或未收到回复就会主动移除该实例。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5185185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1Y7lK6NlTicv232833icKoG9ZIrhVIeQFK8GuvML8E6nGPibjEtrpVBPNuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1026&quot;/&gt;&lt;figcaption&gt;心跳机制-主动检测&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;业界常用的服务注册与发现组件对比&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解服务注册与发现的基本原理后，如果你要在项目中使用服务注册与发现组件，当面对众多的开源组件该如何进行技术选型？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在互联网公司里，有研发实力的大公司一般会选择自研或者基于开源组件进行二次开发，但是对于中小型公司来说直接选用一款开源软件会是一个不错的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的注册与发现组件有eureka，zookeeper，consul，etcd等，由于eureka在2018年已经宣布放弃维护，这里就不再推荐使用了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.32325141776937616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YK9wPaIDydpE0A60bJV2GdnHRsvjZmgAibumCQjjRwdYON2GLvGaROLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot;/&gt;&lt;figcaption&gt;业界开源组件&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面结合各个维度对比一下各组件。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table data-sort=&quot;sortDisabled&quot; interlaced=&quot;disabled&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;组件&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;接口类型&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;一致性算法&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;zookeeper&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1.功能强大，不仅仅只是服务发现；&lt;br/&gt;2.提供watcher机制可以实时获取服务提供者的状态；&lt;br/&gt;3.广泛使用，dubbo等微服务框架已支持；&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1.没有健康检查；&lt;br/&gt;2.需要在服务中引入sdk，集成复杂度高；&lt;br/&gt;3.不支持多数据中心；&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;sdk&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Paxos&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;consul&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1.开箱即用，方便集成；&lt;br/&gt;2.带健康检查；&lt;br/&gt;3.支持多数据中心；&lt;br/&gt;4.提供web管理界面；&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;不能实时获取服务变换通知&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;restful/dns&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Raft&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;etcd&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1.开箱即用，方便集成；&lt;br/&gt;2.可配置性强&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1.没有健康检查；&lt;br/&gt;2.需配合三方工具完成服务发现功能；&lt;br/&gt;3.不支持多数据中心；&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;restful&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Raft&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从整体上看consul的功能更加完备和均衡。接下来以consul为例详细介绍一下。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Consul——值得推荐的服务注册与发现开源组件&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;简单认识一下Consul&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consul是HashiCorp公司推出的开源工，使用Go语言开发，具有开箱即可部署方便的特点。Consul是分布式的、高可用的、 可横向扩展的用于实现分布式系统的服务发现与配置。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Consul有哪些优势？&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;服务注册发现：Consul提供了通过DNS或者restful接口的方式来注册服务和发现服务。服务可根据实际情况自行选择。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;健康检查：Consul的Client可以提供任意数量的健康检查，既可以与给定的服务相关联，也可以与本地节点相关联。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多数据中心：Consul支持多数据中心，这意味着用户不需要担心Consul自身的高可用性问题以及多数据中心带来的扩展接入等问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Consul的架构图&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7142857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EozrV0KJDBlyZ3dH8NBBH1YOIpiclpFn79C0xhaicN8eKZIhMGBIibgTxicxZm6UuBVWic4JWXuEOQ3vEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;figcaption&gt;Consul架构&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consul 实现多数据中心依赖于gossip protocol协议。这样做的目的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不需要使用服务器的地址来配置客户端；服务发现是自动完成的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;健康检查故障的工作不是放在服务器上，而是分布式的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Consul的使用场景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consul的应用场景包括&lt;strong&gt;服务注册发现&lt;/strong&gt;、&lt;strong&gt;服务隔离&lt;/strong&gt;、&lt;strong&gt;服务配置&lt;/strong&gt;等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;服务注册发现场景&lt;/strong&gt;中consul作为注册中心，服务地址被注册到consul中以后，可以使用consul提供的dns、http接口查询，consul支持health check。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;服务隔离场景&lt;/strong&gt;中consul支持以服务为单位设置访问策略，能同时支持经典的平台和新兴的平台，支持tls证书分发，service-to-service加密。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;服务配置场景&lt;/strong&gt;中consul提供key-value数据存储功能，并且能将变动迅速地通知出去，借助Consul可以实现配置共享，需要读取配置的服务可以从Consul中读取到准确的配置信息。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f14dd5732e3fa1153f523f6b9ac19cbf</guid>
<title>阿里终面：分布式事务原理</title>
<link>https://toutiao.io/k/vunm1k6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文提纲如下&lt;/p&gt;&lt;ol start=&quot;0&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;前言&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单数据源事务 &amp;amp; 多数据源事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常见分布式事务解决方案&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;2.1. 分布式事务模型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.2. 二将军问题和幂等性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.3. 两阶段提交（2PC） &amp;amp; 三阶段提交（3PC）方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.4. TCC 方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.5. 事务状态表方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.6. 基于消息中间件的最终一致性事务方案&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Seata in AT mode 的实现&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;3.1. Seata in AT mode 工作流程概述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.2. Seata in AT mode 工作流程详述&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;结束语&lt;/section&gt;&lt;/li&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5766793409378961&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OqmCT8JwGrJu90FJetDcJDBrHYylXMP3X9Lsru4V0SbK3NzuqmqJbCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;789&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;0. 前言&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 CPU 到内存、到磁盘、到操作系统、到网络，计算机系统处处存在不可靠因素。工程师和科学家努力使用各种软硬件方法对抗这种不可靠因素，保证数据和指令被正确地处理。在网络领域有 &lt;strong&gt;TCP 可靠传输协议&lt;/strong&gt;、在存储领域有 &lt;strong&gt;Raid5&lt;/strong&gt; 和 &lt;strong&gt;Raid6&lt;/strong&gt; 算法、在数据库领域有 &lt;strong&gt;基于 ARIES 算法理论实现的事务机制&lt;/strong&gt;……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章先介绍&lt;strong&gt;单机数据库事务的 ACID 特性&lt;/strong&gt;，然后指出&lt;strong&gt;分布式场景下操作多数据源面临的困境&lt;/strong&gt;，引出&lt;strong&gt;分布式系统中常用的分布式事务解决方案&lt;/strong&gt;，这些解决方案可以保证业务代码在操作多个数据源的时候，能够像操作单个数据源一样，具备 ACID 特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章在最后给出业界较为成熟的分布式事务框架——&lt;strong&gt;Seata 的 AT 模式全局事务的实现&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;1. 单数据源事务 &amp;amp; 多数据源事务&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个应用程序在一次业务流中通过连接驱动和数据源接口只连接并查询（这里的查询是广义的，包括增删查改等）一个特定的数据库，该应用程序就可以利用数据库提供的事务机制（如果数据库支持事务的话）保证对库中记录所进行的操作的可靠性，这里的可靠性有四种语义：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者在这里不再对这四种语义进行解释，了解单数据源事务及其 ACID 特性是读者阅读这篇文章的前提。单个数据库实现自身的事务特性是一个复杂又微妙的过程，例如 &lt;strong&gt;MySQL 的 InnoDB 引擎通过 Undo Log + Redo Log + ARIES 算法来实现&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个很宏大的话题，不在本文的描述范围，读者有兴趣的话可自行研究。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;单数据源事务也可以叫做单机事务，或者本地事务。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式场景下，一个系统由多个子系统构成，每个子系统有独立的数据源。多个子系统之间通过互相调用来组合出更复杂的业务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在时下流行的微服务系统架构中，每一个子系统被称作一个微服务，同样每个微服务都维护自己的数据库，以保持独立性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，一个电商系统可能由购物微服务、库存微服务、订单微服务等组成。购物微服务通过调用库存微服务和订单微服务来整合出购物业务。用户请求购物微服务商完成下单时，购物微服务一方面调用库存微服务扣减相应商品的库存数量，另一方面调用订单微服务插入订单记录（为了后文描述分布式事务解决方案的方便，这里给出的是一个最简单的电商系统微服务划分和最简单的购物业务流程，后续的支付、物流等业务不在考虑范围内）。电商系统模型如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2506596306068603&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5O1Z1djEJzPNiaVyvIGQPgtQZm8gG81ibunnYh7yMjH62MDpNqDvToXrlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;379&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在用户购物的业务场景中，&lt;strong&gt;shopping-service&lt;/strong&gt; 的业务涉及两个数据库：&lt;strong&gt;库存库（repo_db）&lt;strong&gt;和&lt;/strong&gt;订单库（repo_db）&lt;/strong&gt;，也就是 g 购物业务是调用多数据源来组合而成的。作为一个面向消费者的系统，电商系统要保证购物业务的高度可靠性，这里的可靠性同样有 ACID 四种语义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是一个数据库的本地事务机制仅仅对落到自己身上的查询操作（这里的查询是广义的，包括增删改查等）起作用，无法干涉对其他数据库的查询操作。所以，&lt;strong&gt;数据库自身提供的本地事务机制无法确保业务对多数据源全局操作的可靠性。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于此，针对多数据源操作提出的分布式事务机制就出现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分布式事务也可以叫做全局事务。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;2. 常见分布式事务解决方案&lt;/strong&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1. 分布式事务模型&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5Og9TkSZzCB0expnKC5ceF7Tk0YXTRic9v38yKfKYXnic2CEbFbM1JEGPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;描述分布式事务，常常会使用以下几个名词：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;事务参与者&lt;/strong&gt;：例如每个数据库就是一个事务参与者&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;事务协调&lt;/strong&gt;者：访问多个数据源的服务程序，例如 shopping-service 就是事务协调者&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;资源管理器（Resource Manager, RM）&lt;/strong&gt;：通常与事务参与者同义&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;事务管理器（Transaction Manager, TM）&lt;/strong&gt;：通常与事务协调者同义&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式事务模型中，一个 TM 管理多个 RM，即一个服务程序访问多个数据源；TM 是一个全局事务管理器，协调多方本地事务的进度，使其共同提交或回滚，最终达成一种全局的 ACID 特性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2. 二将军问题和幂等性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二将军问题是网络领域的一个经典问题，用于表达计算机网络中互联协议设计的微妙性和复杂性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里给出一个二将军问题的简化版本：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一支白军被围困在一个山谷中，山谷的左右两侧是蓝军。困在山谷中的白军人数多于山谷两侧的任意一支蓝军，而少于两支蓝军的之和。若一支蓝军对白军单独发起进攻，则必败无疑；但若两支蓝军同时发起进攻，则可取胜。两只蓝军的总指挥位于山谷左侧，他希望两支蓝军同时发起进攻，这样就要把命令传到山谷右侧的蓝军，以告知发起进攻的具体时间。假设他们只能派遣士兵穿越白军所在的山谷（唯一的通信信道）来传递消息，那么在穿越山谷时，士兵有可能被俘虏。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.8775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5O4MyMt1lE2m7kwf2SLLeXXfqlAQqReD1hhndqm28XPibMl2F1J1iazyKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有当送信士兵成功往返后，总指挥才能确认这场战争的胜利（上方图）。现在问题来了，派遣出去送信的士兵没有回来，则左侧蓝军中的总指挥能不能决定按命令中约定的时间发起进攻？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是不确定，派遣出去送信的士兵没有回来，他可能遇到两种状况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;命令还没送达就被俘虏了（中间图），这时候右侧蓝军根本不知道要何时进攻；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命令送达，但返回途中被俘虏了（下方图），这时候右侧蓝军知道要何时进攻，但左侧蓝军不知道右侧蓝军是否知晓进攻时间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似的问题在计算机网络中普遍存在，例如发送者给接受者发送一个 HTTP 请求，或者 MySQL 客户端向 MySQL 服务器发送一条插入语句，然后超时了没有得到响应。请问服务器是写入成功了还是失败了？答案是不确定，有以下几种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可能请求由于网络故障根本没有送到服务器，因此写入失败；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可能服务器收到了，也写入成功了，但是向客户端发送响应前服务器宕机了；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可能服务器收到了，也写入成功了，也向客户端发送了响应，但是由于网络故障未送到客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论哪种场景，在客户端看来都是一样的结果：它发出的请求没有得到响应。为了确保服务端成功写入数据，客户端只能重发请求，直至接收到服务端的响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似的问题问题被称为&lt;strong&gt;网络二将军问题&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;网络二将军问题的存在使得消息的发送者往往要重复发送消息，直到收到接收者的确认才认为发送成功，但这往往又会导致消息的重复发送。&lt;/strong&gt; 例如电商系统中订单模块调用支付模块扣款的时候，如果网络故障导致二将军问题出现，扣款请求重复发送，产生的重复扣款结果显然是不能被接受的。因此要保证一次事务中的扣款请求无论被发送多少次，接收方有且只执行一次扣款动作，这种保证机制叫做接收方的幂等性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OCkOSATodib1kENFfXyARy7uI3wEzS2QyG1K5y8tyqepjg7d4O17faicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3. 两阶段提交（2PC） &amp;amp; 三阶段提交（3PC）方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2PC 是一种实现分布式事务的简单模型&lt;/strong&gt;，这两个阶段是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;准备阶段&lt;/strong&gt;：事务协调者向各个事务参与者发起询问请求：“我要执行全局事务了，这个事务涉及到的资源分布在你们这些数据源中，分别是……，你们准备好各自的资源（即各自执行本地事务到待提交阶段）”。各个参与者协调者回复 yes（表示已准备好，允许提交全局事务）或 no（表示本参与者无法拿到全局事务所需的本地资源，因为它被其他本地事务锁住了）或超时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提交阶段：如果各个参与者回复的都是 yes，则协调者向所有参与者发起事务提交操作，然后所有参与者收到后各自执行本地事务提交操作并向协调者发送 ACK；如果任何一个参与者回复 no 或者超时，则协调者向所有参与者发起事务回滚操作，然后所有参与者收到后各自执行本地事务回滚操作并向协调者发送 ACK。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 的流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8847184986595175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5Oqr1VBDytKVqEicFfa8Wg3HOXmF3GyUkIILDj7VUHOWvAoe7LQ4bKvCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看出，要实现 2PC，所有的参与者都要实现三个接口：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Prepare()&lt;/strong&gt;：TM 调用该接口询问各个本地事务是否就绪&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Commit()&lt;/strong&gt;：TM 调用该接口要求各个本地事务提交&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Rollback()&lt;/strong&gt;：TM 调用该接口要求各个本地事务回滚&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以将这三个接口简单地（但不严谨地）理解成 &lt;strong&gt;XA 协议&lt;/strong&gt;。XA 协议是 X/Open 提出的分布式事务处理标准。MySQL、Oracle、DB2 这些主流数据库都实现了 XA 协议，因此都能被用于实现 2PC 事务模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 简明易懂，但存在如下的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;性能差。在准备阶段，要等待所有的参与者返回，才能进入阶段二，在这期间，各个参与者上面的相关资源被排他地锁住，参与者上面意图使用这些资源的本地事务只能等待。因为存在这种同步阻塞问题，所以影响了各个参与者的本地事务并发度；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;准备阶段完成后，如果协调者宕机，所有的参与者都收不到提交或回滚指令，导致所有参与者“不知所措”；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在提交阶段，协调者向所有的参与者发送了提交指令，如果一个参与者未返回 ACK，那么协调者不知道这个参与者内部发生了什么（由于网络二将军问题的存在，这个参与者可能根本没收到提交指令，一直处于等待接收提交指令的状态；也可能收到了，并成功执行了本地提交，但返回的 ACK 由于网络故障未送到协调者上），也就无法决定下一步是否进行全体参与者的回滚。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 之后又出现了 3PC，把两阶段过程变成了三阶段过程，分别是：&lt;strong&gt;1.询问阶段&lt;/strong&gt;、&lt;strong&gt;2.准备阶段&lt;/strong&gt;、&lt;strong&gt;3.提交或回滚阶段&lt;/strong&gt;，这里不再详述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3PC 利用超时机制解决了 2PC 的同步阻塞问题，避免资源被永久锁定，进一步加强了整个事务过程的可靠性。但是 3PC 同样无法应对类似的宕机问题，只不过出现多数据源中数据不一致问题的概率更小。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 除了性能和可靠性上存在问题，它的适用场景也很局限，它要求参与者实现了 XA 协议，例如使用实现了 XA 协议的数据库作为参与者可以完成 2PC 过程。但是在多个系统服务利用 api 接口相互调用的时候，就不遵守 XA 协议了，这时候 2PC 就不适用了。所以 2PC 在分布式应用场景中很少使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以前文提到的电商场景无法使用 2PC，因为 shopping-service 通过 RPC 接口或者 Rest 接口调用 repo-service 和 order-service 间接访问 repo_db 和 order_db。除非 shopping-service 直接配置 repo_db 和 order_db 作为自己的数据库。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4. TCC 方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;描述 TCC 方案使用的电商微服务模型如下图所示，在这个模型中，shopping-service 是事务协调者，repo-service 和 order-service 是事务参与者。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2440944881889764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5ORRW2eiaJESv0YyxfNQAuR78nibPibYPCQFiabSjhD6LORxttFiaKYLHsNBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;381&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文提到，2PC 要求参与者实现了 XA 协议，通常用来解决多个数据库之间的事务问题，比较局限。在多个系统服务利用 api 接口相互调用的时候，就不遵守 XA 协议了，这时候 2PC 就不适用了。现代企业多采用分布式的微服务，因此更多的是要解决多个微服务之间的分布式事务问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 就是一种解决多个微服务之间的分布式事务问题的方案。TCC 是 Try、Confirm、Cancel 三个词的缩写，其本质是一个应用层面上的 2PC，同样分为两个阶段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;准备阶段&lt;/strong&gt; ：协调者调用所有的每个微服务提供的 try 接口，将整个全局事务涉及到的资源锁定住，若锁定成功 try 接口向协调者返回 yes。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;提交阶段&lt;/strong&gt; ：若所有的服务的 try 接口在阶段一都返回 yes，则进入提交阶段，协调者调用所有服务的 confirm 接口，各个服务进行事务提交。如果有任何一个服务的 try 接口在阶段一返回 no 或者超时，则协调者调用所有服务的 cancel 接口。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 的流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.871222076215506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5ObtPwqrF3V59taSch79uRGELZNib6CwWcE6nvlbicFUaP2xCiaeiaZXmz3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;761&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个关键问题，既然 TCC 是一种服务层面上的 2PC。&lt;strong&gt;它是如何解决 2PC 无法应对宕机问题的缺陷的呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是不断重试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 try 操作锁住了全局事务涉及的所有资源，保证了业务操作的所有前置条件得到满足，因此无论是 confirm 阶段失败还是 cancel 阶段失败都能通过不断重试直至 confirm 或 cancel 成功（所谓成功就是所有的服务都对 confirm 或者 cancel 返回了 ACK）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5Ob3qPfib0qAIB6F5nIrO0R9HKS3O8bIxv2m6FMciaF3DOQgHdYJAV10Gg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里还有个关键问题，在不断重试 confirm 和 cancel 的过程中（考虑到网络二将军问题的存在）有可能重复进行了 confirm 或 cancel，因此还要再保证 confirm 和 cancel 操作具有幂等性，也就是整个全局事务中，每个参与者只进行一次 confirm 或者 cancel。实现 confirm 和 cancel 操作的幂等性，有很多解决方案，例如每个参与者可以维护一个去重表（可以利用数据库表实现也可以使用内存型 KV 组件实现），记录每个全局事务（以全局事务标记 XID 区分）是否进行过 confirm 或 cancel 操作，若已经进行过，则不再重复执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 由支付宝团队提出，被广泛应用于金融系统中。我们用银行账户余额购买基金时，会注意到银行账户中用于购买基金的那部分余额首先会被冻结，由此我们可以猜想，这个过程大概就是 TCC 的第一阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5. 事务状态表方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外有一种类似 TCC 的事务解决方案，借助事务状态表来实现。假设要在一个分布式事务中实现调用 repo-service 扣减库存、调用 order-service 生成订单两个过程。在这种方案中，协调者 shopping-service 维护一张如下的事务状态表：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;分布式事务 ID&lt;/th&gt;&lt;th&gt;事务内容&lt;/th&gt;&lt;th&gt;事务状态&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;global_trx_id_1&lt;/td&gt;&lt;td&gt;操作 1：调用 repo-service 扣减库存 操作 2：调用 order-service 生成订单&lt;/td&gt;&lt;td&gt;状态 1：初始 状态 2：操作 1 成功 状态 3：操作 1、2 成功&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始状态为 1，每成功调用一个服务则更新一次状态，最后所有的服务调用成功，状态更新到 3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这张表，就可以启动一个后台任务，扫描这张表中事务的状态，如果一个分布式事务一直（设置一个事务周期阈值）未到状态 3，说明这条事务没有成功执行，于是可以重新调用 repo-service 扣减库存、调用 order-service 生成订单。直至所有的调用成功，事务状态到 3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果多次重试仍未使得状态到 3，可以将事务状态置为 error，通过人工介入进行干预。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于存在服务的调用重试，因此每个服务的接口要根据全局的分布式事务 ID 做幂等，原理同 2.4 节的幂等性实现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.6. 基于消息中间件的最终一致性事务方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;无论是 2PC &amp;amp; 3PC 还是 TCC、事务状态表，基本都遵守 XA 协议的思想&lt;/strong&gt;。即这些方案本质上都是事务协调者协调各个事务参与者的本地事务的进度，使所有本地事务共同提交或回滚，最终达成一种全局的 ACID 特性。在协调的过程中，协调者需要收集各个本地事务的当前状态，并根据这些状态发出下一阶段的操作指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这些全局事务方案由于操作繁琐、时间跨度大，或者在全局事务期间会排他地锁住相关资源，使得整个分布式系统的全局事务的并发度不会太高。这很难满足电商等高并发场景对事务吞吐量的要求，因此互联网服务提供商探索出了很多与 XA 协议背道而驰的分布式事务解决方案。其中利用消息中间件实现的最终一致性全局事务就是一个经典方案。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5O5yszDOGWs9CVicia8qFwcH3GnYiah4b1Zkqibbk7eLib20LfJwaaRIZicHxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了表现出这种方案的精髓，我将使用如下的电商系统微服务结构来进行描述：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.828752642706131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5O8H5s6iccLprEicEBucv7WjVyZXic6bmf3BWqRreuy8W5kr5K30icWkDRog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;473&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个模型中，用户不再是请求整合后的 shopping-service 进行下单，而是直接请求 order-service 下单，order-service 一方面添加订单记录，另一方面会调用 repo-service 扣减库存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种基于消息中间件的最终一致性事务方案常常被误解成如下的实现方式：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4182939362795478&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OT1CRZAQpT4dxQ6xzmjoHCHmrt3ue8pldzqI2LicXibOmDqicttDEGicK4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;973&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种实现方式的流程是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;order-service 负责向 MQ server 发送扣减库存消息（repo_deduction_msg）；repo-service 订阅 MQ server 中的扣减库存消息，负责消费消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户下单后，order-service 先执行插入订单记录的查询语句，后将 repo_deduction_msg 发到消息中间件中，这两个过程放在一个本地事务中进行，一旦“执行插入订单记录的查询语句”失败，导致事务回滚，“将 repo_deduction_msg 发到消息中间件中”就不会发生；同样，一旦“将 repo_deduction_msg 发到消息中间件中”失败，抛出异常，也会导致“执行插入订单记录的查询语句”操作回滚，最终什么也没有发生。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9090909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5ODyrv0PYJv9icmhjQaMIQdTAAYTM3qk02BNWdLW5TNwGYQ7KUic8ISTGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;198&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;repo-service 接收到 repo_deduction_msg 之后，先执行库存扣减查询语句，后向 MQ sever 反馈消息消费完成 ACK，这两个过程放在一个本地事务中进行，一旦“执行库存扣减查询语句”失败，导致事务回滚，“向 MQ sever 反馈消息消费完成 ACK”就不会发生，MQ server 在 Confirm 机制的驱动下会继续向 repo-service 推送该消息，直到整个事务成功提交；同样，一旦“向 MQ sever 反馈消息消费完成 ACK”失败，抛出异常，也对导致“执行库存扣减查询语句”操作回滚，MQ server 在 Confirm 机制的驱动下会继续向 repo-service 推送该消息，直到整个事务成功提交。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.025974025974026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OVWRCuEW5KCPYlqibgVGQsicA9gejI9v31kgRaIl7B4CeHEVOEpnOic7fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;154&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种做法看似很可靠。但没有考虑到网络二将军问题的存在，有如下的缺陷：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;网络的 2 将军问题&lt;/strong&gt; ：上面第 2 步中 order-service 发送 repo_deduction_msg 消息失败，对于发送方 order-service 来说，可能是消息中间件没有收到消息；也可能是中间件收到了消息，但向发送方 order-service 响应的 ACK 由于网络故障没有被 order-service 收到。因此 order-service 贸然进行事务回滚，撤销“执行插入订单记录的查询语句”，是不对的，因为 repo-service 那边可能已经接收到 repo_deduction_msg 并成功进行了库存扣减，这样 order-service 和 repo-service 两方就产生了数据不一致问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;数据库长事务问题&lt;/strong&gt; ：repo-service 和 order-service 把网络调用（与 MQ server 通信）放在本地数据库事务里，可能会因为网络延迟产生数据库长事务，影响数据库本地事务的并发度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OSm6gAKgOZZIjZ4Bv73QOqkN493ibeKdichC6M9iaeiac5mCbiauWxJ1yJSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是被误解的实现方式，下面给出正确的实现方式，如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36018518518518516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OSWufbwc1iahgpyuxuk4HBjNbqk4BhZwMalMMnFiaN7U8a8iaPjs77RJHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图所示的方案，利用消息中间件如 rabbitMQ 来实现分布式下单及库存扣减过程的最终一致性。对这幅图做以下说明：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）order-service 中，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;在 t_order 表添加订单记录 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;在 t_local_msg 添加对应的扣减库存消息&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个过程要在一个事务中完成，保证过程的原子性。同样，repo-service 中，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;检查本次扣库存操作是否已经执行过 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;执行扣减库存如果本次扣减操作没有执行过 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;写判重表 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;向 MQ sever 反馈消息消费完成 ACK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这四个过程也要在一个事务中完成，保证过程的原子性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）order-service 中有一个后台程序，源源不断地把消息表中的消息传送给消息中间件，成功后则删除消息表中对应的消息。如果失败了，也会不断尝试重传。由于存在网络 2 将军问题，即当 order-service 发送给消息中间件的消息网络超时时，这时候消息中间件可能收到了消息但响应 ACK 失败，也可能没收到，order-service 会再次发送该消息，直至消息中间件响应 ACK 成功，这样可能发生消息的重复发送，不过没关系，只要保证消息不丢失，不乱序就行，后面 repo-service 会做去重处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）消息中间件向 repo-service 推送 repo_deduction_msg，repo-service 成功处理完成后会向中间件响应 ACK，消息中间件收到这个 ACK 才认为 repo-service 成功处理了这条消息，否则会重复推送该消息。但是有这样的情形：repo-service 成功处理了消息，向中间件发送的 ACK 在网络传输中由于网络故障丢失了，导致中间件没有收到 ACK 重新推送了该消息。这也要靠 repo-service 的消息去重特性来避免消息重复消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4）在 2）和 3）中提到了两种导致 repo-service 重复收到消息的原因，一是生产者重复生产，二是中间件重传。为了实现业务的幂等性，repo-service 中维护了一张判重表，这张表中记录了被成功处理的消息的 id。repo-service 每次接收到新的消息都先判断消息是否被成功处理过，若是的话不再重复处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9345794392523364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OHdf2TqjpXFrdlicGyn9tsqebB0wTFauZzC41lpRvXYE6ddfzBGibGOdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;214&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这种设计，实现了消息在发送方不丢失，消息在接收方不被重复消费，联合起来就是消息不漏不重，严格实现了 order-service 和 repo-service 的两个数据库中数据的最终一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于消息中间件的最终一致性全局事务方案是互联网公司在高并发场景中探索出的一种创新型应用模式，利用 MQ 实现微服务之间的异步调用、解耦合和流量削峰，支持全局事务的高并发，并保证分布式数据记录的最终一致性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5ODAtXVRcibzJbWT3AVC0wSuOjJYeOmeI1cGmTFCc8hNrrPtxR7AMLWJg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;3. Seata in AT mode 的实现&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第 2 章给出了实现实现分布式事务的集中常见的理论模型。本章给出业界开源分布式事务框架 Seata 的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Seata 为用户提供了 AT、TCC、SAGA 和 XA 事务模式&lt;/strong&gt;。其中 &lt;strong&gt;AT 模式是 Seata 主推的事务模式&lt;/strong&gt;，因此本章分析 Seata in AT mode 的实现。&lt;strong&gt;使用 AT 有一个前提，那就是微服务使用的数据库必须是支持事务的关系型数据库。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1. Seata in AT mode 工作流程概述&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Seata 的 AT 模式建立在关系型数据库的本地事务特性的基础之上，通过数据源代理类拦截并解析数据库执行的 SQL，记录自定义的回滚日志，如需回滚，则重放这些自定义的回滚日志即可。AT 模式虽然是根据 XA 事务模型（2PC）演进而来的，但是 AT 打破了 XA 协议的阻塞性制约，在一致性和性能上取得了平衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AT 模式是基于 XA 事务模型演进而来的，它的整体机制也是一个改进版本的两阶段提交协议。AT 模式的两个基本阶段是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先获取本地锁，执行本地事务，业务数据操作和记录回滚日志在同一个本地事务中提交，最后释放本地锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如需全局提交，异步删除回滚日志即可，这个过程很快就能完成。如需要回滚，则通过第一阶段的回滚日志进行反向补偿。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本章描述 Seata in AT mode 的工作原理使用的电商微服务模型如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2440944881889764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5ORRW2eiaJESv0YyxfNQAuR78nibPibYPCQFiabSjhD6LORxttFiaKYLHsNBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;381&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，协调者 shopping-service 先调用参与者 repo-service 扣减库存，后调用参与者 order-service 生成订单。这个业务流使用 Seata in XA mode 后的全局事务流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9425113464447806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OyGdkslGbeFtwvuf8Iic138nocN06p7WNjuIx8pXicL7ibbOxgRGF7WOpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;661&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图描述的全局事务执行流程为：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;shopping-service 向 Seata 注册全局事务，并产生一个全局事务标识 XID&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 repo-service.repo_db、order-service.order_db 的本地事务执行到待提交阶段，事务内容包含对 repo-service.repo_db、order-service.order_db 进行的查询操作以及写每个库的 undo_log 记录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;repo-service.repo_db、order-service.order_db 向 Seata 注册分支事务，并将其纳入该 XID 对应的全局事务范围&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提交 repo-service.repo_db、order-service.order_db 的本地事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;repo-service.repo_db、order-service.order_db 向 Seata 汇报分支事务的提交状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Seata 汇总所有的 DB 的分支事务的提交状态，决定全局事务是该提交还是回滚&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Seata 通知 repo-service.repo_db、order-service.order_db 提交/回滚本地事务，若需要回滚，采取的是补偿式方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 1）2）3）4）5）属于第一阶段，6）7）属于第二阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2. Seata in AT mode 工作流程详述&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的电商业务场景中，购物服务调用库存服务扣减库存，调用订单服务创建订单，显然这两个调用过程要放在一个事务里面。即：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;start global_trx&lt;br/&gt;&lt;br/&gt; call 库存服务的扣减库存接口&lt;br/&gt;&lt;br/&gt; call 订单服务的创建订单接口&lt;br/&gt;&lt;br/&gt;commit global_trx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在库存服务的数据库中，存在如下的库存表 t_repo：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10001&lt;/td&gt;&lt;td&gt;20001&lt;/td&gt;&lt;td&gt;xx 键盘&lt;/td&gt;&lt;td&gt;98&lt;/td&gt;&lt;td&gt;200.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;199&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在订单服务的数据库中，存在如下的订单表 t_order：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;order_code&lt;/th&gt;&lt;th&gt;user_id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;30001&lt;/td&gt;&lt;td&gt;2020102500001&lt;/td&gt;&lt;td&gt;40001&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;30002&lt;/td&gt;&lt;td&gt;2020102500001&lt;/td&gt;&lt;td&gt;40001&lt;/td&gt;&lt;td&gt;20001&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;400.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，id 为 40002 的用户要购买一只商品代码为 20002 的鼠标，整个分布式事务的内容为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）在库存服务的库存表中将记录&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;199&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改为&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;198&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）在订单服务的订单表中添加一条记录&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;order_code&lt;/th&gt;&lt;th&gt;user_id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;30003&lt;/td&gt;&lt;td&gt;2020102500002&lt;/td&gt;&lt;td&gt;40002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上操作，在 AT 模式的第一阶段的流程图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4167623421354765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OOxsngRHRibdaZNwOtfLLbr4ffLUuP8OIzr92CfQK6FS5urJpDnAeviag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;871&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 AT 模式第一阶段的流程来看，分&lt;strong&gt;支的本地事务在第一阶段提交完成之后，就会释放掉本地事务锁定的本地记录&lt;/strong&gt;。这是 AT 模式和 XA 最大的不同点，在 XA 事务的两阶段提交中，被锁定的记录直到第二阶段结束才会被释放。所以 &lt;strong&gt;AT 模式减少了锁记录的时间，从而提高了分布式事务的处理效率&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AT 模式之所以能够实现第一阶段完成就释放被锁定的记录，是因为 Seata 在每个服务的数据库中维护了一张 undo_log 表&lt;/strong&gt;，其中记录了对 t_order / t_repo 进行操作前后记录的镜像数据，即便第二阶段发生异常，只需回放每个服务的 undo_log 中的相应记录即可实现全局回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;undo_log 的表结构：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;branch_id&lt;/th&gt;&lt;th&gt;xid&lt;/th&gt;&lt;th&gt;context&lt;/th&gt;&lt;th&gt;rollback_info&lt;/th&gt;&lt;th&gt;log_status&lt;/th&gt;&lt;th&gt;log_created&lt;/th&gt;&lt;th&gt;log_modified&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;分支事务 ID&lt;/td&gt;&lt;td&gt;全局事务 ID&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;分支事务操作的记录在事务前后的记录镜像，即 beforeImage 和 afterImage&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一阶段结束之后，Seata 会接收到所有分支事务的提交状态，然后决定是提交全局事务还是回滚全局事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1）若所有分支事务本地提交均成功，则 Seata 决定全局提交。&lt;/strong&gt; Seata 将分支提交的消息发送给各个分支事务，各个分支事务收到分支提交消息后，会将消息放入一个缓冲队列，然后直接向 Seata 返回提交成功。之后，每个本地事务会慢慢处理分支提交消息，处理的方式为：删除相应分支事务的 undo_log 记录。之所以只需删除分支事务的 undo_log 记录，而不需要再做其他提交操作，是因为提交操作已经在第一阶段完成了（这也是 AT 和 XA 不同的地方）。这个过程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6545012165450121&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OibuibmFbqjPx25ibiabf7w6RTdpwT73oPAnQkKFbZBNvEIfZ48DFA1ZVRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;822&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分支事务之所以能够直接返回成功给 Seata，是因为真正关键的提交操作在第一阶段已经完成了，清除 undo_log 日志只是收尾工作，即便清除失败了，也对整个分布式事务不产生实质影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2）若任一分支事务本地提交失败，则 Seata 决定全局回滚&lt;/strong&gt;，将分支事务回滚消息发送给各个分支事务，由于在第一阶段各个服务的数据库上记录了 undo_log 记录，分支事务回滚操作只需根据 undo_log 记录进行补偿即可。全局事务的回滚流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7567298105682951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OtBLLPhVMSkNyFg5Mnl075Kuia52teiaVIBf5pcUUatibUM5FHZ6wuyaGA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1003&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里对图中的 2、3 步做进一步的说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由于上文给出了 undo_log 的表结构，所以可以通过 xid 和 branch_id 来找到当前分支事务的所有 undo_log 记录；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拿到当前分支事务的 undo_log 记录之后，首先要做数据校验，如果 afterImage 中的记录与当前的表记录不一致，说明从第一阶段完成到此刻期间，有别的事务修改了这些记录，这会导致分支事务无法回滚，向 Seata 反馈回滚失败；如果 afterImage 中的记录与当前的表记录一致，说明从第一阶段完成到此刻期间，没有别的事务修改这些记录，分支事务可回滚，进而根据 beforeImage 和 afterImage 计算出补偿 SQL，执行补偿 SQL 进行回滚，然后删除相应 undo_log，向 Seata 反馈回滚成功。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OJ6P9q3q6nV7Ug24TQaPnmtt2zmWPWDJQtf59fbJQQJufibIauvySzJQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务具有 ACID 特性，全局事务解决方案也在尽量实现这四个特性。以上关于 Seata in AT mode 的描述很显然体现出了 AT 的原子性、一致性和持久性。下面着重描述一下 AT 如何保证多个全局事务的隔离性的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 AT 中，当多个全局事务操作同一张表时，通过全局锁来保证事务的隔离性。下面描述一下全局锁在读隔离和写隔离两个场景中的作用原理：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）&lt;strong&gt;写隔离&lt;/strong&gt;（若有全局事务在改/写/删记录，另一个全局事务对同一记录进行的改/写/删要被隔离起来，即写写互斥）：写隔离是为了在多个全局事务对同一张表的同一个字段进行更新操作时，避免一个全局事务在没有被提交成功之前所涉及的数据被其他全局事务修改。写隔离的基本原理是：在第一阶段本地事务（开启本地事务的时候，本地事务会对涉及到的记录加本地锁）提交之前，确保拿到全局锁。如果拿不到全局锁，就不能提交本地事务，并且不断尝试获取全局锁，直至超出重试次数，放弃获取全局锁，回滚本地事务，释放本地事务对记录加的本地锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有两个全局事务 gtrx_1 和 gtrx_2 在并发操作库存服务，意图扣减如下记录的库存数量：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;198&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AT 实现写隔离过程的时序图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5651340996168582&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5O1J2BzCm9X9lkuhLEvNEic6SL8d7bFnT75BQADGQtFUUv4P5eicfeXBzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1044&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中，1、2、3、4 属于第一阶段，5 属于第二阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中 gtrx_1 和 gtrx_2 均成功提交，如果 gtrx_1 在第二阶段执行回滚操作，那么 gtrx_1 需要重新发起本地事务获取本地锁，然后根据 undo_log 对这个 id=10002 的记录进行补偿式回滚。此时 gtrx_2 仍在等待全局锁，且持有这个 id=10002 的记录的本地锁，因此 gtrx_1 会回滚失败（gtrx_1 回滚需要同时持有全局锁和对 id=10002 的记录加的本地锁），回滚失败的 gtrx_1 会一直重试回滚。直到旁边的 gtrx_2 获取全局锁的尝试次数超过阈值，gtrx_2 会放弃获取全局锁，发起本地回滚，本地回滚结束后，自然会释放掉对这个 id=10002 的记录加的本地锁。此时，gtrx_1 终于可以成功对这个 id=10002 的记录加上了本地锁，同时拿到了本地锁和全局锁的 gtrx_1 就可以成功回滚了。整个过程，全局锁始终在 gtrx_1 手中，并不会发生脏写的问题。整个过程的流程图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.687962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OpXV1Jzj6Gh6vCoJiapTgwCViaHHlSpNHjeF20VObGMyY6Wa0gUe00iaDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）&lt;strong&gt;读隔离&lt;/strong&gt;（若有全局事务在改/写/删记录，另一个全局事务对同一记录的读取要被隔离起来，即读写互斥）：在数据库本地事务的隔离级别为读已提交、可重复读、串行化时（读未提交不起什么隔离作用，一般不使用），Seata AT 全局事务模型产生的隔离级别是读未提交，也就是说一个全局事务会看到另一个全局事务未全局提交的数据，产生脏读，从前文的第一阶段和第二阶段的流程图中也可以看出这一点。这在最终一致性的分布式事务模型中是可以接受的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要求 AT 模型一定要实现读已提交的事务隔离级别，可以利用 Seata 的 SelectForUpdateExecutor 执行器对 SELECT FOR UPDATE 语句进行代理。SELECT FOR UPDATE 语句在执行时会申请全局锁，如果全局锁已经被其他全局事务占有，则回滚 SELECT FOR UPDATE 语句的执行，释放本地锁，并且重试 SELECT FOR UPDATE 语句。在这个过程中，查询请求会被阻塞，直到拿到全局锁（也就是要读取的记录被其他全局事务提交），读到已被全局事务提交的数据才返回。这个过程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5722222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5Ohz4OheD3PNeibsGnFX0rREpUBicYCM4r6JXeZtpvhgXpCDKOLsj5Mapg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OLeBdUoUwavsbVPliasUqvq03JuFaMDDASq3l0CjK4kKHiamLwGZ3pgfQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;4. 结束语&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XA 协议是 X/Open 提出的分布式事务处理标准。文中提到的 2PC、3PC、TCC、本地事务表、Seata in AT mode，无论哪一种，本质都是事务协调者协调各个事务参与者的本地事务的进度，使使所有本地事务共同提交或回滚，最终达成一种全局的 ACID 特性。在协调的过程中，协调者需要收集各个本地事务的当前状态，并根据这些状态发出下一阶段的操作指令。这个思想就是 XA 协议的要义，我们可以说这些事务模型遵守或大致遵守了 XA 协议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;基于消息中间件的最终一致性事务方案是互联网公司在高并发场景中探索出的一种创新型应用模式，利用 MQ 实现微服务之间的异步调用、解耦合和流量削峰，保证分布式数据记录的最终一致性。它显然不遵守 XA 协议。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于某项技术，可能存在业界标准或协议，但实践者针对具体应用场景的需求或者出于简便的考虑，给出与标准不完全相符的实现，甚至完全不相符的实现，这在工程领域是一种常见的现象。TCC 方案如此、基于消息中间件的最终一致性事务方案如此、Seata in AT mode 模式也如此。而新的标准往往就在这些创新中产生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你难道真的没有发现 2.6 节（基于消息中间件的最终一致性事务方案）给出的正确方案中存在的业务漏洞吗？请各位重新看下这张图，仔细品一品两个微服务的调用方向，把你的想法留在评论区吧 :-)&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36018518518518516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Twj530g4IXy4dcqvnDhcf5OSWufbwc1iahgpyuxuk4HBjNbqk4BhZwMalMMnFiaN7U8a8iaPjs77RJHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>29259e0f21e815f59cdb5b9a80b0d7df</guid>
<title>Kafka 浅谈：什么是 AR、OSR、ISR、HW 和 LEO 以及之间的关系</title>
<link>https://toutiao.io/k/wyi8d8m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content post-body&quot;&gt;&lt;h3 id=&quot;kafka-多副本&quot;&gt;&lt;a href=&quot;#kafka-多副本&quot; class=&quot;headerlink&quot; title=&quot;kafka 多副本&quot;/&gt;kafka 多副本&lt;/h3&gt;&lt;p&gt;Kafka 为分区引入了多副本（Replica）机制，通过增加副本数量可以提升容灾能力。同一分区的不同副本中保存的是相同的消息（当然在同一时刻，副本之间可能并非完全一样），副本之间是“一主多从”的关系，其中leader副本负责处理读写请求，follower副本只负责与leader副本的消息同步。副本处于不同的broker中，当leader副本出现故障时，从follower副本中重新选举新的leader副本对外提供服务。Kafka通过多副本机制实现了故障的自动转移，当Kafka集群中某个broker失效时仍然能保证服务可用。&lt;/p&gt;
&lt;p&gt;Kafka集群中有4个broker，某个主题中有3个分区，且副本因子（即副本个数）也为3，如此每个分区便有1个leader副本和2个follower副本。生产者和消费者只与leader副本进行交互，而follower副本只负责消息的同步，很多时候follower副本中的消息相对leader副本而言会有一定的滞后。&lt;/p&gt;
&lt;p&gt;Kafka 消费端也具备一定的容灾能力。Consumer 使用拉（Pull）模式从服务端拉取消息，并且保存消费的具体位置，当消费者宕机后恢复上线时可以根据之前保存的消费位置重新拉取需要的消息进行消费，这样就不会造成消息丢失。&lt;/p&gt;
&lt;h3 id=&quot;AR、LSR、OSR&quot;&gt;&lt;a href=&quot;#AR、LSR、OSR&quot; class=&quot;headerlink&quot; title=&quot;AR、LSR、OSR&quot;/&gt;AR、LSR、OSR&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;分区中的所有副本统称为AR（Assigned Replicas）。&lt;/li&gt;
&lt;li&gt;所有与leader副本保持一定程度同步的副本（包括leader副本在内）组成ISR（In-Sync Replicas），ISR集合是AR集合中的一个子集。&lt;/li&gt;
&lt;li&gt;与leader副本同步滞后过多的副本（不包括leader副本）组成OSR（Out-of-Sync Replicas）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;消息会先发送到leader副本，然后follower副本才能从leader副本中拉取消息进行同步，同步期间内follower副本相对于leader副本而言会有一定程度的滞后。前面所说的“一定程度的同步”是指可忍受的滞后范围，这个范围可以通过参数进行配置。，由此可见，AR=ISR+OSR。在正常情况下，所有的 follower 副本都应该与 leader 副本保持一定程度的同步，即 AR=ISR，OSR集合为空.&lt;/p&gt;
&lt;h3 id=&quot;LSR-与-OSR-转换、LSR集合中的副本才允许选举为leader&quot;&gt;&lt;a href=&quot;#LSR-与-OSR-转换、LSR集合中的副本才允许选举为leader&quot; class=&quot;headerlink&quot; title=&quot;LSR 与 OSR 转换、LSR集合中的副本才允许选举为leader&quot;/&gt;LSR 与 OSR 转换、LSR集合中的副本才允许选举为leader&lt;/h3&gt;&lt;p&gt;leader副本负责维护和跟踪ISR集合中所有follower副本的滞后状态，当follower副本落后太多或失效时，leader副本会把它从ISR集合中剔除。如果OSR集合中有follower副本“追上”了leader副本，那么leader副本会把它从OSR集合转移至ISR集合。默认情况下，当leader副本发生故障时，只有在ISR集合中的副本才有资格被选举为新的leader，而在OSR集合中的副本则没有任何机会（不过这个原则也可以通过修改相应的参数配置来改变）。ISR与HW和LEO也有紧密的关系。&lt;/p&gt;
&lt;h3 id=&quot;什么是HW高水位&quot;&gt;&lt;a href=&quot;#什么是HW高水位&quot; class=&quot;headerlink&quot; title=&quot;什么是HW高水位&quot;/&gt;什么是HW高水位&lt;/h3&gt;&lt;p&gt;HW是High Watermark的缩写，俗称高水位，它标识了一个特定的消息偏移量（offset），消费者只能拉取到这个offset之前的消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/2020/11/16043177212192.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，它代表一个日志文件，这个日志文件中有 9 条消息，第一条消息的 offset（LogStartOffset）为0，最后一条消息的offset为8，offset为9的消息用虚线框表示，代表下一条待写入的消息。日志文件的HW为6，表示消费者只能拉取到offset在0至5之间的消息，而offset为6的消息对消费者而言是不可见的。&lt;/p&gt;
&lt;h3 id=&quot;什么是LEO&quot;&gt;&lt;a href=&quot;#什么是LEO&quot; class=&quot;headerlink&quot; title=&quot;什么是LEO&quot;/&gt;什么是LEO&lt;/h3&gt;&lt;p&gt;LEO是Log End Offset的缩写，它标识当前日志文件中下一条待写入消息的offset，图中offset为9的位置即为当前日志文件的LEO，LEO的大小相当于当前日志分区中最后一条消息的offset值加1。分区ISR集合中的每个副本都会维护自身的LEO，而ISR集合中最小的LEO即为分区的HW，对消费者而言只能消费HW之前的消息。&lt;/p&gt;
&lt;h3 id=&quot;ISR集合，以及HW和LEO之间的关系&quot;&gt;&lt;a href=&quot;#ISR集合，以及HW和LEO之间的关系&quot; class=&quot;headerlink&quot; title=&quot;ISR集合，以及HW和LEO之间的关系&quot;/&gt;ISR集合，以及HW和LEO之间的关系&lt;/h3&gt;&lt;p&gt;为了更好地理解ISR集合，以及HW和LEO之间的关系，下面通过一个简单的示例来进行相关的说明。如图所示，假设某个分区的ISR集合中有3个副本，即一个leader副本和2个follower副本，此时分区的LEO和HW都为3。消息3和消息4从生产者发出之后会被先存入leader副本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/2020/11/16043177369600.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/2020/11/16043177502794.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/2020/11/16043177624510.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/2020/11/16043177728479.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在消息写入leader副本之后，follower副本会发送拉取请求来拉取消息3和消息4以进行消息同步。&lt;/p&gt;
&lt;p&gt;在同步过程中，不同的 follower 副本的同步效率也不尽相同。在某一时刻follower1完全跟上了leader副本而follower2只同步了消息3，如此leader副本的LEO为5，follower1的LEO为5，follower2的LEO为4，那么当前分区的HW取最小值4，此时消费者可以消费到offset为0至3之间的消息。&lt;/p&gt;
&lt;p&gt;当所有的副本都成功写入了消息3和消息4，整个分区的HW和LEO都变为5，因此消费者可以消费到offset为4的消息了。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h3&gt;&lt;p&gt;由此可见，Kafka 的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的 follower 副本都复制完，这条消息才会被确认为已成功提交，这种复制方式极大地影响了性能。而在异步复制方式下，follower副本异步地从leader副本中复制数据，数据只要被leader副本写入就被认为已经成功提交。在这种情况下，如果follower副本都还没有复制完而落后于leader副本，突然leader副本宕机，则会造成数据丢失。Kafka使用的这种ISR的方式则有效地权衡了数据可靠性和性能之间的关系。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4d657c658db719b027daa896b7a93b61</guid>
<title>Swift 编译慢？请看这里，全套开源</title>
<link>https://toutiao.io/k/ihas21f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;markdown-body entry-content container-lg&quot; itemprop=&quot;text&quot;&gt;&lt;h3&gt;&lt;a id=&quot;user-content-更新&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#更新&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;更新&lt;/h3&gt;

&lt;h1&gt;&lt;a id=&quot;user-content-cocoapods-imy-bin&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#cocoapods-imy-bin&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Cocoapods-imy-bin&lt;/h1&gt;
&lt;p&gt;关于 插件具体的架构部署实践和更详细的资源，可以参考&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5eccceb9f265da76f30e4e13&quot; rel=&quot;nofollow&quot;&gt;iOS编译速度如何稳定提高10倍以上&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5f066cfa5188252e893a136e&quot; rel=&quot;nofollow&quot;&gt;iOS美团同款&quot;ZSource&quot;二进制调试实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6850037272415813645&quot; rel=&quot;nofollow&quot;&gt;iOS教你如何像RN一样实时编译&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/su350380433/cocoapods-imy-bin-demo&quot;&gt;OC-Demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/su350380433/Swift-OC-Demo&quot;&gt;Swift-OC-Demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6890419459639476237&quot; rel=&quot;nofollow&quot;&gt;Swift编译支持&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-特色&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#特色&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;特色：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;无入侵、无感知、不影响现有业务，不影响现有代码框架、完全绿色产品~&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;轻量级，只要项目能编译通过就能使用，无视组件化、无视耦合&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完全自动化，一键使用、无需手动操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一步步教你使用，新手也能欢乐玩转&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供几个特色服务&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持 使用与不使用 use_frameworks!&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;少数支持swift项目二进制化编译的开源项目之一&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-一概要&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#一概要&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;一、概要&lt;/h2&gt;
&lt;p&gt;cocoapods-imy-bin功能点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组件二进制化，&lt;code&gt;无入侵式&lt;/code&gt;支持组件二进制化，完全自动化，无需手动操作。致力于解决Ci打包速度慢、研发编译慢等编译问题。&lt;/li&gt;
&lt;li&gt;本地配置文件 - &lt;code&gt;Podfile_local&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;二进制源码调试&lt;code&gt;pod bin code&lt;/code&gt;，类似&lt;a href=&quot;https://juejin.im/post/6847897745987125262&quot; rel=&quot;nofollow&quot;&gt;美团 iOS 工程 zsource 命令背后的那些事儿&lt;/a&gt;的效果。&lt;/li&gt;
&lt;li&gt;命令快捷键&lt;code&gt;pod bin imy&lt;/code&gt;，如游戏快捷键，根据配置会在特定目录执行特定命令（如任意终端目录下，执行某个特定目录的pod update --no-repo-update命令），减少其他繁琐操作。支持任意个快捷键。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;cocoapods-imy-bin插件所关联的组件二进制化策略：&lt;/p&gt;
&lt;p&gt;预先将打包成 &lt;code&gt;.a&lt;/code&gt;  的组件保存到静态服务器上，并在 &lt;code&gt;install&lt;/code&gt; 时，去下载组件对应的二进制版本，以减少组件编译时间，达到加快 App 打包、组件发布等操作的目的。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-二准备工作&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#二准备工作&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;二、准备工作&lt;/h2&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-1安装插件&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#1安装插件&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;1、安装插件&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;&lt;pre&gt;sudo gem install cocoapods-imy-bin&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-三使用二进制组件&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#三使用二进制组件&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;三、使用二进制组件&lt;/h2&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-1环境搭建&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#1环境搭建&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;1、环境搭建&lt;/h3&gt;
&lt;br/&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/su350380433/cocoapods-imy-bin-demo&quot;&gt;环境搭建详细教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用二进制时，本插件需要提供以下资源：&lt;/p&gt;

&lt;h3&gt;&lt;a id=&quot;user-content-2初始化插件&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#2初始化插件&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;2、初始化插件&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;&lt;pre&gt;xx:Demo slj$ pod bin init

======  dev 环境 ========

开始设置二进制化初始信息.
所有的信息都会保存在 /Users/slj/.cocoapods/bin_dev.yml 文件中.
%w[bin_dev.yml bin_debug_iphoneos.yml bin_release_iphoneos.yml] 
你可以在对应目录下手动添加编辑该文件. 文件包含的配置信息样式如下：

---
configuration_env: dev
code_repo_url: git@github.com:su350380433/example_spec_source.git
binary_repo_url: git@github.com:su350380433/example_spec_bin_dev.git
binary_download_url: http://localhost:8080/frameworks/%s/%s/zip
download_file_type: zip


编译环境
可选值：[ dev / debug_iphoneos / release_iphoneos ]
旧值：dev&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按提示输入&lt;code&gt;所属环境&lt;/code&gt;、源码私有源、二进制私有源、二进制下载地址、下载文件类型后，插件就配置完成了。其中 &lt;code&gt;binary_download_url&lt;/code&gt; 需要预留组件名称与组件版本占位符，插件内部会依次替换 &lt;code&gt;%s&lt;/code&gt; 为相应组件的值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cococapods-imy-bin&lt;/code&gt; 也支持从 url 下载配置文件，方便对多台机器进行配置：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;&lt;pre&gt;➜  &lt;span class=&quot;pl-k&quot;&gt;~&lt;/span&gt; pod bin init --bin-url=https://github.com/su350380433/cocoapods-imy-bin-configs/raw/master/bin_dev.yml&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置文件模版内容如下，根据不同团队的需求定制即可：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;&lt;pre&gt;---
configuration_env: dev
code_repo_url: git@github.com:su350380433/example_spec_source.git
binary_repo_url: git@github.com:su350380433/example_spec_bin_dev.git
binary_download_url: http://localhost:8080/frameworks/%s/%s/zip
download_file_type: zip
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置时，不需要手动添加源码和二进制私有源的 repo，插件在找不到对应 repo 时会主动 clone。&lt;/p&gt;
&lt;p&gt;记得启动 &lt;code&gt;sudo mongod&lt;/code&gt;服务，静态资源服务。&lt;/p&gt;
&lt;br/&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-四制作二进制组件&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#四制作二进制组件&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;四、制作二进制组件&lt;/h2&gt;
&lt;br/&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MeetYouDevs/cocoapods-imy-bin/tree/master/%E6%BC%94%E7%A4%BA%E8%A7%86%E9%A2%91&quot;&gt;视频演示&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-1制作命令&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#1制作命令&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;1、制作命令&lt;/h3&gt;
&lt;p&gt;可以直接使用插件的 &lt;code&gt;pod bin auto&lt;/code&gt;命令，在插件初始化配置完成后，目录下只要有包含podspec文件，根据podspec文件的version版本号会自动化执行build、组装二进制组件、制作二进制podspec、上传二进制文件、上传二进制podspec到私有源仓库。&lt;/p&gt;

&lt;p&gt;带上&lt;code&gt;—all-make&lt;/code&gt;参数会把当前组件所依赖的组件都自动化制作成二进制组件。&lt;/p&gt;

&lt;p&gt;pod bin local 是配合其他三方编译产物的命令，需要配置编译产物的目录。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BinArchive.json&lt;/code&gt;是制作二进制的一些配置项，放在项目跟目录下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-json&quot;&gt;&lt;pre&gt;{
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;//&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;archive-white-pod-list 不制作二进制白名单，&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;archive-white-pod-list&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; : [
        &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;YYTargetDemo&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
        &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;YYModel&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
    ],
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;//&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;ignore-git-list 不制作二进制 所属git白名单，&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;ignore-git-list&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;: [
        &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;git@gitlab.xxx.com:Github-iOS&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
    ],
     &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;//&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;ignore-http-list 不制作二进制 所属https白名单，&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;ignore-http-list&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;: [
        &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;https://gitlab.xxx.com/Github-iOS&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
    ],
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;//&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;xcode_build_path 设置编译缓存完整路径, 默认地址如下&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;xcode_build_path&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; : &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;xcode-build/Build/Intermediates.noindex/ArchiveIntermediates/#{target_name}/IntermediateBuildFilesPath/UninstalledProducts/iphoneos/&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
}&lt;/pre&gt;&lt;/div&gt;
&lt;br/&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-2-二进制podspec&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#2-二进制podspec&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;2. 二进制Podspec&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;pod bin auto&lt;/code&gt;和&lt;code&gt;pod bin local&lt;/code&gt;二进制Podspec 会自动生成、上传，无需关心。&lt;/p&gt;
&lt;br/&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-3查看结果&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#3查看结果&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;3、查看结果&lt;/h3&gt;
&lt;p&gt;二进制存储服务：&lt;a href=&quot;http://localhost:8080/frameworks/&quot; rel=&quot;nofollow&quot;&gt;http://localhost:8080/frameworks/&lt;/a&gt;（默认本地8080端口）&lt;/p&gt;
&lt;p&gt;二进制私有源参考：&lt;a href=&quot;https://github.com/su350380433/example_spec_bin_dev&quot;&gt;https://github.com/su350380433/example_spec_bin_dev&lt;/a&gt;（自定义）&lt;/p&gt;
&lt;br/&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-4使用二进制&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#4使用二进制&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;4、使用二进制&lt;/h3&gt;
&lt;br/&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MeetYouDevs/cocoapods-imy-bin/tree/master/%E6%BC%94%E7%A4%BA%E8%A7%86%E9%A2%91&quot;&gt;视频演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Podfile文件中，加入这两行代码，对已经制作二进制的就会生效，自动转换二进制组件依赖。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ruby&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-en&quot;&gt;plugin&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&#x27;cocoapods-imy-bin&#x27;&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;use_binaries!&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;br/&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-五扩展功能&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#五扩展功能&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;五、扩展功能&lt;/h2&gt;
&lt;br/&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-1本地配置文件---podfile_local&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#1本地配置文件---podfile_local&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;1、本地配置文件 - Podfile_local&lt;/h3&gt;
&lt;p&gt;本地组件配置文件 Podfile_local，目前已支持Podfile下的大部分功能，可以把一些本地配置的语句放到Podfile_local。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://raw.githubusercontent.com/MeetYouDevs/cocoapods-imy-bin/master/img/Podfile_local.png&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/MeetYouDevs/cocoapods-imy-bin/master/img/Podfile_local.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;场景:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不希望把本地采用的源码/二进制配置、本地库传到远程仓库。&lt;/li&gt;
&lt;li&gt;避免直接修改Podfile文件，引起更新代码时冲突、或者误提交。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如Podfile本地库的写法：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ruby&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-en&quot;&gt;pod&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;YYModel&lt;/span&gt; &lt;span class=&quot;pl-pds&quot;&gt;:path&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&#x27;../&#x27;&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;#提交的时候往往要修改回来才提交，操作繁琐&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;在与Podfile同级目录下，新增一个&lt;code&gt;Podfile_local&lt;/code&gt;文件&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ruby&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-c&quot;&gt;#target &#x27;Seeyou&#x27; do 不同的项目注意修改下Seeyou的值&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;#:path =&amp;gt; &#x27;../IMYYQHome&#x27;,根据实际情况自行修改，与之前在podfile写法一致&lt;/span&gt;


 &lt;span class=&quot;pl-en&quot;&gt;plugin&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&#x27;cocoapods-imy-bin&#x27;&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;#是否启用二进制插件，想开启把下面注释去掉&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;# use_binaries! &lt;/span&gt;

&lt;span class=&quot;pl-c&quot;&gt;#设置使用【源码】版本的组件。&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;#set_use_source_pods [&#x27;YYKit&#x27;,&#x27;SDWebImaage&#x27;]&lt;/span&gt;

&lt;span class=&quot;pl-c&quot;&gt;#需要替换Podfile里面的组件才写到这里&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;#在这里面的所写的组件库依赖，默认切换为【源码】依赖&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&#x27;Seeyou&#x27;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;#本地库引用&lt;/span&gt;
&lt;span class=&quot;pl-c&quot;&gt;#pod &#x27;YYModel&#x27;, :path =&amp;gt; &#x27;../YYModel&#x27;&lt;/span&gt;

  &lt;span class=&quot;pl-c&quot;&gt;#覆盖、自定义组件&lt;/span&gt;
  &lt;span class=&quot;pl-c&quot;&gt;#pod &#x27;YYCache&#x27;, :podspec =&amp;gt; &#x27;http://覆盖、自定义/&#x27;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-ruby&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-en&quot;&gt;以前的&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;pod&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;update&lt;/span&gt; --&lt;span class=&quot;pl-en&quot;&gt;no&lt;/span&gt;-&lt;span class=&quot;pl-en&quot;&gt;repo&lt;/span&gt;-&lt;span class=&quot;pl-en&quot;&gt;update&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;命令加个前缀&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;`bin`&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;变成&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;&lt;pre&gt;pod bin update --no-repo-update &lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or&lt;/p&gt;

&lt;p&gt;支持 pod install/update 命令参数&lt;/p&gt;
&lt;p&gt;并将其加入 .gitignore ，再也不用担心我误提交或者冲突了，Podfile_local 中的配置选项优先级比 Podfile 高，支持和 Podfile 相同的配置语句，同时支持&lt;strong&gt;pre_install&lt;/strong&gt; or &lt;strong&gt;post_install&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果您不习惯Podfile_local的使用方式，可以把命令写在Podfile里面，pod时不需要加bin，依旧是 pod update/install。&lt;/p&gt;
&lt;br/&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-2二进制源码调试&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#2二进制源码调试&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;2、二进制源码调试&lt;/h3&gt;
&lt;br/&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MeetYouDevs/cocoapods-imy-bin/tree/master/%E6%BC%94%E7%A4%BA%E8%A7%86%E9%A2%91&quot;&gt;视频演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在项目根目录下，输入命令:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;YYModel&lt;/code&gt;为需要源码调试的组件库名称。成功之后像平时一样单步调试，控制台打印变量。让我们同时拥有使用二进制的便利和源码调试的能力。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;&lt;pre&gt; $ pod bin code --help                                                                   [11:37:50]
Usage:

    $ pod bin code [NAME]

      通过将二进制对应源码放置在临时目录中，让二进制出现断点时可以跳到对应的源码，方便调试。 在不删除二进制的情况下为某个组件添加源码调试能力，多个组件名称用空格分隔

Options:

    --all-clean   删除所有已经下载的源码
    --clean       删除所有指定下载的源码
    --list        展示所有一级下载的源码以及其大小
    --source      源码路径，本地路径,会去自动链接本地源码&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果与演示参考&lt;a href=&quot;https://juejin.im/post/5eccceb9f265da76f30e4e13#heading-48&quot; rel=&quot;nofollow&quot;&gt;链接1&lt;/a&gt;、&lt;a href=&quot;https://github.com/MeetYouDevs/cocoapods-imy-bin/tree/master/%E6%BC%94%E7%A4%BA%E8%A7%86%E9%A2%91&quot;&gt;视频&lt;/a&gt;&lt;/p&gt;
&lt;br/&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-3快捷键命令&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#3快捷键命令&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;3、快捷键命令&lt;/h3&gt;
&lt;br/&gt;
&lt;p&gt;在任意的终端执行命令，都能执行特定目录下特定命令&lt;/p&gt;
&lt;p&gt;使用命令：&lt;/p&gt;

&lt;p&gt;or&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;&lt;pre&gt;pod bin imy 2    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;2 是自定义的快捷键&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用场景:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 在任意目录下，执行项目A的pod update --no-repo-update命令
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令快捷键配置&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;&lt;pre&gt; $ pod bin inithk                                                                        [11:37:58]

开始设置快捷键 pod bin imy.
所有的信息都会保存在 /Users/ci/.cocoapods/hot_key_1.yml 文件中.
%w[hot_key.yaml] 
你可以在对应目录下手动添加编辑该文件. 文件包含的配置信息样式如下：

---
hot_key_index: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&#x27;&lt;/span&gt;1&lt;span class=&quot;pl-pds&quot;&gt;&#x27;&lt;/span&gt;&lt;/span&gt;
hot_key_dir: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&#x27;&lt;/span&gt;/User/ci/自定义目录&lt;span class=&quot;pl-pds&quot;&gt;&#x27;&lt;/span&gt;&lt;/span&gt;
hot_key_cmd: pod bin update --no-repo-update


快捷键
可选值：[ 1 / 2 / 3... ]
旧值：1 &lt;/pre&gt;&lt;/div&gt;
&lt;br/&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-六-dsl参数解释&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#六-dsl参数解释&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;六、 DSL参数解释&lt;/h2&gt;
&lt;p&gt;首先，开发者需要在 Podfile 中需要使用 &lt;code&gt;plugin &#x27;cocoapods-imy-bin&#x27;&lt;/code&gt; 语句引入插件&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ruby&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-en&quot;&gt;plugin&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&#x27;cocoapods-imy-bin&#x27;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;顺带可以删除 Podfile 中的 source ，因为插件内部会自动帮你添加两个私有源。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cocoapods-bin &lt;/code&gt;插件提供二进制相关的配置语句有 &lt;code&gt;use_binaries!&lt;/code&gt;、&lt;code&gt;use_binaries_with_spec_selector!&lt;/code&gt; 以及 &lt;code&gt;set_use_source_pods&lt;/code&gt;，下面会分别介绍。&lt;/p&gt;
&lt;h5&gt;&lt;a id=&quot;user-content-use_binaries&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#use_binaries&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;use_binaries!&lt;/h5&gt;
&lt;p&gt;全部组件使用二进制版本。&lt;/p&gt;
&lt;p&gt;支持传入布尔值控制是否使用二进制版本，比如 DEBUG 包使用二进制版本，正式包使用源码版本，Podfile 关联语句可以这样写：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ruby&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-en&quot;&gt;use_binaries!&lt;/span&gt; &lt;span class=&quot;pl-kos&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;ENV&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&#x27;DEBUG&#x27;&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;nil?&lt;/span&gt; || &lt;span class=&quot;pl-c1&quot;&gt;ENV&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&#x27;DEBUG&#x27;&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;]&lt;/span&gt; == &lt;span class=&quot;pl-s&quot;&gt;&#x27;true&#x27;&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;&lt;a id=&quot;user-content-set_use_source_pods&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#set_use_source_pods&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;set_use_source_pods&lt;/h5&gt;
&lt;p&gt;设置使用源码版本的组件。&lt;/p&gt;
&lt;p&gt;实际开发中，可能需要查看 YYModel 组件的源码，这时候可以这么设置：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ruby&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-en&quot;&gt;set_use_source_pods&lt;/span&gt; &lt;span class=&quot;pl-kos&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&#x27;YYModel&#x27;&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;]&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果 CocoaPods 版本为 1.5.3 ，终端会输出以下内容，表示 YYModel 的参照源从二进制私有源切换到了源码私有源：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ruby&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-en&quot;&gt;Analyzing&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;dependencies&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;Fetching&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;podspec&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;`A`&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;`../`&lt;/span&gt;
&lt;span class=&quot;pl-v&quot;&gt;Downloading&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;dependencies&lt;/span&gt;
&lt;span class=&quot;pl-v&quot;&gt;Using&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;pl-kos&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-en&quot;/&gt;&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-v&quot;&gt;Installing&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;YYModel&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;4.2&lt;/span&gt; &lt;span class=&quot;pl-kos&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;changed&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;`git@git.xxxxxx.net:ios/cocoapods-spec.git`&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;`git@git.xxxxxx.net:ios/cocoapods-spec-binary.git`&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-v&quot;&gt;Generating&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Pods&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;project&lt;/span&gt;
&lt;span class=&quot;pl-v&quot;&gt;Integrating&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;project&lt;/span&gt;
&lt;span class=&quot;pl-v&quot;&gt;Sending&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;stats&lt;/span&gt;
&lt;span class=&quot;pl-v&quot;&gt;Pod&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;installation&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;complete!&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;There&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;dependency&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;Podfile&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;pods&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;installed&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;.&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;&lt;a id=&quot;user-content-use_binaries_with_spec_selector&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#use_binaries_with_spec_selector&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;use_binaries_with_spec_selector!&lt;/h5&gt;
&lt;p&gt;过滤出需要使用二进制版本组件。&lt;/p&gt;
&lt;p&gt;假如开发者只需要 &lt;code&gt;YYModel&lt;/code&gt; 的二进制版本，那么他可以在 Podfile 中添加以下代码：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ruby&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-en&quot;&gt;use_binaries_with_spec_selector!&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;do&lt;/span&gt; |&lt;span class=&quot;pl-s1&quot;&gt;spec&lt;/span&gt;|
  &lt;span class=&quot;pl-s1&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;name&lt;/span&gt; == &lt;span class=&quot;pl-s&quot;&gt;&#x27;YYModel&#x27;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是，如果组件有 subspec ，使用组件名作为判断条件应如下&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ruby&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-en&quot;&gt;use_binaries_with_spec_selector!&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;do&lt;/span&gt; |&lt;span class=&quot;pl-s1&quot;&gt;spec&lt;/span&gt;|
  &lt;span class=&quot;pl-s1&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;start_with?&lt;/span&gt; == &lt;span class=&quot;pl-s&quot;&gt;&#x27;组件名&#x27;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果像上个代码块一样，&lt;strong&gt;直接对比组件名，则插件会忽略此组件的所有 subspec，导致资源拉取错误&lt;/strong&gt;，这种场景下，最好通过 &lt;code&gt;set_use_source_pods&lt;/code&gt; 语句配置依赖。&lt;/p&gt;
&lt;p&gt;一个实际应用是，三方组件采用二进制版本，团队编写的组件依旧采用源码版本。如果三方组件都在 &lt;code&gt;cocoapods-repo&lt;/code&gt; 组下，就可以使用以下代码过滤出三方组件：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ruby&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-en&quot;&gt;use_binaries_with_spec_selector!&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;do&lt;/span&gt; |&lt;span class=&quot;pl-s1&quot;&gt;spec&lt;/span&gt;|
 &lt;span class=&quot;pl-s1&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;source&lt;/span&gt; &amp;amp;&amp;amp; &lt;span class=&quot;pl-s1&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&#x27;git&#x27;&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;pl-s1&quot;&gt;git&lt;/span&gt; &amp;amp;&amp;amp; &lt;span class=&quot;pl-s1&quot;&gt;git&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;include?&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&#x27;cocoapods-repo&#x27;&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;&lt;a id=&quot;user-content-切换devdebug_iphoneosrelease_iphoneos环境初始化设置&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#切换devdebug_iphoneosrelease_iphoneos环境初始化设置&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;切换Dev/Debug_iPhoneos/Release_iPhoneos环境初始化设置&lt;/h5&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;dev 初始化插件配置 默认dev环境&lt;/span&gt;
pod bin init --bin-url=https://gitlab.xxx.com/cocoapods-imy-bin-config/raw/master/bin_dev.yml

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;Debug_iPhoneos 初始化插件配置&lt;/span&gt;
pod bin init --bin-url=https://gitlab.xxx.com/cocoapods-imy-bin-config/raw/master/bin_debug_iphoneos.yml


&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;release_iPhoneos 初始化插件配置&lt;/span&gt;
pod bin init --bin-url=https://gitlab.xxx.com/cocoapods-imy-bin-config/raw/master/bin_release_iphoneos.yml&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用时在podfile 或者 podfile_local指定设置&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt;在podfile 或者 podfile_local 文件下加这句话&lt;/span&gt;
set_configuration_env(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&#x27;&lt;/span&gt;debug_iphoneos&lt;span class=&quot;pl-pds&quot;&gt;&#x27;&lt;/span&gt;&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;&lt;a id=&quot;user-content-其他设置&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#其他设置&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;其他设置&lt;/h5&gt;
&lt;p&gt;插件默认开启多线程下载组件资源，如果要禁用这个功能，Podfile 添加以下代码即可：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ruby&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-en&quot;&gt;install!&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&#x27;cocoapods&#x27;&lt;/span&gt;&lt;span class=&quot;pl-kos&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;pl-kos&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;pl-pds&quot;&gt;install_with_multi_threads&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;pl-kos&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;br/&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-七感谢&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#七感谢&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;七、感谢&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/tripleCC/cocoapods-bin&quot;&gt;cocoapods-bin&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tech.meituan.com/2019/08/08/the-things-behind-the-ios-project-zsource-command.html&quot; rel=&quot;nofollow&quot;&gt;美团 iOS 工程 zsource 命令背后的那些事儿&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;a id=&quot;user-content-您有什么更好的想法可以提出来我们一起来实现共创一个强大的工具平台同时也欢迎给我们提pr&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#您有什么更好的想法可以提出来我们一起来实现共创一个强大的工具平台同时也欢迎给我们提pr&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;您有什么更好的想法，可以提出来，我们一起来实现，共创一个强大的工具平台，同时也欢迎给我们提PR。&lt;/h4&gt;
&lt;p&gt;微信号：su1231235&lt;/p&gt;
&lt;/article&gt;
      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>