<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e92c589169bdb6d30fc38cba86272862</guid>
<title>性能优化：如何更快地接收数据</title>
<link>https://toutiao.io/k/vf7kpbe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;69&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.11875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/OdIoEOgFgUGcibO4v5qxt8aOe6ArwX6qwM3icvwPccBDAjM1eoJTf9QbJ2WcUicIw5QkOiasIKgvNV56qWIXqTcBicg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从网卡到应用程序，数据包会经过一系列组件，其中驱动做了什么？内核做了什么？为了优化，我们又能做些什么？整个过程中涉及到诸多细微可调的软硬件参数，并且相互影响，不存在一劳永逸的“银弹”。本文中又拍云系统开发高级工程师杨鹏将结合自己的的实践经验，介绍在深入理解底层机制的基础上如何做出“场景化”的最优配置。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;文章根据杨鹏在又拍云 Open Talk 技术沙龙北京站主题演讲《性能优化：更快地接收数据》整理而成，现场视频及 PPT 可下拉文末点击阅读原文查看。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;大&lt;/span&gt;&lt;span&gt;家好，我是又拍云开发工程师杨鹏，在又拍云工作已有四年时间，期间一直从事 CDN 底层系统开发的工作，负责调度、缓存、负载均衡等 CDN &lt;/span&gt;&lt;span&gt;的核心组件&lt;/span&gt;&lt;span&gt;，很高兴来跟大家分享在网络数据处理方面的经验和感受。&lt;/span&gt;&lt;span&gt;今天分享的主题是&lt;/span&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;如何更快&lt;/span&gt;&lt;span&gt;地&lt;/span&gt;&lt;span&gt;接收数据&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;span&gt;，主要介绍加速网络数据处理的方法和实践。&lt;/span&gt;&lt;span&gt;希望能帮助大家更好的了解如何在系统的层面，尽量在应用程序无感的情况下做到极致的优化。&lt;/span&gt;&lt;span&gt;言&lt;/span&gt;&lt;span&gt;归正传，进入主题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首&lt;/span&gt;&lt;span&gt;先需要清楚在尝试做任何优化的时候，想到的第一件事情应该是什么&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;人觉得是衡量指标&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;做任何&lt;/span&gt;&lt;span&gt;改动&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;优化之前，都要明确地知道&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;是怎样的指标反映出了当前的问题。&lt;/span&gt;&lt;span&gt;那么在做了相应的调整或改动之后，也才能通过指标去验证实际效果与作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对要分享的主题，有一个围绕上面指标核心的基本原则。&lt;/span&gt;&lt;span&gt;在网络层面做优化，归根结底只需要看一点，假如可以做到网络栈的每个层次，加入能监控到对应层次的丢包率，这样核心的指标，就可以明确地知道问题出在哪一层。&lt;/span&gt;&lt;span&gt;有了明确可监控的指标，之后做相应的调整与实际效果的验证也就很简单了。&lt;/span&gt;&lt;span&gt;当然上述两点相对有点&lt;/span&gt;&lt;span&gt;虚&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;接下来就&lt;/span&gt;&lt;span&gt;是比较干的部分&lt;/span&gt;&lt;span&gt;了&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;367&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6354775828460039&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6ZibspoCcvBZr7f4BSCtZd3dDqykckvQgQST90aIvcpLnUUqsic6XjfJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1026&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，&lt;/span&gt;&lt;span&gt;当&lt;/span&gt;&lt;span&gt;收到&lt;/span&gt;&lt;span&gt;一个数据&lt;/span&gt;&lt;span&gt;包&lt;/span&gt;&lt;span&gt;，从&lt;/span&gt;&lt;span&gt;进入网卡&lt;/span&gt;&lt;span&gt;，一直到达应用层，总的数据流程&lt;/span&gt;&lt;span&gt;有&lt;/span&gt;&lt;span&gt;很多&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;在当前阶段&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;无需关注每个流程，留意其中几个核心的关键路径即可&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上是三个关键的路径。&lt;/span&gt;&lt;span&gt;上&lt;/span&gt;&lt;span&gt;图中右边的手绘图指的&lt;/span&gt;&lt;span&gt;就是&lt;/span&gt;&lt;span&gt;这三个步骤，并有意区分了两个颜色。&lt;/span&gt;&lt;span&gt;之所以这么区分是&lt;/span&gt;&lt;span&gt;因为&lt;/span&gt;&lt;strong&gt;&lt;span&gt;接下来会按这两部分进行分享，一是上层驱动部分，二是下层涉及到内核的部分。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;当然内核比较多，通篇只涉及到内核网络子系统，更具体来说是内核跟驱动交互部分的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;网卡驱动&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;网卡驱动的部分，网卡是硬件，驱动（driver）是软件，包括了网卡驱动部分的大部分。&lt;/span&gt;&lt;span&gt;这部分可简单分四个点，依次是初始化、启动、监控与调优驱动它的初始化流程。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;网卡驱动-初始化 &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;驱动初始化&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;过程&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;硬件相关，无需过分关注。&lt;/span&gt;&lt;span&gt;但需注意一点就是注册 ethool 的一系列操作，这个工具可以对网卡做各种各样的操作，不止&lt;/span&gt;&lt;span&gt;可以&lt;/span&gt;&lt;span&gt;读取网卡的&lt;/span&gt;&lt;span&gt;配置，&lt;/span&gt;&lt;span&gt;还可以更改网卡的&lt;/span&gt;&lt;span&gt;配置&lt;/span&gt;&lt;span&gt;参数，是&lt;/span&gt;&lt;span&gt;一个&lt;/span&gt;&lt;span&gt;非常强大的工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那&lt;/span&gt;&lt;span&gt;它是如何控制网卡的呢&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;span&gt;每&lt;/span&gt;&lt;span&gt;个网卡的驱动在初始化时，通过接口，去注册支持 ethool 工具的一系列操作。&lt;/span&gt;&lt;span&gt;ethool 是一套很通用的接口，比如说它支持 100 个功能，但每个型号的网卡，只能支持一个&lt;/span&gt;&lt;span&gt;子集&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;所以具体支持哪些功能，会在这一步进行声明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;322&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5572374645222328&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6WgANs0IGcV3icPZMicYan6uJSyZZNU4P3mVNzukrJJj2Tsk507y2tETA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1057&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上&lt;/span&gt;&lt;span&gt;图截取的部分，是在初始化时&lt;/span&gt;&lt;span&gt;结构体的赋值。&lt;/span&gt;&lt;span&gt;前面两个可以简单看一下，驱动在初始化的时候会告诉内核，如果想要操作这块网卡对应的回调函数&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;其中最主要的是启动和关闭，有用 ifconfig 工具操作网卡的应该都很熟悉，当用 ifconfig &lt;/span&gt;&lt;span&gt;up/down &lt;/span&gt;&lt;span&gt;一张网卡的时候，调用的都是它初始化时&lt;/span&gt;&lt;span&gt;指定&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;这&lt;/span&gt;&lt;span&gt;几个函数。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;网卡驱动-启动&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;驱动初始化过程之后就是启动（open）中的流程了，一共分为四步：&lt;/span&gt;&lt;span&gt;分配&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;rx/tx&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;队列内存、&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开启 NAPI、注册中断处理函数、开启中断。&lt;/span&gt;&lt;span&gt;其中注册中断处理函数和开启中断是理所当然的，任何一个硬件接入到机器上都需要做这个操作。&lt;/span&gt;&lt;span&gt;当后面收到一些事件时，它需要通过中断去通知系统，然后开启中断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二步的 NAPI 后面会详细说明&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;这里先重点关注启动过程中对内存的分配。&lt;/span&gt;&lt;span&gt;网卡在收到数据时，都必须把数据从链路层拷贝到机器的内存里，而这块内存就是网卡在启动时，通过接口向内核、向操作系统申请而来的。&lt;/span&gt;&lt;span&gt;内存一旦申请下来，地址确定之后，后续网卡在收到数据的时候，就可以直接通过 DMA 的机制，直接把数据包传送到内存固定的地址中去，甚至不需要 CPU 的参与。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;407&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7038269550748752&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d62foTz8b7cs9jBILKcttLEYyFHicVwaKmcy0WqXKia7RP81vBap7OH4Tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到队列内存的分配可以看下上图，很早之前的网卡都是单队列的机制，但现代的网卡大多都是多队列的。&lt;/span&gt;&lt;span&gt;好处就是机器网卡的数据接收可以被负载均衡到多个 CPU 上，因此会提供多个队列，这里先有个概念后面会详细说明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;412&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7127659574468085&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6aSo4giaGYvwLLic9Dg4ia5gq4dDI37FXd8GP3nLIYL79hVGuKOW3OGFGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;752&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下&lt;/span&gt;&lt;span&gt;面来详细介绍启动过程中的第二步 NAPI，这是现代网络数据包处理框架中非常重要的一个扩展。&lt;/span&gt;&lt;span&gt;之所以现在能支持&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;10G、20G、25G&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;等非常高速的网卡，NAPI 机制起到了非常大的作用。&lt;/span&gt;&lt;span&gt;当然 NAPI 并不复杂，其核心就两点：&lt;/span&gt;&lt;span&gt;中断、轮循。&lt;/span&gt;&lt;span&gt;一般来说，网卡在接收数据时肯定是收一个包，产生一个中断，然后在中断处理函数的时候将包处理掉。&lt;/span&gt;&lt;span&gt;处在收包、处理中断，下一个收包，再处理中断，这样的循环中。&lt;/span&gt;&lt;span&gt;而 NAPI 机制优势在于只需要一次中断，收到之后就可以通过轮循的方式，把队列内存中所有的数据都拿走，达到非常高效的状态。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;网卡驱动-监控&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来就是在驱动这层可以做的监控了，需要去关注其中一些数据的来源。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;sudo ethtool -S eth0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;NIC&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;statistics:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;rx_packets&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;597028087&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;tx_packets&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;5924278060&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;rx_bytes&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;112643393747&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;tx_bytes&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;990080156714&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;rx_broadcast&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;96&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;tx_broadcast&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;116&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;rx_multicast&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;20294528&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__meta&quot;&gt;....&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;首先非常重要的是&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ethool 工具，它可以拿到网卡中统计的数据&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;接收的包数量、处理的流量等等常规的信息，而我们更多的是需要关注到异常信息。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ cat /sys/&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt;/&lt;span class=&quot;code-snippet__title&quot;&gt;net&lt;/span&gt;/&lt;span class=&quot;code-snippet__title&quot;&gt;eth0&lt;/span&gt;/&lt;span class=&quot;code-snippet__title&quot;&gt;statistics&lt;/span&gt;/&lt;span class=&quot;code-snippet__title&quot;&gt;rx_dropped&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;通过 sysfs 的接口，可以看到网卡的丢包数，这就是系统出现异常的一个标志。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;86&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.14858705560619873&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d61dMk5rkAnL9IBXlicPveKc0Ls5aodTRy1XAvRyhWTlubvTS3PzHb5NA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1097&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三个途径拿到的信息与前面差不多，只是格式有些乱，仅做了解即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;297&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5144270403957131&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6sZQzK1yMuOwLl49ibFgGic9n1SibIBNmeibyOdgtiaq2h9bkeVvj4nQSAaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1213&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是要分享的一个线上案例。&lt;/span&gt;&lt;span&gt;当时业务上出现异常，经过排查最后是怀疑到网卡这层，为此需要做进一步的分析。&lt;/span&gt;&lt;span&gt;通过 ifconfig 工具可以很直观的查看到网卡的一些统计数据，图中可以看到网卡的 errors 数据指标非常高，明显出现了问题。&lt;/span&gt;&lt;span&gt;但更有意思的一点是， errors 右边最后的 frame 指标数值跟它完全相同。&lt;/span&gt;&lt;span&gt;因为 errors 指标是网卡中很多错误累加之后的指标，与它相邻的 dropped、overruns 这俩个指标都是零，也就是说在当时的状态下，网卡的错误大部分来自 frame。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然这只是瞬时的状态，上图中下面部分是监控数据，可以明显看到波动的变化，确实是某一台机器异常了。&lt;/span&gt;&lt;span&gt;frame 错误一般是在网卡收到数据包，进行 RCR 校验时失败导致的。&lt;/span&gt;&lt;span&gt;当收到数据包，会对该包中的内容做校验，当发现跟已经存下来的校验不匹配，说明包是损坏的，因此会直接将其丢掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个原因是比较好分析的，两点一线，机器的网卡通过网线接到上联交换机。&lt;/span&gt;&lt;span&gt;当这里出现问题，不是网线就是机器本身的网卡问题，或者是对端交换机的端口，也就是上联交换机端口出现问题。&lt;/span&gt;&lt;span&gt;当然按第一优先级去分析，协调运维去更换了机器对应的网线，后面的指标情况也反映出了效果，指标直接突降直到完全消失，错误也就不复存在了，对应上层的业务也很快恢复了正常。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;网卡驱动-调优&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;说完监控之后来看下最后的调优。&lt;/span&gt;&lt;span&gt;在这个层面能调整的东西不多，主要是针对网卡多队列的调整，比较直观。&lt;/span&gt;&lt;span&gt;调整队列数目、大小，各队列间的权重，甚至是调整哈希的字段，都是可以的。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;sudo ethtool -l eth0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Channel&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;parameters for eth0:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;Pre-set&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;maximums:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;RX&lt;/span&gt;:   &lt;span class=&quot;code-snippet__string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;TX&lt;/span&gt;:   &lt;span class=&quot;code-snippet__string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Other&lt;/span&gt;:    &lt;span class=&quot;code-snippet__string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Combined&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Current&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;hardware settings:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;RX&lt;/span&gt;:   &lt;span class=&quot;code-snippet__string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;TX&lt;/span&gt;:   &lt;span class=&quot;code-snippet__string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Other&lt;/span&gt;:    &lt;span class=&quot;code-snippet__string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Combined&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上图是针对多队列的调整。&lt;/span&gt;&lt;span&gt;为了说明刚才的概念，举个例子，比如有个 web server 绑定到了 CPU2，而机器有多个 CPU，这个机器的网卡也是多队列的，其中某个队列会被 CPU2 处理。&lt;/span&gt;&lt;span&gt;这个时候就会有一个问题，因为网卡有多个队列，所以 80 端口的流量只会被分配到其中一个队列上去。&lt;/span&gt;&lt;span&gt;假如这个队列不是由 CPU2 处理的，就会涉及到一些数据的腾挪。&lt;/span&gt;&lt;span&gt;底层把数据接收上来后再交给应用层的时候，需要把这个数据移动一下。&lt;/span&gt;&lt;span&gt;如果本来在 CPU1 处理的，需要挪到 CPU2 去，这时会涉及到 CPU cache 的失效，这对高速运转的 CPU 来说是代价很高的操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么该怎么做呢？&lt;/span&gt;&lt;span&gt;我们可以通过前面提到的工具，特意把 80 端口 tcp 数据流量导向到对应 CPU2 处理的网卡队列。&lt;/span&gt;&lt;span&gt;这么做的效果是数据包从到达网卡开始，到内核处理完再到送达应用层，都是同一个 CPU。&lt;/span&gt;&lt;span&gt;这样最大的好处就是缓存，CPU 的 cache 始终是热的，如此整体下来，它的延迟、效果也会非常好。&lt;/span&gt;&lt;span&gt;当然这个例子并不实际，主要是为了说明能做到的一个效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;内核网络子系统&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;说完了整个网卡驱动部分，接下来是讲解内核子系统部分，这块会分为软中断与网络子系统初始化两部分来分享。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;软中断&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;229&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3969298245614035&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6dLltHTavYDU2DoR89d3HUQiagpEerpmS7eFM1dFZWl5rgrWiaqic7vgWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;912&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图的 NETDEV 是 linux 网络子系统每年都会开的一个分会，其中比较有意思的点是每年大会举办的届数会以一个特殊字符来表示。&lt;/span&gt;&lt;span&gt;图中是办到了 0X15 届，想必也都发现这是 16 进制的数字，0X15 刚好就是 21 年，也是比较极客范。&lt;/span&gt;&lt;span&gt;对网络子系统感兴趣的可以去关注一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;448&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7752126366950183&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6CSXPyicoQ57AjIkoXhCo67o3smyz1dgE17Eb4UsLBicwDnxc9esTjmNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;言归正传，内核延时任务有多种机制，而软中断只是其中一种。&lt;/span&gt;&lt;span&gt;上图是 linux 的基本结构，上层是用户态，中间是内核，下层是硬件，很抽象的一个分层。&lt;/span&gt;&lt;span&gt;用户态和内核态之间会有两种交互的方式：&lt;/span&gt;&lt;span&gt;通过系统调用，或者通过异常可以陷入到内核态里面。&lt;/span&gt;&lt;span&gt;那底层的硬件跟内核又是怎么交互的呢？&lt;/span&gt;&lt;span&gt;答案是中断，硬件跟内核交互的时候必须通过中断，处理任何事件都需要产生一个中断信号来告知 CPU 与内核。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过这样的机制一般情况下也许没有问题，但是对网络数据来说，一个数据报一个中断，这样会有很明显的两个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题一：&lt;/span&gt;&lt;span&gt;中断在处理期间，会屏蔽之前的中断信号。&lt;/span&gt;&lt;span&gt;当一个中断处理的时间很长，在处理期间收到的中断信号都会丢掉。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;如果处理一个包用了十秒，在这十秒期间又收到了五个数据包，但因为中断信号丢了，即便前面的处理完了，后面的数据包也不会再处理了。&lt;/span&gt;&lt;span&gt;对应到 tcp 这边，假如客户端给服务端发了一个数据包，几秒后处理完了，但在处理期间客户端又发了后续的三个包，但是服务端后面并不知道，以为只收到了一个包，这时客户端又在等待服务端的回包，如此会导致两边都卡住了，也说明了信号丢失是一个极其严重的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题二：&lt;/span&gt;&lt;span&gt;一个数据包触发一次中断处理的话，当有大量的数据包到来后，就会产生非常大量的中断。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;如果达到了 10 万、50 万、甚至百万的 pps，那 CPU 就需要处理大量的网络中断，也就不用干其他事情了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;而针对以上两点问题的解决方法就是让中断处理尽可能的短。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;具体来说，不能在中断处理函数，只能把它揪出来，交到软中断机制里。&lt;/span&gt;&lt;span&gt;这样之后的实际结果是硬件的中断处理做的事情就很少了，将接收数据等一些必须的事情交到软中断去完成，这也是软中断存在的意义。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;smp_hotplug_thread&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;softirq_threads&lt;/span&gt; = {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  .store              = &amp;amp;ksoftirqd,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  .thread_should_run  = ksoftirqd_should_run,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  .thread_fn          = run_ksoftirqd,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  .thread-comm        = “ksoftirqd/%u”,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; _&lt;span class=&quot;code-snippet__function&quot;&gt;init &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;spawn_ksoftirqd&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  regiter_cpu_notifier(&amp;amp;cpu_nfb);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  BUG_ON(smpboot_register_percpu_thread(&amp;amp;softirq_threads));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;early_initcall(spawn_ksoftirqd);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;软中断机制是通过内核的线程来实现的。&lt;/span&gt;&lt;span&gt;图中是对应的一个内核线程。&lt;/span&gt;&lt;span&gt;服务器 CPU 都会有一个 ksoftirqd 这样的内核线程，多 CPU 的机器会相对应的有多个线程。&lt;/span&gt;&lt;span&gt;图中结构体最后一个成员 ksoftirqd/，如果有三个 CPU 对应就会有 /0/1/2 三个内核线程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;274&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.47342995169082125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6GnpS7VyxdbJJqeSYbnT625efpRlibdcicVfDCNqM64vGJFpkT3VLVugw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1035&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;软中断机制的信息在 softirqs 下面可以看到。&lt;/span&gt;&lt;span&gt;软中断并不多只有几种，其中需要关注的，跟网络相关的就是 NET-TX 和 NET-RX，网络数据收发的两种场景。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;内核初始化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;铺垫完软中断之后，下面来看内核初始化的流程。&lt;/span&gt;&lt;span&gt;主要为两步：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;409&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7073446327683616&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6uxvJibBrMdU0oBY86Rz0Zhzw3VfLcpILemGYLcDpqoCKRWmeFRJkiaow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是手绘的一个数据包的处理流程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; irqreturn_t &lt;span class=&quot;code-snippet__title&quot;&gt;igb_msix_ring&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; irq, &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; *data)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;igb_q_vector&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;q_vector&lt;/span&gt; = &lt;span class=&quot;code-snippet__title&quot;&gt;data&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  igb_write_itr(q_vector);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  napi_schedule(&amp;amp;q_vector-&amp;gt;napi);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; IRO_HANDLED;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上面的代码是 igb 网卡驱动中断处理函数做的事情。&lt;/span&gt;&lt;span&gt;如果省略掉开始的变量声明和后面的返回，这个中断处理函数只有两行代码，非常短。&lt;/span&gt;&lt;span&gt;需要关注的是第二个，在硬件中断处理函数中，只用激活外部 NIPA 软中断处理机制，无需做其他任何事情。&lt;/span&gt;&lt;span&gt;因此这个中断处理函数会返回的非常快。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;NIPI 激活&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; ____napi_schedule(&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; softnet_data *sd, &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; napi_struct *napi)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  list_add_tail(&amp;amp;napi-&amp;gt;poll_list, &amp;amp;sd-&amp;gt;poll_list);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _raise_softirq_irqoff(NET_RX_SOFTIRQ);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;NIPI 的激活也很简单，主要为两步。&lt;/span&gt;&lt;span&gt;内核网络系统在初始化的时每个 CPU 都会有一个结构体，它会把队列对应的信息插入到结构体的链表里。&lt;/span&gt;&lt;span&gt;换句话说，每个网卡队列在收到数据的时候，需要把自己的队列信息告诉对应的 CPU，将这两个信息绑定起来，保证某个 CPU 处理某个队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除此之外，还要与触发硬中断一样，需要触发软中断。&lt;/span&gt;&lt;span&gt;下图将很多步骤放到了一块，前面讲过的就不再赘述了。&lt;/span&gt;&lt;span&gt;图中要关注的是软中断是怎么触发的。&lt;/span&gt;&lt;span&gt;与硬中断差不多，软中断也有中断的向量表。&lt;/span&gt;&lt;span&gt;每个中断号，都会对应一个处理函数，当需要处理某个中断，只需要在对应的中断向量表里找就好了，跟硬中断的处理是一模一样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;367&quot; data-backw=&quot;546&quot; data-ratio=&quot;0.6716666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6KpoG50JeNEVFjOLgQLFeibEOBDYR5UHLj7RmNibmdUicSmZPVUNWqZVQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;数据接收-监控&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;说完了运作机制，再来看看有哪些地方可以做监控。&lt;/span&gt;&lt;span&gt;在 proc 下面有很多东西，可以看到中断的处理情况。&lt;/span&gt;&lt;span&gt;第一列就是中断号，每个设备都有独立的中断号，这是写死的。&lt;/span&gt;&lt;span&gt;对网络来说只需要关注网卡对应的中断号，图中是 65、66、67、68 等。&lt;/span&gt;&lt;span&gt;当然看实际的数字并没有意义，而是需要看它的分布情况，中断是不是被不同 CPU 在处理，如果所有的中断都是被一个 CPU 处理，那么就需要做些调整，把它分散开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;211&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.36446886446886445&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6hAtkiaWv5o6CgszfjEC8xCyYm7VtiakzgV824Rhj6PeQmoQXkibWRt2icA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1092&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;数据接收-调优&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;中断可以做的调整有两个：&lt;/span&gt;&lt;span&gt;一是中断合并，二是中断亲和性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;自适应中断合并&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;rx-usecs：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;数据帧到达后，延迟多长时间产生中断信号，单位微秒&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;rx-frames：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;触发中断前积累数据帧的最大个数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;rx-usecs-irq：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;如果有中断处理正在执行，当前中断延迟多久送达 &lt;strong&gt;CPU&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;rx-frames-irq：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;如果有中断处理正在执行，最多积累多少个数据帧&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面列的都是硬件网卡支持的功能。&lt;/span&gt;&lt;span&gt;NAPI 本质上也是中断合并的机制，假如有很多包的到来，NAPI 就可以做到只产生一个中断，因此不需要硬件来帮助做中断合并，实际效果是跟 NAPI 是相同的，都是减少了总的中断数量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;中断亲和性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ sudo bash -c ‘echo &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; &amp;gt; &lt;span class=&quot;code-snippet__regexp&quot;&gt;/proc/irq&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/8/smp&lt;/span&gt;_affinity’&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个与网卡多队列是密切相关的。如果网卡有多个队列，就能手动来明确指定由哪个 CPU 来处理，均衡的把数据处理的负载分散到机器的可用 CPU 上。配置也比较简单，只需&lt;/span&gt;&lt;span&gt;把数字写入到 /proc 对应的这个文件中就可以了。&lt;/span&gt;&lt;span&gt;这是个位数组，转成二进制后就会有对应的 CPU 去处理。&lt;/span&gt;&lt;span&gt;如果写个 1，可能就是 CPU0 来处理；&lt;/span&gt;&lt;span&gt;如果写个 4，转化成二进制是 100，那么就会交给 CPU2 去处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外有个小问题需要注意，很多发行版可能会自带一个 irqbalance 的守护进程&lt;/span&gt;&lt;span&gt;（http://irqbalance.github.io/irqbalance）&lt;/span&gt;&lt;span&gt;，会将手动中断均衡的设置给覆盖掉。这个程序做的核心事情就是把上面手动设置文件的操作放到程序里，有兴趣可以去看下它的代码（&lt;/span&gt;&lt;span&gt;https://github.com/Irqbalance/irqbalance/blob/master/activate.c&lt;/span&gt;&lt;span&gt;），也是把这个文件打开，写对应的数字进去就可以了。 &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;内核-数据处理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最后是数据处理部分了。&lt;/span&gt;&lt;span&gt;当数据到达网卡，进入队列内存后，就需要内核从队列内存中将数据拉出来。&lt;/span&gt;&lt;span&gt;如果机器的 PPS 达到了十万甚至百万，而 CPU 只处理网络数据的话，那其他基本的业务逻辑也就不用干了，因此不能让数据包的处理独占整个 CPU，而核心点是怎么去做限制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对上述问题主要有两方面的限制：&lt;/span&gt;&lt;span&gt;整体的限制和单次的限制&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (!list_empty(&amp;amp;sd-&amp;gt;poll_list)){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;napi_struct&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;n&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; work,weight;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (unlikely(budget &amp;lt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; || time_after_eq(jiffies, time_limit)))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;goto&lt;/span&gt; softnet_break;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;整体限制很好理解，就是一个 CPU 对应一个队列。&lt;/span&gt;&lt;span&gt;如果 CPU 的数量比队列数量少，那么一个 CPU 可能需要处理多个队列。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;weight&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;n-&amp;gt;weight;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;work&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;0;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;(test_bit(NAPI_STATE_SCHED, &amp;amp;n-&amp;gt;state)) {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;work&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;n-&amp;gt;poll(n,weight);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;trace_napi_poll(n);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;WARN_ON_ONCE(work&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&amp;gt; weight);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;budget&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;-= work;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;单次限制则是限制一个队列在一轮里处理包的数量。&lt;/span&gt;&lt;span&gt;达到限制之后就停下来，等待下一轮的处理。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;softnet_break:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  sd-&amp;gt;time_squeeze++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _raise_softirq_irqoff(NET_RX_SOFTIRQ);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;而停下来就是很关键的节点，幸运的是有对应的指标记录，有 time-squeeze 这样中断的计数，拿到这个信息就可以判断出机器的网络处理是否有瓶颈，被迫中断的频率高低。&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;124&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6wz7Awj86YEibEDKzp2rOKDbfewgkuCGWjJkjRU3LADzt6hcj5zib907Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是监控 CPU 指标的数据，格式很简单，每行对应一个 CPU，数值之间用空格分割，输出格式为 16 进制。&lt;/span&gt;&lt;span&gt;那么每一列数值又代表什么呢？&lt;/span&gt;&lt;span&gt;很不幸，这个没有文档，只能通过检查使用的内核版本，然后去看对应的代码。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;seq_printf（seq,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;%08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x\n&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     sd-&amp;gt;processed, sd-&amp;gt;dropped, sd-&amp;gt;time_squeeze, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__regexp&quot;&gt;/* was fastroute */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     sd-&amp;gt;cpu_collision, sd-&amp;gt;received_rps, flow_limit_count）;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;下面说明了文件中每个字段都是怎么来的，实际情况可能会有所不同，因为随着内核版本的迭代，字段的数量以及字段的顺序都有可能发生变化，其中与网络数据处理被中断次数相关的就是 squeeze 字段：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; * sd-&amp;gt;processed          处理的包数量（多网卡 bond 模式可能多于实际的收包数量）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; * sd-&amp;gt;dropped             丢包数量，因为队列满了&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; * sd-&amp;gt;time_spueeze      软中断处理 net_rx_action 被迫打断的次数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; * sd-&amp;gt;cpu_collision       发送数据时获取设备锁冲突，比如多个 CPU 同时发送数据&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; * sd-&amp;gt;received_rps       当前 CPU 被唤醒的次数（通过处理器间中断）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;* sd-&amp;gt;flow_limit_count    触发 flow limit 的次数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下图是业务中遇到相关问题的案例，最后排查到 CPU 层面。&lt;/span&gt;&lt;span&gt;图一是 TOP 命令的输出，显示了每个 CPU 的使用量，其中红框标出的 CPU4 的使用率存在着异常，尤其是倒数第二列的 SI 占用达到了 89%。&lt;/span&gt;&lt;span&gt;SI 是 softirq 的缩写，表示 CPU 花在软中断处理上的时间占比，而图中 CPU4 在时间占比上明显过高。&lt;/span&gt;&lt;span&gt;图二则是对应图一的输出结果，CPU4 对应的是第五行，其中第三列数值明显高于其他 CPU，表明它在处理网络数据的时被频繁的打断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;569&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9850074962518741&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d6PwK8Uy7CwoQyUnFVBCAdGFOJV14BGib8CLHfgbTWYbF1jic0lcKfqQMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;667&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;459&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7935323383084577&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF8ECg0JIbujSHGiaYKhs9d68sJ3mQYnfImC4exGl5kIEwN3Dj0FeJ5oZajuJkib3Yd9fnvF7trU36Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对上面的问题推断 CPU4 存在一定的性能衰退，也许是质量不过关或其他的原因。&lt;/span&gt;&lt;span&gt;为了验证是否是性能衰退，写了一个简单的 python 脚本，一个一直去累加的死循环。&lt;/span&gt;&lt;span&gt;每次运行时，把这段脚本绑定到某个 CPU 上，然后观察不同 CPU 耗时的对比。&lt;/span&gt;&lt;span&gt;最后对比结果也显示 CPU4 的耗时比其他的 CPU 高了几倍，也验证了之前的推断。&lt;/span&gt;&lt;span&gt;之后协调运维更换了 CPU，意向指标也就恢复正常了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以上所有操作都只是在数据包从网卡到了内核层，还没到常见的协议，只是完成了万里长征第一步，后面还有一系列的步骤，例如数据包的压缩（GRO）、网卡多队列软件（RPS）还有 RFS 在负载均衡的基础上考虑流的特征，就是 IP 端口四元组的特征，最后才是把数据递交到 IP 层，以及到熟悉的 TCP 层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来说，今天的分享都是围绕驱动来做的，我想强调的性能优化的核心点在于指标，不能测量也就很难去改善，要有指标的存在，这样一切的优化才有意义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现场视频、PPT 以及更多 Open Talk 技术干货，请点击&lt;/span&gt;&lt;span&gt;&lt;strong&gt;↓↓阅读原文↓↓&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;查看&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;&lt;hr/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;快 来&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 找 &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;又&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 小 拍&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h2&gt;&lt;h2&gt;&lt;hr/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;section&gt;&lt;section&gt;&lt;img data-backh=&quot;319&quot; data-backw=&quot;546&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;319&quot; data-ratio=&quot;0.5833333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUFAQemPjhnJTKkl7TwPLibto5mn4m21ZrshVQSeibqIYTw6XqhicImzlLxeW0v3BE4ycJbHd84ic5Oiayg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;推 荐 阅 读&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653586009&amp;amp;idx=1&amp;amp;sn=09aad11a1cc56357be8bb0b2502ff566&amp;amp;chksm=bd1b16d18a6c9fc7fd407aa041c890c7701863f5fe64930a9b68791b3c49a9fbbe543dc55a62&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;273&quot; data-backw=&quot;546&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUElpXebXbjgibum7I6LiboCtK6KV8gcYQ1mFV2XdonnCrOhaQdtBNh71z1u0JNzcdrx5EQRg56zb0IA/0?wx_fmt=jpeg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUEUylg3O41wsJR8aiasuMebIJsicZ1HyIIL8XbjU22CGg8eV9ZciclQxtibdwcudh6PAicxj2D6ibG3T8mg/0?wx_fmt=jpeg&quot; data-ratio=&quot;0.5007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUHgQBPeJ4VZoV13ib2HY93ETcX2lcC1BwsQUYfCqhEZ3w6TiaweiaXbtlnYDicZibySnBukq0VdmYMzGjA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653585893&amp;amp;idx=1&amp;amp;sn=a77f524feeabe1d1f203baa5ebc49454&amp;amp;chksm=bd1b156d8a6c9c7bcbe23557e6eb86932dc8a1fddbc20216321148d3719a931456a4348b8370&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;273&quot; data-backw=&quot;546&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUElpXebXbjgibum7I6LiboCtK6KV8gcYQ1mFV2XdonnCrOhaQdtBNh71z1u0JNzcdrx5EQRg56zb0IA/0?wx_fmt=jpeg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUEUylg3O41wsJR8aiasuMebIJsicZ1HyIIL8XbjU22CGg8eV9ZciclQxtibdwcudh6PAicxj2D6ibG3T8mg/0?wx_fmt=jpeg&quot; data-ratio=&quot;0.5007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUHgQBPeJ4VZoV13ib2HY93ET3tGzaa4btG0wzrKP7nje8AoEiau9TvicBSdnmVNiaEfEtx7XI6icstH3cQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653585879&amp;amp;idx=1&amp;amp;sn=35cf3079ee61f8326ef624a4c3f99813&amp;amp;chksm=bd1b155f8a6c9c49a48eaac27ea940464e439ffdec153d818bc07d2866c177fad1c57c71a72d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;273&quot; data-backw=&quot;546&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUElpXebXbjgibum7I6LiboCtK6KV8gcYQ1mFV2XdonnCrOhaQdtBNh71z1u0JNzcdrx5EQRg56zb0IA/0?wx_fmt=jpeg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUEUylg3O41wsJR8aiasuMebIJsicZ1HyIIL8XbjU22CGg8eV9ZciclQxtibdwcudh6PAicxj2D6ibG3T8mg/0?wx_fmt=jpeg&quot; data-ratio=&quot;0.5007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUHgQBPeJ4VZoV13ib2HY93ETd4zC3JPWxyLQtE1VpofmV5u9fjKdCOZQbr4WJjza6IDttG5iaicicQTRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;设为星标&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9037037&quot; data-type=&quot;png&quot; data-w=&quot;135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUHbb6jzHdqCC83fulktKZtY2WUNN9vVlgibWSiaR7RDHYbVyTy8icCibHV04APOmEqXhdoJv7GHJDMgvg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;更新不错过&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h2&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>20412d79078169c87c82fa9f6a03b0fe</guid>
<title>LeetCode 通关：四万字长文搞定二叉树</title>
<link>https://toutiao.io/k/nxha88x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分门别类刷算法，坚持，进步！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;!! &lt;/span&gt;刷题路线参考：&lt;strong&gt;https://github.com/youngyangyang04/leetcode-master&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是拿输出博客来督促自己刷题的老三，这一节我们来刷二叉树，二叉树相关题目在面试里非常高频，而且在力扣里数量很多，足足有几百道，不要慌，我们一步步来。我的文章很长，你们 &lt;big&gt;&lt;strong&gt;收藏&lt;/strong&gt;&lt;/big&gt;一下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5683417085427136&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaI6iaM5ibYNB7IwqxMFYHOrMgGvjJ8v5vDSxsdicxWTeKst159HUM3Zic8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3980&quot;/&gt;&lt;figcaption&gt;二叉树-汇总&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二叉树基础&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二叉树是一种比较常见的数据结构，在开始刷二叉树之前，先简单了解一下一些二叉树的基础知识。更详细的数据结构知识建议学习《数据结构与算法》。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是二叉树&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二叉树是每个节点至多有两棵子树的树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二叉树主要的两种形式：满二叉树和完全二叉树。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;满⼆叉树&lt;/span&gt;：如果⼀棵⼆叉树只有度为0的结点和度为2的结点，并且度为0的结点在同⼀层上，则这棵⼆&lt;/p&gt;&lt;p&gt;叉树为满⼆叉树。一棵深度为k的满二叉树节点个数为2^k^ -1。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;完全⼆叉树&lt;/span&gt;：至多只有最下面的两层结点的度数可以小于 2, 并且最下一层上的结点都集中在该层最左边的若干位置上， 则此二叉树称为完全二叉树。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4405377456049638&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaexI7D9QmPMbs5fN5qaSb6PCMqor2XHiaj4WQ3KPYAu8Ba0h0bcO8AnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;967&quot;/&gt;&lt;figcaption&gt;满二叉树和完全二叉树&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看出满二叉树是完全二叉树， 但完全二叉树不一定是满二叉树。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;⼆叉搜索树&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⼆叉搜索树，也可以叫二叉查找树、二叉排序树，是一种有序的二叉树。它遵循着&lt;code&gt;左小右大&lt;/code&gt;的规则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它的左、右⼦树也分别为⼆叉搜索树&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5508684863523573&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaHJy1YURLzwgyD2CQYNq9o6G5HRJj2HMOr9rg7Ww4YgDHg7FuJJzwIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;806&quot;/&gt;&lt;figcaption&gt;二叉查找树&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二叉树存储结构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和线性表类似，二叉树的存储结构也可采用顺序存储和链式存储两种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺序存储是将二叉树所有元素编号，存入到一维数组的对应位置，比较适合存储满二叉树。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8618421052631579&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaqSrI3wwAlwvibTpiabNxCs9rJ8JXbTB7Lu4SsW5Azdjt9UcMfPYWibLLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;figcaption&gt;二叉树顺序存储&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于采用顺序存储结构存储一般二叉树造成大量存储空间的浪费， 因此， 一般二叉树的存储结构更多地采用链式的方式。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3837994214079074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaCG9C1xdd3UyQkcUGrsQiagZRiaXpKSm9DXy53Iep8fWia4DvaSY7cFiabg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1037&quot;/&gt;&lt;figcaption&gt;二叉树链式存储&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二叉树节点&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在上面已经看了二叉树的链式存储，注意看，一个个节点是由三部分组成的，左孩子、数据、右孩子。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4563106796116505&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaocicy8yOibF5kbYrSxFFOfUrnv9EMqBWKf8so9sFibhiaW6Ba1mqC7ibXicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;206&quot;/&gt;&lt;figcaption&gt;二叉树节点&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来定义一下二叉树的节点节点：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@Author&lt;/span&gt;: 三分恶&lt;br/&gt; * &lt;span&gt;@Date&lt;/span&gt;: 2021/6/8&lt;br/&gt; * &lt;span&gt;@Description&lt;/span&gt;:&lt;br/&gt; **/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TreeNode&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; val;            &lt;span&gt;//值&lt;/span&gt;&lt;br/&gt;    TreeNode left;      &lt;span&gt;//左子树&lt;/span&gt;&lt;br/&gt;    TreeNode right;     &lt;span&gt;//右子树&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    TreeNode() {&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    TreeNode(&lt;span&gt;int&lt;/span&gt; val) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.val = val;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    TreeNode(&lt;span&gt;int&lt;/span&gt; val, TreeNode left, TreeNode right) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.val = val;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.left = left;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.right = right;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二叉树遍历方式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⼆叉树主要有两种遍历⽅式：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;深度优先遍历：先往深⾛，遇到叶⼦节点再往回⾛。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;⼴度优先遍历：⼀层⼀层的去遍历。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么从深度优先遍历和⼴度优先遍历进⼀步拓展，才有如下遍历⽅式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;深度优先遍历&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;前序遍历（递归法，迭代法）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;中序遍历（递归法，迭代法）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后序遍历（递归法，迭代法）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;⼴度优先遍历&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们耳熟能详的就是根、左、右三种遍历，所谓根、左、右指的就是根节点的次序：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种更利于记忆的叫法：先根遍历、中根遍历、后根遍历，这种说法就更一目了然了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一个图例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3940149625935162&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiapC3QvxumNX1G6SdCCjlEvgdGaFxn9Ob17ly7AaM0Ucq0RPr9JJwQBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;figcaption&gt;前序、中序、后序遍历&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的算法实现主要有两种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;递归&lt;/span&gt;：树本身就是一种带着递归性质的数据结构，使用递归来实现深度优先遍历还是非常方便的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;迭代&lt;/span&gt;：迭代需要借助其它的数据结构，例如栈来实现。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，我们已经了解了二叉树的一些基础知识，接下来，面对LeetCode的疯狂打击吧！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9728260869565217&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaX7V8rS5bh8pYDen9MFy8DlDWIrAlBNYemqreAphsnKWiauQtdeDTl4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;368&quot;/&gt;&lt;figcaption&gt;除了菜，我一无所有&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;深度优先遍历基础&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;递归基础&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二叉树是一种天然递归的数据结构，我们先简单碰一碰递归。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiafRWFia1YnBLgicxMLKiakWV6oNq0GrjqPK3KOibWONjpjuGcibE8tAU6dlQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;100&quot;/&gt;&lt;figcaption&gt;无限放大&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;递归有三大要素：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;递归函数的参数和返回值&lt;/span&gt;&lt;/p&gt;&lt;p&gt;确定哪些参数是递归的过程中需要处理的，那么就在递归函数⾥加上这个参数， 并且还要明确每次递归的返回值是什么进⽽确定递归函数的返回类型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;终⽌条件：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;递归需要注意终止条件，终⽌条件或者终⽌条件写的不对，操作系统的内存栈就会溢出。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;单层递归的逻辑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;确定单层递归的逻辑，在单层里会重复调用自己来实现递归的过程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，那么我们开始吧！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode144. 二叉树的前序遍历&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么先从二叉树的前序遍历开始吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：LeetCode144. 二叉树的前序遍历 (https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回它节点值的 &lt;span&gt;前序&lt;/span&gt; 遍历。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6921241050119332&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiarub2Yic3JMjic6wXQbKF6GlwkHVFLtYCiaic1nxlhce3rsQWobhgtXBvrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;递归法前序遍历&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们前面看了递归三要素，接下来我们开始用递归法来进行二叉树的前序遍历：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;确定递归函数的参数和返回值&lt;/span&gt;：因为要打印出前序遍历节点的数值，所以参数⾥需要传⼊List用来存放节点的数值；要传入节点的值，自然也需要节点，那么递归函数的参数就确定了；因为节点数值已经存在List里了，所以递归函数返回类型是void，代码如下：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;preOrderRecu&lt;/span&gt;&lt;span&gt;(TreeNode root, List&amp;lt;Integer&amp;gt; nodes)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;确定终⽌条件&lt;/span&gt;：递归结束也很简单，如果当前遍历的这个节点是空，就直接return，代码如下：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;       &lt;span&gt;//递归结束条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;确定单层递归的逻辑&lt;/span&gt;：前序遍历是根左右的顺序，所以在单层递归的逻辑里，先取根节点的值，再递归左子树和右子树，代码如下：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        &lt;span&gt;//添加根节点&lt;/span&gt;&lt;br/&gt;        nodes.add(root.val);&lt;br/&gt;        &lt;span&gt;//递归左子树&lt;/span&gt;&lt;br/&gt;        preOrderRecu(root.left, nodes);&lt;br/&gt;        &lt;span&gt;//递归右子树&lt;/span&gt;&lt;br/&gt;        preOrderRecu(root.right, nodes);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看一下二叉树前序遍历的完整代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 二叉树前序遍历&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span&gt;preorderTraversal&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Integer&amp;gt; nodes = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;        preOrderRecu(root, nodes);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; nodes;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 二叉树递归前序遍历&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; nodes&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;preOrderRecu&lt;/span&gt;&lt;span&gt;(TreeNode root, List&amp;lt;Integer&amp;gt; nodes)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//递归结束条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//添加根节点&lt;/span&gt;&lt;br/&gt;        nodes.add(root.val);&lt;br/&gt;        &lt;span&gt;//递归左子树&lt;/span&gt;&lt;br/&gt;        preOrderRecu(root.left, nodes);&lt;br/&gt;        &lt;span&gt;//递归右子树&lt;/span&gt;&lt;br/&gt;        preOrderRecu(root.right, nodes);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;preorderTraversal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        LeetCode144 l = &lt;span&gt;new&lt;/span&gt; LeetCode144();&lt;br/&gt;        &lt;span&gt;//构造二叉树&lt;/span&gt;&lt;br/&gt;        TreeNode root = &lt;span&gt;new&lt;/span&gt; TreeNode(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        TreeNode node1 = &lt;span&gt;new&lt;/span&gt; TreeNode(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        TreeNode node2 = &lt;span&gt;new&lt;/span&gt; TreeNode(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;        root.left = node1;&lt;br/&gt;        node1.right = node2;&lt;br/&gt;        &lt;span&gt;//二叉树先序遍历&lt;/span&gt;&lt;br/&gt;        List&amp;lt;Integer&amp;gt; nodes = l.preorderTraversal(root);&lt;br/&gt;        nodes.stream().forEach(n -&amp;gt; {&lt;br/&gt;            System.out.print(n);&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复杂度：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;🚗 时间复杂度：O(n)，其中 n 是二叉树的节点数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;递归法会者不难，难者不会。只要能理解，这个是不是很轻松？😂&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们接下来，搞一下稍微麻烦一点的迭代法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;迭代法前序遍历&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;迭代法的原理是引入新的数据结构，用来存储遍历的节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;递归的过程是不断往左边走，当递归终止的时候，就添加节点。现在使用迭代，我们需要自己来用一个数据结构存储节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么用什么数据结构比较合适呢？我们自然而然地想到——栈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;迭代法的核心是：借助栈结构，模拟递归的过程，需要注意何时出栈入栈，何时访问结点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前序遍历地顺序是根左右，先把根和左子树入栈，再将栈中的元素慢慢出栈，如果右子树不为空，就把右子树入栈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ps：注意啊，我们的写法将存储元素进列表放在了栈操作前面，栈的作用主要用来找右子树。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39015151515151514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiacIMng9vskld5F0K6icsYAWmPlKKc7W4ASGmvcQs4j0ot0yuOQ6pibdgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;528&quot;/&gt;&lt;figcaption&gt;迭代法-前序-1&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38317757009345793&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiamBHSPT8ibCicHrIdibWu72lG0XJWb3bPVLicGx5Mq9kfJHqEw6siaag0BIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;535&quot;/&gt;&lt;figcaption&gt;迭代法-前序-2&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39853747714808047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqia7bXSNUkCHiaTzqXAlPbtDnJ0iaMTb3hJlLKHHEiaTtDiadfWSn8WBc9ogA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;547&quot;/&gt;&lt;figcaption&gt;迭代法-前序-3&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;迭代和递归究其本质是一样的东西，不过递归里这个栈由虚拟机帮我们隐式地管理了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 二叉树前序遍历-迭代法&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span&gt;preorderTraversal&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         List&amp;lt;Integer&amp;gt; nodes = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; nodes;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//使用链表作为栈&lt;/span&gt;&lt;br/&gt;        Deque&amp;lt;TreeNode&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;TreeNode&amp;gt;();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(root!=&lt;span&gt;null&lt;/span&gt; || !stack.isEmpty()){&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt;(root!=&lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;                 &lt;span&gt;//根&lt;/span&gt;&lt;br/&gt;                nodes.add(root.val);  &lt;br/&gt;                stack.push(root);&lt;br/&gt;                &lt;span&gt;//左&lt;/span&gt;&lt;br/&gt;                root=root.left;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//出栈&lt;/span&gt;&lt;br/&gt;            root=stack.pop();&lt;br/&gt;            &lt;span&gt;//右&lt;/span&gt;&lt;br/&gt;            root=root.right;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; nodes;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;🚗时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode94. 二叉树的中序遍历&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：LeetCode94. 二叉树的中序遍历 (https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回它节点值的 &lt;span&gt;前序&lt;/span&gt; 遍历。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7027348394768134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaHPkQGzn5HCtzFjoHRjwULNnPV9R00upKoxjCXpsSd6LrbOUzzicwjkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;841&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在前面已经用递归法进行了二叉树大的前序遍历，中序遍历类似，只是把根节点的次序放到中间而已。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 中序遍历-递归&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; nodes&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;inOrderRecu&lt;/span&gt;&lt;span&gt;(TreeNode root, List&amp;lt;Integer&amp;gt; nodes)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//递归左子树&lt;/span&gt;&lt;br/&gt;        inOrderRecu(root.left, nodes);&lt;br/&gt;        &lt;span&gt;//根节点&lt;/span&gt;&lt;br/&gt;        nodes.add(root.val);&lt;br/&gt;        &lt;span&gt;//递归右子树&lt;/span&gt;&lt;br/&gt;        inOrderRecu(root.right, nodes);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;迭代法中序遍历和前序遍历类似，只是我们访问节点的时机不同而已：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;前序遍历需要每次向左走之前就访问根结点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;而中序遍历先压栈，在出栈的时候才访问&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1185944363103952&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiac1Lopelx3jYrUPlqFBcvJfaQYeBR5nOc5pwcJ4j52E2pKtrGibGNl1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;683&quot;/&gt;&lt;figcaption&gt;迭代法后序遍历&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将节点的所有左孩子压入栈中，然后出栈，出栈的时候将节点的值放入List，如果节点右孩子不为空，就处理右孩子。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 中序遍历-迭代&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span&gt;inorderTraversal&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Integer&amp;gt; nodes = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; nodes;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//使用链表作为栈&lt;/span&gt;&lt;br/&gt;        Deque&amp;lt;TreeNode&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;TreeNode&amp;gt;();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (root != &lt;span&gt;null&lt;/span&gt; || !stack.isEmpty()) {&lt;br/&gt;            &lt;span&gt;//遍历左子树&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (root != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                stack.push(root);&lt;br/&gt;                root = root.left;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//取出栈中的节点&lt;/span&gt;&lt;br/&gt;            root = stack.pop();&lt;br/&gt;            &lt;span&gt;//添加取出的节点&lt;/span&gt;&lt;br/&gt;            nodes.add(root.val);&lt;br/&gt;            &lt;span&gt;//右子树&lt;/span&gt;&lt;br/&gt;            root = root.right;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; nodes;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode145. 二叉树的后序遍历&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：145. 二叉树的后序遍历 (https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：给定一个二叉树，返回它的 &lt;em&gt;后序&lt;/em&gt; 遍历。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3751493428912784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaVvArm9uJXgXmVicCuAyKjZYTDGEyNAMPibSJtMLplQkKdPIicCkP4jKxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;837&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;递归法，只要理解了可以说so easy了！&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 二叉树后序遍历-递归&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; nodes&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;postorderRecu&lt;/span&gt;&lt;span&gt;(List&amp;lt;Integer&amp;gt; nodes, TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//递归左子树&lt;/span&gt;&lt;br/&gt;        postorderRecu(nodes, root.left);&lt;br/&gt;        &lt;span&gt;//递归右子树&lt;/span&gt;&lt;br/&gt;        postorderRecu(nodes, root.right);&lt;br/&gt;        &lt;span&gt;//根子树&lt;/span&gt;&lt;br/&gt;        nodes.add(root.val);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;递归法后序遍历，可以用一个取巧的办法，套用一下前序遍历，前序遍历是根左右，后序遍历是左右根，我们只需要将前序遍历的结果反转一下，就是根左右。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用Java实现，可以在链表上做文章，将尾插改成头插也是一样的效果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.31860776439089694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaVv42naFTZ4AdOcr5bencRcCPGkpUhrpNsyQSVjOW01cZawt9icOAPrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;747&quot;/&gt;&lt;figcaption&gt;迭代法后序-1&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3041168658698539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaZDk1eG5EJ4shK79ekXDDfRkkQ0l5ibdz8LaeibvgyGvYMkhPg2feh5Ug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;753&quot;/&gt;&lt;figcaption&gt;迭代法后序-2&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.31973684210526315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaY8W0cjibIh8oCT152fia4794x5ibjoGGDgsOgFiadfJZkgDOOfzdwUKyGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;figcaption&gt;迭代法后序-3&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 二叉树后序遍历-迭代&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span&gt;postorderTraversal&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//使用链表作为栈&lt;/span&gt;&lt;br/&gt;        Deque&amp;lt;TreeNode&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;TreeNode&amp;gt;();&lt;br/&gt;        &lt;span&gt;//节点&lt;/span&gt;&lt;br/&gt;        LinkedList&amp;lt;Integer&amp;gt; nodes = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;Integer&amp;gt;();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (root != &lt;span&gt;null&lt;/span&gt; || !stack.isEmpty()) {&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (root != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;//头插法插入节点&lt;/span&gt;&lt;br/&gt;                nodes.addFirst(root.val);&lt;br/&gt;                &lt;span&gt;//根节点入栈&lt;/span&gt;&lt;br/&gt;                stack.push(root);&lt;br/&gt;                &lt;span&gt;//左子树&lt;/span&gt;&lt;br/&gt;                root = root.left;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//节点出栈&lt;/span&gt;&lt;br/&gt;            root = stack.pop();&lt;br/&gt;            &lt;span&gt;//右子树&lt;/span&gt;&lt;br/&gt;            root = root.right;&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; nodes;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这是一种取巧的做法，你说这不是真正的迭代法后序遍历，要真正的后序迭代二叉树，也不复杂，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点在于：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果右子树为空或者已经访问过了才访问根结点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;否则，需要将该结点&lt;span&gt;再次&lt;/span&gt;压回栈中，去访问其右子树&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9540078843626807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiakJunErDa4gs1b7kDwgrDUQPkkJ4AKo7sNWnyE730p0S6r7kqgwCmQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;761&quot;/&gt;&lt;figcaption&gt;迭代法后序遍历-常规&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;/**&lt;br/&gt;     * 二叉树后序遍历-迭代-常规&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span&gt;postorderTraversal1&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//使用链表作为栈&lt;/span&gt;&lt;br/&gt;        Deque&amp;lt;TreeNode&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;TreeNode&amp;gt;();&lt;br/&gt;        &lt;span&gt;//节点值存储&lt;/span&gt;&lt;br/&gt;        List&amp;lt;Integer&amp;gt; nodes = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//用于记录前一个节点&lt;/span&gt;&lt;br/&gt;        TreeNode pre = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (root != &lt;span&gt;null&lt;/span&gt; || !stack.isEmpty()) {&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (root != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;//根节点入栈&lt;/span&gt;&lt;br/&gt;                stack.push(root);&lt;br/&gt;                &lt;span&gt;//左子树&lt;/span&gt;&lt;br/&gt;                root = root.left;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//节点出栈&lt;/span&gt;&lt;br/&gt;            root = stack.pop();&lt;br/&gt;            &lt;span&gt;//判断节点右子树是否为空或已经访问过&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (root.right == &lt;span&gt;null&lt;/span&gt; || root.right == pre) {&lt;br/&gt;                &lt;span&gt;//添加节点&lt;/span&gt;&lt;br/&gt;                nodes.add(root.val);&lt;br/&gt;                &lt;span&gt;//更新访问过的节点&lt;/span&gt;&lt;br/&gt;                pre = root;&lt;br/&gt;                &lt;span&gt;//使得下一次循环直接出栈下一个&lt;/span&gt;&lt;br/&gt;                root = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;//再次入栈&lt;/span&gt;&lt;br/&gt;                stack.push(root);&lt;br/&gt;                &lt;span&gt;//访问右子树&lt;/span&gt;&lt;br/&gt;                root = root.right;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; nodes;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;广度优先遍历基础&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode102. 二叉树的层序遍历&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：102. 二叉树的层序遍历(https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：给你一个二叉树，请你返回其按 &lt;span&gt;层序遍历&lt;/span&gt; 得到的节点值。（即逐层地，从左到右访问所有节点）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5732860520094563&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqia4KWkvzrX0DhwYDJcytnkqoacYUbcg0XCGibdj2w6lnsdzLdZIjKeGGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;846&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在前面已经使用迭代法完成了二叉树的深度优先遍历，现在我们来磕一下广度优先遍历。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在迭代法深度优先遍历里，我们用了栈这种数据结构来存储节点，那么层序遍历这种一层一层遍历的逻辑，适合什么数据结构呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么层序遍历的思路是什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用队列，把每一层的节点存储进去，一层存储结束之后，我们把队列中的节点再取出来，左右孩子节点不为空，我们就把左右孩子节点放进去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0224215246636772&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaAeLhaCIK33wu2GNibfesku833rvDFhP5QJQlbt8zCrO8YVgkJT5iaNvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;669&quot;/&gt;&lt;figcaption&gt;二叉树层序遍历&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 二叉树层序遍历&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) {&lt;br/&gt;        &lt;span&gt;//结果集合&lt;/span&gt;&lt;br/&gt;        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//保存节点的队列&lt;/span&gt;&lt;br/&gt;        Queue&amp;lt;TreeNode&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;//加入根节点&lt;/span&gt;&lt;br/&gt;        queue.offer(root);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!queue.isEmpty()) {&lt;br/&gt;            &lt;span&gt;//存放每一层节点的集合&lt;/span&gt;&lt;br/&gt;            List&amp;lt;Integer&amp;gt; level = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;//这里每层队列的size要先取好，因为队列是不断变化的&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; queueSize = queue.size();&lt;br/&gt;            &lt;span&gt;//遍历队列&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= queueSize; i++) {&lt;br/&gt;                &lt;span&gt;//取出队列的节点&lt;/span&gt;&lt;br/&gt;                TreeNode node = queue.poll();&lt;br/&gt;                &lt;span&gt;//每层集合中加入节点&lt;/span&gt;&lt;br/&gt;                level.add(node.val);&lt;br/&gt;                &lt;span&gt;//如果当前节点左孩子不为空，左孩子入队&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.left);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//如果右孩子不为空，右孩子入队&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.right);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//结果结合加入每一层结果集合&lt;/span&gt;&lt;br/&gt;            result.add(level);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;🚗时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，二叉树的深度优先遍历和广度优先遍历的基础已经完成了，接下来，我们看一看，在这两种遍历的基础上衍生出的各种变化吧！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;广度优先遍历基础-变式&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们首先来看一下在层序遍历的基础上，稍微有一些变化的题目。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;剑指 Offer 32 - I. 从上到下打印二叉树&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：剑指 Offer 32 - I. 从上到下打印二叉树 (https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48009650180940894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqia4aWvZRvtHNePx4odRoicMr0mSwbVOFFPiaQmPfOaPBvdzTOicFaN1psIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;829&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题可以说变化非常小了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该咋做？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这么做！&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;/**&lt;br/&gt;     * 从上到下打印二叉树&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] levelOrder(TreeNode root) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;        }&lt;br/&gt;        List&amp;lt;Integer&amp;gt; nodes=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;64&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//队列&lt;/span&gt;&lt;br/&gt;        Deque&amp;lt;TreeNode&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;//根节点&lt;/span&gt;&lt;br/&gt;        queue.offer(root);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!queue.isEmpty()) {&lt;br/&gt;            TreeNode node = queue.poll();&lt;br/&gt;            nodes.add(node.val);&lt;br/&gt;            &lt;span&gt;//左孩子入队&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (node.left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                queue.offer(node.left);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//右孩子入队&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (node.right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                queue.offer(node.right);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//结果数组&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt;[] result = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[nodes.size()];&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; nodes.size(); i++) {&lt;br/&gt;            result[i] = nodes.get(i);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码没改几行，往里面套就完了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;剑指 Offer 32 - III. 从上到下打印二叉树 III&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：剑指 Offer 32 - III. 从上到下打印二叉树 III(https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6133651551312649&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiakFj6e67yYzWd9kWxsucIrS7ZyYgh9cf41e3PuPnXtXiarItMXr2S2Qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个题目的变化是奇数层要从左往右打印，偶数层要从右往左打印。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们需要一个变量来记录层级。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那什么数据结构既能从左往右插数据，又能从右往左插数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们想到了双向链表。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27682737169517885&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaNwoybiaUuC5phIicPqvbVZiarAEVngBWUph7hRo4zDib1rmHPq2jZINvCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;643&quot;/&gt;&lt;figcaption&gt;双向链表&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;/**&lt;br/&gt;     * 剑指 Offer 32 - III. 从上到下打印二叉树 III&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) {&lt;br/&gt;        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//队列&lt;/span&gt;&lt;br/&gt;        Deque&amp;lt;TreeNode&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;//根节点&lt;/span&gt;&lt;br/&gt;        queue.offer(root);&lt;br/&gt;        &lt;span&gt;//记录层级&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; levelCount = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!queue.isEmpty()) {&lt;br/&gt;            &lt;span&gt;//当前队列size&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; queueSize = queue.size();&lt;br/&gt;            &lt;span&gt;//使用双向链表存储每层节点&lt;/span&gt;&lt;br/&gt;            LinkedList&amp;lt;Integer&amp;gt; level = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= queueSize; i++) {&lt;br/&gt;                &lt;span&gt;//取节点&lt;/span&gt;&lt;br/&gt;                TreeNode node = queue.poll();&lt;br/&gt;                &lt;span&gt;//判断层级&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;//奇数，尾插&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (levelCount % &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;                    level.addLast(node.val);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//偶数，头插&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (levelCount % &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                    level.addFirst(node.val);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//左孩子&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.left);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//右孩子&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.right);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//添加每层节点&lt;/span&gt;&lt;br/&gt;            result.add(level);&lt;br/&gt;            &lt;span&gt;//层级增加&lt;/span&gt;&lt;br/&gt;            levelCount++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode107. 二叉树的层序遍历 II&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：107. 二叉树的层序遍历 II (https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：给定一个二叉树，返回其节点值自底向上的层序遍历。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5896510228640193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiawIAEQwbK2khtZiaJ7F9TerTAXRu2f0z7gGfPO5knmGBEpjZDN2cUq9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;831&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得我们后序遍历二叉树的取巧做法吗？这不就是一回事吗，层序遍历，反转List，或者用链表头插每一层的集合。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;/**&lt;br/&gt;     * 二叉树的层序遍历 II&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrderBottom(TreeNode root) {&lt;br/&gt;        &lt;span&gt;//使用链表存储结果，使用头插法添加元素&lt;/span&gt;&lt;br/&gt;        LinkedList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//队列&lt;/span&gt;&lt;br/&gt;        Deque&amp;lt;TreeNode&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;//插入根节点&lt;/span&gt;&lt;br/&gt;        queue.offer(root);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!queue.isEmpty()) {&lt;br/&gt;            &lt;span&gt;//存放每一层节点的集合&lt;/span&gt;&lt;br/&gt;            List&amp;lt;Integer&amp;gt; level = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;//当前队列size，需要取好，因为队列在不断变化&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; currentQueueSize = queue.size();&lt;br/&gt;            &lt;span&gt;//遍历队列&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= currentQueueSize; i++) {&lt;br/&gt;                TreeNode node = queue.poll();&lt;br/&gt;                &lt;span&gt;//每一层集合添加值&lt;/span&gt;&lt;br/&gt;                level.add(node.val);&lt;br/&gt;                &lt;span&gt;//左孩子&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.left);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//右孩子&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.right);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//头插法插入每一层节点集合&lt;/span&gt;&lt;br/&gt;            result.addFirst(level);&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode199. 二叉树的右视图&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：199. 二叉树的右视图 (https://leetcode-cn.com/problems/binary-tree-right-side-view/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4068396226415094&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiavzqCto3S5VWF5zgYszsR5BX2xywjSdOSbLlmp4Y4jtHZQyu5f519vg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;848&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个也很简单对不对？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们只需要判断一下，节点是不是每层最后一个元素，是就加入集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么判断？记得我们维护的有一个每层的元素个数变量吗？拿这个判断。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 二叉树的右视图&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span&gt;rightSideView&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Integer&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//队列&lt;/span&gt;&lt;br/&gt;        Deque&amp;lt;TreeNode&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;//根节点入队&lt;/span&gt;&lt;br/&gt;        queue.offer(root);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!queue.isEmpty()) {&lt;br/&gt;            &lt;span&gt;//维护队列当前size&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; queueCurrentSize = queue.size();&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= queueCurrentSize; i++) {&lt;br/&gt;                &lt;span&gt;//取出当前遍历的节点&lt;/span&gt;&lt;br/&gt;                TreeNode node = queue.poll();&lt;br/&gt;                &lt;span&gt;//判断是否最右一个&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (i == queueCurrentSize) {&lt;br/&gt;                    &lt;span&gt;//结果集合添加节点值&lt;/span&gt;&lt;br/&gt;                    result.add(node.val);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//左孩子&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.left);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//右孩子&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.right);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode637. 二叉树的层平均值&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：637. 二叉树的层平均值(https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42890995260663506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaK3icVhWIeZibUI2sgoCKvM2hPkgdZFTlfBHcDeXpib38wCubaNtfXefKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot;/&gt;&lt;figcaption&gt;题目描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每层求和，再除个节点个数，取个均值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 637. 二叉树的层平均值&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Double&amp;gt; &lt;span&gt;averageOfLevels&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Double&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//队列&lt;/span&gt;&lt;br/&gt;        Deque&amp;lt;TreeNode&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;//根节点&lt;/span&gt;&lt;br/&gt;        queue.offer(root);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!queue.isEmpty()) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; currentQueueSize = queue.size();&lt;br/&gt;            &lt;span&gt;//每一层值的总和&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;double&lt;/span&gt; levelSum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= currentQueueSize; i++) {&lt;br/&gt;                TreeNode node = queue.poll();&lt;br/&gt;                &lt;span&gt;//累加&lt;/span&gt;&lt;br/&gt;                levelSum += node.val;&lt;br/&gt;                &lt;span&gt;//左孩子&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.left);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.right);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//平均值&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;double&lt;/span&gt; avg = levelSum / currentQueueSize;&lt;br/&gt;            &lt;span&gt;//结果集合添加每层平均值&lt;/span&gt;&lt;br/&gt;            result.add(avg);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode429. N 叉树的层序遍历&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：429. N 叉树的层序遍历(https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：给定一个 N 叉树，返回其节点值的&lt;em&gt;层序遍历&lt;/em&gt;。（即从左到右，逐层遍历）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5269461077844312&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaD0eTC3RCQdouoAqW2JDlopwUQmlWZ4W7lYNkJft88gMkrLUJoia6UpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;835&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和二叉树的层序遍历类似，不多树变成了N叉树，思路差不多，只不过左右子节点的入队，变成了子节点集合节点的入队。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 429. N 叉树的层序遍历&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(Node root) {&lt;br/&gt;        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//队列&lt;/span&gt;&lt;br/&gt;        Deque&amp;lt;Node&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;//根节点&lt;/span&gt;&lt;br/&gt;        queue.offer(root);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!queue.isEmpty()) {&lt;br/&gt;            List&amp;lt;Integer&amp;gt; level = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; currentQueueSize = queue.size();&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= currentQueueSize; i++) {&lt;br/&gt;                Node node = queue.poll();&lt;br/&gt;                level.add(node.val);&lt;br/&gt;                &lt;span&gt;//判断子节点是否为空，添加子节点&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!node.children.isEmpty()) {&lt;br/&gt;                    queue.addAll(node.children);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//添加每层节点&lt;/span&gt;&lt;br/&gt;            result.add(level);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode515. 在每个树行中找最大值&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：515. 在每个树行中找最大值 (https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：您需要在二叉树的每一行中找到最大的值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4149577804583836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaBQnh3uBrkXecLVQ4sklbVibRX03emwxYt0YicYHCfloaSal8syRiakm8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;829&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义一个变量，来表示每层最大数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 515. 在每个树行中找最大值&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span&gt;largestValues&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Integer&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//队列&lt;/span&gt;&lt;br/&gt;        Deque&amp;lt;TreeNode&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;//根节点&lt;/span&gt;&lt;br/&gt;        queue.offer(root);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!queue.isEmpty()) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; queueSize = queue.size();&lt;br/&gt;            &lt;span&gt;//最大值&lt;/span&gt;&lt;br/&gt;            Integer max = Integer.MIN_VALUE;&lt;br/&gt;            &lt;span&gt;//遍历一层&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= queueSize; i++) {&lt;br/&gt;                &lt;span&gt;//取节点&lt;/span&gt;&lt;br/&gt;                TreeNode node = queue.poll();&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.val &amp;gt; max) {&lt;br/&gt;                    max = node.val;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//左孩子&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.left);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.right);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            result.add(max);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode116. 填充每个节点的下一个右侧节点指针&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：116. 填充每个节点的下一个右侧节点指针 (https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;struct Node {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; val;&lt;br/&gt;  Node *left;&lt;br/&gt;  Node *right;&lt;br/&gt;  Node *next;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始状态下，所有 next 指针都被设置为 NULL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进阶：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;你只能使用常量级额外空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3954050785973398&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqia0oVSJr1WsR4HGtoDmzWLhZpo1q3bVt3cfDcQjPJF0q9UwaiblHZHtfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;827&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个思路也不难，我们增加一个变量来表示前一个节点，让前一个节点的next指向当前节点。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;/**&lt;br/&gt;     * 116. 填充每个节点的下一个右侧节点指针&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Node &lt;span&gt;connect&lt;/span&gt;&lt;span&gt;(Node root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//队列&lt;/span&gt;&lt;br/&gt;        Deque&amp;lt;Node&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList();&lt;br/&gt;        &lt;span&gt;//根节点&lt;/span&gt;&lt;br/&gt;        queue.offer(root);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!queue.isEmpty()) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; queueSize = queue.size();&lt;br/&gt;            &lt;span&gt;//前一个节点&lt;/span&gt;&lt;br/&gt;            Node pre = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; queueSize; i++) {&lt;br/&gt;                Node node = queue.poll();&lt;br/&gt;                &lt;span&gt;//每一层的第一个节点&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (i == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                    pre = node;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//让前点左边节点的next指向当前节点&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (i &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                    pre.next = node;&lt;br/&gt;                    pre = node;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//左孩子&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.left);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//右孩子&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.right);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode117. 填充每个节点的下一个右侧节点指针 II&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：117. 填充每个节点的下一个右侧节点指针 II (https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：给定一个二叉树&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;struct Node {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; val;&lt;br/&gt;  Node *left;&lt;br/&gt;  Node *right;&lt;br/&gt;  Node *next;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始状态下，所有 next 指针都被设置为 NULL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和上一道题不是基本一模一样嘛？除了不是完美二叉树，但是不影响，一样的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连续做了十道能用一个套路解决的问题，是不是瞬间有种神清气爽，自信澎湃的感觉，我们继续！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;!! &lt;/span&gt;由于老三时间和水平有限，所以接下来的题目以递归法为主。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二叉树属性&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode101. 对称二叉树&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：101. 对称二叉树 (https://leetcode-cn.com/problems/symmetric-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：给定一个二叉树，检查它是否是镜像对称的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5738255033557047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaxRKQariceGGMUia6YMjfwgIMU43Y71xHgG43KhCPvrbqia1v7RCO9L60g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;596&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这题首先是要弄懂，这个镜像对称是什么镜像？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;判断二叉树对称，比较的是两棵树（也就是根节点的左右子树）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意看，比较看的是T1左侧的元素和T2的右侧的元素；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及T2左侧的元素和T1右侧的元素。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7490196078431373&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaFg1NIicfOCnQpKcklGdIwicC6icVzQZcRmcO8eibaccbyKmRLuyTiaNbjiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;510&quot;/&gt;&lt;figcaption&gt;对称镜像&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，我们现在看看递归应该怎么实现。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;递归方法参数和返回值&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;返回值是是否对称，就是布尔类型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;要比较两个子树，所以参数是左子树节点和右子树节点&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;终止条件&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;都为空指针则返回 &lt;code&gt;true&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有一个为空则返回 &lt;code&gt;false&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两个节点值不相等则返回 &lt;code&gt;false&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;递归逻辑&lt;/p&gt;&lt;p&gt;最后要短路与，只有二者都返回&lt;code&gt;true&lt;/code&gt;最终才为true&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判断 T1 的右子树与 T2 的左子树是否对称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断 T1 的左子树与 T2 的右子树是否对称&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 101. 对称二叉树&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isSymmetric&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//调用递归函数，比较左孩子，右孩子&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; isSymmetric(root.left, root.right);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isSymmetric&lt;/span&gt;&lt;span&gt;(TreeNode left, TreeNode right)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//递归终止条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//1、左右两个节点都为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; right == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//2、两个节点中有一个为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left == &lt;span&gt;null&lt;/span&gt; || right == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//3、两个节点的值不相等&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left.val != right.val) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//递归左节点的左孩子和右节点的右孩子&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; outSide = isSymmetric(left.left, right.right);&lt;br/&gt;        &lt;span&gt;//递归左节点的右孩子和右节点的左孩子&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; inSide = isSymmetric(left.right, right.left);&lt;br/&gt;        &lt;span&gt;//两种都对称，树才对称&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; outSide &amp;amp;&amp;amp; inSide;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode104. 二叉树的最大深度&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：104. 二叉树的最大深度 (https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：给定一个二叉树，找出其最大深度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说明:&lt;/span&gt; 叶子节点是指没有子节点的节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4068441064638783&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqia3zUiaYlPpVybNbogcyYK2Giar2IK3ekwOppxEhhd8LespcBuyA2duKxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;526&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题其实和后序遍历类似。递归左右子树，求出左右子树的深度，其中的最大值再加根节点的深度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看看递归怎么写：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;入参、返参&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;终止条件&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;单层逻辑&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;求左子树根的深度l&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;求右子树的深度r&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两棵子树深度的最大值再加上根节点深度，max(&lt;em&gt;l&lt;/em&gt;,&lt;em&gt;r&lt;/em&gt;)+1&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 104. 二叉树的最大深度&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;maxDepth&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; leftDepth = maxDepth(root.left);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rightDepth = maxDepth(root.right);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; maxDepth = Math.max(leftDepth, rightDepth) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; maxDepth;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode 559. N 叉树的最大深度&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：559. N 叉树的最大深度 (https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：给定一个 N 叉树，找到其最大深度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5308219178082192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaG0YnchD3gKlmVjxE7pg4sXlf5zoNvWYlhmPN3sowfzCrBIJlKptv6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;584&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和上一道思路一样，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 559. N 叉树的最大深度&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;maxDepth&lt;/span&gt;&lt;span&gt;(Node root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; maxDepth = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; root.children.size(); i++) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; childrenDepth = maxDepth(root.children.get(i));&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (childrenDepth &amp;gt; maxDepth) {&lt;br/&gt;                maxDepth = childrenDepth;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; maxDepth + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;🚗时间复杂度：每个节点遍历一次，所以时间复杂度是 O(N)，其中 N&lt;em&gt;N&lt;/em&gt; 为节点数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode111. 二叉树的最小深度&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：111. 二叉树的最小深度 (https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个二叉树，找出其最小深度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最小深度是从根节点到最近叶子节点的最短路径上的节点数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**说明：**叶子节点是指没有子节点的节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6868686868686869&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiajOiat1oNT3HRswCaZJc6iaDURI8eL1JpUT5DxdrHN7tj6lY2EBBrVs5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;乍一看，暗喜，这不和二叉树最大深度一样吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仔细一看，不对劲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最小深度是从根节点到最近叶子节点的最短路径上的节点数量。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是到最近的叶子节点。如果子树为空，那就没有叶子节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8142201834862385&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaSV4Qoa6eia0VQXFrLn5tl4W9meQG1SmvKIZ0LcEuAibsxZ58k07eNpGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;436&quot;/&gt;&lt;figcaption&gt;最小深度&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在我们的单层逻辑里要考虑这种情况，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 111. 二叉树的最小深度&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;minDepth&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//左子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; leftDepth = minDepth(root.left);&lt;br/&gt;        &lt;span&gt;//左子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rightDepth = minDepth(root.right);&lt;br/&gt;        &lt;span&gt;//左子树为空的情况&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root.left == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; root.right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; rightDepth + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//右子树为空的情况&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root.right == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; root.left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; leftDepth + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Math.min(leftDepth, rightDepth) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode222. 完全二叉树的节点个数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：222. 完全二叉树的节点个数  (https://leetcode-cn.com/problems/count-complete-tree-nodes/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**进阶：**遍历树来统计节点是一种时间复杂度为 &lt;code&gt;O(n)&lt;/code&gt; 的简单解决方案。你可以设计一个更快的算法吗？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.711304347826087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiatm5T0jUSnywVic3BU99nSwI2iaJibBPokxOr4ZNATPPdtVibqMhwUJkxkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;575&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;递归方法：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要用递归是不是挺简单。左右子树递归，加上根节点。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 222. 完全二叉树的节点个数&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;countNodes&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; leftCount = countNodes(root.left);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rightCount = countNodes(root.right);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; leftCount + rightCount + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;利用完全二叉树特性：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来回忆一下什么是完全二叉树：若一棵二叉树至多只有最下面的两层结点的度数可以小于 2, 并且最下一层上的结点都集中在该层最左边的若干位置上， 则此二叉树称为完全二叉树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完全二叉树有两种情况：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;满二叉树&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最后一层节点没满&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第1种情况，节点个数=2^k-1（k为树的深度，根节点的深度为0）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第2种情况，分别递归左孩⼦，和右孩⼦，递归到某⼀深度⼀定会有左孩⼦或者右孩⼦为满⼆叉树，节点数就可以用2^k-1。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6720297029702971&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaakSKqM81a5UNsbKe9NqasR3cuAyxkD20GT4rSXicYe2Wrg6xLSbhroA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;808&quot;/&gt;&lt;figcaption&gt;完全二叉树情形1&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6492450638792102&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqia8nZIjXMY1K2IbvJNkrJNkPCAnsH0ficjqcOHWdfJBibLU1ZGfYibtyx3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;figcaption&gt;完全二叉树情形-2&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要树不是满二叉树，就递归左右孩子，知道遇到满二叉树，用公式计算子树的节点数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 222. 完全二叉树的节点个数-利用完全二叉树特性&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;countNodes&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//左孩子&lt;/span&gt;&lt;br/&gt;        TreeNode left = root.left;&lt;br/&gt;        &lt;span&gt;//右孩子&lt;/span&gt;&lt;br/&gt;        TreeNode right = root.right;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; leftHeight = &lt;span&gt;0&lt;/span&gt;, rightHeight = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 求左⼦树深度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            left = left.left;&lt;br/&gt;            leftHeight++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 求右⼦树深度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            right = right.right;&lt;br/&gt;            leftHeight++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//满二叉树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (leftHeight == rightHeight) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;2&lt;/span&gt; &amp;lt;&amp;lt; leftHeight) - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; countNodes(root.left) + countNodes(root.right) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;🚗时间复杂度：O(logn * logn)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;🏠 空间复杂度：O(logn)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode110. 平衡二叉树&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：110. 平衡二叉树 (https://leetcode-cn.com/problems/balanced-binary-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本题中，一棵高度平衡二叉树定义为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7307692307692307&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiahwRWibibTFCI4IgegiaekqRBGDMNKrSz1fD6b1G7Q6FJR2K51wNxZdezQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;806&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面，我们做了一道题：104.二叉树的最大深度 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平衡二叉树的定义是&lt;code&gt;一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们思路就有了，用前序遍历的方式去判断一个节点以及节点的左右子树是否平衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;/**&lt;br/&gt;     * 110. 平衡二叉树&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isBalanced&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//左子树高度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; leftDepth = depth(root.left);&lt;br/&gt;        &lt;span&gt;//右子树高度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rightDepth = depth(root.right);&lt;br/&gt;        &lt;span&gt;//当前节点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; isRootBalanced = Math.abs(leftDepth - rightDepth) &amp;lt;= &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//递归左子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; isLeftBalanced = isBalanced(root.left);&lt;br/&gt;        &lt;span&gt;//递归右子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; isRightBalaced = isBalanced(root.right);&lt;br/&gt;        &lt;span&gt;//平衡&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; isRootBalanced &amp;amp;&amp;amp; isLeftBalanced &amp;amp;&amp;amp; isRightBalaced;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取子树高度&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;depth&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//左子树高度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; leftDepth = depth(root.left);&lt;br/&gt;        &lt;span&gt;//右子树高度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rightDepth = depth(root.right);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Math.max(leftDepth, rightDepth) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;🚗 时间复杂度：获取子树高度时间复杂度O(n)，判断平衡又要不断递归左右子树，所以时间复杂度为O(n²)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种是一种时间复杂度略高的方式，是一种&lt;code&gt;从上往下&lt;/code&gt;的判断方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种方式，&lt;code&gt;从下往上&lt;/code&gt;，类似于二叉树的后序遍历。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;/**&lt;br/&gt;     * 110. 平衡二叉树-从下往上&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; root&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isBalanced&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; helper(root) != -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;helper&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//不平衡直接返回-1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//左子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; left = helper(root.left);&lt;br/&gt;        &lt;span&gt;//左子树不平衡&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left == -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//右子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; right = helper(root.right);&lt;br/&gt;        &lt;span&gt;//右子树不平衡&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (right == -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//如果左右子树都是平衡二叉树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//判断左右子树高度差是否小于1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (Math.abs(left - right) &amp;gt; &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//返回二叉树中节点的最大高度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Math.max(left, right) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;🚗时间复杂度：因为从下往上，每个节点只会遍历到一次，所以时间复杂度为O(n)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode404. 左叶子之和&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：404. 左叶子之和(https://leetcode-cn.com/problems/sum-of-left-leaves/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算给定二叉树的所有左叶子之和。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26123936816524906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqia4zBhdfYjWADWMfnkb65ib6hyUlyGlSkEx9FXWWNX61icxEdXqshicHZGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题题号很危险，但其实不难，重点在于搞清楚&lt;span&gt;什么是左叶子节点？&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先，这个节点得是父节点的左孩子，&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;其次，这个节点得是叶子节点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把这点搞清楚以后，就是一个前序遍历，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;sumOfLeftLeaves&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//判断根节点的左孩子是否为左叶子&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root.left != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; root.left.left == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; root.left.right == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            sum = root.left.val;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//递归左右子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode513. 找树左下角的值&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：513. 找树左下角的值 (https://leetcode-cn.com/problems/find-bottom-left-tree-value/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个二叉树，在树的最后一行找到最左边的值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4414019715224535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaP8GLvN4bDKagp6jicj7yZDl3NjxicH0p0IjKZXwDUmG51b9ibtJ6RdWtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;913&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题用广度优先遍历比较简单，前面我们已经做过十道广度优先遍历的题目，这里就不再赘言，上代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;findBottomLeftValue&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; bottomLeftValue = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//保存节点的队列&lt;/span&gt;&lt;br/&gt;        Queue&amp;lt;TreeNode&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;//加入根节点&lt;/span&gt;&lt;br/&gt;        queue.offer(root);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!queue.isEmpty()) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; currentSize = queue.size();&lt;br/&gt;            &lt;span&gt;//取出队列中的节点&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; currentSize; i++) {&lt;br/&gt;                &lt;span&gt;//取出队中节点&lt;/span&gt;&lt;br/&gt;                TreeNode node = queue.poll();&lt;br/&gt;                &lt;span&gt;//每层最左边节点&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (i == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;//赋值&lt;/span&gt;&lt;br/&gt;                    bottomLeftValue = node.val;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//当前节点左孩子入队&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.left);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//当前节点右孩子入队&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (node.right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    queue.offer(node.right);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bottomLeftValue;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二叉树路径问题&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode257. 二叉树的所有路径&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：257. 二叉树的所有路径 (https://leetcode-cn.com/problems/binary-tree-paths/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个二叉树，返回所有从根节点到叶子节点的路径。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说明:&lt;/span&gt; 叶子节点是指没有子节点的节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3558504221954162&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaqcZaNtJFib21qgTFZIAWwkyWPptibmQzyR6Yib9mAE2PxkfKM45pk6icXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;829&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用深度优先遍历的方式处理这道题——前序遍历，递归，我们都写熟了的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，这道题不仅仅是递归，还隐藏了&lt;span&gt;回溯&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类比一下我们平时走路，假如说从一个路口，我们想走完所有路口，那么我们该怎么走呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就是我们先沿着一个路口走到头，再回到上一个路口，走另外一个方向。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这道题目，回溯的示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9584487534626038&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiayf5SyD8GmNBHpAcEDnU91YLgDWYKPAUMr5WkxiaDIsgVRAPGopia6xtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;361&quot;/&gt;&lt;figcaption&gt;回溯&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;/**&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; java.util.List&amp;lt;java.lang.String&amp;gt;&lt;br/&gt;     * &lt;span&gt;@Description&lt;/span&gt;: 二叉树的所有路径-回溯初版&lt;br/&gt;     * &lt;span&gt;@author&lt;/span&gt; 三分恶&lt;br/&gt;     * &lt;span&gt;@date&lt;/span&gt; 2021/7/14 8:28&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span&gt;binaryTreePaths&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;String&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        LinkedList path = &lt;span&gt;new&lt;/span&gt; LinkedList();&lt;br/&gt;        traversal(root, path, result);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; void&lt;br/&gt;     * &lt;span&gt;@Description&lt;/span&gt;: 遍历&lt;br/&gt;     * &lt;span&gt;@author&lt;/span&gt; 三分恶&lt;br/&gt;     * &lt;span&gt;@date&lt;/span&gt; 2021/7/14 8:29&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;traversal&lt;/span&gt;&lt;span&gt;(TreeNode current, LinkedList path, List&amp;lt;String&amp;gt; result)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        path.add(current.val);&lt;br/&gt;        &lt;span&gt;//叶子节点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (current.left == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; current.right == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            StringBuilder sPath = &lt;span&gt;new&lt;/span&gt; StringBuilder();&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; path.size() - &lt;span&gt;1&lt;/span&gt;; i++) {&lt;br/&gt;                sPath.append(path.get(i));&lt;br/&gt;                &lt;span&gt;//这个箭头不能忘&lt;/span&gt;&lt;br/&gt;                sPath.append(&lt;span&gt;&quot;-&amp;gt;&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            sPath.append(path.get(path.size() - &lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;            result.add(sPath.toString());&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//递归左子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (current.left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            traversal(current.left, path, result);&lt;br/&gt;            &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;            path.removeLast();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//递归右子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (current.right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            traversal(current.right, path, result);&lt;br/&gt;            &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;            path.removeLast();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;精简一下也是可以的，不过回溯就隐藏了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;/**&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; java.util.List&amp;lt;java.lang.String&amp;gt;&lt;br/&gt;     * &lt;span&gt;@Description&lt;/span&gt;: 257. 二叉树的所有路径&lt;br/&gt;     * https://leetcode-cn.com/problems/binary-tree-paths/&lt;br/&gt;     * &lt;span&gt;@author&lt;/span&gt; 三分恶&lt;br/&gt;     * &lt;span&gt;@date&lt;/span&gt; 2021/7/11 10:11&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span&gt;binaryTreePaths&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;String&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        traversal(root, &lt;span&gt;&quot;&quot;&lt;/span&gt;, result);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; void&lt;br/&gt;     * &lt;span&gt;@Description&lt;/span&gt;: 遍历&lt;br/&gt;     * &lt;span&gt;@author&lt;/span&gt; 三分恶&lt;br/&gt;     * &lt;span&gt;@date&lt;/span&gt; 2021/7/11 10:10&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;traversal&lt;/span&gt;&lt;span&gt;(TreeNode current, String path, List&amp;lt;String&amp;gt; result)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        path += current.val;&lt;br/&gt;        &lt;span&gt;//叶子节点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (current.left == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; current.right == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//将路径加入到结果中&lt;/span&gt;&lt;br/&gt;            result.add(path);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//递归左子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (current.left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            traversal(current.left, path + &lt;span&gt;&quot;-&amp;gt;&quot;&lt;/span&gt;, result);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//递归右子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (current.right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            traversal(current.right, path + &lt;span&gt;&quot;-&amp;gt;&quot;&lt;/span&gt;, result);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;🚗 时间复杂度：O(n²)，其中n表示节点数目。在深度优先搜索中每个节点会被访问一次且只会被访问一次，每一次会对 path 变量进行拷贝构造，时间代价为 O(n)，所以时间复杂度为O(n^2)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode112. 路径总和&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：112. 路径总和 (https://leetcode-cn.com/problems/path-sum/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;叶子节点 是指没有子节点的节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7121212121212122&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqia7C09ENNBx3VnVekha51XJk3cWHI1IPOZKDdQYZIZ7ibicLwQnDiabzn0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然路径问题已经开始，我们就连做几道来巩固一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一样的思路：&lt;span&gt;递归遍历&lt;/span&gt;+&lt;span&gt;回溯&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7578397212543554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiao1E59MoOyJ0aRBqrT7cI2kD5CBeiaOdQIHMXicTx4x0q9yAicicVG3kKpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot;/&gt;&lt;figcaption&gt;回溯2&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; boolean&lt;br/&gt;     * &lt;span&gt;@Description&lt;/span&gt;:&lt;br/&gt;     * &lt;span&gt;@author&lt;/span&gt; 三分恶&lt;br/&gt;     * &lt;span&gt;@date&lt;/span&gt; 2021/7/13 8:34&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasPathSum&lt;/span&gt;&lt;span&gt;(TreeNode root, &lt;span&gt;int&lt;/span&gt; targetSum)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; traversal(root, targetSum - root.val);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; boolean&lt;br/&gt;     * &lt;span&gt;@Description&lt;/span&gt;: 遍历&lt;br/&gt;     * &lt;span&gt;@author&lt;/span&gt; 三分恶&lt;br/&gt;     * &lt;span&gt;@date&lt;/span&gt; 2021/7/14 21:22&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;traversal&lt;/span&gt;&lt;span&gt;(TreeNode current, &lt;span&gt;int&lt;/span&gt; count)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//终止条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (current.left == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; current.right == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; count == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//叶子节点，且计数为0&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (current.left == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; current.right == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//叶子节点&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//左子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (current.left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            count -= current.left.val;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (traversal(current.left, count)) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//回溯，撤销处理结果&lt;/span&gt;&lt;br/&gt;            count += current.left.val;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//右子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (current.right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            count -= current.right.val;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (traversal(current.right, count)) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            count += current.right.val;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简化一波，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasPathSum&lt;/span&gt;&lt;span&gt;(TreeNode root, &lt;span&gt;int&lt;/span&gt; targetSum)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; traversal(root, targetSum);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;traversal&lt;/span&gt;&lt;span&gt;(TreeNode root, &lt;span&gt;int&lt;/span&gt; count)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//找到满足条件路径&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root.left == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; root.right == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; count == root.val) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; traversal(root.left, count - root.val) || traversal(root.right, count - root.val);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode113. 路径总和 II&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：113. 路径总和 II (https://leetcode-cn.com/problems/path-sum-ii/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;叶子节点 是指没有子节点的节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7128547579298832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaRru2z7bdtRMs086YdNfzZoYBSBCniaP4b1dkqsmWSLmH4XcZMVyRYibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;599&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好家伙，这道题不是结合了257和112嘛！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接先上&lt;span&gt;递归&lt;/span&gt;+&lt;span&gt;回溯&lt;/span&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; pathSum(TreeNode root, &lt;span&gt;int&lt;/span&gt; targetSum) {&lt;br/&gt;        &lt;span&gt;//结果&lt;/span&gt;&lt;br/&gt;        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//路径&lt;/span&gt;&lt;br/&gt;        LinkedList&amp;lt;Integer&amp;gt; path = &lt;span&gt;new&lt;/span&gt; LinkedList();&lt;br/&gt;        traversal(root, path, result, targetSum - root.val);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;traversal&lt;/span&gt;&lt;span&gt;(TreeNode root, LinkedList&amp;lt;Integer&amp;gt; path, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, &lt;span&gt;int&lt;/span&gt; count)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//根节点放入路径&lt;/span&gt;&lt;br/&gt;        path.add(root.val);&lt;br/&gt;        &lt;span&gt;//叶子节点,且满足节点总和要求&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root.left == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; root.right == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; count == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//注意，这里需要新定义一个path集合,否则result里存储的是path的引用&lt;/span&gt;&lt;br/&gt;            List&amp;lt;Integer&amp;gt; newPath = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;(path);&lt;br/&gt;            &lt;span&gt;//添加路径&lt;/span&gt;&lt;br/&gt;            result.add(newPath);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//如果是叶子节点，直接返回&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root.left == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; root.right == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//递归左子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root.left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            count -= root.left.val;&lt;br/&gt;            traversal(root.left, path, result, count);&lt;br/&gt;            &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;            path.removeLast();&lt;br/&gt;            count += root.left.val;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//递归右子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root.right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            count -= root.right.val;&lt;br/&gt;            traversal(root.right, path, result, count);&lt;br/&gt;            &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;            path.removeLast();&lt;br/&gt;            count += root.right.val;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来简化一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;     &lt;span&gt;//结果&lt;/span&gt;&lt;br/&gt;    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;//路径&lt;/span&gt;&lt;br/&gt;    LinkedList&amp;lt;Integer&amp;gt; path = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; java.util.List&amp;lt;java.util.List &amp;lt; java.lang.Integer&amp;gt;&amp;gt;&lt;br/&gt;     * &lt;span&gt;@Description&lt;/span&gt;: 113. 路径总和 II&lt;br/&gt;     * &lt;span&gt;@author&lt;/span&gt; 三分恶&lt;br/&gt;     * &lt;span&gt;@date&lt;/span&gt; 2021/7/12 21:25&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; pathSum(TreeNode root, &lt;span&gt;int&lt;/span&gt; targetSum) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        traversal(root, targetSum);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; void&lt;br/&gt;     * &lt;span&gt;@Description&lt;/span&gt;: 深度优先遍历&lt;br/&gt;     * &lt;span&gt;@author&lt;/span&gt; 三分恶&lt;br/&gt;     * &lt;span&gt;@date&lt;/span&gt; 2021/7/12 22:03&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;traversal&lt;/span&gt;&lt;span&gt;(TreeNode root, &lt;span&gt;int&lt;/span&gt; sum)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//路径和&lt;/span&gt;&lt;br/&gt;        sum -= root.val;&lt;br/&gt;        &lt;span&gt;//添加节点&lt;/span&gt;&lt;br/&gt;        path.offerLast(root.val);&lt;br/&gt;        &lt;span&gt;//到达叶子节点,且路径和满足要求&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root.left == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; root.right == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; sum == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            result.add(&lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;(path));&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//递归左子树&lt;/span&gt;&lt;br/&gt;        traversal(root.left, sum);&lt;br/&gt;        &lt;span&gt;//递归右子树&lt;/span&gt;&lt;br/&gt;        traversal(root.right, sum);&lt;br/&gt;        &lt;span&gt;//回溯&lt;/span&gt;&lt;br/&gt;        path.pollLast();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode437. 路径总和 III&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：437. 路径总和 III (https://leetcode-cn.com/problems/path-sum-iii/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个二叉树，它的每个结点都存放着一个整数值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找出路径和等于给定数值的路径总数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6071856287425149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqianjiamIaVshJIDj06NMiaziboyDmw0vLvsgibTW97rSsmG2h15Mf1Srdh4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;835&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题不需要从根节点开始，也不需要在叶子节点结束，所以呢，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我们要遍历每一个节点，要额外递归一次&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取到符合条件的path，也不要return&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面上代码，直接上精简版的，看了前面一道题，相信原始版&lt;span&gt;递归&lt;/span&gt;+&lt;span&gt;回溯&lt;/span&gt; 也是小case。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;//结果&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; result = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;pathSum&lt;/span&gt;&lt;span&gt;(TreeNode root, &lt;span&gt;int&lt;/span&gt; targetSum)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//根节点&lt;/span&gt;&lt;br/&gt;        traversal(root, targetSum);&lt;br/&gt;        &lt;span&gt;//左子树递归&lt;/span&gt;&lt;br/&gt;        pathSum(root.left, targetSum);&lt;br/&gt;        &lt;span&gt;//右子树递归&lt;/span&gt;&lt;br/&gt;        pathSum(root.right, targetSum);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; void&lt;br/&gt;     * &lt;span&gt;@Description&lt;/span&gt;: 深度优先遍历&lt;br/&gt;     * &lt;span&gt;@author&lt;/span&gt; 三分恶&lt;br/&gt;     * &lt;span&gt;@date&lt;/span&gt; 2021/7/12 22:03&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;traversal&lt;/span&gt;&lt;span&gt;(TreeNode root, &lt;span&gt;int&lt;/span&gt; sum)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//路径和&lt;/span&gt;&lt;br/&gt;        sum -= root.val;&lt;br/&gt;        &lt;span&gt;//不需要到达叶子节点,路径和满足要求即可&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (sum == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//结果添加&lt;/span&gt;&lt;br/&gt;            result++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//递归左子树&lt;/span&gt;&lt;br/&gt;        traversal(root.left, sum);&lt;br/&gt;        &lt;span&gt;//递归右子树&lt;/span&gt;&lt;br/&gt;        traversal(root.right, sum);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;🚗时间复杂度：pathSum会遍历每一个节点，时间复杂度为O(n)，traversal 时间复杂度为O(n)，所以时间复杂度为O(n²)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一道题 ——面试题 04.12. 求和路径 (https://leetcode-cn.com/problems/paths-with-sum-lcci/)   和这道题基本一模一样。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;⼆叉树的修改与构造&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode 106. 从中序与后序遍历序列构造二叉树&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：106. 从中序与后序遍历序列构造二叉树 (https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据一棵树的中序遍历与后序遍历构造二叉树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意:&lt;/span&gt;你可以假设树中没有重复的元素。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38209606986899564&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiateBuwsplI6uJ17REB2ue8wSemjs5gkCOzZmKiaqgwPGTqUdX0NEV6qQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;916&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们首先来看一棵树，中序遍历和后序遍历是什么样&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3684895833333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiay10OkYRWg9j8hgjRf4SMex00I1O6JDJ6By7XDqSxuJbZBUfj1ZMMlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;figcaption&gt;构造二叉树-1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们根据中序遍历和后序遍历的特性，可以得出：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在后序遍历序列中，最后一个元素是树的根节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在中序遍历序列中，根节点的左边是左子树，根节点的右边是右子树&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34167893961708395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaiccazLMgOFiczic59CTvvJQdvInPcDL0jcpdibwZibUiaLpRSn2DMenGxUGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;figcaption&gt;构建二叉树-2&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们怎么还原二叉树呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以拿后序序列的最后一个节点去切分中序序列，然后根据中序序列，再反过来切分后序序列，这样一层一层地切下去，每次后序序列的最后一个元素就是节点的元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看一下这个过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8861788617886179&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaxmBkml2lFKmDYVnyekLhu0xEc2m47AFjEYHHibOfyCxfyTddm2PwYyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;738&quot;/&gt;&lt;figcaption&gt;构建二叉树-3&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那具体的步骤是什么样呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果数组长度为0，说明是空节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果不为空，那么取后序数组最后一个元素作为节点元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找到后序数组最后一个元素在中序数组的位置，作为切割点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;切割中序数组，切成中序左数组（左子树）和中序右数组（右子树）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;切割后序数组，切成后序左数组和后序右数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;递归左、右区间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里又存在一个问题，我们需要确定，下一轮的起点和终点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们拿[inStart，inEnd] 标记中序数组起始和终止位置，拿[postStart，postEnd]标记后序数组起止位置，rootIndex标记根节点位置。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;左子树-中序数组 &lt;code&gt;inStart = inStart&lt;/code&gt;, &lt;code&gt;inEnd = rootIndex - 1&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;左子树-后序数组 &lt;code&gt;postSrart = postStart&lt;/code&gt;, &lt;code&gt;postEnd = postStart + ri - is - 1&lt;/code&gt; (pe计算过程解释，后续数组的起始位置加上左子树长度-1 就是后后序数组结束位置了，左子树的长度 = 根节点索引-左子树)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;右子树-中序数组 &lt;code&gt;inStart = roootIndex + 1, inEnd = inEnd&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;右子树-后序数组&lt;code&gt;postStart = postStart + rootIndex - inStart, postEnd - 1&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4179750947482404&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaKN9Aet66jdAFxdXwdTY74R12pppibrgm1yCv14nCiba3P6bWkmDxYWZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1847&quot;/&gt;&lt;figcaption&gt;树的计算过程-来源参考[7]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 106. 从中序与后序遍历序列构造二叉树&lt;br/&gt;     * https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; inorder&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; postorder&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode &lt;span&gt;buildTree&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] inorder, &lt;span&gt;int&lt;/span&gt;[] postorder)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (inorder.length == &lt;span&gt;0&lt;/span&gt; || postorder.length == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; buildTree(inorder, &lt;span&gt;0&lt;/span&gt;, inorder.length, postorder, &lt;span&gt;0&lt;/span&gt;, postorder.length);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; inorder   中序数组&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; inStart   中序数组起点&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; inEnd     中序数组终点&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; postorder 后序数组&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; postStart 后序数组起点&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; postEnd   后序数组终点&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode &lt;span&gt;buildTree&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] inorder, &lt;span&gt;int&lt;/span&gt; inStart, &lt;span&gt;int&lt;/span&gt; inEnd,&lt;br/&gt;                              &lt;span&gt;int&lt;/span&gt;[] postorder, &lt;span&gt;int&lt;/span&gt; postStart, &lt;span&gt;int&lt;/span&gt; postEnd)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//没有元素&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (inEnd - inStart &amp;lt; &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//只有一个元素&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (inEnd - inStart == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TreeNode(inorder[inStart]);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//后序数组最后一个元素就是根节点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rootVal = postorder[postEnd - &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;        TreeNode root = &lt;span&gt;new&lt;/span&gt; TreeNode(rootVal);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rootIndex = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//根据根节点，找到该值在中序数组inorder里的位置&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = inStart; i &amp;lt; inEnd; i++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (inorder[i] == rootVal) {&lt;br/&gt;                rootIndex = i;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//根据rootIndex切割左右子树&lt;/span&gt;&lt;br/&gt;        root.left = buildTree(inorder, inStart, rootIndex,&lt;br/&gt;                postorder, postStart, postStart + (rootIndex - inStart));&lt;br/&gt;        root.right = buildTree(inorder, rootIndex + &lt;span&gt;1&lt;/span&gt;, inEnd,&lt;br/&gt;                postorder, postStart + (rootIndex - inStart), postEnd - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode105. 从前序与中序遍历序列构造二叉树&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：105. 从前序与中序遍历序列构造二叉树 (https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一棵树的前序遍历 &lt;code&gt;preorder&lt;/code&gt; 与中序遍历 &lt;code&gt;inorder&lt;/code&gt;。请构造二叉树并返回其根节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.712707182320442&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaAvbvnZibq3ZvYZoHjESJRrAicXC7nUDbPwlwFuUBKCjyibTcnqCrA5Vaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;905&quot;/&gt;&lt;figcaption&gt;题目示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和上一道题目类似，先序遍历第一个节点是根节点，拿先序遍历数组第一个元素去切割中序数组，再拿中序数组切割先序数组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode &lt;span&gt;buildTree&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] preorder, &lt;span&gt;int&lt;/span&gt;[] inorder)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; buildTree(preorder, &lt;span&gt;0&lt;/span&gt;, preorder.length-&lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;                inorder, &lt;span&gt;0&lt;/span&gt;, inorder.length-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode &lt;span&gt;buildTree&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] preorder, &lt;span&gt;int&lt;/span&gt; preStart, &lt;span&gt;int&lt;/span&gt; preEnd,&lt;br/&gt;                              &lt;span&gt;int&lt;/span&gt;[] inorder, &lt;span&gt;int&lt;/span&gt; inStart, &lt;span&gt;int&lt;/span&gt; inEnd)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//递归终止条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (inStart &amp;gt; inEnd || preStart &amp;gt; preEnd) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//根节点值&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rootVal = preorder[preStart];&lt;br/&gt;        TreeNode root = &lt;span&gt;new&lt;/span&gt; TreeNode(rootVal);&lt;br/&gt;        &lt;span&gt;//根节点下标&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rootIndex = inStart;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; inorder.length; i++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (inorder[i] == rootVal) {&lt;br/&gt;                rootIndex = i;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//递归，寻找左右子树&lt;/span&gt;&lt;br/&gt;        root.left=buildTree(preorder, preStart + &lt;span&gt;1&lt;/span&gt;, preStart + (rootIndex - inStart),&lt;br/&gt;                inorder, inStart, rootIndex - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        root.right=buildTree(preorder, preStart + (rootIndex - inStart) + &lt;span&gt;1&lt;/span&gt;, preEnd,&lt;br/&gt;                inorder, rootIndex + &lt;span&gt;1&lt;/span&gt;, inEnd);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🚗 时间复杂度：O(n)&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode654. 最大二叉树&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：654. 最大二叉树 (https://leetcode-cn.com/problems/maximum-binary-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;二叉树的根是数组 nums 中的最大元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回有给定数组 nums 构建的 最大二叉树 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;示例 1：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3940397350993377&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaC2jEjLzFVibDib0WsMbgib0xA8hGiauE6AqRicsmUMeHqN4qpy3MibibM2OXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;302&quot;/&gt;&lt;figcaption&gt;示例1&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;输入：nums = [3,2,1,6,0,5]&lt;br/&gt;输出：[6,3,5,null,2,0,null,null,1]&lt;br/&gt;解释：递归调用如下所示：&lt;br/&gt;- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。&lt;br/&gt;    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。&lt;br/&gt;        - 空数组，无子节点。&lt;br/&gt;        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。&lt;br/&gt;            - 空数组，无子节点。&lt;br/&gt;            - 只有一个元素，所以子节点是一个值为 1 的节点。&lt;br/&gt;    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。&lt;br/&gt;        - 只有一个元素，所以子节点是一个值为 0 的节点。&lt;br/&gt;        - 空数组，无子节点。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;示例 2：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.6538461538461537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiawY2MDPqibaDZ9aoU4pskRTPavYibhda1lHCno57bHPdbwgXTlCNWzMWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;182&quot;/&gt;&lt;figcaption&gt;示例2&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;输入：nums = [3,2,1]&lt;br/&gt;输出：[3,null,2,null,1]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个就好说了，题目里面都给出了解法，nums最大元素是根节点，然后再递归最大元素左右部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode &lt;span&gt;constructMaximumBinaryTree&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; constructMaximumBinaryTree(nums, &lt;span&gt;0&lt;/span&gt;, nums.length);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode &lt;span&gt;constructMaximumBinaryTree&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums, &lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt; end)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//没有元素&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (end - start &amp;lt; &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//只剩一个元素&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (end - start == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TreeNode(nums[start]);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//最大值位置&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; maxIndex = start;&lt;br/&gt;        &lt;span&gt;//最大值&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; maxVal = nums[start];&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start + &lt;span&gt;1&lt;/span&gt;; i &amp;lt; end; i++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (nums[i] &amp;gt; maxVal) {&lt;br/&gt;                maxVal = nums[i];&lt;br/&gt;                maxIndex = i;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//根节点&lt;/span&gt;&lt;br/&gt;        TreeNode root = &lt;span&gt;new&lt;/span&gt; TreeNode(maxVal);&lt;br/&gt;        &lt;span&gt;//递归左半部分&lt;/span&gt;&lt;br/&gt;        root.left = constructMaximumBinaryTree(nums, start, maxIndex);&lt;br/&gt;        &lt;span&gt;//递归右半部分&lt;/span&gt;&lt;br/&gt;        root.right = constructMaximumBinaryTree(nums, maxIndex + &lt;span&gt;1&lt;/span&gt;, end);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;🚗 时间复杂度 ：找到数组最大值时间复杂度O(n)，递归时间复杂度O(n)，所以总的时间复杂度O(n²)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode617. 合并二叉树&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：617. 合并二叉树 (https://leetcode-cn.com/problems/merge-two-binary-trees/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 1:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;输入: &lt;br/&gt; Tree 1                     Tree 2                  &lt;br/&gt;          1                         2                             &lt;br/&gt;         / \                       / \                            &lt;br/&gt;        3   2                     1   3                        &lt;br/&gt;       /                           \   \                      &lt;br/&gt;      5                             4   7                  &lt;br/&gt;输出: &lt;br/&gt;合并后的树:&lt;br/&gt;      3&lt;br/&gt;     / \&lt;br/&gt;    4   5&lt;br/&gt;   / \   \ &lt;br/&gt;  5   4   7&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意:&lt;/span&gt; 合并必须从两个树的根节点开始。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做个简单题找下信心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题啥情况呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这不就前序遍历&lt;code&gt;根&lt;/code&gt;、&lt;code&gt;左&lt;/code&gt;、&lt;code&gt;右&lt;/code&gt;嘛。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然题目里没要求不能改变原来的树结构，但是，我们还是用一棵新树来合并两棵树。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode &lt;span&gt;mergeTrees&lt;/span&gt;&lt;span&gt;(TreeNode root1, TreeNode root2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//递归结束条件，有一个节点为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root1 == &lt;span&gt;null&lt;/span&gt; || root2 == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; root1 == &lt;span&gt;null&lt;/span&gt; ? root2 : root1;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//新树&lt;/span&gt;&lt;br/&gt;        TreeNode root = &lt;span&gt;new&lt;/span&gt; TreeNode(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//合并&lt;/span&gt;&lt;br/&gt;        root.val = root1.val + root2.val;&lt;br/&gt;        &lt;span&gt;//左子树&lt;/span&gt;&lt;br/&gt;        root.left = mergeTrees(root1.left, root2.left);&lt;br/&gt;        &lt;span&gt;//右子树&lt;/span&gt;&lt;br/&gt;        root.right = mergeTrees(root1.right, root2.right);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;求⼆叉搜索树的属性&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二叉搜索树我们前面也了解了，左小右大，接下来我们开始看看二叉搜索树相关题目。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode700. 二叉搜索树中的搜索&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：700. 二叉搜索树中的搜索 (https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定二叉搜索树（BST）的根节点和一个值。你需要在BST中找到节点值等于给定值的节点。返回以该节点为根的子树。如果节点不存在，则返回 NULL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;给定二叉搜索树:&lt;br/&gt;&lt;br/&gt;        4&lt;br/&gt;       / \&lt;br/&gt;      2   7&lt;br/&gt;     / \&lt;br/&gt;    1   3&lt;br/&gt;&lt;br/&gt;和值: 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你应该返回如下子树:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;      2     &lt;br/&gt;     / \   &lt;br/&gt;    1   3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述示例中，如果要找的值是 &lt;code&gt;5&lt;/code&gt;，但因为没有节点值为 &lt;code&gt;5&lt;/code&gt;，我们应该返回 &lt;code&gt;NULL&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也没啥好说的吧，前序遍历就行了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只不过递归左右子树的时候，我们可以利用&lt;code&gt;左小右大&lt;/code&gt;的特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📜代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode &lt;span&gt;searchBST&lt;/span&gt;&lt;span&gt;(TreeNode root, &lt;span&gt;int&lt;/span&gt; val)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt; || root.val == val) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//递归左子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (val &amp;lt; root.val) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; searchBST(root.left, val);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//递归右子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (val &amp;gt; root.val) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; searchBST(root.right, val);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode98. 验证二叉搜索树&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：98. 验证二叉搜索树(https://leetcode-cn.com/problems/validate-binary-search-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个二叉树，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设一个二叉搜索树具有如下特征：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;节点的左子树只包含小于当前节点的数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点的右子树只包含大于当前节点的数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;所有左子树和右子树自身必须也是二叉搜索树。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 1:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;输入:&lt;br/&gt;    2&lt;br/&gt;   / \&lt;br/&gt;  1   3&lt;br/&gt;输出: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;示例 2:&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;输入:&lt;br/&gt;    5&lt;br/&gt;   / \&lt;br/&gt;  1   4&lt;br/&gt;     / \&lt;br/&gt;    3   6&lt;br/&gt;输出: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;解释: 输入为: [5,1,4,null,null,3,6]。&lt;br/&gt;     根节点的值为 5 ，但是其右子节点值为 4 。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，中序遍历二叉搜索树，输出的是有序序列，所以上中序遍历。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在root比较的时候呢，我们可以把root和上一个root比较。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📜代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TreeNode pre;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isValidBST&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//左子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; isValidLeft = isValidBST(root.left);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!isValidLeft){&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//根&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pre!=&lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp;pre.val&amp;gt;=root.val){&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        pre=root;&lt;br/&gt;        &lt;span&gt;//右子树&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; isValidRight = isValidBST(root.right);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;  isValidRight;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode530. 二叉搜索树的最小绝对差&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：98. 验证二叉搜索树(https://leetcode-cn.com/problems/validate-binary-search-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;输入：&lt;br/&gt;&lt;br/&gt;   1&lt;br/&gt;    \&lt;br/&gt;     3&lt;br/&gt;    /&lt;br/&gt;   2&lt;br/&gt;&lt;br/&gt;输出：&lt;br/&gt;1&lt;br/&gt;&lt;br/&gt;解释：&lt;br/&gt;最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二叉搜索树的中序遍历是有序的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那和上一道题一样，中序遍历。我们同样记录上一个遍历的节点，然后取和当前节点差值的最大值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📜代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    TreeNode pre;&lt;br/&gt;    Integer res = Integer.MAX_VALUE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getMinimumDifference&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        dfs(root);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; res;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;dfs&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//左&lt;/span&gt;&lt;br/&gt;        getMinimumDifference(root.left);&lt;br/&gt;        &lt;span&gt;//中&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pre != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            res = Math.min(res, root.val-pre.val);&lt;br/&gt;        }&lt;br/&gt;        pre=root;&lt;br/&gt;        &lt;span&gt;//右&lt;/span&gt;&lt;br/&gt;        getMinimumDifference(root.right);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode501. 二叉搜索树中的众数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：501. 二叉搜索树中的众数 (https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假定 BST 有如下定义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;结点左子树中所含结点的值小于等于当前结点的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结点右子树中所含结点的值大于等于当前结点的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;左子树和右子树都是二叉搜索树&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：给定 BST &lt;code&gt;[1,null,2,2]&lt;/code&gt;,&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   1&lt;br/&gt;    \&lt;br/&gt;     2&lt;br/&gt;    /&lt;br/&gt;   2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;返回[2]&lt;/code&gt;.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;提示&lt;/span&gt;：如果众数超过1个，不需考虑输出顺序&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**进阶：**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是二叉树求众数，我们能想到的办法就是引入map来统计高频元素集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是二叉搜索树，我们接着用它的中序遍历有序这个特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用prev表示前一个节点，用count表示当前值的数量，用maxCount表示重复数字的最大数量，使用列表存储结果。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果节点值等于prev，count就加1，&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果节点不等于prev，说明遇到了下一个新的值，更新prev为新的值，然后让count=1；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果count==maxCount，就把当前节点的值加入到集合list中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果count&amp;gt;maxCount，先把list集合清空，然后再把当前节点的值加入到集合list中，最后在更新maxCount的值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📜代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//记录当前个数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//最大个数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; maxCount = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//前驱&lt;/span&gt;&lt;br/&gt;    TreeNode pre=&lt;span&gt;new&lt;/span&gt; TreeNode(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;//存储众数列表&lt;/span&gt;&lt;br/&gt;    List&amp;lt;Integer&amp;gt; res = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] findMode(TreeNode root) {&lt;br/&gt;        dfs(root);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt;[] ans = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[res.size()];&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; res.size(); i++) {&lt;br/&gt;            ans[i] = res.get(i);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ans;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;dfs&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//左&lt;/span&gt;&lt;br/&gt;        dfs(root.left);&lt;br/&gt;        &lt;span&gt;//中&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root.val == pre.val) {&lt;br/&gt;            &lt;span&gt;//如果和前一个相同，count++&lt;/span&gt;&lt;br/&gt;            count++;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//否则&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//pre往后&lt;/span&gt;&lt;br/&gt;            pre = root;&lt;br/&gt;            &lt;span&gt;//count刷新为1&lt;/span&gt;&lt;br/&gt;            count = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//如果是出现次数最多的值&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (count == maxCount) {&lt;br/&gt;            res.add(root.val);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (count &amp;gt; maxCount) {&lt;br/&gt;            &lt;span&gt;//如果超过最多出现次数&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//清空结果结合&lt;/span&gt;&lt;br/&gt;            res.clear();&lt;br/&gt;            &lt;span&gt;//加入新的max元素&lt;/span&gt;&lt;br/&gt;            res.add(root.val);&lt;br/&gt;            &lt;span&gt;//刷新max计数&lt;/span&gt;&lt;br/&gt;            maxCount = count;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//右&lt;/span&gt;&lt;br/&gt;        dfs(root.right);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;⼆叉树公共祖先问题&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode236. 二叉树的最近公共祖先&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：501. 二叉搜索树中的众数 (https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;示例 1：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.95&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqia8MmU06ibicH6FibCa49qKYVgricK44WAAJG7SCNo9sRn8a02ic9VGffv3Tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;200&quot;/&gt;&lt;figcaption&gt;示例1&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1&lt;br/&gt;输出：3&lt;br/&gt;解释：节点 5 和节点 1 的最近公共祖先是节点 3 。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;示例 2：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.95&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqia8MmU06ibicH6FibCa49qKYVgricK44WAAJG7SCNo9sRn8a02ic9VGffv3Tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;200&quot;/&gt;&lt;figcaption&gt;示例2&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4&lt;br/&gt;输出：5&lt;br/&gt;解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们想啊，查找公共祖先，要是我们能从两个节点往回走就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那有什么办法呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得我们前面做路径问题的时候吗？我们用到了一个方法——&lt;code&gt;回溯&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8814432989690721&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaHKW5lCC3o3KxIHKPicyK2eIfdZzlxW7ymmSl6FD3d8LUZ09eicFITWdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;388&quot;/&gt;&lt;figcaption&gt;回溯-公共祖先&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家看一下这个顺序是什么？&lt;code&gt;左、右、根&lt;/code&gt;,这不是后序遍历嘛！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那怎么判断一个节点是节点q和节点p的公共祖先呢？有哪几种情况呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;q和q都是该节点的子树，而且异侧（p左q右或者p右q左）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;q在p的子树中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;q在p的子树中&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那这个后序的递归，又该怎么写呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看看递归三要素[8]：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要递归函数返回节点值，来告诉我们是否找到节点q或者p。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果找到了 节点p或者q，或者遇到空节点，就返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要判断是否找到了p和q.&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当 leftleftleft 和 rightrightright 同时为空 ：说明 root的左 / 右子树中都不包含 p,q，返回 null；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当 left 和 right 同时不为空 ：说明 p,q 分列在 root 的 异侧 （分别在 左 / 右子树），因此 root为最近公共祖先，返回 root&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当 leftleftleft 为空 ，right不为空 ：p,q 都不在 root的左子树中，直接返回 right。具体可分为两种情况：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;p,q 其中一个在 root 的 &lt;span&gt;右子树&lt;/span&gt; 中，此时 right指向 p（假设为 p ）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;p,q 两节点都在 root的 &lt;span&gt;右子树&lt;/span&gt; 中，此时的 right 指向 &lt;span&gt;最近公共祖先节点&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当 left不为空 ， right为空 ：与情况 &lt;code&gt;3.&lt;/code&gt; 同理；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6336805555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaogBTX7chV3G887CozqibvfzgIaicNflHpxyoPmpw6zzrl2icszTbE7ZHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;576&quot;/&gt;&lt;figcaption&gt;二叉树最近公共祖先&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode &lt;span&gt;lowestCommonAncestor&lt;/span&gt;&lt;span&gt;(TreeNode root, TreeNode p, TreeNode q)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//递归结束条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt; || root == p || root == q) &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;        &lt;span&gt;//左&lt;/span&gt;&lt;br/&gt;        TreeNode left = lowestCommonAncestor(root.left, p, q);&lt;br/&gt;        &lt;span&gt;//右&lt;/span&gt;&lt;br/&gt;        TreeNode right = lowestCommonAncestor(root.right, p, q);&lt;br/&gt;        &lt;span&gt;//四种情况判断&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//left和right同时为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; right == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//left和right同时不为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//left为空，right不为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; right;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//left不为空，right为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; right == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; left;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;精简一下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode &lt;span&gt;lowestCommonAncestor&lt;/span&gt;&lt;span&gt;(TreeNode root, TreeNode p, TreeNode q)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//递归结束条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt; || root == p || root == q) &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;        &lt;span&gt;//左&lt;/span&gt;&lt;br/&gt;        TreeNode left = lowestCommonAncestor(root.left, p, q);&lt;br/&gt;        &lt;span&gt;//右&lt;/span&gt;&lt;br/&gt;        TreeNode right = lowestCommonAncestor(root.right, p, q);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; right != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; right;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; left;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode235. 二叉搜索树的最近公共祖先&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：501. 二叉搜索树中的众数 (https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（&lt;span&gt;一个节点也可以是它自己的祖先&lt;/span&gt;）。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.95&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaSSeeVQBD9l7Mgj2nQb6ic1eTRLCRiaMHD2BxKJ1Kq2ePr6bWlpkvgDoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;200&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 1:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8&lt;br/&gt;输出: 6 &lt;br/&gt;解释: 节点 2 和节点 8 的最近公共祖先是 6。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 2:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4&lt;br/&gt;输出: 2&lt;br/&gt;解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说明:&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;所有节点的值都是唯一的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;p、q 为不同节点且均存在于给定的二叉搜索树中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们来看二叉搜索树的最近公共祖先，我们可以直接用二叉树的最近公共祖先的方法给它来一遍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是有没有可能能利用到我们二叉搜索树的特性呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然可以。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的二叉树的节点是左小右大的特性，只要当前节点在[p,q]之间，就可以确定当前节点是最近公共祖先。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6194267515923567&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaWmz5kWtibjLSTu55tLVSqKmKOfcCP3Oic5axkMm1142uL0Hy6g1LqIqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;628&quot;/&gt;&lt;figcaption&gt;二叉搜索树公共祖先&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode &lt;span&gt;lowestCommonAncestor&lt;/span&gt;&lt;span&gt;(TreeNode root, TreeNode p, TreeNode q)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//左&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root.val &amp;gt; p.val &amp;amp;&amp;amp; root.val &amp;gt; q.val) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; lowestCommonAncestor(root.left, p, q);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//右&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root.val &amp;lt; p.val &amp;amp;&amp;amp; root.val &amp;lt; q.val) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; lowestCommonAncestor(root.right, p, q);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;⼆叉搜索树的修改与构造&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode701. 二叉搜索树中的插入操作&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：701. 二叉搜索树中的插入操作 (https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。返回插入后二叉搜索树的根节点。输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。你可以返回 任意有效的结果 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 1：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.29388297872340424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiafHFePVC7xfmmhDtl2dEiawOzPwlAUibfUP7yibO4qGOKiaonzm6LzGELNg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;752&quot;/&gt;&lt;figcaption&gt;示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;输入：root = [4,2,7,1,3], val = 5&lt;br/&gt;输出：[4,2,7,1,3,5]&lt;br/&gt;解释：另一个满足题目要求可以通过的树是：&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8551136363636364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaewQ2QWTfuT0wyVI9Y3kwEnvFyRq7fudb4e2R8kgOPdnHBibJNOBX4Mg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;352&quot;/&gt;&lt;figcaption&gt;示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：这道题是没有限制插入的方式的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像题目示例中，给出了两种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一种：占别人的位置，可以看到5和4的位置做了调整，让树满足平衡二叉树的要求，但是这种实现起来肯定麻烦&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48947368421052634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqia5PWVIfCjIjougYX0D9Biba45LUK8fpMmq2tlicQbB4RlXWJhHNKQahVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;figcaption&gt;第一种&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第二种：我们其实可以偷个懒，找个空位呗，我们通过搜索，找到一个符合大小关系的叶子节点，把它插入到叶子节点的子树。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4075757575757576&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaETQicpXHMkcfaiaGh2wkicuqKviciaBSJJic3XjULrftsKVhwic6NqNmuBXyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;660&quot;/&gt;&lt;figcaption&gt;第二种&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode &lt;span&gt;insertIntoBST&lt;/span&gt;&lt;span&gt;(TreeNode root, &lt;span&gt;int&lt;/span&gt; val)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TreeNode(val);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//左&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (val &amp;lt; root.val) {&lt;br/&gt;            root.left = insertIntoBST(root.left, val);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//右&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (val &amp;gt; root.val) {&lt;br/&gt;            root.right = insertIntoBST(root.right, val);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode450. 删除二叉搜索树中的节点&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：701. 二叉搜索树中的插入操作 (https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，删除节点可分为两个步骤：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明：要求算法时间复杂度为 O(h)，h 为树的高度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;示例:&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;root = [5,3,6,2,4,null,7]&lt;br/&gt;key = 3&lt;br/&gt;&lt;br/&gt;    5&lt;br/&gt;   / \&lt;br/&gt;  3   6&lt;br/&gt; / \   \&lt;br/&gt;2   4   7&lt;br/&gt;&lt;br/&gt;给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。&lt;br/&gt;&lt;br/&gt;一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。&lt;br/&gt;&lt;br/&gt;    5&lt;br/&gt;   / \&lt;br/&gt;  4   6&lt;br/&gt; /     \&lt;br/&gt;2       7&lt;br/&gt;&lt;br/&gt;另一个正确答案是 [5,2,6,null,4,null,7]。&lt;br/&gt;&lt;br/&gt;    5&lt;br/&gt;   / \&lt;br/&gt;  2   6&lt;br/&gt;   \   \&lt;br/&gt;    4   7&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哦吼，上道题我们偷了懒，但是这道题没法偷懒了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除一个节点，就相当于挖了个坑，我们就得想办法把它填上，而且还得让二叉树符合平衡二叉树的定义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找到删除节点，我们把所有的情况列出来：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;左右孩子都为空（叶子节点），直接删除节点&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5462686567164179&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqia62yu6HY00ytYCa1Qut8ic8xUeIibEf57RDZ3armCrG3wSemlEFYFBnxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;figcaption&gt;情形1&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5334346504559271&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaOdDSicAMRtU5RJ6DhyNmJS4bqyicSjTEtmvBudAfictv1yVKDZo8d7y3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot;/&gt;&lt;figcaption&gt;情形2&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5110456553755522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaiaNkJ6iamByAtl9nUGFXX5XZZibnytfELSXpobcPrZ5D6Xg6hyicicMeQQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;figcaption&gt;情形3&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;被删除节点&lt;/code&gt;左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子），放到删除节点的右子树的最左节点的左孩子上。这句话很绕对不对，我们拿图说话。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5370370370370371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaibLVYbgFNBCRB70l61icU7mleFlepkic3HFlgWKwFrcLWuDI8HFeYBe4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;figcaption&gt;情形4&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode &lt;span&gt;deleteNode&lt;/span&gt;&lt;span&gt;(TreeNode root, &lt;span&gt;int&lt;/span&gt; key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;        &lt;span&gt;//找到被删除节点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root.val == key) {&lt;br/&gt;            &lt;span&gt;//1. 左右孩子都为空（叶子节点）&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (root.left == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; root.right == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;//2. 左孩子为空，右孩子不为空&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (root.left == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; root.right;&lt;br/&gt;            &lt;span&gt;//3. 右孩子为空，左孩子不空&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (root.right == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; root.left;&lt;br/&gt;            &lt;span&gt;//4.左右孩子都不为空&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (root.left != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; root.right != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;//寻找右子树最左节点&lt;/span&gt;&lt;br/&gt;                TreeNode node = root.right;&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (node.left != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    node = node.left;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//把要删除节点的左子树放在node左子树位置&lt;/span&gt;&lt;br/&gt;                node.left = root.left;&lt;br/&gt;                &lt;span&gt;//把root节点保存一下，准备删除&lt;/span&gt;&lt;br/&gt;                TreeNode temp = root;&lt;br/&gt;                &lt;span&gt;//root右孩子作为新的根节点&lt;/span&gt;&lt;br/&gt;                root = root.right;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//左孩子&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (key &amp;lt; root.val) root.left = deleteNode(root.left, key);&lt;br/&gt;        &lt;span&gt;//右孩子&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (key &amp;gt; root.val) root.right = deleteNode(root.right, key);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码点臃肿，但是每种情况都很清晰，懒得再精简了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode669. 修剪二叉搜索树&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：701. 二叉搜索树中的插入操作 (https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。可以证明，存在唯一的答案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;示例 1：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27977839335180055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiat8MTKIpiaAibBnFHbIgQYd1nVS2hhpetEm12lpvrciaWclKbB06bYl4hA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;722&quot;/&gt;&lt;figcaption&gt;示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;输入：root = [1,0,2], low = 1, high = 2&lt;br/&gt;输出：[1,null,2]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;示例 2：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6149584487534626&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaeCTib3PdDFCAuFLuP7SlMU6dZNI8AsWic505qF3jrYiauvpg5ttXbzURw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;722&quot;/&gt;&lt;figcaption&gt;示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3&lt;br/&gt;输出：[3,2,null,1]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡 思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修剪的示意图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8682926829268293&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaL3jTc6fjNumLjJVyibpf9ib13Fv4hIHpx2zkKYYKu7MIJyia8ODACzh1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;410&quot;/&gt;&lt;figcaption&gt;修减示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概的过程是什么样呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;遍历二叉树：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当前节点如果是在[low，high]内，继续向下遍历&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前节点小于low时候，是需要剪枝的节点，查找它的右子树，找到在[low，high]区间的节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果当前节点大于high的时候，是需要剪枝的节点，查找它的左子树，找到在[low，high]区间的节点&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode &lt;span&gt;trimBST&lt;/span&gt;&lt;span&gt;(TreeNode root, &lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt; high)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root.val &amp;lt; low) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; trimBST(root.right, low, high);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root.val &amp;gt; high) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; trimBST(root.left, low, high);&lt;br/&gt;        }&lt;br/&gt;        root.left = trimBST(root.left, low, high);&lt;br/&gt;        root.right = trimBST(root.right, low, high);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LeetCode538. 把二叉搜索树转换为累加树&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;☕ 题目：701. 二叉搜索树中的插入操作 (https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;❓ 难度：中等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;📕 描述：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提醒一下，二叉搜索树满足下列约束条件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;节点的左子树仅包含键 小于 节点键的节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点的右子树仅包含键 大于 节点键的节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;左右子树也必须是二叉搜索树。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;💡思路：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个题怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是数组[3,5,6] 我们马上就能想到，从后往前累加呗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这是个二叉搜索树，我们知道二叉搜索树的中序序列是一个有序序列，那我们把中序倒过来不就行了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中序是&lt;code&gt;左、右、中&lt;/code&gt;,我们改成&lt;code&gt;右、中、左&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.506426735218509&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaZPDrmADzlOV2gPaH6icYOlI4xiaDtCM3pq6A0MygFXqU3uJV9A6vS3Vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;389&quot;/&gt;&lt;figcaption&gt;中序，倒中序&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; preVal = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode &lt;span&gt;convertBST&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        dfs(root);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; root;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;dfs&lt;/span&gt;&lt;span&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//倒中序，右左中&lt;/span&gt;&lt;br/&gt;        dfs(root.right);&lt;br/&gt;        root.val += preVal;&lt;br/&gt;        preVal = root.val;&lt;br/&gt;        dfs(root.left);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺口溜总结来了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.058027079303675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiaePNfep7qBia0nscLXyibjDjcsDkbMFqQO86zDHPmYuLrTBQsrEMTwDeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1034&quot;/&gt;&lt;figcaption&gt;leetcode通关-二叉树总结&lt;/figcaption&gt;&lt;/figure&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;!! &lt;/span&gt;简单的事情重复做，重复的事情认真做，认真的事情有创造性地做！&lt;/p&gt;&lt;p&gt;我是&lt;code&gt;三分恶&lt;/code&gt;，一个能文能武的全栈开发。&lt;/p&gt;&lt;p&gt;&lt;code&gt;点赞&lt;/code&gt;、&lt;code&gt;关注&lt;/code&gt;不迷路，大家下期见！&lt;/p&gt;&lt;/blockquote&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;博主是个算法萌新，刷题思路和路线主要参考了以下大佬！建议关注！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[1]. https://github.com/youngyangyang04/leetcode-master&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[2]. https://labuladong.gitbook.io/algo/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[3]. https://leetcode-cn.com/u/sdwwld/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[4]. https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/qing-song-ji-yi-er-cha-shu-de-qian-zhong-6vu5/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[5]. https://leetcode-cn.com/problems/binary-tree-paths/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-5f58/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[6]. https://leetcode-cn.com/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode-solution/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[7].https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/tu-jie-gou-zao-er-cha-shu-wei-wan-dai-xu-by-user72/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[8].https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[9]. https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/javachao-jian-dan-de-er-fen-sou-suo-di-g-z83v/&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.46484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeM9JsEtVJfEXiaYguBFnAqiahGBws3jfsEQJAGDSmHklNhs0Pu6Ugic14licGTsO6YGiccHxMHFFkIo9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8e28bf0e9b90e956f1cdd3ef79e812ee</guid>
<title>服务发现机制 SPI 居然是破坏者？！</title>
<link>https://toutiao.io/k/kv7cqn1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; role=&quot;option&quot; title=&quot;链接&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot;&gt;
                                            
                                                                                    &lt;span class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2MjUzODc5Mw==&amp;amp;action=getalbum&amp;amp;album_id=1909704794886242314#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1909704794886242314&quot; data-tag_source=&quot;0&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;#&lt;/span&gt;图解技术区&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span class=&quot;article-tag-card__right&quot;&gt;&lt;span class=&quot;weui-hidden_abs&quot;&gt;,&lt;/span&gt;12个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;今天 &lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;4ye&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 来和小伙伴们分享下这个 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;SPI&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 机制啦~ ，&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;SPI&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 的身影无处不在！是&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;热插拔&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;的体现之一，更和&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;双亲委派机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;有点小关系，居然是个破坏者😜&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://img.ryzeyang.top/k6l0&quot;&gt;&lt;img data-ratio=&quot;0.8571428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zIjiaGEEKdYHicGhYCpJhx1lCWAZKWBvrXo0yfrbdyEamsFQKP9sCfrrkvqK1vyzH6wtcn29r0wqFEKb2Drj93Vw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;133&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 cid=&quot;n432&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;主要介绍下 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;Java&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 中的 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;SPI&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 机制 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;Springboot&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 的 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;SPI&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 机制 咱们在下文 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;Springboot&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;的&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;自动装配&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;中再说~ 😝 嘿嘿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;至于 [[ &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;dubbo&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 的 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;SPI&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 机制]]，还没时间深入了解，简单知道了它的 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;SPI&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 的自适应扩展机制，以及下面这些扩展~（超级多扩展的~）🐷&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://img.ryzeyang.top/image-20210610212406478.png&quot;&gt;&lt;img data-ratio=&quot;1.8246153846153845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYHicGhYCpJhx1lCWAZKWBvrXoLIiaKKgPsrlFLibtM6uQV4xVe0oicnbFEez2T5Cr6JicQibnuhcDxpxAJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;325&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://img.ryzeyang.top/roxYg&quot;&gt;&lt;img data-ratio=&quot;1.3170731707317074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYHicGhYCpJhx1lCWAZKWBvrXwkVCjmqxOOMb61uU8f5QI8UocK9qvEBKZdZM2L43YLR8lBC1DD6icDw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;123&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;冲冲冲&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 cid=&quot;n64&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;什么是SPI呢？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n68&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;SPI&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; ，全称为 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;Service Provider Interface&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，是一种&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;服务发现机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。它通过在 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;ClassPath&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 路径下的 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;META-INF/services&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 文件夹查找文件，自动加载文件里所定义的类（定义多少，加载多少）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;它是 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;Java&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 提供的一套用来被第三方实现或者扩展的接口&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 cid=&quot;n81&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;JAVA SPI 实践&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;步骤&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; cid=&quot;n106&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;先定义一个接口和它的实现类&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;2&quot; cid=&quot;n86&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;再在 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;resources&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 下添加  &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;META-INF/services&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 这&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;两个&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;文件夹  在该文件夹中新建一个普通文本，名字为 &lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;接口的全名&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; ，并将 &lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;接口的实现类全名&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 添加到文本中，多个的话进行换行操作&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;最后在代码中调用 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;ServiceLoader.load&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 方法即可实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 cid=&quot;n126&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;项目结构图&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://img.ryzeyang.top/image-20210610215254568.png&quot;&gt;&lt;img data-ratio=&quot;0.9436997319034852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYHicGhYCpJhx1lCWAZKWBvrXjWEyQrGeJA7VvgVibeC1jrjuTpgoiaAysrCG9r2cyudia362XViadNQE5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;373&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 cid=&quot;n138&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;spi文件内容&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://img.ryzeyang.top/image-20210610220930536.png&quot;&gt;&lt;img data-ratio=&quot;0.47297297297297297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYHicGhYCpJhx1lCWAZKWBvrXakfJUia525J4FBAFonictrpFUZMh7HpibickwUba4seeRWwdBic3vepCtTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;222&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 cid=&quot;n112&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;源码如下&lt;/span&gt;&lt;/h3&gt;&lt;h4 cid=&quot;n133&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;接口&lt;/span&gt;&lt;/h4&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot; cid=&quot;n98&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IJava4ye&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Java4yeImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IJava4ye&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;() {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.&lt;span&gt;println&lt;/span&gt;(&lt;span&gt;&quot; 【java4ye】 杰伦 杰伦！&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 cid=&quot;n131&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;测试类&lt;/span&gt;&lt;/h4&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot; cid=&quot;n129&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;SpiTest&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;spiTest&lt;/span&gt;(){&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;ServiceLoader&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IJava4ye&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;load&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;ServiceLoader&lt;/span&gt;.&lt;span&gt;load&lt;/span&gt;(&lt;span&gt;IJava4ye&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;IJava4ye&lt;/span&gt; &lt;span&gt;iJava4ye&lt;/span&gt; : &lt;span&gt;load&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;iJava4ye&lt;/span&gt;.&lt;span&gt;say&lt;/span&gt;();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 cid=&quot;n75&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;结果&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://img.ryzeyang.top/image-20210610221031150.png&quot;&gt;&lt;img data-ratio=&quot;0.391304347826087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYHicGhYCpJhx1lCWAZKWBvrXtqLhP5179dNjn0kySicRppzK4pD8qlRsaPYhTsSGVDiaicibvHOYx4JpiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;276&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;是不是非常的方便，还有 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;IOC&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 的感觉 哈哈😄&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 cid=&quot;n172&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;JDBC实例&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;那么实践完，我们再来看看 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;JDBC&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;  这个小案例😝&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://img.ryzeyang.top/image-20210611081924795.png&quot;&gt;&lt;img data-ratio=&quot;0.7927631578947368&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYHicGhYCpJhx1lCWAZKWBvrXdDxDDPYpWqCCG0abeLHBTrDZFwZQlAIxt3On6mZlP6HHx7VSx5iarTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;304&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;可以看到我们使用的 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;MySQL&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 的 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;JDBC&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 包中就有这么一个例子~🐷&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;而这个 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;java.sql.Driver&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 文件中就定义了这么一个实现类~👇&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n186&quot; mdtype=&quot;blockquote&quot;&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;bash&quot; cid=&quot;n189&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span role=&quot;presentation&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 cid=&quot;n230&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Driver源码&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://img.ryzeyang.top/image-20210611160737792.png&quot;&gt;&lt;img data-ratio=&quot;0.5738498789346247&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYHicGhYCpJhx1lCWAZKWBvrX8udUliabMpw13mefbQCFkC5jR1StrD8iaGCdjIJPHO2yuDyod2M2SAgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;可以发现这里有一个&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;静态代码块&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，随着类被加载，它会直接往 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;DriverManager&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 中注册这个 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;Driver&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 驱动器 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 cid=&quot;n198&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;那有什么作用呢？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;简单看下这个 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;JDBC&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 的写法 ，可以发现，之前我们都是要手动去写这个&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;Class.forName&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 来加载这个驱动器，但是用了这个 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;SPI&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 后，那不就可以省略这行代码了吗~😄 哈哈🐷  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;以后我们都不用管厂商定义了啥，直接使用 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;DriverManager.getConnection(url, username, password);&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 就可以获取到这个连接了，代码中就不会出现这种硬编码~ 灵活多了🐷 （当然不开发框架或者自己多折腾好像也用不上呀😝 哈哈哈）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://img.ryzeyang.top/image-20210611162639137.png&quot;&gt;&lt;img data-ratio=&quot;0.7323340471092077&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYHicGhYCpJhx1lCWAZKWBvrXDD4JqJCOmyCYJ9rib1wKmum0XAMYv1NPOX6niaPWpSh9y7BsDZpaH1qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 cid=&quot;n298&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;JAVA SPI 原理探索&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 cid=&quot;n324&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;疑惑&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;不知道小伙伴们实践完会不会有点小疑惑，这个 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;SPI&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 一定要用 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;ServiceLoader.load&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 方法去加载的吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;4ye&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 也不知道是不是  哈哈，但是 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;DriverManager&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 中就是这么使用的😝&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;详细请看下图👇&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://img.ryzeyang.top/image-20210611180542626.png&quot;&gt;&lt;img data-ratio=&quot;0.3767741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYHicGhYCpJhx1lCWAZKWBvrXK6NT5kjN243wKibicyUJrmf9b5O0KM1QVI0QQq3LYnbwcoib9sKdmcNhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;775&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://img.ryzeyang.top/image-20210611174457450.png&quot;&gt;&lt;img data-ratio=&quot;0.5455543358946213&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYHicGhYCpJhx1lCWAZKWBvrX6vI8W3O1TpHQrJd6ialoorkic6C9eoenyH5tSMdeXw36wEiaic4TgicEAwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 cid=&quot;n335&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;破坏双亲委派机制&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;我们都知道在 Java 中有这个&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;双亲委派机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; ，像上面 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;DriverManager&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;  这种做法，其实是破坏了这个 &lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;双亲委派机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;因为这个实现类是属于第三方类库 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;mysql&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;而这个 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;Driver&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 接口是在&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;jdk&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 自身的 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;lib&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;  --》 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;rt.jar&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 中的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;它是由 &lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;根类加载器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;BootstrapClassloader&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 加载的， 而它的实现类却是在第三方的包中，这样子 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;BootstrapClassloader&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 是无法加载的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 cid=&quot;n370&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;那么怎样才能加载第三方包中的类呢？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;看看 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 这个类我们就清楚啦~ 😝&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://img.ryzeyang.top/97nZ&quot;&gt;&lt;img data-ratio=&quot;0.7215909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zIjiaGEEKdYHicGhYCpJhx1lCWAZKWBvrXmJKA9bJoQjojsEMj3pjXh2MAYTJeiaVcP40CIPd3p05UyKwLBUrvrww/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;176&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 cid=&quot;n385&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ServiceLoader源码&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://img.ryzeyang.top/image-20210611181021122.png&quot;&gt;&lt;img data-ratio=&quot;0.28662420382165604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYHicGhYCpJhx1lCWAZKWBvrXUPKHrpOk7SzftYFznSMeibaE7rhJdruYm1UibSdjT4aLYhRlb18KEuaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;785&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;可以发现这里有很显眼的一句话&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n391&quot; mdtype=&quot;blockquote&quot;&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot; cid=&quot;n394&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;ClassLoader&lt;/span&gt; &lt;span&gt;cl&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt;.&lt;span&gt;currentThread&lt;/span&gt;().&lt;span&gt;getContextClassLoader&lt;/span&gt;();&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;通过 &lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;当前线程的上下文类加载器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 去加载的！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;那么这个 &lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;当前线程的上下文类加载器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 中又是用了哪个 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;classLoader&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;在源码中一番搜索之后，我们可以看到在&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;启动器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;Launcher&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 中有这么一段代码，将 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;AppClassLoader&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 赋值给 &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 变量，并将其设置到当前线程中。😋&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://img.ryzeyang.top/image-20210611200408416.png&quot;&gt;&lt;img data-ratio=&quot;0.6004540295119183&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYHicGhYCpJhx1lCWAZKWBvrXlOv8N50yeticCEz5VUZCicsxm48NQH8g65uzQibBp7sGichWASiaUxMIqmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;881&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;那么结论也很明显啦，&lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;SPI&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 是通过&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;应用程序类加载器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;AppClassLoader&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 去加载第三方包中的类的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 cid=&quot;n466&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;java&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 提供了这个&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;服务发现机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;span md-inline=&quot;code&quot; spellcheck=&quot;false&quot;&gt;&lt;code&gt;SPI&lt;/code&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; ，可以方便我们对某个接口进行&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;扩展&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，实现模块的&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;热插拔&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，而缺点就是，灵活度不高，配置文件中由多少实现类，都会被加载到内存中，不管有没有使用到~🐷&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;原理图奉上~&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://img.ryzeyang.top/image-20210611214049491.png&quot;&gt;&lt;img data-ratio=&quot;0.3975448536355052&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYHicGhYCpJhx1lCWAZKWBvrXT6vAChzX6my357egNBu2x9ZMbgHE7yWEMGZkFRbxRicp4fyiaKibxAHBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1059&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 cid=&quot;n491&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;欢迎小伙伴们来一起探讨问题~&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n493&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;如果你觉得本篇文章还不错的话，那拜托再点点赞支持一下呀😝&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;让我们开始这一场意外的相遇吧！~&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;plain&quot;&gt;欢迎留言！谢谢支持！ヾ(≧▽≦*)o 冲冲冲！！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;我是4ye 咱们下期很快再见！！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;1&quot; data-recommend-article-id=&quot;2247485996_1&quot; data-recommend-article-time=&quot;1615903076&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/zIjiaGEEKdYGcWlu5ArFWeeiccmrvWIdYdVzhkBfh7Qia8gIGic1LbP6IEtB2XdGb9PJxKheF2xg96a2U7GpB7ag2Q/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;电子书网站和整理好的一份电子书单&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247485996&amp;amp;idx=1&amp;amp;sn=20e2728118f8e46a2d5e840da0c628fa&amp;amp;chksm=ce07176af9709e7cb593dad0446e75accd03b893f7e2bd16067e371ab735ec75870cea3881ae#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247485996&amp;amp;idx=1&amp;amp;sn=20e2728118f8e46a2d5e840da0c628fa&amp;amp;chksm=ce07176af9709e7cb593dad0446e75accd03b893f7e2bd16067e371ab735ec75870cea3881ae&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;1&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.42668024439918534&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zIjiaGEEKdYGcWlu5ArFWeeiccmrvWIdYdVzhkBfh7Qia8gIGic1LbP6IEtB2XdGb9PJxKheF2xg96a2U7GpB7ag2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;982&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;电子书网站和整理好的一份电子书单&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;1&quot; data-recommend-article-id=&quot;2247487336_1&quot; data-recommend-article-time=&quot;1619968887&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/zIjiaGEEKdYGicOvlN4usBDvvFqCWf5iakoabhdWSV34GnibYW0yswYKYDPvicltIdK6dmBOeo5iborI7LHKgqtuhISQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;站了5个小时换来的书单&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247487336&amp;amp;idx=1&amp;amp;sn=2555ead60a4a965b0a1222d900b0ee86&amp;amp;chksm=ce07122ef9709b38fce40c665cdc7181920291785c19875fd5f96c0d296d2926a08f14cdcbca#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247487336&amp;amp;idx=1&amp;amp;sn=2555ead60a4a965b0a1222d900b0ee86&amp;amp;chksm=ce07122ef9709b38fce40c665cdc7181920291785c19875fd5f96c0d296d2926a08f14cdcbca&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;1&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.4267399267399267&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zIjiaGEEKdYGicOvlN4usBDvvFqCWf5iakoabhdWSV34GnibYW0yswYKYDPvicltIdK6dmBOeo5iborI7LHKgqtuhISQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1092&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;站了5个小时换来的书单&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;1&quot; data-recommend-article-id=&quot;2247487670_1&quot; data-recommend-article-time=&quot;1622649064&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/zIjiaGEEKdYHHyIf8Wibdzsv4a3y2c2MZ2OdGnDzXe73Nd4CdRuv36XCEF43XibpFRAHqibwusicIdsrz4FfmickgJxA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;一份Vue笔记，一个少年故事&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247487670&amp;amp;idx=1&amp;amp;sn=0bef10ca5360531a9295f1819ae42a00&amp;amp;chksm=ce070df0f97084e602d651e9556abf80406900d6f4acf55f2a68a102f61c4f8243722b751288#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247487670&amp;amp;idx=1&amp;amp;sn=0bef10ca5360531a9295f1819ae42a00&amp;amp;chksm=ce070df0f97084e602d651e9556abf80406900d6f4acf55f2a68a102f61c4f8243722b751288&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;1&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.4269889224572004&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zIjiaGEEKdYHHyIf8Wibdzsv4a3y2c2MZ2OdGnDzXe73Nd4CdRuv36XCEF43XibpFRAHqibwusicIdsrz4FfmickgJxA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;993&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;一份Vue笔记，一个少年故事&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;1&quot; data-recommend-article-id=&quot;2247487645_1&quot; data-recommend-article-time=&quot;1622482478&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/zIjiaGEEKdYG66FkVGMP4iaeHAz4WxB9e0z3PzfwicYAtB4r8YaESuoFWf5waiaRdbh18p3ibcNnfgrIIGuNUIuIakA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;万字长文，带你快速上手这些池化技术！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247487645&amp;amp;idx=1&amp;amp;sn=6e198d21ba7d07217535784f295b56af&amp;amp;chksm=ce070ddbf97084cdf80cf162c38fc18647072d2a1079c06c8289d028bd56470d311bdae23036#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247487645&amp;amp;idx=1&amp;amp;sn=6e198d21ba7d07217535784f295b56af&amp;amp;chksm=ce070ddbf97084cdf80cf162c38fc18647072d2a1079c06c8289d028bd56470d311bdae23036&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;1&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.4222972972972973&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zIjiaGEEKdYG66FkVGMP4iaeHAz4WxB9e0z3PzfwicYAtB4r8YaESuoFWf5waiaRdbh18p3ibcNnfgrIIGuNUIuIakA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;296&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;万字长文，带你快速上手这些池化技术！&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;1&quot; data-recommend-article-id=&quot;2247487689_1&quot; data-recommend-article-time=&quot;1623163586&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/zIjiaGEEKdYEUZPDhtZjdaQn036M1cgtUlXWOerFfQGqo1XgAe0SMqiazt2f50ib7pxFy4SGIObXK3xQA0jBgbPTg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;MySQL各大版本新特性一览&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247487689&amp;amp;idx=1&amp;amp;sn=1c3d9fe81a771684e3ec55a84f655287&amp;amp;chksm=ce070d8ff9708499d2f5f4d8a1912ece0d915b84797917dd0f87ddc27f932c0c52e6ad3d3a71#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247487689&amp;amp;idx=1&amp;amp;sn=1c3d9fe81a771684e3ec55a84f655287&amp;amp;chksm=ce070d8ff9708499d2f5f4d8a1912ece0d915b84797917dd0f87ddc27f932c0c52e6ad3d3a71&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;1&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.42567567567567566&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zIjiaGEEKdYEUZPDhtZjdaQn036M1cgtUlXWOerFfQGqo1XgAe0SMqiazt2f50ib7pxFy4SGIObXK3xQA0jBgbPTg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;296&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;MySQL各大版本新特性一览&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;br/&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2MjUzODc5Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFUAO47rDkQycV4q8RTDe4kKXORDlaNmjGLiaxZxbHdOJ32ict5W0wEejBficWOLqDYELibIe5IEdtzeA/0?wx_fmt=png&quot; data-nickname=&quot;Java4ye&quot; data-alias=&quot;Java4ye&quot; data-signature=&quot;定个小目标，写个3年先 ！！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7a79323d33740a48952ecb3c3785b37d</guid>
<title>[译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测 (2020)</title>
<link>https://toutiao.io/k/vydmpz2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post&quot;&gt;
  
  &lt;h1 class=&quot;postTitle&quot;&gt;[译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测（2020）&lt;/h1&gt;
  &lt;p class=&quot;meta&quot;&gt;Published at 2021-09-01 | Last Update 2021-09-01&lt;/p&gt;

  
  
  &lt;h3 id=&quot;译者序&quot;&gt;译者序&lt;/h3&gt;

&lt;p&gt;本文组合翻译了以下两篇文章的干货部分，作为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 相关的入门参考：&lt;/p&gt;



&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 是 2019 年 &lt;strong&gt;&lt;mark&gt;Linux 5.1&lt;/mark&gt;&lt;/strong&gt; 内核首次引入的高性能
&lt;strong&gt;&lt;mark&gt;异步 I/O 框架&lt;/mark&gt;&lt;/strong&gt;，能显著加速 I/O 密集型应用的性能。
但如果你的应用&lt;strong&gt;&lt;mark&gt;已经在使用&lt;/mark&gt;&lt;/strong&gt; 传统 Linux AIO 了，&lt;strong&gt;&lt;mark&gt;并且使用方式恰当&lt;/mark&gt;&lt;/strong&gt;，
那 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; &lt;strong&gt;&lt;mark&gt;并不会带来太大的性能提升&lt;/mark&gt;&lt;/strong&gt; —— 根据原文测试（以及我们
自己的复现），即便打开高级特性，也只有 5%。除非你真的需要这 5% 的额外性能，否则
&lt;strong&gt;&lt;mark&gt;切换&lt;/mark&gt;&lt;/strong&gt;成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; &lt;strong&gt;&lt;mark&gt;代价可能也挺大&lt;/mark&gt;&lt;/strong&gt;，因为要
&lt;strong&gt;&lt;mark&gt;重写应用&lt;/mark&gt;&lt;/strong&gt;来适配 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt;（或者让依赖的平台或框架去适配，总之需要改代码）。&lt;/p&gt;

&lt;p&gt;既然性能跟传统 AIO 差不多，那为什么还称 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 为革命性技术呢？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;它首先和最大的贡献在于：&lt;strong&gt;&lt;mark&gt;统一了 Linux 异步 I/O 框架&lt;/mark&gt;&lt;/strong&gt;，&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Linux AIO &lt;strong&gt;&lt;mark&gt;只支持 direct I/O&lt;/mark&gt;&lt;/strong&gt; 模式的&lt;strong&gt;&lt;mark&gt;存储文件&lt;/mark&gt;&lt;/strong&gt;
（storage file），而且主要用在&lt;strong&gt;&lt;mark&gt;数据库这一细分领域&lt;/mark&gt;&lt;/strong&gt;；&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 支持存储文件和网络文件（network sockets），也支持更多的异步系统调用
（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;accept/openat/stat/...&lt;/code&gt;），而非仅限于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read/write&lt;/code&gt; 系统调用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在&lt;strong&gt;&lt;mark&gt;设计上是真正的异步 I/O&lt;/mark&gt;&lt;/strong&gt;，作为对比，Linux AIO 虽然也
是异步的，但仍然可能会阻塞，某些情况下的行为也无法预测；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;灵活性和可扩展性&lt;/mark&gt;&lt;/strong&gt;非常好，甚至能基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 重新所有系统调用，而 Linux AIO 设计时就没考虑扩展性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;eBPF 也算是异步框架（事件驱动），但与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 没有本质联系，二者属于不同子系统，
并且在模型上有一个本质区别：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;eBPF 对用户是透明的&lt;/mark&gt;&lt;/strong&gt;，只需升级内核（到合适的版本），&lt;strong&gt;&lt;mark&gt;应用程序无需任何改造&lt;/mark&gt;&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 提供了&lt;strong&gt;&lt;mark&gt;新的系统调用和用户空间 API&lt;/mark&gt;&lt;/strong&gt;，因此&lt;strong&gt;&lt;mark&gt;需要应用程序做改造&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;eBPF 作为动态跟踪工具，能够更方便地排查和观测 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 等模块在执行层面的具体问题。&lt;/p&gt;

&lt;p&gt;本文介绍 Linux 异步 I/O 的发展历史，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 的原理和功能，
并给出了一些&lt;strong&gt;&lt;mark&gt;程序示例&lt;/mark&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;mark&gt;性能压测&lt;/mark&gt;&lt;/strong&gt;结果（我们在 5.10
内核做了类似测试，结论与原文差不多）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以下是译文。&lt;/p&gt;

&lt;hr/&gt;



&lt;hr/&gt;

&lt;p&gt;很多人可能还没意识到，Linux 内核在过去几年已经发生了一场革命。这场革命源于
&lt;strong&gt;&lt;mark&gt;两个激动人心的新接口&lt;/mark&gt;&lt;/strong&gt;的引入：&lt;strong&gt;&lt;mark&gt;eBPF 和 io_uring&lt;/mark&gt;&lt;/strong&gt;。
我们认为，二者将会完全&lt;strong&gt;&lt;mark&gt;改变应用与内核交互的方式&lt;/mark&gt;&lt;/strong&gt;，以及
&lt;strong&gt;&lt;mark&gt;应用开发者思考和看待内核的方式&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;本文介绍 io_uring（我们在 ScyllaDB 中有 io_uring 的深入使用经验），并略微提及一下 eBPF。&lt;/p&gt;

&lt;h1 id=&quot;1-linux-io-系统调用演进&quot;&gt;1 Linux I/O 系统调用演进&lt;/h1&gt;

&lt;h2 id=&quot;11-基于-fd-的阻塞式-ioreadwrite&quot;&gt;1.1 基于 fd 的阻塞式 I/O：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()/write()&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;作为大家最熟悉的读写方式，Linux 内核提供了&lt;strong&gt;&lt;mark&gt;基于文件描述符的系统调用&lt;/mark&gt;&lt;/strong&gt;，
这些描述符指向的可能是&lt;strong&gt;&lt;mark&gt;存储文件&lt;/mark&gt;&lt;/strong&gt;（storage file），也可能是 &lt;strong&gt;&lt;mark&gt;network sockets&lt;/mark&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;ssize_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;ssize_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;二者称为&lt;strong&gt;&lt;mark&gt;阻塞式系统调用&lt;/mark&gt;&lt;/strong&gt;（blocking system calls），因为程序调用
这些函数时会进入 sleep 状态，然后被调度出去（让出处理器），直到 I/O 操作完成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果数据在文件中，并且文件内容&lt;strong&gt;&lt;mark&gt;已经缓存在 page cache 中&lt;/mark&gt;&lt;/strong&gt;，调用会&lt;strong&gt;&lt;mark&gt;立即返回&lt;/mark&gt;&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;如果数据在另一台机器上，就需要通过网络（例如 TCP）获取，会阻塞一段时间；&lt;/li&gt;
  &lt;li&gt;如果数据在硬盘上，也会阻塞一段时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但很容易想到，随着存储&lt;strong&gt;&lt;mark&gt;设备越来越快，程序越来越复杂&lt;/mark&gt;&lt;/strong&gt;，
阻塞式（blocking）已经这种最简单的方式已经不适用了。&lt;/p&gt;

&lt;h2 id=&quot;12-非阻塞式-ioselectpollepoll&quot;&gt;1.2 非阻塞式 I/O：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select()/poll()/epoll()&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;阻塞式之后，出现了一些新的、非阻塞的系统调用，例如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;poll()&lt;/code&gt; 以及更新的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoll()&lt;/code&gt;。
应用程序在调用这些函数读写时不会阻塞，而是&lt;strong&gt;&lt;mark&gt;立即返回&lt;/mark&gt;&lt;/strong&gt;，返回的是一个
&lt;strong&gt;&lt;mark&gt;已经 ready 的文件描述符列表&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/intro-to-io-uring/epoll.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;但这种方式存在一个致命缺点：&lt;strong&gt;&lt;mark&gt;只支持 network sockets 和 pipes&lt;/mark&gt;&lt;/strong&gt; ——
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoll()&lt;/code&gt; 甚至连 storage files 都不支持。&lt;/p&gt;

&lt;h2 id=&quot;13-线程池方式&quot;&gt;1.3 线程池方式&lt;/h2&gt;

&lt;p&gt;对于 storage I/O，经典的解决思路是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Thread_pool&quot;&gt;thread pool&lt;/a&gt;：
主线程将 I/O 分发给 worker 线程，后者代替主线程进行阻塞式读写，主线程不会阻塞。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/intro-to-io-uring/thread-pools.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这种方式的问题是&lt;strong&gt;&lt;mark&gt;线程上下文切换开销可能非常大&lt;/mark&gt;&lt;/strong&gt;，后面性能压测会看到。&lt;/p&gt;

&lt;h2 id=&quot;14-direct-io数据库软件绕过-page-cache&quot;&gt;1.4 Direct I/O（数据库软件）：绕过 page cache&lt;/h2&gt;

&lt;p&gt;随后出现了更加灵活和强大的方式：&lt;strong&gt;&lt;mark&gt;数据库软件&lt;/mark&gt;&lt;/strong&gt;（database software）
有时 &lt;a href=&quot;https://www.scylladb.com/2018/07/26/how-scylla-data-cache-works&quot;&gt;&lt;mark&gt;并不想使用操作系统的 page cache&lt;/mark&gt;&lt;/a&gt;，
而是希望打开一个文件后，&lt;strong&gt;&lt;mark&gt;直接从设备读写这个文件&lt;/mark&gt;&lt;/strong&gt;（direct access to the device）。
这种方式称为&lt;strong&gt;&lt;mark&gt;直接访问&lt;/mark&gt;&lt;/strong&gt;（direct access）或&lt;strong&gt;&lt;mark&gt;直接 I/O&lt;/mark&gt;&lt;/strong&gt;（direct I/O），&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;需要指定 &lt;strong&gt;&lt;mark&gt;&lt;code&gt;O_DIRECT&lt;/code&gt;&lt;/mark&gt;&lt;/strong&gt; flag；&lt;/li&gt;
  &lt;li&gt;需要&lt;strong&gt;&lt;mark&gt;应用自己管理自己的缓存&lt;/mark&gt;&lt;/strong&gt; —— 这正是数据库软件所希望的；&lt;/li&gt;
  &lt;li&gt;是 &lt;strong&gt;&lt;mark&gt;zero-copy I/O&lt;/mark&gt;&lt;/strong&gt;，因为应用的缓冲数据直接发送到设备，或者直接从设备读取。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;15-异步-ioaio&quot;&gt;1.5 异步 IO（AIO）&lt;/h2&gt;

&lt;p&gt;前面提到，随着存储设备越来越快，主线程和 worker 线性之间的上下文切换开销占比越来越高。
现在市场上的一些设备，例如 &lt;a href=&quot;https://pcper.com/2018/12/intels-optane-dc-persistent-memory-dimms-push-latency-closer-to-dram&quot;&gt;Intel Optane&lt;/a&gt;
，&lt;strong&gt;&lt;mark&gt;延迟已经低到和上下文切换一个量级&lt;/mark&gt;&lt;/strong&gt;（微秒 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;us&lt;/code&gt;）。换个方式描述，
更能让我们感受到这种开销：
&lt;strong&gt;&lt;mark&gt;上下文每切换一次，我们就少一次 dispatch I/O 的机会&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;因此，Linux &lt;strong&gt;&lt;mark&gt;2.6&lt;/mark&gt;&lt;/strong&gt; 内核引入了异步 I/O（asynchronous I/O）接口，
方便起见，本文简写为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linux-aio&lt;/code&gt;。AIO &lt;strong&gt;&lt;mark&gt;原理&lt;/mark&gt;&lt;/strong&gt;是很简单的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_submit()&lt;/code&gt; 提交 I/O 请求，&lt;/li&gt;
  &lt;li&gt;过一会再调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_getevents()&lt;/code&gt; 来检查哪些 events 已经 ready 了。&lt;/li&gt;
  &lt;li&gt;使程序员&lt;strong&gt;&lt;mark&gt;能编写完全异步的代码&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;近期，&lt;a href=&quot;https://lwn.net/Articles/742978/&quot;&gt;Linux AIO 甚至支持了&lt;/a&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoll()&lt;/code&gt;：也就是说
不仅能提交 storage I/O 请求，还能提交网络 I/O 请求。照这样发展下去，linux-aio
&lt;strong&gt;&lt;mark&gt;似乎能成为一个王者&lt;/mark&gt;&lt;/strong&gt;。但由于它糟糕的演进之路，这个愿望几乎不可能实现了。
我们从 &lt;strong&gt;&lt;mark&gt;Linus 标志性的激烈言辞中就能略窥一斑&lt;/mark&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Reply to: &lt;a href=&quot;https://lwn.net/Articles/671657/&quot;&gt;to support opening files asynchronously&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;em&gt;So I think this is ridiculously ugly.&lt;/em&gt;&lt;/p&gt;

  &lt;p&gt;&lt;em&gt;AIO is a horrible ad-hoc design, with the main excuse being “other, less
gifted people, made that design, and we are implementing it for compatibility
because database people — who seldom have any shred of taste — actually use
it”.&lt;/em&gt;&lt;/p&gt;

  &lt;p&gt;— Linus Torvalds (on lwn.net)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先，作为数据库从业人员，我们想借此机会为我们的没品（lack of taste）向 Linus 道歉。
但更重要的是，我们要进一步解释一下&lt;strong&gt;&lt;mark&gt;为什么 Linus 是对的&lt;/mark&gt;&lt;/strong&gt;：Linux AIO 确实问题缠身，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;只支持 &lt;code&gt;O_DIRECT&lt;/code&gt; 文件&lt;/mark&gt;&lt;/strong&gt;，因此&lt;strong&gt;&lt;mark&gt;对常规的非数据库应用&lt;/mark&gt;&lt;/strong&gt;
  （normal, non-database applications）&lt;strong&gt;&lt;mark&gt;几乎是无用的&lt;/mark&gt;&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;接口在&lt;strong&gt;&lt;mark&gt;设计时并未考虑扩展性&lt;/mark&gt;&lt;/strong&gt;。虽然可以扩展 —— 我们也确实这么做了 —— 但每加一个东西都相当复杂；&lt;/li&gt;
  &lt;li&gt;虽然从&lt;strong&gt;&lt;mark&gt;技术上说接口是非阻塞的&lt;/mark&gt;&lt;/strong&gt;，但实际上有
  &lt;a href=&quot;https://lwn.net/Articles/724198&quot;&gt;&lt;mark&gt;很多可能的原因都会导致它阻塞&lt;/mark&gt;&lt;/a&gt;，而且引发的方式难以预料。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;16-小结&quot;&gt;1.6 小结&lt;/h2&gt;

&lt;p&gt;以上可以清晰地看出 Linux I/O 的演进：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最开始是同步（阻塞式）系统调用；&lt;/li&gt;
  &lt;li&gt;然后随着&lt;strong&gt;&lt;mark&gt;实际需求和具体场景&lt;/mark&gt;&lt;/strong&gt;，不断加入新的异步接口，还要保持与老接口的兼容和协同工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外也看到，在非阻塞式读写的问题上&lt;strong&gt;&lt;mark&gt;并没有形成统一方案&lt;/mark&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Network socket 领域：添加一个异步接口，然后去轮询（poll）请求是否完成（readiness）；&lt;/li&gt;
  &lt;li&gt;Storage I/O 领域：&lt;strong&gt;&lt;mark&gt;只针对某一细分领域&lt;/mark&gt;&lt;/strong&gt;（数据库）在某一特定时期的需求，添加了一个定制版的异步接口。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;&lt;mark&gt;这就是 Linux I/O 的演进历史&lt;/mark&gt;&lt;/strong&gt; —— 只着眼当前，出现一个问题就引入一种设计，而并没有多少前瞻性 —— 直到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 的出现。&lt;/p&gt;

&lt;h1 id=&quot;2-io_uring&quot;&gt;2 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;io_uring 来自资深内核开发者 Jens Axboe 的想法，他在 Linux I/O stack 领域颇有研究。
从最早的 patch &lt;a href=&quot;https://lwn.net/ml/linux-fsdevel/20181221192236.12866-9-axboe@kernel.dk&quot;&gt;aio: support for IO polling&lt;/a&gt;
可以看出，这项工作始于一个很简单的观察：随着设备越来越快，
&lt;strong&gt;&lt;mark&gt;中断驱动（interrupt-driven）模式效率已经低于轮询模式&lt;/mark&gt;&lt;/strong&gt;
（polling for completions） —— 这也是高性能领域最常见的主题之一。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 的&lt;strong&gt;&lt;mark&gt;基本逻辑与 linux-aio 是类似的&lt;/mark&gt;&lt;/strong&gt;：提供两个接口，一个将
I/O 请求提交到内核，一个从内核接收完成事件。&lt;/li&gt;
  &lt;li&gt;但随着开发深入，它逐渐变成了一个完全不同的接口：设计者开始从源头思考
&lt;strong&gt;&lt;mark&gt;如何支持完全异步的操作&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;21-与-linux-aio-的不同&quot;&gt;2.1 与 Linux AIO 的不同&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linux-aio&lt;/code&gt; 有着本质的不同：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;在设计上是真正异步的&lt;/mark&gt;&lt;/strong&gt;（truly asynchronous）。只要
  设置了合适的 flag，它在&lt;strong&gt;&lt;mark&gt;系统调用上下文中就只是将请求放入队列&lt;/mark&gt;&lt;/strong&gt;，
  不会做其他任何额外的事情，&lt;strong&gt;&lt;mark&gt;保证了应用永远不会阻塞&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;支持任何类型的 I/O&lt;/mark&gt;&lt;/strong&gt;：cached files、direct-access files 甚至 blocking sockets。&lt;/p&gt;

    &lt;p&gt;由于设计上就是异步的（async-by-design nature），因此&lt;strong&gt;&lt;mark&gt;无需 poll+read/write 来处理 sockets&lt;/mark&gt;&lt;/strong&gt;。
 只需提交一个阻塞式读（blocking read），请求完成之后，就会出现在 completion ring。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;灵活、可扩展&lt;/mark&gt;&lt;/strong&gt;：基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 甚至能重写（re-implement）Linux 的每个系统调用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;22-原理及核心数据结构sqcqsqecqe&quot;&gt;2.2 原理及核心数据结构：SQ/CQ/SQE/CQE&lt;/h2&gt;

&lt;p&gt;每个 io_uring 实例都有&lt;strong&gt;&lt;mark&gt;两个环形队列&lt;/mark&gt;&lt;/strong&gt;（ring），在内核和应用程序之间共享：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;提交队列&lt;/mark&gt;&lt;/strong&gt;：submission queue (SQ)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;完成队列&lt;/mark&gt;&lt;/strong&gt;：completion queue (CQ)&lt;/li&gt;
&lt;/ul&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/intro-to-io-uring/io_uring.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这两个队列：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;都是&lt;strong&gt;&lt;mark&gt;单生产者、单消费者&lt;/mark&gt;&lt;/strong&gt;，size 是 2 的幂次；&lt;/li&gt;
  &lt;li&gt;提供&lt;strong&gt;&lt;mark&gt;无锁接口&lt;/mark&gt;&lt;/strong&gt;（lock-less access interface），内部使用
&lt;strong&gt;&lt;mark&gt;内存屏障&lt;/mark&gt;&lt;/strong&gt;做同步（coordinated with memory barriers）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;mark&gt;使用方式&lt;/mark&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;请求&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;应用创建 SQ entries (SQE)，更新 SQ tail；&lt;/li&gt;
      &lt;li&gt;内核消费 SQE，更新 SQ head。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;完成&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;内核为完成的一个或多个请求创建 CQ entries (CQE)，更新 CQ tail；&lt;/li&gt;
      &lt;li&gt;应用消费 CQE，更新 CQ head。&lt;/li&gt;
      &lt;li&gt;完成事件（completion events）可能以任意顺序到达，到总是与特定的 SQE 相关联的。&lt;/li&gt;
      &lt;li&gt;消费 CQE 过程无需切换到内核态。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;23-带来的好处&quot;&gt;2.3 带来的好处&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 这种请求方式还有一个好处是：原来需要多次系统调用（读或写），现在变成批处理一次提交。&lt;/p&gt;

&lt;p&gt;还记得 Meltdown 漏洞吗？当时我还写了&lt;a href=&quot;https://www.scylladb.com/2018/01/07/cost-of-avoiding-a-meltdown/&quot;&gt;一篇文章&lt;/a&gt;
解释为什么我们的 Scylla NoSQL 数据库受影响很小：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aio&lt;/code&gt; 已经将我们的 I/O 系统调用批处理化了。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; &lt;strong&gt;&lt;mark&gt;将这种批处理能力带给了&lt;/mark&gt;&lt;/strong&gt; storage I/O 系统调用之外的
&lt;strong&gt;&lt;mark&gt;其他一些系统调用&lt;/mark&gt;&lt;/strong&gt;，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recv&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;accept&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;openat&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stat&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;专用的一些系统调用，例如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fallocate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 使异步 I/O 的使用场景也不再仅限于数据库应用，&lt;strong&gt;&lt;mark&gt;普通的
非数据库应用也能用&lt;/mark&gt;&lt;/strong&gt;。这一点值得重复一遍：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;虽然 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aio&lt;/code&gt; 有一些相似之处，但它的&lt;strong&gt;&lt;mark&gt;扩展性和架构是革命性的&lt;/mark&gt;&lt;/strong&gt;：
它&lt;strong&gt;&lt;mark&gt;将异步操作的强大能力带给了所有应用&lt;/mark&gt;&lt;/strong&gt;（及其开发者），而
&lt;strong&gt;&lt;mark&gt;不再仅限于是数据库应用这一细分领域&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们的 CTO Avi Kivity 在 the Core C++ 2019 event 上 &lt;a href=&quot;https://www.scylladb.com/2020/03/26/avi-kivity-at-core-c-2019&quot;&gt;有一次关于 async 的分享&lt;/a&gt;。
核心点包括：&lt;strong&gt;&lt;mark&gt;从延迟上来说&lt;/mark&gt;&lt;/strong&gt;，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;现代多核、多 CPU 设备，其内部本身就是一个基础网络；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;CPU 之间&lt;/mark&gt;&lt;/strong&gt;是另一个网络；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;CPU 和磁盘 I/O 之间&lt;/mark&gt;&lt;/strong&gt;又是一个网络。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此网络编程采用异步是明智的，而现在开发自己的应用也应该考虑异步。
这&lt;strong&gt;&lt;mark&gt;从根本上改变了 Linux 应用的设计方式&lt;/mark&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;之前都是一段顺序代码流，需要系统调用时才执行系统调用，&lt;/li&gt;
  &lt;li&gt;现在需要思考一个文件是否 ready，因而自然地引入 event-loop，不断通过共享 buffer 提交请求和接收结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;24-三种工作模式&quot;&gt;2.4 三种工作模式&lt;/h2&gt;

&lt;p&gt;io_uring 实例可工作在三种模式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;中断驱动模式&lt;/mark&gt;&lt;/strong&gt;（interrupt driven）&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;默认模式&lt;/mark&gt;&lt;/strong&gt;。可通过 io_uring_enter() 提交 I/O 请求，然后直接检查 CQ 状态判断是否完成。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;轮询模式&lt;/mark&gt;&lt;/strong&gt;（polled）&lt;/p&gt;

    &lt;p&gt;Busy-waiting for an I/O completion，而不是通过异步 IRQ（Interrupt Request）接收通知。&lt;/p&gt;

    &lt;p&gt;这种模式需要文件系统（如果有）和块设备（block device）支持轮询功能。
 相比中断驱动方式，这种方式延迟更低，但可能会消耗更多 CPU 资源。&lt;/p&gt;

    &lt;p&gt;目前，只有指定了 O_DIRECT flag 打开的文件描述符，才能使用这种模式。当一个读
 或写请求提交给轮询上下文（polled context）之后，应用（application）必须调用
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring_enter()&lt;/code&gt; 来轮询 CQ 队列，判断请求是否已经完成。&lt;/p&gt;

    &lt;p&gt;对一个 io_uring 实例来说，&lt;strong&gt;&lt;mark&gt;不支持混合使用轮询和非轮询模式&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;mark&gt;内核轮询模式&lt;/mark&gt;&lt;/strong&gt;（kernel polled）&lt;/p&gt;

    &lt;p&gt;这种模式中，会 &lt;strong&gt;&lt;mark&gt;创建一个内核线程&lt;/mark&gt;&lt;/strong&gt;（kernel thread）来执行 SQ 的轮询工作。&lt;/p&gt;

    &lt;p&gt;使用这种模式的 io_uring 实例， &lt;strong&gt;&lt;mark&gt;应用无需切到到内核态&lt;/mark&gt;&lt;/strong&gt; 就能触发（issue）I/O 操作。
通过 SQ 来提交 SQE，以及监控 CQ 的完成状态，应用无需任何系统调用，就能提交和收割 I/O（submit and reap I/Os）。&lt;/p&gt;

    &lt;p&gt;如果内核线程的空闲时间超过了用户的配置值，它会通知应用，然后进入 idle 状态。
这种情况下，应用必须调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring_enter()&lt;/code&gt; 来唤醒内核线程。如果 I/O 一直很繁忙，内核线性是不会 sleep 的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;25-io_uring-系统调用-api&quot;&gt;2.5 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 系统调用 API&lt;/h2&gt;

&lt;p&gt;有三个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring_setup(2)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring_register(2)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring_enter(2)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面展开介绍。完整文档见 &lt;a href=&quot;https://github.com/axboe/liburing/tree/master/man&quot;&gt;manpage&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;251-io_uring_setup&quot;&gt;2.5.1 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring_setup()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;执行异步 I/O 需要先&lt;strong&gt;&lt;mark&gt;设置上下文&lt;/mark&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;io_uring_setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring_params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个系统调用&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;创建一个 SQ 和一个 CQ&lt;/mark&gt;&lt;/strong&gt;，&lt;/li&gt;
  &lt;li&gt;queue size 至少 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entries&lt;/code&gt; 个元素，&lt;/li&gt;
  &lt;li&gt;返回一个文件描述符，随后用于在这个 io_uring 实例上执行操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SQ 和 CQ 在应用和内核之间共享，避免了在初始化和完成 I/O 时（initiating and completing I/O）拷贝数据。&lt;/p&gt;

&lt;p&gt;参数 p：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;应用用来配置 io_uring，&lt;/li&gt;
  &lt;li&gt;内核返回的 SQ/CQ 配置信息也通过它带回来。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;io_uring_setup() 成功时返回一个文件描述符（fd）。应用随后可以将这个 fd 传给 mmap(2) 系统调用，来
map the submission and completion queues 或者传给 to the io_uring_register() or io_uring_enter() system calls.&lt;/p&gt;

&lt;h3 id=&quot;252-io_uring_register&quot;&gt;2.5.2 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring_register()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;注册用于异步 I/O 的&lt;strong&gt;&lt;mark&gt;文件或用户缓冲区&lt;/mark&gt;&lt;/strong&gt;（files or user buffers）：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;io_uring_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;opcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nr_args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注册文件或用户缓冲区，使内核能&lt;strong&gt;&lt;mark&gt;长时间持有对该文件在内核内部的数据结构引用&lt;/mark&gt;&lt;/strong&gt;（internal kernel data structures associated with the files），
或创建&lt;strong&gt;&lt;mark&gt;应用内存的长期映射&lt;/mark&gt;&lt;/strong&gt;（long term mappings of application memory associated with the buffers），
这个操作只会在注册时执行一次，而不是每个 I/O 请求都会处理，因此减少了 
per-I/O overhead。&lt;/p&gt;

&lt;h4 id=&quot;注册的缓冲区buffer性质&quot;&gt;注册的缓冲区（buffer）性质&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Registered buffers 将会&lt;strong&gt;&lt;mark&gt;被锁定在内存中&lt;/mark&gt;&lt;/strong&gt;（be locked in memory），并&lt;strong&gt;&lt;mark&gt;计入用户的 RLIMIT_MEMLOCK&lt;/mark&gt;&lt;/strong&gt; 资源限制。&lt;/li&gt;
  &lt;li&gt;此外，每个 buffer 有 &lt;strong&gt;&lt;mark&gt;1GB 的大小限制&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;当前，buffers 必须是&lt;strong&gt;&lt;mark&gt;匿名、非文件后端的内存&lt;/mark&gt;&lt;/strong&gt;（anonymous,
non-file-backed memory），例如 malloc(3) or mmap(2) with the MAP_ANONYMOUS
flag set 返回的内存。&lt;/li&gt;
  &lt;li&gt;Huge pages 也是支持的。整个 huge page 都会被 pin 到内核，即使只用到了其中一部分。&lt;/li&gt;
  &lt;li&gt;已经注册的 buffer 无法调整大小，想调整只能先 unregister，再重新 register 一个新的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;通过-eventfd-订阅-completion-事件&quot;&gt;通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eventfd()&lt;/code&gt; 订阅 completion 事件&lt;/h4&gt;

&lt;p&gt;可以用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eventfd(2)&lt;/code&gt; 订阅 io_uring 实例的 completion events。
将 eventfd 描述符通过这个系统调用注册就行了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The credentials of the running application can be registered with io_uring which returns an id associated with
those credentials. Applications wishing to share a ring between separate
users/processes can pass in this credential id in the SQE personality field. If
set, that particular SQE will be issued with these credentials.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;253-io_uring_enter&quot;&gt;2.5.3 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring_enter()&lt;/code&gt;&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;io_uring_enter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to_submit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min_complete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sigset_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个系统调用用于初始化和完成（initiate and complete）I/O，使用共享的 SQ 和 CQ。
单次调用同时执行：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;提交新的 I/O 请求&lt;/li&gt;
  &lt;li&gt;等待 I/O 完成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参数：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring_setup()&lt;/code&gt; 返回的文件描述符；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;to_submit&lt;/code&gt; 指定了 SQ 中提交的 I/O 数量；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;依据不同模式：&lt;/p&gt;

    
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意：对于 interrupt driven I/O，&lt;strong&gt;&lt;mark&gt;应用无需进入内核就能检查 CQ 的 event completions&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring_enter()&lt;/code&gt; 支持很多操作，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Open, close, and stat files&lt;/li&gt;
  &lt;li&gt;Read and write into multiple buffers or pre-mapped buffers&lt;/li&gt;
  &lt;li&gt;Socket I/O operations&lt;/li&gt;
  &lt;li&gt;Synchronize file state&lt;/li&gt;
  &lt;li&gt;Asynchronously monitor a set of file descriptors&lt;/li&gt;
  &lt;li&gt;Create a timeout linked to a specific operation in the ring&lt;/li&gt;
  &lt;li&gt;Attempt to cancel an operation that is currently in flight&lt;/li&gt;
  &lt;li&gt;Create I/O chains&lt;/li&gt;
  &lt;li&gt;Ordered execution within a chain&lt;/li&gt;
  &lt;li&gt;Parallel execution of multiple chains&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当这个系统调用返回时，表示一定数量的 SEQ 已经被消费和提交了，此时可以安全的重用队列中的 SEQ。
此时 IO 提交有可能还停留在异步上下文中，即实际上 SQE 可能还没有被提交 —— 不过
用户不用关心这些细节 —— 当随后内核需要使用某个特定的 SQE 时，它已经复制了一份。&lt;/p&gt;

&lt;h2 id=&quot;26-高级特性&quot;&gt;2.6 高级特性&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 提供了一些用于特殊场景的高级特性：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;File registration&lt;/mark&gt;&lt;/strong&gt;（文件注册）：每次发起一个指定文件描述的操
作，内核都需要&lt;strong&gt;&lt;mark&gt;花费一些时钟周期&lt;/mark&gt;&lt;/strong&gt;（cycles）&lt;strong&gt;&lt;mark&gt;将文件描述符映射到内部表示&lt;/mark&gt;&lt;/strong&gt;。
对于那些&lt;strong&gt;&lt;mark&gt;针对同一文件进行重复操作&lt;/mark&gt;&lt;/strong&gt;的场景，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 支持&lt;strong&gt;&lt;mark&gt;提前注册这些文件&lt;/mark&gt;&lt;/strong&gt;，后面直接查找就行了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;Buffer registration&lt;/mark&gt;&lt;/strong&gt;（缓冲区注册）：与 file registration 类
似，direct I/O 场景中，内核需要 map/unmap memory areas。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 支持提前
注册这些缓冲区（buffers）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;Poll ring&lt;/mark&gt;&lt;/strong&gt;（轮询环形缓冲区）：对于非常快是设备，处理中断的开
销是比较大的。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 允许用户关闭中断，使用轮询模式。前面“三种工作模式”小节
也介绍到了这一点。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;mark&gt;Linked operations&lt;/mark&gt;&lt;/strong&gt;（链接操作）：允许用户发送串联的请求。这两
个请求同时提交，但后面的会等前面的处理完才开始执行。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;27-用户空间库-liburing&quot;&gt;2.7 用户空间库 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;liburing&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/axboe/liburing/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;liburing&lt;/code&gt;&lt;/a&gt; 提供了一个简单的高层 API，
可用于一些基本场景，应用程序避免了直接使用更底层的系统调用。
此外，这个 API 还避免了一些重复操作的代码，如设置 io_uring 实例。&lt;/p&gt;

&lt;p&gt;举个例子，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring_setup()&lt;/code&gt; 的 manpage 描述中，调用这个系统调用获得一个 ring 文
件描述符之后，应用必须调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap()&lt;/code&gt; 来这样的逻辑需要一段略长的代码，而用
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;liburing&lt;/code&gt; 的话，下面的函数已经将上述流程封装好了：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;io_uring_queue_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下一节来看两个例子基于 liburing 的例子。&lt;/p&gt;

&lt;h1 id=&quot;3-基于-liburing-的示例应用&quot;&gt;3 基于 liburing 的示例应用&lt;/h1&gt;

&lt;p&gt;编译：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://github.com/axboe/liburing.git
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git co &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; liburing-2.0 tags/liburing-2.0

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;liburing
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls &lt;/span&gt;examples/
io_uring-cp  io_uring-cp.c  io_uring-test  io_uring-test.c  link-cp  link-cp.c  Makefile  ucontext-cp  ucontext-cp.c

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make &lt;span class=&quot;nt&quot;&gt;-j4&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./examples/io_uring-test &amp;lt;file&amp;gt;
&lt;span class=&quot;nv&quot;&gt;Submitted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;4, &lt;span class=&quot;nv&quot;&gt;completed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;4, &lt;span class=&quot;nv&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;16384

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./examples/link-cp &amp;lt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &amp;lt;out-file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;31-io_uring-test&quot;&gt;3.1 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring-test&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;这个程序使用 4 个 SQE，从输入文件中&lt;strong&gt;&lt;mark&gt;读取最多 16KB 数据&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;源码及注释&quot;&gt;源码及注释&lt;/h3&gt;

&lt;p&gt;为方便看清主要逻辑，忽略了一些错误处理代码，完整代码见
&lt;a href=&quot;https://github.com/axboe/liburing/blob/liburing-2.0/examples/io_uring-test.c&quot;&gt;io_uring-test.c&lt;/a&gt;。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* SPDX-License-Identifier: MIT */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
 * Simple app that demonstrates how to setup an io_uring interface,
 * submit and complete IO against it, and then tear it down.
 *
 * gcc -Wall -O2 -D_GNU_SOURCE -o io_uring-test io_uring-test.c -luring
 */&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &quot;liburing.h&quot;
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define QD    4 // io_uring 队列长度
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 1. 初始化一个 io_uring 实例&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring_queue_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;QD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 队列长度&lt;/span&gt;
                              &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// io_uring 实例&lt;/span&gt;
                              &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// flags，0 表示默认配置，例如使用中断驱动模式&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 2. 打开输入文件，注意这里指定了 O_DIRECT flag，内核轮询模式需要这个 flag，见前面介绍&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_RDONLY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_DIRECT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fstat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 获取文件信息，例如文件长度，后面会用到&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 3. 初始化 4 个读缓冲区&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;ssize_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fsize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// 程序的最大读取长度&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iovec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iovecs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;QD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iovec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;posix_memalign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;iovecs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iov_base&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 起始地址&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;iovecs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iov_len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 缓冲区大小&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fsize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 4. 依次准备 4 个 SQE 读请求，指定将随后读入的数据写入 iovecs &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring_sqe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring_get_sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 获取可用 SQE&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;io_uring_prep_readv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 用这个 SQE 准备一个待提交的 read 操作&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;// 从 fd 打开的文件中读取数据&lt;/span&gt;
                            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iovecs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// iovec 地址，读到的数据写入 iovec 缓冲区&lt;/span&gt;
                            &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// iovec 数量&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 读取操作的起始地址偏移量&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iovecs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iov_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 更新偏移量，下次使用&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 如果超出了文件大小，停止准备后面的 SQE&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 5. 提交 SQE 读请求&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring_submit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 4 个 SQE 一次提交，返回提交成功的 SQE 数量&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;io_uring_submit: %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strerror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;io_uring_submit submitted less %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 6. 等待读请求完成（CQE）&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring_cqe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pending&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fsize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;io_uring_wait_cqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 等待系统返回一个读完成事件&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fsize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ret=%d, wanted 4096&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;fsize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;io_uring_cqe_seen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 更新 io_uring 实例的完成队列&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 7. 打印统计信息&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Submitted=%d, completed=%d, bytes=%lu&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 8. 清理工作&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;io_uring_queue_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;其他说明&quot;&gt;其他说明&lt;/h3&gt;

&lt;p&gt;代码中已经添加了注释，这里再解释几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每个 SQE 都执行一个 allocated buffer，后者是用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iovec&lt;/code&gt; 结构描述的；&lt;/li&gt;
  &lt;li&gt;第 3 &amp;amp; 4 步：初始化所有 SQE，用于接下来的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IORING_OP_READV&lt;/code&gt; 操作，后者
&lt;strong&gt;&lt;mark&gt;提供了 &lt;code&gt;readv(2)&lt;/code&gt; 系统调用的异步接口&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;操作完成之后，这个 SQE iovec buffer 中存放的是相关 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readv&lt;/code&gt; 操作的结果；&lt;/li&gt;
  &lt;li&gt;接下来调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring_wait_cqe()&lt;/code&gt; 来 reap CQE，并通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cqe-&amp;gt;res&lt;/code&gt; 字段验证读取的字节数；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring_cqe_seen()&lt;/code&gt; 通知内核这个 CQE 已经被消费了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;32-link-cp&quot;&gt;3.2 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;link-cp&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;link-cp 使用 io_uring 高级特性 SQE chaining 特性来复制文件。&lt;/p&gt;

&lt;h3 id=&quot;io-chain&quot;&gt;I/O chain&lt;/h3&gt;

&lt;p&gt;io_uring 支持创建 I/O chain。一个 chain 内的 I/O 是顺序执行的，多个 I/O chain 可以并行执行。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring_enter()&lt;/code&gt; manpage 中对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOSQE_IO_LINK&lt;/code&gt; 有 &lt;a href=&quot;https://www.mankier.com/2/io_uring_enter#Description-IOSQE_IO_LINK&quot;&gt;详细解释&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When this flag is specified, it forms a link with the next SQE in the
submission ring. That next SQE will not be started before this one completes.
This, in effect, forms a chain of SQEs, which can be arbitrarily long. The tail
of the chain is denoted by the first SQE that does not have this flag set. This
flag has no effect on previous SQE submissions, nor does it impact SQEs that
are outside of the chain tail. This means that multiple chains can be executing
in parallel, or chains and individual SQEs. Only members inside the chain are
serialized. A chain of SQEs will be broken, if any request in that chain ends
in error. io_uring considers any unexpected result an error. This means that,
eg, a short read will also terminate the remainder of the chain. If a chain of
SQE links is broken, the remaining unstarted part of the chain will be
terminated and completed with -ECANCELED as the error code. Available since
5.3.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为实现复制文件功能，link-cp 创建一个长度为 2 的 SQE chain。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一个 SQE 是一个读请求，将数据从输入文件读到 buffer；&lt;/li&gt;
  &lt;li&gt;第二个请求，与第一个请求是 linked，是一个写请求，将数据从 buffer 写入输出文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;源码及注释-1&quot;&gt;源码及注释&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* SPDX-License-Identifier: MIT */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
 * Very basic proof-of-concept for doing a copy with linked SQEs. Needs a
 * bit of error handling and short read love.
 */&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &quot;liburing.h&quot;
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define QD    64         // io_uring 队列长度
#define BS    (32*1024)
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iovec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iov&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;infd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;outfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inflight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 创建一个 read-&amp;gt;write SQE chain&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;queue_rw_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;off_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;off_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring_sqe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iov&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iov_base&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iov&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iov_len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring_get_sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                            &lt;span class=&quot;c1&quot;&gt;// 获取可用 SQE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;io_uring_prep_readv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;infd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iov&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 准备 read 请求&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOSQE_IO_LINK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                             &lt;span class=&quot;c1&quot;&gt;// 设置为 LINK 模式&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;io_uring_sqe_set_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                        &lt;span class=&quot;c1&quot;&gt;// 设置 data&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring_get_sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                            &lt;span class=&quot;c1&quot;&gt;// 获取另一个可用 SQE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;io_uring_prep_writev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;outfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iov&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 准备 write 请求&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;io_uring_sqe_set_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                        &lt;span class=&quot;c1&quot;&gt;// 设置 data&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 处理完成（completion）事件：释放 SQE 的内存缓冲区，通知内核已经消费了 CQE。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handle_cqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring_cqe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring_cqe_get_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 获取 CQE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ECANCELED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;queue_rw_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;inflight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cqe error: %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strerror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// read-&amp;gt;write chain 完成，释放缓冲区内存&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iov&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iov_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;io_uring_cqe_seen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 通知内核已经消费了 CQE 事件&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;copy_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;off_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring_cqe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;off_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;                      &lt;span class=&quot;c1&quot;&gt;// 数据还没处理完&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has_inflight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inflight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// 当前正在进行中的 SQE 数量&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// SQE 阈值，当前进行中的 SQE 数量（inflight）超过这个值之后，需要阻塞等待 CQE 完成&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inflight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 数据还没处理完，io_uring 队列也还没用完&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;this_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 最后一段数据不足 BS 大小&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;this_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;queue_rw_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 创建一个 read-&amp;gt;write chain，占用两个 SQE&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;insize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;inflight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// 正在进行中的 SQE 数量 +2&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;has_inflight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inflight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 如果有新创建的 SQE，&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;io_uring_submit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 就提交给内核&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;                       &lt;span class=&quot;c1&quot;&gt;// 如果还有 data 等待处理，&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;// 阈值设置 SQ 的队列长度，即 SQ 队列用完才开始阻塞等待 CQE；&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;                              &lt;span class=&quot;c1&quot;&gt;// data 处理已经全部提交，&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                    &lt;span class=&quot;c1&quot;&gt;// 阈值设置为 1，即只要还有 SQE 未完成，就阻塞等待 CQE&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 下面这个 while 只有 SQ 队列用完或 data 全部提交之后才会执行到&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inflight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 如果所有 SQE 都已经用完，或者所有 data read-&amp;gt;write 请求都已经提交&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;io_uring_wait_cqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 等待内核 completion 事件&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;handle_cqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 处理 completion 事件：释放 SQE 内存缓冲区，通知内核 CQE 已消费&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;inflight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;// 正在进行中的 SQE 数量 -1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setup_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;io_uring_queue_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_file_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;off_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fstat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_ISREG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_ISBLK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ioctl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLKGETSIZE64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;off_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;infd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_RDONLY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;outfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_WRONLY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_CREAT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_TRUNC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;0644&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setup_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;QD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_file_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;infd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;infd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;io_uring_queue_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;其他说明-1&quot;&gt;其他说明&lt;/h3&gt;

&lt;p&gt;代码中实现了三个函数：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;copy_file()&lt;/code&gt;：高层复制循环逻辑；它会调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;queue_rw_pair(ring, this_size, offset)&lt;/code&gt; 来构造 SQE pair；
  并通过一次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring_submit()&lt;/code&gt; 调用将所有构建的 SQE pair 提交。&lt;/p&gt;

    &lt;p&gt;这个函数维护了一个最大 DQ 数量的 inflight SQE，只要数据 copy 还在进行中；否则，即数据已经全部读取完成，就开始等待和收割所有的 CQE。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;queue_rw_pair()&lt;/code&gt; 构造一个 read-write SQE pair.&lt;/p&gt;

    &lt;p&gt;read SQE 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOSQE_IO_LINK&lt;/code&gt; flag 表示开始一个 chain，write SQE 不用设置这个 flag，标志着这个 chain 的结束。
 用户 data 字段设置为同一个 data 描述符，并且在随后的 completion 处理中会用到。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handle_cqe()&lt;/code&gt; 从 CQE 中提取之前由  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;queue_rw_pair()&lt;/code&gt; 保存的 data 描述符，并在描述符中记录处理进展（index）。&lt;/p&gt;

    &lt;p&gt;如果之前请求被取消，它还会重新提交 read-write pair。&lt;/p&gt;

    &lt;p&gt;一个 CQE pair 的两个 member 都处理完成之后（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;index==2&lt;/code&gt;），释放共享的 data descriptor。
最后通知内核这个 CQE 已经被消费。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;4-io_uring-性能压测基于-fio&quot;&gt;4 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 性能压测（基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fio&lt;/code&gt;）&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;&lt;mark&gt;对于已经在使用 linux-aio 的应用&lt;/mark&gt;&lt;/strong&gt;，例如 ScyllaDB，
&lt;strong&gt;&lt;mark&gt;不要期望换成 io_uring 之后能获得大幅的性能提升&lt;/mark&gt;&lt;/strong&gt;，这是因为：
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 性能相关的底层机制与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linux-aio&lt;/code&gt; 并无本质不同（都是异步提交，轮询结果）。&lt;/p&gt;

&lt;p&gt;在此，本文也希望使读者明白：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; &lt;strong&gt;&lt;mark&gt;首先和最重要的贡献&lt;/mark&gt;&lt;/strong&gt;在于：
&lt;strong&gt;&lt;mark&gt;将 linux-aio 的所有优良特性带给了普罗大众&lt;/mark&gt;&lt;/strong&gt;（而非局限于数据库这样的细分领域）。&lt;/p&gt;

&lt;h2 id=&quot;41-测试环境&quot;&gt;4.1 测试环境&lt;/h2&gt;

&lt;p&gt;本节使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fio&lt;/code&gt; 测试 4 种模式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;synchronous reads&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;posix-aio&lt;/code&gt; (implemented as a thread pool)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linux-aio&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;硬件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NVMe 存储设备，物理极限能打到 &lt;strong&gt;&lt;mark&gt;3.5M IOPS&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;8 核处理器&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;42-场景一direct-io-1kb-随机读绕过-page-cache&quot;&gt;4.2 场景一：direct I/O &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1KB&lt;/code&gt; 随机读（绕过 page cache）&lt;/h2&gt;

&lt;p&gt;第一组测试中，我们希望所有的读请求都能&lt;strong&gt;&lt;mark&gt;命中存储设备&lt;/mark&gt;&lt;/strong&gt;（all reads
to hit the storage），&lt;strong&gt;&lt;mark&gt;完全绕开操作系统的页缓存&lt;/mark&gt;&lt;/strong&gt;（page cache）。&lt;/p&gt;

&lt;p&gt;测试配置：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;8 个 CPU 执行 72 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fio&lt;/code&gt; job，&lt;/li&gt;
  &lt;li&gt;每个 job 随机读取 4 个文件，&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iodepth=8&lt;/code&gt;（number of I/O units to keep in flight against the file.）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种配置&lt;strong&gt;&lt;mark&gt;保证了 CPU 处于饱和状态&lt;/mark&gt;&lt;/strong&gt;，便于观察 I/O 性能。
如果 CPU 数量足够多，那每组测试都可能会打满设备带宽，结果对 I/O 压测就没意义了。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;表 1. Direct I/O（绕过系统页缓存）：1KB 随机读，CPU 100% 下的 I/O 性能&lt;/p&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;backend&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;IOPS&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;context switches&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;IOPS ±% vs io_uring&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sync&lt;/td&gt;
&lt;td&gt;814,000&lt;/td&gt;
&lt;td&gt;27,625,004&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;-42.6%&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;posix-aio (thread pool)&lt;/td&gt;
&lt;td&gt;433,000&lt;/td&gt;
&lt;td&gt;64,112,335&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;-69.4%&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linux-aio&lt;/td&gt;
&lt;td&gt;1,322,000&lt;/td&gt;
&lt;td&gt;10,114,149&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;-6.7%&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;io_uring (basic)&lt;/td&gt;
&lt;td&gt;1,417,000&lt;/td&gt;
&lt;td&gt;11,309,574&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;—&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;io_uring (enhanced)&lt;/td&gt;
&lt;td&gt;1,486,000&lt;/td&gt;
&lt;td&gt;11,483,468&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;4.9%&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/intro-to-io-uring/benchmark-1.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;几点分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 相比 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linux-aio&lt;/code&gt; 确实有一定提升，但并非革命性的。&lt;/li&gt;
  &lt;li&gt;开启高级特性，例如 buffer &amp;amp; file registration 之后性能有进一步提升 —— 但也还
没有到为了这些性能而重写整个应用的地步，除非你是搞数据库研发，想榨取硬件的最后一分性能。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linux-aio&lt;/code&gt; &lt;strong&gt;&lt;mark&gt;都比同步 read 接口快 2 倍，而后者又比 posix-aio 快 2 倍&lt;/mark&gt;&lt;/strong&gt; ——
初看有点差异。但看看&lt;strong&gt;&lt;mark&gt;上下文切换次数&lt;/mark&gt;&lt;/strong&gt;，就不难理解为什么 posix-aio 这么慢了。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;同步 read 性能差是因为：在这种没有 page cache 的情况下，
&lt;strong&gt;&lt;mark&gt;每次 read 系统调用都会阻塞，因此就会涉及一次上下文切换&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;posix-aio&lt;/code&gt; 性能更差是因为：不仅内核和应用程序之间要频繁上下文切换，线程池的&lt;strong&gt;&lt;mark&gt;多个线程之间也在频繁切换&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;42-场景二buffered-io-1kb-随机读数据提前加载到内存100-hot-cache&quot;&gt;4.2 场景二：buffered I/O &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1KB&lt;/code&gt; 随机读（数据提前加载到内存，100% hot cache）&lt;/h2&gt;

&lt;p&gt;第二组测试 buffered I/O：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;将文件数据提前加载到内存，然后再测随机读。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;由于&lt;strong&gt;&lt;mark&gt;数据全部在 page cache&lt;/mark&gt;&lt;/strong&gt;，因此&lt;strong&gt;&lt;mark&gt;同步 read 永远不会阻塞&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;这种场景下，我们预期&lt;strong&gt;&lt;mark&gt;同步读和 io_uring 的性能差距不大（都是最好的）&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他测试条件不变。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p align=&quot;center&quot;&gt;表 2. Buffered I/O（数据全部来自 page cache，&lt;mark&gt;100% hot cache&lt;/mark&gt;）：1KB 随机读，100% CPU 下的 I/O 性能&lt;/p&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Backend&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;IOPS&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;context switches&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;IOPS ±% vs io_uring&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sync&lt;/td&gt;
&lt;td&gt;4,906,000&lt;/td&gt;
&lt;td&gt; 105,797&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;-2.3%&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;posix-aio (thread pool)&lt;/td&gt;
&lt;td&gt;1,070,000&lt;/td&gt;
&lt;td&gt;114,791,187&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;-78.7%&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linux-aio&lt;/td&gt;
&lt;td&gt;4,127,000&lt;/td&gt;
&lt;td&gt;105,052&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;-17.9%&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;io_uring&lt;/td&gt;
&lt;td&gt;5,024,000&lt;/td&gt;
&lt;td&gt;106,683&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;—&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/intro-to-io-uring/benchmark-2.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;结果分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;同步读和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 性能差距确实很小，二者都是最好的。&lt;/p&gt;

    &lt;p&gt;但注意，&lt;strong&gt;&lt;mark&gt;实际的应用&lt;/mark&gt;&lt;/strong&gt;不可能一直 100% 时间执行 IO 操作，因此
基于同步读的真实应用性能&lt;strong&gt;&lt;mark&gt;还是要比基于 io_uring 要差的&lt;/mark&gt;&lt;/strong&gt;，因为 io_uring 会将多个系统调用批处理化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;posix-aio&lt;/code&gt; 性能最差，直接原因是&lt;strong&gt;&lt;mark&gt;上下文切换次数太多&lt;/mark&gt;&lt;/strong&gt;，这也和场景相关：
在这种 &lt;strong&gt;&lt;mark&gt;CPU 饱和的情况下&lt;/mark&gt;&lt;/strong&gt;，它的线程池反而是累赘，会完全拖慢性能。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linux-aio&lt;/code&gt; 并&lt;strong&gt;&lt;mark&gt;不是针对 buffered I/O 设计的&lt;/mark&gt;&lt;/strong&gt;，在这种 page cache直接返回的场景，
它的&lt;strong&gt;&lt;mark&gt;异步接口反而会造成性能损失&lt;/mark&gt;&lt;/strong&gt; —— 将操作分
为 dispatch 和 consume 两步不但没有性能收益，反而有额外开销。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;43-性能测试小结&quot;&gt;4.3 性能测试小结&lt;/h2&gt;

&lt;p&gt;最后再次提醒，本节是极端应用/场景（&lt;strong&gt;&lt;mark&gt;100% CPU + 100% cache miss/hit&lt;/mark&gt;&lt;/strong&gt;）测试，
真实应用的行为通常处于同步读和异步读之间：时而一些阻塞操作，时而一些非阻塞操作。
但不管怎么说，用了 io_uring 之后，用户就无需担心同步和异步各占多少比例了，因为它&lt;strong&gt;&lt;mark&gt;在任何场景下都表现良好&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果操作是非阻塞的，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 不会有额外开销；&lt;/li&gt;
  &lt;li&gt;如果操作是阻塞式的，也没关系，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 是完全异步的，并且不依赖线程池或昂贵的上下文切换来实现这种异步能力；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本文测试的都是随机读，但对&lt;strong&gt;&lt;mark&gt;其他类型的操作&lt;/mark&gt;&lt;/strong&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 表现也是非常良好的。例如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;打开/关闭文件&lt;/li&gt;
  &lt;li&gt;设置定时器&lt;/li&gt;
  &lt;li&gt;通过 network sockets 传输数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而且&lt;strong&gt;&lt;mark&gt;使用的是同一套 io_uring 接口&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;44-scylladb-与-io_uring&quot;&gt;4.4 ScyllaDB 与 io_uring&lt;/h2&gt;

&lt;p&gt;Scylla 重度依赖 direct I/O，从一开始就使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linux-aio&lt;/code&gt;。
在我们转向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 的过程中，最开始测试显示对某些 workloads，能取得 50% 以上的性能提升。
但&lt;strong&gt;&lt;mark&gt;深入研究之后发现&lt;/mark&gt;&lt;/strong&gt;，这是因为我们&lt;strong&gt;&lt;mark&gt;之前的 linux-aio 用的不够好&lt;/mark&gt;&lt;/strong&gt;。
这也揭示了一个&lt;strong&gt;&lt;mark&gt;经常被忽视的事实&lt;/mark&gt;&lt;/strong&gt;：获得高性能没有那么难（前提是你得弄对了）。
在对比 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linux-aio&lt;/code&gt; 应用之后，我们&lt;strong&gt;&lt;mark&gt;很快改进了一版，二者的性能差距就消失了&lt;/mark&gt;&lt;/strong&gt;。
但坦率地说，解决这个问题&lt;strong&gt;&lt;mark&gt;需要一些工作量&lt;/mark&gt;&lt;/strong&gt;，因为要改动一个已经使用
了很多年的基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linux-aio&lt;/code&gt; 的接口。而对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 应用来说，做类似的改动是轻而
易举的。&lt;/p&gt;

&lt;p&gt;以上只是一个场景，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 相比 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linux-aio&lt;/code&gt; 的&lt;strong&gt;&lt;mark&gt;优势&lt;/mark&gt;&lt;/strong&gt;是能应用于 file I/O 之外的场景。
此外，它还自带了特殊的 &lt;a href=&quot;https://www.p99conf.io/&quot;&gt;高性能&lt;/a&gt; 接口，例如
buffer registration、file registration、轮询模式等等。&lt;/p&gt;

&lt;p&gt;启用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 高级特性之后，我们看到性能确实有提升：Intel Optane 设备，单个
CPU  读取 512 字节，观察到 5% 的性能提升。与 表 1 &amp;amp; 2 对得上。虽然 5% 的提升
看上去不是太大，但对于希望压榨出硬件所有性能的数据库来说，还是非常宝贵的。&lt;/p&gt;

&lt;table&gt;
 &lt;tbody&gt;
   &lt;tr&gt;
   &lt;td&gt;
   &lt;mark&gt;linux-aio:&lt;/mark&gt;
     &lt;p&gt;
     Throughput         :      330 MB/s&lt;br/&gt;
     Lat average        :     1549 usec&lt;br/&gt;
     Lat quantile=  0.5 :     1547 usec&lt;br/&gt;
     Lat quantile= 0.95 :     1694 usec&lt;br/&gt;
     Lat quantile= 0.99 :     1703 usec&lt;br/&gt;
     Lat quantile=0.999 :     1950 usec&lt;br/&gt;
     Lat max            :     2177 usec
     &lt;/p&gt;
   &lt;/td&gt;
   &lt;td&gt;

   &lt;mark&gt;io_uring, with buffer and file registration and poll:&lt;/mark&gt;
   
     &lt;p&gt;
     Throughput         :      346 MB/s&lt;br/&gt;
     Lat average        :     1470 usec&lt;br/&gt;
     Lat quantile= 0.5  :     1468 usec&lt;br/&gt;
     Lat quantile= 0.95 :     1558 usec&lt;br/&gt;
     Lat quantile= 0.99 :     1613 usec&lt;br/&gt;
     Lat quantile=0.999 :     1674 usec&lt;br/&gt;
     Lat max            :     1829 usec
     &lt;/p&gt;
   &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
   &lt;td colspan=&quot;2&quot;&gt;使用 1 个 CPU 从 Intel Optane 设备读取 512 字节。1000 并发请求。linux-aio 和 io_uring basic interface 性能差异很小。
   但启用 io_uring 高级特性后，有 5% 的性能差距。&lt;/td&gt;
   &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;5-ebpf&quot;&gt;5 eBPF&lt;/h1&gt;

&lt;p&gt;eBPF 也是一个&lt;strong&gt;&lt;mark&gt;事件驱动框架&lt;/mark&gt;&lt;/strong&gt;（因此也是异步的），允许用户空间程序动态向内核注入字节码，主要有两个使用场景：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Networking：&lt;a href=&quot;https://arthurchiao.art&quot;&gt;本站&lt;/a&gt; 已经有相当多的文章&lt;/li&gt;
  &lt;li&gt;Tracing &amp;amp; Observability：例如 &lt;a href=&quot;https://github.com/iovisor/bcc&quot;&gt;bcc&lt;/a&gt; 等工具&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;eBPF 在内核  4.9 首次引入，4.19 以后功能已经很强大。更多关于 eBPF 的演进信息，可参考：
&lt;a href=&quot;/blog/ebpf-and-k8s-zh/&quot;&gt;&lt;mark&gt;（译）大规模微服务利器：eBPF + Kubernetes（KubeCon, 2020）&lt;/mark&gt;&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;谈到与 io_uring 的结合，就是用 bcc 之类的工具跟踪一些 I/O 相关的内核函数，例如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Trace how much time an application spends sleeping, and what led to those sleeps. (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wakeuptime&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Find all programs in the system that reached a particular place in the code (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trace&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Analyze network TCP throughput aggregated by subnet (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tcpsubnet&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Measure how much time the kernel spent processing softirqs (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;softirqs&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Capture information about all short-lived files, where they come from, and for how long they were opened (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filelife&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;6-结束语&quot;&gt;6 结束语&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io_uring&lt;/code&gt; 和 eBPF 这两大特性&lt;strong&gt;&lt;mark&gt;将给 Linux 编程带来革命性的变化&lt;/mark&gt;&lt;/strong&gt;。
有了这两个特性的加持，开发者就能更充分地利用 &lt;a href=&quot;https://www.scylladb.com/2019/05/28/aws-new-i3en-meganode&quot;&gt;Amazon i3en meganode systems&lt;/a&gt;
之类的多核/多处理器系统，以及 &lt;a href=&quot;https://www.scylladb.com/2017/09/27/intel-optane-scylla-providing-speed-memory-database-persistency&quot;&gt;Intel Optane 持久存储&lt;/a&gt;
之类的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;us&lt;/code&gt; 级延迟存储设备。&lt;/p&gt;

&lt;h1 id=&quot;参考资料&quot;&gt;参考资料&lt;/h1&gt;




  
  
&lt;/div&gt;


          

      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1fd1d51eabebe151330498b877d16dbf</guid>
<title>美团商品知识图谱的构建及应用</title>
<link>https://toutiao.io/k/dvuncww</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>