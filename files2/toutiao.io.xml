<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>53291337f0760e5fa26856f2b035c427</guid>
<title>为什么 Go 占用那么多的虚拟内存？</title>
<link>https://toutiao.io/k/0zyeufv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前段时间，某同学说某服务的容器因为超出内存限制，不断地重启，问我们是不是有内存泄露，赶紧排查，然后解决掉，省的出问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们大为震惊，赶紧查看监控+报警系统和性能分析，发现应用指标压根就不高，不像有泄露的样子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题到底是出在哪里了呢，我们进入某个容器里查看了 &lt;code&gt;top&lt;/code&gt; 的系统指标：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;PID       VSZ    RSS   ... COMMAND&lt;br/&gt;67459     2007m  136m  ... ./eddycjy-server&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上去也没什么大开销的东西，就一个 Go 进程？就这？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/KVl0giak5ib4htibhubl5wtrrJqdexvxTbXrZYlg4HFnHt2cfNvp73aUaBHuM3ic0ficGHOTGuWEGb4CHC67kWJ2JVQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再定眼一看，某同学就说 VSZ 那么高，而某云上的容器内存指标居然恰好和 VSZ 的值相接近，因此就怀疑是不是 VSZ 所导致的，觉得存在一定的关联关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个猜测的结果到底是否正确呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础知识&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章将&lt;strong&gt;主要围绕 Go 进程的 VSZ 来进行剖析&lt;/strong&gt;，看看到底它为什么那么 &quot;高&quot;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一节为前置的补充知识，大家可按顺序阅读。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是 VSZ&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VSZ 是该进程所能使用的虚拟内存总大小，它包括进程可以访问的所有内存，其中包括了被换出的内存（Swap）、已分配但未使用的内存以及来自共享库的内存。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么要虚拟内存&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面我们有了解到 VSZ 其实就是该进程的虚拟内存总大小，那&lt;strong&gt;如果我们想了解 VSZ 的话，那我们得先了解 “为什么要虚拟内存？”&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质上来讲，在一个系统中的进程是与其他进程共享 CPU 和主存资源的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此在现代的操作系统中，多进程的使用非常的常见，如果太多的进程需要太多的内存，在没有虚拟内存的情况下，物理内存很可能会不够用，就会导致其中有些任务无法运行，更甚至会出现一些很奇怪的现象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 “某一个进程不小心写了另一个进程使用的内存”，就会造成内存破坏，因此虚拟内存是非常重要的一个媒介。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;虚拟内存包含了什么&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟内存，又分为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个进程的虚拟内存都是独立的， 内部结构如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7496902106567535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4htibhubl5wtrrJqdexvxTbXPV2vnCH3W9YyUKcjhsn7vSTWhh3TF6CQU2ianKmRq5fQbvdibYLzUTkA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1614&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在内核虚拟内存中，包含了内核中的代码和数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核虚拟内存中的某些区域会被映射到所有进程共享的物理页面中去，因此你会看到 ”内核虚拟内存“ 中实际上是包含了 ”物理内存“ 的，它们两者存在映射关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而从应用场景上来讲，每个进程也会去共享内核的代码和全局数据结构，因此就会被映射到所有进程的物理页面中去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7496902106567535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4htibhubl5wtrrJqdexvxTbXNH1leIy1liaqzHmMH75W1GcibLpUUH8FwZhTFYEl2IaG1eRMyPkFlEUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1614&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;虚拟内存的重要能力&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更有效地管理内存并且减少出错，现代系统提供了一种对主存的抽象概念，也就是今天的主角，叫做虚拟内存（VM）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件交互的地方，它为每个进程提供了一个大的、一致的和私有的地址空间，虚拟内存提供了三个重要的能力：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它为每个进程提供了一致的地址空间，从而简化了内存管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它保护了每个进程的地址空间不被其他进程破坏。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面发散的可能比较多，简单来讲，对于本文我们重点关注这些知识点，如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;虚拟内存它是有各式各样内存交互的地方，它包含的不仅仅是 &quot;自己&quot;，&lt;strong&gt;而在本文中，我们只需要关注 VSZ，也就是进程虚拟内存，它包含了你的代码、数据、堆、栈段和共享库&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虚拟内存作为内存保护的工具，能够保证进程之间的内存空间独立，不受其他进程的影响，因此每一个进程的 VSZ 大小都不一样，互不影响。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虚拟内存的存在，系统给各进程分配的内存之和是可以大于实际可用的物理内存的，因此你也会发现你进程的物理内存总是比虚拟内存低的多的多。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;排查问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解了基础知识后，我们正式开始排查问题，第一步我们先编写一个测试程序，看看没有什么业务逻辑的 Go 程序，它初始的 VSZ 是怎么样的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; r := gin.Default()&lt;br/&gt; r.GET(&lt;span&gt;&quot;/ping&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  c.JSON(&lt;span&gt;200&lt;/span&gt;, gin.H{&lt;br/&gt;   &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;pong&quot;&lt;/span&gt;,&lt;br/&gt;  })&lt;br/&gt; })&lt;br/&gt; r.Run(&lt;span&gt;&quot;:8001&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看进程情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; ps aux 67459&lt;/span&gt;&lt;br/&gt;USER      PID  %CPU %MEM      VSZ    RSS   ...&lt;br/&gt;eddycjy 67459   0.0  0.0  4297048    960   ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结果上来看，VSZ 为 4297048K，也就是 4G 左右，咋一眼看过去还是挺吓人的，明明没有什么业务逻辑，但是为什么那么高呢，真是令人感到好奇。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;确认有没有泄露&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在未知的情况下，我们可以首先看下 &lt;code&gt;runtime.MemStats&lt;/code&gt; 和 &lt;code&gt;pprof&lt;/code&gt;，确定应用到底有没有泄露。不过我们这块是演示程序，什么业务逻辑都没有，因此可以确定和应用没有直接关系。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# runtime.MemStats&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Alloc = 1298568&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# TotalAlloc = 1298568&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Sys = 71893240&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Lookups = 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Mallocs = 10013&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Frees = 834&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapAlloc = 1298568&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapSys = 66551808&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapIdle = 64012288&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapInuse = 2539520&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapReleased = 64012288&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapObjects = 9179&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go FAQ&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我第一反应是去翻了 Go FAQ（因为看到过，有印象），其问题为 &quot;Why does my Go process use so much virtual memory?&quot;，回答如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;The Go memory allocator reserves a large region of virtual memory as an arena for allocations. This virtual memory is local to the specific Go process; the reservation does not deprive other processes of memory.&lt;/p&gt;&lt;p&gt;To find the amount of actual memory allocated to a Go process, use the Unix top command and consult the RES (Linux) or RSIZE (macOS) columns.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 FAQ 是在 2012 年 10 月 提交 的，这么多年了也没有更进一步的说明，再翻了 issues 和 forum，一些关闭掉的 issue 都指向了 FAQ，这显然无法满足我的求知欲，因此我继续往下探索，看看里面到底都摆了些什么。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查看内存映射&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，我们有提到进程虚拟内存，主要包含了你的代码、数据、堆、栈段和共享库，那初步怀疑是不是进程做了什么内存映射，导致了大量的内存空间被保留呢，为了确定这一点，我们通过如下命令去排查：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ vmmap --wide 67459&lt;br/&gt;...&lt;br/&gt;==== Non-writable regions for process 67459&lt;br/&gt;REGION TYPE                      START - END             [ VSIZE  RSDNT  DIRTY   SWAP] PRT/MAX SHRMOD PURGE    REGION DETAIL&lt;br/&gt;__TEXT                 00000001065ff000-000000010667b000 [  496K   492K     0K     0K] r-x/rwx SM=COW          /bin/zsh&lt;br/&gt;__LINKEDIT             0000000106687000-0000000106699000 [   72K    44K     0K     0K] r--/rwx SM=COW          /bin/zsh&lt;br/&gt;MALLOC metadata        000000010669b000-000000010669c000 [    4K     4K     4K     0K] r--/rwx SM=COW          DefaultMallocZone_0x10669b000 zone structure&lt;br/&gt;...&lt;br/&gt;__TEXT                 00007fff76c31000-00007fff76c5f000 [  184K   168K     0K     0K] r-x/r-x SM=COW          /usr/lib/system/libxpc.dylib&lt;br/&gt;__LINKEDIT             00007fffe7232000-00007ffff32cb000 [192.6M  17.4M     0K     0K] r--/r-- SM=COW          dyld shared cache combined __LINKEDIT&lt;br/&gt;...        &lt;br/&gt;&lt;br/&gt;==== Writable regions for process 67459&lt;br/&gt;REGION TYPE                      START - END             [ VSIZE  RSDNT  DIRTY   SWAP] PRT/MAX SHRMOD PURGE    REGION DETAIL&lt;br/&gt;__DATA                 000000010667b000-0000000106682000 [   28K    28K    28K     0K] rw-/rwx SM=COW          /bin/zsh&lt;br/&gt;...   &lt;br/&gt;__DATA                 0000000106716000-000000010671e000 [   32K    28K    28K     4K] rw-/rwx SM=COW          /usr/lib/zsh/5.3/zsh/zle.so&lt;br/&gt;__DATA                 000000010671e000-000000010671f000 [    4K     4K     4K     0K] rw-/rwx SM=COW          /usr/lib/zsh/5.3/zsh/zle.so&lt;br/&gt;__DATA                 0000000106745000-0000000106747000 [    8K     8K     8K     0K] rw-/rwx SM=COW          /usr/lib/zsh/5.3/zsh/complete.so&lt;br/&gt;__DATA                 000000010675a000-000000010675b000 [    4K     4K     4K     0K] rw-&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这块主要是利用 macOS 的 &lt;code&gt;vmmap&lt;/code&gt; 命令去查看内存映射情况，这样就可以知道这个进程的内存映射情况，从输出分析来看，&lt;strong&gt;这些关联共享库占用的空间并不大，导致 VSZ 过高的根本原因不在共享库和二进制文件上，但是并没有发现大量保留内存空间的行为，这是一个问题点&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：若是 Linux 系统，可使用 &lt;code&gt;cat /proc/PID/maps&lt;/code&gt; 或 &lt;code&gt;cat /proc/PID/smaps&lt;/code&gt; 查看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查看系统调用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然在内存映射中，我们没有明确的看到保留内存空间的行为，那我们接下来看看该进程的系统调用，确定一下它是否存在内存操作的行为，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ sudo dtruss -a ./awesomeProject&lt;br/&gt;...&lt;br/&gt; 4374/0x206a2:     15620       6      3 mprotect(0x1BC4000, 0x1000, 0x0)   = 0 0&lt;br/&gt;...&lt;br/&gt; 4374/0x206a2:     15781       9      4 sysctl([CTL_HW, 3, 0, 0, 0, 0] (2), 0x7FFEEFBFFA64, 0x7FFEEFBFFA68, 0x0, 0x0)   = 0 0&lt;br/&gt; 4374/0x206a2:     15783       3      1 sysctl([CTL_HW, 7, 0, 0, 0, 0] (2), 0x7FFEEFBFFA64, 0x7FFEEFBFFA68, 0x0, 0x0)   = 0 0&lt;br/&gt; 4374/0x206a2:     15899       7      2 mmap(0x0, 0x40000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0x4000000 0&lt;br/&gt; 4374/0x206a2:     15930       3      1 mmap(0xC000000000, 0x4000000, 0x0, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0xC000000000 0&lt;br/&gt; 4374/0x206a2:     15934       4      2 mmap(0xC000000000, 0x4000000, 0x3, 0x1012, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0xC000000000 0&lt;br/&gt; 4374/0x206a2:     15936       2      0 mmap(0x0, 0x2000000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0x59B7000 0&lt;br/&gt; 4374/0x206a2:     15942       2      0 mmap(0x0, 0x210800, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0x4040000 0&lt;br/&gt; 4374/0x206a2:     15947       2      0 mmap(0x0, 0x10000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0x1BD0000 0&lt;br/&gt; 4374/0x206a2:     15993       3      0 madvise(0xC000000000, 0x2000, 0x8)   = 0 0&lt;br/&gt; 4374/0x206a2:     16004       2      0 mmap(0x0, 0x10000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0x1BE0000 0&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这小节中，我们通过 macOS 的 &lt;code&gt;dtruss&lt;/code&gt; 命令监听并查看了运行这个程序所进行的所有系统调用，发现了与内存管理有一定关系的方法如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mmap：创建一个新的虚拟内存区域，但这里需要注意，&lt;strong&gt;就是当系统调用 mmap 时，它只是从虚拟内存中申请了一段空间出来，并不会去分配和映射真实的物理内存，而当你访问这段空间的时候，才会在当前时间真正的去分配物理内存&lt;/strong&gt;。那么对应到我们实际应用的进程中，那就是 VSZ 的增长后，而该内存空间又未正式使用的话，物理内存是不会有增长的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;madvise：提供有关使用内存的建议，例如：MADV_NORMAL、MADV_RANDOM、MADV_SEQUENTIAL、MADV_WILLNEED、MADV_DONTNEED 等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mprotect：设置内存区域的保护情况，例如：PROT_NONE、PROT_READ、PROT_WRITE、PROT_EXEC、PROT_SEM、PROT_SAO、PROT_GROWSUP、PROT_GROWSDOWN 等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sysctl：在内核运行时动态地修改内核的运行参数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在此比较可疑的是 &lt;code&gt;mmap&lt;/code&gt; 方法，它在 &lt;code&gt;dtruss&lt;/code&gt; 的最终统计中一共调用了 10 余次，我们可以相信它在 Go Runtime 的时候进行了大量的虚拟内存申请。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再接着往下看，看看到底是在什么阶段进行了虚拟内存空间的申请。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：若是 Linux 系统，可使用 &lt;code&gt;strace&lt;/code&gt; 命令。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查看 Go Runtime&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;启动流程&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述的分析，我们可以知道在 Go 程序启动的时候 VSZ 就已经不低了，并且确定不是共享库等的原因，且程序在启动时系统调用确实存在 &lt;code&gt;mmap&lt;/code&gt; 等方法的调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们可以充分怀疑 Go 在初始化阶段就保留了该内存空间。那我们第一步要做的就是查看一下 Go 的引导启动流程，看看是在哪里申请的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引导过程如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;graph TD&lt;br/&gt;A(rt0_darwin_amd64.s:8&amp;lt;br/&amp;gt;_rt0_amd64_darwin) --&amp;gt;|JMP| B(asm_amd64.s:15&amp;lt;br/&amp;gt;_rt0_amd64)&lt;br/&gt;B --&amp;gt; |JMP|C(asm_amd64.s:87&amp;lt;br/&amp;gt;runtime-rt0_go)&lt;br/&gt;C --&amp;gt; D(runtime1.go:60&amp;lt;br/&amp;gt;runtime-args)&lt;br/&gt;D --&amp;gt; E(os_darwin.go:50&amp;lt;br/&amp;gt;runtime-osinit)&lt;br/&gt;E --&amp;gt; F(proc.go:472&amp;lt;br/&amp;gt;runtime-schedinit)&lt;br/&gt;F --&amp;gt; G(proc.go:3236&amp;lt;br/&amp;gt;runtime-newproc)&lt;br/&gt;G --&amp;gt; H(proc.go:1170&amp;lt;br/&amp;gt;runtime-mstart)&lt;br/&gt;H --&amp;gt; I(在新创建的 p 和 m 上运行 runtime-main)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;runtime-osinit：获取 CPU 核心数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime-schedinit：初始化程序运行环境（包括栈、内存分配器、垃圾回收、P等）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime-newproc：创建一个新的 G 和 绑定 runtime.main。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime-mstart：启动线程 M。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：来自@曹大的 《Go 程序的启动流程》和@全成的 《Go 程序是怎样跑起来的》，推荐大家阅读。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;初始化运行环境&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，我们要研究的是 runtime 里的 &lt;code&gt;schedinit&lt;/code&gt; 方法，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;&lt;span&gt;schedinit&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; ...&lt;br/&gt; stackinit()&lt;br/&gt; mallocinit()&lt;br/&gt; mcommoninit(_g_.m)&lt;br/&gt; cpuinit()       // must run before alginit&lt;br/&gt; alginit()       // maps must not be used before this call&lt;br/&gt; modulesinit()   // provides activeModules&lt;br/&gt; typelinksinit() // uses maps, activeModules&lt;br/&gt; itabsinit()     // uses activeModules&lt;br/&gt;&lt;br/&gt; msigsave(_g_.m)&lt;br/&gt; initSigmask = _g_.m.sigmask&lt;br/&gt;&lt;br/&gt; goargs()&lt;br/&gt; goenvs()&lt;br/&gt; parsedebugvars()&lt;br/&gt; gcinit()&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从用途来看，非常明显， &lt;code&gt;mallocinit&lt;/code&gt; 方法会进行内存分配器的初始化，我们继续往下看。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;初始化内存分配器&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;mallocinit&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们正式的分析一下 &lt;code&gt;mallocinit&lt;/code&gt; 方法，在引导流程中， &lt;code&gt;mallocinit&lt;/code&gt; 主要承担 Go 程序的内存分配器的初始化动作，而今天主要是针对虚拟内存地址这块进行拆解，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;&lt;span&gt;mallocinit&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; sys.PtrSize == 8 {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := 0x7f; i &amp;gt;= 0; i-- {&lt;br/&gt;   var p uintptr&lt;br/&gt;   switch {&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; GOARCH == &lt;span&gt;&quot;arm64&quot;&lt;/span&gt; &amp;amp;&amp;amp; GOOS == &lt;span&gt;&quot;darwin&quot;&lt;/span&gt;:&lt;br/&gt;    p = uintptr(i)&amp;lt;&amp;lt;40 | uintptrMask&amp;amp;(0x0013&amp;lt;&amp;lt;28)&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; GOARCH == &lt;span&gt;&quot;arm64&quot;&lt;/span&gt;:&lt;br/&gt;    p = uintptr(i)&amp;lt;&amp;lt;40 | uintptrMask&amp;amp;(0x0040&amp;lt;&amp;lt;32)&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; GOOS == &lt;span&gt;&quot;aix&quot;&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; i == 0 {&lt;br/&gt;     &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    p = uintptr(i)&amp;lt;&amp;lt;40 | uintptrMask&amp;amp;(0xa0&amp;lt;&amp;lt;52)&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; raceenabled:&lt;br/&gt;    ...&lt;br/&gt;   default:&lt;br/&gt;    p = uintptr(i)&amp;lt;&amp;lt;40 | uintptrMask&amp;amp;(0x00c0&amp;lt;&amp;lt;32)&lt;br/&gt;   }&lt;br/&gt;   hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())&lt;br/&gt;   hint.addr = p&lt;br/&gt;   hint.next, mheap_.arenaHints = mheap_.arenaHints, hint&lt;br/&gt;  }&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      ...&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判断当前是 64 位还是 32 位的系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 0x7fc000000000~0x1c000000000 开始设置保留地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断当前 &lt;code&gt;GOARCH&lt;/code&gt;、&lt;code&gt;GOOS&lt;/code&gt; 或是否开启了竞态检查，根据不同的情况申请不同大小的连续内存地址，而这里的 &lt;code&gt;p&lt;/code&gt; 是即将要要申请的连续内存地址的开始地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保存刚刚计算的 arena 的信息到 &lt;code&gt;arenaHint&lt;/code&gt; 中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能会有小伙伴问，为什么要判断是 32 位还是 64 位的系统，这是因为不同位数的虚拟内存的寻址范围是不同的，因此要进行区分，否则会出现高位的虚拟内存映射问题。而在申请保留空间时，我们会经常提到 &lt;code&gt;arenaHint&lt;/code&gt; 结构体，它是 &lt;code&gt;arenaHints&lt;/code&gt;链表里的一个节点，结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; arenaHint struct {&lt;br/&gt; addr uintptr&lt;br/&gt; down bool&lt;br/&gt; next *arenaHint&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;addr：&lt;code&gt;arena&lt;/code&gt; 的起始地址&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;down：是否最后一个 &lt;code&gt;arena&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;next：下一个 &lt;code&gt;arenaHint&lt;/code&gt; 的指针地址&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这里疯狂提到的 &lt;code&gt;arena&lt;/code&gt; 又是什么东西呢，这其实是 Go 的内存管理中的概念，Go Runtime 会把申请的虚拟内存分为三个大块，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5018587360594795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4htibhubl5wtrrJqdexvxTbXdphQOjjGxD6m2JyDrpwMvZwRRGbouDkoZtgDc6siaR3ee3bS7eYcQNQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1614&quot;/&gt;&lt;figcaption&gt;image&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;spans：记录 arena 区域页号和 mspan 的映射关系。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bitmap：标识 arena 的使用情况，在功能上来讲，会用于标识 arena 的哪些空间地址已经保存了对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;arean：arean 其实就是 Go 的堆区，是由 mheap 进行管理的，它的 MaxMem 是 512GB-1。而在功能上来讲，Go 会在初始化的时候申请一段连续的虚拟内存空间地址到 arean 保留下来，在真正需要申请堆上的空间时再从 arean 中取出来处理，这时候就会转变为物理内存了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里的话，你需要理解 arean 区域在 Go 内存里的作用就可以了。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;mmap&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们刚刚通过上述的分析，已经知道 &lt;code&gt;mallocinit&lt;/code&gt; 的用途了，但是你可能还是会有疑惑，就是我们之前所看到的 &lt;code&gt;mmap&lt;/code&gt; 系统调用，和它又有什么关系呢，怎么就关联到一起了，接下来我们先一起来看看更下层的代码，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func sysAlloc(n uintptr, sysStat *uint64) unsafe.Pointer {&lt;br/&gt; p, err := mmap(nil, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0)&lt;br/&gt; ...&lt;br/&gt; mSysStatInc(sysStat, n)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; p&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func sysReserve(v unsafe.Pointer, n uintptr) unsafe.Pointer {&lt;br/&gt; p, err := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, -1, 0)&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func sysMap(v unsafe.Pointer, n uintptr, sysStat *uint64) {&lt;br/&gt; ...&lt;br/&gt; munmap(v, n)&lt;br/&gt; p, err := mmap(v, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE, -1, 0)&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go Runtime 中存在着一系列的系统级内存调用方法，本文涉及的主要如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;sysAlloc：从 OS 系统上申请清零后的内存空间，调用参数是 &lt;code&gt;_PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE&lt;/code&gt;，得到的结果需进行内存对齐。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sysReserve：从 OS 系统中保留内存的地址空间，这时候还没有分配物理内存，调用参数是 &lt;code&gt;_PROT_NONE, _MAP_ANON|_MAP_PRIVATE&lt;/code&gt;，得到的结果需进行内存对齐。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sysMap：通知 OS 系统我们要使用已经保留了的内存空间，调用参数是 &lt;code&gt;_PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上去好像很有道理的样子，但是 &lt;code&gt;mallocinit&lt;/code&gt; 方法在初始化时，到底是在哪里涉及了 &lt;code&gt;mmap&lt;/code&gt; 方法呢，表面看不出来，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; i := 0x7f; i &amp;gt;= 0; i-- {&lt;br/&gt; ...&lt;br/&gt; hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())&lt;br/&gt; hint.addr = p&lt;br/&gt; hint.next, mheap_.arenaHints = mheap_.arenaHints, hint&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上在调用 &lt;code&gt;mheap_.arenaHintAlloc.alloc()&lt;/code&gt; 时，调用的是 &lt;code&gt;mheap&lt;/code&gt;  下的 &lt;code&gt;sysAlloc&lt;/code&gt; 方法，而 &lt;code&gt;sysAlloc&lt;/code&gt; 又会与 &lt;code&gt;mmap&lt;/code&gt; 方法产生调用关系，并且这个方法与常规的 &lt;code&gt;sysAlloc&lt;/code&gt; 还不大一样，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var mheap_ mheap&lt;br/&gt;...&lt;br/&gt;func (h *mheap) sysAlloc(n uintptr) (v unsafe.Pointer, size uintptr) {&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; h.arenaHints != nil {&lt;br/&gt;  hint := h.arenaHints&lt;br/&gt;  p := hint.addr&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; hint.down {&lt;br/&gt;   p -= n&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; p+n &amp;lt; p {&lt;br/&gt;   v = nil&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; arenaIndex(p+n-1) &amp;gt;= 1&amp;lt;&amp;lt;arenaBits {&lt;br/&gt;   v = nil&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   v = sysReserve(unsafe.Pointer(p), n)&lt;br/&gt;  }&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以惊喜的发现 &lt;code&gt;mheap.sysAlloc&lt;/code&gt; 里其实有调用 &lt;code&gt;sysReserve&lt;/code&gt; 方法，而 &lt;code&gt;sysReserve&lt;/code&gt; 方法又正正是从 OS 系统中保留内存的地址空间的特定方法，是不是很惊喜，一切似乎都串起来了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本节中，我们先写了一个测试程序，然后根据非常规的排查思路进行了一步步的跟踪怀疑，整体流程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;top&lt;/code&gt; 或 &lt;code&gt;ps&lt;/code&gt; 等命令，查看进程运行情况，分析基础指标。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;pprof&lt;/code&gt; 或 &lt;code&gt;runtime.MemStats&lt;/code&gt; 等工具链查看应用运行情况，分析应用层面是否有泄露或者哪儿高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;vmmap&lt;/code&gt; 命令，查看进程的内存映射情况，分析是不是进程虚拟空间内的某个区域比较高，例如：共享库等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;dtruss&lt;/code&gt; 命令，查看程序的系统调用情况，分析可能出现的一些特殊行为，例如：在分析中我们发现  &lt;code&gt;mmap&lt;/code&gt; 方法调用的比例是比较高的，那我们有充分的理由怀疑 Go 在启动时就进行了大量的内存空间保留。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过上述的分析，确定可能是在哪个环节申请了那么多的内存空间后，再到 Go Runtime 中去做进一步的源码分析，因为源码面前，了无秘密，没必要靠猜。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结论上而言，VSZ（进程虚拟内存大小）与共享库等没有太大的关系，主要与 Go Runtime 存在直接关联，也就是在前图中表示的运行时堆（malloc）。转换到 Go Runtime 里，就是在 &lt;code&gt;mallocinit&lt;/code&gt;  这个内存分配器的初始化阶段里进行了一定量的虚拟空间的保留。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而保留虚拟内存空间时，受什么影响，又是一个哲学问题。从源码上来看，主要如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;受不同的 OS 系统架构（GOARCH/GOOS）和位数（32/64 位）的影响。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;受内存对齐的影响，计算回来的内存空间大小是需要经过对齐才会进行保留。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过一步步地分析，讲解了 Go 会在哪里，又会受什么因素，去调用了什么方法保留了那么多的虚拟内存空间，但是我们肯定会忧心进程虚拟内存（VSZ）高，会不会存在问题呢，我分析如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;VSZ 并不意味着你真正使用了那些物理内存，因此是不需要担心的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;VSZ 并不会给 GC 带来压力，GC 管理的是进程实际使用的物理内存，而 VSZ 在你实际使用它之前，它并没有过多的代价。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;VSZ 基本都是不可访问的内存映射，也就是它并没有内存的访问权限（不允许读、写和执行）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;思考&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里舒一口气，因为 Go VSZ 的高，并不会对我们产生什么非常实质性的问题，但是又仔细一想，为什么 Go 要申请那么多的虚拟内存呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总体考虑如下：&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Go 的设计是考虑到 &lt;code&gt;arena&lt;/code&gt; 和  &lt;code&gt;bitmap&lt;/code&gt; 的后续使用，先提早保留了整个内存地址空间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Go Runtime 和应用的逐步使用，肯定也会开始实际的申请和使用内存，这时候 &lt;code&gt;arena&lt;/code&gt; 和 &lt;code&gt;bitmap&lt;/code&gt; 的内存分配器就只需要将事先申请好的内存地址空间保留更改为实际可用的物理内存就好了，这样子可以极大的提高效能。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;High virtual memory allocation by golang&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GO MEMORY MANAGEMENT&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GoBigVirtualSize&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GoProgramMemoryUse&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;曹大的 Go 程序的启动流程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全成大佬的 Go 程序是怎样跑起来的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;欧神的 go-under-the-hood&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>91e7a13707e627392261990e7be27daf</guid>
<title>资料 | ThoughtWorks 技术雷达第 23 期.pdf</title>
<link>https://toutiao.io/k/7mdyut5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>182248dbec16d336002e5936f5064c52</guid>
<title>博客十年</title>
<link>https://toutiao.io/k/nxy0gra</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot;&gt;
      &lt;p&gt;是的，我的个人博客今天迎来了第 10 个年头。今天碎碎念一篇这 10 年对我有很深影响的人和事情，以及感想。&lt;/p&gt;
&lt;h3 id=&quot;感谢带我入行的悦秋&quot;&gt;感谢带我入行的悦秋&lt;/h3&gt;
&lt;p&gt;我一开始是以网络工程师的身份进入职场的，清晰记得当时面试时运维经理悦秋问我的那些运维问题一个都回答不出来，印象最深的一个问题是「了解 CentOS 么？」只用过 RHEL 的我一脸懵逼。我想能通过面试是因为我非计算机专业的背景却独身一人来北京闯的那种拼劲和对知识的渴求吧。&lt;/p&gt;
&lt;p&gt;记得有一天和悦秋闲聊，悦秋给我展示了他的技术博客，拥有一个自己的博客在当时对我来说既神秘又向往，我就缠着悦秋教我怎么搞。从买域名、租主机到部署博客程序、配置 DNS，现在看来这些都太简单不过了，可是对于当时的我来说学到了很多知识。&lt;/p&gt;
&lt;h3 id=&quot;第一篇博客&quot;&gt;第一篇博客&lt;/h3&gt;
&lt;p&gt;无论是开发者还是运维，想必在职业生涯中都犯过错误。相信很多人都怕在试用期犯错，而我犯了个当时惊出我们组所有人一身冷汗的事故。&lt;/p&gt;
&lt;p&gt;我们接手了前面运维的工作，悦秋给我安排了一个修改全部服务器日常用户账号密码的任务。我忘了当时怎么操作了，密码改错了，所有人都登不上这个账号且没人知道 root 密码，当时只有我有一个终端还没有退出登录，但是已经不能 sudo 了。&lt;/p&gt;
&lt;p&gt;讲一点背景，当时运维是做日常维护，除此之外开发部门也有上线权限，当我发现密码出现问题赶紧和悦秋汇报，悦秋很镇定，在确定确实找不回来了后和我说 CentOS5 有一个通过 Gcc++ 漏洞普通用户获得 root 权限的问题我们还没有打补丁，让我网上找方法试试拿到 root 权限改密码。有大神指点，我很快 Google 到方法，试了下确实可以，就这样有惊无险在没人知道的情况下把密码改回来了。^_^&lt;/p&gt;
&lt;p&gt;现在说起来很轻松，但是当时对我可以说是差点被开除，现在想想很后怕：如果此时恰好出现个严重 BUG 需要上线...&lt;/p&gt;
&lt;p&gt;在悦秋的鼓励下，写了第一篇博客 &lt;a href=&quot;https://old.dongwm.com/old/archives/linux-gcc%E6%BC%8F%E6%B4%9E%EF%BC%9A%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E8%8E%B7%E5%BE%97root%E6%9D%83%E9%99%90/&quot;&gt;《Linux Gcc++ 漏洞：普通用户获得 root 权限》&lt;/a&gt; (这篇文章由于年久失修代码段格式已经混乱了)。它的发表时间是 2010 年 11 月 1 日，我说的博客十年就是按这个日期开始算的。&lt;/p&gt;
&lt;p&gt;从那个时刻开始，我把个人博客定位在一个存放笔记的地方，把工作和个人学习过程中一些觉得重要的、有价值的内容记录下来，方便日后能随时翻到，当时并没想着惠及他人或者出名之类的。&lt;/p&gt;
&lt;h3 id=&quot;追忆&quot;&gt;追忆&lt;/h3&gt;
&lt;p&gt;翻了翻过去写的内容，一转眼已经 328 篇，可以感受到文笔从稚嫩到成熟再到有自己的理解和风格。我的学习经历比较曲折：做过运维，学过 Ruby、Perl、Go 等语言以及前端的各种知识，刚开始工作走了很多弯路，无基础，无人指导，像没头苍蝇那样乱学一通。虽然人生的每一段经历都是有意义的，但现在回头想想，实在是浪费了太多不必要的时间，直到这几年才渐渐的才摸索出属于自己的方向。&lt;/p&gt;
&lt;p&gt;现在入行的朋友们已经非常幸福了，网络上资源非常多，大多数遇到的问题也能很容易地从网上找到答案或者思路，但不可否认的是，资源太分散，而且绝大多数文章都是浅尝辄止，千篇一律，想找到一些出众的、优秀的、比较原理性的文章真的没那么容易。&lt;/p&gt;
&lt;p&gt;虽然不同的文章会对应各个阶段的读者，对不同的人也有不同的帮助。但是我一直在试着写一些系列的、完整的、稍有深入的内容，并且未来也会这样。&lt;/p&gt;
&lt;p&gt;能有自己的理解和风格，需要付出很多的精力和时间，现在想想还能记起很多美好的事情。例如在早期学习 Linux 命令时我把所有系统里面存在的命令全部找出来，挨个查它是做什么的，都可以加什么参数实现什么作用。另外也会从同事那里了解一些有意思的玩法，我那会经常 attach 到同事的 tmux 会话里看他们怎么操作，‘偷师’成绩斐然。学习 Python 时也是这么个习惯，挨个查 Python 标准库是做什么的怎么用，这个很有价值，对于我 Python 的快速提高极其有帮助。我写的关于 Puppet、Nagios、Icinga、Gentoo、AWK/Sed、Celery、IPython、Python 并发编程、Asyncio 等等内容收到了很多网友从各种途径的反馈，这对我是很大的鼓励，能帮到别人非常有成就感，也非常开心。&lt;/p&gt;
&lt;h3 id=&quot;那些记忆深刻的博客和ID&quot;&gt;那些记忆深刻的博客和 ID&lt;/h3&gt;
&lt;p&gt;我赶上了最好的时代，也错过了最好的时代。怀念那个博客盛行的时代有太多闪亮的 ID 了。如果你在华蟒邮件组 (CPyUG) 里，你能见到非常多知名的 ID，在 14 年之前讨论很热烈，之后渐渐的消沉直到陷入长期的静默。而我有幸在豆瓣里也经历了这样的过程：我入职时洪教授和清风老师还在，翻代码版本库可以 blame 到各个大神的 ID，但是每个人都选择在正确、合适的时间离开了。豆瓣的那些开发者 ID 我就不提了，就写几个在互联网上印象最深的独立博客和 ID 吧。&lt;/p&gt;
&lt;h4 id=&quot;simple-is-better.com&quot;&gt;simple-is-better.com&lt;/h4&gt;
&lt;p&gt;这个网站到现在也不知道主人是谁，很神秘。我开始学习 Python 就关注了它，从里面看过有很多有价值的文章，后来还很忐忑的把自己的博客链接加在了它的「酷站导航」列表中。这个网站现在已经不可以访问，就像是突然消失，甚至像是从来没有出现过。&lt;/p&gt;
&lt;h4 id=&quot;laoqiu&quot;&gt;laoqiu&lt;/h4&gt;
&lt;p&gt;我刚开始学习 Python 时就看过他的技术博客。那个时候用 Flask 框架自己搞个博客是个很酷的事情 ，在之后我学习 Tornado 时还看到他基于 &lt;a href=&quot;https://github.com/laoqiu/pypress&quot;&gt;pypress&lt;/a&gt; 搞了一个 Tornado 版本的博客，一直走在我前面。这个人很神秘 ，等我能用 Python 写 Web 时他的博客已经不能访问，我之后一直关注他，但是他好像已经不在这一行了 。&lt;/p&gt;
&lt;h4 id=&quot;gashero&quot;&gt;gashero&lt;/h4&gt;
&lt;p&gt;这个 ID 想必大家很熟，不过大家可能只知道他是知乎大 V 刘老师，不知道他在 Python 领域里面做过什么，有兴趣的可以看看他的 &lt;a href=&quot;http://gashero.net/resume.html&quot;&gt;简历&lt;/a&gt; ，我一开始了解和学习 Twisted、SQLAlchemy 都是看他写的系列文章，真大佬。&lt;/p&gt;
&lt;h4 id=&quot;lepture&quot;&gt;lepture&lt;/h4&gt;
&lt;p&gt;很有名的 ID 了，如果你做过 Python Web 开发应该听过他的名字。他写了很多 Flask 插件 ，我的博客程序也用到了他写的 mistune 和 github-cards。不过遗憾的是他已经退出 Python 社区开发很久了，可以说他写 Flask 时我还不会，他不写很久以后我才开始做 Web 开发。&lt;/p&gt;
&lt;h3 id=&quot;博客程序历史&quot;&gt;博客程序历史&lt;/h3&gt;
&lt;p&gt;一开始用的是 Wordpress 和吴钊 (mg12) 的 iNove 主题，这个双栏主题当时很有名，曾经长期位于 WP 官方主题目录榜首。&lt;/p&gt;
&lt;p&gt;但是作为了 Python 开发者用一个 PHP 写的博客总觉得不好，后来紧跟潮流改用了 Jekyll：写 Markdown 语法的文章，它会自动帮你生成静态网站页面文件。使用 Jekyll 的时间比较短，而且比较早已经不记得用了什么主题了。不过当时没有一个好的 Wordpress 转 Markdown 文件的工具，所以我的早期文章转化后的格式是有问题的，上面提的类似第一篇文章的代码段格式问题就是这么来的。&lt;/p&gt;
&lt;p&gt;Jekyll 是 Ruby 写的，虽然我当时会一点 Ruby，但是上手不易且容易出现问题，很快就换成了基于它的 Octopress (现在我的 &lt;a href=&quot;https://old.dongwm.com/&quot;&gt;老博客&lt;/a&gt; 还是可以访问的)，这个时期我正好也在学前端知识，所以定制了一些内容包括用了一个自己写的豆瓣收藏秀的插件，可以说倒腾自己的博客是我实践我的前端知识的第一站。&lt;/p&gt;
&lt;p&gt;这里解释下，一直没选择 Python 世界里面的静态网站生成器 (例如 Pelican) 主要是没有满意的主题。而我一直也有个遗憾，就是没有用我 Web 开发的知识写个博客产品。&lt;/p&gt;
&lt;p&gt;说到这里偏个题，我以前面试别人或者看别人个人技术博客时，如果我发现对方用的博客应用是自己写的加分，用 Python 写的超加分，用静态网站生成器不减分，用 PHP 或者其他语言编写的应用时会减分：这是一种「&lt;strong&gt;技术信仰&lt;/strong&gt;」。终于借着机会在 19 年中用上了我自己写的博客应用 &lt;a href=&quot;https://github.com/dongweiming/lyanna&quot;&gt;Lyanna&lt;/a&gt; ，嗯，效果就是你现在访问的这样，觉得总算对得起自己的工作内容了，省的被嘲讽一个 Python Web 开发用着 Ruby 写的静态网站生成器 (其实并没人这么说过)。&lt;/p&gt;
&lt;h3 id=&quot;为什么写博客的越来越少？&quot;&gt;为什么写博客的越来越少？&lt;/h3&gt;
&lt;p&gt;和我同时代写技术博客的，现在几乎都已经停更了，即便现在还在更新的我也是很久一篇，而且渐渐的不怎么写技术性内容了。原来在我订阅列表里的绝大部分觉得写的很好、内容很有价值的国内外技术博客都停更甚至不再可以访问，其实挺可惜的。&lt;/p&gt;
&lt;p&gt;那么为什么大家不再写或者不愿意写了？&lt;/p&gt;
&lt;h4 id=&quot;有更重要的事情&quot;&gt;有更重要的事情&lt;/h4&gt;
&lt;p&gt;我认识的大部分博主都是在职场早期博客写的很勤快，一方面是求知欲相对更强，一方面一个有价值的技术博客是一份很好的简历，对于找工作确实能起到一些作用。不过随着技术的提升，大家有了非常多的方向：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt; 进入管理岗。我想大部分能写好技术博客的同学一开始也没想着去做管理，但是老人走了，能力又突出就顺理成章升职啦。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; 肩负更重更高的职责。在工作中已经证明了自己的实力，甚至在业界也被认可了，写不写博客已经不重要。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; 转行 / 创业。已经不碰代码了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; 带娃。很多我认识的博主都已经有了自己的家庭，有了孩子。我反正是非常羡慕公司的单身同事的，结婚后要花很多时间精力维护各种关系，而且带娃写作业比写博客可累多了，现在我已经很少能专心花个半天或者更长时间去专研点什么，更多的是碎片时间，也许正专心的思考什么时候就会被各种事情打断。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们每个人都要上班，这是一种习惯，但没人热爱上班。写博客这件事其实写着写着熟悉了就无趣了，很少有人热爱分享和写作。博客可以不写，但是班能不上嘛？写博客在后来的日子里会慢慢变得更力不从心，把有限的精力用来做更有价值的事情是成年人应该的选择。初入职场工资低娱乐少，写写博客充实也会很开心，但是慢慢地随着工资和见识增涨，会发现快乐的事情其实还有很多...O (∩_∩) O 再花那么多时间和精力写博客就没意思了。&lt;/p&gt;
&lt;h4 id=&quot;没有能力持续产出&quot;&gt;没有能力持续产出&lt;/h4&gt;
&lt;p&gt;职场一开始有非常多技术和非技术的技能要学习和理解，但是融入之后自己不求上进的话很容易温水煮青蛙。其实我们每个人只是公司产品线上的一颗螺丝钉罢了，在业务里我们并没有那么重要，对很多人来说只是负责其中一小部分，这部分可能你是专家，但是其他的部分基本上都只能算熟悉，写不了什么高质量文章：这也是很多人不写书或者写不了书的原因。就拿我说，知乎上我可能花半个小时就能写一篇上百赞的回答，但是写技术文章，别说日更，我都不敢说持续的每周能写 1-2 篇。&lt;/p&gt;
&lt;p&gt;哎，越学习越觉得懂得太少，知识深度和广度有限。&lt;/p&gt;
&lt;h4 id=&quot;收不到正反馈&quot;&gt;收不到正反馈&lt;/h4&gt;
&lt;blockquote&gt;&lt;p&gt; 写作和健身很像 ，是一个长期的、过程中效果不明显的工程。在这个碎片化的时代，踏实的好好写作很难收到正反馈 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在有非常多的渠道的方式分享你的知识和经验，甚至还能从其中获得实际的收益。写技术博客是其中最孤独、最不容易获得反馈的方式。其他的如微信公众号、知乎专栏和 Github 等等，无论那种都比自建博客开发和资源成本低，现在大部分人都喜欢快餐式的获得知识收获关注，不愿意从折腾中获得乐趣，看后就走，就好像点个赞、加个收藏就已经学会了。我能理解一个新人花了很长时间写完一篇自我感觉不错的文章充满期待的发出去，结果只有个位数的阅读量，无人点赞无人评论，这样很容易放弃掉。&lt;/p&gt;
&lt;p&gt;真正的技术人大部分不愿意「营销」自己，我这里说的营销不是贬义，是指写完文章主动推广给别人知道你写了它，要不然如果不是通过一些特殊的关键词搜索基本它就会被现在每日大量的信息垃圾淹没了。&lt;/p&gt;
&lt;p&gt;另外一个点是转载 / 搬运成风。原创的高质量文章永远是很稀缺的，搜索引擎先搜到的可能是那些专门搬运和转载的人的内容：因为他们总是在刷爆款文垃圾文，访问量高，权重很高。&lt;/p&gt;
&lt;p&gt;大家都没时间或者说不愿意静下心来学习和总结。各种碎片时间都用在了微信、知乎、短视频 (如抖音等) 这些平台了。所以越来越多的人丧失了独立思考的能力，很少有人静下心来写点有思考有深度的东西，也很少有人愿意静下心来读一些这样的文字。过去有独立的博客很自豪，通过网络可以找到同样喜欢某种技术或者某个东西的朋友，我们会交流观点分享经验，即便从未线下见过，也是心照不宣，这激励了我持续学习和思考。我能从脑海和 Google Reader 里面能找到一大堆有价值的博客甚至具体的文章，当年那些知名 Python 博客我能如数家珍，能快速的想到某个博主曾经写过某篇 (些) 文章介绍某个知识点或者解决某个问题的方案以及思路。而现在好的独立博客已经凤毛麟角，Python 领域我已经很长时间没有看到新鲜的内容和博主了；知乎直接沦陷成小白和割韭菜党；微信公众号头部大 V 们都是纯自媒体自己 Python 写的一坨屎，还日常贩卖焦虑，标题党，有一堆小白捧臭脚，真的看得我很尴尬，唉。&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;blockquote&gt;&lt;p&gt; 我还是从前那个少年，没有一丝丝改变，时间只不过是考验，种在心中信念丝毫未减 - 《少年》歌词 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;十年很长，十年很短。写博客并不难，难的是坚持。我可能是一个愿意分享的人一直坚持到现在，但当我不再热血不再年轻的时候，我发现自己的精力并不是我想的那般充沛，生活并不是我想的那么美好，太多的事情要做，所以未来更新博客不会再如从前，但是如果我那天停更了，我会写最后一篇告诉大家不必再等。&lt;/p&gt;
&lt;p&gt;最后再次欢迎各位光临我的博客，更希望我的文章能对各位有所帮助。&lt;/p&gt;

    &lt;/div&gt;

  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>760abac844d1ba78b385dfca2d50b53e</guid>
<title>想自学 Maven？推荐 Maven 极简高速入门及常规使用</title>
<link>https://toutiao.io/k/7q3wfwb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.22260869565217392&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gDHRjEowjKQMYibiaKeHYSvicqcPfHnAwYpnTo6pOJiaGjibkf6kJ31Hll3h46EANcStccScvMOaMmp6mh4VY3CmdRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;575&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;公众号[JavaQ]原创，专注分享Java基础原理分析、实战技术、微服务架构、分布式系统构建，诚邀点赞关注！&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;前言&lt;/h3&gt;&lt;p&gt;笔者的工作经历中使用过Ant、Maven和Gradle，如果让笔者选择，笔者会首选Gradle。那为什么还要写Maven这篇内容呢？时下大部分公司都还在使用Maven，并且很多开源项目也在使用Maven，Maven有一些功能特性还是很不错的，很值得做总结记录。&lt;/p&gt;&lt;h3&gt;Maven是什么&lt;/h3&gt;&lt;p&gt;Maven是Apache旗下的一个纯Java开发的开源项目，是一个用于构建和管理任何基于Java的项目的工具。&lt;/p&gt;&lt;h3&gt;为什么要使用Maven&lt;/h3&gt;&lt;p&gt;使用Maven轻松实现项目jar包依赖管理、子模块管理、构建jar/war包、管理jar/war包、执行单元/集成测试、执行代码分析/代码质量检查等等，开箱即用让开发者无需花更多的时间。&lt;/p&gt;&lt;h3&gt;Maven安装&lt;/h3&gt;&lt;p&gt;安装Maven之前，需要确保安装了JDK，Maven3.3+版本需要安装JDK 1.7或更高版本。Apache Maven 3.6.3是当前推荐安装的最新版本，推荐使用国内镜像地址下载(https://mirrors.tuna.tsinghua.edu.cn/apache/)。&lt;/p&gt;&lt;h4&gt;Windows系统安装及设置&lt;/h4&gt;&lt;p&gt;下载地址：https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3094274146905726&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKQMYibiaKeHYSvicqcPfHnAwYp0icpTKxuFxPsKJ2hJRQHDPOCT2bL240lXsb91zIjKpfs5LazBUOKuicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1729&quot;/&gt;&lt;/p&gt;&lt;p&gt;windows操作系统下载apache-maven-3.6.3-bin.zip，解压压缩包到硬盘的某个路径，例如：D：\Maven\apache-maven-3.6.3，右键&quot;计算机&quot;(或我的电脑)，选择&quot;属性&quot;，点击&quot;高级系统设置&quot;，点击&quot;环境变量&quot;，新建系统变量 MAVEN_HOME，变量值为D：\Maven\apache-maven-3.6.3，编辑系统变量Path，在变量值得末尾加上;%MAVEN_HOME%\bin，保存如上修改退出。&lt;/p&gt;&lt;p&gt;打开命令行窗口(快捷键win+r，输入cmd回车)，输入mvn –v回车，如果正常输出Maven版本号则安装及配置完成，否则安装上述步骤检查。&lt;/p&gt;&lt;h4&gt;Linux系统安装及设置&lt;/h4&gt;&lt;p&gt;Linux系统下载apache-maven-3.6.3-bin.tar.gz，通过如下命令行操作下载及解压，例如解压到/usr/local/路径：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;wget https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;tar -xvf apache-maven-3.6.3-bin.tar.gz&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo mv -f apache-maven-3.6.3/usr/local/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;使用如下命令行操作打开/etc/profile：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo vim /etc/profile&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;在文件末尾添加如下配置：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;export MAVEN_HOME=/usr/local/apache-maven-3.6.3&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;export PATH=${PATH}:${MAVEN_HOME}/bin&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;退出编辑并保存，运行如下命令使配置的环境变量生效：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;source /etc/profile&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;在命令行窗口输入mvn –v命令检查安装及设置是否完成，如果正常输出Maven版本号则安装及配置完成，否则安装上述步骤检查。&lt;/p&gt;&lt;h4&gt;Mac系统安装及设置&lt;/h4&gt;&lt;p&gt;Mac系统下载apache-maven-3.6.3-bin.tar.gz，通过如下命令行操作下载及解压，例如解压到/usr/local/路径：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;curl -O https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;tar -xvf apache-maven-3.6.3-bin.tar.gz&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo mv -f apache-maven-3.6.3/usr/local/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;使用如下命令行操作打开/etc/profile：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo vim /etc/profile&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;在文件末尾添加如下配置：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;export MAVEN_HOME=/usr/local/apache-maven-3.6.3&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;export PATH=${PATH}:${MAVEN_HOME}/bin&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;退出编辑并保存，运行如下命令使配置的环境变量生效：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;source /etc/profile&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;在命令行窗口输入mvn –v命令检查安装及设置是否完成，如果正常输出Maven版本号则安装及配置完成，否则安装上述步骤检查。&lt;/p&gt;&lt;h3&gt;如何使用Maven&lt;/h3&gt;&lt;p&gt;Maven是一个庞大的项目，有很全面的管理功能，本篇内容只记录开发者日常使用频率比较高的部分功能。&lt;/p&gt;&lt;h3&gt;设置Maven仓库&lt;/h3&gt;&lt;p&gt;Maven仓库就是一个位置，用于存储项目中的依赖，这个依赖可以是jar、war、zip、pom等。&lt;/p&gt;&lt;p&gt;Maven仓库有三种类型：本地仓库、中央仓库和远程仓库。当执行Maven构建命令查找项目依赖时，首先从本地仓库搜索，如果本地仓库找不到，再从中央仓库搜索，如果中央仓库也找不到，又配置过远程仓库，那么再从远程仓库搜索。&lt;/p&gt;&lt;p&gt;本地仓库是计算机本机硬盘上的某个路径，这个路径在安装Maven后不会马上创建，它在第一次运行Maven命令的时候才被创建。默认情况下，本地仓库被创建后，这个路径是用户目录下.m2/repository/，例如Windows系统是C:\Users\admin.m2\repository，Linux系统是/home/admin/.m2/repository/，Mac系统是/Users/wxq/.m2/repository/。如果要修改本地仓库的位置，更改Maven解压后目录下conf中的settings.xml文件，找到localRepository标签，将其值设置为想要的本地路径，例如：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!-- localRepository&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;|The path to the local repository maven will use to store artifacts.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;|&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;|Default: ${user.home}/.m2/repository&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;localRepository&amp;gt;D:/LocalRepository&amp;lt;/localRepository&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/settings&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;中央仓库是由Maven社区提供的仓库，其中包含了绝大多数流行的开源Java依赖。这个仓库不需要配置，只要有网络就可以直接使用。如果你想确认一下某依赖在中央仓库中是否真的存在，可以在http://search.maven.org/#browse搜索。使用中央仓库下载依赖可能会很慢，所以需要配置一个国内的镜像地址来代替原中央仓库的默认地址，推荐使用阿里云的镜像地址。打开Maven解压后目录下conf中的settings.xml文件，在mirrors标签中添加如下镜像配置即可。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;mirror&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　 &amp;lt;id&amp;gt;alimaven&amp;lt;/id&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　 &amp;lt;name&amp;gt;aliyun maven&amp;lt;/name&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　 &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public/&amp;lt;/url&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　 &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/mirror&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;远程仓库是开发人员自己定制的仓库，用于存放不想被公开的私有依赖，例如用于存放管理个人/公司开发的公共jar。远程仓库可以在pom.xml中配置，这里不详细描述步骤了。&lt;/p&gt;&lt;h3&gt;认识pom.xml&lt;/h3&gt;&lt;p&gt;pom.xml是Maven的基本工作单元，包含了项目的基本信息，声明了项目依赖、项目如何构建等等。使用Maven时，Maven会自动在当前目录中查找pom.xml，读取pom.xml，获取所需的配置信息，然后执行目标任务。pom.xml一般放置在项目源码的根目录下。&lt;/p&gt;&lt;p&gt;每个pom.xml都有一个父pom.xml，父pom.xml中包含了一些可以被继承的默认设置，例如当查找依赖时，如果本地仓库中没有，默认会从中央仓库中查找依赖，但是这个中央仓库默认是不需要配置的，是因为在父pom.xml中配置了中央仓库的地址http://repo1.maven.org/maven2。&lt;/p&gt;&lt;p&gt;pom.xml文件元素有很多，这里只介绍常用的部分标签元素。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--继承的父项目信息，默认可以不配置，如果有可以配置--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--父项目的pom.xml中定义的元素值被本项目继承下来，也就是说如果本项目pom.xml中某元素没定义，那么默认会自动使用父项目定义的值--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;parent&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定父项目的全球唯一标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;groupId&amp;gt;com.alibaba.nacos&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定父项目的构件标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;nacos-all&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定父项目的版本号--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;version&amp;gt;1.2.1&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定父项目pom.xml文件的相对路径。默认值是../pom.xml--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/parent&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定模型版本号，指定当前pom.xml应遵循哪一个POM模型版本，当前版本4.0.0--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--定义本项目的全球唯一标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;groupId&amp;gt;com.wind.cloud&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--定义本项目的构建标识，它和groupId一起唯一标识一个构件--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;demo&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定本项目的构建版本号--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--目标构建类型，如jar、war、pom等，默认是jar--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--定义key-value形式的属性，这些属性可以在全局使用--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;properties&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;alibaba-nacos-config-version&amp;gt;2.2.1.RELEASE&amp;lt;/alibaba-nacos-config-version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--项目需要的依赖列表--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的具体信息--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的全球唯一标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的构建标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-config&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的版本号--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;version&amp;gt;${alibaba-nacos-config-version}&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定依赖在什么时候被使用，默认是compile，即编译--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--如果值为test，则用于test任务时使用--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--当有传递依赖时，从依赖列表中排除某些不需要的依赖--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;exclusions&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--排除依赖的信息--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;exclusion&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--排除依赖的构建标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;org.slf4j&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--排除依赖的全球唯一标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;groupId&amp;gt;slf4j-api&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/exclusion&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/exclusions&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--项目构建管理，默认会使用父pom.xml中的配置，没有特殊需求可以不配置--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;build&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--使用的插件列表 --&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--Maven社区提供了很多不同功能的插件可以使用，这里不一一介绍了，有需要的在Maven官网查看(https://maven.apache.org/)--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--plugin元素描述插件所需要的信息--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--插件的artifactId--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--插件的版本--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;version&amp;gt;3.5.1&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--插件工作时需要的参数配置--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;source&amp;gt;${maven.compiler.source}&amp;lt;/source&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;target&amp;gt;${maven.compiler.target}&amp;lt;/target&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;compilerVersion&amp;gt;${maven.compiler.source}&amp;lt;/compilerVersion&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;showDeprecation&amp;gt;true&amp;lt;/showDeprecation&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;showWarnings&amp;gt;true&amp;lt;/showWarnings&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;依赖管理&lt;/h3&gt;&lt;p&gt;在pom.xml文件的dependencies标签中通过添加dependency元素添加项目依赖。实际的开发中，通常将项目的公共依赖定义到父项目的pom.xml中，或者定义到公共项目的pom.xml中。&lt;/p&gt;&lt;p&gt;Maven中的项目依赖是可传递的，例如项目A依赖jar包B，项目C依赖项目A构建后的jar包，那么项目C间接依赖jar包B。&lt;/p&gt;&lt;p&gt;有时，这种依赖传递会导致依赖的版本冲突，可以通过配置exclusions排除某些不需要的依赖，当然也可以通过optional标记某传递依赖是可选的。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--项目需要的依赖列表--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的具体信息--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的全球唯一标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的构建标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-config&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的版本号--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;version&amp;gt;${alibaba-nacos-config-version}&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定依赖在什么时候被使用，默认是compile，即编译--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--如果值为test，则用于test任务时使用--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--当有传递依赖时，从依赖列表中排除某些不需要的依赖--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;exclusions&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--排除依赖的信息--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;exclusion&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--排除依赖的构建标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;org.slf4j&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--排除依赖的全球唯一标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;groupId&amp;gt;slf4j-api&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/exclusion&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/exclusions&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的全球唯一标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的构建标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的版本号--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;version&amp;gt;2.6.8&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定依赖在什么时候被使用，默认是compile，即编译--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--如果值为test，则用于test任务时使用--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--当有传递依赖时，指定依赖是可选的--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;Maven构建生命周期&lt;/h3&gt;&lt;p&gt;Maven构建生命周期（lifecycle）由各个阶段组成，每个阶段由Maven的插件plugin来执行完成。一般情况下，一个项目的Maven构建生命周期由以下几个阶段的序列组成。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.7937219730941705&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKQMYibiaKeHYSvicqcPfHnAwYpNNHwDKHC7TMBKmAibgdq1sPDbIEKVemfSIMrX4vF1Niaq0E9hXAtXJLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;446&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6161616161616161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKQMYibiaKeHYSvicqcPfHnAwYpyEYlmQiboJF5GHic1PFvP28gfCfBpQagWkaravM2TrWB8oewCZyY8mpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;990&quot;/&gt;&lt;/p&gt;&lt;h3&gt;Maven构建命令&lt;/h3&gt;&lt;p&gt;在pom.xml文件所在的路径使用mvn命令，Maven会自动查找pom.xml，加载解析并执行文件中的构建任务。&lt;/p&gt;&lt;p&gt;一般常用的构建命令有mvn clean package、mvn clean install和mvn clean deploy。&lt;/p&gt;&lt;p&gt;mvn clean package：依次执行移除所有上一次构建生成的文件、代码编译、单元测试、打包。&lt;/p&gt;&lt;p&gt;mvn clean install：依次执行移除所有上一次构建生成的文件、代码编译、单元测试、打包、将打好的包安装到本地仓库。&lt;/p&gt;&lt;p&gt;mvn clean deploy：依次执行移除所有上一次构建生成的文件、代码编译、单元测试、打包、将打好的包安装到本地仓库、将打好的包发布到远程仓库。&lt;/p&gt;&lt;h3&gt;IntelliJ IDEA中使用Maven&lt;/h3&gt;&lt;p&gt;最新版本的IntelliJ IDEA会自带Maven插件，但还是建议通过配置更改成本机安装的Maven，这样方便更改Maven相关配置。&lt;/p&gt;&lt;p&gt;新建Maven项目或打开已有的Maven项目后，IDEA会自动识别项目中的pom.xml，在IDEA右侧的窗口中会展示pom.xml中使用到的插件和构建声明周期，例如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8385772913816689&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKQMYibiaKeHYSvicqcPfHnAwYp00Jq0zibD83wxnoaviaDwsIaoyjua58T3IrG1RG9DkHuHeaiaqSsIas0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot;/&gt;&lt;/p&gt;&lt;p&gt;双击Lifecycle中的某阶段，会自动执行相应的构建任务。当然，也可以通过IDEA中的Terminal直接执行mvn命令。&lt;/p&gt;&lt;h3&gt;Eclipse中使用Maven&lt;/h3&gt;&lt;p&gt;最新版本的Eclipse会自带Maven插件，但还是建议通过配置更改成本机安装的Maven，这样方便更改Maven相关配置。&lt;/p&gt;&lt;p&gt;新建Maven项目或打开已有的Maven项目后，Eclipse会自动识别项目中的pom.xml。项目代码在Eclipse中打开后，右键选中项目，然后选择Run As，会列出可执行的Maven构建任务。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484878&amp;amp;idx=1&amp;amp;sn=daee4e4702b0d3a44daf8599501d72e8&amp;amp;chksm=e9bf5750dec8de4656a9aaf85ada2ca8042921c8e52b57c494cc9af52e615e19fb101a485103&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Java开发人员必知的常用类库，这些你都知道吗？&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484871&amp;amp;idx=1&amp;amp;sn=74ede98f0281459c8ded84bd5178caa0&amp;amp;chksm=e9bf5759dec8de4fa24d29ada560d50e73dd35264a02fdd85aab44c4a931af8f1f6e47d1b683&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊一聊Redis官方置顶推荐的Java客户端Redisson&lt;/a&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484871&amp;amp;idx=1&amp;amp;sn=74ede98f0281459c8ded84bd5178caa0&amp;amp;chksm=e9bf5759dec8de4fa24d29ada560d50e73dd35264a02fdd85aab44c4a931af8f1f6e47d1b683&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484828&amp;amp;idx=1&amp;amp;sn=bbdfbbed2c5e97dd58386df08fc011db&amp;amp;chksm=e9bf5702dec8de14016f5468ee387d8b326cdec0eca0013e8b5b95d945897f64a6cb817793d3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;我画了25张图展示线程池工作原理和实现原理，原创干货，建议先收藏再阅读&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484763&amp;amp;idx=1&amp;amp;sn=a67f151b04967d149c2b60ed648e5dbf&amp;amp;chksm=e9bf57c5dec8ded33ccfc6cd269c4736eec528b8e6ab4cc6c2beb11deb744e7f78d7b61ec72b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Spring框架你敢写精通，面试官就敢问@Autowired注解的实现原理&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484742&amp;amp;idx=1&amp;amp;sn=54e9e3e9de14d3681a8d426d90f5d687&amp;amp;chksm=e9bf57d8dec8decec68531bd74f92a6dba3fb4e74564c27fa9933ece75290d27ffa317a4a8ae&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;面试被问为什么使用Spring Boot？答案好像没那么简单&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484730&amp;amp;idx=1&amp;amp;sn=dd043e8eb2fbf4ca7df266aabed45443&amp;amp;chksm=e9bf57a4dec8deb2e7162250c559dd4d2189681f6e08b37da371d04867698a26b9be062fc24b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Spring声明式事务处理的实现原理，来自面试官的穷追拷问&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484712&amp;amp;idx=1&amp;amp;sn=982a0801e878700b42b48f7fae3e5f30&amp;amp;chksm=e9bf57b6dec8dea04544c551c8206897f66efb81f49532b65df4ff878ad284c261b48ad9e3dd&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;没使用加号拼接字符串，面试官竟然问我为什么&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484707&amp;amp;idx=1&amp;amp;sn=3eea7537f43fcf0cd646d9bc64fd657f&amp;amp;chksm=e9bf57bddec8deab4ffea25c68197d82c1b46ba58ad0963c9fc0ee6d79f9c47c29660875187f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;面试官一步一步的套路你，为什么SimpleDateFormat不是线程安全的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484701&amp;amp;idx=1&amp;amp;sn=67ba3d2cedbd7a475371acfc474210e1&amp;amp;chksm=e9bf5783dec8de95e76115bc1fbd14401f8b41030d7aa5ebd42894eba56f138fd03f153718a4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;都说ThreadLocal被面试官问烂了，可为什么面试官还是喜欢继续问&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484696&amp;amp;idx=1&amp;amp;sn=54c8b5ad9373d88564032c8bc4bc0926&amp;amp;chksm=e9bf5786dec8de90506632f193789cc088165985e35320a5e2a64f6a1230f5d74c9118a811af&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java注解是如何玩转的，面试官和我聊了半个小时&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;学之多，而后知之少&lt;/strong&gt;&lt;span&gt;！以上是本次分享的内容，朋友们点【在看】是我持续更新的最大动力，我们下期见！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKSxTAD3licFmGltOsliao1ZVHCicnRtbiarMjXCkm2y0FjRlsJ596O4ibOAoOib1XWGhXlYX8x0wYXIPfxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5555555555555556&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6a8b75c19ea8a48865cdf3bee18fbdee</guid>
<title>Apache Doris 在京东广告的应用实践</title>
<link>https://toutiao.io/k/e4n8raw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9900990099009901&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT930CzevNBb2yMhKjOn9yuJqscN6FicEzJ7iaIdeV8ibJEyVBJNVD6VdujVn2zyicOYIKribkoPEBP1Vb4icQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;-     前言     -&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文主要介绍Apache Doris在京东广告报表查询场景下的应用。文章将从我们原有系统开始讲述，包括我们遇到的问题，面临的挑战，以及我们为何选择使用Apache Doris。最后将介绍Doris在我们生产环境下的使用情况，包括Apache Doris在京东“618”、“双11”大促中的表现。希望通过我们的使用实践为大家提供一些经验参考，也欢迎大家对我们的不足之处提出建议。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9900990099009901&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT930CzevNBb2yMhKjOn9yuJqscN6FicEzJ7iaIdeV8ibJEyVBJNVD6VdujVn2zyicOYIKribkoPEBP1Vb4icQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;-     背景介绍     -&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;京准通是京东集团旗下的广告营销推广平台。&lt;/span&gt;&lt;span&gt;我们团队主要负责京准通平台的报表查询服务，主要为广告主/运营/采销等提供实时/离线的报表的查询，支持了十余个业务线，300多张报表，覆盖了京准通内绝大多数效果报表，每日千万级查询总量，百亿级数据增量，毫秒级的查询耗时。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9900990099009901&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT930CzevNBb2yMhKjOn9yuJqscN6FicEzJ7iaIdeV8ibJEyVBJNVD6VdujVn2zyicOYIKribkoPEBP1Vb4icQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;-     原有系统存在的问题     -&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我&lt;/span&gt;&lt;span&gt;们原来有一套京东广告自己内部开发的广告效果数据查询系统，可以支持数据预聚合，支持原子导入，支持按列建立Rollup表。&lt;/span&gt;&lt;span&gt;由于这些特性的原因，原有系统在广告效果数据报表的特定场景下，可以满足日常线上查询的需求。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但随着业务的迭代&lt;/span&gt;&lt;span&gt;，上层查询系统对我们的要求越来越高，主要表现为以下几个方面：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;1. 原有系统已经逐渐无法满足我们日常业务的性能需求；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 日常业务所需的Schema Change、Rollup等操作，在原有系统上有极高的人力成本；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 原有系统的数据无法迁移，扩容需要重刷全部历史数据，运维成本极高；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. 在“618”和“双11”的时候，原有系统会成为我们对外服务的一个隐患。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此我们需要一个合适的数据查询引擎来替代我们的原有系统，考虑到我们团队的人力和研发能力，我们选择使用开源的OLAP引擎来替换原有系统。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9900990099009901&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT930CzevNBb2yMhKjOn9yuJqscN6FicEzJ7iaIdeV8ibJEyVBJNVD6VdujVn2zyicOYIKribkoPEBP1Vb4icQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;-     技术选型     -&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里简单介绍我们日常操作所关注的痛点，也是我们在之后技术选型方面主要考虑的关键。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;• 查询&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们为广告主提供在线报表数据查询服务，因此该OLAP查询引擎必须满足：可以支持高并发查询、可以毫秒级返回数据，并且可以随着业务的发展水平扩展。此外我们也承接了越来越多运营和采销同事的多维数据分析需求，因此希望该OLAP引擎也可以支持高吞吐的Ad-hoc查询。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sq4ia0xXeMC6NrgicAMgbp0edp6AaJ9lrOe8DdBlhkyjcUPG15LU0faW28MJqwcX7wkqRUFqBmkSAJfDtwic0oQhw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;405&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;284&quot; data-ratio=&quot;0.6987654320987654&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9TPn66HT932wIbaE4okIUbicsnFR7nNXAeCpA1DHdbQXjII3bYdFYKETic3A1vhyibxULoHogDdYibD5IVRlQiblC8w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;405&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;• 数据导入&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们需要同时支持离线（T+1）大规模数据和实时（分钟级间隔）数据的导入，数据导入后即可查询，保证数据导入的实时性和原子性。离线数据（几十G）的导入任务需要在1小时内完成，实时数据（百M到几G）的导入任务需要在10分钟内完成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;• 扩容&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在“618”这类大促前我们通常会进行扩容，因此需要新系统扩容方便，无需重刷历史数据来重新分布数据，且扩容后原有机器的数据最好可以很方便地迁移到新机器上，避免造成数据倾斜。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据日常业务的需要，我们经常会进行Schema Change操作。由于原有系统对这方面的支持很差，我们希望新系统可以进行Online Schema Change，且对线上查询无影响。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;• 数据修复&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于业务的日常变更会对一些表进行数据修复，因此新系统需要支持错误数据的删除，从而无需重刷全部历史数据，避免人力和计算资源的浪费。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前开源的OLAP引擎很多，但由于面临大促的压力，我们需要尽快完成选型并进行数据迁移，因此我们只考察了比较出名的几个OLAP系统：ClickHouse，Druid和Doris。最终我们选择了Doris来替换我们的原有系统，主要基于以下几方面的考虑：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. Doris的查询速度是亚秒级的，并且相对ClickHouse来说，Doris对高并发的支持要优秀得多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. Doris扩容方便，数据可以自动进行负载均衡，解决了我们原有系统的痛点。ClickHouse在扩容时需要进行数据重分布，工作量比较大。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. Doris支持Rollup和Online Schema Change，这对我们日常业务需求十分友好，而且由于支持MySQL协议，Doris可以很好地和之前已有的系统进行融合。同时，Druid对标准SQL的支持有限，并且不支持MySQL协议，对于我们来说改造成本很高。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.44722222222222224&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT932wIbaE4okIUbicsnFR7nNXAm9oSrQIMwKjdGsaDHUSKrFDyxPSTyYpsRnXTphCPz6eRq6dkXKybhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9900990099009901&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT930CzevNBb2yMhKjOn9yuJqscN6FicEzJ7iaIdeV8ibJEyVBJNVD6VdujVn2zyicOYIKribkoPEBP1Vb4icQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;-     广告场景应用     -&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过对我们系统的改造，目前我们使用Doris作为我们系统中的一个数据存储层，&lt;/span&gt;&lt;span&gt;汇总了离线和实时数据，也为上层查询系统提供统一的效果数据查询接口。&lt;/span&gt;&lt;span&gt;如下图所示：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7585470085470085&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT932wIbaE4okIUbicsnFR7nNXAjLJYibYw2N5Iw6HMxbFgFeFIOglOwxDIQhdx7ZqfNVc0qRS7N4jLgfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;468&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;• 数据导入&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们日常实时数据主要包含展现/点击跟单数据，DMP人群包的效果数据以及十几条产品线的点击、展现和消耗数据，导入时间间隔从1分钟到1小时不等，数据量在百M左右的可以秒级导入，数据量在1G左右的可以在1分钟内完成。离线数据主要包含搜索词的效果数据和各种营销工具的基础数据，大多数都是T+1数据，每日新增数据量在20G-30G，导入耗时在10-20分钟。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;• 预计算&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于我们的大多数效果数据报表，广告主的查询维度相对固定且可控，但要求能在毫秒级返回数据，所以必须保证这些查询场景下的性能。Doris支持的聚合模型可以进行数据的预聚合，将点击、展现、消耗等数据汇总到建表时指定的维度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此外，Doris支持建立Rollup表（即物化视图）也可以在不同维度上进行预聚合，这种自定义的方式相比Kylin的自动构建cube，有效避免了数据的膨胀，在满足查询时延的要求下，降低了磁盘占用。Doris还可以通过Rollup表对维度列的顺序进行调整，避免了Kylin中因过滤维度列在HBase RowKey后部而造成的查询性能低下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;• 现场计算&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于一些为广告主提供的营销工具，维度和指标通常会有30~60列之多，而且大部分查询要求按照所有维度列进行聚合，由于维度列较多，这种查询只能依赖于现场计算能力。目前我们对于这种类型的查询请求，会将其数据尽量均匀分布到多台BE上，利用Doris MPP架构的特性，并行计算，并通过控制查询时间范围（一个月），可以使TP99达到3s左右。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;• 业务举例&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正是由于Doris具有自定义的预计算能力和不俗的现场计算能力，简化了我们的日常工作。以我们为广告主提供的营销工具“行业大盘”为例，如图所示，这种业务场景下，不仅要计算广告主自身的指标数据，还需计算广告主所在类目的指标数据，从而进行对比。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4523809523809524&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT932wIbaE4okIUbicsnFR7nNXAQibI0QdrIGQLXr8GH7ukrbia6bCeBNRdzPrRAO781YM1B0LjzPpwdG8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;420&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;原有系&lt;/span&gt;&lt;span&gt;统数据分片只能按照指定列进行散列，没有分布式查询计划，就不能汇总类目维度数据。&lt;/span&gt;&lt;span&gt;原先为了解决这种业务场景，虽然底层是同一数据源，但我们需要建两个表，一个是广告主维度表，一个是类目维度表，维护了两个数据流，增大了工作负担。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用了Doris之后，广告主维度表可以Rollup出类目维度表。查询广告主维度数据时可以根据分区分桶（按照时间分区，按照广告主ID分桶）确定一个Tablet，缩小数据查询范围，查询效率很高。查询类目维度时，数据已经按照广告主ID进行分片 ，可以充分利用Doris现场计算的能力，多个BE并行计算，实时计算类目维度数据，在我们的线上环境也能实现秒级查询。这种方案下数据查询更加灵活，无需为了查询性能而维护多个预计算数据，也可以避免多张表之间出现数据不一致的问题。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3888888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT932wIbaE4okIUbicsnFR7nNXAYFS0icKx50F0VDu3UlrW8g3ng6gp55zo2pBB4FdOfAr4MtAY9PGoFjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;468&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9900990099009901&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT930CzevNBb2yMhKjOn9yuJqscN6FicEzJ7iaIdeV8ibJEyVBJNVD6VdujVn2zyicOYIKribkoPEBP1Vb4icQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;-    实际使用效果     -&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;• 日常需求&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;– Doris支持聚合模型，可以提前聚合好数据，对计算广告效果数据点击，展现和消耗十分适合。对一些数据量较大的高基数表，我们可以对查询进行分析，建立不同维度或者顺序的的Rollup表来满足查询性能的需求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;– Doris支持Online Schema Change，相比原有系统Schema Change需要多个模块联动，耗费多个人力数天才能进行的操作，Doris只需一条SQL且在较短时间内就可以完成。对于日常需求来说，最常见的Schema Change 操作就是加列，Doris对于加列操作使用的是Linked Schema Change方式，该方式可以无需转换数据，直接完成，新导入的数据按照新的Schema进行导入，旧数据可以按照新加列的默认值进行查询，无需重刷历史数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;– Doris通过HLL列和BITMAP列支持了近似/精确去重的功能，解决了之前无法计算UV的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;– 日常数据修复，相较于以前有了更多的方式可以选择。对于一些不是很敏感的数据，我们可以删除错误数据并进行重新导入；对于一些比较重要的线上数据，我们可以使用Spark on Doris计算正确数据和错误数据之间的差值，并导入增量进行修复。这样的好处是，不会暴露一个中间状态给广告主。我们还有一些业务会对一个或多个月的数据进行重刷。我们目前在测试使用Doris 0.12版本提供的Temp Partition功能，该功能可以先将正确数据导入到Temp Partition中，完成后可以将要删除的Partition和Temp Partition进行交换，交换操作是原子性的，对于上层用户无感知。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;• 大促备战&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;– Doris添加新的BE节点后可以自动迁移Tablet到新节点上，达到数据负载均衡。通过添加FE节点，则可以支撑更高的查询峰值，满足大促高并发的要求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;– 大促期间数据导入量会暴增，而且在备战期间，也会有憋单演练，在短时间内会产生大量数据导入任务。通过导入模块限制Load的并发，可以避免大量数据的同时导入，保证了Doris的导入性能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;– Doris在我们团队已经经历了数次大促，在所有大促期间无事故发生，查询峰值4500+qps，日查询总量8千万+，TP99毫秒级，数据日增量近300亿行，且实时导入数据秒级延迟。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;• 使用实践&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;– Doris支持低延时的高并发查询和高吞吐的Ad-hoc查询，但是这两类查询会相互影响，迁移到Doris的初期日常线上的主要问题就是高吞吐的查询占用资源过多，导致大量低延时的查询超时。后来我们使用两个集群来对两类查询进行物理隔离，解决了该问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;– Doris在0.11版本时FE的MySQL服务IO线程模型较为简单，使用一个Acceptor+ThreadPool来完成MySQL协议的通信过程，单个FE节点在并发较高（2000+qps左右）的时候会出现连接不上的问题，但此时CPU占用并不高。在0.12版本的时候，Doris支持了NIO，解决了这个问题，可以支撑更高的并发，也可以使用长连接解决这个问题，但需要注意Doris默认对连接数有限制，连接占满了就无法建立新的连接了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9900990099009901&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT930CzevNBb2yMhKjOn9yuJqscN6FicEzJ7iaIdeV8ibJEyVBJNVD6VdujVn2zyicOYIKribkoPEBP1Vb4icQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;-     总结     -&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过一年多时间的生产环境使用，Doris满足了我们日常使用的需求，并通过了多次大促的考验，证明了其在广告效果数据场景下适用性，和高并发场景下的可靠性。&lt;/span&gt;&lt;span&gt;在日常使用中，其良好的设计也大大降低我们的维护成本，缩短了我们日常业务的开发时间。&lt;/span&gt;&lt;span&gt;Doris已经成为了京东广告的核心系统之一。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当前Doris已经逐渐成熟，其周边的生态也越来越完善，未来可以在更多业务场景下进行尝试。Doris研发团队的核心成员组建了鼎石科技，不仅对Apache Doris有更强的支持，而且他们研发的企业版产品，相对于开源版本功能更加完善，性能也更加卓越。在使用Doris的过程中，鼎石科技的小伙伴们也给予了我们很大的帮助。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;未来，我们会进一步探索Doris在广告其他方面的应用，包括广告物料数据方面等。期待Doris的功能和性能进一步提升，最终成为解决数据分析问题的统一平台。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;344&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9TPn66HT930CzevNBb2yMhKjOn9yuJqsL0NGicTHp8c6lB2CAkpgN1wxZ3Dat42DZuf7un3szPcrEeMJc9SBy5w/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;-   关注“架构之美”   -&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5163398692810458&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT930CzevNBb2yMhKjOn9yuJqsCPbyzicCBx6Zm9sNJCWibo6VzGRYbxrSfjJaaGibSRuyZFQmr3KcX07sw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>