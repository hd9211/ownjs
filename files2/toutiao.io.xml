<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>df4da509ff40e155e97a826e1ff5d5bf</guid>
<title>看的书多，就有用吗？</title>
<link>https://toutiao.io/k/4xmlwst</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;img-content&quot; class=&quot;rich_media_wrp&quot;&gt;
                
                
                

                
                                                

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;p class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;大家好，我是袁吴范。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最近面试，我问的最多的问题就是：你的职业规划是什么？你打算准备怎么去实现？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第一个问题，基本上都能回答的上来。想要成为技术大牛，或者成为技术管理者等等。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二个问题，很多人都支支吾吾的回答不上来，其中有一个人说会看很多书。听他的描述&lt;span&gt;他的书单里有通俗心理学的，有管理学的，还有侦探小说。数量虽然不少，但是实在比较杂乱。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我记得有一个美国专家，曾经提出过一种理论，叫作LOE理论（level of effort投入水平），这种理论的核心观点，就是总体目标下的任何分目标，都应该为总体目标服务，这种情况下你的努力才是有效努力，而不是一种低水平努力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但其实很多时候，我们都陷入了低水平努力的误区。难道看书就是越多越好？难道一本书就一定要看完？难道订阅的专栏就每篇必看？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;真正厉害的人，会对自己的学习目标越来越清晰，不断收获反馈，获得学习能力的成长和升级，而不是毫无重点地乱看一气。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我发现，目标感强的人，总能给自己设定出一个非常现实的目标，并坚定不移地执行下去。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如我，干啥都要给自己设置一个目标。去年10月份开始写公众号，给自己定的是4个月订阅数达1w的目标，最终是艰难的完成了。可想而知，没有这个目标，不知道虎年马月才能到1w呢。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但很多人会陷入一个误区：我提出目标，不管这个目标是否合理，是否能执行下去，我都一定要坚持，否则我就是个彻头彻尾的失败者。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以很多人才会问我类似下面这样的问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我报名参加了某线上课程，听了一半之后，觉得自己看相关参考书就可以了，那么为了避免浪费钱，还要继续听下去吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果我给自己定了目标，要今年考上硕士，结果发挥失常，落榜了，那么我就要很难过地放弃吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每个人的努力，都是为了实现某种目标；只可惜，没有人能够完全掌控自己的人生，总会有一些超出预料的事情发生。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么，面对暂时的挫折，我们应该怎么办呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比起一筹莫展、不知所措，为什么不尝试分析一下自己没有完成这个目标的原因？到底遇到了哪些不可解决的问题？能否通过一定途径去解决？能否重新调整目标去完成？是你的执行有问题，还是目标本身就出了问题？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如假设你的最初目标是读完三百本书，那么只要你适当地浏览一下，知道每本书的内容自己是否感兴趣，而不是单凭标题和别人的推荐就一股脑读完，那么你可能选择其中二十本，甚至十本去精读，最后你的收获会比慢慢读完三百本书多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span data-original-font-size=&quot;13&quot; data-original-line-height=&quot;21&quot;&gt;另外，不论学习还是工作，一定要给自己反馈，而且是正向的反馈。&lt;/span&gt;比如你给自己定计划，每天要跑五圈，结果你今天只跑了三圈，但其实昨天跑得更少，只跑了一圈。所以，你要奖励一下自己的进步，然后去制订一个更符合实际的目标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，仅有一个空洞的目标是不够的。真正厉害的人，会对自己的目标进行阶段细分，并在执行的过程中不断调整这个目标，把目标变得越来越现实，这才能建立自我鼓励的良性循环。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大部分的人都有自己的目标，可真正能做到这一点的人，只有一小部分。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这里，我愿意分享个人的一些小技巧，来帮助大家利用目标感来推动自己，制订可执行的方案，从而达成更高的人生成就。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span data-original-font-size=&quot;13&quot; data-original-line-height=&quot;21&quot;&gt;第一，找到自己的最终目标，并以此为依据，倒推对能力的需求。&lt;/span&gt;比如想要在五年内成为管理二十个人的团队负责人的话，需要具备哪些能力——是领导力、团队协作能力、专业领域能力还是沟通能力，并且找到这些能力当中，自己和目标有差距的地方。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span data-original-font-size=&quot;13&quot; data-original-line-height=&quot;21&quot;&gt;第二，把总体目标分解成阶段性目标。&lt;/span&gt;比如三年内成为部门的经理，管理五个人，成为细分专业的专家；五年内横向拓展并且寻求纵向发展，成为二十个人团队的负责人。为了实现这些阶段目标，你要得到业内哪些人的承认？是否需要跳槽才能实现这些目标？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span data-original-font-size=&quot;13&quot; data-original-line-height=&quot;21&quot;&gt;第三，找到最近的阶段目标，再次细分。&lt;/span&gt;比如一年内达到专业领域精通，成为细分专业的核心，那么需要哪些能力，达到什么样的水平，需要学习哪些东西，一年时间是否足够？需要付出多少额外的精力？需要看多少本专业书籍？需要进行多少次实操？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所有你真心想完成、真正能完成的目标，都自带一套可调整的执行方案。想在成长道路上做一个有目标感的人，就不要让那种大而空的目标增加你的焦虑感，把它拆分成一个个的小目标吧！在前进的道路上，每完成一个小目标，就给自己一些适当的鼓励，形成心理上的良性循环，这样做下去，你的目标终有一天会实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/p&gt;

                

                



                
                &lt;p class=&quot;read-more__area&quot; id=&quot;js_more_read_area&quot;&gt;
                    
                &lt;/p&gt;

                 
                                            
                        
                                                    &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;经验的结晶&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;
                                        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>160caf8fc084a4ec7925997499c2ee29</guid>
<title>JavaScript 中原型与原型链的简单理解</title>
<link>https://toutiao.io/k/u4ikq3r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;blockquote&gt;&lt;p&gt;原型和原型链是JavaScript中一个比较难理解的概念，什么是prototype？什么是&lt;strong&gt;proto&lt;/strong&gt;？什么是构造函数？&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;讲原型和原型链，如果是讲定义，那很是晦涩难懂，今天我们就通俗易懂的说说原型与原型链。还需要借助阮老师的“&lt;/span&gt;&lt;span&gt;Javascript继承机制的设计思想”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1 构造函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在讲原型和原型链之前，我们简单说下什么是&lt;strong&gt;构造函数&lt;/strong&gt;，在 JavaScript 中，用 new 关键字来调用的函数，称为构造函数。&lt;/span&gt;&lt;span&gt;任何的函数都可以作为构造函数存在&lt;/span&gt;&lt;span&gt;，构造函数首字母一般大写。看看我们常用构造函数：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; arr = []; &lt;span&gt;// var arr = new Array(); &lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; obj = {}; &lt;span&gt;// var obj = new Object();  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt;  date = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;那我们知道了什么是构造函数，那我们还应该知道它的作用，我们举个例子，比如有个班级，班级里有50人，老师把这50人的信息录入系统，信息可能包含姓名、年龄、性别、身高、体重、联系方式及各科成绩等，普通方式，我们可以这么处理，每个人都建个对象，对象包含这些信息。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; lisi = { name: &lt;span&gt;&#x27;李四&#x27;&lt;/span&gt;, age: &lt;span&gt;6&lt;/span&gt;, gender: &lt;span&gt;&#x27;男&#x27;&lt;/span&gt;, address: &lt;span&gt;&#x27;xxxx&#x27;&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; zhangsan = { name: &lt;span&gt;&#x27;张三&#x27;&lt;/span&gt;, age: &lt;span&gt;6&lt;/span&gt;, gender: &lt;span&gt;&#x27;女&#x27;&lt;/span&gt;, address: &lt;span&gt;&#x27;xxxx&#x27;&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; wangwu = { name: &lt;span&gt;&#x27;王五&#x27;&lt;/span&gt;, age: &lt;span&gt;6&lt;/span&gt;, gender: &lt;span&gt;&#x27;女&#x27;&lt;/span&gt;, address: &lt;span&gt;&#x27;xxxx&#x27;&lt;/span&gt; };&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上面这种写法，我们会发现做了很多重复的事情，每个人都有名字、年龄等信息，其实我们就可以把这些提取出来。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt;(&lt;span&gt;name, gender, address&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.gender = gender;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.address= address;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;然后就可以实例化学生。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; lisi = &lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;&#x27;李四&#x27;&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;&#x27;xxx&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; zhangsan = &lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;&#x27;张三&#x27;&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;&#x27;xxx&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; wangwu = &lt;span&gt;new&lt;/span&gt; Person(&lt;span&gt;&#x27;王五&#x27;&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;&#x27;xxx&#x27;&lt;/span&gt;);&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;在使用对象字面量创建一系列同一类型的对象时，这些对象可能具有一些相似的特征(属性)和行为(方法)，此时会产生很多重复的代码，而使用构造函数就可以实现代码复用。说到这应该可以理解构造函数的作用了。接下来我们说说原型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2 原型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接上例子，比如我们还要针对学生统计每个人的总分是多少，我们改造构造函数Person，构造函数上有个 prototype属性，这个属性就是这个构造函数的原型（&lt;strong&gt;显式&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;原型&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;），这个原型是函数特有，&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;rototype对象默认有两个属性，con&lt;/span&gt;&lt;span&gt;structor属性和__proto__属性。&lt;/span&gt;&lt;span&gt;constructor，这个属性包含了一个指针，指回原构造函数。&lt;span&gt;__proto__属性&lt;/span&gt;我们下面详细说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;rototype&lt;/span&gt;&lt;span&gt;作用就是共享和继承。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;共享&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：学生都是一班的&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;Person.prototype.&lt;span&gt;class&lt;/span&gt; = &lt;span&gt;&quot;一班&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;继承&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：所有实例化的都可以调用这个方法统计分数&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;Person.prototype.statistical = function () {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.yw + &lt;span&gt;this&lt;/span&gt;.sx + &lt;span&gt;this&lt;/span&gt;.yy&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;实例化的学生对象都可以调用statistical &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;lisi&lt;/span&gt;&lt;span&gt;.statistical&lt;/span&gt;()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;通过控制台输出，我们可以看到我们实例化的对象，有个__proto__属性，这个属性就是&lt;strong&gt;隐式原型&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，这个&lt;span&gt;__proto__是所有对象都有的属性，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;302&quot; data-backw=&quot;549&quot; data-ratio=&quot;0.5500910746812386&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ldv96ZtlFHTqr4PfIdmibbGwZ5eMvVsiaPliaiaiclR8ibDvD8h2uxM1uMl2UImegCuozhbyegH0hwu1JeqXtI89AH1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;549&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;这个__proto__属性指向我们的构造函数的prototype，我们通过===（全等）测试&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;48&quot; data-backw=&quot;518&quot; data-ratio=&quot;0.09284332688588008&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ldv96ZtlFHTqr4PfIdmibbGwZ5eMvVsiaPyyWZml02vEJfED7oCc86Bw22rItPiclbhH6fsBvxe7ic5WgeFpScVesg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;517&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;借用网上一张图，理下构造函数、原型对象、实例的关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;179&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.31&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ldv96ZtlFHTqr4PfIdmibbGwZ5eMvVsiaPwLoNIkpHQVJl0uoGEdW774TsEcQ4Io2yoMXfZSukxqb901zxj6DYEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3 原型链&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面这张图，我们可以看到原型链的影子，由于&lt;span&gt;JavaScript的一切都是对象&lt;/span&gt;（除undefined），又由于所有对象都有&lt;span&gt;__proto__属性，&lt;span&gt;__proto__又指向构造函数的&lt;span&gt;prot&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;otype，&lt;/span&gt;&lt;span&gt;当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去__proto__里找这个属性，这个__proto__又会有自己的__proto__，于是就这样 一直找下去，也就是我们平时所说的原型链的概念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原型链，说明是链式，而不是环，说明有终点，它的终点是&lt;strong&gt;null&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1124031007751938&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ldv96ZtlFHTqr4PfIdmibbGwZ5eMvVsiaP2clfKCYzuK0I9QpsDDRxuSRmklnZYEvbZE4rp1c0oxVNv8ppVQ7yrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4 总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;prototype是函数的原型对象，即prototype是一个对象，它会被对应的__proto__引用。&lt;span&gt;__proto__&lt;/span&gt;是所有对象都有的属性，通过&lt;span&gt;__proto__&lt;/span&gt;的链式查找，可以形成原型链，原型链的终点是&lt;strong&gt;null&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>842eecd734f9ca45b9716938521a30cc</guid>
<title>OCTO 2.0：美团基于 Service Mesh 的服务治理系统详解</title>
<link>https://toutiao.io/k/mms9xqu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文将继续介绍OCTO系统在Service Mesh化演进方面的工作。主要从数据面的角度，详细介绍各项技术方案的设计思路。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1 整体架构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们先开看看OCTO 2.0的整体架构，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7112781954887218&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVBbKyeFxNR7J1IUkd5CBZXX67baKRbia6fEVQDD4TiaQibX0HCziabauq6pdOxIBFZ3NuOcVcKgiaeIAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;图1 整体架构四个组成部分：基础设施、控制平面、数据平面和运维系统&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基础设施是指美团现有的服务治理系统 &lt;/span&gt;&lt;a href=&quot;https://github.com/Meituan-Dianping&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;OCTO1.0&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，包括&lt;/span&gt;&lt;a href=&quot;https://github.com/Meituan-Dianping/octo-ns&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;MNS&lt;/span&gt;&lt;/a&gt;&lt;span&gt;、KMS（&lt;/span&gt;&lt;span&gt;鉴权管理服务&lt;/span&gt;&lt;span&gt;）、MCC（&lt;/span&gt;&lt;span&gt;配置管理中心&lt;/span&gt;&lt;span&gt;）、Rhino（&lt;/span&gt;&lt;span&gt;熔断限流服务&lt;/span&gt;&lt;span&gt;）等。这些系统接入到OCTO 2.0的控制平面，避免过多重构引入的不必要成本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;OCTO 2.0控制平面摒弃了社区的Istio，完全自研。数据平面基于开源Envoy改造。运维系统负责数据面组件的升级、发布等运维工作。更多的整体选型及原因可参考之前团队的文章: &lt;/span&gt;&lt;a href=&quot;https://tech.meituan.com/2019/12/12/meituan-octo.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《美团下一代服务治理系统 OCTO2.0 的探索与实践》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对OCTO 2.0中的功能，我们分为Mesh和服务治理两个维度。下面我们来重点看下流量劫持、无损重启、服务路由等几个常见的问题，并阐述美团是如何结合现有比较完善的服务治理系统来解决这些问题的。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2 Mesh功能&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 流量劫持&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;OCTO 2.0并未采用Istio的原生方案，而是使用iptables对进出POD的流量进行劫持。主要考量了以下两个因素：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;iptables自身存在性能损失大、管控性差的问题：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;iptables在内核对于包的处理过程中定义了五个“hook point”，每个“hook point”各对应到一组规则链，outbond流量将两次穿越协议栈并且经过这5组规则链匹配，在大并发场景下会损失转发性能。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;iptables全局生效，不能显式地禁止相关规则的修改，没有相关ACL机制，可管控性比较差。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;在美团现有的环境下，使用iptables存在以下几个问题：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651750633&amp;amp;idx=1&amp;amp;sn=51a4b05deac592c4ccbf2dbcf709288b&amp;amp;chksm=bd1259a48a65d0b2d198239c03158e4f5eeace74241f8dc7f7d361974fa1e85bfbc8d3dfab88&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;HULK&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;HULK&lt;/span&gt;&lt;/a&gt;&lt;span&gt;容器为富容器形态，业务进程和其他所有基础组件都处于同一容器中，这些组件使用了各种各样的端口，使用iptables容易造成误拦截。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;美团现在存在物理机、虚拟机、容器等多个业务运行场景，基于iptables的流量劫持方案在适配这些场景时复杂度较高。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;鉴于上述问题，我们最终采用了Unix Domain Socket直连方式来实现业务进程和OCTO-Proxy之间的流量转发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6039915966386554&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVBbKyeFxNR7J1IUkd5CBZXMXs2TDZZ55tDOqJhvrpnhBFL9b1BibotldmeCUiahia7FXhv2o0LXJDPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1904&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;图2 Unix Domain Socket直连流量转发&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在服务消费者一方，业务进程通过轻量的Mesh SDK和OCTO-Proxy所监听的UDS地址建立连接。在服务提供者一方，OCTO-Proxy代替业务进程监听在TCP端口上，业务进程则监听在指定的UDS地址上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;该方案的优点是Unix Domain Socket相比于iptable劫持拥有更好的性能和更低的运维成本。缺点是需要Mesh SDK的支持。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2 服务订阅&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原生Envoy的CDS/EDS请求是全量服务发现模式，即将系统中所有的服务列表都请求到数据面中。由于大规模集群中服务数量太多，真正所需的只是少数服务，所以需要改造成按需服务发现模式，仅请求需要访问的后端服务的节点列表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7290419161676647&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVBbKyeFxNR7J1IUkd5CBZXcZXv6wHNNxC2M6aYXhyh4B77oJ4EaogsCm5PDicsChurkV1npGvyb1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1336&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;图3 服务订阅流程&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在业务进程启动后，需要通过HTTP的方式向OCTO-Proxy发起订阅请求。OCTO-Proxy将所请求的后端服务Appkey更新到XDS中，XDS再向控制面请求特定的服务资源。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了增加整个过程中的健壮性，降低后续运维成本，我们做了部分适配。例如，OCTO-Proxy的启动速度有可能慢于业务进程，所以在Mesh SDK中增加了请求的重试逻辑；将Mesh SDK和OCTO-Proxy之间的http请求改造成了同步请求，防止Pilot资源下发延时带来的问题；Mesh SDK的订阅信息也会保存在本地文件中，以便OCTO-Proxy热重启或者故障重启时使用。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3 无损热重启&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3.1 流量损失场景&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何在基础组件升级过程中提供持续、不间断的服务，做到业务流量无损及业务无感知，是所有基础组件面临的一大难题。这个问题对于OCTO-Proxy这种处于流量核心链路上的组件更加重要。社区原生的Envoy自身已经支持了热重启功能但并不彻底，在某些场景下还是不能做到完全的流量无损。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下图分别在短连接和长连接两种场景下来说明OCTO-Proxy热重启时的流量损耗问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.498&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVBbKyeFxNR7J1IUkd5CBZXXLkG1wWiaFD12yicWyVYUxE3kXPKZtiabkW8UcOB7nI3EYRwmpzeAJCEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;图4 代理升级过程中流量损耗&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于短连接，所有新的连接会在新的OCTO-Proxy上创建，旧OCTO-Proxy上已有的连接在响应到来后主动断开。旧OCTO-Proxy的所有短连接逐渐断开，这就是“Drain”（&lt;/span&gt;&lt;span&gt;排空&lt;/span&gt;&lt;span&gt;）的过程。连接排空之后，旧OCTO-Proxy主动退出，新的OCTO-Proxy继续工作。整个过程中的流量，完全无损。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于长连接方式，SDK和旧OCTO-Proxy维持一条长连接不断开，并持续使用该连接发送请求。旧OCTO-Proxy进程最终退出时，该连接被动断开，此时可能尚有部分响应未返回，导致Client端请求超时。因此，Envoy的热重启对长连接场景的支持并不完美。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了支持基础组件在升级过程中提供不间断的服务，业界目前主要使用的是滚动发布（&lt;/span&gt;&lt;span&gt;Rolling Update&lt;/span&gt;&lt;span&gt;）的方式：服务器分批停止服务，执行更新，然后重新将其投入使用，直到集群中所有实例都更新为新版本。在此过程中会主动摘掉业务流量，保证升级过程中业务流量不丢失。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2987927565392354&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVBbKyeFxNR7J1IUkd5CBZXGxs3sYVP4nibEbOStHUBahW0GJib8VMvBGCD6F1NDMZib2okutBz1t0Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;图5 滚动升级&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;美团内部因为要兼容物理机、虚拟机、容器，业界云原生使用K8s滚动升级的方式不太适用，所以在现有环境下，如何保证服务治理系统的高可用性以及业务的高可靠性是一个非常棘手的事情。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3.2 适配方案&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当前方案是把业务服务分为两种角色，即对外提供服务的Server端角色和对外发起请求的Client端角色，针对两种不同的角色采用不同的热更新支持。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Client端OCTO-Proxy热更新：老的OCTO-Proxy在进入热重启状态后，对后续“新请求”直接返回含“热重启”标志的响应协议，Client SDK在收到含“热重启”标志的响应协议时，应主动切换新连接并请求重试（&lt;/span&gt;&lt;span&gt;以避免当前Client SDK持有的旧连接由于旧OCTO-Proxy热重启流程完成后被主动关闭的问题&lt;/span&gt;&lt;span&gt;）。这里需要注意，Client SDK需要“妥善”处理旧连接所在链路上遗留的所有“应答”协议。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8262108262108262&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVBbKyeFxNR7J1IUkd5CBZX7libI5Pf8BfA3ZZqNib2OnOPnvccbIa9ts71hvaOQlBPK48aR1wjTOTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1404&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;图6 客户端SDK/代理相互配合进行热升级&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过这种Client SDK和OCTO-Proxy间的交互配合，可以支持Client端在OCTO-Proxy升级过程中保证流量的安全性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Server端OCTO-Proxy热更新：Server侧OCTO-Proxy在热重启开始后，即会主动向Client侧OCTO-Proxy发送ProxyRestart消息，通知Client侧OCTO-Proxy主动切换新连接，避免当前Client侧OCTO-Proxy持有的旧连接由于Server侧旧OCTO-Proxy热重启流程完成后被强制关闭的问题。Client端OCTO-Proxy在收到“主动切换新连接”的请求后，应即时从可用连接池中移除，并“妥善”处理旧连接所在链路上遗留的所有“应答”协议（&lt;/span&gt;&lt;span&gt;保守起见可标记连接不可用，并维持一段时间，比如OCTO-Proxy默认drainTime&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8259629101283881&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVBbKyeFxNR7J1IUkd5CBZXdyABNibwxIp0KIBn3kQnOaHLQkTzvmOIwfERr2lQBNWpHgOiaS00Tj2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1402&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;图7 服务端反向主动通知客户端重连&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.4 数据面运维&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.4.1 LEGO运维方案&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;云原生环境中，Envoy运行在标准的K8S Pod中，通常会独立出一个Sidecar容器。可以使用K8s提供的能力来完成对Envoy Sidecar容器的管理，例如容器注入、健康检查、滚动升级、资源限制等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;美团内部所使用的容器运行时模式为“单容器模式”，即一个Pod内只包含一个容器（&lt;/span&gt;&lt;span&gt;不考虑Pause容器&lt;/span&gt;&lt;span&gt;）。由于业务进程以及所有的基础组件都运行在一个容器中，所以只能采用进程粒度的管理措施，无法做到容器粒度的管理。我们通过自研的LEGO平台解决了OCTO-Proxy的运维问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0290697674418605&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVBbKyeFxNR7J1IUkd5CBZXDgUtJSyCX7KVGdW9oE6DdpNqZEGrcYNtxLTMUW7PDiclPdJRUaS26QQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1032&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;图8 LEGO数据面管理系统&lt;/span&gt;&lt;/figcaption&gt;&lt;p&gt;&lt;span&gt;我们对LEGO-Agent做了定制化改造，增加了对OCTO-Proxy的热重启过程的支持。另外，LEGO-Agent还负责对OCTO-Proxy的健康检查、故障状态重启、监控信息上报和版本发布等。相对于原生K8s的容器重启方式，进程粒度重启会有更快的速度。&lt;/span&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LEGO系统的另一个优点是，可以同时支持容器、虚拟机和物理机等多种运行时环境。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.4.2 云原生运维方案&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前，我们也正在探索OCTO-Proxy云原生的运维方案，在此场景下最大的区别就是从进程粒度运维转变为了容器粒度运维，与业务应用做到了更好的解耦，同时可享受不可变基础设施等理念带来的红利，但是此场景带来的一个问题就是如何管理容器粒度的热重启。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为此，我们通过自研的Operator对OCTO-Proxy容器进行全生命周期的运维管理，并且期望通过Operator对OCTO-Proxy进行热重启，具体流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3813038130381304&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVBbKyeFxNR7J1IUkd5CBZXcmjBkgTAhjjM1dsK9aEl5CNnBAbum2WkBtFoS1iaNI2IzFibBvegdMcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1626&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;图9 期望的OCTO-Proxy容器热重启流程&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是在实施过程中这个方案是有问题的，原因是K8s在底层设计上是不支持对运行中的Pod进行容器的增删操作，如果需要实现该方案，将需要对K8s底层组件进行定制化修改，这样将带来一定风险以及与社区的不兼容性。为了保证与社区的兼容性，我们对此热重启方案进行改造，最终使用双容器驻留热重启方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3762254901960784&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVBbKyeFxNR7J1IUkd5CBZXHzpiaMyVZYBIg9SVN138V2pc3jPhXyzMBicpnY6OHwQPiakvXlprmWlBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1632&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;图10 双容器驻留热重启方案&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;首先，我们在启动Pod时，给OCTO-Proxy不再只分配一个容器，而是分配两个容器，其中一个容器为正常运行状态，另一个容器为standby状态。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当需要对OCTO-Proxy进行热重启升级时，我们修改standby容器的镜像为最新OCTO-Proxy的镜像，此时开始热重启流程。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当热重启流程结束后，新容器进入正常工作状态，而旧容器进入等待状态，最终，我们将旧容器的镜像修改为standby镜像，结束整个热重启流程。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;该方案利用一开始就驻留双容器在Pod内，避免了K8s对运行中Pod不能增删容器的限制，实现了在Pod中对OCTO-Proxy进行容器粒度的热重启。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3 未来规划&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前接入OCTO2.0系统的服务数量数千，天粒度流量数十亿。随着OCTO2.0在公司的不断推广，越来越多的服务开始接入，对我们的稳定性和运维能力提出了更高的要求。如何更细致的了解线上OCTO-Proxy以及所称在的业务系统的健康状况、如何在出现故障时能更及时的监测到并快速恢复是我们最近OCTO2.0系统建设的重点。除此之外，未来OCTO2.0的规划重点还包括：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;运维、发布和稳定性建设朝云原生化方向探索。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;支持公司内部Http服务的Mesh化，降低对中心化网关的依赖。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;全链路mTLS支持。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4 作者简介&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;舒超、世朋、来俊，均来自美团基础架构部基础开发组，从事OCTO2.0的开发工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;---&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7r&quot; textvalue=&quot;前端&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;前端&lt;/span&gt;&lt;/a&gt;&lt;strong&gt;&lt;span&gt; |&lt;/span&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jsdG&quot; textvalue=&quot;算法&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;算法&lt;/a&gt;&lt;strong&gt; |&lt;/strong&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jsWK&quot; textvalue=&quot;后端&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;后端&lt;/a&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt; |&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jqRZ&quot; textvalue=&quot;数据&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;数据&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;安全&lt;/a&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jui4&quot; textvalue=&quot;Android&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Android&lt;/a&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jtXE&quot; textvalue=&quot;iOS&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;iOS&lt;/a&gt; &lt;strong&gt; |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7K&quot; textvalue=&quot;运维&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;运维&lt;/a&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jtsX&quot; textvalue=&quot;测试&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;测试&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>74d65509e954840b9e5a5db5f710ff1d</guid>
<title>独立开发者如何快速从 0 到 1 设计一款 App 的 Logo：绘制图形</title>
<link>https://toutiao.io/k/6j2gosr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;点击上方“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;独立开发者杂谈&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;喜欢本文，请置顶或星标&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6653620352250489&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oQUHic2XyiaCC2RRd5Z9C3mQggsPpYXr0n7RrBzOaeiaD2AHWnUUCeibJiby49oAqT6PFPoduqG4Clon3j6ibgbx886w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;511&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;快速制作简单的 Icon&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Icon 通常就是一些图形和颜色组成。这篇文章介绍 &lt;span&gt;‍&lt;/span&gt;Sketch 中重点的绘制图形的方法，只要掌握了，就能快速的制作自&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;己设计的 Icon了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5714285714285714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/oQUHic2XyiaCC2RRd5Z9C3mQggsPpYXr0nBnkpnVZeejPlTka3mPOq4totuC1IQ6ibCG3p77QibciaB6TzqubwAcJOQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;绘制基本的图形和文字&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先了解一下 Sketch 基础功能&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; ：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.568359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/oQUHic2XyiaCC2RRd5Z9C3mQggsPpYXr0nJw2Gxo1icpwDE8fP5eKtpSpTnTicD4xicibqNNmTgL56nibz0gcjSMTf2JA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;绘制基本图形和文字&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;添加椭圆形&lt;span&gt; / &lt;/span&gt;圆形 【 O / Shift + O 】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;添加方形&lt;span&gt; / 方&lt;/span&gt;&lt;span&gt;形&lt;/span&gt;&lt;span&gt; &lt;/span&gt;【 R&lt;span&gt; / Shift + &lt;span&gt;R&lt;/span&gt;&lt;/span&gt; 】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;文字 【 T 】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;其他图形，比如直线和三角形，&lt;span&gt;【 置入 -&amp;gt; &lt;/span&gt;&lt;span&gt; 形状 】里选&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5676274944567627&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/oQUHic2XyiaCC2RRd5Z9C3mQggsPpYXr0nfLZ3UlyAmqiaiaJYb2FtdVw6VhKEsc1ib7gYhZUnIicOZ3XsVs3iaJt9upw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;902&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;绘制不规则的图形&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Icon 设计可能包含不规则的形状，比如箭头，曲线等。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;接下来的操作用于绘制这些不规则的图形。首先可以&lt;/span&gt;&lt;span&gt;利用锚点来调整图形的形状&lt;span&gt;【&lt;/span&gt;&lt;span&gt; 双击图形获得锚点&lt;/span&gt;&lt;span&gt; 】&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5676274944567627&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/oQUHic2XyiaCC2RRd5Z9C3mQggsPpYXr0nibOGOdEbG7ZMtEbNXHiarYsnNFuOObX5T5hk5FDW5pf8FJzOYexDK4Ng/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;902&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用蒙版功能【 Control + Cmd + M 】来裁剪图形，使用切片功能【 S 】切割图形。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5676274944567627&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/oQUHic2XyiaCC2RRd5Z9C3mQggsPpYXr0ngYcg7iaK7wbc1KGI8ibwCYjqNBh5ztJAnCmCaZ4SjZPx7CgoADicNYG5A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;902&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5676274944567627&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/oQUHic2XyiaCC2RRd5Z9C3mQggsPpYXr0nhBU5PEL2e8A2tzruYhWnONJxhdCoo8JZRpxgrvSTpic40fgVcDFAVCQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;902&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;strong&gt;还可以使用集联来合并图片：&lt;/strong&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;合并形状【 Alt + Cmd + U 】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;减去顶层形状【 Alt + Cmd + S 】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;保留重叠形状【 Alt + Cmd + I 】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;排除重叠形状 【 Alt + Cmd + X 】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5676274944567627&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/oQUHic2XyiaCC2RRd5Z9C3mQggsPpYXr0nHWZBMOYGUVNwYPxozNe86iaCZAdets06LefqSDbOH9te9qxGxF8giaVQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;902&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;使用设计师的图形来组装或参考&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;有一些拟物的图形可以直接使用网上设计师的图形来组装，或者参考重新绘制&lt;strong&gt;。可以把阿里巴巴 iconfont 里的图标直接拖进来组装。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.36036036036036034&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oQUHic2XyiaCC2RRd5Z9C3mQggsPpYXr0nqCYthYm5eaMPSNnicwYy6OsgyI2tntibfC1miaWhqM6dS6NXUKKYebiaYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1110&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;绘制图形很简单，所以重在设计 Icon。下一篇文章将介绍如何设计。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-mid=&quot;t22&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot; data-contenteditable=&quot;false&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; data-contenteditable=&quot;false&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;END&lt;/section&gt;&lt;section data-mid=&quot;&quot; data-contenteditable=&quot;false&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; data-contenteditable=&quot;false&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;往期回顾：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5OTk1ODA2Ng==&amp;amp;mid=2247484037&amp;amp;idx=1&amp;amp;sn=7180c82a511ccb4ecdd56e2da6455986&amp;amp;chksm=feadb5d8c9da3cce9cdb91acd7db787a65e58b868592174a2b412a5d9a8bd51b1f84f61cead6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;【第1期】&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《 独立开发者如何快速从 0 到 1 设计一款 App 的 Logo —— 配置 Sketch 工具&lt;/a&gt; 》&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5OTk1ODA2Ng==&amp;amp;mid=2247484037&amp;amp;idx=1&amp;amp;sn=7180c82a511ccb4ecdd56e2da6455986&amp;amp;chksm=feadb5d8c9da3cce9cdb91acd7db787a65e58b868592174a2b412a5d9a8bd51b1f84f61cead6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;【第1期】&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎扫码关注&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;独立开发者杂谈&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9603174603174603&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oQUHic2XyiaCAWtEPRq29Zbzib8hg74x5iaV8M2ibDWwxZ6FGegmgNm2zFwygKFE3Kubkib6cxGnbOkkcqWPuzmt1cfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;756&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;      喜欢本文，右下方点击 &lt;/span&gt;&lt;span&gt;在看&lt;/span&gt;&lt;span&gt;  &lt;span&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oQUHic2XyiaCArznuqiatf3WI5LibSqibZ12qtS4kAQSXib9ZD71WlSJ8siaNma4LlRlIWQjzyNxQPvWXFbV8zibyoEK2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;↓&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c95672284582be38f95a5cccee645b95</guid>
<title>[译] 如何优雅地关闭 Kubernetes 集群中的 Pod</title>
<link>https://toutiao.io/k/2n1unis</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文标题：Gracefully Shutting Down Pods in a Kubernetes Cluster&lt;/p&gt;&lt;p&gt;发布时间：Jan 26, 2019&lt;/p&gt;&lt;p&gt;原文链接：https://blog.gruntwork.io/zero-downtime-server-updates-for-your-kubernetes-cluster-902009df5b33&lt;/p&gt;&lt;p&gt;文章作者：yorinasub17&lt;/p&gt;&lt;/blockquote&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzNTY5MzU2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4pGhLz2xEbRFHnAQon2QLYgbBibCJo1ibJHesLWshPJeRibateRtAqkaf6BgjlbhYiaxHLq6Zu07CRPw/0?wx_fmt=png&quot; data-nickname=&quot;网管叨bi叨&quot; data-alias=&quot;kevin_tech&quot; data-signature=&quot;每周分享技术类原创文章&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我们实现 Kubernetes 集群零停机时间更新的第二部分。在本系列的&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247487176&amp;amp;idx=1&amp;amp;sn=e3cb877a897fa24320f1820ceb80c4d0&amp;amp;chksm=fa80df5fcdf75649c1d517fabd265b37408654917bf6dfe8ffb35625387d0aef23e5516c0fe8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第一部分中&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;第一部分中&lt;/a&gt;，我们列举出了简单粗暴地使用&lt;code&gt;kubectl drain&lt;/code&gt; 命令清除集群节点上的 Pod 的问题和挑战。在这篇文章中，我们将介绍解决这些问题和挑战的手段之一：优雅地关闭 Pod。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Pod驱逐的生命周期&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，&lt;code&gt;kubectl drain&lt;/code&gt;命令驱逐节点上的 Pod 时会遵循 Pod 的生命周期，这意味着整个过程会遵守以下规则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;kubectl drain&lt;/code&gt;将向控制中心发出删除目标节点上的 Pod 的请求。随后，请求将通知目标节点上的 &lt;code&gt;kubelet&lt;/code&gt; 开始关闭 Pod。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点上的&lt;code&gt;kubelet&lt;/code&gt; 将会调用 Pod 里的 &lt;code&gt;preStop&lt;/code&gt; 钩子。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当 &lt;code&gt;preStop&lt;/code&gt; 钩子执行完成后，节点上的&lt;code&gt;kubelet&lt;/code&gt; 会向Pod容器中运行的程序发送 &lt;code&gt;TERM&lt;/code&gt;信号 （SIGTERM）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点上的&lt;code&gt;kubelet&lt;/code&gt;将最多等待指定的宽限期（在pod上指定，或从命令行传入；默认为30秒）然后关闭容器，然后强行终止进程（使用SIGKILL）。注意，这个宽限期包括执行 &lt;code&gt;preStop&lt;/code&gt;钩子的时间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;译注：Kubelet 终止Pod前的等待宽限期有两种方式指定&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在Pod定义里通过Pod模板的spec.terminationGracePeriodSeconds 设定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;kubectl delete pod {podName} --grace-period=60&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于此流程，我们可以利用应用程序 Pod 中的&lt;code&gt;preStop&lt;/code&gt;钩子和信号处理来正常关闭应用程序，以便在最终终止应用程序之前对其进行“清理”。例如，假如有一个工作进程从队列中读取信息然后处理任务，我们可以让应用程序捕获 TERM 系统信号，以指示该应用程序应停止接受新任务，并在所有当前任务完成后停止运行。或者，如果运行的应用程序无法修改以捕获 TERM 信号（例如第三方应用程序），则可以使用&lt;code&gt;preStop&lt;/code&gt;钩子来实现该服务提供的自定义API，来正常关闭应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的示例中，Nginx 默认情况下不能处理 TERM 信号，因此，我们将改为依靠 Pod 的 &lt;code&gt;preStop&lt;/code&gt;钩子实现正常停止Nginx。我们将修改资源定义，将生命周期钩子添加到容器的&lt;code&gt;spec&lt;/code&gt;定义中，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;lifecycle:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;preStop:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;exec:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;command:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# Gracefully shutdown nginx&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;/usr/sbin/nginx&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;-s&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;quit&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用此配置后，在将 TERM 信号发送给容器中的Nginx进程之前，&lt;code&gt;kebulet&lt;/code&gt; 调用 Pod 的生命周期钩子发出命令 &lt;code&gt;/ usr / sbin / nginx -s quit&lt;/code&gt;。请注意，由于该命令将会正常停止 Nginx 进程和 Pod，因此 TERM 信号实际上在这个例子中是一个空操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在定义文件添加了生命周期钩子后，整个 Deployment 资源的定义变成了下面这样&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;apps/v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Deployment&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;nginx-deployment&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;nginx&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;replicas:&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;nginx&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;template:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;nginx&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;nginx&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;nginx:1.15&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;containerPort:&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;lifecycle:&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;preStop:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;exec:&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;command:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;# Gracefully shutdown nginx&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&quot;/usr/sbin/nginx&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;-s&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;quit&quot;&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;停机后的后续流量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用上面的&lt;code&gt;preStop&lt;/code&gt;钩子正常关闭 Pod 可以确保 Nginx 在处理完现存流量有才会停止。但是，你可能会发现，Nginx 容器在关闭后仍会继续接收到流量，从而导致服务出现停机时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了了解造成这个问题的原因，让我们来看一个示例图。假定该节点已接收到来自客户端的流量。应用程序会产生一个工作线程来处理请求。我们用在 Nginx Pod 示例图内的圆圈表示该工作线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8378378378378378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f5khlYtJDtMLXRb4XfQ6lFdGzD5F8Cq7yt2SibA6g7CWAUNGo3mLQSnWoVicRhTlrQvhKBhrwLcQXxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;740&quot;/&gt;&lt;figcaption&gt;正在处理请求的Nginx&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设在工作线程处理请求的同时，集群的运维人员决定对 &lt;code&gt;Node1&lt;/code&gt; 进行维护。运维运行了&lt;code&gt;kubectl drain node-1&lt;/code&gt; 后，节点上的&lt;code&gt;kubelet&lt;/code&gt; 会执行 Pod 设置的&lt;code&gt;preStop&lt;/code&gt;钩子，开始进入Nginx进程正常关闭的流程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8157894736842105&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f5khlYtJDtMLXRb4XfQ6lFdKIItj2t6HibFwVJicc7r2CNx4aCDibdicsygk0bSh1KyRKdmQ4n9EmZpLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;figcaption&gt;对节点进行维护，清出节点上的Pod时会先执行preStop钩子&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 Nginx 仍要处理已存流量的请求，所以进入正常关闭流程后 Nginx 不会马上终止进程，但是会拒绝处理后续到达的流量，向新请求返回错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个时间点，假设一个新的服务请求到达了 Pod 上层的 Service，因为此时 Pod 仍然是上层 Service 的Endpoint，所以这个即将关闭的 Pod 仍然可能会接收到 Service 分发过来的请求。如果 Pod 真的接收到了分发过来的新请求 Nginx 就会拒绝处理并返回错误。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;译注：推荐阅读&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486082&amp;amp;idx=1&amp;amp;sn=42a9bc8fcfc9da09445e9e2f4cf2fb96&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;学练结合快速掌握K8s Service控制器&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8378378378378378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f5khlYtJDtMLXRb4XfQ6lFdnNo8J18erYvwnEVN2MVe1j00V8f3S2E8GTicK0iaUzKcweEFXCngK9Qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;740&quot;/&gt;&lt;figcaption&gt;Nginx处于关闭流程时会拒绝新来的请求&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终 Nginx 将完成对原始已存请求的处理，随后&lt;code&gt;kubelet&lt;/code&gt;会删除 Pod，节点完成排空。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8918918918918919&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f5khlYtJDtMLXRb4XfQ6lFdLuGgKnzyn9N4K8LMHQyJuQC3Pa8maGrm8A3hGabsNlicE3wu06aPT5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;740&quot;/&gt;&lt;figcaption&gt;Nginx 处理完已存请求后终止进程&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8918918918918919&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f5khlYtJDtMLXRb4XfQ6lFdW5Wz32ZcicQexbadl3cZ710nJTRz4nsOQvbJLEV805wY27UbX4Bvwfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;740&quot;/&gt;&lt;figcaption&gt;Pod停止运行，kubelet删除Pod&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么会这样呢？如何避免在Pod执行关闭期间接受到来自客户端的请求呢？在本系列的下一部分中，我们会更详细地介绍 Pod 的生命周期，并给出如何在 &lt;code&gt;preStop&lt;/code&gt; 钩子中引入延迟为 Pod 进行摘流，以减轻来自 Service 的后续流量的影响。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>