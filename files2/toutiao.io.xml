<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5d738bdebbd0404b17fdb90c48adca36</guid>
<title>面试字节，被操作系统问挂了</title>
<link>https://toutiao.io/k/8r0yjir</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，鄙人三某，不善面试。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标题是真事，感觉凉了，难受，爬起来整理了一波操作系统面试题，下次一定……&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引论&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是操作系统？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以这么说，操作系统是一种运行在内核态的软件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是应用程序和硬件之间的媒介，向应用程序提供硬件的抽象，以及管理硬件资源。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42319508448540705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoxTu62pksR9IhVYM0Dj4uF4gFCdKljbzwKYPFMNlLwWias3vsichjKqpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1302&quot;/&gt;&lt;figcaption&gt;操作系统是什么&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;操作系统主要有哪些功能？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统最主要的功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;处理器（CPU）管理：CPU的管理和分配，主要指的是进程管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存管理：内存的分配和管理，主要利用了虚拟内存的方式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;外存管理：外存（磁盘等）的分配和管理，将外存以文件的形式提供出去。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;I/O管理：对输入/输出设备的统一管理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还有保证自身正常运行的健壮性管理，防止非法操作和入侵的安全性管理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5074626865671642&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoPPBNsZuWicicrrj2PHonNV6SGtTNLdEeNtGXaGm8OLicYibdlibXQgdQe9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;figcaption&gt;操作系统主要功能&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;操作系统结构&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是内核？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以这么说，内核是一个计算机程序，它是操作系统的核心，提供了操作系统最核心的能力，可以控制操作系统中所有的内容。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是用户态和内核态？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核具有很⾼的权限，可以控制 cpu、内存、硬盘等硬件，出于权限控制的考虑，因此⼤多数操作系统，把内存分成了两个区域：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内核空间，这个内存空间只有内核程序可以访问；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;⽤户空间，这个内存空间专⻔给应⽤程序使⽤，权限比较小；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⽤户空间的代码只能访问⼀个局部的内存空间，⽽内核空间的代码可以访问所有内存空间。因此，当程序使⽤⽤户空间时，我们常说该程序在&lt;strong&gt;⽤户态&lt;/strong&gt;执⾏，⽽当程序使内核空间时，程序则在&lt;strong&gt;内核态&lt;/strong&gt;执⾏。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用户态和内核态是如何切换的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应⽤程序如果需要进⼊内核空间，就需要通过系统调⽤，来进入内核态：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26560587515299877&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEo77ibaVtZtMsZ7Nsa1QERoMyibNsibBm0C6fIqwMSBXJRYpKpwjibl8xhXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;817&quot;/&gt;&lt;figcaption&gt;用户态&amp;amp;内核态切换&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核程序执⾏在内核态，⽤户程序执⾏在⽤户态。当应⽤程序使⽤系统调⽤时，会产⽣⼀个中断。发⽣中断后， CPU 会中断当前在执⾏的⽤户程序，转⽽跳转到中断处理程序，也就是开始执⾏内核程序。内核处理完后，主动触发中断，把 CPU 执⾏权限交回给⽤户程序，回到⽤户态继续⼯作。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进程和线程&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并行和并发有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器做到的并发，其实是利用时间片的轮转，例如有两个进程A和B，A运行一个时间片之后，切换到B，B运行一个时间片之后又切换到A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48431618569636137&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoDCY0kqsGsA3cNKXtHQUTD7expllKNynWnFuRcVYxUkJAFfPIhuR5cA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;797&quot;/&gt;&lt;figcaption&gt;并发和并行&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是进程上下文切换？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。上下文切换 (Context Switch) 是一种将 CPU 资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26230975828111014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoRZQRtTgib0CmutRhY7jULVwSnpaVxl9wQibHpEK9YtyAbayia0oIgFJ4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1117&quot;/&gt;&lt;figcaption&gt;进程上下文切换-来源参考[3]&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进程有哪些状态？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个进程开始运行时，它可能会经历下面这几种状态：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图中各个状态的意义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;运⾏状态（&lt;em&gt;Runing&lt;/em&gt;）：该时刻进程占⽤ CPU；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;就绪状态（&lt;em&gt;Ready&lt;/em&gt;）：可运⾏，由于其他进程处于运⾏状态⽽暂时停⽌运⾏；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞状态（&lt;em&gt;Blocked&lt;/em&gt;）：该进程正在等待某⼀事件发⽣（如等待输⼊/输出操作的完成）⽽暂时停⽌运⾏，这时，即使给它CPU控制权，它也⽆法运⾏；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46621621621621623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEo5QiapSJebBfxxYXshk9uRRspZ0DAib5Az1lLFFypIpf7aqDuwNiawlNicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;592&quot;/&gt;&lt;figcaption&gt;进程3种状态&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，进程还有另外两个基本状态：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建状态（&lt;em&gt;new&lt;/em&gt;）：进程正在被创建时的状态；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结束状态（&lt;em&gt;Exit&lt;/em&gt;）：进程正在从系统中消失时的状态；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.313588850174216&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoxwxNW1wkdJ8QblQWbgVV4JWYodsp2mGcsNXY63EVEE4ibE6xglHsTlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;figcaption&gt;进程5种状态&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是僵尸进程？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;僵尸进程是已完成且处于终止状态，但在进程表中却仍然存在的进程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;僵尸进程一般发生有父子关系的进程中，一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是孤儿进程？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 init 进程 (进程 ID 为 1 的进程) 所收养，并由 init 进程对它们完成状态收集工作。因为孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进程有哪些调度算法？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程调度就是确定某一个时刻CPU运行哪个进程，常见的进程调度算法有：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.815442561205273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEo3Cpgusw1XryYGLce8HfkXaTicup1IvALo3dwXYkqrZWLuaddjCnqzvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;531&quot;/&gt;&lt;figcaption&gt;进程调度算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对I/O密集型进程也不利，因为这种进程每次进行I/O操作之后又得重新排队。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23143164693218515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEolCfONuicsziaoTs4YHakjzaWWZmnSrsMzezT0VXZ8JLtAgF2X7tPtxyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;929&quot;/&gt;&lt;figcaption&gt;先来先服务&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2682602921646746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEotBk4e2SoThWwDKrPJTHDzSaX8BE3nNNb2CznMS3TFXchyKZ05UPAlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;753&quot;/&gt;&lt;figcaption&gt;短作业优先&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.31097560975609756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEokxzibTzHt6uVudebvQVtc8pNabicy4iamlqMcfemA0fhCOTaxyyBPyXFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot;/&gt;&lt;figcaption&gt;优先级调度&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将所有就绪进程按 先来先服务的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30099857346647646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoYzWJAAK3pyf2jgibCyib8iaPibLflm6PmfUvSW3cD74pWIdJZvmb7GJOHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;701&quot;/&gt;&lt;figcaption&gt;时间片轮转&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进程间通信有哪些方式？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.967654986522911&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEom0Le30dzxEPyZglelFL8ubySOGV7TiaAvhZrBXIka1ibBX907kia7ouZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;371&quot;/&gt;&lt;figcaption&gt;进程间通信方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;管道：管道可以理解成不同进程之间的对白，一方发声，一方接收，声音的介质可是是空气或者电缆，进程之间就可以通过管道，&lt;strong&gt;所谓的管道就是内核中的一串缓存&lt;/strong&gt;，从管道的一端写入数据，就是缓存在了内核里，另一端读取，也是从内核中读取这段数据。&lt;/p&gt;&lt;p&gt;管道可以分为两类：&lt;strong&gt;匿名管道&lt;/strong&gt;和&lt;strong&gt;命名管道&lt;/strong&gt;。匿名管道是单向的，只能在有亲缘关系的进程间通信；命名管道是双向的，可以实现本机任意两个进程通信。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5346938775510204&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEopqykia4qGbFPbFxN2BlwFIZmVEepu3boT1eUv7EUYbMNTR2NZksU4fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;735&quot;/&gt;&lt;figcaption&gt;“奉先我儿”&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;信号 ：信号可以理解成一种电报，发送方发送内容，指定接收进程，然后发出特定的软件中断，操作系统接到中断请求后，找到接收进程，通知接收进程处理信号。&lt;/p&gt;&lt;p&gt;比如&lt;code&gt;kill -9 1050&lt;/code&gt;就表示给PID为1050的进程发送&lt;code&gt;SIGKIL&lt;/code&gt;信号。Linux系统中常用信号：&lt;/p&gt;&lt;p&gt;（1）SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。&lt;span&gt;（2）SIGINT：&lt;/span&gt;&lt;span&gt;程序终止信号。&lt;/span&gt;&lt;span&gt;程序运行过程中，按Ctrl+C键将产生该信号。&lt;/span&gt;&lt;span&gt;（3）SIGQUIT：&lt;/span&gt;&lt;span&gt;程序退出信号。&lt;/span&gt;&lt;span&gt;程序运行过程中，按Ctrl+\键将产生该信号。&lt;/span&gt;&lt;span&gt;（4）SIGBUS和SIGSEGV：&lt;/span&gt;&lt;span&gt;进程访问非法地址。&lt;/span&gt;&lt;span&gt;（5）SIGFPE：&lt;/span&gt;&lt;span&gt;运算中出现致命错误，如除零操作、数据溢出等。&lt;/span&gt;&lt;span&gt;（6）SIGKILL：&lt;/span&gt;&lt;span&gt;用户终止进程执行信号。&lt;/span&gt;&lt;span&gt;shell下执行kill -9发送该信号。&lt;/span&gt;&lt;span&gt;（7）SIGTERM：&lt;/span&gt;&lt;span&gt;结束进程信号。&lt;/span&gt;&lt;span&gt;shell下执行kill 进程pid发送该信号。&lt;/span&gt;&lt;span&gt;（8）SIGALRM：&lt;/span&gt;&lt;span&gt;定时器信号。&lt;/span&gt;&lt;span&gt;（9）SIGCLD：&lt;/span&gt;&lt;span&gt;子进程退出信号。&lt;/span&gt;&lt;span&gt;如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;消息队列：&lt;strong&gt;消息队列就是保存在内核中的消息链表&lt;/strong&gt;，包括Posix消息队列和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27816411682892905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoL6mUvfU7LytnzXhQrVaQmORTpNsbhBaibiadZytzYWdrDZVkO4MQbX9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;719&quot;/&gt;&lt;figcaption&gt;消息队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;共享内存：&lt;strong&gt;共享内存的机制，就是拿出⼀块虚拟地址空间来，映射到相同的物理内存中&lt;/strong&gt;。这样这个进程写⼊的东西，另外的进程⻢上就能看到。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4715762273901809&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoBicZye5KkVFRDI2s1jb7ib0qdH1m27mBDrDKmIicY8qWQAbibZ8sTLRGtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;&lt;figcaption&gt;共享内存&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;信号量：信号量我们可以理解成红绿灯，红灯行，绿灯停。&lt;strong&gt;它本质上是一个整数计数器&lt;/strong&gt;，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。&lt;/p&gt;&lt;p&gt;信号量表示资源的数量，控制信号量的⽅式有两种原⼦操作：&lt;/p&gt;&lt;p&gt;P 操作是⽤在进⼊共享资源之前，V 操作是⽤在离开共享资源之后，这两个操作是必须成对出现的。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4957118353344768&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEocU7cElKoicovE5P94VZNLkAnDNib3OI6erdibibn1k6lFfiaFU8T1lNnfXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;583&quot;/&gt;&lt;figcaption&gt;信号量&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;⼀个是 &lt;strong&gt;P&lt;/strong&gt; &lt;strong&gt;操作&lt;/strong&gt;，这个操作会把信号量减去 1，相减后如果信号量 &amp;lt; 0，则表明资源已被占⽤，进程需阻塞等待；相减后如果信号量 &amp;gt;= 0，则表明还有资源可使⽤，进程可正常继续执⾏。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另⼀个是 &lt;strong&gt;V&lt;/strong&gt; &lt;strong&gt;操作&lt;/strong&gt;，这个操作会把信号量加上 1，相加后如果信号量 &amp;lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运⾏；相加后如果信号量 &amp;gt; 0，则表明当前没有阻塞中的进程；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Socket：与其他通信机制不同的是，它可用于不同机器间的进程通信。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;管道：简单；效率低，容量有限；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息队列：不及时，写入和读取需要用户态、内核态拷贝。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;共享内存区：能够很容易控制容量，速度快，但需要注意不同进程的同步问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;信号量：不能传递复杂消息，一般用来实现进程间的同步；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;信号：它是进程间通信的唯一异步机制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Socket：用于不同主机进程间的通信。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进程和线程的联系和区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程和进程的联系：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程是进程当中的⼀条执⾏流程。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同⼀个进程内多个线程之间可以共享代码段、数据段、打开的⽂件等资源，但每个线程各⾃都有⼀套独⽴的寄存器和栈，这样可以确保线程的控制流是相对独⽴的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.93342776203966&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoT1UGvYoYzT9hCmYS2lZKGicq5Sr6kibjNIwica4vjvH2JKKPxZHialQL1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;706&quot;/&gt;&lt;figcaption&gt;多线程-来源参考[3]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程与进程的⽐较如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调度：&lt;strong&gt;进程是资源（包括内存、打开的⽂件等）分配的单位&lt;/strong&gt;，&lt;strong&gt;线程是 CPU 调度的单位&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;资源：进程拥有⼀个完整的资源平台，⽽线程只独享必不可少的资源，如寄存器和栈；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拥有资源：线程同样具有就绪、阻塞、执⾏三种基本状态，同样具有状态之间的转换关系；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统开销：线程能减少并发执⾏的时间和空间开销——创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线程上下文切换了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这还得看线程是不是属于同⼀个进程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当两个线程不是属于同⼀个进程，则切换的过程就跟进程上下⽂切换⼀样；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;当两个线程是属于同⼀个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据&lt;/strong&gt;；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，线程的上下⽂切换相⽐进程，开销要⼩很多。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线程有哪些实现方式？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有三种线程的实现⽅式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内核态线程实现&lt;/strong&gt;：在内核空间实现的线程，由内核直接管理直接管理线程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6676384839650146&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoAvkrHK0sOeHmYd33Y3uvDnjtwJ8O8FbZZ8HmIfXZNAcOsVbUibvUwXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;686&quot;/&gt;&lt;figcaption&gt;内核态线程实现&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;⽤户态线程实现&lt;/strong&gt;：在⽤户空间实现线程，不需要内核的参与，内核对线程无感知。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7121879588839941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoBbgM8T5rQQHebOM9Cz9m6N5xwO1piarViaLiar3AUYmaiaERpBk2ZF66dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;figcaption&gt;用户态线程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;混合线程实现&lt;/strong&gt;：现代操作系统基本都是将两种方式结合起来使用。用户态的执行系统负责进程内部线程在非阻塞时的切换；内核态的操作系统负责阻塞线程的切换。即我们同时实现内核态和用户态线程管理。其中内核态线程数量较少，而用户态线程数量较多。每个内核态线程可以服务一个或多个用户态线程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6129458388375165&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEofqiaYEXUXrXibicEdOFicIj5Egc46lj7FiacBaZ66v9BNv0RfjuCMpNafgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;757&quot;/&gt;&lt;figcaption&gt;混合线程实现&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线程间如何同步？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步解决的多线程操作共享资源的问题，目的是不管线程之间的执行如何穿插，最后的结果都是正确的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们前面知道线程和进程的关系：线程是进程当中的⼀条执⾏流程。所以说下面的一些同步机制不止针对线程，同样也可以针对进程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;临界区&lt;/strong&gt;：我们把对共享资源访问的程序片段称为&lt;code&gt;临界区&lt;/code&gt;，我们希望这段代码是&lt;code&gt;互斥&lt;/code&gt;的，保证在某时刻只能被一个线程执行，也就是说一个线程在临界区执行时，其它线程应该被阻止进入临界区。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5069967707212056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoO1hlY8JL70hjsZU9xNMMLq59Z7ficoN2H7Q9leLW0nRfPk2C9MEPpUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;929&quot;/&gt;&lt;figcaption&gt;临界区互斥-来源参考[3]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;临界区不仅针对线程，同样针对进程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;临界区同步的一些实现方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、&lt;strong&gt;锁&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使⽤加锁操作和解锁操作可以解决并发线程/进程的互斥问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任何想进⼊临界区的线程，必须先执⾏加锁操作。若加锁操作顺利通过，则线程可进⼊临界区；在完成对临界资源的访问后再执⾏解锁操作，以释放该临界资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁和解锁锁住的是什么呢？可以是&lt;code&gt;临界区对象&lt;/code&gt;，也可以只是一个简单的&lt;code&gt;互斥量&lt;/code&gt;，例如互斥量是&lt;code&gt;0&lt;/code&gt;无锁，&lt;code&gt;1&lt;/code&gt;表示加锁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1025236593059937&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoz2SQQXusSM30kUFyeuVnTnyibffJJUKn6xrkjJFgdPOean11a8DUpEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;634&quot;/&gt;&lt;figcaption&gt;加锁和解锁-来源参考[3]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据锁的实现不同，可以分为&lt;code&gt;忙等待锁和&lt;/code&gt;和&lt;code&gt;⽆忙等待锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;忙等待锁和&lt;/code&gt;就是加锁失败的线程，会不断尝试获取锁，也被称为自旋锁，它会一直占用CPU。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;⽆忙等待锁&lt;/code&gt;就是加锁失败的线程，会进入阻塞状态，放弃CPU，等待被调度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、&lt;strong&gt;信号量&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;信号量是操作系统提供的⼀种协调共享资源访问的⽅法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常&lt;strong&gt;信号量表示资源的数量&lt;/strong&gt;，对应的变量是⼀个整型（ sem ）变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，还有&lt;strong&gt;两个原⼦操作的系统调⽤函数来控制信号量的&lt;/strong&gt;，分别是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;P&lt;/em&gt; 操作：将 sem 减 1 ，相减后，如果 sem &amp;lt; 0 ，则进程/线程进⼊阻塞等待，否则继续，表明 P操作可能会阻塞；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;V&lt;/em&gt; 操作：将 sem 加 1 ，相加后，如果 sem &amp;lt;= 0 ，唤醒⼀个等待中的进程/线程，表明 V 操作不会阻塞；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;P 操作是⽤在进⼊临界区之前，V 操作是⽤在离开临界区之后，这两个操作是必须成对出现的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是死锁？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在两个或者多个并发线程中，如果每个线程持有某种资源，而又等待其它线程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组线程产生了死锁。通俗的讲就是两个或多个线程无限期的阻塞、相互等待的一种状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5826086956521739&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoKsVuMS0828R0TDnVzMesn0tt1kfVoALzibE5cF07oNibASwUQmmqYkqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;575&quot;/&gt;&lt;figcaption&gt;死锁&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;死锁产生有哪些条件？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁产生需要&lt;strong&gt;同时&lt;/strong&gt;满足四个条件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;互斥条件&lt;/strong&gt;：指线程对己经获取到的资源进行它性使用，即该资源同时只由一个线程占用。如果此时还有其它线程请求获取获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;请求并持有条件&lt;/strong&gt;：指一个 线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞 的同时并不释放自己已经获取的资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不可剥夺条件&lt;/strong&gt;：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才由自己释放该资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;环路等待条件&lt;/strong&gt;：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合 {T0，T1，T2,…… ，Tn} 中 T0 正在等待一 T1 占用的资源，Tl1正在等待 T2用的资源，…… Tn 在等待己被 T0占用的资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何避免死锁呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产⽣死锁的有四个必要条件：互斥条件、持有并等待条件、不可剥夺条件、环路等待条件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免死锁，破坏其中的一个就可以。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消除互斥条件&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是没法实现，因为很多资源就是只能被一个线程占用，例如锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消除请求并持有条件&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消除这个条件的办法很简单，就是一个线程一次请求其所需要的所有资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消除不可剥夺条件&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可剥夺这个条件就破坏掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消除环路等待条件&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;活锁和饥饿锁了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;饥饿锁：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;饥饿锁，这个饥饿指的是资源饥饿，某个线程一直等不到它所需要的资源，从而无法向前推进，就像一个人因为饥饿无法成长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;活锁：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在活锁状态下，处于活锁线程组里的线程状态可以改变，但是整个活锁组的线程无法推进。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;活锁可以用两个人过一条很窄的小桥来比喻：为了让对方先过，两个人都往旁边让，但两个人总是让到同一边。这样，虽然两个人的状态一直在变化，但却都无法往前推进。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内存管理&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是虚拟内存？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们实际的物理内存主要是主存，但是物理主存空间有限，所以一般现代操作系统都会想办法把一部分内存块放到磁盘中，用到的时候再装入主存，但是对用户程序而言，是不需要注意实际的物理内存的，为什么呢？因为有&lt;code&gt;虚拟内存&lt;/code&gt;的机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;简单说，虚拟内存是操作系统提供的⼀种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个进程都有自己独立的地址空间，再由操作系统映射到到实际的物理内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，这⾥就引出了两种地址的概念：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序所使⽤的内存地址叫做&lt;strong&gt;虚拟内存地址&lt;/strong&gt;（&lt;em&gt;Virtual Memory Address&lt;/em&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际存在硬件⾥⾯的空间地址叫&lt;strong&gt;物理内存地址&lt;/strong&gt;（&lt;em&gt;Physical Memory Address&lt;/em&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7195945945945946&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoZNBL2ZttkwcIDX97UWBThKqmPm8dasZp2vzgkRI1S156IoJLr5wFsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot;/&gt;&lt;figcaption&gt;虚拟内存&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是内存分段？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序是由若⼲个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就⽤分段（Segmentation）的形式把这些段分离出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分段机制下的虚拟地址由两部分组成，&lt;strong&gt;段号&lt;/strong&gt;和&lt;strong&gt;段内偏移量&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟地址和物理地址通过段表映射，段表主要包括&lt;strong&gt;段号&lt;/strong&gt;、&lt;code&gt;段的界限&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5433628318584071&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoexSt96UUxkXMZCG96RdmrveQjxmDG91AT1EXdYMQaOlf1Np1YbKicicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1130&quot;/&gt;&lt;figcaption&gt;虚拟地址、段表、物理地址&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一个映射，虚拟地址：段3、段偏移量500  ----&amp;gt;  段基地址7000+段偏移量500 ----&amp;gt; 物理地址：7500。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3582089552238806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoQ0Bre0nfIlTvh7oFvsibZw8Ba2QSJlIga5iazN7XkvtETsxQROcjLuwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;figcaption&gt;段虚拟地址映射&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是内存分页？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分⻚是把整个虚拟和物理内存空间切成⼀段段固定尺⼨的⼤⼩&lt;/strong&gt;。这样⼀个连续并且尺⼨固定的内存空间，我们叫&lt;strong&gt;⻚&lt;/strong&gt;（&lt;em&gt;Page&lt;/em&gt;）。在 Linux 下，每⼀⻚的⼤⼩为 4KB 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问分页系统中内存数据需要两次的内存访问 ：一次是从内存中访问页表，从中找到指定的物理页号，加上页内偏移得到实际物理地址，第二次就是根据第一次得到的物理地址访问内存取出数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5846994535519126&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEohXStPFN3FC7icQiaSc13ypeMZux3ddOBbleuQ7cfamcP89rVI0HcLAYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1098&quot;/&gt;&lt;figcaption&gt;内存分页&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多级页表知道吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统可能会有非常多进程，如果只是使用简单分页，可能导致的后果就是页表变得非常庞大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，引入了多级页表的解决方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的多级页表，就是把我们原来的单级页表再次分页，这里利用了&lt;code&gt;局部性原理&lt;/code&gt;，除了顶级页表，其它级别的页表一来可以在需要的时候才被创建，二来内存紧张的时候还可以被置换到磁盘中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7172717271727173&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEojBXlWA5z6TwoZ6MMUP68LXnibJMtibk0CofNKbDmlz0CsnRBps3zEKhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;909&quot;/&gt;&lt;figcaption&gt;多级页表示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是块表？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样利用了&lt;code&gt;局部性原理&lt;/code&gt;，即在⼀段时间内，整个程序的执⾏仅限于程序中的某⼀部分。相应地，执⾏所访问的存储空间也局限于某个内存区域。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利⽤这⼀特性，把最常访问的⼏个⻚表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯⽚中，加⼊了⼀个专⻔存放程序最常访问的⻚表项的 Cache，这个 Cache 就是 TLB（&lt;em&gt;Translation Lookaside Buffer&lt;/em&gt;） ，通常称为⻚表缓存、转址旁路缓存、快表等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5301866081229418&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEovSC3ErmCn2LX2qgqVC6WJicicV0equGP4EW7oMYMFjj2xibMAOGJsO6TQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot;/&gt;&lt;figcaption&gt;TLB示意图-来源参考[3]&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分页和分段有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;段的大小不固定，有它所完成的功能决定；页的大小固定，由系统决定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;段向用户提供二维地址空间；页向用户提供的是一维地址空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是交换空间？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统把物理内存(Physical RAM)分成一块一块的小内存，每一块内存被称为页(page)。当内存资源不足时，Linux把某些页的内容转移至磁盘上的一块空间上，以释放内存空间。磁盘上的那块空间叫做交换空间(swap space),而这一过程被称为交换(swapping)。物理内存和交换空间的总容量就是虚拟内存的可用容量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用途：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;物理内存不足时一些不常用的页可以被交换出去，腾给系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序启动时很多内存页被用来初始化，之后便不再需要，可以交换出去。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;页面置换算法有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分页系统里，一个虚拟的页面可能在主存里，也可能在磁盘中，如果CPU发现虚拟地址对应的物理页不在主存里，就会产生一个缺页中断，然后从磁盘中把该页调入主存中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果内存里没有空间，就需要从主存里选择一个页面来置换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的页面置换算法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7950819672131147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoxNE8jkH4Vgl2K49VvjmI9uV95YvIUUOM6aOicN1FGdctDbgRRyGfWWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;488&quot;/&gt;&lt;figcaption&gt;常见页面置换算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最佳⻚⾯置换算法是一个理想的算法，基本思路是，&lt;strong&gt;置换在未来最⻓时间不访问的⻚⾯&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，该算法实现需要计算内存中每个逻辑⻚⾯的下⼀次访问时间，然后⽐较，选择未来最⻓时间不访问的⻚⾯。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这个算法是无法实现的，因为当缺页中断发生时，操作系统无法知道各个页面下一次将在什么时候被访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然我们⽆法预知⻚⾯在下⼀次访问前所需的等待时间，那可以&lt;strong&gt;选择在内存驻留时间很⻓的⻚⾯进⾏中置换&lt;/strong&gt;，这个就是「先进先出置换」算法的思想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FIFO的实现机制是使用链表将所有在内存的页面按照进入时间的早晚链接起来，然后每次置换链表头上的页面就行了，新加进来的页面则挂在链表的末端。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28725961538461536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEor9puwtlicPXicOfK3xK80bNp8xImGCA2bG5L62BQ4pibSFLtIUcUFvGNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;832&quot;/&gt;&lt;figcaption&gt;按照进入内存早晚构建的页面链表&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近最久未使⽤（&lt;em&gt;LRU&lt;/em&gt;）的置换算法的基本思路是，发⽣缺⻚时，&lt;strong&gt;选择最⻓时间没有被访问的⻚⾯进⾏置换&lt;/strong&gt;，也就是说，该算法假设已经很久没有使⽤的⻚⾯很有可能在未来较⻓的⼀段时间内仍然不会被使⽤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种算法近似最优置换算法，最优置换算法是通过「未来」的使⽤情况来推测要淘汰的⻚⾯，⽽ LRU 则是通过&lt;code&gt;历史&lt;/code&gt;的使⽤情况来推测要淘汰的⻚⾯。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LRU 在理论上是可以实现的，但代价很⾼。为了完全实现 LRU，需要在内存中维护⼀个所有⻚⾯的链表，最近最多使⽤的⻚⾯在表头，最近最少使⽤的⻚⾯在表尾。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4508990318118949&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoURoKlicKKpAT72iatp3tqTOyfnkFfBkiaAqicM7lMNhXuP5D3EVUyAcI1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;723&quot;/&gt;&lt;figcaption&gt;LRU实现&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;困难的是，在每次访问内存时都必须要更新整个链表。在链表中找到⼀个⻚⾯，删除它，然后把它移动到表头是⼀个⾮常费时的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，LRU 虽然看上去不错，但是由于开销⽐较⼤，实际应⽤中⽐较少使⽤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个算法的思路是，把所有的⻚⾯都保存在⼀个类似钟⾯的环形链表中，⼀个表针指向最⽼的⻚⾯。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7508196721311475&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoiabjnC6dYe8mx0JSpKl97Y4AP5TbYIzAOVpAh606MTPHrngsCp5MEag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;915&quot;/&gt;&lt;figcaption&gt;时钟页面置换算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当发⽣缺⻚中断时，算法⾸先检查表针指向的⻚⾯：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果它的访问位位是 0 就淘汰该⻚⾯，并把新的⻚⾯插⼊这个位置，然后把表针前移⼀个位置；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果访问位是 1 就清除访问位，并把表针前移⼀个位置，重复这个过程直到找到了⼀个访问位为 0 的⻚⾯为⽌；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最不常用算法（LFU），&lt;strong&gt;当发⽣缺⻚中断时，选择访问次数最少的那个⻚⾯，将其置换&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的实现⽅式是，对每个⻚⾯设置⼀个「访问计数器」，每当⼀个⻚⾯被访问时，该⻚⾯的访问计数器就累加 1。在发⽣缺⻚中断时，淘汰计数器值最⼩的那个⻚⾯。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;文件&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;硬链接和软链接有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;硬链接就是在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。删除任意一个条目，文件还是存在，只要引用数量不为 0。但是硬链接有限制，它不能跨越文件系统，也不能对目录进行链接。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5485278080697928&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEox70YgKdNiaVY7FDAa6sSPpRiceQFCQkacrFEJKbBh4ZKZgH0AovTqAbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;917&quot;/&gt;&lt;figcaption&gt;硬链接-来源参考[3]&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;软链接相当于重新创建⼀个⽂件，这个⽂件有&lt;strong&gt;独⽴的&lt;/strong&gt; &lt;strong&gt;inode&lt;/strong&gt;，但是这个&lt;strong&gt;⽂件的内容是另外⼀个⽂件的路径&lt;/strong&gt;，所以访问软链接的时候，实际上相当于访问到了另外⼀个⽂件，所以&lt;strong&gt;软链接是可以跨⽂件系统的&lt;/strong&gt;，甚⾄&lt;strong&gt;⽬标⽂件被删除了，链接⽂件还是在的，只不过打不开指向的文件了而已。&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5226781857451404&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEol5rAvpsfQ07cB2Hibv0Wia9BsMF5YCkouo39jwFeiaibKTHjrZrsOD11xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;figcaption&gt;软链接-来源参考[3]&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;IO&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;零拷贝了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如需要文件传输，使用传统I/O，数据读取和写入是用户空间到内核空间来回赋值，而内核空间的数据是通过操作系统的I/O接口从磁盘读取或者写入，这期间发生了多次用户态和内核态的上下文切换，以及多次数据拷贝。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6214442013129103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoEzvib01uaTuvVokI5yq7QVWbibXOAicRhWrT9MMVHBCLaiadj5yD4PmK6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;914&quot;/&gt;&lt;figcaption&gt;传统文件传输示意图-来源参考[3]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了提升I/O性能，就需要&lt;strong&gt;减少用户态与内核态的上下文切换&lt;/strong&gt;和&lt;strong&gt;内存拷贝的次数&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就用到了我们零拷贝的技术，零拷贝技术实现主要有两种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mmap() 系统调⽤函数会直接把内核缓冲区⾥的数据「&lt;strong&gt;映射&lt;/strong&gt;」到⽤户空间，这样，操作系统内核与⽤户空间就不需要再进⾏任何的数据拷⻉操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6345945945945946&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoJSj0vM3WhDb068Hca1JdQs039uqfeMNLoUQGJvNDZfiaS1advsWQqIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;925&quot;/&gt;&lt;figcaption&gt;mmap示意图-来源参考[3]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 内核版本 2.1 中，提供了⼀个专⻔发送⽂件的系统调⽤函数 sendfile() 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⾸先，它可以替代前⾯的 read() 和 write() 这两个系统调⽤，这样就可以减少⼀次系统调⽤，也就减少了 2 次上下⽂切换的开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，该系统调⽤，可以直接把内核缓冲区⾥的数据拷⻉到 socket 缓冲区⾥，不再拷⻉到⽤户态，这样就只有 2 次上下⽂切换，和 3 次数据拷⻉。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6721491228070176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEod8YuwT2laThnRqG3OD4u150j7FJyQ5WBJWBV7MUaFSUZDNsBIz7M8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;912&quot;/&gt;&lt;figcaption&gt;sendfile示意图-来源参考[3]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多开源项目如Kafka、RocketMQ都采用了零拷贝技术来提升IO效率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;聊聊&lt;strong&gt;阻塞与⾮阻塞&lt;/strong&gt; **I/O **、 &lt;strong&gt;同步与异步&lt;/strong&gt; &lt;strong&gt;I/O&lt;/strong&gt;？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看看&lt;strong&gt;阻塞&lt;/strong&gt; &lt;strong&gt;I/O&lt;/strong&gt;，当⽤户程序执⾏ read ，线程会被阻塞，⼀直等到内核数据准备好，并把数据从内核缓冲区拷⻉到应⽤程序的缓冲区中，当拷⻉过程完成， read 才会返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，&lt;strong&gt;阻塞等待的是&lt;code&gt;内核数据准备好&lt;/code&gt;和&lt;code&gt;数据从内核态拷⻉到⽤户态&lt;/code&gt;这两个过程&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5943627450980392&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEofcibqftZlLvXaibNPJBGVLBxFLJ7UlvZeiadqpN9WaZuTk95FpoApZE9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;816&quot;/&gt;&lt;figcaption&gt;阻塞I/O&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⾮阻塞的 read 请求在数据未准备好的情况下⽴即返回，可以继续往下执⾏，此时应⽤程序不断轮询内核，直到数据准备好，内核将数据拷⻉到应⽤程序缓冲区， read 调⽤才可以获取到结果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8314883148831488&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoOA0pQLqiamCMhYX4PRHibSlGbiclttAqCfoGjaxb8uXlfmA2RMZqUeKog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;813&quot;/&gt;&lt;figcaption&gt;非阻塞I/O&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们上面的非阻塞I/O有一个问题，什么问题呢？应用程序要一直轮询，这个过程没法干其它事情，所以引入了&lt;strong&gt;I/O&lt;/strong&gt; &lt;strong&gt;多路复⽤&lt;/strong&gt;技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当内核数据准备好时，以事件通知应⽤程序进⾏操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7912218268090154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEooxx1thVA0387dPG2GpFr05AFTDtCjKgCNMped9IcmJsJu8hQhXW86Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;843&quot;/&gt;&lt;figcaption&gt;基于非阻塞的I/O多路复用&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;strong&gt;⽆论是阻塞 I/O、还是⾮阻塞 I/O、非阻塞I/O多路复用，都是同步调⽤。因为它们在read调⽤时，内核将数据从内核空间拷⻉到应⽤程序空间，过程都是需要等待的，也就是说这个过程是&lt;/strong&gt;同步&lt;/strong&gt;的，如果内核实现的拷⻉效率不⾼，read调⽤就会在这个同步过程中等待⽐较⻓的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真正的&lt;strong&gt;异步&lt;/strong&gt; &lt;strong&gt;I/O&lt;/strong&gt; 是&lt;code&gt;内核数据准备好&lt;/code&gt;和&lt;code&gt;数据从内核态拷⻉到⽤户态&lt;/code&gt;这两个过程都不⽤等待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发起 aio_read 之后，就⽴即返回，内核⾃动将数据从内核空间拷⻉到应⽤程序空间，这个拷⻉过程同样是异步的，内核⾃动完成的，和前⾯的同步操作不⼀样，应⽤程序并不需要主动发起拷⻉动作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7861715749039693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoelLkqx8NBzcpG0J8IToyfEWicah5E0qE4zdWAwcNPeDicZrkcCS2qyGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;781&quot;/&gt;&lt;figcaption&gt;异步/IO&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;拿例子理解几种I/O模型&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老三关注了很多UP主，有些UP主是老鸽子，到了更新的时间：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阻塞I/O就是，老三不干别的，就干等着，盯着UP的更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非阻塞I/O就是，老三发现UP没更，就去喝个茶什么的，过一会儿来盯一次，一直等到UP更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于⾮阻塞的 I/O 多路复⽤好⽐，老三发现UP没更，就去干别的，过了一会儿B站推送消息了，老三一看，有很多条，就去翻动态，看看等的UP是不是更新了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步I/O就是，老三说UP你该更了，UP赶紧爆肝把视频做出来，然后把视频亲自呈到老三面前，这个过程不用等待。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8093480934809348&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEo3Rldqib1XRz7qqktrHTUOjvvE4B6SlNibz2bGhaNGEOMx1vlbquP2wCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;813&quot;/&gt;&lt;figcaption&gt;鸽宗&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;详细讲一讲I/O多路复用？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我们先了解什么是I/O多路复用？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在传统的I/O模型中，如果服务端需要支持多个客户端，我们可能要为每个客户端分配一个进程/线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是基于重一点的进程模型，还是轻一点的线程模型，假如连接多了，操作系统是扛不住的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以就引入了&lt;strong&gt;I/O多路复用&lt;/strong&gt; 技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说，就是一个进程/线程维护多个Socket，这个多路复用就是多个连接复用一个进程/线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5227722772277228&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEoCp2XoYHNj57NmPb0ZyEqLpbtU6cxdcmQR6YIBxeqKt2wicHXKYfKiaibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;505&quot;/&gt;&lt;figcaption&gt;I/O多路复用&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看看I/O多路复用三种实现机制：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;select 实现多路复⽤的⽅式是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将已连接的 Socket 都放到⼀个&lt;strong&gt;⽂件描述符集合&lt;/strong&gt;fd_set，然后调⽤ select 函数将fd_set集合拷⻉到内核⾥，让内核来检查是否有⽹络事件产⽣，检查的⽅式很粗暴，就是通过遍历fd_set的⽅式，当检查到有事件产⽣后，将此 Socket 标记为可读或可写， 接着再把整个fd_set拷⻉回⽤户态⾥，然后⽤户态还需要再通过遍历的⽅法找到可读或可写的 Socket，再对其处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;select 使⽤固定⻓度的 BitsMap，表示⽂件描述符集合，⽽且所⽀持的⽂件描述符的个数是有限制的，在Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最⼤值为 1024 ，只能监听 0~1023 的⽂件描述符。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;select机制的缺点：&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）每次调用select，都需要把fd_set集合从用户态拷贝到内核态，如果fd_set集合很大时，那这个开销也很大，比如百万连接却只有少数活跃连接时这样做就太没有效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）每次调用select都需要在内核遍历传递进来的所有fd_set，如果fd_set集合很大时，那这个开销也很大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）为了减少数据拷贝带来的性能损坏，内核对被监控的fd_set集合大小做了限制，一般为1024，如果想要修改会比较麻烦，可能还需要编译内核。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）每次调用select之前都需要遍历设置监听集合，重复工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;poll 不再⽤ BitsMap 来存储所关注的⽂件描述符，取⽽代之⽤动态数组，以链表形式来组织，突破了select 的⽂件描述符个数限制，当然还会受到系统⽂件描述符限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 poll 和 select 并没有太⼤的本质区别，都是使⽤线性结构存储进程关注的Socket集合，因此都需要遍历⽂件描述符集合来找到可读或可写的Socke，时间复杂度为O(n)，⽽且也需要在⽤户态与内核态之间拷⻉⽂件描述符集合，这种⽅式随着并发数上来，性能的损耗会呈指数级增⻓。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;epoll 通过两个⽅⾯，很好解决了 select/poll 的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第⼀点，epoll 在内核⾥使⽤&lt;strong&gt;红⿊树来跟踪进程所有待检测的⽂件描述字&lt;/strong&gt;，把需要监控的 socket 通过epoll_ctl() 函数加⼊内核中的红⿊树⾥，红⿊树是个⾼效的数据结构，增删查⼀般时间复杂度是O(logn) ，通过对这棵⿊红树进⾏操作，这样就不需要像 select/poll 每次操作时都传⼊整个 socket 集合，只需要传⼊⼀个待检测的 socket，&lt;strong&gt;减少了内核和⽤户空间⼤量的数据拷⻉和内存分配&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第⼆点， epoll 使⽤事件驱动的机制，内核⾥&lt;strong&gt;维护了⼀个链表来记录就绪事件&lt;/strong&gt;，当某个 socket 有事件发⽣时，通过回调函数，内核会将其加⼊到这个就绪事件列表中，当⽤户调⽤ epoll_wait() 函数时，只会返回有事件发⽣的⽂件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，⼤⼤提⾼了检测的效率。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5005382131324004&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBP2VmFpjKOLPS8NABafEot1cMNY7BrmBta6JYsENiatpxMZlQo89Pyh4cxqRsichEXILUxt1g5VQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;929&quot;/&gt;&lt;figcaption&gt;epoll接口作用-来源参考[3]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;epoll 的⽅式即使监听的 Socket 数量越多的时候，效率不会⼤幅度降低，能够同时监听的 Socket 的数⽬也⾮常的多了，上限就为系统定义的进程打开的最⼤⽂件描述符个数。因⽽，&lt;strong&gt;epoll&lt;/strong&gt; &lt;strong&gt;被称为解决&lt;/strong&gt; &lt;strong&gt;C10K&lt;/strong&gt; &lt;strong&gt;问题的利器&lt;/strong&gt;。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;博主水平有限，参阅的资料在某些问题上也有一些出入，如有错漏，欢迎指出！&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1].&lt;/span&gt;&lt;span&gt;这可能最全的操作系统面试题https://blog.csdn.net/qq_36894974/article/details/115654242&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2]. &lt;/span&gt;操作系统常见面试题（2021最新版）https://blog.csdn.net/weixin_45545542/article/details/117929487&lt;/p&gt;&lt;p&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;3]. 小林coding《图解系统》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[4].《现代操作系统》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[5]. 《深入理解计算机系统》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[6]. 《操作系统之哲学原理》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-recommend-type=&quot;list-title&quot; data-recommend-tid=&quot;6&quot; data-mpa-template=&quot;t&quot; data-mid=&quot;&quot; data-from=&quot;yb-recommend&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;6&quot; data-recommend-article-id=&quot;2247488268_1&quot; data-recommend-article-time=&quot;1631895551&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcejvmIydIIflOyuuTyJgBw8pDU3ibRCogIha2YobVmNiagD0YyPhs8IC5G1p2b9kWLDPSrGLLG2n3g/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;不就是分布式事务，这下彻底清楚了&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488268&amp;amp;idx=1&amp;amp;sn=5707facc0405ea0b09b8d32a841853d5&amp;amp;chksm=c0ccfba9f7bb72bf0519fca2984e235aaeb6dceba25aff6a220048c3116117c4cf5493b03f5f#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488268&amp;amp;idx=1&amp;amp;sn=5707facc0405ea0b09b8d32a841853d5&amp;amp;chksm=c0ccfba9f7bb72bf0519fca2984e235aaeb6dceba25aff6a220048c3116117c4cf5493b03f5f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;不就是分布式事务，这下彻底清楚了&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;6&quot; data-recommend-article-id=&quot;2247488224_1&quot; data-recommend-article-time=&quot;1631772946&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWd1vWDuBdiaXia8dmNThExPTRTpKV81t5mAvzicIKuibqQtiadeaZNriblSSofJVW9p97ibMmWF0Y7YSyyBA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;分布式必备理论基础：CAP和BASE&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488224&amp;amp;idx=1&amp;amp;sn=0631d97efbf9786755742c0b4b15f21f&amp;amp;chksm=c0ccfa45f7bb7353e6a4086ecc3c8cfdd75d8aaf9a2bc953fb0ee5ce63c7711ea3ac9981219e#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488224&amp;amp;idx=1&amp;amp;sn=0631d97efbf9786755742c0b4b15f21f&amp;amp;chksm=c0ccfa45f7bb7353e6a4086ecc3c8cfdd75d8aaf9a2bc953fb0ee5ce63c7711ea3ac9981219e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;分布式必备理论基础：CAP和BASE&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;6&quot; data-recommend-article-id=&quot;2247488210_1&quot; data-recommend-article-time=&quot;1631702296&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWeAAo73iaIl9STAC0GbcmQicA0giasT5SCYTxbhFnr1dFs2pb5mCliaFwwyhBcvk3JUyvkI5MwScxOSOQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;缓存一致性？get！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488210&amp;amp;idx=1&amp;amp;sn=e3735aeaa702c6e4115c1f6d15e0c125&amp;amp;chksm=c0ccfa77f7bb7361468efd7e0c0746edde5230d4d9c7c60d9e43e46ba579048d82999ff2c0b6#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488210&amp;amp;idx=1&amp;amp;sn=e3735aeaa702c6e4115c1f6d15e0c125&amp;amp;chksm=c0ccfa77f7bb7361468efd7e0c0746edde5230d4d9c7c60d9e43e46ba579048d82999ff2c0b6&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;缓存一致性？get！&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;6&quot; data-recommend-article-id=&quot;2247488075_1&quot; data-recommend-article-time=&quot;1631502054&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcF97CtqllJ3MpbAZdKTfQ2SdE3UICqzXp36SxFbGSlyic4Nc68LvFu8Ht8kkBW1aIibEXUNdYNW8ibA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;单例模式的七种写法，你都知道吗？&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488075&amp;amp;idx=1&amp;amp;sn=558c9aaa80cec1dfe7d8f587edd868a6&amp;amp;chksm=c0ccfaeef7bb73f8b0c67f6d1ce0cb8702f311f7303dfdc95d056dfa6cc437c8dc19d4c380f9#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488075&amp;amp;idx=1&amp;amp;sn=558c9aaa80cec1dfe7d8f587edd868a6&amp;amp;chksm=c0ccfaeef7bb73f8b0c67f6d1ce0cb8702f311f7303dfdc95d056dfa6cc437c8dc19d4c380f9&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;单例模式的七种写法，你都知道吗？&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;6&quot; data-recommend-article-id=&quot;2247488048_1&quot; data-recommend-article-time=&quot;1631287965&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWdicRFdvwlGXxvYdLGyWiaEehyNLtpYSsHpE9l5RIF7OI4xRZzMzB1ZDJmCibeTRY14BCXgQyBf1dHSg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;十分钟彻底掌握缓存击穿、缓存穿透、缓存雪崩&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488048&amp;amp;idx=1&amp;amp;sn=959ef15104f95fc341ba837c628f5d6f&amp;amp;chksm=c0ccfa95f7bb73837942d7d863befadfd198bdb22a72276c6622d4725607b08a835876757622#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488048&amp;amp;idx=1&amp;amp;sn=959ef15104f95fc341ba837c628f5d6f&amp;amp;chksm=c0ccfa95f7bb73837942d7d863befadfd198bdb22a72276c6622d4725607b08a835876757622&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;十分钟彻底掌握缓存击穿、缓存穿透、缓存雪崩&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;6&quot; data-recommend-article-id=&quot;2247487931_1&quot; data-recommend-article-time=&quot;1630815802&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWe5pYXdPIhvzGPvSJFMmpic7ia71RNsAp7mF4iaibMICYSAPqY73jngfl9fEYOib9JkI87lAKvGDj5yMSg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;万字长文|十大基本排序，一次搞定！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247487931&amp;amp;idx=1&amp;amp;sn=35ab65fe21ac2dfc7502794c858e8b3b&amp;amp;chksm=c0ccf91ef7bb7008cd6d7c3aa7e3d32bdf1429675e20401156e2844bcd57f9eca8bbd29ad3c7#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247487931&amp;amp;idx=1&amp;amp;sn=35ab65fe21ac2dfc7502794c858e8b3b&amp;amp;chksm=c0ccf91ef7bb7008cd6d7c3aa7e3d32bdf1429675e20401156e2844bcd57f9eca8bbd29ad3c7&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;万字长文|十大基本排序，一次搞定！&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b3bccce311ab5081d7fdf4b65f8b4392</guid>
<title>一文了解 ClickHouse 的向量化执行</title>
<link>https://toutiao.io/k/xade3vc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIxMjI3NTI5OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/DicvpKIBbiaxdvguk5d6BgaNvk9mvMnmticIjibcW5fOibhicUCZDRVGq2SfEib6bRT7djd8icz5HV0sWuKkse9k0Ve7ow/0?wx_fmt=png&quot; data-nickname=&quot;Java与大数据架构&quot; data-alias=&quot;deltalake_bigdata&quot; data-signature=&quot;7年老码农，10W关注者。【Java与大数据架构】全面分享Java编程、Spark、Flink、Kafka、Elasticsearch、数据湖等干货。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;ClickHouse在计算层做了非常细致的工作，竭尽所能榨干硬件能力，提升查询速度。它实现了单机多核并行、分布式计算、向量化执行与SIMD指令、代码生成等多种重要技术。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;多核并行&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;ClickHouse将数据划分为多个partition，每个partition再进一步划分为多个index granularity，然后通过多个CPU核心分别处理其中的一部分来实现并行数据处理。&lt;/p&gt;&lt;p&gt;在这种设计下，单条Query就能利用整机所有CPU。极致的并行处理能力，极大的降低了查询延时。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;分布式计算&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;除了优秀的单机并行处理能力，ClickHouse还提供了可线性拓展的分布式计算能力。ClickHouse会自动将查询拆解为多个task下发到集群中，然后进行多机并行处理，最后把结果汇聚到一起。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;向量化执行与SIMD&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;ClickHouse不仅将数据按列存储，而且按列进行计算。传统OLTP数据库通常采用按行计算，原因是事务处理中以点查为主，SQL计算量小，实现这些技术的收益不够明显。但是在分析场景下，单个SQL所涉及计算量可能极大，将每行作为一个基本单元进行处理会带来严重的性能损耗：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;对每一行数据都要调用相应的函数，函数调用开销占比高；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;存储层按列存储数据，在内存中也按列组织，但是计算层按行处理，无法充分利用CPU cache的预读能力，造成CPU Cache miss严重；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;按行处理，无法利用高效的SIMD指令；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;ClickHouse实现了向量执行引擎（Vectorized execution engine），对内存中的列式数据，一个batch调用一次SIMD指令（而非每一行调用一次），不仅减少了函数调用次数、降低了cache miss，而且可以充分发挥SIMD指令的并行能力，大幅缩短了计算耗时。向量执行引擎，通常能够带来数倍的性能提升。&lt;/p&gt;&lt;h2&gt;What IS SIMD ?&lt;/h2&gt;&lt;h3&gt;SIMD&lt;/h3&gt;&lt;p&gt;即 single instruction multiple data 英文首字母缩写，单指令流多数据流，也就是说一次运算指令可以执行多个数据流，一个简单的例子就是向量的加减。&lt;/p&gt;&lt;h3&gt;SSE 与 SMID 关系&lt;/h3&gt;&lt;p&gt;SSE（为Streaming SIMD Extensions的缩写）是由 Intel公司在1999年推出Pentium III处理器时，同时推出的新指令集。如同其名称所表示的，SSE是一种SIMD指令集。SSE有8个128位寄存器，XMM0 ~XMM7。可以用来存放四个32位的单精确度浮点数。可以看出，SSE 是一套专门为 SIMD（单指令多数据）架构设计的指令集。通过它，用户可以同时在多个数据片段上执行运算，实现数据并行（aka:矢量处理）。&lt;/p&gt;&lt;p&gt;SSE2是SSE指令的升级版，寄存器与指令格式都和SSE一致，不同之处在于其能够处理双精度浮点数等更多数据类。SSE3增加了13条新的指令。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;参考：https://www.cnblogs.com/xidian-wws/p/11023762.html&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;C++使用SIMD编程的3种方法&lt;/h3&gt;&lt;p&gt;SIMD指令集的使用，有如下三种方式：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;编译器优化&lt;/strong&gt; 即使用C/C++编写程序之后，带有SIMD优化选项编译，在CPU支持的情况下，编译器按照自己的规则去优化。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;使用intrinsic指令&lt;/strong&gt; 参考Intel手册，针对SIMD指令，可以在编程时直接使用其内置的某些库函数，编译的时候在cpu和编译器的支持下会生成对应的SIMD指令。比如：double _mm_cvtsd_f64 (__m128d a) 该函数编译时就会翻译成指令：movsd&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;嵌入式汇编&lt;/strong&gt; 内联汇编直接在程序中嵌入对应的SIMD指令。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;Intrinsics头文件与SIMD指令集、Visual Studio版本对应表&lt;/h3&gt;&lt;p&gt;VS和GCC都支持SSE指令的Intrinsic，SSE有多个不同的版本，其对应的Intrinsic也包含在不同的头文件中，如果确定只使用某个版本的SSE指令则只包含相应的头文件即可。&lt;/p&gt;&lt;p&gt;例如，要使用SSE3，则&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#include&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;lt;tmmintrin.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;如果不关心使用那个版本的SSE指令，则可以包含所有&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#include&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;lt;intrin.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;参考资料：https://www.cnblogs.com/huaping-audio/p/4115890.html&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;简单运算的Intrinsic和SSE指令对比 使用Intrinsic函数的代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;undefined&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  __m128 a1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; b2&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  __m128 c1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; count&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; i&lt;/span&gt;&lt;span&gt;++)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      a1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _mm_load_ps&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      b2 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _mm_load_ps&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      c1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _mm_add_ps&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;a1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;  b2&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;对应汇编指令代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;undefined&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; count&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;++)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    _asm&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        movaps  xmm0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;];&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        movaps  xmm1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;];&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        addps  xmm0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; xmm1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;简要说明其中一种操作：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;addps XMM,XMM/m128 源存储器内容按双字对齐，共4个单精度浮点数与目的寄存器相加，结果送入目的寄存器&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;计算机硬件支持与编译器支持&lt;/h3&gt;&lt;p&gt;要能够使用 Intel 的 SIMD 指令集，不仅需要当前 Intel 处理器的硬件支持，还需要编译器的支持。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ grep &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;q sse4_2 &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;proc&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;cpuinfo &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; echo &lt;/span&gt;&lt;span&gt;&quot;SSE 4.2 supported&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;||&lt;/span&gt;&lt;span&gt; echo &lt;/span&gt;&lt;span&gt;&quot;SSE 4.2 not supported&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;如果你的机器支持SSE4.2，那么，将打印：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;SSE &lt;/span&gt;&lt;span&gt;4.2&lt;/span&gt;&lt;span&gt; supported&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;使用SIMD考量&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;利用优点：&lt;/strong&gt; 频繁调用的基础函数，大量的可并行计算&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;尽量避免：&lt;/strong&gt; SSE指令集对分支处理能力非常的差，而且从128位的数据中提取某些元素数据的代价又非常的大，因此不适合有复杂逻辑的运算。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;How Clickhouse USE SIMD ?&lt;/h2&gt;&lt;p&gt;大家在搜索CLICKHOUSE为什么快的文章中，都提到了CH使用到的技术列式存储，压缩，向量引擎。&lt;/p&gt;&lt;p&gt;CH在所有能够提高CPU计算效率的地方，都大量的使用了SIMD。&lt;/p&gt;&lt;p&gt;本文以clickhouse其中的一个简单的LowerUpperImpl函数为例（这个函数完成大小写转换）。&lt;/p&gt;&lt;p&gt;测试产出SIMD模式与非SIMD模式下benchmark的效率对比。&lt;/p&gt;&lt;p&gt;code如下，关键节点已加注释:&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; not_case_lower_bound&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; not_case_upper_bound&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;LowerUpperImpl&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; array&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; src_end&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; dst&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;//32&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;auto&lt;/span&gt;&lt;span&gt; flip_case_mask &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;A&#x27;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;^&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#ifdef&lt;/span&gt;&lt;span&gt; __SSE2__&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;auto&lt;/span&gt;&lt;span&gt; bytes_sse &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;__m128i&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;auto&lt;/span&gt;&lt;span&gt; src_end_sse &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; src_end &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;src_end &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt; bytes_sse&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;auto&lt;/span&gt;&lt;span&gt; v_not_case_lower_bound &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _mm_set1_epi8&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;not_case_lower_bound &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;auto&lt;/span&gt;&lt;span&gt; v_not_case_upper_bound &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _mm_set1_epi8&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;not_case_upper_bound &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;auto&lt;/span&gt;&lt;span&gt; v_flip_case_mask &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _mm_set1_epi8&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;flip_case_mask&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(;&lt;/span&gt;&lt;span&gt; src &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; src_end_sse&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; src &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt;&lt;span&gt; bytes_sse&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; dst &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt;&lt;span&gt; bytes_sse&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;//_mm_loadu_si128表示：Loads 128-bit value；即加载128位值。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;//一次性加载16个连续的8-bit字符&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;auto&lt;/span&gt;&lt;span&gt; chars &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _mm_loadu_si128&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;reinterpret_cast&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; __m128i &lt;/span&gt;&lt;span&gt;*&amp;gt;(&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;//_mm_and_si128(a,b)表示：将a和b进行与运算，即r=a&amp;amp;b&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;//_mm_cmpgt_epi8(a,b)表示：分别比较a的每个8bits整数是否大于b的对应位置的8bits整数，若大于，则返回0xff，否则返回0x00。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;//_mm_cmplt_epi8(a,b)表示：分别比较a的每个8bits整数是否小于b的对应位置的8bits整数，若小于，则返回0xff，否则返回0x00。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;//下面的一行代码对这128位的寄存器并行操作了3遍，最后得到一个128位数，对应位置上是0xff的，表示&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;//那个8-bit数在 [case_lower_bound, case_upper_bound]范围之内的，其余的被0占据的位置，是不在操作范围内的数。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;auto&lt;/span&gt;&lt;span&gt; is_not_case&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;               &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _mm_and_si128&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;_mm_cmpgt_epi8&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chars&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; v_not_case_lower_bound&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;span&gt; _mm_cmplt_epi8&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chars&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; v_not_case_upper_bound&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;//每个0xff位置与32进行与操作，原来的oxff位置变成32，也就是说，每个在 [case_lower_bound, case_upper_bound]范围区间的数，现在变成了32，其他的位置是0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;auto&lt;/span&gt;&lt;span&gt; xor_mask &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _mm_and_si128&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;v_flip_case_mask&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; is_not_case&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;//将源chars内容与xor_mask进行异或，符合条件的字节可能从uppercase转为lowercase，也可能从lowercase转为uppercase，不符合区间的仍保留原样。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;auto&lt;/span&gt;&lt;span&gt; cased_chars &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _mm_xor_si128&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chars&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; xor_mask&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;//将结果集存到dst中&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           _mm_storeu_si128&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;reinterpret_cast&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;__m128i &lt;/span&gt;&lt;span&gt;*&amp;gt;(&lt;/span&gt;&lt;span&gt;dst&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;span&gt; cased_chars&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#ifndef&lt;/span&gt;&lt;span&gt; __SSE2__&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(;&lt;/span&gt;&lt;span&gt; src &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; src_end&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;dst&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(*&lt;/span&gt;&lt;span&gt;src &lt;/span&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt; not_case_lower_bound &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;src &lt;/span&gt;&lt;span&gt;&amp;lt;=&lt;/span&gt;&lt;span&gt; not_case_upper_bound&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;               &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;dst &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;src &lt;/span&gt;&lt;span&gt;^&lt;/span&gt;&lt;span&gt; flip_case_mask&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;           &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;               &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;dst &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;完整代码参考 &lt;span&gt;这里&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;测试结果如下：&lt;/p&gt;&lt;p&gt;32位输入：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;root@2458d1317fc8&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;/var/&lt;/span&gt;&lt;span&gt;tmp&lt;/span&gt;&lt;span&gt;# g++ -std=c++11 -Wall -pedantic -pthread sse.cpp &amp;amp;&amp;amp; ./a.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; des &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; abcdefghabcdefghabcdefghabcdefgh&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;花费了&lt;/span&gt;&lt;span&gt;6.8059&lt;/span&gt;&lt;span&gt;秒&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;root@2458d1317fc8&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;/var/&lt;/span&gt;&lt;span&gt;tmp&lt;/span&gt;&lt;span&gt;# g++ -std=c++11 -Wall -pedantic -pthread nosse.cpp &amp;amp;&amp;amp; ./a.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; des &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; abcdefghabcdefghabcdefghabcdefgh&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;花费了&lt;/span&gt;&lt;span&gt;9.39051&lt;/span&gt;&lt;span&gt;秒&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;64位输入：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;root@2458d1317fc8&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;/var/&lt;/span&gt;&lt;span&gt;tmp&lt;/span&gt;&lt;span&gt;# g++ -std=c++11 -Wall -pedantic -pthread sse.cpp &amp;amp;&amp;amp; ./a.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; des &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; abcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefgh&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;花费了&lt;/span&gt;&lt;span&gt;9.26642&lt;/span&gt;&lt;span&gt;秒&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;root@2458d1317fc8&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;/var/&lt;/span&gt;&lt;span&gt;tmp&lt;/span&gt;&lt;span&gt;# g++ -std=c++11 -Wall -pedantic -pthread nosse.cpp &amp;amp;&amp;amp; ./a.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; des &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; abcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefgh&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;花费了&lt;/span&gt;&lt;span&gt;17.3588&lt;/span&gt;&lt;span&gt;秒&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;128位输入：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;root@2458d1317fc8&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;/var/&lt;/span&gt;&lt;span&gt;tmp&lt;/span&gt;&lt;span&gt;# g++ -std=c++11 -Wall  -pedantic -pthread sse.cpp &amp;amp;&amp;amp; ./a.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; des &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; abcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefgh&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;花费了&lt;/span&gt;&lt;span&gt;10.2672&lt;/span&gt;&lt;span&gt;秒&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;root@2458d1317fc8&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;/var/&lt;/span&gt;&lt;span&gt;tmp&lt;/span&gt;&lt;span&gt;# g++ -std=c++11 -Wall  -pedantic -pthread nosse.cpp &amp;amp;&amp;amp; ./a.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; des &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; abcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefgh&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;花费了&lt;/span&gt;&lt;span&gt;31.7568&lt;/span&gt;&lt;span&gt;秒&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;这只是其中一个简单的函数。但，为什么Clickhouse快？管中窥豹，可见一斑。&lt;/p&gt;&lt;p&gt;Clickhouse 仅短短几年在OLAP领域横空出世，这和Clickhouse在设计和细节上追求极致密不可分。&lt;/p&gt;&lt;p&gt;对于俄罗斯人，开源一款产品可是大事。但不开源还则罢了。一旦开源，必是行业大事。一如nginx。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;本文转载自：https://www.jianshu.com/p/fc384f18ff1a，作者：金科_&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; 这里: &lt;em&gt;https://github.com/Johnny-Three/clickhousedive/blob/master/main.cpp&lt;/em&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1MzI3OTExMw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hia1hBWfqIiciakUBWXibicbib2AoADSSUrEa3HnoeGpibSbrvIu0dic5tG4pBzGs1OamGkBj0IlN3hWTPLg5eLrmwAicQA/0?wx_fmt=png&quot; data-nickname=&quot;大数据厂长&quot; data-alias=&quot;bigdata-fish&quot; data-signature=&quot;大数据技术升级打怪历程、优质文章分享&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cb0132913691be1dd7ba39f945effef2</guid>
<title>一套优雅的 Go 错误问题解决方案</title>
<link>https://toutiao.io/k/8qf7wmi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：andruzhang，腾讯 IEG 后台开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在使用 Go 开发的后台服务中，对于错误处理，一直以来都有多种不同的方案，本文探讨并提出一种从服务内到服务外的错误传递、返回和回溯的完整方案，还请读者们一起讨论。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题提出&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在后台开发中，针对错误处理，有三个维度的问题需要解决：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;函数内部的错误处理: 这是一个函数在执行过程中遇到各种错误时的错误处理。这是一个语言级的问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数/模块的错误信息返回: 一个函数在操作错误之后，要怎么将这个错误信息优雅地返回，方便调用方（也要优雅地）处理。这也是一个语言级的问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务/系统的错误信息返回: 微服务/系统在处理失败时，如何返回一个友好的错误信息，依然是需要让调用方优雅地理解和处理。这是一个服务级的问题，适用于任何语言&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;函数内部的错误处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个面向过程的函数，在不同的处理过程中需要 handle 不同的错误信息；一个面向对象的函数，针对一个操作所返回的不同类型的错误，有可能需要进行不同的处理。此外，在遇到错误时，也可以使用断言的方式，快速中止函数流程，大大提高代码的可读性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在许多高级语言中都提供了 &lt;code&gt;try ... catch&lt;/code&gt; 的语法，函数内部可以通过这种方案，实现一个统一的错误处理逻辑。而即便是 &lt;code&gt;C&lt;/code&gt; 这种 “中级语言” 虽然没有，但是程序员也可以使用宏定义的方式，来实现某种程度上的错误断言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，对于 Go 的情况就比较尴尬了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go 的错误断言&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看断言，我们的目的是，仅使用一行代码就能够检查错误并终止当前函数。由于没有 &lt;code&gt;throw&lt;/code&gt;，没有宏，如果要实现一行断言，有两种方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种是把 &lt;code&gt;if&lt;/code&gt; 的错误判断写在一行内，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; err }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种方法是借用 &lt;code&gt;panic&lt;/code&gt; 函数，结合 &lt;code&gt;recover&lt;/code&gt; 来实现:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;SomeProcess&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(err error)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; e := &lt;span&gt;recover&lt;/span&gt;(); e != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            err = e.(error)&lt;br/&gt;        }&lt;br/&gt;    }()&lt;br/&gt;&lt;br/&gt;    assert := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(cond &lt;span&gt;bool&lt;/span&gt;, f &lt;span&gt;string&lt;/span&gt;, a ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; !cond {&lt;br/&gt;            &lt;span&gt;panic&lt;/span&gt;(fmt.Errorf(f, a...))&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    err = DoSomething()&lt;br/&gt;    assert(err == &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;&quot;DoSomething() error: %w&quot;&lt;/span&gt;, err)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种方法都值得商榷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，将 &lt;code&gt;if&lt;/code&gt; 写在同一行内的问题有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这种写法，虽然理论上符合 Go 代码规范，但是在实操中，花括号不换行这一点还是有点争议的，笔者在实际代码中也很少见到过&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不够直观，而且在花括号中也不方便写其他语句，原因是 Go 的规范中强烈不建议使用 &lt;code&gt;;&lt;/code&gt; 来分隔代码语句（&lt;code&gt;if&lt;/code&gt; 判断除外）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于第二种方法，我们要分情况看；&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先 &lt;code&gt;panic&lt;/code&gt; 的设计原意，是在当程序或协程遇到严重错误，完全无法继续运行下去的时候，才会调用（比如段错误、共享资源竞争错误）。这相当于 Linux 中 &lt;code&gt;FATAL&lt;/code&gt; 级别的错误日志。仅仅用来进行普通的错误处理（&lt;code&gt;ERROR&lt;/code&gt; 级别），杀鸡用牛刀了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;panic&lt;/code&gt; 调用本身，相比于普通的业务逻辑，的系统开销是比较大的。而错误处理这种事情，可能是常态化逻辑，频繁的 panic - recover 操作，也会大大降低系统的吞吐。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过使用 panic 来断言的方案，虽然在业务逻辑中基本上不用，但在测试场景下则是非常常见的。测试嘛，用牛刀有何不可？稍微大一点的系统开销也没啥问题。对于 Go 来说，非常热门的单元测试框架 &lt;a href=&quot;https://github.com/smartystreets/goconvey&quot; data-linktype=&quot;2&quot;&gt;goconvey&lt;/a&gt; 就是使用 &lt;code&gt;panic&lt;/code&gt; 机制来实现单元测试中的断言，用的人都说好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上，在 Go 中，对于业务代码，笔者不建议采用断言，遇到错误的时候建议还是老老实实采用这种格式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; err := DoSomething(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在单测代码中，则完全可以大大方方地采用类似于 &lt;code&gt;goconvey&lt;/code&gt; 之类基于 panic 机制的断言。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go 的_try ... catch_&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知 Go 是没有 &lt;code&gt;try ... catch&lt;/code&gt; 的，而且从官方的态度来看，短时间内也没有考虑的计划。但程序员有这个需求呀。笔者采用的方法，是将需要返回的 &lt;code&gt;err&lt;/code&gt; 变量在函数内部全局化，然后结合 &lt;code&gt;defer&lt;/code&gt; 统一处理：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;SomeProcess&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(err error)&lt;/span&gt;&lt;/span&gt; { &lt;span&gt;// &amp;lt;-- 注意，err 变量必须在这里有定义&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 这下面的逻辑，就当作 catch 作用了&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; errors.Is(err, somepkg.ErrRecordNotExist) {&lt;br/&gt;            err = &lt;span&gt;nil&lt;/span&gt;       &lt;span&gt;// 这里是举一个例子，有可能捕获到某些错误，对于该函数而言不算错误，因此 err = nil&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; errors.Like(err, somepkg.ErrConnectionClosed) {&lt;br/&gt;            &lt;span&gt;// ...          // 或者是说遇到连接断开的操作时，可能需要做一些重连操作之类的；甚至乎还可以在这里重连成功之后，重新拉起一次请求&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err = DoSomething(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案要特别注意变量作用域问题.比如前面的 &lt;code&gt;if err = DoSomething(); err != nil {&lt;/code&gt; 行，如果我们将 &lt;code&gt;err = ...&lt;/code&gt; 改为 &lt;code&gt;err := ...&lt;/code&gt;，那么这一行中的 &lt;code&gt;err&lt;/code&gt; 变量和函数最前面定义的 &lt;code&gt;(err error)&lt;/code&gt; 不是同一个变量，因此即便在此处发生了错误，但是在 defer 函数中无法捕获到 err 变量了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;try ... catch&lt;/code&gt; 方面，笔者其实没有特别好的方法来模拟，即便是上面的方法也有一个很让人头疼的问题：defer 写法导致错误处理前置，而正常逻辑后置了，从可读性的角度来说非常不友好。因此也希望读者能够指教。同时还是希望 Go 官方能够继续迭代，支持这种语法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;函数/模块的错误信息返回&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一点在 Go 里面，一开始看起来还是比较统一的，这就是 Go 最开始就定义的 &lt;code&gt;error&lt;/code&gt; 类型，以系统标准的方式，统一了进程内函数级的错误返回模式。调用方使用 &lt;code&gt;if err != nil&lt;/code&gt; 的统一模式，来判断一个调用是不是成功了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是随着 Go 的逐步推广，由于 &lt;code&gt;error&lt;/code&gt; 接口的高自由度，程序员们对于 “如何判断该错误是什么错误” 的时候，出现了分歧。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go 1.13 之前&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 1.13 之前，对于 error 类型的传递，有三种常见的模式：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;==&lt;/code&gt; 流派&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个流派很简单，就是将各种错误信息直接定义为一个类枚举值的模式，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt;    ErrRecordNotExist   = errors.New(&lt;span&gt;&quot;record not exist&quot;&lt;/span&gt;)&lt;br/&gt;    ErrConnectionClosed = errors.New(&lt;span&gt;&quot;connection closed&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当遇到相应的错误信息时，直接返回对应的 error 类枚举值就行了。对于调用方也非常方便，可以采用 &lt;code&gt;switch - case&lt;/code&gt; 来判断错误类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;switch&lt;/span&gt; err {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; ErrRecordNotExist:&lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;个人觉得这种设计模式本质上还是 &lt;code&gt;C&lt;/code&gt; error code 模式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类型断言流派&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种流派则是充分使用了 “&lt;code&gt;error&lt;/code&gt; 是一个 &lt;code&gt;interface&lt;/code&gt;” 的特性，重新自定义一个 error 类型。一方面是用不同的类型来表示不同的错误分类，另一方面则能够实现对于同一错误类型，能够给调用方提供更佳详尽的信息。举个例子，我们可以定义多个不同的错误类型如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; ErrRecordNotExist errImpl&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ErrPermissionDenined errImpl&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ErrOperationTimeout errImpl&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; errImpl &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    msg &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(e *errImpl)&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; e.msg&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于调用方，则通过以下代码来判断不同的错误：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;if&lt;/span&gt; err == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; _, ok := err.(*ErrRecordNotExist); ok {&lt;br/&gt;        &lt;span&gt;// 处理记录不存在的错误&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; _, ok := err.(*ErrPermissionDenined); ok {&lt;br/&gt;        &lt;span&gt;// 处理权限错误&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 处理其他类型的错误&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;code&gt;fmt.Errorf&lt;/code&gt; 流派&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;if&lt;/span&gt; err := DoSomething(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; fmt.Errorf(&lt;span&gt;&quot;DoSomething() error: %v&quot;&lt;/span&gt;, err)&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式，一方面可以透传底层错误，另一方面又可以添加自定义的信息。但对于调用方而言，灾难在于如果要判断某一个错误的具体类型，只能用 &lt;code&gt;strings.Contains()&lt;/code&gt; 来实现，而错误的具体描述文字是不可靠的，同一类型的信息可能会有不同的表达；而在 &lt;code&gt;fmt.Errorf&lt;/code&gt; 的过程中，各个业务添加的额外信息也可能会有不同的文字，这带来了极大的不可靠性，提高了模块之间的耦合度。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go 1.13 之后&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 go 1.13 版本发布之后，针对 &lt;code&gt;fmt.Errorf&lt;/code&gt; 增加了 &lt;code&gt;wraping&lt;/code&gt; 功能，并在 &lt;code&gt;errors&lt;/code&gt; 包中添加了 &lt;code&gt;Is()&lt;/code&gt; 和 &lt;code&gt;As()&lt;/code&gt; 函数。关于这个模式的原理和使用已经有很多文章了，本文就不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个功能，合并并改造了前文的所谓 “== 流派” 和 “fmt.Errorf” 流派，统一使用 &lt;code&gt;errors.Is()&lt;/code&gt; 函数；此外，也算是官方对类型断言流派的认可（专门用 &lt;code&gt;As()&lt;/code&gt; 函数来支持）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际应用中，函数/模块透传错误时，应该采用 Go 的 error wrapping 模式，也就是 &lt;code&gt;fmt.Errorf()&lt;/code&gt; 配合 &lt;code&gt;%w&lt;/code&gt; 使用，业务方可以放心地添加自己的错误信息，只要调用方统一采用 &lt;code&gt;errors.Is()&lt;/code&gt; 和 &lt;code&gt;errors.As()&lt;/code&gt; 即可。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;服务/系统的错误信息返回&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;传统方案&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务/系统层面的错误信息返回，大部分协议都可以看成是 &lt;code&gt;code - message&lt;/code&gt; 模式或者是其变体：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;code&lt;/code&gt; 是数字或者预定义的字符串，可以视为整型或者是字符串类型的枚举值&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果是数字的话，大部分情况下是使用 0 表示成功，小部分则采用一个比较规整的十进制数字表示成功，比如 1000、10000 等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是预定义的字符串，那么是使用 &quot;success&quot;、&quot;OK&quot; 等字符串表示成功，或者是直接以空字符串、甚至是不返回字符串字段来表示成功&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;message&lt;/code&gt; 字段则是错误信息的具体描述，大部分情况下都是一个人类可读的句子&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一般而言，只有当 code 表示错误的时候，这个 message 字段才有返回的必要。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式的特点是：&lt;code&gt;code&lt;/code&gt; 是给程序代码使用的，代码判断这是一个什么类型的错误，进入相应的分支处理；而 &lt;code&gt;message&lt;/code&gt; 是给人看的，程序可以以某种形式抛出或者记录这个错误信息，供用户查看。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;存在问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这一层面有什么问题呢？&lt;code&gt;code&lt;/code&gt; for computer，&lt;code&gt;message&lt;/code&gt; for user，好像挺好的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有时候，我们可能会收到用户/客户反馈一个问题：“XXX 报错了，帮忙看看什么问题？”。用户看不懂我们的错误提示吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在笔者的经验中，我们在使用 code - message 机制的时候，特别是业务初期，难以避免的是前后端的设计文案没能完整地覆盖所有的错误用例，或者是错误极其罕见。因此当出现错误时，提示暧昧不清（甚至是直接提示错误信息），导致用户从错误信息中找到解决方案&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种情况下，尽量覆盖所有错误路径肯定是最完美的方法。不过在做到这一点之前，码农们往往有下面的解决方案：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;遇到未定义错误时，后端在 code 中返回一个统一的错误码，并且将详细的错误信息记录在 &lt;code&gt;message&lt;/code&gt; 中。不过这个模式有下面的问题：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端提示此类信息时，如果将 &lt;code&gt;message&lt;/code&gt; 信息直接展示，可能会展示很多让用户看不懂（也没必要看懂）的文字，而且文字可能会很长（万一是一个 panic 信息），这对用户来说非常不友好&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果开发者不注意，message 信息可能会暴露程序细节，比如连接 DB 失败的信息里可能会涉及数据库的用户名、IP。敏感信息一旦暴露，轻则安全教育，重则高压线伺候&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;还是类似上面的方法，返回统一的错误码，message 则直接用一个通用的 “unknown error” 或 ”未知错误，请联系 XXX“ 之类的提示信息。但是这个时候，我们要怎么查错呢？&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果主调方是另一个模块的话还好，用户肯定是个程序员，这个时候只要对对方提供 requestID / trackID 过来就行了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果对方是个普通用户，难道让用户 F12 看控制台吗？（别笑，我们还真让用户这么干过……）如果是移动端，那可一点看的机会都没；如果将 traceID 暴露给用户，那么长的 ID，谁记得住啊。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既要隐藏信息，又要暴露信息，我可以摔盘子吗……&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，笔者从日益普及的短信验证码有了个灵感——人的短期记忆对 4 个字符还是比较强的，因此我们可以考虑把错误代码缩短到 4 个字符——不区分大小写，因为如果人在记忆时还要记录大小写的话，难度会增加不少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么用 4 个字符表示尽量多的数据呢？数字+字母总共有 36 个字符，理论上使用 4 位 36 进制可以表示 36x36x36x36 = 1679616 个值。因此我们只要找到一个针对错误信息字符串的哈希算法，把输出值限制在 1679616 范围内就行了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我采用的是 MD5 作为例子。MD5 的输出是 128 位，理论上我可以取 MD5 的输出，模 1679616 就可以得到一个简易的结果。实际上为了减少除法运算，我采用的是取高 20 位（0xFFFFF）的简易方式（20 位二进制的最大值为 1048575），然后将这个数字转成 36 进制的字符串输出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当出现异常错误时，我们可以将 message 的提示信息如下展示：“未知错误，错误代码 30EV，如需协助，请联系 XXX”。顺带一提，&lt;code&gt;30EV&lt;/code&gt; 是 &lt;code&gt;&quot;Access denied for user &#x27;db_user&#x27;@&#x27;127.0.0.1&#x27;&quot;&lt;/code&gt; 的计算结果，这样一来，我就对调用方隐藏了敏感信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于后台侧，还是需要实实在在地将这个哈希值和具体的错误信息记录在日志或者其他支持搜索的渠道里。当用户提供该代码时，可以快速定位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案的优点很明显：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;能够提供足够的信息，用户可以记住代码，从而反馈给开发侧进行 debug。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于同一个错误，由于哈希的特点，计算结果是相同的。即便出现了碰撞，那么只要输入的数据不至于太多，还是能够快速区分的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于不论多长的错误信息，反馈到前端都只有四个字符，因此后端在记录错误信息的时候，可以放心地基于 Go 1.13 的 error wraping 机制进行嵌套，从而记录足够的错误信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简易的错误码生成代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;github.com/martinlindhe/base36&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt;    replacer = strings.NewReplacer(&lt;br/&gt;        &lt;span&gt;&quot; &quot;&lt;/span&gt;, &lt;span&gt;&quot;0&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;O&quot;&lt;/span&gt;, &lt;span&gt;&quot;0&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;I&quot;&lt;/span&gt;, &lt;span&gt;&quot;1&quot;&lt;/span&gt;,&lt;br/&gt;    )&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Err2Hashcode&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;uint64&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    u64 := hash(err.Error())&lt;br/&gt;    codeStr := encode(u64)&lt;br/&gt;    u64, _ = decode(codeStr)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; u64, codeStr&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;encode&lt;/span&gt;&lt;span&gt;(code &lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    s := fmt.Sprintf(&lt;span&gt;&quot;%4s&quot;&lt;/span&gt;, base36.Encode(code))&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; replace.Replace(s)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;decode&lt;/span&gt;&lt;span&gt;(s &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;uint64&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(s) != &lt;span&gt;4&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    s = strings.Replace(s, &lt;span&gt;&quot;l&quot;&lt;/span&gt;, &lt;span&gt;&quot;1&quot;&lt;/span&gt;, &lt;span&gt;-1&lt;/span&gt;)&lt;br/&gt;    s = strings.ToUpper(s)&lt;br/&gt;    s = replace.Replace(s)&lt;br/&gt;    code := base36.Decode(s)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; code, code &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// hash 函数可以自定义&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;&lt;span&gt;(s &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;uint64&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    h := md5.Sum([]&lt;span&gt;byte&lt;/span&gt;(s))&lt;br/&gt;    u := binary.BigEndian.Uint32(h[&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;])&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;uint64&lt;/span&gt;(u &amp;amp;amp; &lt;span&gt;0xFFFFF&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这种方案也有局限性，笔者能想到的是需要注意以下两点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生成 &lt;code&gt;error&lt;/code&gt; 时要避免记录随机数据、不可重放数据、千人千面的数据，比如说时间、账户号、流水 ID 等等信息，尽可能使用户进行统一操作时，能够生成相同的错误码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于数字 &lt;code&gt;1&lt;/code&gt; 和字母 &lt;code&gt;I&lt;/code&gt;、数字 &lt;code&gt;0&lt;/code&gt; 和字母 &lt;code&gt;O&lt;/code&gt; 很类似，因此需要进行统一转换，避免出现歧义。这就是为什么在 &lt;code&gt;Err2Hashcode&lt;/code&gt; 中，对 hash 结果 encode 之后要重新 decode 一次再返回的原因。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，笔者需要再强调的是：在开发中，针对各种不同的、正式的错误用例依然需要完整覆盖，尽可能通过已有的 code - message 机制将足够清晰的信息告知主调方。这种 hashcode 的错误代码生成方法，仅适用于错误用例遗漏、或者是快速迭代过程中，用于发现和调试遗漏的错误用例的临时方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5ODYwMjI2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasvpPfMrktl2xvC9A325p8Qa9dFeEzxZmZ2O1XuFGsVXyQhG9Dia8J8nTXVtzNcHozr0umH3R4iboXg/0?wx_fmt=png&quot; data-nickname=&quot;腾讯技术工程&quot; data-alias=&quot;Tencent_TEG&quot; data-signature=&quot;腾讯技术官方号。腾讯技术创新、前沿领域发布解读平台。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>df055802d35f8ce83cf6516bc759ea13</guid>
<title>让 MongoDB 的 CRUD 有 JPA 的味道</title>
<link>https://toutiao.io/k/tqyde81</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;关于 Java、PHP、其他编程语言……或安全、或码农、或技术、或总结！学习交流，共同进步！码农 up to you，码农UP2U!&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;文末提供我整理的 SpringBoot 整合、操作 MongoDB 文档的下载方式！！！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;早期文章&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        上篇文章介绍了使用 MongoTemplate 对 MongoDB 进行 CRUD 的操作，那么接着上篇文章来继续介绍使用 MongoRepository 对 MongoDB 的 CRUD 的操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        需要回顾上面文章的，可以点击该连接进行查看该链接 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484598&amp;amp;idx=1&amp;amp;sn=e28020c5506c3eaecd4395a18124058a&amp;amp;chksm=e973e28cde046b9a0990d41157898dacdf91c70ecf9d4a691422b93fc0fd8ea549ae9ac0dfe8&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;使用 MongoTemplate 对 MongoDB 进行 CRUD&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        来看一下 MongoDB 官网对 MongoDB 的简单描述，截图如下所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3020231213872832&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwtgFjXRD60mialxfALxnvSdJUdPHjt9t7Yjf23mYvB6ib04g8j9Yt6v4JkKbWPtpLTCwfkFpVc6Qk6TA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;692&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        上篇文章中，使用 MongoTemplate 时只需要使用 @Autowired 将其注入就可以使用，而使用 MongoRepository 需要自己定义一个 Repository 接口，然后继承 MongoRepository 即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        下面，接着来介绍 MongoRepository 的用法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一、&lt;strong&gt;&lt;span&gt;在 SpringBoot 中引入依赖&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        接着在上篇文章的项目来使用 MongoRepository 完成对 MongoDB 的 CRUD，如果没有看上篇使用 MongoTemplate 对 MongoDB 的 CRUD 的文章也没关系。只要创建一个 SpringBoot 项目，然后在 POM 文件中引入 MongoDB 的依赖坐标，即可将操作 MongoDB 的类库整合入 SpringBoot 项目当中，相关依赖如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-mongodb&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、添加配置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        引入依赖之后，如果 Maven 项目没有自动下载依赖，那么需要手动进行刷新一下，然后在 SpringBoot 的配置文件 application.yml（或 application.properties）中添加 MongoDB 的地址，如同使用 MySQL 一样，提供一个 uri 来告诉项目。配置文件如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;spring:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  data:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mongodb:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      uri: mongodb://127.0.0.1:27017/test&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        在上面的 uri 中，test 指定了我们 Demo 中要操作的数据库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、定义对应 MongoDB 中集合的实体类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        操作 MySQL 时，我们会将 MySQL 的表在项目中定义一个对应的实体类，操作 MongoDB 的集合也需要定义一个对应的实体类。这里定义一个 Student 的实体类作为 Demo 中的实体类来进行操作，定义如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Data&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Document(&quot;Student&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class Student {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Id&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private String id;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private String name;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private Integer age;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private String email;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        在实体类上添加注解 @Document，@Document 中给出的是集合的名称。注解 @Id 会将该字段与 MongoDB 生成的 _id 进行关联。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在具体操作 MongoDB 时可以通过 MongoTemplate 来进行操作，也可以通过 MongoRepository 来进行操作。上篇文章介绍了 MongoTemplate 对 MongoDB 的 CRUD，本次将介绍如何使用 MongoRepository 来完成对 MongoDB 的 CRUD 操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        以上的三步，和使用 MongoTemplate 的步骤是完全一样，下面的步骤则稍有差别。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、定义实现 MongoRepository 接口的类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        该步骤是使用 MongoTemplate 没有的一个步骤，我们需要定义一个 Repository 接口来继承 MongoRepository 接口，类似定义一个 Mapper 或一个 Dao，定义如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public interface StudentRepository extends MongoRepository&amp;lt;Student, String&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        有了这个接口，我们就可以通过它来操作 MongoDB 数据库中的 Student 文档了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        这里简单介绍一下&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;MongoRepositor&lt;/span&gt;&lt;span&gt;y &lt;/span&gt;&lt;span&gt;接口继承&lt;/span&gt;&lt;span&gt;了 PagingAndSortingRepository 接口&lt;/span&gt;&lt;span&gt;，该接口定义了 分页 和 排序 的功能，PagingAndSortingRepository 接口继承了 CrudRepository 接口，该接口定义了一组 CRUD 相关的方法。&lt;/span&gt;&lt;span&gt;继承关系图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7962962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwthzToCauIFWRLGOoKEjjrBcbmPvC89Fc8hfiaEG0wuFayv5D4KDsaElCycXzjheZdZxhUp3MNYic7iaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        看了上面的继承关系图，是不是有一种很熟悉的味道？那就是 Spring Data Jpa 的继承关系图与之类似，将 MongoRepository 改为 JpaRepository 来观察继承关系图，如下所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7925801011804384&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwthzToCauIFWRLGOoKEjjrBc96WHKamOw0XGsoPQiawhPOPxx5eibY8EcwN4DtzJcs9jh1WpQ650XDGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;593&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        由此可以得知，使用 Repository 操作 MongoDB 的方法，同样可以用来操作 MySQL 数据库，反之亦然。如果在平时使用它操作 MySQL，可以很轻松的应用在 MongoDB 上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、使用 MongoRepository 完成 CRUD&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        定义了 StudentRepository 接口，那么在需要对 Student 进行操作的类中，只要将 StudentRepository 注入即可使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.注入 StudentRepository 到使用类中&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        创建一个测试类，通过 @Autowired 将 StudentRepository 进行注入，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 注入StudentRepository&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Autowired&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private StudentRepository studentRepository;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.添加操作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        如果看过《使用 MongoTemplate 对 MongoDB 进行 CRUD》 文章的读者，可以先将上篇文章中生成的数据先删除，删除方式如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        首先，选中 test 数据库，如下图：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.22702702702702704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwthzToCauIFWRLGOoKEjjrBcKMARqtibicJ0Aj9CSicAgFQnNZ90L3xjQbx6ibDNvTvAPFoBCQ9SNVZZtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;185&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        接着，查看数据库中的集合，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23728813559322035&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwthzToCauIFWRLGOoKEjjrBcpUIjiaTlmLn5nYT06PUAibogGelVu6qPNtpQ2nXzr8uQibMqAzicc2zUpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;177&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        最后，删除 Student 集合，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4205128205128205&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwthzToCauIFWRLGOoKEjjrBcbSEA9f1R5BzQS5lLgCicDrkOyt7Itk1Kvhxze2HCRJGus6zw6ICQ1yA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;195&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        删除原来测试的数据，便于我们有一个干净的环境来让我们进行测试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在注入 StudentRepository 后，我们即可在测试类中完成 CRUD 的操作，先来完成一个添加数据的操作，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@&lt;span class=&quot;code-snippet__function&quot;&gt;Test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;; i ++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Student student = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Student();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        student.setName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;zhangsan&quot;&lt;/span&gt; + i);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        student.setAge(&lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt; + i);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        student.setEmail(i + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;999@qq.com&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Student save = studentRepository.save(student);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(save);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        通过 StudentRepository 的 save 方法，即可完成数据的插入操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        执行上面的测试代码后，我们通过 MongoDB 的客户端来查看一下我们添加的数据。首先使用 use 选择该数据库，然后使用 show collections 查看 test 数据库下的集合，可以看到在 test 数据库下自动创建了一个 Student 集合，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.48619329388560156&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwthzToCauIFWRLGOoKEjjrBc3gPzuNZwucZ6AtfuxqR1tqolOHPn4tTTeqdvibxkgpUgdr5D9bicsyXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在我们执行上面的 save 方法之前，已经把 Student 集合删除了，也没有再创建 Student 集合。执行了上面的代码后，会自动创建 Student 集合，并且在 Student 集合中插入了 10 条文档。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.查询集合中的所有记录&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        上面完成了文档数据插入的操作，现在通过 StudentRepository 来将其全部查出，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * 查询表中所有记录&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Test&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void findAll() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    List&amp;lt;Student&amp;gt; all = studentRepository.findAll();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    all.forEach(System.out::println);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        通过 StudentRepository 的 findAll 方法可以查询指定集合下的所有文档。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        执行上面的代码后，在控制台会输出 Student 集合中的全部文档，输出内容如下所示。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Student(id=6153405a080b7946ca278b3e, name=zhangsan0, age=30, email=0999@qq.com)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Student(id=6153405a080b7946ca278b3f, name=zhangsan1, age=31, email=1999@qq.com)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Student(id=6153405a080b7946ca278b40, name=zhangsan2, age=32, email=2999@qq.com)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Student(id=6153405a080b7946ca278b41, name=zhangsan3, age=33, email=3999@qq.com)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Student(id=6153405a080b7946ca278b42, name=zhangsan4, age=34, email=4999@qq.com)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Student(id=6153405a080b7946ca278b43, name=zhangsan5, age=35, email=5999@qq.com)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Student(id=6153405a080b7946ca278b44, name=zhangsan6, age=36, email=6999@qq.com)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Student(id=6153405a080b7946ca278b45, name=zhangsan7, age=37, email=7999@qq.com)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Student(id=6153405a080b7946ca278b46, name=zhangsan8, age=38, email=8999@qq.com)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Student(id=6153405a080b7946ca278b47, name=zhangsan9, age=39, email=9999@qq.com)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        从输出中可以看出，MongoDB 为我们生成了 id，通过这个 id 我们可以唯一的确定一条数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.通过 id 查询指定的文档&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        通常，我们在查询指定的某条数据时会通过 id 进行查询，在添加数据时，可以看到 MongoDB 为我们自动生成了 id，名为 _id，只要通过 MongoRepository 的 findById 方法（MongoTemplate 也有 findById 方法），并传入相应的 id 值即可查询指定的文档，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * id查询&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Test&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void findById() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Student student = studentRepository.findById(&quot;6153405a080b7946ca278b3e&quot;).get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.out.println(student);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        MongoRepository 的 findById 返回的是 Optional&amp;lt;Student&amp;gt; 类型，通过 get 方法可以获取到 Student 类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.条件查询&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        MongoDB 支持非常强大的查询功能，这里简单的完成一个条件查询。代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Test&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void findUserList() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Student student = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Student();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    student.setName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;zhangsan0&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    student.setAge(&lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Example&amp;lt;Student&amp;gt; userExample = Example.of(student);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Student&amp;gt; all = studentRepository.findAll(userExample);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    all.&lt;span class=&quot;code-snippet__keyword&quot;&gt;forEach&lt;/span&gt;(System.out::println);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        &lt;span&gt;上面的查询相当于如下 SQL 语句：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; student &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; name = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;zhangsan0&#x27;&lt;/span&gt; and age = &lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        除了通过 Example 来构建查询条件外，还可以通过在 StudentRepository 中定义接口的方式来进行查询，将上面的查询在 StudentRepository 中进行定义，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;StudentRepository&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MongoRepository&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__title&quot;&gt;Student&lt;/span&gt;, &lt;span class=&quot;code-snippet__title&quot;&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;Student &lt;span class=&quot;code-snippet__title&quot;&gt;getStudentByNameAndAge&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String name, Integer age)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        有了上面的定义无需自己实现代码即可调用，调用方式如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@&lt;span class=&quot;code-snippet__function&quot;&gt;Test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;findUserByCondition&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Student zhangsan0 = studentRepository.getStudentByNameAndAge(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;zhangsan0&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(zhangsan0);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        Spring Data 提供的自动生成查询语句的功能只要根据约定好的规则，在接口中定义方法名即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6.模糊查询&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        MongoRepository 提供的模糊查询使用 ExampleMatcher 和 Example 即可完成模糊查询，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Test&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void findLikeUserList() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ExampleMatcher matcher = ExampleMatcher&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .matching()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .withIgnoreCase();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Student student = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Student();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    student.setName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;s&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    student.setAge(&lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Example&amp;lt;Student&amp;gt; studentExample = Example.of(student, matcher);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Student&amp;gt; all = studentRepository.findAll(studentExample);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    all.&lt;span class=&quot;code-snippet__keyword&quot;&gt;forEach&lt;/span&gt;(System.out::println);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        在 ExampleMatcher 中定义模糊查询的规则，Example 中提供查询的条件，即可完成模糊查询的功能。同样，模糊查询也可以使用 Spring Data 提供的规则来自动生成查询语句，这里不再进行演示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7.分页查询&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        在 MySQL 中进行数据的分页查询，一般需要给接口传入页码和每页记录的条数，当然也需要传入一些查询条件。对于 MongoDB 而言，传入接口的数据也是一样的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;findPageUserList&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Pageable pageable = PageRequest.of(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Page&amp;lt;Student&amp;gt; page = studentRepository.findAll(pageable);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    page.forEach(System.out::println);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.out.println(page.getTotalPages());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;分页查询通过 &lt;span&gt;Pageable &lt;/span&gt;&lt;/span&gt;&lt;span&gt;来完成&lt;/span&gt;&lt;span&gt;，此处也类似于 MySQL 的 limit 的用法。上面的代码中，我们的分页每页显示 3 条，当前页是第 1 页。&lt;/span&gt;&lt;span&gt;PageRequest.of 第一个参数传递是页数，只要传递页数后，它会自动计算从第几条记录开始取数据。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Student(id=&lt;span class=&quot;code-snippet__number&quot;&gt;6153405&lt;/span&gt;a080b7946ca278b41, name=zhangsan3, age=&lt;span class=&quot;code-snippet__number&quot;&gt;33&lt;/span&gt;, email=&lt;span class=&quot;code-snippet__number&quot;&gt;3999&lt;/span&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@qq&lt;/span&gt;.com)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Student(id=&lt;span class=&quot;code-snippet__number&quot;&gt;6153405&lt;/span&gt;a080b7946ca278b42, name=zhangsan4, age=&lt;span class=&quot;code-snippet__number&quot;&gt;34&lt;/span&gt;, email=&lt;span class=&quot;code-snippet__number&quot;&gt;4999&lt;/span&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@qq&lt;/span&gt;.com)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Student(id=&lt;span class=&quot;code-snippet__number&quot;&gt;6153405&lt;/span&gt;a080b7946ca278b43, name=zhangsan5, age=&lt;span class=&quot;code-snippet__number&quot;&gt;35&lt;/span&gt;, email=&lt;span class=&quot;code-snippet__number&quot;&gt;5999&lt;/span&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@qq&lt;/span&gt;.com)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        通过返回的 Page 对象，调用 getTotalPages 方法可以得到总的页数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8.修改数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        修改数据时首先对数据进行查询，然后设置需要修改的值，再进行数据的更新。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@&lt;span class=&quot;code-snippet__function&quot;&gt;Test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;updateUser&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Student student = studentRepository.findById(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;6153405a080b7946ca278b41&quot;&lt;/span&gt;).&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    student.setName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;wangwu&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Student save = studentRepository.save(student);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(save);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;        在上面的代码中，使用 MongoRepository 的 save 方法即可完成数据的更新。在前面介绍插入时，使用的也是 save 方法。在调用 save 方法时，如果实体类中的 id 有值，则进行更新，如果没有值则进行插入操作。具体看其实现源码，源码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &amp;lt;S extends T&amp;gt; S save(S entity) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Assert.notNull(entity, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Entity must not be null!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.entityInformation.isNew(entity) ? &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.mongoOperations.insert(entity, &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.entityInformation.getCollectionName()) : &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.mongoOperations.save(entity, &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.entityInformation.getCollectionName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        可以看到源码中使用 isNew 来判断是插入操作，还是更新操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        接着来查看我们的数据是否被更新，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.19326065411298315&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwtgt6X1UqgVayWlB9mwsLtP56jibWaRlkuYeHdbpGAHmFQvVjyGuehCylErETsj6F32okaYMtNkwbAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1009&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在更新字段时，更新哪个字段则对那个字段进行设置即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;9.删除数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        删除操作直接使用 MongoRepository 提供的 deleteById 进行删除即可，代码如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@&lt;span class=&quot;code-snippet__function&quot;&gt;Test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;deleteUser&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    studentRepository.deleteById(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;6153405a080b7946ca278b41&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;六、总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        MongoDB 已经被越来越多的使用，它适合于对大量的、无固定数据结构的数据进行存储。本文简单的介绍了通过使用 MongoRepository 来对 MongoDB 进行 CRUD 的操作，上篇文章介绍了 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484598&amp;amp;idx=1&amp;amp;sn=e28020c5506c3eaecd4395a18124058a&amp;amp;chksm=e973e28cde046b9a0990d41157898dacdf91c70ecf9d4a691422b93fc0fd8ea549ae9ac0dfe8&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;使用 MongoTemplate 对 MongoDB 进行 CRUD&lt;/a&gt; 的内容。大家可以对比学习。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;两篇文章整理成了 PDF 文件，公众号内回复 【mongo】 下载 SpringBoot 整合操作 MongoDB 的文档。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;更多文章&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JHWsQdz8yVn3MVh22hia7NFoPyNJz4ZI7XUnMa9xM50TJRqPkWf7BRibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>31ea06d3872e571e9f9511feae6b9d99</guid>
<title>自动替换 Kubernetes 镜像</title>
<link>https://toutiao.io/k/gopzxm8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MjM5OTg2MTM0MQ==&amp;amp;action=getalbum&amp;amp;album_id=1950838022879477762#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1950838022879477762&quot; data-tag_source=&quot;3&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#kubernetes&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;4个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;前几天有朋友在问如何在某云上拉取 Tekton 的镜像，这种情况其实比较普遍不只是某云。工作中经常要用到过某些靠运气才能拉取到的镜像，这对工作来说真是极度的不友好。&lt;/p&gt;&lt;p&gt;因此也萌生了个想法，维护一个后网络友好的仓库镜像，在 Pod 创建时将镜像仓库切换到自维护的仓库，从自维护的仓库拉取镜像。&lt;/p&gt;&lt;p&gt;前几天&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5OTg2MTM0MQ==&amp;amp;mid=2247484487&amp;amp;idx=1&amp;amp;sn=c5e7a0d11b82bba9be42d503d215299b&amp;amp;scene=21#wechat_redirect&quot; title=&quot;体验了极狐Gitlab 的容器镜像库&quot; data-linktype=&quot;2&quot;&gt;体验了极狐Gitlab 的容器镜像库&lt;/a&gt;，便是为这个想法做的准备。当然其他的云厂商也有提供针对个人版的免费镜像仓库和企业版仓库。&lt;/p&gt;&lt;p&gt;正好 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5OTg2MTM0MQ==&amp;amp;mid=2247484402&amp;amp;idx=1&amp;amp;sn=e9414acf54d7509f00260a112cdd5666&amp;amp;scene=21#wechat_redirect&quot; title=&quot;Pipy 作为策略引擎&quot; data-linktype=&quot;2&quot;&gt;Pipy 作为策略引擎&lt;/a&gt;，非常适合实现这种策略的执行。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9300411522633745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxdsQHSd4ewsab58iauULJgZiaMHDqMMGVpB1LUibzYBMzIK1S9SVCkQPB1wTRYlWdMPZyUEnCXiajG1ng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;486&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;实现思路&lt;/h2&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7993254637436762&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxdsQHSd4ewsab58iauULJgZiazGdOyStE98RKnA7hiaC8gO5oL1SGxUZfiaPCrr4qXqAdrVXbOhxnQvnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2372&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;Admission Webhook&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Kubernetes 动态准备控制&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt; 的 &lt;code&gt;MutatingWebhookConfiguration&lt;/code&gt; 可以 hook Pod 的创建或者更新，然后调用目标服务对 Pod 资源对象进行 patch 操作。&lt;/p&gt;&lt;h3&gt;策略引擎&lt;/h3&gt;&lt;p&gt;Pipy 作为应用的核心，也就是 &lt;code&gt;MutatingWebhookConfiguration&lt;/code&gt; 的目标服务，以策略引擎的角色完成策略的执行。&lt;/p&gt;&lt;p&gt;Pipy 支持从文件或者 HTTP 地址加载脚本，这里为了便于策略的更新，使用了后者。&lt;/p&gt;&lt;p&gt;对于从 HTTP 地址加载脚本，HTTP 地址返回内容的第一行会作为 Pipy 的主脚本，Pipy 启动时会加载主脚本，其他的文件也会被缓存到内存中。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#地址 http://localhost:6080/repo/registry-mirror/&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ curl http&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//localhost:6080/repo/registry-mirror/&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;js&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;Pipy 会每隔 5s 检查脚本和配置文件的 &lt;code&gt;etag&lt;/code&gt;（就是文件的最后更新时间），假如与当前文件的 etag 不一致，则会缓存并重新加载。&lt;/p&gt;&lt;p&gt;利用 Pipy 的这个特性，便可以策略和配置的准实时更新。&lt;/p&gt;&lt;h3&gt;策略&lt;/h3&gt;&lt;p&gt;对于策略的部分，我们将其逻辑和配置进行了分离。配置部分，配置了需要进行替换的镜像的前缀，以及替换成的内容；而逻辑，这是对 &lt;code&gt;MutatingWebhookConfiguration&lt;/code&gt; 的 &lt;code&gt;AdmissionReview&lt;/code&gt; 的对象进行检查。&lt;/p&gt;&lt;p&gt;配置：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&quot;registries&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&quot;gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;registry.gitlab.cn/flomesh/registry-mirror/tekton-pipeline&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;比如说，对于镜像 &lt;code&gt;gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/controller:v0.28.1&lt;/code&gt;，将 &lt;code&gt;gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd&lt;/code&gt; 替换成 &lt;code&gt;registry.gitlab.cn/addozhang/registry-mirror/tekton-pipeline&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;Demo&lt;/h2&gt;&lt;p&gt;本文使用所有的&lt;span&gt;源码&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;都已上传到了 github。&lt;/p&gt;&lt;h3&gt;脚本服务器&lt;/h3&gt;&lt;p&gt;既然选用了 HTTP 方式加载 Pipy 的脚本，那就需要实现一个脚本服务器。实现的方式有两种：使用脚本实现脚本服务器和使用 Pipy 内置的 Codebase。&lt;/p&gt;&lt;h4&gt;使用脚本实现脚本服务器&lt;/h4&gt;&lt;p&gt;根据需求定义两种路由：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;/repo/registry-mirror/&lt;/code&gt;：返回脚本和配置的文件列表&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;/repo/registry-mirror/[File Name]&lt;/code&gt;：返回对应的文件的内容，同时需要在响应头添加 &lt;code&gt;etag&lt;/code&gt;，值是文件的更新时间&lt;/span&gt;&lt;/p&gt;&lt;p&gt;具体脚本如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#repo.js&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;pipy&lt;/span&gt;&lt;span&gt;({&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  _serveFile&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;req&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; filename&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    filename &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; req&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;substring&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    os&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;stat&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;filename&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Message&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;          bodiless&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; req&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;method &lt;/span&gt;&lt;span&gt;===&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;HEAD&#x27;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;          headers&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&#x27;etag&#x27;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; os&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;stat&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;filename&lt;/span&gt;&lt;span&gt;)?.&lt;/span&gt;&lt;span&gt;mtime &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&#x27;content-type&#x27;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;},&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;},&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        req&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;method &lt;/span&gt;&lt;span&gt;===&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;HEAD&#x27;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; os&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;filename&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Message&lt;/span&gt;&lt;span&gt;({&lt;/span&gt;&lt;span&gt; status&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;404&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;},&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;`file ${filename} not found`&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  _router&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; algo&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;URLRouter&lt;/span&gt;&lt;span&gt;({&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&#x27;/repo/registry-mirror/&#x27;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Message&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&#x27;/main.js\n/config.json&#x27;&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&#x27;/repo/registry-mirror/*&#x27;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; req &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; _serveFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;req&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;text/plain&#x27;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;}),&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;listen&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;6080&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;serveHTTP&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    req &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; _router&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;find&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;req&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;)(&lt;/span&gt;&lt;span&gt;req&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;)%&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ pipy repo&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;js&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Module&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;repo&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;js&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;===============&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Listen&lt;/span&gt;&lt;span&gt; on &lt;/span&gt;&lt;span&gt;:::&lt;/span&gt;&lt;span&gt;6080&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;-----&amp;gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;       serveHTTP&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;-----|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;listener&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Listening&lt;/span&gt;&lt;span&gt; on port &lt;/span&gt;&lt;span&gt;6080&lt;/span&gt;&lt;span&gt; at &lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;检查路由：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ curl http&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//localhost:6080/repo/registry-mirror/&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;js&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ curl http&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//localhost:6080/repo/registry-mirror/main.js&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#省略 main.js 的内容&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ curl http&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//localhost:6080/repo/registry-mirror/config.json&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#省略 config.json 的内容&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h4&gt;使用 Pipy 内置的 Codebase&lt;/h4&gt;&lt;p&gt;在最新发布的 Pipy 内置了一个 Codebase，大家可以理解成脚本仓库，但是比单纯的仓库功能更加强大（后面会有文档介绍该特性）。&lt;/p&gt;&lt;p&gt;目前版本的 Codebase 还未支持持久化的存储，数据都是保存在内存中。后续会提供 KV store 或者 git 类型的持久化支持。&lt;/p&gt;&lt;p&gt;启动 Pipy 的 Codebase很简单：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ pipy&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;codebase&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Starting&lt;/span&gt;&lt;span&gt; codebase service&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;08&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;listener&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Listening&lt;/span&gt;&lt;span&gt; on port &lt;/span&gt;&lt;span&gt;6060&lt;/span&gt;&lt;span&gt; at &lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6430555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxdsQHSd4ewsab58iauULJgZiaEylbTLbYerJiatKgYjeeVm7KLx1825KNtLy4BEmJvae3dLcPtHibORiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;对于新的 Codebase 控制台的使用，这里不做过多的介绍，直接使用 REST API 完成脚本的写入：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#创建 registry-mirror codebase，会自动创建一个空的 main.js&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ curl &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;X POST http&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//localhost:6060/api/v1/repo/registry-mirror&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#更新 main.js&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ curl &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;X POST &lt;/span&gt;&lt;span&gt;&#x27;http://localhost:6060/api/v1/repo/registry-mirror/main.js&#x27;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;binary &lt;/span&gt;&lt;span&gt;&#x27;@scripts/main.js&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#创建 config.json&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ curl &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;X POST &lt;/span&gt;&lt;span&gt;&#x27;http://localhost:6060/api/v1/repo/registry-mirror/config.json&#x27;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;binary &lt;/span&gt;&lt;span&gt;&#x27;@scripts/config.json&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#检查 codebase 的版本&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ curl &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;s http&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//localhost:6060/api/v1/repo/registry-mirror | jq -r .version&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#更新版本&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ curl &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;X POST &lt;/span&gt;&lt;span&gt;&#x27;http://localhost:6060/api/v1/repo/registry-mirror&#x27;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;raw &lt;/span&gt;&lt;span&gt;&#x27;{&quot;version&quot;:2}&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;安装&lt;/h3&gt;&lt;p&gt;进入到项目的根目录中，执行：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ helm install registry&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mirror &lt;/span&gt;&lt;span&gt;./&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mirror &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;n &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;NAME&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; registry&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mirror&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;LAST DEPLOYED&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Tue&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Oct&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2021&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;NAMESPACE&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;STATUS&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; deployed&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;REVISION&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;TEST SUITE&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;查看 webhook：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ kubectl &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; mutatingwebhookconfigurations&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;NAME                      WEBHOOKS   AGE&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mirror&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;webhook   &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;2m6s&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;检查 pod 的启动日志：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ kubectl logs &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;n pipy &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;l app&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;pipy&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;codebase&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; GET http&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//192.168.1.101:6060/repo/registry-mirror/ -&amp;gt; 21 bytes&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;codebase&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; GET &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;repo&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mirror&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;js &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2213&lt;/span&gt;&lt;span&gt; bytes&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;codebase&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; GET &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;repo&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mirror&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;json &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;149&lt;/span&gt;&lt;span&gt; bytes&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Module&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;js&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;===============&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Listen&lt;/span&gt;&lt;span&gt; on &lt;/span&gt;&lt;span&gt;:::&lt;/span&gt;&lt;span&gt;6443&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;-----&amp;gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;       acceptTLS&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;|--&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;tls&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;offloaded&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;              decodeHTTPRequest&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;              replaceMessage&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;              encodeHTTPResponse &lt;/span&gt;&lt;span&gt;--&amp;gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;                                    &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;---------------------------------|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;2021&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;listener&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Listening&lt;/span&gt;&lt;span&gt; on port &lt;/span&gt;&lt;span&gt;6443&lt;/span&gt;&lt;span&gt; at &lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;测试&lt;/h3&gt;&lt;p&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5OTg2MTM0MQ==&amp;amp;mid=2247484487&amp;amp;idx=1&amp;amp;sn=c5e7a0d11b82bba9be42d503d215299b&amp;amp;scene=21#wechat_redirect&quot; title=&quot;上一篇&quot; data-linktype=&quot;2&quot;&gt;上一篇&lt;/a&gt;中我已经推送了 Tekton 的两个镜像到容器镜像库中，因此这里直接安装 tekton 进行测试。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ kubectl apply &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;filename https&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//storage.googleapis.com/tekton-releases/pipeline/previous/v0.28.1/release.yaml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ kubectl &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; pod &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;n tekton&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;pipelines&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;NAME                                           READY   STATUS    RESTARTS   AGE&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;tekton&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;pipelines&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;75974fbfb8&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;f62dv   &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;7m36s&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;tekton&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;pipelines&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;webhook&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;6cc478f7ff&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mm5l9      &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;7m36s&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;检查结果：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ kubectl &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; pod &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;o json &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;n tekton&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;pipelines &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;l app&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;tekton&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;pipelines&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;controller &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; jq &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;r &lt;/span&gt;&lt;span&gt;&#x27;.items[].spec.containers[].image&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;gitlab&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;cn&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;flomesh&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mirror&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;tekton&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;pipeline&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;v0&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;28.1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ kubectl &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; pod &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;o json &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;n tekton&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;pipelines &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;l app&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;tekton&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;pipelines&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;webhook &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; jq &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;r &lt;/span&gt;&lt;span&gt;&#x27;.items[].spec.containers[].image&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;gitlab&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;cn&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;flomesh&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mirror&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;tekton&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;pipeline&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;webhook&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;v0&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;28.1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;从上面的结果可以看到结果是符合预期的。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;整个实现的策略部分加上配置，只有 70 多行的代码。并且实现了逻辑与配置的分离之后，后续的配置也都可以做到实时的更新而无需修改任何逻辑代码，更无需重新部署。&lt;/p&gt;&lt;p&gt;但是目前的实现，是需要手动把镜像推送的自维护的镜像仓库中。实际上理想的情况是检查自维护的仓库中是否存在镜像（比如通过 REST API），如果未发现镜像，先把镜像拉取到本地，&lt;code&gt;tag&lt;/code&gt; 后再推送到自维护的仓库。不过这种操作，还是需要网络的畅通。当然也尝试过通过 REST API 触发 CICD Pipeline 的执行拉取镜像并 tag，但是极狐Gitlab 是部署在某云的环境上，同样也受困于网络问题。&lt;/p&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; Kubernetes 动态准备控制: &lt;em&gt;https://kubernetes.io/zh/docs/reference/access-authn-authz/extensible-admission-controllers/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; 源码: &lt;em&gt;https://github.com/addozhang/registry-mirror&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>