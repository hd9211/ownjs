<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0060fe78d971aa1e2717d0b9eecb78df</guid>
<title>中国最著名的黑客排行榜</title>
<link>https://toutiao.io/k/gcdt8gi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;“黑客”算是一个外来词，&lt;/p&gt;

&lt;p&gt;是“hacker”的中文翻译。原意是指一些热衷于计算机和网络技术的人。这些人为计算机和网络世界而发狂，对任何有趣的问题都会去研究，他们的精神是一般人所不能领悟的。这样的“hacker”是一个褒意词。但英雄谁都愿意做，慢慢的有些人打着黑客的旗帜，做了许多并不光彩的事。黑客们叫他们骇客（creaker)，并以他们为耻，不愿和他们做朋友。&lt;/p&gt;

&lt;p&gt;其实，黑客和骇客并没有一个十分明显的界限。他们都入侵网络，破解密码。但从他们的出发点上看，却有着本质的不同：黑客是为了网络安全而入侵，为了提高自己的技术而入侵。free是黑客们的理想，&lt;/p&gt;

&lt;p&gt;他们梦想的网络世界是没有利益冲突，没有金钱交易，完全共享的自由世界。而骇客们呢，为了达到自己的私欲，进入别人的系统大肆破坏。为了几个零花钱而破解软件。黑客们拼命的研究，是为了完善网络，是网络更加安全。&lt;/p&gt;

&lt;p&gt;骇客们也在钻研，他们是为了成为网络世界的统治者。&lt;/p&gt;

&lt;p&gt;NO.1  goodwell&lt;/p&gt;

&lt;p&gt;网名：goodwell QQ228095全名:龚蔚&lt;/p&gt;

&lt;p&gt;所属组织；绿色兵团 介绍：中国最早黑客组织绿色兵团的创始人，中国黑客界泰斗级元老。&lt;/p&gt;

&lt;p&gt;入选理由：作为中国黑客界最早组织创始人，goodwell领导下绿色兵团在网络界甚至更广领域都得到认同。他与其组织揭开中国黑客历史的序幕。他个人也因此受到黑客界的爱戴。虽然现在他本人已经很少在黑客界露面，其组织也已经解散。但他对黑客界的贡献仍是巨大的。&lt;/p&gt;

&lt;p&gt;NO.2 KING&lt;/p&gt;

&lt;p&gt;网名:KING QQ1576172全名:谭绪武&lt;/p&gt;

&lt;p&gt;所属组织；中国黑客联盟 介绍：中国最早期黑客组织中国黑客联盟的创始人，中国黑客界泰斗级元老，中国传奇黑客。&lt;/p&gt;

&lt;p&gt;入选理由：原中国黑客联盟站长。2001年中]=美黑客大战领军人物之一，中国第1代黑客之一，中国最早期黑客组织中国黑客联盟的创始人，中国黑客界泰斗级元老，中国传奇黑客。&lt;/p&gt;

&lt;p&gt;NO.3  coolfire&lt;/p&gt;

&lt;p&gt;coolfire  全名:谢朝霞&lt;/p&gt;

&lt;p&gt;QQ:304093101&lt;/p&gt;

&lt;p&gt;所属组织：飞鹰工作室 介绍：中国台湾著名黑客，中国黑客界元老人物&lt;/p&gt;

&lt;p&gt;入选理由：作为黑客界元老级人物，coolfrie所编写的许多技术文章仍在指导着众多中国黑客技术方向。作为一位台湾黑客，他对海峡两岸统一的支持，对黑客界的贡献，是有目共睹的。coolfrie以他的能力做出值得人们尊敬的黑客篇章。&lt;/p&gt;

&lt;p&gt;NO.4  抱雪&lt;/p&gt;

&lt;p&gt;网名：抱雪全名:徐伟辰&lt;/p&gt;

&lt;p&gt;QQ:648681048&lt;/p&gt;

&lt;p&gt;所属组织：第八军团 介绍：中国技术实力最强的黑客教学网站长，中国黑客界泰斗级领袖。&lt;/p&gt;

&lt;p&gt;入选理由：伟辰领导下的第八军团成为教学网中技术实力最强的组织，他与老邪的黄金搭档摆脱了黑客教学平庸的局面，成为众多各段级黑客的集中地。这与伟辰的领导不无相关，伟辰以他低调的风格影响着新一代黑客走向。&lt;/p&gt;

&lt;p&gt;NO.5  教主&lt;/p&gt;

&lt;p&gt;网名：教主 全名:徐达&lt;/p&gt;

&lt;p&gt;QQ:不详&lt;/p&gt;

&lt;p&gt;所属组织：华夏黑客同盟 介绍：中国黑客第一门户教学网站站长，中国黑客界领袖人物。&lt;/p&gt;

&lt;p&gt;入选理由：华夏同盟作为中国黑客第一教学门户，影响着黑客界的未来发展，他作为站长在其中有着巨大作用。同时教主所开发的众多黑客程序一直是受黑客们欢迎的必备工具。他以平凡的事情影响着黑客界的未来。&lt;/p&gt;

&lt;p&gt;NO.6  中国鹰派&lt;/p&gt;

&lt;p&gt;网名：中国鹰派 全名:袁仁广&lt;/p&gt;

&lt;p&gt;QQ:不详&lt;/p&gt;

&lt;p&gt;所属组织：中国鹰派联盟 介绍：中国现在最大黑客组织创始人站长，中国黑客界泰斗级领袖。&lt;/p&gt;

&lt;p&gt;入选理由：这位曾经加入绿色兵团后又创建了现在黑客界最大组织CEU的领袖。他经历了黑客界各大组织发展变迁，深刻了解黑客文化发展才创立现役规范规模的鹰派联盟。如今的鹰派联盟以成为黑客界权威组织，也使“中国鹰派”成为黑客界不可缺少的影响力人物。&lt;/p&gt;

&lt;p&gt;NO.7  孤独剑客&lt;/p&gt;

&lt;p&gt;网名：孤独剑客 全名:陈三少&lt;/p&gt;

&lt;p&gt;QQ:不详&lt;/p&gt;

&lt;p&gt;所属组织：黑客基地 介绍：剑客联盟站长，中国黑客界新一代黑客泰斗人物。&lt;/p&gt;

&lt;p&gt;入选理由：曾经作为剑客联盟站长风云一时，现加入黑客基地，他的名字已经在黑客界家喻户晓。他正演绎属于他自己的黑客生涯，同时他用自身的技术实力征服着每个向往黑客的人，作为并不新的新一代黑客，未来黑客界还得靠他们。&lt;/p&gt;

&lt;p&gt;NO.8  冰叶&lt;/p&gt;

&lt;p&gt;网名：冰叶 QQ23323326&lt;/p&gt;

&lt;p&gt;全名；不详&lt;/p&gt;

&lt;p&gt;所属组织；中国蓝客联盟 介绍：中国网络界黑马组织的蓝客联盟组织部长，中国黑客界第一管理大师。&lt;/p&gt;

&lt;p&gt;入选理由：作为曾经刹驰风云的黑客组织蓝客联盟组织部长，他以其天才的组织管理策划能力为蓝客联盟发展做出巨大贡献，但由于内部原有的分裂和其它困境原因，一直得不到好的发展。他所创作论文对黑客组织发展有着指导性影响，为黑客界作出了贡献。希望在以后他能继续作为。&lt;/p&gt;

&lt;p&gt;NO.9  中华特攻&lt;/p&gt;

&lt;p&gt;网名：中华特攻&lt;/p&gt;

&lt;p&gt;全名；不详&lt;/p&gt;

&lt;p&gt;(King\&#x27;Xer) 所属组织：中国网络安全部队、雷霆反计算机病毒小组&lt;/p&gt;

&lt;p&gt;介绍：中国网络安全部队站长，雷霆反计算机病毒小组站长，中国黑客界新一代黑客泰斗人物。&lt;/p&gt;

&lt;p&gt;入选理由：此人对软件程式编译及程式破解方面有较高的技术，对防火墙及反病毒技术有着深入的研究，曾写过不少技术论文《防火墙突破最新方案》、《雷霆教你反病毒》等一些有重要意义的文章就是出自此人之手，开发过不少黑客工具，其中&lt;/p&gt;

&lt;p&gt;“WINDOWS 2000 安全过滤系统”也是出自此人之手，为黑客界作出了贡献。&lt;/p&gt;

&lt;p&gt;NO.10  冰雪封情&lt;/p&gt;

&lt;p&gt;网名：冰雪封情&lt;/p&gt;

&lt;p&gt;所属组织：邪恶八进制 介绍：中国现役风云组织邪恶八进制站长，中国黑客界后起领袖人物。&lt;/p&gt;

&lt;p&gt;入选理由：现在如日中天的邪恶八进制在冰雪封情的正带领走向另一个新的高峰，在进入黑客界并不很久的情况下冰血封情以极快的速度发展自己和所在组织，并影响着其他黑客向着更高顶峰攀登，期待着他能更多的为黑客文化作出更多贡献&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f0e0991d5b2c70e864bfd793a0c53eb4</guid>
<title>这些不可不知的 JVM 知识，我都用思维导图整理好了</title>
<link>https://toutiao.io/k/vxuckw2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;JVM是面试中必问的部分，本文通过思维导图以面向面试的角度整理JVM中不可不知的知识。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先上图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0387172467735628&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkptLub4muyteQaY9mEQpMdgbtWFficjzmh9Yyg6ia9LFViaVjYUGyYT3Ug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2557&quot;/&gt;&lt;figcaption&gt;JVM必备知识&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、JVM基本概念&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1、JVM是什么&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM 的全称是 &lt;strong&gt;「Java Virtual Machine」&lt;/strong&gt;，也就是我们耳熟能详的 Java 虚拟机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM具备着计算机的基本运算方式，它主要负责把 Java 程序生成的字节码文件，解释成具体系统平台上的机器指令，让其在各个平台运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM是运行在操作系统上的，它与硬件没有直接的交互。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;当然，严格来说JVM也是虚拟机规范，有很多不同的实现，Sun/OracleJDK和OpenJDK中的默认Java虚拟机是HotSpot虚拟机，是目前使用范围最广的Java虚拟机，一般讲到的JVM默认指的就是HotSpot虚拟机。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2、Java程序运行过程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.402555910543131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkBJ8WGribUrLKXPsMtYk5ibUWw5N2tPcxPGzK5aNrtl17eoGMhx2CZFjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;313&quot;/&gt;&lt;figcaption&gt;image-20210213164039026&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3、JDK、JRE、JVM&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;JDK&lt;/strong&gt;(Java Development Kit Java 开发工具包)，JDK 是提供给 Java 开发人员使用的，其中包含了 Java 的开发工具，也包括了 JRE。其中的开发工具包括编译工具(javac.exe) 打包工具(jar.exe)等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;JRE&lt;/strong&gt;(Java Runtime Environment Java 运行环境) 是 JDK 的子集，也就是包括 JRE 所有内容，以及开发应用程序所需的编译器和调试器等工具。JRE 提供了库、Java 虚拟机（JVM）和其他组件，用于运行 Java 编程语言、小程序、应用程序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;JVM&lt;/strong&gt;(Java Virtual Machine Java 虚拟机)，JVM 可以理解为是一个虚拟出来的计算机，具备着计算机的基本运算方式，它主要负责把 Java 程序生成的字节码文件，&lt;/p&gt;&lt;p&gt;解释成具体系统平台上的机器指令，让其在各个平台运行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK中包含JRE，也包括JDK，而JRE也包括JDK。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;范围关系：JDK&amp;gt;JRE&amp;gt;JVM。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6042972247090421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkOicXITib1ggZI8SuicviaCJtUvBls3A9DnuHAKq4OKRkuGsiaBibbNvFHUkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1117&quot;/&gt;&lt;figcaption&gt;image-20210213164531155&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、JVM内存区域&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7456709956709957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkhiahyt4WacibhXibXe5Ww0e3E6wk40WNOOGtbTkiaz4mGJgyCFb6qaIOlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;924&quot;/&gt;&lt;figcaption&gt;image-20210213172256916&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，实际上，为了更好的适应 CPU 性能提升，最大限度提升JVM 运行效率，JDK中各个版本对JVM进行了一些迭代，示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7434908389585342&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkpXibuURvWKuppyv5WwkqwNibVEx1btX45WypT8435DTRSBc8kqVFicaXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1037&quot;/&gt;&lt;figcaption&gt;image-20210213172547779&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK1.6、JDK1.7、JDK1.8 JVM 内存模型主要有以下差异：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JDK 1.6：有永久代，静态变量存放在永久代上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JDK 1.7：有永久代，但已经把字符串常量池、静态变量，存放在堆上。逐渐的减少永久代的使用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JDK 1.8：无永久代，运行时常量池、类常量池，都保存在元数据区，也就是常说的元空间。但字符串常量池仍然存放在堆上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1、程序计数器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是 Native 方法，则为空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2、Java虚拟机栈&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3041825095057034&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkK9qmjlClb6g3HIIOQ6zrcFuDoiblu1wYevoJqH7GPic9CcQ9kYiavkeTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;789&quot;/&gt;&lt;figcaption&gt;image-20210214142724540&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3、本地方法栈&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native） 方法服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hot-Spot虚拟机直接把本地方法栈和虚拟机栈合二为一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4、Java堆&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从回收内存的角度看，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Java 堆，由年轻代和年老代组成，分别占据 1/3 和 2/3。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;而年轻代又分为三部分，&lt;strong&gt;Eden&lt;/strong&gt;、&lt;strong&gt;From Survivor&lt;/strong&gt;、&lt;strong&gt;To Survivor&lt;/strong&gt;，占据比例为 8:1:1，可调。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体实现的固有内存布局，HotSpot里面已经出现了不采用分代设计的新垃圾收集器。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2974413646055437&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkicMVicINoT6fbicjQ7KwUYygCljb5nQnP3RzqmfKrn5tM57mgsPH0UmKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot;/&gt;&lt;figcaption&gt;image-20210213193521527&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.5、方法区（JDK1.8移除）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JDK1.8以前，HotSpot使用永久代来实现方法区，所以某些场合也认为方法区和永久代是一个概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JDK 6的 时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用在本地内存中实现的元空间（Meta- space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.6、运行时常量池&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行时常量池（Runtime Constant Pool）是方法区的一部分——在JDK1.8已经被移到了元空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行时常量池相对于Class文件常量池的一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的 intern()方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.7、直接内存&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;元空间&lt;/strong&gt;从虚拟机 Java 堆中转移到本地内存，默认情况下，元空间的大小仅受本地内存的限制。&lt;em&gt;jdk1.8 以前版本的 class 和 JAR 包数据存储在 PermGen 下面 ，PermGen 大小是固定的，而且项目之间无法共用，公有的 class，所以比较容易出现 OOM 异常。&lt;/em&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;升级 JDK 1.8 后，元空间配置参数，-XX:MetaspaceSize=512M XX:MaxMetaspaceSize=1024M。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、JVM中的对象&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面已经了解Java虚拟机的运行时数据区域，我们接下来更进一步了解这些虚拟机内存中数据的其他细节，譬如它们是如何创建、如何布局以及如何访问的。以最常用的虚拟机HotSpot和最常用的内存区域Java堆为例，了解一下HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1、对象的创建&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java对象创建的大概过程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2255790533736153&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgk8ic81zkjNTicl0k1SUxQL21YG3ic5vlNLdWnEXyDvxSkFRtSCvezVibYpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;993&quot;/&gt;&lt;figcaption&gt;image-20210214114717010&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;①&lt;/strong&gt;类加载检查：虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引⽤，并且检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执⾏相应的类加载过程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;②&lt;/strong&gt;分配内存：在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存。对象所需的内存⼤⼩在类加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定⼤⼩的内存从 Java 堆中划分出来。分配⽅式有 &lt;strong&gt;“&lt;strong&gt;指针碰撞&lt;/strong&gt;”&lt;/strong&gt; 和 &lt;strong&gt;“&lt;strong&gt;空闲列表&lt;/strong&gt;”&lt;/strong&gt; 两种，选择那种分配⽅式由 &lt;strong&gt;Java&lt;/strong&gt; 堆是否规整决定，⽽&lt;strong&gt;Java&lt;/strong&gt;堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;内存分配的两种⽅式：选择以上两种⽅式中的哪⼀种，取决于 Java 堆内存是否规整。⽽ Java 堆内存是否规整，取决于 GC收集器的算法是&quot;标记-清除&quot;，还是&quot;标记-整理&quot;（也称作&quot;标记-压缩&quot;），值得注意的是，复制算法内存也是规整的。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2424908424908425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkEdBRePBTVREicKEtAYu1LxwfL96hncIhJjYXHcoP0D6U2s0DfziatyTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1365&quot;/&gt;&lt;figcaption&gt;image-20210214115130021&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;③&lt;/strong&gt;初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，程序能访问到这些字段的数据类型所对应的零值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;④&lt;/strong&gt;设置对象头：初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;⑤&lt;/strong&gt;执⾏ &lt;strong&gt;init&lt;/strong&gt; ⽅法：在上⾯⼯作都完成之后，从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从Java 程序的视⻆来看，对象创建才刚开始，  ⽅法还没有执⾏，所有的字段都还为零。所以⼀般来说，执⾏ new 指令之后会接着执⾏  ⽅法，把对象按照程序员的意愿进⾏初始化，这样⼀个真正可⽤的对象才算完全产⽣出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2、对象的内存布局&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.49943246311010214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgk0uGpibrfFCqjon82ibIo7fk9ShC4ice9S25SorQXDH4dR5ZJJbT3vkXKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;881&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HotSpot虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3、对象的访问定位&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建⽴对象就是为了使⽤对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问⽅式有虚拟机实现⽽定，⽬前主流的访问⽅式有&lt;strong&gt;①&lt;/strong&gt;使⽤句柄和&lt;strong&gt;②&lt;/strong&gt;直接指针两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;句柄&lt;/code&gt;：如果使⽤句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池，reference 中存储的就是对象的句柄地址，⽽句柄中包含了对象实例数据与类型数据各⾃的具体地址信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44457409568261375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkO5vibHHt3WOjj8z0NYfbfPGGkIYp7CbBBW6s7jiaick5xExJ5PzpS5Y3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;857&quot;/&gt;&lt;figcaption&gt;image-20210214120115895&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;直接指针&lt;/code&gt;：如果使⽤直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，⽽reference 中存储的直接就是对象的地址。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4511494252873563&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkPoeLgVyWxpcqT7hHe7wbXJiaibiaAicuF6H9sbyl6LJAfEOCYmC7KGrhRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;&lt;figcaption&gt;image-20210214120227426&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、GC垃圾回收&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于垃圾回收，主要考虑的就是完成三件事：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1、如何判断对象需要回收？&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1.1、引用计数法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用计数法的算法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当引用失效时，计数器值就减一；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任何时刻计数器为零的对象就是不可 能再被使用的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客观地说，引用计数算法（Reference Counting）虽然占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。也有一些比较著名的应用案例，例如微软COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言以及在游戏脚本领域得到许多应用的Squirrel中都使用了引用计数算法进行内存管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，在Java 领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，例如在处理处理一些相互依赖、循环引用时非常复杂。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1.2、可达性分析算法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7062706270627063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkqfVQwb62t7PPp8bNpjU7XWewnoiaqdScicN1TWwc9PeE4r9W6iaEJgywA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;909&quot;/&gt;&lt;figcaption&gt;image-20210214121217760&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GC Roots 包括；&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;全局性引用，对方法区的静态对象、常量对象的引用&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;执行上下文，对 Java 方法栈帧中的局部对象引用、对 JNI handles 对象引用&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;已启动且未停止的 Java 线程&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1.3、引用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和“引用”离不开关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java的引用分为四种：&lt;strong&gt;强引用（Strongly Re-ference）&lt;/strong&gt;、&lt;strong&gt;软引用（Soft Reference）&lt;/strong&gt;、&lt;strong&gt;弱引用（Weak Reference）&lt;strong&gt;和&lt;/strong&gt;虚引用（Phantom Reference）&lt;/strong&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。Java提供提供了SoftReference类来实现软引用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java提供了WeakReference类来实现弱引用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。Java提供了PhantomReference类来实现虚引用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2、垃圾收集算法&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2.1、标记-清除算法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最早出现也是最基础的垃圾收集算法是“标记-清除”（Mark-Sweep）算法，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法分为“&lt;code&gt;标记&lt;/code&gt;”和“&lt;code&gt;清除&lt;/code&gt;”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的主要缺点有两个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程的执行效率都随对象数量增长而降低；&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-清除算法的执行过程如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5969387755102041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgko4Nq42lAfzxUj9JpchOiaDviasrUoItgibXOVo9HhY3VSpRDRSXrChFeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;980&quot;/&gt;&lt;figcaption&gt;image-20210213205500815&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2.2、标记-复制算法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-复制算法常被简称为复制算法。为了解决标记-清除算法面对大量可回收对象时执行效率低的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费较多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-复制算法的执行过程如图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5768854064642507&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkDFw2RUrVlkYV7EOR76dxeeu8REg6mr8ibDmfNDtDvOeJNpSe3n59xNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1021&quot;/&gt;&lt;figcaption&gt;image-20210213205852314&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2.3、标记-整理算法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-整理算法的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“标记-整理”算法的示意图如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6131386861313869&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkicFTUD4jcqCsAI8MPII61bSyknTwaLGhcJK8HvTOjXuLQB9KCUEofFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;959&quot;/&gt;&lt;figcaption&gt;image-20210213210117656&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3、分代收集理论&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前商业虚拟机的垃圾收集器，大多数都遵循了“&lt;code&gt;分代收集&lt;/code&gt;”（Generational Collection）的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于这两个假说，收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计者一般至少会把Java堆划分为&lt;code&gt;新生代&lt;/code&gt;（Young Generation）和&lt;code&gt;老年代&lt;/code&gt;（Old Generation）两个区域。顾名思义，在新生代中，每次垃圾收集&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于这种分代，老年代和新生代具备不同的特点，可以采用不同的垃圾收集算法。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;⽐如在新⽣代中，每次收集都会有⼤量对象死去，所以可以选择&lt;code&gt;标记-复制&lt;/code&gt;算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;⽽⽼年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分配担保，所以必须选择&lt;code&gt;标记-清除&lt;/code&gt;或&lt;code&gt;标记-整理&lt;/code&gt;算法进⾏垃圾收集。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;因为有了分代收集理论，所以就有了了“Minor GC（新⽣代GC）”、“Major GC（⽼年代GC）”、“Full GC（全局GC）”这样的回收类型的划分&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4、垃圾收集器&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4.1、Serial收集器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial收集器是最基础、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是HotSpot虚拟机新生代收集器的唯一选择。这个收集器是一个单线程工作的收集器，但它的“单线 程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial/Serial Old收 集器的运行过程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21089223638470453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkLay9aAFksP1VA4zXIPMOwU2FsmTNE8PeEcHbAMPl1k4YBib2fjapvhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;863&quot;/&gt;&lt;figcaption&gt;image-20210213213230637&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4.2、ParNew收集器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX：PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ParNew收集器的工作过程如图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21552723059096177&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkg5mqlDEQ6egDzOwlGXoT48DbFRdD6iaRRWwHJh6T9eoap4m1xcKGInA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;863&quot;/&gt;&lt;figcaption&gt;image-20210213213606136&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4.3、Parallel Scavenge收集器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4.4、Serial Old收集器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS 收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。这两点都将在后面的内容中继续讲解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial Old收集器的工作过程如图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20713463751438435&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkulNd6x3IMnkHEbZBoJpblghWiaOX3nShRLU0hmiaalweiaCwmHKC2RprQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;869&quot;/&gt;&lt;figcaption&gt;image-20210213214008232&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4.5、Parallel Old收集器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。这个收集器是直到JDK 6时才开始提供的。Parallel Old收集器的工作过程如图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21509009009009009&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkSqlHr0B7MPLftF3KogFXooOn3FR3GZt3VcI9Tf6eic0lMBnE4FJDiblQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot;/&gt;&lt;figcaption&gt;image-20210213214130222&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4.6、CMS收集器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Concurrent Mark Sweep收集器运行过程如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2034090909090909&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgk4mcVU2w3sNiaYibFA3wTRtl6r6tI5K2DAZJJy7lXpMicINAlicoS6k7eQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;figcaption&gt;image-20210213214323197&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4.7、Garbage First收集器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1是一款主要面向服务端应用的垃圾收集器，是目前垃圾回收器的前沿成果。HotSpot开发团队最初赋予它的期望是（在比较长期的）未来可以替换掉JDK 5中发布的CMS收集器。现在这个期望目标已经实现过半了，JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1收集器运行过程如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2222222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkD7WRLalGInfJNJBAibS7tWAc691yj8Nj1k5wu1vHHIo2XbVU4rTZ2Og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;873&quot;/&gt;&lt;figcaption&gt;image-20210213214532807&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5、JVM类加载&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.1、类加载过程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过程如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33495145631067963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkyqmtloz8PPiamSficeVfOJqsN8EflqjGrh0w2hRzw1CQc8JO7I4FhNYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1030&quot;/&gt;&lt;figcaption&gt;image-20210214122059420&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**加载 **:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“加载”（Loading）阶段是整个“类加载”（Class Loading）过程中的一个阶段，在加载阶段，Java虚拟机需要完成以下三件事情：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1）通过一个类的全限定名来获取定义此类的二进制字节流。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2）将这个字节流所代表的静态存储结构转化为堆的运行时数据结构。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;验证&lt;/strong&gt;:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证阶段大致上会完成四个阶段的检验动作：&lt;code&gt;文件格式验证&lt;/code&gt;、&lt;code&gt;元数据验证&lt;/code&gt;、&lt;code&gt;字节码验证&lt;/code&gt;和&lt;code&gt;符号引用验证&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;准备&lt;/strong&gt;:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解析&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2、类加载器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2.1、类与类加载器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2.2、双亲委派模型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM 中内置了三个重要的 ClassLoader，启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分，其他所有&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;启动类加载器（Bootstrap Class Loader）&lt;/code&gt;: 这个类加载器负责加载存放在 &amp;lt;JAVA_HOME&amp;gt;\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;扩展类加载器（Extension Class Loader）&lt;/code&gt;：这个类加载器是在类sun.misc.Launcher$ExtClassLoader 中以Java代码的形式实现的。它负责加载&amp;lt;JAVA_HOME&amp;gt;\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;应用程序类加载器（Application Class Loader）&lt;/code&gt;：这个类加载器由 sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径 （ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;双亲委派模型&lt;/strong&gt;: 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0332326283987916&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkRaOVpqFJ3jhETict1T3wK4ZNSrtlFVicD024YiaGOV5jDaI5gwBrGAD7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;figcaption&gt;image-20210214124729757&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**为什么要使用双亲委派模型来组织类加载器之间的关系呢？**一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的 ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2.3、破坏双亲委派模型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第一次破坏：向前兼容&lt;/p&gt;&lt;p&gt;JDK1.2发布之前，兼容之前的代码。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第二次破坏：加载SPI接口实现类&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二次被破坏是这个模型自身的缺陷导致的。双亲委派模型很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API， 但没有绝对，如果基础类调用会用户的代码怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这不是没有可能的。一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时就放进去的rt.jar）,但它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI， Service Provider Interface）的代码，但启动类加载器不可能“认识“这些代码啊。因为这些类不在rt.jar中，但是启动类加载器又需要加载。怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置。如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过多的话，那这个类加载器默认即使应用程序类加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了线程上下文加载器，JNDI服务使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。但这无可奈何，Java中所有涉及SPI的加载动作基本胜都采用这种方式。例如JNDI，JDBC，JCE，JAXB，JBI等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第三次“被破坏”是由于用户对程序的动态性的追求导致的。为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。例如OSGi的出现。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们自己想定义一个类加载器，破坏双亲委派模型，&lt;strong&gt;只需要重写重写其中的loadClass方法，使其不进行双亲委派即可。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2.4、Tomcat类加载器架构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat是主流的Java Web服务器之一，为了实现一些特殊的功能需求，自定义了一些类加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat类加载器如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.6207906295754027&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkLyIwzkPmDTqQo5psRbeoBflagvS1m68COF2ewicibbM0V7JJhrd1N55w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;683&quot;/&gt;&lt;figcaption&gt;image-20210214131305597&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat实际上也是破坏了双亲委派模型的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomact是web容器，可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如多个应用都要依赖hollis.jar，但是A应用需要依赖1.0.0版本，但是B应用需要依赖1.0.1版本。这两个版本中都有一个类是com.hollis.Test.class。&lt;strong&gt;如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，&lt;strong&gt;Tomcat破坏双亲委派原则，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat的类加载机制：为了实现隔离性，优先加载 Web 应用自己定义的类，所以没有遵照双亲委派的约定，每一个应用自己的类加载器——WebAppClassLoader负责加载本身的目录下的class文件，加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6、JVM故障处理&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1、基础故障处理工具&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1.1、jps：虚拟机进程状况工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jps（JVM Process Status Tool），它的功能与 ps 命令类似，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;名称以及这些进程的本地虚拟机唯一 ID （ Local Virtual Machine Identifier,LVMID），类似于 ps -ef | grep java 的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;命令格式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jps [ options ] [ hostid ]&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; options：选项、参数，不同的参数可以输出需要的信息&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; hostid：远程查看&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;选项列表&lt;/th&gt;&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;-q&lt;/td&gt;&lt;td&gt;只输出进程 ID，忽略主类信息&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-l&lt;/td&gt;&lt;td&gt;输出主类全名，或者执行 JAR 包则输出路径&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-m&lt;/td&gt;&lt;td&gt;输出虚拟机进程启动时传递给主类 main()函数的参数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-v&lt;/td&gt;&lt;td&gt;输出虚拟机进程启动时的 JVM 参数&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1.2、jstat：虚拟机统计信息监视工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jstat（JVM Statistics Monitoring Tool），用于监视虚拟机各种运行状态信息。它可以查看本地或者远程虚拟机进程中，类加载、内存、垃圾收集、即时编译等运行时数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;命令格式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jstat -&lt;select&gt;&lt;option&gt;[-t] [-h]  [ []]&lt;/option&gt;&lt;/select&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[protocol:][//]lvmid[@hostname[:port]/servername]&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;interval 和 count，表示查询间隔和次数，比如每隔 1000 毫秒查询一次进程 ID 的gc 收集情况，每次查询 5 次。jstat -gc 111552 1000 5&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;选项列表&lt;/strong&gt;:&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;选项列表&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;-class&lt;/td&gt;&lt;td&gt;监视类加载、卸载数量、总空间以及类装载所耗费时长&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-gc&lt;/td&gt;&lt;td&gt;监视 Java 堆情况，包括 Eden 区、2 个 Survivor 区、老年代、永久代或者 jdk1.8 元空间等，容量、已用空间、垃圾收集时间合计等信息&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-gccapacity&lt;/td&gt;&lt;td&gt;监视内容与-gc 基本一致，但输出主要关注 Java 堆各个区域使用到的最大、最小空间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-gcutil&lt;/td&gt;&lt;td&gt;监视内容与-gc 基本相同，但输出主要关注已使用空间占总空间的百分比&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-gccause&lt;/td&gt;&lt;td&gt;与 -gcutil 功能一样，但是会额外输出导致上一次垃圾收集产生的原因&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-gcnew&lt;/td&gt;&lt;td&gt;监视新生代垃圾收集情况&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-gcnewcapacity&lt;/td&gt;&lt;td&gt;监视内容与 -gcnew 基本相同，输出主要关注使用到的最大、最小空间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-gcold&lt;/td&gt;&lt;td&gt;监视老年代垃圾收集情况&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-gcoldcapacity&lt;/td&gt;&lt;td&gt;监视内容与 -gcold 基本相同，输出主要关注使用到的最大、最小空间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-compiler&lt;/td&gt;&lt;td&gt;输出即时编译器编译过的方法、耗时等信息&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-printcompilation&lt;/td&gt;&lt;td&gt;输出已经被即时编译的方法&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1.3、jinfo：Java配置信息工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jinfo（Configuration Info for Java），实时查看和调整 JVM 的各项参数。在上面讲到 jps -v 指令时，可以看到它把虚拟机启动时显式的参数列表都打印&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出来了，但如果想更加清晰的看具体的一个参数或者想知道未被显式指定的参数时，就可以通过 jinfo -flag 来查询了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;命令格式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jinfo [ option ] pid&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1.4、jmap：Java内存映像工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jmap（Memory Map for Java），用于生成堆转储快照（heapdump 文件）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jmap 的作用除了获取堆转储快照，还可以查询 finalize 执行队列、Java 堆和&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法区的详细信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;命令格式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jmap [ option ] pid&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; option：选项参数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; pid：需要打印配置信息的进程 ID&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; executable：产生核心 dump 的 Java 可执行文件&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; core：需要打印配置信息的核心文件&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; server-id：可选的唯一 id，如果相同的远程主机上运行了多台调试服务器，用此选&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项参数标识服务器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; remote server IP or hostname：远程调试服务器的 IP 地址或主机名&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;选项&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;-dump&lt;/td&gt;&lt;td&gt;生成 Java 堆转储快照。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-finalizerinfo&lt;/td&gt;&lt;td&gt;显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象。Linux平台&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-heap&lt;/td&gt;&lt;td&gt;显示 Java 堆详细信息，比如：用了哪种回收器、参数配置、分代情况。Linux 平台&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-histo&lt;/td&gt;&lt;td&gt;显示堆中对象统计信息，包括类、实例数量、合计容量&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-permstat&lt;/td&gt;&lt;td&gt;显示永久代内存状态，jdk1.7，永久代&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-F&lt;/td&gt;&lt;td&gt;当虚拟机进程对 -dump 选项没有响应式，可以强制生成快照。Linux平台&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1.5、jhat：虚拟机堆转储快照分析工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jhat（JVM Heap Analysis Tool），与 jmap 配合使用，用于分析 jmap 生成的堆转储快照。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jhat 内置了一个小型的 http/web 服务器，可以把堆转储快照分析的结果，展示在浏览器中查看。不过用途不大，基本大家都会使用其他第三方工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;命令格式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jhat [-stack ] [-refs ] [-port ] [-baseline ] [-&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;debug ] [-version] [-h|-help]&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1.6、jstack：Java堆栈跟踪工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jstack（Stack Trace for Java），用于生成虚拟机当前时刻的线程快照（threaddump、javacore）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如：线程死锁、死循环、请求&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;外部资源耗时较长导致挂起等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程出现听顿时通过 jstack 来查看各个线程的调用堆栈，就可以获得没有响应的线程在搞什么鬼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;命令格式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jstack [ option ] vmid&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;选项参数&lt;/strong&gt;:&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;选项&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;-F&lt;/td&gt;&lt;td&gt;当正常输出的请求不被响应时，强制输出线程堆栈&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-l&lt;/td&gt;&lt;td&gt;除了堆栈外，显示关于锁的附加信息&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-m&lt;/td&gt;&lt;td&gt;如果调用的是本地方法的话，可以显示 c/c++的堆栈&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2、可视化故障处理工具&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK中除了附带大量的命令行工具外，还提供了几个功能集成度更高的可视化工具，用户可以使用这些可视化工具以更加便捷的方式进行进程故障诊断和调试工作。这类工具主要包括JConsole、 JHSDB、VisualVM和JMC四个。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2.1、JHSDB：基于服务性代理的调试工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK中提供了JCMD和JHSDB两个集成式的多功能工具箱，它们不仅整合了所有 基础工具所能提供的专项功能，而且由于有着“后发优势”，能够做得往往比之前的老工具们更好、更强大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JHSDB是一款基于服务性代理（Serviceability Agent，SA）实现的进程外调试工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用以下命令进入JHSDB的图形化模式，并使其附加进程11180：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jhsdb hsdb --pid &lt;span&gt;11180&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令打开的JHSDB的界面:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48139255702280914&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkse91niabdcsol0FIqkphtuYDeMAYkLI7cAP7XqLzJAGVsxunCallyLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;833&quot;/&gt;&lt;figcaption&gt;image-20210214140518407&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2.2、JConsole：Java监视与管理控制台&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JConsole（Java Monitoring and Management Console）是一款基于JMX（Java Manage-ment Extensions）的可视化监视、管理工具。它的主要功能是通过JMX的MBean（Managed Bean）对系统进 行信息收集和参数动态调整。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JConsole连接页面 :&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0920840064620356&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgk0GQvjVScITwjgMLQsgfiaowUb6YTk9ibgNiaQrPWpgYkAT9cjyiaD4zSfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;619&quot;/&gt;&lt;figcaption&gt;image-20210214140713141&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过JDK/bin目录下的jconsole.exe启动JCon-sole后，会自动搜索出本机运行的所有虚拟机进程&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8056537102473498&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgk9GdMjSdGXhINKKuHYOEuGKXLYK3kvsjyLx6ApfP5Z7sCr9lWVHSib6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;849&quot;/&gt;&lt;figcaption&gt;image-20210214140905009&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2.3、VisualVM：多合-故障处理工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VisualVM（All-in-One Java Troubleshooting Tool）是功能最强大的运行监视和故障处理程序之一， 曾经在很长一段时间内是Oracle官方主力发展的虚拟机故障处理工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它除了常规的运行监视、故障处理外，还可以做性能分析等工作。因为它的通用性很强，对应用程序影响较小，所以可以直接接入到生产环境中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VisualVM的插件可以手工进行安装，在网站上下载nbm包后，点击“工具-&amp;gt;插件-&amp;gt;已下载”菜单，然后在弹出对话框中指定nbm包路径便可完成安装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VisualVM插件页签:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6916666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkeImOLjgFGqiac1LNvBXMpU67vcP4QKRspv1glSjfzLjyTOlwG5hEB7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;840&quot;/&gt;&lt;figcaption&gt;image-20210214141116343&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2.4、Java Mission Control：可持续在线的监控工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMC最初是BEA公司的产品，因此并没有像VisualVM那样一开始就基于自家的Net-Beans平台来开发，而是选择了由IBM捐赠的Eclipse RCP作为基础框架，现在的JMC不仅可以下载到独立程序，更常见的是作为Eclipse的插件来使用。JMC与虚拟机之间同样采取JMX协议进行通信，JMC一方面作为 JMX控制台，显示来自虚拟机MBean提供的数据；另一方面作为JFR的分析工具，展示来自JFR的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMC的主界面如图:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcUIaicKQYhj4gJuFZtKicDgkPyuuticbeib4iaJDf7auZ5UWtrfc7f9MGC7MMwYQSxGzNq2nSXZHNFkrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;850&quot;/&gt;&lt;figcaption&gt;image-20210214141410375&lt;/figcaption&gt;&lt;/figure&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;本文是作者结合一些常见面试题学习周志朋老师《深入理解Java虚拟机：JVM高级特性与最佳实践》的整理。这本书是非常经典的JVM书籍，也是一部七百多页的大部头，强烈建议有空仔细研读这本书籍，来学习更多JVM的特性和细节。&lt;/p&gt;&lt;/blockquote&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【1】：周志朋编著 《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【2】：JavaGuide 搞定大厂jvm面试&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【3】：小傅哥编著 《Java面经手册》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【4】：Java内存管理-JVM内存模型以及JDK7和JDK8内存模型对比总结（三）          &lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4474b5ba5856437fb1e8e51225d621ea</guid>
<title>Java 中那些让你傻傻分不清楚的小细节</title>
<link>https://toutiao.io/k/mj4pi93</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;扩展右上角“&lt;/span&gt;&lt;span&gt;设为星标&lt;/span&gt;&lt;span&gt;”能第一时间看到好文章&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;大家好，我是苏三，又和大家见面了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;祝大家新年快乐，身体健康，财源滚滚，万事如意。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最近有篇文章在开源中国上火了，让我挺惊喜的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6736842105263158&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFwibxOMNAs3R0krMc6ewDo2G0OTtFNgXaz4yJQXMRIOmYwFsZAUWfBCkvKRBthiaFyvmhWPbblAm0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;570&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;我以前在上面发表文章，一般只有几个阅读量，稍微好点的有几十，如果被推荐也只有几百。像这种有3.2W阅读的情况，还是头一次遇到，真的活久见。非常感谢源码中国平台，让我的文章可以被更多的人看见。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近我们通过sonar静态代码检测，同时配合人工代码review，发现了项目中很多代码问题。除了常规的bug和安全漏洞之外，还有几处方法用法错误，引起了我极大的兴趣。我为什么会对这几个方法这么感兴趣呢？因为它们极具迷惑性，可能会让我们傻傻分不清楚。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. replace会替换所有字符？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候我们在使用字符串时，想把字符串比如：ATYSDFA*Y中的字符&lt;code&gt;A&lt;/code&gt;替换成字符&lt;code&gt;B&lt;/code&gt;，第一个想到的可能是使用&lt;code&gt;replace&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想把所有的&lt;code&gt;A&lt;/code&gt;都替换成&lt;code&gt;B&lt;/code&gt;，很显然可以用&lt;code&gt;replaceAll&lt;/code&gt;方法，因为非常直观，光从方法名就能猜出它的用途。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了：&lt;code&gt;replace&lt;/code&gt;方法会替换所有匹配字符吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jdk的官方给出了答案。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.21832358674463936&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFwibxOMNAs3R0krMc6ewDo2fmwTvm99Nzqmp65PdF9exFic3ibP4KA6ZFWa9zxOhozvyYdCg5pNjb3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1026&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法会替换每一个匹配的字符串。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然&lt;code&gt;replace&lt;/code&gt;和&lt;code&gt;replaceAll&lt;/code&gt;都能替换所有匹配字符，那么他们有啥区别呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;replace&lt;/code&gt;有两个重载的方法。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中一个方法的参数：char oldChar 和 char newChar，支持字符的替换。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;source.replace(&lt;span&gt;&#x27;A&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;B&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个方法的参数是：CharSequence target 和 CharSequence replacement，支持字符串的替换。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;source.replace(&lt;span&gt;&quot;A&quot;&lt;/span&gt;, &lt;span&gt;&quot;B&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;replaceAll&lt;/code&gt;方法的参数是：String regex 和 String replacement，基于正则表达式的替换。普通字符串替换：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;source.replaceAll(&lt;span&gt;&quot;A&quot;&lt;/span&gt;, &lt;span&gt;&quot;B&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正则表达替换（将*替换成C）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;source.replaceAll(&lt;span&gt;&quot;\\*&quot;&lt;/span&gt;, &lt;span&gt;&quot;C&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便说一下，将*替换成C使用&lt;code&gt;replace&lt;/code&gt;方法也可以实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;source.replace(&lt;span&gt;&quot;*&quot;&lt;/span&gt;, &lt;span&gt;&quot;C&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无需对特殊字符进行转义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，千万注意，切勿使用如下写法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;source.replace(&lt;span&gt;&quot;\\*&quot;&lt;/span&gt;, &lt;span&gt;&quot;C&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种写法会导致字符串无法替换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有个小问题，如果我只想替换第一个匹配的字符串该怎么办?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可以使用&lt;code&gt;replaceFirst&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;source.replaceFirst(&lt;span&gt;&quot;A&quot;&lt;/span&gt;, &lt;span&gt;&quot;B&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. Integer不能用==判断相等？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你在项目中有没有见过，有些同事对&lt;code&gt;Integer&lt;/code&gt;类型的两个参数使用&lt;code&gt;==&lt;/code&gt;比较是否相等？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反正我见过的，那么这种用法对吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的回答是看具体场景，不能说一定对，或不对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些状态字段，比如：&lt;code&gt;orderStatus&lt;/code&gt;有：-1(未下单)，0（已下单），1（已支付），2（已完成），3（取消），5种状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时如果用&lt;code&gt;==&lt;/code&gt;判断是否相等：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  Integer orderStatus1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  Integer orderStatus2 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  System.out.println(orderStatus1 == orderStatus2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果会是&lt;code&gt;true&lt;/code&gt;吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：是&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些同学可能会反驳，&lt;code&gt;Integer&lt;/code&gt;中不是有范围是：&lt;code&gt;-128&lt;/code&gt;-&lt;code&gt;127&lt;/code&gt;的缓存吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么是&lt;code&gt;false&lt;/code&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看Integer的构造方法：&lt;img data-ratio=&quot;0.2754237288135593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFwibxOMNAs3R0krMc6ewDo225CZeEF69U9qV3c4iaiaubfwDS2hQice074yKSQ20xhUSjWGTUXQnYt8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;472&quot;/&gt;它其实并没有用到缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么缓存是在哪里用的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案在&lt;code&gt;valueOf&lt;/code&gt;方法中：&lt;img data-ratio=&quot;0.226457399103139&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFwibxOMNAs3R0krMc6ewDo2V9WegxpfvA5QBE24MAgerkzicx7eribeGlwkibLnveeYbEleHwxdibz4FA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上面的判断改成这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String orderStatus1 = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;String orderStatus2 = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(Integer.valueOf(orderStatus1) == Integer.valueOf(orderStatus2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果会是&lt;code&gt;true&lt;/code&gt;吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：还真是&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要养成良好编码习惯，尽量少用&lt;code&gt;==&lt;/code&gt;判断两个&lt;code&gt;Integer&lt;/code&gt;类型数据是否相等，只有在上述非常特殊的场景下才相等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而应该改成使用&lt;code&gt;equals&lt;/code&gt;方法判断：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Integer orderStatus1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;Integer orderStatus2 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;System.out.println(orderStatus1.equals(orderStatus2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3. 使用BigDecimal就不丢失精度？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常我们会把一些小数类型的字段（比如：金额），定义成BigDecimal，而不是Double，避免丢失精度问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用Double时可能会有这种场景：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;double&lt;/span&gt; amount1 = &lt;span&gt;0.02&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;double&lt;/span&gt; amount2 = &lt;span&gt;0.03&lt;/span&gt;;&lt;br/&gt;System.out.println(amount2 - amount1);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下预计&lt;code&gt;amount2 - amount1&lt;/code&gt;应该等于&lt;code&gt;0.01&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是执行结果，却为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;0.009999999999999998&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际结果小于预计结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Double类型的两个参数相减会转换成二进制，因为Double有效位数为&lt;code&gt;16&lt;/code&gt;位这就会出现存储小数位数不够的情况，这种情况下就会出现误差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常识告诉我们使用BigDecimal能避免丢失精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是使用BigDecimal能避免丢失精度吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;BigDecimal amount1 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;0.02&lt;/span&gt;);&lt;br/&gt;BigDecimal amount2 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;0.03&lt;/span&gt;);&lt;br/&gt;System.out.println(amount2.subtract(amount1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中定义了两个BigDecimal类型参数，使用构造函数初始化数据，然后打印两个参数相减后的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;0.0099999999999999984734433411404097569175064563751220703125&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不科学呀，为啥还是丢失精度了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jdk中BigDecimal的构造方法上有这样一段描述：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2511013215859031&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFwibxOMNAs3R0krMc6ewDo26GykGjaEjdTU6Seia3JmxZNRRdJFxGPj0lvx1eJNg4tibiaK7ZTbxP6bQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致的意思是此构造函数的结果可能不可预测，可能会出现创建时为0.1，但实际是0.1000000000000000055511151231257827021181583404541015625的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，使用BigDecimal构造函数初始化对象，也会丢失精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何才能不丢失精度呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;BigDecimal amount1 = &lt;span&gt;new&lt;/span&gt; BigDecimal(Double.toString(&lt;span&gt;0.02&lt;/span&gt;));&lt;br/&gt;BigDecimal amount2 = &lt;span&gt;new&lt;/span&gt; BigDecimal(Double.toString(&lt;span&gt;0.03&lt;/span&gt;));&lt;br/&gt;System.out.println(amount2.subtract(amount1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;Double.toString&lt;/code&gt;方法对double类型的小数进行转换，这样能保证精度不丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，还有更好的办法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;BigDecimal amount1 = BigDecimal.valueOf(&lt;span&gt;0.02&lt;/span&gt;);&lt;br/&gt;BigDecimal amount2 = BigDecimal.valueOf(&lt;span&gt;0.03&lt;/span&gt;);&lt;br/&gt;System.out.println(amount2.subtract(amount1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;BigDecimal.valueOf&lt;/code&gt;方法初始化BigDecimal类型参数，也能保证精度不丢失。在新版的阿里巴巴开发手册中，也推荐使用这种方式创建BigDecimal参数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4. 字符串拼接不能用String？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String&lt;/code&gt;类型的字符串被称为不可变序列，也就是说该对象的数据被定义好后就不能修改了，如果要修改则需要创建新对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String a = &lt;span&gt;&quot;123&quot;&lt;/span&gt;;&lt;br/&gt;String b = &lt;span&gt;&quot;456&quot;&lt;/span&gt;;&lt;br/&gt;String c = a + b;&lt;br/&gt;System.out.println(c);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大量字符串拼接的场景中，如果对象被定义成&lt;code&gt;String&lt;/code&gt;类型，会产生很多无用的中间对象，浪费内存空间，效率低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，我们可以用更高效的可变字符序列：&lt;code&gt;StringBuilder&lt;/code&gt;和&lt;code&gt;StringBuffer&lt;/code&gt;，来定义对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，&lt;code&gt;StringBuilder&lt;/code&gt;和&lt;code&gt;StringBuffer&lt;/code&gt;有啥区别？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;StringBuffer对各主要方法加了&lt;code&gt;synchronized&lt;/code&gt;关键字，而StringBuilder没有。所以，StringBuffer是线程安全的，而StringBuilder不是。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，我们很少会出现需要在多线程下拼接字符串的场景，所以StringBuffer实际上用得非常少。一般情况下，拼接字符串时我们推荐使用&lt;code&gt;StringBuilder&lt;/code&gt;，通过它的&lt;code&gt;append&lt;/code&gt;方法追加字符串，它只会产生一个对象，而且没有加锁，效率较高。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String a = &lt;span&gt;&quot;123&quot;&lt;/span&gt;;&lt;br/&gt;String b = &lt;span&gt;&quot;456&quot;&lt;/span&gt;;&lt;br/&gt;StringBuilder c = &lt;span&gt;new&lt;/span&gt; StringBuilder();&lt;br/&gt;c.append(a).append(b);&lt;br/&gt;System.out.println(c);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，关键问题来了：&lt;strong&gt;字符串拼接时使用String类型的对象，效率一定比StringBuilder类型的对象低？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;javap -c StringTest&lt;/code&gt;命令反编译：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5989247311827957&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFwibxOMNAs3R0krMc6ewDo2ujRaojvnRQiaCzYzDq30Gq4uwWFU0MHhzAicibssqVuuvHOfmAEmYhPSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1860&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中能看出定义了两个String类型的参数，又定义了一个StringBuilder类的参数，然后两次使用append方法追加字符串。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果代码是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String a = &lt;span&gt;&quot;123&quot;&lt;/span&gt;;&lt;br/&gt;String b = &lt;span&gt;&quot;789&quot;&lt;/span&gt;;&lt;br/&gt;String c = a + b;&lt;br/&gt;System.out.println(c);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;javap -c StringTest&lt;/code&gt;命令反编译的结果会怎样呢？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5501618122977346&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFwibxOMNAs3R0krMc6ewDo2umtx7Y6OCic9gvY3dVfPVzNxEHSXD9SLdOJbNnofJtqxibPw6ZuZDc3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1854&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们会惊讶的发现，同样定义了两个String类型的参数，又定义了一个StringBuilder类的参数，然后两次使用append方法追加字符串。跟上面的结果是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其实从jdk5开始，java就对String类型的字符串的+操作做了优化，该操作编译成字节码文件后会被优化为StringBuilder的append操作。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5. isEmpty和isBlank的区别&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在对字符串进行操作的时候，需要经常判断该字符串是否为空。如果没有借助任何工具，我们一般是这样判断的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; != source &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(source)) {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;not empty&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果每次都这样判断，会有些麻烦，所以很多jar包都对字符串判空做了封装。目前市面上主流的工具有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;spring中的StringUtils&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jdbc中的StringUtils&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;apache common3中的StringUtils&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过&lt;code&gt;spring&lt;/code&gt;中的&lt;code&gt;StringUtils&lt;/code&gt;类只有&lt;code&gt;isEmpty&lt;/code&gt;方法，没有&lt;code&gt;isNotEmpty&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;jdbc&lt;/code&gt;中的&lt;code&gt;StringUtils&lt;/code&gt;类只有&lt;code&gt;isNullOrEmpty&lt;/code&gt;方法，也没有&lt;code&gt;isNotNullOrEmpty&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在这里强烈推荐一下&lt;code&gt;apache common3&lt;/code&gt;中的&lt;code&gt;StringUtils&lt;/code&gt;类，它里面包含了很多实用的判空方法：isEmpty、isBlank、isNotEmpty、isNotBlank等，还有其他字符串处理方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题来了，&lt;code&gt;isEmpty&lt;/code&gt;和&lt;code&gt;isBlank&lt;/code&gt;有啥区别？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;isEmpty&lt;/code&gt;方法判断：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; StringUtils.isEmpty(&lt;span&gt;null&lt;/span&gt;)      = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; StringUtils.isEmpty(&lt;span&gt;&quot;&quot;&lt;/span&gt;)        = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; StringUtils.isEmpty(&lt;span&gt;&quot; &quot;&lt;/span&gt;)       = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; StringUtils.isEmpty(&lt;span&gt;&quot;bob&quot;&lt;/span&gt;)     = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; StringUtils.isEmpty(&lt;span&gt;&quot;  bob  &quot;&lt;/span&gt;) = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;isBlank&lt;/code&gt;方法判断：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;StringUtils.isBlank(&lt;span&gt;null&lt;/span&gt;)      = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;StringUtils.isBlank(&lt;span&gt;&quot;&quot;&lt;/span&gt;)        = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;StringUtils.isBlank(&lt;span&gt;&quot; &quot;&lt;/span&gt;)       = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;StringUtils.isBlank(&lt;span&gt;&quot;bob&quot;&lt;/span&gt;)     = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;StringUtils.isBlank(&lt;span&gt;&quot;  bob  &quot;&lt;/span&gt;) = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个方法关键的区别在于这种&lt;code&gt;&quot; &quot;&lt;/code&gt;空字符串的情况，&lt;code&gt;isNotEmpty&lt;/code&gt;返回false，而&lt;code&gt;isBlank&lt;/code&gt;返回true。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6. mapper查询结果要判空？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有次代码review的时候，当时有个同事说这里的判空可以去掉，让我记忆犹新：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;List&amp;lt;User&amp;gt; list = userMapper.query(search);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(CollectionUtils.isNotEmpty(list)) {&lt;br/&gt;    List&amp;lt;Long&amp;gt; idList = list.stream().map(User::getId).collect(Collectors.toList());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为按常理，一般调用方法查询出来的集合，可能为&lt;code&gt;null&lt;/code&gt;，需要判空的。但是，这里比较特殊，我查了一下&lt;code&gt;mybatis&lt;/code&gt;的源码，这个判空的代码还真的可以去掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么回事呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;mybatis&lt;/code&gt;的查询方法最终都会调到DefaultResultSetHandler类的handleResultSets方法：&lt;img data-ratio=&quot;1.0215716486902928&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFwibxOMNAs3R0krMc6ewDo2Q5MRiaQHbf9ibPF1yR9ee02R1kn1n0fvEnc606svwibD3ibSLxTwsXgstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1298&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08595988538681948&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFwibxOMNAs3R0krMc6ewDo2nN3z8Piadyn2Kf7efQZQ15S0VqppWkLWcX9A3Kiab8aU1IwNX3YDx2SQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot;/&gt;该方法会返回一个&lt;code&gt;multipleResults&lt;/code&gt;List集合对象，在方法刚开始就&lt;code&gt;new&lt;/code&gt;出来了，肯定是不会为空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，如果你在项目的代码中看到有人直接使用查询出的结果，不判空也不要惊讶：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;List&amp;lt;User&amp;gt; list = userMapper.query(search);&lt;br/&gt;List&amp;lt;Long&amp;gt; idList = list.stream().map(User::getId).collect(Collectors.toList());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为&lt;code&gt;mapper&lt;/code&gt;底层已经处理过的，它不会出现空指针异常。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7. indexOf方法的正确用法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有次在review别人代码的时候，看到有个地方&lt;code&gt;indexOf&lt;/code&gt;使用了这种写法，让我印象比较深刻：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String source = &lt;span&gt;&quot;#ATYSDFA*Y&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(source.indexOf(&lt;span&gt;&quot;#&quot;&lt;/span&gt;) &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;do something&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你们说这段代码会打印出&lt;code&gt;do something&lt;/code&gt;吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jdk官方说了不存在的情况会返回-1&lt;img data-ratio=&quot;0.31194295900178254&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFwibxOMNAs3R0krMc6ewDo24Z0RTYN4zn9VqdDMHKZBgpUIWSOibFqUZV3F4LiaHn1GFQQTculR3svw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1122&quot;/&gt;&lt;code&gt;indexOf&lt;/code&gt;方法返回的是指定元素在字符串中的位置，从0开始。而上面的例子&lt;code&gt;#&lt;/code&gt;在字符串的第一个位置，所以调用&lt;code&gt;indexOf&lt;/code&gt;方法后的值其实是0。所以，条件是false，不会打印&lt;code&gt;do something&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想通过&lt;code&gt;indexOf&lt;/code&gt;判断某个元素是否存在时，要用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(source.indexOf(&lt;span&gt;&quot;#&quot;&lt;/span&gt;) &amp;gt; -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;do something&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，还有更优雅的&lt;code&gt;contains&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(source.contains(&lt;span&gt;&quot;#&quot;&lt;/span&gt;)) {&lt;br/&gt;   System.out.println(&lt;span&gt;&quot;do something&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d6141cdeb4adc12df5876207b53ec719</guid>
<title>敏捷团队实践</title>
<link>https://toutiao.io/k/6mfogkx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;main class=&quot;post-styles_main__2vaxQ&quot;&gt;&lt;p class=&quot;zh-cn&quot;&gt;业务实践介绍完了，现在该聊聊团队实践了。团队实践支配着团队成员之间的关系，以及团队成员与他们所创造的产品之间的关系。这些实践有助于小型团队表现得像真正的团队。他们帮助团队建立交流的语言，使团队成员对彼此、对正在构建的项目的期望保持一致。&lt;/p&gt;
&lt;h2 id=&quot;隐喻&quot;&gt;隐喻&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/050954.gif&quot; alt=&quot;ubiquitous_language&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;隐喻是一个看名字你根本不明白这是啥的实践，即使是看了它的概念，你也许还是会这么想：&lt;strong&gt;为了有效地进行沟通，团队需要一个受限制的、有几率的词汇表，其中包含项目中的术语和概念。&lt;strong&gt;这个实践的目的是&lt;/strong&gt;为了将项目与团队具备的共同知识关联到一起。&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这个隐晦的实践直到领域驱动设计的出现迎来了曙光。埃里克·埃文斯(Eric Evans) 在《领域驱动设计：软件核心复杂性应对之道》中创造了一个概念 - 统一语言(Ubiquitous Language)。这才是隐喻该有的名字。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;在某一个项目中团队需要对问题域进行建模，描述这个模型的词汇表需要得到所有人的认同，是的，包括利益相关者。这样做有一个好处，当大家在讨论问题时，不用做过多解释，大家都在同一个上下文里。举个例子：&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;在某项目中需要用一个词语来指代系统的客户，在项目前期并没有统一语言(或者说没有很好地实践隐喻)，大家对客户一词有无数个词语来指代 - person，client，customer...于是在讨论问题时，他在说person，我在说client。在代码里也是同样的情景，同样的实体，有无数个变量名，但其实他们都是同一样东西。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;统一语言过后，大家指定一个用词，摒弃其他所有词语，不论是在代码中还是在讨论的时候大家都能在同一个上下文里。&lt;/p&gt;
&lt;h2 id=&quot;可持续节奏&quot;&gt;可持续节奏&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/050935.jpg&quot; alt=&quot;work_overtime&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;跑得快的不一定赢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;加班&quot;&gt;加班&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;加班是程序员们绕不开的话题，我们需要达成一个共识 - 永远不加班是不现实的，低频率的偶尔加班是合理的，一直在加班是不可接受的。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;长期加班或者说是加班到深夜，会给我们带来什么？以我自己为例，我的脑子里一团浆糊，平时简单的问题我需要更多的时间来思考；我更容易做出错误的决策，第二天上班发现自己昨天写了一坨无法描述的代码；代码质量也得不到保证。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;加班只有两种原因&lt;/p&gt;

&lt;p class=&quot;zh-cn&quot;&gt;这两种问题可以通过很多方式解决，但长期加班绝不是唯一一种，在&lt;a href=&quot;https://teobler.com/posts/20210123-what-is-agile&quot;&gt;第一篇文章&lt;/a&gt;中，我们已经有了一些不错的解决方案，或许还有很多别的方案，你必须非常清醒地意识到加班的成本可能远远超过节省的时间。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;当然，在国内背景下，有一些项目需要迅速抢占市场以获得第一批用户，这些项目的同学需要无休止地加班，在这种问题上，每个人都有不同的选择。&lt;/p&gt;
&lt;h3 id=&quot;马拉松&quot;&gt;马拉松&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;不管是项目管理者还是程序员或者别的什么角色，都应该意识到软件项目是一场马拉松，而不是冲刺，更不是一系列的连续冲刺。你的奔跑必须能长时间坚持。你必须以“可持续节奏”来奔跑。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;一旦冲刺，你就必须减速或者休息(换句话说就是996都在划水)，这样一来，你的平均速度将慢于“可持续节奏”。马拉松的冲刺，应该只发生在快接近重点且你还有足够的能量。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;请你记住，加班工作并不能向雇主展现你的奉献精神。相反，如果你自己天天在加班，而同事没有加班，说明你的计划做的很糟糕，你答应了不该答应的截止日期，承诺了做不了的事情，你只是一个可被操纵的劳工而非专业人士。&lt;/p&gt;
&lt;h3 id=&quot;睡眠&quot;&gt;睡眠&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;不管怎样，请保持你充足的睡眠，这是人类最好的养生之道。每个人所需的睡眠时长不一样，尽快认识自己的身体，找到自己到底需要多久的睡眠。请不要让工作吞噬你的睡眠时间，否则你的生产力会直线下降。&lt;/p&gt;
&lt;h2 id=&quot;代码集体所有&quot;&gt;代码集体所有&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/051007.png&quot; alt=&quot;codebase&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;敏捷项目中没有人独占代码，代码归集体所有。任何团队成员都可以随时改善项目中的任意模块。团队集体拥有代码。这样做的好处是知识会分散在团队中。每个团队成员都能够更好地理解模块之间的界限，以及系统的整体工作方式。这极大地提高了团队沟通和决策的能力。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;代码集体所有并不意味着你不能有所专长。你需要做的是既要在自己擅长的领域工作，还要与其他领域的代码打交道。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;一些公司的规则与这完全相反。每个程序员拥有自己的代码，并且要对自己的代码负责。程序出现 bug，要通过代码追责；别人需要修改自己的代码，需要告知你，由你来修改；业绩和地位由代码来决定，关键业务代码的程序员地位高于其他程序员。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;整个代码库无法复用，模块封闭，壁垒坚固。&lt;/p&gt;
&lt;h2 id=&quot;持续集成&quot;&gt;持续集成&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/051018.jpg&quot; alt=&quot;CI_firmware&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;在早年的敏捷中，&lt;strong&gt;持续集成&lt;/strong&gt;意味着开发人员每隔一两个小时就签入一次源代码的修改，并将其合并入主干。所有单元测试和验收测试都应该是通过状态。不存在任何未集成的特性分支。部署时不应激活的所有变更都要通过开关(toggle)来处理。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这个时候所谓的集成其实都是&lt;strong&gt;开发人员自觉在本地实施&lt;/strong&gt;的，是否真的破坏了集成，需要开发人员自觉地修复或是等到 QA 来发现问题。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;2001年，ThoughtWorks 创造了 CruiseControl，第一个&lt;strong&gt;持续构建&lt;/strong&gt;工具。这个工具可以将签入时间缩短至几分钟。它能够监视源代码控制系统，一旦发生任何签入就会启动构建，自动运行系统的大部分测试，并将构建结果发给团队中的每一个人。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;后来出现了许多大家耳熟能详的构建工具 - Jenkins、Bamboo 等等。因为签入源代码的时间已经被缩短到几分钟，持续构建变成了持续签入，每一次签入都将触发一次构建。&lt;/p&gt;
&lt;h3 id=&quot;纪律&quot;&gt;纪律&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;持续构建应该&lt;strong&gt;永不失败&lt;/strong&gt;，每个程序员都要在提交代码前运行所有测试。如果构建失败了，那说明有奇怪的事情发生了，毕竟你在本地的构建时成功的。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;失败的构建是一次紧急事件，应该有物理措施立马通知所有人，所有人应该用最高优先级来处理这个事件，所有程序员应该停止手头的工作，合力将构建修复成功。&lt;strong&gt;构建必须永不失败。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;代价&quot;&gt;代价&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;如果对构建失败熟视无睹会发生什么？简单来说，这是在作死，所有人都会自动屏蔽构建服务器发来的失败通知。经受不住骚扰的人还可能删去失败的测试，&lt;strong&gt;觉得以后加上就好了&lt;/strong&gt;。往往这样的以后会变成永不。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;日复一日，构建看起来都是完美的，但是大家都忘了其实我们删除了一大堆测试，既然测试失败了，那么也就意味着我们的系统已经被破坏了。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;但是无所谓，构建时绿色的，它在告诉大家，系统现在可以被部署，于是，一个不堪重用的系统上线了。&lt;/p&gt;
&lt;h2 id=&quot;站会&quot;&gt;站会&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;img src=&quot;https://teobler-image.s3-us-west-1.amazonaws.com/051029.jpg&quot; alt=&quot;stand_up&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;站会的思路很简单，团队成员站成一个圈，回答3个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上次站会之后我做了什么？&lt;/li&gt;
&lt;li&gt;下次站会之前我要做什么？&lt;/li&gt;
&lt;li&gt;什么阻碍了我的工作？&lt;/li&gt;
&lt;/ol&gt;
&lt;p class=&quot;zh-cn&quot;&gt;在站会上不要讨论，不要深入解释，不要藏着掖着或者带情绪的表达，也不要发牢骚或聊八卦。每人30秒，会议结束，该干活的干活，该讨论的自己下去讨论。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;虽然思路简单，但是在实践的过程中大家依旧会产生很多困惑，这些回答或许可以解答你的困惑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该会议是可选的。许多团队不开这个会议也能过得很好。&lt;/li&gt;
&lt;li&gt;不一定每天都开。但需要选择合理的时间间隔。&lt;/li&gt;
&lt;li&gt;即使是大型团队，站会时间也只应该在10分钟以内。&lt;/li&gt;
&lt;li&gt;这个会议只遵循上述的简单议程，不要多加任何东西。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;猪和鸡的寓言&quot;&gt;猪和鸡的寓言&lt;/h3&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/The_Chicken_and_the_Pig&quot;&gt;猪和鸡的寓言&lt;/a&gt;讲的是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;一只猪和一只鸡走在路上。
鸡说：&quot;嘿，猪，我们开一家餐馆吧！&quot;
猪回答说：&quot;嗯，可以啊，我们叫什么名字呢？&quot;
鸡答道：&quot;叫火腿蛋怎么样？&quot;
猪想了一下，说：&quot;滚！你要我的肉，但你就下个蛋！&quot;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;问：在培根加鸡蛋的早餐中，鸡和猪有什么区别？
答案：鸡只是参与，但猪需要牺牲！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这个故事应用在站会里面的意思是：理论上来说，只有开发人员才能在站会上讲话，经理和其他人可以旁听，但不应该插话。但其实这不是一条铁律，只要议程还是那样的议程，如果需要，其他人也可以发言。&lt;/p&gt;
&lt;/main&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3bb449d00588363df1d482f47b1a2d0a</guid>
<title>[译] 为容器时代设计的高级 eBPF 内核特性 (FOSDEM, 2021)</title>
<link>https://toutiao.io/k/sqc33s5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post&quot;&gt;
  
  &lt;h1 class=&quot;postTitle&quot;&gt;[译] 为容器时代设计的高级 eBPF 内核特性（FOSDEM, 2021）&lt;/h1&gt;
  &lt;p class=&quot;meta&quot;&gt;Published at 2021-02-13 | Last Update 2021-02-13&lt;/p&gt;

  
  
  &lt;h3 id=&quot;译者序&quot;&gt;译者序&lt;/h3&gt;

&lt;p&gt;本文翻译自 2021 年 Daniel Borkmann 在 FOSDEM 的一篇分享：
&lt;a href=&quot;https://fosdem.org/2021/schedule/event/containers_ebpf_kernel/&quot;&gt;Advanced eBPF kernel features for the container age&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;内容是 2019 和 2020 两次 LPC 大会分享的延续，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/cilium-scale-k8s-service-with-bpf-zh/&quot;&gt;利用 eBPF 支撑大规模 K8s Service (LPC, 2019)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/cilium-k8s-service-lb-zh/&quot;&gt;基于 BPF/XDP 实现 K8s Service 负载均衡 (LPC, 2020)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;翻译已获得 Daniel 授权。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以下是译文。&lt;/p&gt;

&lt;hr/&gt;



&lt;hr/&gt;

&lt;p&gt;我来自 Isovalent（Cilium 背后的公司），是内核 &lt;strong&gt;eBPF 的维护者之一&lt;/strong&gt;（co-maintainer）。
今天给大家分享一些 Cilium（1.9）和 eBPF 的最新进展。&lt;/p&gt;

&lt;h1 id=&quot;1-纠正一些关于-ebpf-的错误理解&quot;&gt;1 纠正一些关于 eBPF 的错误理解&lt;/h1&gt;

&lt;p&gt;首先我想纠正一些关于 eBPF 的错误理解与不实描述。&lt;/p&gt;

&lt;h2 id=&quot;11-ebpf-是什么通用目的引擎最小指令集架构&quot;&gt;1.1 eBPF 是什么？通用目的引擎、最小指令集架构&lt;/h2&gt;

&lt;p&gt;之前我们讨论 eBPF 时大都集中在&lt;strong&gt;网络&lt;/strong&gt;（networking）和&lt;strong&gt;跟踪&lt;/strong&gt;（tracing）领域，
最近可能将范围扩大到了&lt;strong&gt;安全&lt;/strong&gt;（security）领域 —— 但我想说的是：eBPF 是一个
&lt;strong&gt;通用目的执行引擎&lt;/strong&gt;（general purpose execution engine）。&lt;/p&gt;

&lt;p&gt;换句话说，eBPF 是一个&lt;strong&gt;最小指令集架构&lt;/strong&gt;（a minimal instruction set
architecture），在设计时&lt;strong&gt;两个主要考虑&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;mark&gt;将 eBPF 指令映射到平台原生指令时开销尽可能小&lt;/mark&gt; —— 尤其是 x86-64 和
arm64 平台，因此我们针对这两种架构进行了很多优化，使程序运行地尽可能快。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;mark&gt;内核在加载 eBPF 代码时要能验证代码的安全性&lt;/mark&gt; —— 这也是为什么我们一
直将其限制为一个最小指令集，因为这样才能确保它是可验证的（进而是安全的）。&lt;/p&gt;

    &lt;p&gt;很多人像我一样，在过去很长时间都在开发&lt;strong&gt;内核模块&lt;/strong&gt;（kernel module）。
 但&lt;strong&gt;内核模块中引入 bug 是一件极度危险的事情 —— 它会导致内核 crash&lt;/strong&gt;。
 此时 &lt;strong&gt;BPF 的优势&lt;/strong&gt;就体现出来了：校验器（verifier）会检查是否有越界内存访问
 、无限循环等问题，一旦发现就会拒绝加载，而非将这些问题留到运行时（导致
 内核 crash 等破坏系统稳定性的行为）。&lt;/p&gt;

    &lt;p&gt;所以出于安全方面的原因，很多内核开发者开始用 eBPF 编写程序，而不再使用传统的内核模块方式。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;eBPF 提供的是基本功能模块（building blocks）和程序附着点（attachment points）。
我们可以编写 eBPF 程序来 attach 到这些 hook 点完成某些高级功能。&lt;/p&gt;

&lt;h2 id=&quot;12-ebpf-不是什么通用目的虚拟机全功能通用指令集&quot;&gt;1.2 eBPF 不是什么？通用目的虚拟机、全功能通用指令集&lt;/h2&gt;

&lt;p&gt;BPF 是一个&lt;strong&gt;通用目的虚拟机&lt;/strong&gt;（general purpose virtual machine）吗？
这是人们经常问的一个问题。不是 —— &lt;mark&gt;BPF 并不打算模拟完整的计算机&lt;/mark&gt;，它只是一个最小指令集和通用目的执行引擎。&lt;/p&gt;

&lt;p&gt;BPF 是一个&lt;strong&gt;全功能通用指令集&lt;/strong&gt;吗？也不是。它必须保持最小，这样才能保证可验证和安全。&lt;/p&gt;

&lt;h2 id=&quot;13-ebpf-与-c&quot;&gt;1.3 eBPF 与 C&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;BPF 在设计上&lt;mark&gt;有意采用了 C 调用约定&lt;/mark&gt;（calling convention）。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;由于内核是用 C 写的&lt;/strong&gt;，BPF 要与内核&lt;strong&gt;&lt;mark&gt;高效&lt;/mark&gt;&lt;/strong&gt;地交互，因此也采用了 C。
  当需要从 BPF 程序中调用所谓的 BPF helper 甚至是真正的内核函数时，这会非常方
  便；另外，用户态和内核态之间共享数据（BPF maps）必须越快越好。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;目前 ~150 BPF helpers，~30 BPF maps。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BPF C 与普通 C 差异有多大？&lt;/p&gt;

    &lt;p&gt;BPF 校验器可能最清楚地见证了近几年 BPF C 的发展历史。
  现在我们有了 BPF-to-BPF 函数调用、有限循环（bounded loops）、全局变量、静态
  链接（static linking）、&lt;mark&gt;BTF&lt;/mark&gt;（BPF Type Format，在 &lt;strong&gt;tracing 场景&lt;/strong&gt;尤其有用；其
  他方面也有用到，&lt;mark&gt;使内核成为可自描述的&lt;/mark&gt; self-descriptive）、
  &lt;mark&gt;单个 BPF 程序的最大指令数&lt;/mark&gt;（instructions/program）从原来的 4096
  条放大到了 &lt;mark&gt;100 万条&lt;/mark&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上可以看到，BPF 已经具备了很多的基础模块和功能。基于这项功能，我们能解决许多更
加有趣的生产问题。其中之一 —— 也是我接下来想讨论的 —— 就是 Cilium。
我们来看它是如何使用 eBPF 以及用来解决什么问题的。&lt;/p&gt;

&lt;h1 id=&quot;2-基于-ebpf-的云原生项目cilium-简介&quot;&gt;2 基于 eBPF 的云原生项目：Cilium 简介&lt;/h1&gt;

&lt;p&gt;Cilium 是一个基于 eBPF 技术的云原生网络、安全和可观测项目。下面简单列举一些特性。&lt;/p&gt;

&lt;h2 id=&quot;21-网络功能&quot;&gt;2.1 网络功能&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;通过 CNI 集成到 Kubernetes。&lt;/li&gt;
  &lt;li&gt;基于 BPF 实现了 Pod-to-Pod &lt;strong&gt;数据转发路径&lt;/strong&gt;（datapath）。&lt;/li&gt;
  &lt;li&gt;支持&lt;strong&gt;直接路由&lt;/strong&gt;（direct routing）、overlay、&lt;strong&gt;cloud-provider native&lt;/strong&gt;（例如 AWS）等网
络模式。&lt;/li&gt;
  &lt;li&gt;支持 IPv4、IPv6、NAT46。&lt;/li&gt;
  &lt;li&gt;支持&lt;strong&gt;多集群路由&lt;/strong&gt;（multi-cluster routing）。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;更多信息，可参考 [3,4,5,6]。译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;22-负载均衡&quot;&gt;2.2 负载均衡&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;实现了&lt;strong&gt;高度可扩展的 L3-L4（XDP）负载均衡&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;能完全替代 kube-proxy，提供 K8s Service 功能。&lt;/li&gt;
  &lt;li&gt;支持&lt;strong&gt;多集群&lt;/strong&gt;（multi-cluster）。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;详见 [1,2]，译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;23-网络安全&quot;&gt;2.3 网络安全&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;支持&lt;strong&gt;基于身份的（identity-based）L3-L7 网络安全&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;API-aware 安全（HTTP、gRPC 等）&lt;/li&gt;
  &lt;li&gt;DNS-aware&lt;/li&gt;
  &lt;li&gt;透明加密&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;24-可观测性&quot;&gt;2.4 可观测性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Metrics：通过 BPF 收集观测数据和 tracing 数据并导出；包含网络、DNS、安全、延迟、HTTP 等方面的数据。&lt;/li&gt;
  &lt;li&gt;提供 flow 级别的日志（flow log），并支持设置聚合粒度（datapath aggregation）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;25-servicemesh&quot;&gt;2.5 Servicemesh&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;注入 sidecar 时开销最小（minimized overhead）。&lt;/li&gt;
  &lt;li&gt;与 Istio 集成。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;用到了sockmap/redirection 做 socket 重定向，可参考 [7]，译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;26-小结&quot;&gt;2.6 小结&lt;/h2&gt;

&lt;p&gt;接下来介绍几个最近的新特性（我们在 Cilium 1.9 及内核方面的最新工作）。&lt;/p&gt;

&lt;h1 id=&quot;3-深入剖析一基于-bpfxdpmaglev-实现-k8s-service-负载均衡&quot;&gt;3 深入剖析（一）：基于 BPF/XDP/Maglev 实现 K8s Service 负载均衡&lt;/h1&gt;

&lt;p&gt;首先看基于 XDP/BPF 和 Maglev 算法实现的 K8s Service 负载均衡。&lt;/p&gt;

&lt;h2 id=&quot;31-原理&quot;&gt;3.1 原理&lt;/h2&gt;

&lt;p&gt;K8s Service 模型中，入口和后端实例位于同一组节点，即&lt;strong&gt;每个节点既用于部署容器，
又负责 Service 负载均衡的实现&lt;/strong&gt;（&lt;mark&gt;co-location of service
load balancer with regular user workloads on every node&lt;/mark&gt;）的。换句话说，每个
node 上都实现了 Service 负载均衡的功能。在原生 K8s 中，实现这个功能的组件是 kube-proxy。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Service 是对&lt;strong&gt;服务&lt;/strong&gt;的抽象，服务包含一个入口和多个后端实例，因此涉及到负载均衡
，即如何将请求分发到不同后端。但在模型及实现上，入口（负载均衡器）和后端实例
可以是分开部署的（例如负载均衡器部署在独立设备上），也可以部署在一起（负载均
衡器直接部署在运行实例的宿主机上）。
更多关于 kube-proxy 的设计及实现，可参考 [8]。&lt;/p&gt;

  &lt;p&gt;译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但 kube-proxy 的问题之一是性能很差。Cilium 所做的一项工作就是&lt;strong&gt;基于 BPF/XDP 实现了
kube-proxy 的功能&lt;/strong&gt;（针对南北向流量），显著减少了 CPU 使用量，并达到（某些场景甚至
超过了）DPDK 的性能。&lt;/p&gt;

&lt;p&gt;XDP 运行在网络驱动层，因此能&lt;strong&gt;直接在驱动层将收到的包再发出去&lt;/strong&gt;，
这是软件栈中&lt;mark&gt;最早能够处理数据包的位置&lt;/mark&gt;（此时 skb 都还没有创建），因此性能非常高。&lt;/p&gt;

&lt;h2 id=&quot;32-转发性能对比xdp-vs-dpdk&quot;&gt;3.2 转发性能对比（XDP vs DPDK）&lt;/h2&gt;

&lt;p&gt;以下测试结果基于 Cilium 1.9 及原生 Linux 内核中的 XDP 驱动。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/advanced-bpf-kernel-features-for-container-age/xdp-vs-dpdk.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里测试的是后端 pod 在另一台 node 的场景。三条线分别表示：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;DPDK (different NIC): DPDK 从一个网卡收包，然后将包从&lt;strong&gt;另一个网卡&lt;/strong&gt;发出去。&lt;/li&gt;
  &lt;li&gt;XDP (different NIC): Cilium/XDP 从一个网卡收包，然后将包从&lt;strong&gt;另一个网卡&lt;/strong&gt;发出去。&lt;/li&gt;
  &lt;li&gt;XDP (same NIC): Cilium/XDP 从一个网卡收包，然后直接将包从&lt;strong&gt;当前网卡&lt;/strong&gt;发出去。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以看出，XDP (different NIC) 的性能已经接近 DPDK；但 &lt;strong&gt;same NIC 组，四核
及以上的性能已经远超过 DPDK&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;再看 CPU 消耗：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/advanced-bpf-kernel-features-for-container-age/xdp-vs-dpdk-2.png&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;DPDK 是 busy-poll 模型，因此 CPU 一直是 100%，即需要独占一个或多个 CPU。&lt;/li&gt;
  &lt;li&gt;相比之下，XDP 的 CPU 消耗基本上是线性的，远小于 DPDK 的消耗。&lt;/li&gt;
  &lt;li&gt;&lt;mark&gt;图中还给出了 Linux kernel 收发包的 CPU 消耗作为 benchmark&lt;/mark&gt;。可以
看到在 5Mpps 时它就已经饱和了，转发性能无法进一步提高。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;32-source-ip-处理snatdsr&quot;&gt;3.2 Source IP 处理：SNAT/DSR&lt;/h2&gt;

&lt;p&gt;简要重温 Service LB 的 NAT/DSR 模式。&lt;/p&gt;

&lt;p&gt;假设 Service 请求到达了 node1，而这个 Service 的 backend pod 在 node2。&lt;/p&gt;

&lt;h3 id=&quot;snat&quot;&gt;SNAT&lt;/h3&gt;

&lt;p&gt;这种模式下，node1 &lt;strong&gt;对源 IP 地址（Source IP）的处理&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;请求：做源地址转换（SNAT）&lt;/li&gt;
  &lt;li&gt;响应：对源地址做反向转换（rev-SNAT）&lt;/li&gt;
&lt;/ul&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/advanced-bpf-kernel-features-for-container-age/nat.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;响应包需要先回到 node1，再回到客户端。来回路径是相同的。&lt;/p&gt;

&lt;h3 id=&quot;dsr&quot;&gt;DSR&lt;/h3&gt;

&lt;p&gt;这种模式下，node1 不需要做 SNAT：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/advanced-bpf-kernel-features-for-container-age/dsr.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;mark&gt;响应包也无需回到 node1，而是直接从 node2 回到客户端&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;详见 [2,10]，译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;33-destination-ip-处理--maglev-负载均衡&quot;&gt;3.3 Destination IP 处理 —— Maglev 负载均衡&lt;/h2&gt;

&lt;p&gt;上面小节讨论的是对源 IP 地址的处理，接下来看对目的 IP 地址的处理，即，如何选择后
端 pod。&lt;/p&gt;

&lt;p&gt;kube-proxy &lt;mark&gt;选择后端 pod 时都是随机的&lt;/mark&gt;（select a random backend）。
&lt;strong&gt;Cilium 1.9 之前也是这个行为&lt;/strong&gt;，并将这个状态存储到本节点的 BPF conntrack table。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;conntrack，连接跟踪，可参考 [9]，译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但这里存在一个问题是，如下图所示，&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/advanced-bpf-kernel-features-for-container-age/lb-2.png&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当负责处理某个 Service 的 node 挂掉时，这个连接&lt;mark&gt;接下来的包会被转发到另一个 node&lt;/mark&gt;
 （例如通过 ECMP）—— &lt;strong&gt;此时还没有问题&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;但&lt;mark&gt;新 node 没有之前的 service -&amp;gt; backend1 上下文信息&lt;/mark&gt;（因为这些信息
  只存在于 node1 的 conntrack table），因此&lt;mark&gt;会随机再选择一个 backend&lt;/mark&gt;，
  假设这里选择了 backend2，然后&lt;mark&gt;建立新的映射 service -&amp;gt; backdend2&lt;/mark&gt;，并将包转
  发过去 —— &lt;strong&gt;这里也没问题，能发送过去&lt;/strong&gt;，但接下来 ——&lt;/li&gt;
  &lt;li&gt;&lt;mark&gt;包到达 backend2 时会被拒绝&lt;/mark&gt;，因为 backend2 上并不存在这条连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结起来就是：&lt;mark&gt;一旦 node 挂掉，所有经过这台 node 的 Service 连接会全部中断&lt;/mark&gt;。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我们在 1.9 中引入了一致性哈希：在 Cilium 中实现了 &lt;strong&gt;Google
Maglev 一致性哈希算法&lt;/strong&gt;，用于 BPF/XDP Service 负载均衡。简单来说，
&lt;mark&gt;对于同一条 Service 连接，该算法能保证哈希到相同的后端&lt;/mark&gt;。因此一台 node 挂掉后
，只要接下来的包能到达其他 node，该 node 就能保证将包转发到原
来的 backend pod，因此&lt;strong&gt;连接不会中断&lt;/strong&gt;，如下图所示：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/advanced-bpf-kernel-features-for-container-age/lb-3.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在实现上，&lt;/p&gt;



&lt;h2 id=&quot;34-内核-ebpf-改动&quot;&gt;3.4 内核 eBPF 改动&lt;/h2&gt;

&lt;p&gt;为实现以上功能，我们&lt;mark&gt;对内核 eBPF 的 map-in-map 做了增强，允许内层 map 的大小是动态的&lt;/mark&gt;，
见 &lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4a8f87e60f6d&quot;&gt;bpf: Allow for map-in-map with dynamic inner array map entries&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果没有这个扩展，那内层 map 只能是固定大小，而很多 Service 可能只有少量后端，
导致 map 的大部分空间都是用不到的，非常浪费内存。&lt;/p&gt;

&lt;h1 id=&quot;4-深入剖析二基于-bpf-的低延迟转发路径fast-path&quot;&gt;4 深入剖析（二）：基于 BPF 的低延迟转发路径（fast-path）&lt;/h1&gt;

&lt;p&gt;这里主要是介绍绕过宿主机内核协议栈，直接将包从网卡或容器 redirect 到另一个端（容器或网卡）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这些内容在去年的分享中有更详细介绍，见
&lt;a href=&quot;/blog/cilium-k8s-service-lb-zh/&quot;&gt;基于 BPF/XDP 实现 K8s Service 负载均衡 (LPC, 2020)&lt;/a&gt;。
译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;41-进出宿主机的容器流量host---pod&quot;&gt;4.1 进出宿主机的容器流量（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;host &amp;lt;-&amp;gt; pod&lt;/code&gt;）&lt;/h2&gt;

&lt;p&gt;原来需要穿越宿主机的内核协议栈：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/advanced-bpf-kernel-features-for-container-age/fast-path-1.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在绕过了宿主机内核协议栈，直接将包从网卡重定向到容器网络设备：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/advanced-bpf-kernel-features-for-container-age/fast-path-2.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;42-同宿主机的容器流量pod---pod&quot;&gt;4.2 同宿主机的容器流量（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod &amp;lt;-&amp;gt; pod&lt;/code&gt;）&lt;/h2&gt;

&lt;p&gt;与前面类似，绕过宿主机内核协议栈，直接重定向：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/advanced-bpf-kernel-features-for-container-age/fast-path-3.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;43-内核-ebpf-改动&quot;&gt;4.3 内核 eBPF 改动&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/torvalds/c/9aa1206e8f48&quot;&gt;bpf: Add redirect_peer helper&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://git.kernel.org/torvalds/c/b4ab31414970&quot;&gt;bpf: Add redirect_neigh helper as redirect drop-in&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;44-性能对比&quot;&gt;4.4 性能对比&lt;/h2&gt;

&lt;p&gt;用 netperf 做了一些性能测试。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/advanced-bpf-kernel-features-for-container-age/fast-path-performance-1.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;TCP_SENDFILE 性能，三组测试：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;node-to-node 转发性能：作为 benchmark 参考。&lt;/li&gt;
  &lt;li&gt;pod-to-remote-pod，没有使用 fast-path：传统的经过宿主机内核协议栈方式。&lt;/li&gt;
  &lt;li&gt;pod-to-remote-pod，使用 fast-path：可以看到&lt;strong&gt;&lt;mark&gt;几乎达到了 node-to-node 性能 —— 理论上的最高性能&lt;/mark&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TCP_RR 测试（ping-pong）也是类似的结果：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/advanced-bpf-kernel-features-for-container-age/fast-path-performance-2.png&quot;/&gt;&lt;/p&gt;

&lt;h1 id=&quot;5-深入剖析三基于-bpf-实现-pod-限速rate-limiting&quot;&gt;5 深入剖析（三）：基于 BPF 实现 pod 限速（rate-limiting）&lt;/h1&gt;

&lt;p&gt;这个功能也是在最新的 Cilium 1.9 中实现的。&lt;/p&gt;

&lt;h2 id=&quot;51-传统方式&quot;&gt;5.1 传统方式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;传统的 pod 限速方式&lt;/strong&gt;：加一个 CNI 插件，&lt;mark&gt;通过 CNI chaining 给容器设置 TBF qdisc&lt;/mark&gt;。
甚至还会为了 ingress shaping 设置所谓的 ifb（Intermediate Functional Block）设备。可扩展性差。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TBF、HTB、MQ、FQ 等 tc qdisc 信息，可参考 [11]。译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种方式存在很多问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;效率不高，因为通常情况下这都会涉及到多队列设备（multi-queue devices），需要竞
争 qdisc 锁，不是一种无锁方式。&lt;/li&gt;
  &lt;li&gt;通过 ifb 设备来做整形（shaping）也不是合适，因为它占用了很多的资源来做 ingress
整形，效果却不怎么样。整形都应该是在出向做的。&lt;/li&gt;
  &lt;li&gt;整体上这种方式并不是可扩展的。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;52-cilium-方式bpf-edt&quot;&gt;5.2 Cilium 方式：BPF EDT&lt;/h2&gt;

&lt;p&gt;在 Cilium 中，我们基于 multi-queue 和 BPF，实现了一种称为 &lt;mark&gt;Earlist Departhure Time&lt;/mark&gt;（EDT，最早离开时间）
的&lt;mark&gt;无锁（lockless）方式来对 pod 进行限速&lt;/mark&gt;。&lt;/p&gt;

&lt;p&gt;工作原理如下图所示：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/advanced-bpf-kernel-features-for-container-age/rate-limit.png&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在 K8s 里&lt;strong&gt;为 pod 设置限速带宽&lt;/strong&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubernetes.io/egress-bandwidth: &quot;50M&quot;&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;Cilium agent 生成 BPF 程序。&lt;/li&gt;
  &lt;li&gt;&lt;mark&gt;BPF 对流量进行分类&lt;/mark&gt;，根据用户定义的限速带宽，&lt;mark&gt;为每个包设置一个离开时间&lt;/mark&gt;（
departure time），其实就是一个时间戳 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;tstamp&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;在物理设备上设置 FQ qdisc，&lt;strong&gt;&lt;mark&gt;FQ qdisc 会根据这个时间戳对包进行调度&lt;/mark&gt;&lt;/strong&gt;。保证不会早于这个时间戳将包发送出去。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;53-性能对比&quot;&gt;5.3 性能对比&lt;/h2&gt;

&lt;p&gt;下面是基于一些生产流量所做的测试，&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/advanced-bpf-kernel-features-for-container-age/rate-limit-performance.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;左边是传统方式 HTB，右边是 Cilium 方式 BPF+FQ，Y 轴是取了对数（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;log&lt;/code&gt;）的。总结：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;mark&gt;p99：延迟降低了 10x&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;&lt;mark&gt;p95：延迟降低了 20x&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;6-总结&quot;&gt;6 总结&lt;/h1&gt;

&lt;p&gt;与其他内核子系统不同，BPF 在内核中的位置非常特殊，因此能极其高效地解决一些复杂的生产问题。
而&lt;strong&gt;其他任何内核子系统，都无法只依靠自身解决这些问题&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这次分享的主要是网络方面，但其实 BPF 也已经在跟踪、安全等领域大展拳脚，而且
还有更多更多的可能性正在被发掘。此外，我仍然觉得 &lt;mark&gt;BPF 才刚刚开始&lt;/mark&gt;（
feels it’s at the very beginning）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cilium 以 BPF 为核心，将这项技术带入了主流的 Kubernetes 社区&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;推荐阅读：&lt;a href=&quot;/blog/ebpf-and-k8s-zh/&quot;&gt;大规模微服务利器：eBPF + Kubernetes（KubeCon, 2020）&lt;/a&gt;。译注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外一件可喜的事情是，GKE（Google Kubernets Engine）已经宣布将 Cilium 作为其下一
代 dataplane。因此，如果是在 GKE 上创建 K8s 集群，那你已经能原生地使用了 Cilium 了。&lt;/p&gt;

&lt;p&gt;最后，几个链接：&lt;/p&gt;



&lt;h1 id=&quot;译文参考链接扩展阅读&quot;&gt;译文参考链接（扩展阅读）&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/cilium-scale-k8s-service-with-bpf-zh/&quot;&gt;（译）利用 eBPF 支撑大规模 K8s Service (LPC, 2019)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/cilium-k8s-service-lb-zh/&quot;&gt;（译）基于 BPF/XDP 实现 K8s Service 负载均衡 (LPC, 2020)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/cilium-life-of-a-packet-pod-to-service-zh/&quot;&gt;Life of a Packet in Cilium：实地探索 Pod-to-Service 转发路径及 BPF 处理逻辑&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/trip-stepping-into-cloud-native-networking-era-zh/&quot;&gt;迈入 Cilium+BGP 的云原生网络时代&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/cilium-network-topology-on-aws/&quot;&gt;Cilium Network Topology and Traffic Path on AWS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/cilium-clustermesh/&quot;&gt;Cilium ClusterMesh: A Hands-on Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/socket-acceleration-with-ebpf-zh/&quot;&gt;（译）利用 ebpf sockmap/redirection 提升 socket 性能（2020）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/cracking-k8s-node-proxy/&quot;&gt;Cracking kubernetes node proxy (aka kube-proxy)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/conntrack-design-and-implementation-zh/&quot;&gt;连接跟踪（conntrack）：原理、应用及 Linux 内核实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/k8s-l4lb/&quot;&gt;L4LB for Kubernetes: Theory and Practice with Cilium+BGP+ECMP&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/lartc-qdisc-zh/&quot;&gt;（译）《Linux 高级路由与流量控制手册（2012）》第九章：用 tc qdisc 管理 Linux 网络带宽&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/ebpf-and-k8s-zh/&quot;&gt;（译）大规模微服务利器：eBPF + Kubernetes（KubeCon, 2020）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;


  
  
&lt;/div&gt;


          

      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>