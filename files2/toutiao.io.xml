<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3b0aaf3c6e35f2ed71a2d58dc78050d4</guid>
<title>架构设计：分布式结构下，服务部署发布</title>
<link>https://toutiao.io/k/34mzduc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、服务发布简介&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;分布式系统架构下，服务发布是一件很麻烦的事情，特别是在构建自动发布流程和灰度测试的策略两个核心方面。通常情况下如果不涉及数据层面的灰度流程，服务可以灰度上线，或者滚动上线，这两种方式很常用；如果涉及到数据灰度，则可能需要中间服务做不同版本数据之间追平，或者停机维护一次性处理好数据和上线问题，不过后面这种方式风险较大。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、蓝绿部署&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6417322834645669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvC1ibhQIbG6gSxTwUDxjWxam2INdajE1Ps9qico6V5dTr4ykZYOA8VjN8BHafCHvlkY8cKiarQLLQ5hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;/p&gt;&lt;p&gt;新版本上线的时候，并不停掉老版本，新旧两个版本同时运行，通常还会在负载均衡的策略上倾向于旧版本服务处理请求，这样新版本就有一个执行的观察期过渡期，等到新版本平稳运行一段时间后，再把请求都发到新版服务上，旧版本服务完成下线。这种方式在分布式架构下很少使用，对服务器要求过高。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、滚动发布&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6429980276134122&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvC1ibhQIbG6gSxTwUDxjWxamlPJicTqjK8OlstcWhP2ww5WOGCRZCsj5dtBN28ppgChhqn3qaBuwRmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/p&gt;&lt;p&gt;滚动发布可以避免蓝绿部署的服务器资源占用问，首先发布一台新版本服务，然后停掉一台老版本服务，新版服务经过观察之后，再逐步替换掉所有老版本的服务，这样服务的环境变动比较频繁，相对不稳定。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、灰度发布&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;上述两种方式在普通业务场景下都还算好操作，分布式系统下的灰度发布复杂程序相对高很多，基础流程如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4632768361581921&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvC1ibhQIbG6gSxTwUDxjWxamJMqMPIeN4ZkZoGwQEAZjWg2GRVHfOFdNvzaz5IyTOBicNKdHSLIFXJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1062&quot;/&gt;&lt;/p&gt;&lt;p&gt;新版本上线，可能涉及分布式下多个灰度服务，因此在服务在整个链路上分发时，都要判断下个请求是路由到正常服务还是灰度服务，还要对灰度服务做请求的权重控制，不能让灰度服务处理大量的请求。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;实际策略&lt;/strong&gt;：在实际的分布式系统灰度发布流程，通常会采用如下一个策略：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配置一个灰度是否开启的标识；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配置一批灰度账户，通常内部人员；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配置灰度服务版本标识；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;请求在链路执行时，判断灰度是否开启；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;判断当前用户身份是否是灰度测试账号；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;获取当前可以请求的服务列表；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据灰度服务版本选择请求的具体服务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这个流程非常的复杂，需要很多自定义的策略，还要熟悉分布式框架的底层API原理，要二次重写来适配灰度策略，设计重写原生API还容易触发一些惊喜问题。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、数据库灰度&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;如果说最难处理的灰度模式是什么，就是数据库的版本灰度问题，通常业务对数据库改造升级，实际都是通过停机维护来处理的，可能很多开发都经历过，发布停服公告，然后在指定时间内把数据全部追平或者二次搬运，再重新提供服务。但是总有些业务场景是不能停机维护的，处理灰度数据的基本策略如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5643153526970954&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvC1ibhQIbG6gSxTwUDxjWxamI2TmuGBWFORvekeLjP9LsXXb7W6DicEGB9L8VUwUZvVNlUuVYUP2aHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/p&gt;&lt;p&gt;该模式中，除了正常的灰度流程之外，需要在灰度数据库和正常数据中间提供一个数据调配服务，用来解决如下问题：灰度数据库缺失数据，需要临时从正常库拉取，灰度版本失败，新数据需要重新整合写入原本正常库；灰度版本成功，旧版数据迁移等；最终保证数据的平稳升级。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;六、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/data-manage-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/data-manage-parent&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bcee2c0d746045b84e4d93d9fa128e90</guid>
<title>Spring Boot 2.4.0 正式发布，全新的配置文件加载机制（不向下兼容）</title>
<link>https://toutiao.io/k/wqze2aq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/crPesQVeyKJwK0sja2OPadOzZvoWXfCS4axGZhVoCbwevXqNdJWv1Y8510uC2t2MeH09tMEWVtkhvzoqUKcRoQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍前言&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是YourBatman。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;北京时间2020-11-12，&lt;code&gt;Spring Boot 2.4.0&lt;/code&gt;正式发布。2.4.0是第一个使用&lt;strong&gt;「新版本方案」&lt;/strong&gt;的Spring Boot发行版本。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;注意：2.4.0版本号没有&lt;code&gt;.RELEASE&lt;/code&gt;后缀，没有&lt;code&gt;.RELEASE&lt;/code&gt;后缀，没有&lt;code&gt;.RELEASE&lt;/code&gt;后缀。使用的是Spring最新的版本发布规则。此规则详解请参考上篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247490521&amp;amp;idx=1&amp;amp;sn=7eaa0ace090023715926cd02e0bfc188&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Spring改变版本号命名规则：此举对非英语国家很友好&lt;/a&gt;&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得&lt;code&gt;Spring Boot 2.3.0.RELEASE&lt;/code&gt;版本发布时那会麽？前后相差将好半年：&lt;img data-ratio=&quot;0.7130434782608696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKJwK0sja2OPadOzZvoWXfCSichm2uG4NtxGm34ic7qxK8stG8kY1mf4DG2wDYeDXK2DR5KtiaAclFGQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;460&quot;/&gt;直达电梯：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247484792&amp;amp;idx=1&amp;amp;sn=8447ecf530a46fa643346d9abfeab545&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Spring Boot 2.3.0正式发布：优雅停机、配置文件位置通配符新特性一览&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，次版本号的升级会有点料，根据之前的爆料此次升级据说是做了大量的更新和改进。那么老规矩，作为小白鼠的我先代你玩一玩，初体验吧。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;也可参见官方的更新日志：Spring Boot 2.4.0 Release Notes&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍正文&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了刚发布的Spring Boot 2.4.0，Spring Boot 2.3.x/2.2.x仍旧是&lt;strong&gt;「活跃的」&lt;/strong&gt;维护的版本。Spring Boot遵循的是&lt;code&gt;Pivotal OSS&lt;/code&gt;支持策略，从发布日期起支持主要版本&lt;strong&gt;「3年」&lt;/strong&gt;（注意：是主要版本）。下面是详情：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;2.3.x&lt;/code&gt;：&lt;strong&gt;「支持的版本」&lt;/strong&gt;。2020.05发布，是现在的活跃的主干&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;2.2.x&lt;/code&gt;：&lt;strong&gt;「支持的版本」&lt;/strong&gt;。2019.10发布，是现在的活跃的主干&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;2.1.x&lt;/code&gt;：2018.10发布，支持到2020.10月底，&lt;strong&gt;「建议尽快升级」&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「EOL分支」&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;2.0.x&lt;/code&gt;：2018.3发布，2019.4.3停止维护&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;1.5.x&lt;/code&gt;：生命已终止的版本。2017.1发布，是最后一个1.x分支，2019.8.1停止维护&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41911764705882354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKJwK0sja2OPadOzZvoWXfCS0x6kVYPWHEF06Oqw8ib6cSyic9ibHCGUE9m2zcHUq8hFaKWn3smk6Aujg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;952&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回忆2.3版本的新特性&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能大部分小伙伴都还没用过2.3.x分支，没想到2.4.x就已发布。因此这里先对2.3.x版本的新特性，来波简单回忆：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优雅停机。这是&lt;strong&gt;「2.3.x主打的新特性」&lt;/strong&gt;：在关闭时，web服务器将不再允许新的请求，并将等待完成的请求给个宽限期让它完成。这个宽限期是可以设置的：可以使用&lt;code&gt;spring.lifecycle.timeout-per-shutdown-phase=xxx&lt;/code&gt;来配置，默认值是30s。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置文件位置支持通配符。简单的说，如果你有MySql的配置和Redis配置的话，你就可以把他们分开来放置，这个新特性也是棒棒哒。隔离性更好目录也更加清晰了（注意：此格式只支持放在classpath外部）：&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mysql：&lt;code&gt;/config/mysql/application.properties&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;redis：&lt;code&gt;/config/redis/application.properties&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;核心依赖升级。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一般来说建议你手动引入，毕竟Bean Validation的使用还是很广泛，并且真的非常非常好用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;说明：小版本号的升级对于新特性来说一般选择性忽略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Data Neumann。备注：很明显这个还是旧的命名方式。在Spirng新的版本规则下，Spring Data最新版本为Spring Data 2020.0.0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Session Dragonfruit（很明显这个也还是旧的命名方式）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Security 5.3&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「Spring Framework」&lt;/strong&gt; 没有升级，使用的依旧是和Spring Boot 2.2相同的&lt;code&gt;5.2.x&lt;/code&gt;版本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于&lt;strong&gt;「Bean Validation」&lt;/strong&gt;：从此版本开始，&lt;code&gt;spring-boot-starter-web&lt;/code&gt;不会再把validation带进来，所以若使用到，你需要自己添加这个&lt;code&gt;spring-boot-starter-validation&lt;/code&gt;依赖&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做足功课后，就开始最新的Spring Boot 2.4.0之旅吧。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4.0主要新特性&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;全新的配置文件处理(properties/yaml)&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个改变&lt;strong&gt;「最为重磅」&lt;/strong&gt;，本次改变了配置文件的加载逻辑，旨在&lt;strong&gt;「简化」&lt;/strong&gt;和&lt;strong&gt;「合理化」&lt;/strong&gt;外部配置的加载方式，它可能具有不向下兼容性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Boot 2.4改变了处理&lt;code&gt;application.properties&lt;/code&gt;和&lt;code&gt;application.yml&lt;/code&gt;文件的方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若你只是简单的文件application.properties/yaml，那么升级对你是&lt;strong&gt;「无缝」&lt;/strong&gt;的，你感受不到任何变化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若你使用了比较复杂的文件，如&lt;code&gt;application-profile.properties/yaml&lt;/code&gt;这种（或者使用了Spirng Cloud的配置中心、（带有分隔符----的）多yaml文件），那么默认是不向下兼容的，需要你显式的做出些更改&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为配置文件隶属于程序的一部分，特别是我们现在几乎都会使用到配置中心。因此下面针对于老版本升级到Spring Boot 2.4.0做个简单的迁移指导。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：因配置文件加载逻辑完全进行了重写，因此详细版本我放到了下文专文讲解，有兴趣可保持关注&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;老版本版本配置属性迁移指南&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老版本：2.4.0之前的版本都叫老版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Boot 2.4对&lt;code&gt;application.poperties/yaml&lt;/code&gt;的处理做了更新/升级。旨在简化和合理化外部配置的加载方式。它还提供了新功能：&lt;code&gt;spring.config.import&lt;/code&gt;支持。所以呢，对于Spring Boot 2.4.0之前的版本（老版本）若升级到2.4.0需要做些修改，指导建议如下：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方式一：恢复旧模式（不推荐）&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你还未准备好做配置迁移的修改，Spring Boot也帮你考虑到了，提供了&lt;strong&gt;「一键切换」&lt;/strong&gt;到旧模式的“按钮”。具体做法是：只需要在&lt;code&gt;Environment&lt;/code&gt;里增加一个属性&lt;code&gt;spring.config.use-legacy-processing = true&lt;/code&gt;就搞定。最简的方式就是把这个属性放在application.poperties/yaml里即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;spring.config.use-legacy-processing = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;增加此配置后，Spring Boot对配置文件的解析恢复到原来模式：仍旧使用&lt;code&gt;ConfigFileApplicationListener&lt;/code&gt;去解析。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;&lt;code&gt;ConfigFileApplicationListener&lt;/code&gt;属于Spring Boot非常核心的底层代码，这次做了不向下兼容的改进，可见它对进击云原生的决心&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是：此API在2.4.0已被标记为过期：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// @since 1.0.0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// @deprecated since 2.4.0 in favor of {@link ConfigDataEnvironmentPostProcessor}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Deprecated&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConfigFileApplicationListener&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;EnvironmentPostProcessor&lt;/span&gt;, &lt;span&gt;SmartApplicationListener&lt;/span&gt;, &lt;span&gt;Ordered&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照Spring Boot的版本策略，此类将在Spring Boot 2.6.0版本被移除。因此：若不是迫不得已（时间紧急），并不建议你用兼容手法这么去做，因为这将成为技术债，迟早要还的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：很多RD其实只会看到当前的方便，获得利益（比如快速上线获奖），坑交给后人。我个人认为作为程序员应该有一定自我修养，自我追求，不为一时的爽而持续给团队积累债务，毕竟积重难返。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方式二：按新规则迁移（推荐）&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若你对配置文件的使用有如下情行，那么你需要做迁移：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;多文档的yaml文件（带有----分隔符的文件）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在Jar外使用配置文件，或者使用形如application-{xxx}.properties/yaml这种配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若在多文档yaml中使用到了&lt;code&gt;spring.profiles&lt;/code&gt;配置项&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Boot 2.4.0升级对配置文件的改动是最大的，并且还&lt;strong&gt;「不具备向下兼容性」&lt;/strong&gt;，简单的说就是从此版本开始要把Spring Boot的配置文件加载机制重学一遍（比如还增加了&lt;code&gt;spring.config.import&lt;/code&gt;，增加了对kubernetes配置的支持等等），并且还要学会如何迁移。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「为了更好的描述好这个非常非常重要的知识点，下篇文章我会用专文来全面介绍 Spring Boot这套全新的配置文件加载机制，并且辅以原理，以及和过去方式的比较，帮助你更全面、更快速、更劳的掌握它，欢迎持续关注。」&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：Spring Boot的配置文件加载机制非常非常重要，因为你也知道你平时开发中很大程度实际上是在跟它的配置项打交道。新的配置加载方式比老的更加优秀，适应发展，敬请期待&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;从spring-boot-starter-test中删除Vintage Engine&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Spring Boot 2.2.0&lt;/code&gt;版本开始就引入JUnit 5作为单元测试&lt;strong&gt;「默认库」&lt;/strong&gt;，在此之前，spring-boot-starter-test包含的是JUnit 4的依赖，Spring Boot 2.2.0版本之后替换成了Junit Jupiter（Junit5）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vintage Engine属于Junit5的一个模块，它的作用是：允许用JUnit 5运行用JUnit 4编写的测试，从而提供了向下兼容的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从2.2.0到现在经过了2个版本的迭代，到&lt;code&gt;Spring Boot 2.4.0&lt;/code&gt;这个版本决定了把Vintage Engine从spring-boot-starter-test正式移除。因此：若你的工程仍需要对JUnit4支持，那么请手动引入依赖项（如果工程量不大，强烈建议使用JUnit5，比4好用太多）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.junit.vintage&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;junit-vintage-engine&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;exclusions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;exclusion&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.hamcrest&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;hamcrest-core&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;exclusion&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;exclusions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：其实在2.4.0之前，若你是从&lt;code&gt;https://start.spring.io&lt;/code&gt;生成的项目其实也是不会带有vintage-engine的。只不过它是通过显式的在pom里通过exclusion标签来排除的&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;嵌入式数据库检测&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改进嵌入式数据库检测机制：仅当数据库在&lt;strong&gt;「内存中」&lt;/strong&gt;时才将其视为嵌入式数据库。所以如果使用H2、HSQL等产品，&lt;strong&gt;「但是」&lt;/strong&gt;你是基于文件的持久性或使用的是服务器模式，那么将不会检测为内存数据库。而对于&lt;strong&gt;「非内存」&lt;/strong&gt;数据库，你可能需要额外做如下动作：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;sa用户名将不会再被主动设置。所以如果你的数据库需要用户名，请增加配置项：&lt;code&gt;spring.datasource.username = sa&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这种数据库将不会再被自动初始化，若要使用请根据需要更改&lt;code&gt;spring.datasource.initialization-mode&lt;/code&gt;的值&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Logback配置属性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Logback一些配置项改名了，更加表名了它是logback的配置项。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;新增了配置类&lt;code&gt;LogbackLoggingSystemProperties&lt;/code&gt;用于对应，它继承自之前的&lt;code&gt;LoggingSystemProperties&lt;/code&gt;&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前的配置项有些被废弃（此版本还未删除，后续版本肯定会删除的），对应关系如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;老(已废弃)&lt;/span&gt;&lt;/th&gt;&lt;th&gt;新&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;logging.pattern.rolling-file-name&lt;/span&gt;&lt;/td&gt;&lt;td&gt;logging.logback.rollingpolicy.file-name-pattern&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;logging.file.clean-history-on-start&lt;/span&gt;&lt;/td&gt;&lt;td&gt;logging.logback.rollingpolicy.clean-history-on-start&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;logging.file.max-size&lt;/span&gt;&lt;/td&gt;&lt;td&gt;logging.logback.rollingpolicy.max-file-size&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;logging.file.total-size-cap&lt;/span&gt;&lt;/td&gt;&lt;td&gt;logging.logback.rollingpolicy.total-size-cap&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;logging.file.max-history&lt;/span&gt;&lt;/td&gt;&lt;td&gt;logging.logback.rollingpolicy.max-history&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些属性是被放到system environment里面的：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;老(已废弃)&lt;/span&gt;&lt;/th&gt;&lt;th&gt;新&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;~~ROLLING_FILE_NAME_PATTERN ~~&lt;/td&gt;&lt;td&gt;LOGBACK_ROLLINGPOLICY_FILE_NAME_PATTERN&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;LOG_FILE_CLEAN_HISTORY_ON_START&lt;/span&gt;&lt;/td&gt;&lt;td&gt;LOGBACK_ROLLINGPOLICY_CLEAN_HISTORY_ON_START&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;LOG_FILE_MAX_SIZE&lt;/span&gt;&lt;/td&gt;&lt;td&gt;LOGBACK_ROLLINGPOLICY_MAX_FILE_SIZE&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;LOG_FILE_TOTAL_SIZE_CAP&lt;/span&gt;&lt;/td&gt;&lt;td&gt;LOGBACK_ROLLINGPOLICY_TOTAL_SIZE_CAP&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;LOG_FILE_MAX_HISTORY&lt;/span&gt;&lt;/td&gt;&lt;td&gt;LOGBACK_ROLLINGPOLICY_MAX_HISTORY&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;不再注册DefaultServlet&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从Spring Boot 2.4开始，默认将不会再注册&lt;code&gt;DefaultServlet&lt;/code&gt;。因为在绝大多数的应用中，Spring MVC提供的&lt;code&gt;DispatcherServlet&lt;/code&gt;是&lt;strong&gt;「唯一」&lt;/strong&gt;需要被注册的Servlet。从源码处感受下这次改动：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;AbstractServletWebServerFactory：&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 2.4.0之前版本，默认值是true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; registerDefaultServlet = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// 2.4.0以及之后版本，默认值是false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; registerDefaultServlet = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然喽，若你的工程强依赖于此Servelt，那么可以通过此配置项&lt;code&gt;server.servlet.register-default-servlet = true&lt;/code&gt;把它注册上去。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;补课：什么是DefaultServlet？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是Java EE提供的标准技术，如Tomcat、Jetty等都提供了这个类。简而言之它的作用就是兜底（拦截&lt;code&gt;/&lt;/code&gt;），当别的servlet都没匹配上时就交给它来处理，一般用于处理静态资源如&lt;code&gt;.jpg,.html,.js&lt;/code&gt;这类的静态文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DefaultServlet&lt;/code&gt;在传统web容器里，会被配置在tomcat目录（此处以tomcat为例）下的&lt;code&gt;conf/web.xml&lt;/code&gt;里：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;servlet&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;default&lt;span&gt;&amp;lt;/&lt;span&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;servlet-class&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.catalina.servlets.DefaultServlet&lt;span&gt;&amp;lt;/&lt;span&gt;servlet-class&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;init-param&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;param-name&lt;/span&gt;&amp;gt;&lt;/span&gt;debug&lt;span&gt;&amp;lt;/&lt;span&gt;param-name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;param-value&lt;/span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;span&gt;param-value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;init-param&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;init-param&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;param-name&lt;/span&gt;&amp;gt;&lt;/span&gt;listings&lt;span&gt;&amp;lt;/&lt;span&gt;param-name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;param-value&lt;/span&gt;&amp;gt;&lt;/span&gt;false&lt;span&gt;&amp;lt;/&lt;span&gt;param-value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;init-param&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;load-on-startup&lt;/span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;span&gt;load-on-startup&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;servlet&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;servlet-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;default&lt;span&gt;&amp;lt;/&lt;span&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;/&lt;span&gt;&amp;lt;/&lt;span&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;servlet-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：tomcat下的web.xml对其加载的所有的Application都生效，并且最终和Application自己的web.xml内容合并，遇相同的话后者优先级更高&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Spring Boot &lt;strong&gt;「嵌入式容器」&lt;/strong&gt;里配置是这样的（完全等价于xml配置）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addDefaultServlet&lt;/span&gt;&lt;span&gt;(Context context)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; Wrapper defaultServlet = context.createWrapper();&lt;br/&gt; defaultServlet.setName(&lt;span&gt;&quot;default&quot;&lt;/span&gt;);&lt;br/&gt; defaultServlet.setServletClass(&lt;span&gt;&quot;org.apache.catalina.servlets.DefaultServlet&quot;&lt;/span&gt;);&lt;br/&gt; defaultServlet.addInitParameter(&lt;span&gt;&quot;debug&quot;&lt;/span&gt;, &lt;span&gt;&quot;0&quot;&lt;/span&gt;);&lt;br/&gt; defaultServlet.addInitParameter(&lt;span&gt;&quot;listings&quot;&lt;/span&gt;, &lt;span&gt;&quot;false&quot;&lt;/span&gt;);&lt;br/&gt; defaultServlet.setLoadOnStartup(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt; &lt;span&gt;// Otherwise the default location of a Spring DispatcherServlet cannot be set&lt;/span&gt;&lt;br/&gt; defaultServlet.setOverridable(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt; context.addChild(defaultServlet);&lt;br/&gt; context.addServletMappingDecoded(&lt;span&gt;&quot;/&quot;&lt;/span&gt;, &lt;span&gt;&quot;default&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是：Spring Boot注册的&lt;code&gt;DispatcherServlet&lt;/code&gt;的path也是&lt;code&gt;/&lt;/code&gt;（覆盖掉了&lt;code&gt;DefaultServelt&lt;/code&gt;）。在Spring MVC环境下倘若是静态资源，也不用DefaultServelt费心，Spring MVC专门提供了一个&lt;code&gt;DefaultServletHttpRequestHandler&lt;/code&gt;用于处理静态资源（虽然最终还是Dispatcher给&lt;code&gt;defaultServlet&lt;/code&gt;去搞定）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的Spring Boot服务大都是REST服务，并无静态资源需要提供，因此就没有必要启用&lt;code&gt;DefaultServletHttpRequestHandler&lt;/code&gt;和注册&lt;code&gt;DefaultServlet&lt;/code&gt;来增加不必要的开销喽。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;HTTP traces不再包含cookie头&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Http traces默认将不再包含请求头&lt;code&gt;Cookie&lt;/code&gt;以及响应头&lt;code&gt;Set-Cookie&lt;/code&gt;。源码处感受一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;org.springframework.boot.actuate.trace.http.Include：&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 2.4.0版本之前：包含COOKIE_HEADERS这个头&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; {&lt;br/&gt; Set&amp;lt;Include&amp;gt; defaultIncludes = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;();&lt;br/&gt; defaultIncludes.add(Include.REQUEST_HEADERS);&lt;br/&gt; defaultIncludes.add(Include.RESPONSE_HEADERS);&lt;br/&gt; defaultIncludes.add(Include.COOKIE_HEADERS);&lt;br/&gt; defaultIncludes.add(Include.TIME_TAKEN);&lt;br/&gt; DEFAULT_INCLUDES = Collections.unmodifiableSet(defaultIncludes);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 2.4.0版本以及之后：不包含COOKIE_HEADERS这个头&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; {&lt;br/&gt; Set&amp;lt;Include&amp;gt; defaultIncludes = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;();&lt;br/&gt; defaultIncludes.add(Include.REQUEST_HEADERS);&lt;br/&gt; defaultIncludes.add(Include.RESPONSE_HEADERS);&lt;br/&gt; defaultIncludes.add(Include.TIME_TAKEN);&lt;br/&gt; DEFAULT_INCLUDES = Collections.unmodifiableSet(defaultIncludes);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若你仍旧想保留老的习惯，那么请用配置项&lt;code&gt;management.trace.http.include = cookies, errors, request-headers, response-headers&lt;/code&gt;自行控制。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Neo4j&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个版本对Neo4j的支持进行了重大调整。直接用源码来说明差异：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Boot 2.4.0之前版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span&gt;&quot;spring.data.neo4j&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Neo4jProperties&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationContextAware&lt;/span&gt; &lt;/span&gt;{ ... }&lt;br/&gt;&lt;span&gt;// 无Neo4jDataProperties配置类&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Boot 2.4.0以及之后版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span&gt;&quot;spring.neo4j&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Neo4jProperties&lt;/span&gt; &lt;/span&gt;{ ... }&lt;br/&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span&gt;&quot;spring.data.neo4j&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Neo4jDataProperties&lt;/span&gt; &lt;/span&gt;{ ... }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其它升级关注点&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「Spring Framework 5.3」&lt;/strong&gt;：Spring Boot 2.4.0使用的是5.3.0主线分支（之前使用的5.2.x或更低）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「Spring Data 2020.0」&lt;/strong&gt;：Spring Boot 2.4.0使用的是最新发布的Spring Data 2020.0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「支持Java 15」&lt;/strong&gt;：此版本的Spring Boot完全支持Java 15，最小支持依旧是Java 8&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自定义属性名支持：当使用&lt;strong&gt;「构造函数绑定」&lt;/strong&gt;时，属性的名称需要和参数名称保持一样。如果您想使用Java保留关键字，这可能是一个问题。如下例子：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span&gt;&quot;sample&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SampleConfigurationProperties&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String importValue;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// import是Java关键字&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;SampleConfigurationProperties&lt;/span&gt;&lt;span&gt;(@Name(&lt;span&gt;&quot;import&quot;&lt;/span&gt;)&lt;/span&gt; String importValue) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.importValue = importValue;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;@Name注解是Spring Boot 2.4.0新增的注解，能标注在&lt;code&gt;ElementType.PARAMETER&lt;/code&gt;上&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「支持导入无扩展名的配置文件」&lt;/strong&gt;：如果您有这样的需求，现在就可以通过向Spring Boot引导提供关于内容类型的提示来导入这些文件&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;此版本对Spring Boot的配置文件加载进行了完全重新改造，并且不向下兼容，具体参见&lt;strong&gt;「下篇文章」&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「新增StartupEndpoint」&lt;/strong&gt;：显示有关应用程序启动的信息。此端点可以帮助您识别启动时间超过预期的bean&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;此端点依赖于Spring Framework 5.3.0新提供的应用启动追踪新特性。具体可参考&lt;code&gt;ApplicationStartup&lt;/code&gt;和&lt;code&gt;StartupStep&lt;/code&gt;这个两个API是如何做追踪的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「新增RedisCacheMetrics」&lt;/strong&gt;：用于监控使用redis时的puts、gets、deletes以及缓存命中率等信息&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;此指标信息默认不开启，需你增加配置&lt;code&gt;spring.cache.redis.enable-statistics = true&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「新增些Web配置项」&lt;/strong&gt;：&lt;code&gt;spring.web.locale、spring.web.locale-resolver、spring.web.resources.*、management.server.base-path&lt;/code&gt;，这些属性既支持Servlet也支持WebFlux&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对应的&lt;strong&gt;「只能用于」&lt;/strong&gt; Spring MVC或servelt下配置项&lt;code&gt;spring.mvc.locale/spring.mvc.locale-resolver/spring.resources.*/management.server.servlet.context-path&lt;/code&gt;均以标注为过期&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「支持Flyway 7」&lt;/strong&gt;：这个版本升级到Flyway 7，带来了一些额外的属性。如：&lt;code&gt;spring.flyway.url/user/password&lt;/code&gt;（开源版本）；&lt;code&gt;spring.flyway.cherry-pick/jdbc-properties...&lt;/code&gt;（团队版本）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「H2数据库控制台支持配置密码」&lt;/strong&gt;：可通过&lt;code&gt;spring.h2.console.settings.web-admin-password&lt;/code&gt;属性配置通过密码访问H2控制台&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「增强的错误分析器FailureAnalizers」&lt;/strong&gt;：现在即使你还没有创建ApplicationContext，FailureAnalizers都会生效来帮你定位错误位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「处理/标注Spring Boot 2.2和2.3中过期项」&lt;/strong&gt;：按照Spring Boot的&lt;strong&gt;「版本兼容性政策」&lt;/strong&gt;，在2.2版本已被标记为&lt;code&gt;@Deprecated&lt;/code&gt;的在2.4.0版本会被删除，在2.3版本中被标记为&lt;code&gt;@Deprecated&lt;/code&gt;的计划在2.5.0版本中将其移除&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是A哥奉给大家的，对Spring Boot2.4.0版本新特性的介绍，希望对你有些帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Boot 2.4.0版本的升级目标，基本和Spring Framework 5.3.0保持一致：&lt;strong&gt;「为云原生做努力」&lt;/strong&gt;。表现在除了删除些无用类，禁止不需要的类的加载外，重点还会体现在它对&lt;strong&gt;「配置文件加载机制」&lt;/strong&gt;的重构上，这将是下文的内容，也是本次升级的重头戏，敬请关注。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Boot重写了对配置文件的加载机制，并且新引入了近40个类来处理（老方式仅有区区几个类），可见其重视、重要程度。因此，为了适应未来的发展，你一定要掌握，并且越早越好，下篇将为你揭晓。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;✔推荐阅读：&lt;span/&gt;&lt;/h5&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>eedb8610c644b3abe334f5f6ebde77ac</guid>
<title>ClickHouse 在大数据分析平台留存分析上的应用</title>
<link>https://toutiao.io/k/43p1n50</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;导语 &lt;span/&gt;&lt;span&gt;| &lt;/span&gt;&lt;/span&gt;本文实践了对于千万级别的用户，操作总数达万级别，每日几十亿操作流水的留存分析工具秒级别查询的数据构建方案。同时，除了留存分析，对于用户群分析，事件分析等也可以尝试用此方案来解决。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;文章作者：陈璐，腾讯高级数据分析师&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;  背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;你可能听说过Growingio、神策等数据分析平台，本文主要介绍实现留存分析工具相关的内容。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;留存分析是一种用来分析用户参与情况/活跃程度的分析模型，可考查进行初始行为后的用户中，有多少人会进行后续行为，这是衡量产品对用户价值高低的重要指标。如，为评估产品更新效果或渠道推广效果，我们常常需要对同期进入产品或同期使用了产品某个功能的用户的后续行为表现进行评估 [1]。大部分数据分析平台主要包括如图的几个功能（以神策为例）：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.39453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7djjGuFMQC5frmR4MaEZxu1aACgmM0VmzClz8bNIU4dwbsOPEMsLsNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文主要介绍留存分析工具的优化方案（只涉及数据存储和查询的方案设计，不涉及平台）。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我想每个数据/产品同学在以往的取数分析过程中，都曾有一个痛点，就是每次查询留存相关的数据时，都要等到天荒地老，慢！而最近采用优化方案的目的也是为了提高查询的效率和减少数据的存储，可以帮助产品快速地查询/分析留存相关的数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优化方案的核心是在Clickhouse中使用Roaringbitmap对用户进行压缩，将留存率的计算交给高效率的位图函数，这样既省空间又可以提高查询速度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;希望本实践方案可以给你带来一些帮助和启示。下面主要分3个部分详细介绍：Roaringbitmap简介、思路与实现、总结与思考。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、Roaringbitmap 简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面先简单介绍一下高效的位图压缩方法Roaringbitmap。先来看一个问题:&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;给定含有&lt;span&gt;40&lt;/span&gt;亿个不重复的位于&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;^&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;区间内的整数集合，如何快速判定某个数是否在该集合内？&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;显然，如果我们将这40亿个数原样存储下来，需要耗费高达14.9GB的内存，这是难以接受的。所以我们可以用位图(bitmap)来存储，即第0个比特表示数字0，第1个比特表示数字1，以此类推。如果某个数位于原集合内，就将它对应的位图内的比特置为1，否则保持为0，这样就能很方便地查询得出结果了，仅仅需要占用512MB的内存，不到&lt;span&gt;原来的&lt;/span&gt;3.4% [3]。但是这种方式也有缺点：比如我需要将1~5000w这5000w个连续的整数存储起来，用普通的bitmap同样需要消耗512M的存储，显然，对于这种情况其实有很大的优化空间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2016年由S. Chambi、D. Lemire、O. Kaser等人在论文《Better bitmap performance with Roaring bitmaps》与《Consistently faster and smaller compressed bitmaps with Roaring》中提出了roaringbitmap，主要特点就是可以极大程度地节约存储及提供了快速的位图计算，因此考虑用它来做优化。对于前文提及的存储连续的5000w个整数，只需要几十KB。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;它的主要思路是：将32位无符号整数按照高16位分桶，即最多可能有2^16&lt;span&gt;=65536个桶，论文内称为container。存储数据时，按照数据的高16位找到container（找不到就会新建一个），再将低16位放入container中。也就是说，一个roaringbitmap就是很多container的集合 [3]，具体细节可以自行查看文末的参考文章&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、思路与实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们的原始数据主要分为：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1.用户操作行为数据table_oper_raw&lt;br/&gt;包括时间分区(ds)、用户标识id(user_id)和用户操作行为名称(oper_name)，如：20200701|6053002|点击首页banner 表示用户6053002在20200701这天点击了首页banner（同一天中同一个用户多次操作了同一个行为只保留一条）。实践过程中，此表每日记录数达几十亿行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.用户属性数据table_attribute_raw&lt;br/&gt;表示用户在产品/画像中的属性，包括时间分区(ds)、用户标识(user_id)及各种用户属性字段（可能是用户的新进渠道、所在省份等），如20200701|6053002|小米商店|广东省。实践过程中，此表每日有千万级的用户数，测试属性在20+个。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;现在我们需要根据这两类数据，求出某天操作了某个行为的用户在后续的某一天操作了另一个行为的留存率，比如，在20200701这天操作了“点击banner”的用户有100个，这部分用户在20200702这天操作了“点击app签到”的有20个，那么对于分析时间是20200701，且“点击banner”的用户在次日“点击app签到”的留存率是20%。同时，还需要考虑利用用户属性对留存比例进行区分，例如只考虑广东省的用户的留存率，或者只考虑小米商店用户的留存率，或者在广东的小米商店的用户的留存率等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般来说，求留存率的做法就是两天的用户求交集，例如前文说到的情况，就是先获取出20200701的所有操作了“点击banner”的用户标识id集合假设为S1，然后获取20200702的所有操作了“点击app签到”的用户标识id集合假设为S2，最后求解S1和S2的交集：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.49635036496350365&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7JM2bmia6bQibnZI0yjHVf5GmBDYGv20GB3e0mvX3lE6WJdG2Zm6f7IicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;548&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看到，当s1和s2的集合中用户数都比较大的时候，join的速度会比较慢。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在此我们考虑前文说到的bitmap，假若每一个用户都可以表示成一个32位的无符号整型，用bitmap的形式去存储，S1和S2的求交过程就是直接的一个位比较过程，这样速度会得到巨大的提升。而Roaringbitmap对数据进行了压缩，其求交的速度在绝大部分情况下比bitmap还要快，因此这里我们考虑使用Roaringbitmap的方法来对计算留存的过程进行优化。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;1.数据构建&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;整个过程主要是：首先对初始的两张表——用户操作数据表table_oper_raw和用户筛选维度数据表table_attribute_raw中的user_id字段进行编码，将每个用户映射成唯一的id（32位的无符号整型），分别得到两个新表table_oper_middle和table_attribute_middle。再将他们导入clickhouse，使用roaringbitmap的方法对用户进行压缩存储，最后得到压缩后的两张表table_oper_bit和table_attribute_bit，即为最终的查询表。流程图如下：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7wPRPrVWW2ApyiaXVn4S8fvkNQTIdCGf041ibR4oCbQGfIGJq7p0Nb3hQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;(1).生成用户id映射表&lt;br/&gt;首先，需要构建一个映射表table_user_map，包含时间分区(ds)、用户标识id(user_d)及映射后的id(id)，它将每个用户(String类型)映射成一个32位的无符号整型。这里我们从1开始编码，这样每个用户的标识就转化成了指定的一个数字。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.23493975903614459&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7Gxgfwyiab2RO1ylAIEnGfc1w5icUdby5ZjjzD5h9sY5BMJlUd67Uiasag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;332&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;(2).初始数据转化&lt;br/&gt;分别将用户操作数据表和用户筛选维度数据中的imei字段替换成对应的数值，生成编码后的用户操作数据:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.11635220125786164&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7tpLtCFB2yfRFczs5qUibTp1EtoQ8zbOHPsf6FePKGXicZKsPYhQpPyrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;和用户筛选维度数据:&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.09112709832134293&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7R2ZSW4zF4G0Q5HnlbUKTFQzAQjq91CXqSib9nlPQ8SvWz3WDy7suysg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;834&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;(3).导入clickhouse&lt;br/&gt;首先在clickhouse中创建相同结构的表，如table_oper_middle_ch。&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;同样的，在clickhouse中创建表table_attribute_middle_ch。然后用spark将这两份数据分别导入这两张表。这一步导入很快，几十亿的数据大概10分多钟就可以完成&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3967828418230563&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7ib0IxqbeU1SILUhCrzs0iby23DFCbFe8rGiadMz5cvadRpGwdWAN9BPMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;373&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;(4).Roaringbitmap压缩&lt;br/&gt;对于用户操作流水数据，我们先建一个可以存放bitmap的表table_oper_bit，建表语句如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3259423503325942&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw78tV3UksY9Mia7wE2hSSmAfz8nicLkq91LIRgjWH2KjMogO164ZXjExAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;451&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;用户属性数据table_attribute_bit也类似：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.38063063063063063&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7sUG3cp406UEqEPhO1CBYhYK1otykS1Cf2kY7CUKdMVVXicFFxudlVxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;444&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;这里索引粒度可设置小值，接着用聚合函数groupBitmapState对用户id进行压缩：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.41455696202531644&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7gFXqiaqVibv4HwKJ1dQicFIyK56ibrZwNsib2ytCGNT1KF4BQcX9w1ZF7ibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;316&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;这样，对于用户操作数据表，原本几十亿的数据就压缩成了几万行的数据，每行包括操作名称和对应的用户id形成的bitmap：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.15104166666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7BzFicBUndWMm5QCaWfbK0vibGgiceDl4QQtfkjn2y73oja0G1KYjnc1wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;384&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;同样的，用户属性的数据也可以这样处理，得到table_attribute_bit表，每行包括某个属性的某个属性值对应的用户的id形成的bitmap：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.12058212058212059&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7OibLlbhjic1SjicTcFxJtCGZbIfMo3kQ61aedM1g27p0tPoyaE4UzvfEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;481&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;至此，数据压缩的过程就这样完成了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;2.查询过程&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;首先，简要地介绍下方案中常用的bitmap函数（详细见文末的参考资料）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.bitmapCardinality&lt;br/&gt;返回一个UInt64类型的数值，表示bitmap对象的基数。用来计算不同条件下的用户数，可以粗略理解为count(distinct)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.bitmapAnd&lt;br/&gt;为两个bitmap对象进行与操作，返回一个新的bitmap对象。可以理解为用来满足两个条件之间的and，但是参数只能是两个bitmap&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.bitmapOr&lt;br/&gt;为两个bitmap对象进行或操作，返回一个新的bitmap对象。可以理解为用来满足两个条件之间的or，但是参数也同样只能是两个bitmap。如果是多个的情况，可以尝试使用groupBitmapMergeState&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;举例来说，假设20200701这天只有[1,2,3,5,8]这5个用户点击了banner，则有：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;# 返回5&lt;/span&gt;&lt;br/&gt;select bitmapCardinality&lt;span&gt;(&lt;/span&gt;user_bit&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; tddb&lt;span&gt;.&lt;/span&gt;table_oper_bit&lt;br/&gt;where ds &lt;span&gt;=&lt;/span&gt; &lt;span&gt;20200701&lt;/span&gt; AND oper_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&#x27;点击banner&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;又如果20200701从小米商店新进的用户是[1,3,8,111,2000,100000]，则有：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;# 返回3,因为两者的重合用户只有1,3,8这3个用户&lt;/span&gt;&lt;br/&gt;select bitmapCardinality&lt;span&gt;(&lt;/span&gt;bitmapAnd&lt;span&gt;(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(&lt;/span&gt;SELECT user_bit&lt;br/&gt;         FROM tddb&lt;span&gt;.&lt;/span&gt;table_oper_bit&lt;br/&gt;         WHERE &lt;span&gt;(&lt;/span&gt;ds &lt;span&gt;=&lt;/span&gt; &lt;span&gt;20200701&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; AND &lt;span&gt;(&lt;/span&gt;oper_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&#x27;点击banner&#x27;&lt;/span&gt;&lt;span&gt;)),&lt;/span&gt; &lt;br/&gt;&lt;span&gt;(&lt;/span&gt;SELECT user_bit&lt;br/&gt; FROM tddb&lt;span&gt;.&lt;/span&gt;table_attribute_bit&lt;br/&gt; WHERE ds &lt;span&gt;=&lt;/span&gt; &lt;span&gt;20200701&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;attr_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&#x27;first_channel&#x27;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;attr_value IN &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&#x27;小米商店&#x27;&lt;/span&gt;&lt;span&gt;)))))&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;有了以上的数据生成过程和bitmap函数，我们就可以根据不同的条件使用不同的位图函数来快速查询，具体来说，主要是以下几种情况：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;a. 操作了某个行为的用户在后续某一天操作了另一个行为的留存：&lt;br/&gt;如“20200701点击了banner的用户在次日点击app签到的留存人数”，就可以用以下的sql快速求解:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.44764795144157815&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7q3XGdutJvsmXcSibb444YnHmHF20NnffOxyPxlHtXJ3uQ5zLSSGvUrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;659&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;b. 操作了某个行为并且带有某个属性的用户在后续的某一天操作了另一个行为的留存：&lt;br/&gt;如“20200701点击了banner且来自广东/江西/河南的用户在次日点击app签到的留存人数”：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7K2q8kMUzbQsS1tq47Cnj1u6m52Mah2UY678DnibSetIPBEzH1V6Eb6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1040&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;c. 操作了某个行为并且带有某几个属性的用户在后续的某一天操作了另一个行为的留存：&lt;br/&gt;如“20200701点击了banner、来自广东且新进渠道是小米商店的用户在次日点击app签到的留存人数”：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4229287090558767&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7Nf7mtL6QhAxS7BxBmOy5s8hZflCW6F0z5Mp20n6QsGIQWwibBdBGibsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1038&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;3.实践效果&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;根据这套方案做了实践，对每日按时间分区、用户、操作名称去重后包括几十亿的操作记录，其中包含千万级别的用户数，万级别的操作数。最后实现了：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;存储&lt;br/&gt;原本每日几十G的操作流水数据经压缩后得到的表table_oper_bit为4GB左右/天。而用户属性表table_attribute_bit为500MB左右/天&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;查询速度&lt;br/&gt;clickhouse集群现状：12核125G内存机器10台。clickhouse版本:20.4.7.67。查询的表都存放在其中一台机器上。测试了查询在20200701操作了行为oper_name_1(用户数量级为3000+w)的用户在后续7天内每天操作了另一个行为oper_name_2(用户数量级为2700+w)的留存数据(用户重合度在1000w以上)，耗时0.2秒左右&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.0796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7VAlcIZchWNwDCJDymLTEFic2YEBfKOxtya0UkpkOquQk4VECt4JqyVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;反馈&lt;br/&gt;最后和前端打通，效果也是有了明显的优化，麻麻再也不用担心我会转晕~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37846655791190864&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5DWdeuDz8ibYF8eujg7tPgw7jlAz7DARIaq4uKa6LtXy1XJQCyoE5kgo43rjQNuuSp7rwVcTmroAicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;613&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;三、总结与思考&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总的来说，本方案的优点是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，根据本方案的特点，除了留存分析工具，对于用户群分析，事件分析等工具也可以尝试用此方案来解决。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;PS : 作者初入坑&lt;span&gt;ch&lt;/span&gt;，对于以上内容，有不正确/不严谨之处请轻拍~ 欢迎交流~&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;参考文献：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;[1] 解析常见的数据分析模型——留存分析：https://www.sensorsdata.cn/blog/jie-xi-chang-jian-de-shu-ju-fen-xi-mo-xing-liu-cun-fen-xi/&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;[2] &lt;/span&gt;RoaringBitmap数据结构及原理：&lt;/span&gt;&lt;span&gt;https://blog.csdn.net/yizishou/article/details/78342499&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;] &lt;/span&gt;高效压缩位图RoaringBitmap的原理与应用：&lt;/span&gt;&lt;span&gt;https://www.jianshu.com/p/818ac4e90daf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;] 论文：Better bitmap performance with Roaring bitmaps：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;https://arxiv.org/abs/1402.6407v9?utm_source=feedburner&amp;amp;utm_medium=feed&amp;amp;utm_campaign=Feed%3A+DanielLemiresArticlesOnArxiv+(Daniel+Lemire%27s+articles+on+arXiv)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;] &lt;/span&gt;Clickhouse文档-位图函数：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;https://clickhouse.tech/docs/zh/sql-reference/functions/bitmap-functions/&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section label=&quot;Copyright © 2016 playhudong All Rights Reserved.&quot; donone=&quot;shifuMouseDownPayStyle(&#x27;shifu_sig_022&#x27;)&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;腾讯云大数据&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/o2eWePa4j5DaCQzdVZibTicwrQId09Q0DzibuXlpp9fRibyulbDiafDHDk1ImSnbiaJ7PUHiajfOQLQlnLiczls7BVJFqQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; title=&quot;https://image.ipaiban.com/upload-ueditor-image-20200619-1592556685554099336.jpg&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;长按二维码&lt;br/&gt;关注我们&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>492aae953157a81e18da9b570030ac8e</guid>
<title>从单元测试覆盖率看富领域模型到底有多富</title>
<link>https://toutiao.io/k/84xy6p3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;使用了DDD（领域驱动设计）后，代码编写有什么不一样呢？&lt;/span&gt;&lt;span&gt;这可能是程序员们在接触DDD后最关心的一个问题。&lt;/span&gt;&lt;span&gt;这个系列文章会对一些优秀的DDD实例代码进行分析，管中窥豹，略见数斑。&lt;/span&gt;&lt;span&gt;这是第一篇。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;DDD中程序员最关心的部分&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;DDD（领域驱动设计）是一个复杂而全面的方法，编码只是最后一步。&lt;img data-ratio=&quot;0.561662198391421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FKH7VBhA4DebpUmrVyBZAA6wF96Nh5kO3R234h9Q52pYs30nCyGmBVGwARTKqXc7b1LvicPCvErRZSp8ic37MbKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;https://github.com/ddd-crew/ddd-starter-modelling-process&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;但这是程序员最关心的部分，也是被问到最多的问题。所以计划写个系列文章对一些优秀的DDD实例代码进行分析，希望能解开一些困惑。&lt;/p&gt;&lt;p&gt;IDDD（《实现领域驱动设计》），是最常被推荐的一本书。书中有一个关于构建Scrum管理软件的例子，我们先来分析这个经典的例子的源码（https://github.com/VaughnVernon/IDDD_Samples）。&lt;/p&gt;&lt;p&gt;第一篇先从单元测试和富领域模型说起。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;我所目睹单元测试之怪状&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;关于自动化的单元测试，无数人都心怀向往。&lt;/p&gt;&lt;p&gt;《The Clean Coder》里边描述的测试金字塔给出了单元测试在整个测试中的位置。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7194444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FKH7VBhA4DebpUmrVyBZAA6wF96Nh5kOMjjd3zUK851niaceZ4BaNummlgGtjMhFHWnwicQIU2qSMYyv9HOzb4iaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;经是好经，但大部分时候会被歪嘴和尚给念歪：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我遇到的第一个例子，比较普遍，开发人员用JUnit写单元测试，每次本地开发的时候改一改，当main方法用，在构建的时候都把test case都给skip掉&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我遇到的第二个例子，是曾经有一个质量效能部门推动对单测覆盖率进行考核。结果各个开发团队有苦难言，只有一个开发团队做的比较好，质量效能团队给发了个大奖，后来有人发现这个团队的测试覆盖率高，是因为他们写了一个代码自动生成工具，给每个get/set方法都生成了JUnit测试……质量效能团队被piapia打脸&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我遇到的第三个例子，是一个 有追求的团队，他们在构建时不skip，但每次做需求的时候，修改单元测试代码的时间甚至会超过了编写正式代码的时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我遇到的第四个例子，是一个更有追求的团队，他们想学习Google、Facebook搞主干开发模式，把CI/CD做的特别好，但自动化测试覆盖率不够还经常跑不通，没有了自动化测试做保障，主干开发也不得不作罢&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我在《当我们在谈论单测时我们在谈论什么》里分析过这个问题：“自动化单元测试 = 自动化 + 单元 + 测试”，本质原因是大部分代码“单元化”程度很低，所以，这个前提不具备，是折腾不成功的。&lt;/p&gt;&lt;p&gt;但DDD的富领域模型有助于达成这个前提。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;富领域模型为什么有助于单测&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;DDD的代码组织推荐六边形模型，一个重点是领域层和应用层的分工。&lt;img data-ratio=&quot;0.6292286874154263&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FKH7VBhA4DebpUmrVyBZAA6wF96Nh5kOK19s9icUEV7ScTSm6ofKsj1uG3HyvVurVyLbSU5F0p3NCr8ia5C0hB1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;739&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里有几个有助于用低成本（编写和维护）提升覆盖测试率的条件：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;领域层里的实体对象不再只是有get/set方法，还有很多业务逻辑。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;领域实体是没有任何外部依赖的，也就是说，这些业务逻辑都是本地内存中就可以执行的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;以聚合组织的领域实体内聚性强&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从图上也可以看出，应用层比较薄，领域层比较厚&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们看看IDDD_Sample这么做了以后，单元测试覆盖率的达到理想的状况吗？&lt;/p&gt;&lt;h2&gt;&lt;span&gt;IDDD示例的单测覆盖率统计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;首先我们选择agilepm这个模块，看看应用层代码行数和领域层代码行数的对比，看看是否符合领域层比较厚的这个前提。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9980694980694981&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FKH7VBhA4DebpUmrVyBZAA6wF96Nh5kOqZM4hqFXKAOMKoZjx68xAfKeLib8yqwQKias4r7GstxhDC1cxc03DwTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;518&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;领域层代码&lt;span&gt;6943&lt;/span&gt;行，而应用层只有&lt;span&gt;750&lt;/span&gt;行，领域层代码占比达到了90%！！！&lt;/strong&gt;这个比例是不是和我们平时写的贫血模型代码很不一样？&lt;/p&gt;&lt;p&gt;下面我们看看领域层的无任何外部依赖的单元测试（不需要Mock，不需要准备数据库等）的测试覆盖率：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.4714518760195758&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FKH7VBhA4DebpUmrVyBZAA6wF96Nh5kOtHOJcBlaElSudKGy2HaEjDOGqrsAiaD9KQjWlUcvbnX4FUoTZcz24Yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;613&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;行代码覆盖率有70%！！！我看了一下，这其中没有被测试到的，是一些equals、get/set方法。除去这些，应该会达到90%，或者继续做的100%也并不难。&lt;/p&gt;&lt;p&gt;总结起来，这个应用的&lt;strong&gt;90%的逻辑可以有90%的自动化单元测试覆盖率 &lt;/strong&gt;—— 不需要mock，不需要依赖数据库、外部中间件、RPC等。&lt;/p&gt;&lt;p&gt;这得益于它使用了富领域模型，而不是贫血模型，得益于其正确地组织了业务逻辑代码。测试覆盖率也从侧面展示了富领域模型到底有多富。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;但是先不要急&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;我最担心的是有人看到这里说：懂了，我们开始搞富领域模型吧！&lt;/p&gt;&lt;p&gt;这可能让你从一个坑里爬出来，接着跳到另外一个坑里。&lt;/p&gt;&lt;p&gt;自动化单测难以推行，是因为“单元化”这个前提不具备。富领域模型可以帮助这个前提的达成。&lt;/p&gt;&lt;p&gt;但富领域模型的前提是什么？已经具备了吗？&lt;/p&gt;&lt;p&gt;且待下回分解。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.14444444444444443&quot; data-type=&quot;png&quot; data-w=&quot;360&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fgnkxfGnnkShjqicTdm3hyJco21g4Zf1s3nTnNoAGcHlv4uUcwUGoibTicgVxBNtjMlnCGGWNnYRVfu9RjUuxTibibw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;往期推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FKH7VBhA4DcPRUGgRo2smeBShibfI08FRWH4C3MVNAcHu5SKhbyVb7zNZoemDID3NJMjAGuONjwKGjBNMAWyeTA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span data-raw-text=&quot;长&quot; data-textnode-index=&quot;85&quot; data-index=&quot;3059&quot;&gt;长&lt;/span&gt;&lt;span data-raw-text=&quot;按&quot; data-textnode-index=&quot;85&quot; data-index=&quot;3060&quot;&gt;按&lt;/span&gt;&lt;span data-raw-text=&quot;2&quot; data-textnode-index=&quot;85&quot; data-index=&quot;3061&quot;&gt;2&lt;/span&gt;&lt;span data-raw-text=&quot;秒&quot; data-textnode-index=&quot;85&quot; data-index=&quot;3062&quot;&gt;秒&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;85&quot; data-index=&quot;3063&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;识&quot; data-textnode-index=&quot;85&quot; data-index=&quot;3064&quot;&gt;识&lt;/span&gt;&lt;span data-raw-text=&quot;别&quot; data-textnode-index=&quot;85&quot; data-index=&quot;3065&quot;&gt;别&lt;/span&gt;&lt;span data-raw-text=&quot;二&quot; data-textnode-index=&quot;85&quot; data-index=&quot;3066&quot;&gt;二&lt;/span&gt;&lt;span data-raw-text=&quot;维&quot; data-textnode-index=&quot;85&quot; data-index=&quot;3067&quot;&gt;维&lt;/span&gt;&lt;span data-raw-text=&quot;码&quot; data-textnode-index=&quot;85&quot; data-index=&quot;3068&quot;&gt;码&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;85&quot; data-index=&quot;3069&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;关&quot; data-textnode-index=&quot;85&quot; data-index=&quot;3070&quot;&gt;关&lt;/span&gt;&lt;span data-raw-text=&quot;注&quot; data-textnode-index=&quot;85&quot; data-index=&quot;3071&quot;&gt;注&lt;/span&gt;&lt;span data-raw-text=&quot;我&quot; data-textnode-index=&quot;85&quot; data-index=&quot;3072&quot;&gt;我&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>34931caaf04707b8dd228c40bedaf9d0</guid>
<title>从烟囱式到 SOA 再到微服务，我把阿里面试官说懵了</title>
<link>https://toutiao.io/k/otecb5i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt; &lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;大家都听过&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;SOA架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;，也都知道现在特别火的&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;微服务架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;，那么这两个有什么区别呢，别傻傻分不清了，这篇告诉你，学会它，把阿里面试官都说懵逼！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;之前找工作面试的时候，面试官总是问我你了解SOA吗，你知道为什么微服务这么火吗，他们有什么区别吗，之前乱说一通的我现在才知道，了解这个可能比你会开发更重要，所以它来了！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;系统架构的发展&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;烟囱式的架构&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;很多公司老的IT架构属于传统的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;“烟囱式”架构&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，也就是每个业务线之间由不同的开发团队独立建设，技术栈不同，互不联系。大多数的架构会被打包成为war包并且被部署到Apache Tomcat Web容器中， 整个结构趋于传统的单体架构，业务逻辑耦合在一个项目中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/YUg6EDkZ5ThUYCMJ8fOWfFRIXpZVfp3khoACnFPVUwmuicA1xxe2PGEs64lSTGn9azUjrSHcnB5MLm6usxZPXEg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;375&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;这样的架构有几个主要的弊端：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重复开发。每个业务线中间同样的模块会重复开发，比如会员营销模块，A业务线要建一个会员营销系统，B业务线也要建一个会员营销系统，这会造成很大的开发资源浪费；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;技术栈不统一。可能A系统用的是Spring MVC, B系统用的就是Spring Boot/Cloud。这会造成公司内部IT架构无法统一规划，且技术能力难以积累的问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据分布广，格式不统一，导致数据难以打通。A系统的会员存在A系统的MySQL库中，B系统的会员存在B系统的Oracle库中，如果要识别A系统中的001会员和B系统中的002会员是同一个人，也许只能在数仓中实现了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;总结：这样的架构的好处就是可以互不影响地独立部署独立迭代了，适合业务线较少且比较独立的公司采用。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SOA架构&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;SOA 全称是: Service Oriented Architecture&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，中文释义为 “&lt;/span&gt;&lt;span&gt;&lt;strong&gt;面向服务的架构&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”它是一种设计理念，其中包含多个服务， 服务之间通过相互依赖最终提供一系列完整的功能。各个服务通常以独立的形式部署运行，服务之间 通过网络进行调用。&lt;span&gt;架构图如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7137931034482758&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YUg6EDkZ5ThUYCMJ8fOWfFRIXpZVfp3kad5bm3aueop8OiaQ8iasez154t2A6xoqEoeP3e9H7ze3Yaib5870CZcMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;290&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;SOA的核心理念为：&lt;/span&gt;&lt;span&gt;松耦合带来的服务重用，通过服务编排助力业务的快速响应和创新&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在SOA时代，有两种SOA的主要实现方式，分别是&lt;/span&gt;&lt;span&gt;Web Service&lt;/span&gt;&lt;span&gt; 和&lt;/span&gt;&lt;span&gt;ESB&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;下面会着重讲一下ESB&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;微服务架构&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;微服务架构和 SOA 架构非常类似,微服务只是的 SOA 升华，只不过微服务架构强调的是“业务需要彻底的组件化及服务化”，原单个业务系统会被拆分为多个可以独立开发、设计、部署运行的小应用。这些小应用间通过服务化完成交互和集成。组件表示的就是一个可以独立更换和升级的单元，就像 PC 中的 CPU、内存、显卡、硬盘一样，独立且可以更换升级而不影响其他单元。若我们把 PC 中的各个组件以服务的方式构建，那么这台 PC 只需要维护主板和一些必要的外部设备就可以。CPU、内存、硬盘等都是以组件方式提供服务，例如PC 需要调用 CPU 做计算处理，只需知道 CPU 这个组件的地址就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;微服务架构的特性：&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;单一职责&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;轻量级通信&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;独立性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;进程隔离&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;微服务架构的缺点：&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;运维要求较高&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分布式的复杂性&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;接口调整成本高&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;重复劳动&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;单体架构和微服务架构对比：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;table data-sort=&quot;sortDisabled&quot; align=&quot;left&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;&lt;br/&gt;&lt;/th&gt;&lt;th align=&quot;center&quot;&gt;传统单体架构&lt;/th&gt;&lt;th align=&quot;center&quot;&gt;分布式微服务化架构&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;新功能开发&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;需要时间&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;容易开发和实现&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;部署&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;不经常而且容易部署&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;经常发布，部署复杂&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;隔离性&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;故障影响范围大&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;故障影响范围小&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;架构设计&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;初期技术选型难度大&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;设计逻辑难度大&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;系统性能&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;相对时间快，吞吐量小&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;相对时间慢，吞吐量大&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;系统运维&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;运维难度简单&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;运维难度复杂&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;新人上手&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;学习曲线大（应用逻辑）&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;学习曲线大（架构逻辑）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;技术&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;技术单一而且封闭&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;技术多样而且容易开发&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;测试和差错&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;简单&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;复杂（每个服务都要进行单独测试，还需要集群测试）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;系统扩展性&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;扩展性差&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;扩展性好&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;系统管理&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;重点在于开发成本&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;重点在于服务治理和调度&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;使用微服务架构的原因：&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;开发简单&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;快速响应需求变化&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;随时随地更新&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;系统更加稳定可靠&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;接下来聊一聊SOA中的ESB&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;随着我们的业务越来越复杂，会发现服务越来越多，SOA架构下，他们的调用关系会变成&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;1.0520833333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YUg6EDkZ5ThUYCMJ8fOWfFRIXpZVfp3kXwGzGpo2SMPfrP0fAbT086iasIekoPPUFMicMaDE80W4lGFfyvmXicAjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;480&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;怎么去清理这一团糟的东西呢？ESB(企业服务总线)来了！&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;当你理解系统并不直接交换信息，理解什么是服务，那么现在你可以开始使用ESB了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.8115942028985508&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YUg6EDkZ5ThUYCMJ8fOWfFRIXpZVfp3kQOTd41rdXQC4jWSbOlW9VXnIBdnJuvCgkpGGTiaCeXwJQLBtNl7ZSiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;414&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简单来说 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;ESB &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;就是一根管道，用来连接各个服务节点。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;ESB&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的存在是为了集成基于不同协议的不同服务，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;ESB &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;做了消息的转化、解释以及路由的工作，以此来让不同的服务互联互通。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;从名称就能知道，它的概念借鉴了计算机组成原理中的通信模型——总线，所有需要和外部系统通信的系统，统统接入&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;ESB&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，岂不是完美地兼容了现有的互相隔离的异构系统，可以利用现有的系统构建一个全新的松耦合的异构的分布式系统&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;ESB&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;做了消息的转换解释与路由等工作，让不同的服务互联互通。传统的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;ESB&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的服务调用方式是，每一次服务的调用者要向服务提供者进行服务交互请求时都必须通过中心的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;ESB&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;来进行路由。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;每一次服务交互的路线是：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;服务调用者--&amp;gt;ESB（接收服务请求）--&amp;gt;服务提供者（服务处理）--&amp;gt;ESB（服务提供返回结果）--&amp;gt;服务调用者（服务返回）&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6465863453815262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/YUg6EDkZ5ThUYCMJ8fOWfFRIXpZVfp3kH6yLjEp4kLiaO5XM2xJBIcZnBBwIkRrbBYsK59hygTb1S7JHd1phxwA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;996&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;使用了ESB，也需要注意！&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;毁掉SOA概念的最好的方法就是，推出ESB，就期待所有的事情自己顺顺利利。虽然ESB是一个了不起的想法，但很不幸，只是简单的安装ESB不会解决你太多问题。最好的方法，你还是要整理一下你的架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;像下图一样，如果不打扫，即使用了ESB也得不到任何好处。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6935779816513762&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YUg6EDkZ5ThUYCMJ8fOWfFRIXpZVfp3kS68qLLCygibtdnmkc6SNsQ0SYkU2rgjp3EyXxmJpSsUC9qnHcVUtebA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;545&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以从最开始的架构设计到之后的定时整理都至关重要！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;从SOA到微服务&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;SOA的出现其实是为了解决历史问题：企业在信息化的过程中会有各种各样互相隔离的系统，需要有一种机制将他们整合起来，所以才会有上边所述的ESB的出现。同样的，也造成了SOA初期的服务是很大的概念，通常指定的一个可以独立运作的系统（这样看，好像服务间天然的松耦合）。这种做法相当于是「把子系统服务化」。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;而微服务没有历史包袱，轻装上阵，服务的尺寸通常不会太大，关于服务的尺寸，在实际情况中往往是一个服务应该能够代表「实际业务场景中的一块不可分割或不易分割的业务实体」。将服务的尺寸控制在一个较小的体量可以带来很多的好处&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;微服务架构倡导将软件应用设计成多个可独立开发、可配置、可运行和可维护的子服务&lt;/strong&gt;，子服务之间通过良好的接口定义通信机制，通常使用 RESTful 风格的 API 形式来通信 ，因为RESTful 风格的 API 通常是在 HTTP 或者 HTTPS 通道上传输 JSON 格式的数据来实现的， HTTP协议有跨语言、跨异构系统的优点， 当然，也可以通过底层的 进制协议、消息队列协议等进行交互。这些服务不需要中心化的统 管理，每个服务的功能可自治，并且可以由不同的语言、系统和平台实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;微服务的架构如下图所示：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/YUg6EDkZ5ThUYCMJ8fOWfFRIXpZVfp3k9OQLibbN0CDMtVQp3jzozdIC1Sb9EcgCAezCxl3GMgicwk9qCqHg3Qug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们看到微服务架构的 些特点与 SOA 服务化架构相似， 事实上微服务架构与 SOA服务化架构并不冲突，它们一脉相承，却略有不同：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;目的不同&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;微服务使用 系列的微小服务来实现整体的业务流程，目的是有效地拆分应用，实现敏捷开发和部署，在每个微小服务的团队里，减少了跨团队的沟通，让专业的人做专业的事，缩小变更和迭代影响的范围，并达到单一微服务更容易水平扩展的目的。&lt;br/&gt;SOA 服务化涉及的范围更广 些，强调不同的异构服务之间的协作和契约 ，并强调有效集成、业务流程编排、历史应用集成等，典型代表为 Web Service 和ESB。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;部署不同&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;微服务将完整的应用拆分成多个细小的服务，通常使用敏捷扩容、缩容的 Docker 技术来实现自动化的容器管理 每个微服务运行在单 的进程内，微服务中的部署互相独立互不影响。&lt;br/&gt;SOA 服务化通常将多个业务服务通过组件化模块方式打包在 War 包里，然后统部署在一个应用服务器上。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;服务粒度不同&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;微服务倡导将服务拆分成更细的粒度，通过多个服务组合来实现业务流程的处理，拆到职责单一，甚至小到不能再进行拆分。&lt;br/&gt;SOA对粒度没有要求，在实践中服务通常是粗粒度的，强调接口契约的规范化，内部实现可以更粗粒度。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;SOA，ESB，微服务的区别和关系&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;1、SOA是一种理念，它的主要特性--面向服务的分布式计算，服务间松散耦合，支持服务的封装，服务注册和自动发现，以服务契约方式定义服务交互方式。但是，SOA并没有定义出具体的实现方式，目前有两套SOA理念的实现方式：中心化和去中心化，这两套架构并没有优劣之分，还是要针对企业的根本诉求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;SOA中心化的实现方式就是ESB&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，ESB的根本诉求是为了解决异构系统之间的连通性，通过协议转换、消息解析、消息路由把服务提供者的数据传送到服务消费者。所以，ESB是中心化的，很重，有一定的逻辑，但它的确可以解决一些公用逻辑的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;/span&gt;&lt;strong&gt;&lt;span&gt;SOA去中心化的实现方式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的根本诉求是扩展性，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;实现方式就是微服务&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;分布式服务框架&lt;/span&gt;，主要有dubbo、spring cloud，实现后端服务治理的功能。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;本文主要讲了架构的演变过程，以及各个架构模式的解析，从SOA出发了解它的概念和实现方式，了解ESB的作用和原理，探讨了SOA和微服务之间的关系。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;SOA是一种概念，拿SOA和微服务做对比不太恰当，微服务是SOA去中心化的实现方式，而ESB是SOA中心化的实现方式，要分清两者的区别，不要混淆了！&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;假如面试中你被问到这些，我相信你看了这篇一定能拨动面试官的心！&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;下篇将会更加深入的来了解微服务的知识哦，&lt;strong&gt;希望你们是我最好的观众！&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;乐于输出&lt;span&gt;干货&lt;/span&gt;的Java技术公众号：Garnett的Java之路。公众号内有大量的技术文章、海量视频资源、精美脑图，不妨来&lt;span&gt;关注&lt;/span&gt;一下！&lt;span&gt;回复【资料】领取大量学习资源和免费书籍！&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YUg6EDkZ5ThgRCBaRHic38hicRLZU31vdEialoicFrXTjetMY9QLgnqIcbK636w3z7unway0rIC07YrlISMD9a9ofg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;&lt;span&gt;转发朋友圈是对我最大的支持！&lt;/span&gt;&lt;/figcaption&gt;&lt;figcaption/&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;23&quot; data-width=&quot;100%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAujO0pvtNCLzZCiaWxGBfq2xaPwze1NRLTSQZYbzWNnTJwDwsReHiam91Wojzvw3RLibjicWkLWJjicgsvw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt; 觉得有点东西就点一下“赞和在看”吧！感谢大家的支持了！&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>