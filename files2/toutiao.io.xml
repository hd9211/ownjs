<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c3916f78d449bd583001793f77e55e92</guid>
<title>生产环境Go程序内存泄露，用pprof如何快速定位</title>
<link>https://toutiao.io/k/o31fl5p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄漏可以在整个系统中以多种形式出现，除了在写代码上的疏忽，忘了关闭该关闭的资源外，更多的时候导致系统发生内存泄露原因可能是设计上决策不对、或者业务逻辑上的疏忽没有考虑到一些边界条件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如查数据库时，有个查询条件在一定情况下应用不到，导致程序被迫持有一个超大的结果集，这样持续一段时间，执行相同任务的线程一多，就会造成内存泄露。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 为我们提供了 pprof 工具。掌握之后，可以帮助排查程序的内存泄露问题，当然除了排查内存，它也能排查 CPU 占用过高，线程死锁的这些问题，不过这篇文章我们会聚焦在怎么用 pprof 排查程序的内存泄露问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 开发的系统中，怎么 添加 pprof 进行采样的步骤，在这里我就不再细说了，因为我之前的文章，对 pprof 的安装和使用做了详细的说明，文章链接我放在这里：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然如果你想尝试点更智能的，让程序能自己监控自己，并在出现抖动的时候自己采样，Dump 出导致内存、CPU的问题调用栈信息，可以看一下下面两篇文章里我介绍的方法和实用的类库。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内存泄露该看哪个指标&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pprof&lt;/code&gt;工具集，提供了&lt;code&gt;Go&lt;/code&gt;程序内部多种性能指标的采样能力，我们常会用到的性能采样指标有这些：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;profile：CPU采样&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;heap：堆中活跃对象的内存分配情况的采样&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;goroutine：当前所有goroutine的堆栈信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;allocs: 会采样自程序启动所有对象的内存分配信息（包括已经被GC回收的内存）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;threadcreate：采样导致创建新系统线程的堆栈信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面 heap 和 allocs 是两个与内存相关的指标， allocs 指标会采样自程序启动所有对象的内存分配信息。一般是在想要分析哪些代码能优化提高效率时，查看的指标。针对查看内存泄露问题的分析，使用则的是 heap 指标里的采样信息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Heap&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pprof 的 heap 信息，是对堆中活跃对象的内存分配情况的采样。Go 里边哪些对象会被分配到堆上？一般概况就是，被多个函数引用的对象、全局变量、超过一定体积（32KB）的对象都会被分配到堆上，当然对于 Go 来说还会有其他的一些情况会让对象逃逸到堆上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体哪些变量会被分配到堆上、以及内存逃逸的事儿，就不多说了，想看详细情况的，看下面这两篇文章。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Heap 采样&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要使用 pprof 获取 heap 指标的采样信息，一种情况是使用 &quot;net/http/pprof&quot; 包&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;net/http/pprof&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/debug/pprof/heap&quot;&lt;/span&gt;, pprof.Index)&lt;br/&gt; ......&lt;br/&gt; http.ListenAndServe(&lt;span&gt;&quot;:80&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后通过 HTTP 请求的方式获得&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl -sK -v https://example.com/debug/pprof/profile &amp;gt; heap.out&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种主要的方法是使用&lt;code&gt;runtime.pprof&lt;/code&gt;  提供的方法，把采样信息保存到文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pprof.Lookup(&lt;span&gt;&quot;heap&quot;&lt;/span&gt;).WriteTo(profile_file, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于这两个包的使用方式，以及怎么把信息采样到文件，上面介绍自动采样的文章里有详细的介绍，这里就不再花过多篇幅了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面进入文章的正题， 拿到采样文件后，怎么用 pprof 排查出代码哪里导致了内存泄露。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用 pprof 找出内存泄露的地方&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pprof 在采样 heap 指标的信息时，使用的是 runtime.MemProfile 函数，该函数默认收集每个 512KB 已分配字节的分配信息。我们可以设置让 runtime.MemProfile 收集所有对象的信息，不过这会对程序的性能造成影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们拿到采样文件后，就可以通过 go tool pprof 将信息加载到一个交互模式的控制台中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;gt; go tool pprof heap.out&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入，交互式控制台后，一般会有如下的提示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;File: heap.out&lt;br/&gt;Type: inuse_space&lt;br/&gt;Time: Feb 1, 2022 at 10:11am (CST)&lt;br/&gt;Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的 &lt;code&gt;Type: inuse_space&lt;/code&gt;  指明了文件内采样信息的类型， Type 可能的值有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;inuse_space — 已分配但尚未释放的内存空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;inuse_objects——已分配但尚未释放的对象数量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;alloc_space — 分配的内存总量（已释放的也会统计）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;alloc_objects — 分配的对象总数（无论是否释放）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，介绍一个 pprof 交互式模式下的命令 &lt;strong&gt;top&lt;/strong&gt;，也可以是 &lt;strong&gt;topN&lt;/strong&gt;，比如 top10。这个跟Linux 系统的 top 命令类似，输出 Top N 个最占用内存的函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(pprof) top10&lt;br/&gt;Showing nodes accounting for 134.55MB, 92.16% of 145.99MB total&lt;br/&gt;Dropped 60 nodes (cum &amp;lt;= 0.73MB)&lt;br/&gt;Showing top 10 nodes out of 117&lt;br/&gt;      flat  flat%   sum%        cum   cum%&lt;br/&gt;   60.53MB 41.46% 41.46%    85.68MB 58.69%  github.com/jinzhu/gorm.glob..func2&lt;br/&gt;   18.65MB 12.77% 54.24%    18.65MB 12.77%  regexp.(*Regexp).Split&lt;br/&gt;   16.95MB 11.61% 65.84%    16.95MB 11.61%  github.com/jinzhu/gorm.(*Scope).AddToVars&lt;br/&gt;    8.67MB  5.94% 71.78%   129.05MB 88.39%  example.com/xxservice/dummy.GetLargeData&lt;br/&gt;    7.50MB  5.14% 82.63%     7.50MB  5.14%  reflect.packEface&lt;br/&gt;    6.50MB  4.45% 87.08%     6.50MB  4.45%  fmt.Sprintf&lt;br/&gt;       4MB  2.74% 89.82%        4MB  2.74%  runtime.malg&lt;br/&gt;    1.91MB  1.31% 91.13%     1.91MB  1.31%  strings.Replace&lt;br/&gt;    1.51MB  1.03% 92.16%     1.51MB  1.03%  bytes.makeSlice&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这两个里边，最占用内存的前三是 gorm 库的一个方法，gorm 是个 ORM 库，但是导致它内存泄露的原因应该是后面一个有业务逻辑的代码，dummy.GetLargeData 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 top 指令输出的列表中，我们可以看到两个值，flat 和 cum。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;flat：表示此函数分配、并由该函数持有的内存空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cum：表示由这个函数或它调用堆栈下面的函数分配的内存总量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外 sum % 表示前面几行输出的 flat百分比之和， 比如上面第四行 sum% 列的值是， 71.78%  实际上就是它以及它上面三行输出的 flat% 的总和。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定位到导致内存泄露的函数后，后面要做的优化问题就是，深入函数内部，看哪里使用不当或者有逻辑上的疏忽，比如我开头举得那个查询条件在有些情况下应用不上的例子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然如果你想在函数内部再精确的定位到底是哪段代码导致的内存溢出，也是有办法的，这时候就需要用到 list 指令了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;list&lt;/strong&gt; 指令可以列出函数内部，每一行代码运行时分配的内存（如果分析CPU的采样文件，则会显示CPU使用时间）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(pprof) list dummy.GetLargeData&lt;br/&gt;Total: 814.62MB&lt;br/&gt;ROUTINE ======================== dummy.GetLargeData in /home/xxx/xxx/xxx.go&lt;br/&gt;  814.62MB   814.62MB (flat, cum)   100% of Total&lt;br/&gt;         .          .     20:    }()&lt;br/&gt;         .          .     21:&lt;br/&gt;         .          .     22:    tick := time.Tick(time.Second / 100)&lt;br/&gt;         .          .     23:    var buf []byte&lt;br/&gt;         .          .     24:    for range tick {&lt;br/&gt;  814.62MB   814.62MB     25:        buf = append(buf, make([]byte, 1024*1024)...)&lt;br/&gt;         .          .     26:    }&lt;br/&gt;         .          .     27:}&lt;br/&gt;         .          .     28:&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里把用 pprof 怎么排查程序的内存泄露做了个简单的总结，当然如果你们公司有条件上持续采样，或者我之前文章说的自动采样方案的话，最好还是用上，让机器帮我们做这些事情。&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过不管是用什么办法，最终只能是帮我们定位出来哪里造成了内存泄露，至于要怎么优化解决这个问题，还得具体情况具体分析，如果是一些业务逻辑实现上的问题，那就得跟团队商量一下实现方式，可能还会涉及到产品上的一些改动&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzNTY5MzU2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4pGhLz2xEbRFHnAQon2QLYgbBibCJo1ibJHesLWshPJeRibateRtAqkaf6BgjlbhYiaxHLq6Zu07CRPw/0?wx_fmt=png&quot; data-nickname=&quot;网管叨bi叨&quot; data-alias=&quot;kevin_tech&quot; data-signature=&quot;分享软件开发和系统架构设计基础、Go 语言和Kubernetes。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;觉得有用就点个在看&lt;/span&gt;&lt;span&gt;  👇👇👇&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ea34e50f48a9abbb95c092446b90d10</guid>
<title>浏览器缓存库设计总结（localStorage/indexedDB）</title>
<link>https://toutiao.io/k/a7b1mnn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5539906103286385&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlZkx88icktcNibiaaKBHa3SLWHlj2icm0ticUXficmSdbj1vQeP600iaEOmnlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1278&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU2Mzk1NzkwOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibpVQtdHw0UaW5glBQ3RRqy8rYolxkF0tOaAqTUGW9MXPIGvLUGAJ7jB2JicLxJd6xvvWicThNSWFgg/0?wx_fmt=png&quot; data-nickname=&quot;趣谈前端&quot; data-alias=&quot;beautifulFront&quot; data-signature=&quot;徐小夕【知乎专栏作家】掘金签约作者，定期分享前端工程化，可视化，企业实战项目知识，深度复盘企业中经常遇到的500+技术问题解决方案。【关注趣谈前端，前端路上不迷茫】&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;0&quot; data-index=&quot;0&quot;&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;0&quot; data-index=&quot;0&quot;&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;0&quot; data-index=&quot;0&quot;&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index-1642080622978=&quot;0&quot; data-index-1642080622978=&quot;0&quot;&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index-1646223552202=&quot;0&quot; data-index-1646223552202=&quot;0&quot;&gt;大&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index=&quot;0&quot; data-index=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index=&quot;1&quot; data-index=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index=&quot;1&quot; data-index=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index-1642080622978=&quot;1&quot; data-index-1642080622978=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index-1646223552202=&quot;1&quot; data-index-1646223552202=&quot;1&quot;&gt;厂&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index=&quot;0&quot; data-index=&quot;2&quot;&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index=&quot;2&quot; data-index=&quot;2&quot;&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index=&quot;2&quot; data-index=&quot;2&quot;&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index-1642080622978=&quot;2&quot; data-index-1642080622978=&quot;2&quot;&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index-1646223552202=&quot;2&quot; data-index-1646223552202=&quot;2&quot;&gt;技&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index=&quot;0&quot; data-index=&quot;3&quot;&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index=&quot;3&quot; data-index=&quot;3&quot;&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index=&quot;3&quot; data-index=&quot;3&quot;&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index-1642080622978=&quot;3&quot; data-index-1642080622978=&quot;3&quot;&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index-1646223552202=&quot;3&quot; data-index-1646223552202=&quot;3&quot;&gt;术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;1&quot; data-index=&quot;4&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;4&quot; data-index=&quot;4&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;4&quot; data-index=&quot;4&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1642080622978=&quot;4&quot; data-index-1642080622978=&quot;4&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1646223552202=&quot;4&quot; data-index-1646223552202=&quot;4&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;1&quot; data-index=&quot;5&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;5&quot; data-index=&quot;5&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;5&quot; data-index=&quot;5&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1642080622978=&quot;5&quot; data-index-1642080622978=&quot;5&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1646223552202=&quot;5&quot; data-index-1646223552202=&quot;5&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index=&quot;2&quot; data-index=&quot;6&quot;&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index=&quot;6&quot; data-index=&quot;6&quot;&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index=&quot;6&quot; data-index=&quot;6&quot;&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index-1642080622978=&quot;6&quot; data-index-1642080622978=&quot;6&quot;&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index-1646223552202=&quot;6&quot; data-index-1646223552202=&quot;6&quot;&gt;坚&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index=&quot;2&quot; data-index=&quot;7&quot;&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index=&quot;7&quot; data-index=&quot;7&quot;&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index=&quot;7&quot; data-index=&quot;7&quot;&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index-1642080622978=&quot;7&quot; data-index-1642080622978=&quot;7&quot;&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index-1646223552202=&quot;7&quot; data-index-1646223552202=&quot;7&quot;&gt;持&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;周&quot; data-textnode-index=&quot;2&quot; data-index=&quot;8&quot;&gt;&lt;span data-raw-text=&quot;周&quot; data-textnode-index=&quot;8&quot; data-index=&quot;8&quot;&gt;&lt;span data-raw-text=&quot;周&quot; data-textnode-index=&quot;8&quot; data-index=&quot;8&quot;&gt;&lt;span data-raw-text=&quot;周&quot; data-textnode-index-1642080622978=&quot;8&quot; data-index-1642080622978=&quot;8&quot;&gt;&lt;span data-raw-text=&quot;周&quot; data-textnode-index-1646223552202=&quot;8&quot; data-index-1646223552202=&quot;8&quot;&gt;周&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index=&quot;2&quot; data-index=&quot;9&quot;&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index=&quot;9&quot; data-index=&quot;9&quot;&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index=&quot;9&quot; data-index=&quot;9&quot;&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index-1642080622978=&quot;9&quot; data-index-1642080622978=&quot;9&quot;&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index-1646223552202=&quot;9&quot; data-index-1646223552202=&quot;9&quot;&gt;更&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;3&quot; data-index=&quot;10&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;10&quot; data-index=&quot;10&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;10&quot; data-index=&quot;10&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1642080622978=&quot;10&quot; data-index-1642080622978=&quot;10&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1646223552202=&quot;10&quot; data-index-1646223552202=&quot;10&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;3&quot; data-index=&quot;11&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;11&quot; data-index=&quot;11&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;11&quot; data-index=&quot;11&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1642080622978=&quot;11&quot; data-index-1642080622978=&quot;11&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1646223552202=&quot;11&quot; data-index-1646223552202=&quot;11&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index=&quot;4&quot; data-index=&quot;12&quot;&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index=&quot;12&quot; data-index=&quot;12&quot;&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index=&quot;12&quot; data-index=&quot;12&quot;&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index-1642080622978=&quot;12&quot; data-index-1642080622978=&quot;12&quot;&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index-1646223552202=&quot;12&quot; data-index-1646223552202=&quot;12&quot;&gt;精&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index=&quot;4&quot; data-index=&quot;13&quot;&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index=&quot;13&quot; data-index=&quot;13&quot;&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index=&quot;13&quot; data-index=&quot;13&quot;&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index-1642080622978=&quot;13&quot; data-index-1642080622978=&quot;13&quot;&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index-1646223552202=&quot;13&quot; data-index-1646223552202=&quot;13&quot;&gt;选&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index=&quot;4&quot; data-index=&quot;14&quot;&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index=&quot;14&quot; data-index=&quot;14&quot;&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index=&quot;14&quot; data-index=&quot;14&quot;&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index-1642080622978=&quot;14&quot; data-index-1642080622978=&quot;14&quot;&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index-1646223552202=&quot;14&quot; data-index-1646223552202=&quot;14&quot;&gt;好&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;4&quot; data-index=&quot;15&quot;&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;15&quot; data-index=&quot;15&quot;&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;15&quot; data-index=&quot;15&quot;&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index-1642080622978=&quot;15&quot; data-index-1642080622978=&quot;15&quot;&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index-1646223552202=&quot;15&quot; data-index-1646223552202=&quot;15&quot;&gt;文&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-id=&quot;heading-0&quot;&gt;前言&lt;br/&gt;&lt;/h2&gt;&lt;section&gt;浏览器缓存设计一直是web性能优化中非常重要的一个环节,也是SPA应用盛行的今天不得不考虑的问题.作为一名优秀的前端工程师,为了让我们的应用更流畅,用户体验更好,我们有必要做好浏览器缓存策略.&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;每个Web应用体验都必须快速，对于渐进式 Web 应用更是如此。快速是指在屏幕上获取有意义内容所需的时间，要在不到 5 秒的时间内提供交互式体验。并且，它必须真的很快。很难形容可靠的高性能有多重要。可以这样想: 本机应用的首次加载令人沮丧。已安装的渐进式 Web 应用必须能让用户获得可靠的性能。&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;本文会介绍一些笔者曾经做过的Web性能优化方案以及浏览器缓存的基本流程,并会着重介绍如&lt;span&gt;何利用浏览器缓存API封装适合自己团队的前端缓存库&lt;/span&gt;来极大地提高应用性能,并&lt;span&gt;为公司省钱&lt;/span&gt;.&lt;/p&gt;&lt;h2 data-id=&quot;heading-1&quot;&gt;你将收获&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;熟悉浏览器缓存的基本过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Web性能优化基本方案以及缓存策略为公司带来的价值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于localStorage的缓存方案设计以及库的封装(vuex/redux数据持久化解决方案)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于indexedDB的缓存方案设计以及库的封装&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结合http请求库(axios/umi-request)进行更细粒度的缓存代理层设计&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-id=&quot;heading-2&quot;&gt;正文&lt;/h2&gt;&lt;h3 data-id=&quot;heading-3&quot;&gt;&lt;strong&gt;1.浏览器缓存的基本过程&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;首先要想设计一个优秀的缓存策略,一定要了解浏览器缓存的流程,接下来是笔者总结的一个基本的流程图:&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1280&quot; data-ratio=&quot;1.0322916666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlkmWCzBR7JP1FyMKw1pWoA3wYPoLT2gfwDesqoc9OzbQoO1CibvtTBRw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;960&quot; data-width=&quot;1240&quot;/&gt;&lt;/section&gt;&lt;p&gt;上图展示了一个基本的从浏览器请求到展示资源的过程,我们的缓存策略一部分可以从以上流程出发来做优化.我们都知道页面的缓存状态是由header决定的,下面具体介绍几个概念:&lt;/p&gt;&lt;h4 data-id=&quot;heading-4&quot;&gt;&lt;strong&gt;1. ETag&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;由服务端根据资源内容生成一段 hash 字符串，标识资源的状态,用户第一次请求时服务器会将ETag随着资源一起返回给浏览器, 再次请求时浏览器会将这串字符串传回服务器，验证资源是否已经修改，如果没有修改直接使用缓存.具体流程可以是如下情景:&lt;/p&gt;&lt;section&gt;&lt;img data-height=&quot;624&quot; data-ratio=&quot;0.4875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlj59T40N93PsFia4ZViaW6MZN56O1ByPic7ic0924aeghOetaAW3rWKnCvQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;基于内容的hash往往会比Last-modified更准确.&lt;/section&gt;&lt;h4 data-id=&quot;heading-5&quot;&gt;&lt;strong&gt;2. Last-modified&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;服务器端资源最后的修改时间，必须和 cache-control 共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送 If-Modified-Since 报头，询问 Last-Modified 时间点之后资源是否被修改过。如果没有修改，则返回 304，使用缓存；如果修改过，则再次去服务器请求资源，返回200，重新请求资源。&lt;/p&gt;&lt;h4 data-id=&quot;heading-6&quot;&gt;&lt;strong&gt;3. Expires&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和 Last-modified 结合使用. Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。&lt;/p&gt;&lt;h4 data-id=&quot;heading-7&quot;&gt;&lt;strong&gt;4. Cache-Control的max-age&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;单位为秒,指定设置缓存最大的有效时间。当浏览器向服务器发送请求后，在 max-age 这段时间里浏览器就不会再向服务器发送请求了。以上就是浏览器缓存几个基本的概念,更多知识可以在wiki中学习,这里就不一一介绍了.接下来我们具体看看如何优化web应用以及缓存策略给公司带来的价值.&lt;/p&gt;&lt;h3 data-id=&quot;heading-8&quot;&gt;&lt;strong&gt;2.Web性能优化基本方案以及缓存策略为公司带来的价值&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Web性能优化又是老生常谈的问题了,几年前就一直在探讨这个问题,笔者大致盘点一下性能优化的几个常用的方向:&lt;/p&gt;&lt;h4 data-id=&quot;heading-9&quot;&gt;&lt;strong&gt;1.资源的合并与压缩.&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;比如我们常用的gulp或者webpack这些打包工具, 可以帮我们压缩js,css,html代码,并且将不同页面模块的js,css打包合并到一个文件中,好处就是减少了http请求,降低了资源的体积,使得响应更快.但是仍然存在一个缺陷,就是合并代码会导致一次请求的资源体积会比之前分包的要大,所以会一定程度的影响页面渲染时间,所以这里需要做一个权衡,或者部分采用按需加载的方式.&lt;/p&gt;&lt;h4 data-id=&quot;heading-10&quot;&gt;&lt;strong&gt;2.图片压缩&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;一个网站往往更占资源的是媒体文件,比如图片,视频,音频等,对于图片在发布到线上时最好是需求提前压缩一下, 为了减少图片请求几年前常用的做法是雪碧图,也就是几张图片合成一张大图,通过背景定位来显示不同的图片,不过目前貌似用的不多了,现在更多的采用字体图标,svg,或者webp,所以我们需要根据不同的场景使用不同的策略,当然目前主流的云平台支持对象存储,对媒体资源有不错的优化,有条件的可以采用这种方案,比如七牛云,阿里的对象存储oss.&lt;/p&gt;&lt;h4 data-id=&quot;heading-11&quot;&gt;&lt;strong&gt;3. 合理规划html代码结构&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;这个优化主要是为了提高页面渲染时间,我们都知道css和js的加载一般都是阻塞的, css不会阻塞js和外部脚本的加载,但是会阻塞js的执行, 如果我们把css放到body最底部,那么我们在网络不好的情况下可能会看到先展示html文本然后才渲染页面样式的窘境,如果我们把js脚本放到head内,那么将会阻塞后面内容的渲染,并且造成一些应dom还未生成的导致的错误, 虽然我们可以采用async、defer让script变成异步的,但是如果不同js文件有依赖关系,那么很可能导致意外的错误,所以我们的最佳实践往往是如下这种结构的:&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&amp;lt;html&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;head&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;title&amp;gt;&lt;/span&gt;趣谈前端&lt;span&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;meta &lt;span&gt;charset&lt;/span&gt;=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;meta &lt;span&gt;http-equiv&lt;/span&gt;=&lt;span&gt;&quot;X-UA-Compatible&quot;&lt;/span&gt; &lt;span&gt;content&lt;/span&gt;=&lt;span&gt;&quot;IE=edge&quot;&lt;/span&gt;&amp;gt;&amp;lt;meta &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span&gt;content&lt;/span&gt;=&lt;span&gt;&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;link &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;icon&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;/ico.png&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;image/x-icon&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;link &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;/umi.348436c0.css&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;head&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;body&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;div&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br/&gt;  // html内容&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&amp;lt;script &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;/umi.520.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAACqQM_YXjnwAAAAstQy6ubaLX4KHWvLEZgBPEwqIsTFUobrmDzNPgMItkWr-oUT8q0cKQ9EqDyqU8&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqzmbtSvenORBKaKibb4mozQd7rCrPLe3FZBApyGGmv2eLy1FbLdSKjicsRBxcmVO4w56lZTkUl1Na21NqmiaagmmFiaA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdXx38Y7joEHSBiaOBSbP0TU32f9SwcRbT9leGznPbpnYN8HlrBcJAwt6wqHYUgSljAI&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/Q3auHgzwzM4tvraXsd7pvRicQvE0LyrS5rcniaRbU4vOc6FzBaI3ohqQ/0&quot; data-username=&quot;v2_060000231003b20faec8c4e2811ecaddcd04e831b077c27ce29110552a007ce53c57ffd87d08@finder&quot; data-nickname=&quot;小夕说&quot; data-desc=&quot;使用H5-Dooring轻松搭建荣耀·618电商活动页面#荣耀#618#H5-Dooring@趣谈前端 @小夕说 &quot; data-nonceid=&quot;17605746584529250133&quot; data-type=&quot;video&quot; data-width=&quot;1440&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;h4 data-id=&quot;heading-12&quot;&gt;&lt;strong&gt;4.资源的懒加载和预加载&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;资源的懒加载可以极大的降低页面首屏时间, 我们不仅仅可以对图片采用懒加载, 即只给用户展示可视区域内的图片(虽然图片的懒加载意义更加重大),我们还可以对内容进行懒加载,本质上是一种特殊的分页技巧, jquery时代的lazyload是一个很好的例子,当然现在自己实现一个懒加载方案也非常简单,我们只需要使用getBoundingClientRect这个API配合具体业务使用即可,内容型平台用的比较多,比如我们手机滑到某一区域才加载更多内容,笔者之前做的某头条的广告埋点上报机制就是一个很好的例子.大致思路如下:&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;848&quot; data-ratio=&quot;0.6625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlnRPldmOuMOzefJfUyoE2L6VmOgtSIzn7oN1EdyXibeU4ldcOx2Ouia9w/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;p&gt;预加载就是提前加载图片，当用户需要查看时可直接从本地缓存中渲染.这种机制和懒加载往往相反,预加载为了带来更加流畅的用户体验,比如漫画网站,我们如果不使用预加载,那么用户频繁切换图片时体验是相当差的,所以我们需要提前将图片加载好,牺牲的代价就是用户可能会等待一定的时间来开启&quot;漫画之旅&quot;.&lt;/p&gt;&lt;h4 data-id=&quot;heading-13&quot;&gt;&lt;strong&gt;5.静态资源使用cdn&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;cdn的好处就是可以突破浏览器同域名下一次最大请求并发数量,从而不用&quot;排队&quot;来提高加载速度.我们都是到同一域名下浏览器最多并发请求6条(不同浏览器之间有差异),超过6条的则会等待前面的请求完成才会继续发起,如果使用cdn,一方面它采用离用户最近的资源来响应,另一方面cdn往往和应用处于不同的域下,所以可以不用等待其他域下的并发数限制,从而加速网站响应.&lt;/p&gt;&lt;h4 data-id=&quot;heading-14&quot;&gt;&lt;strong&gt;6.浏览器缓存&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;这一块就是本文上一节中探讨的内容,这里不做过多介绍了,我们还可以采用localStorage, indexedDB来进一步优化缓存,我们下面会详细介绍这一块的内容.&lt;/p&gt;&lt;h4 data-id=&quot;heading-15&quot;&gt;&lt;strong&gt;7.代码层面的优化&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;代码层面往往就是工程师自己对代码掌控的能力,一个优秀的工程师往往会写出代码量更少,性能更好的代码, 比如采用函数式编程来优化代码结构,使用算法来提高js代码执行效率(比如排序,搜索算法),如果想了解更多这方面的知识,可以参考笔者之前写的两篇文章:&lt;/p&gt;&lt;section&gt;所以说在写代码时,请无时无都都提醒自己, 今天的代码跑性能测试了吗?&lt;/section&gt;&lt;h4 data-id=&quot;heading-16&quot;&gt;&lt;strong&gt;8.使用web worker技术并行执行js代码,减少阻塞&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Web Worker的作用就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。&lt;/p&gt;&lt;p&gt;Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是Worker比较耗费资源，一旦使用完毕，就应该关闭。&lt;/p&gt;&lt;p&gt;知道了这些web性能优化知识,我们还要充分理解为什么要做这些优化.有过内容平台开发经验的朋友可能会知道,内容平台比较耗资源的就是媒体资源,比如图片,视频等,我们为了有更好的用户体验往往会将这些资源放到第三方服务平台存储,这样会有更好的请求性能还不用担心服务器压力,但是唯一缺点就是烧钱.每一个请求都是钱,虽然不多, 但是也抗不了百万千万的ip请求量,所以这些做的好的内容平台每年至少在这块花个几百万很正常,尤其是按请求付费.所以优化好了网站, 一方面可以带来更多的用户,更好的用户体验,也可以帮公司省流量, 进而帮老板省钱!(跪求求一个年终奖o(╥﹏╥)o).&lt;/p&gt;&lt;p&gt;接下里的内容,就教大家如何省钱.&lt;/p&gt;&lt;h3 data-id=&quot;heading-17&quot;&gt;&lt;strong&gt;3.基于localStorage的缓存方案设计以及库的封装(vuex/redux数据持久化解决方案)&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;&lt;section&gt;localStorage属性允许你访问一个Document 源（origin）的对象 Storage；存储的数据将保存在浏览器会话中。localStorage 类似 sessionStorage，但其区别在于：存储在 localStorage 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 sessionStorage 的数据会被清除 。&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;关于localStorage的文章也写了很多,使用方法也很简单, 这里就不做过多介绍了,但是有没有考虑自己封装一个localStorage呢? 大多数人可能会觉得很多余,因为localStorage提供的api已经够简单了,没必要封装,但是你有没有考虑过,localStorage是持久化缓存,不支持过期时间,所以有些业务场景下原生localStorage是满足不了的,所以这种情况下饿哦们需要自己实现具有过期时间的localStorage库, 关于如何实现该功能,笔者之前也写过一篇文章,有详细的介绍,并且可以让localStorage使用起来更强大,感兴趣的可以学习研究一下:&lt;/p&gt;&lt;section&gt;笔者已经将库发布到npm上了,可以通过如下方式安装使用:&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt; dao &lt;span&gt;from&lt;/span&gt; @alex_xu/dao&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;或者在html标签中直接使用umd文件,github地址: &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247483764&amp;amp;idx=1&amp;amp;sn=736e1e642056fa08b70d31c15e9315a9&amp;amp;chksm=fc53188fcb249199c2a6ece5cf4483c5293d5df119d332dd76d0abf402a4e4e6110c24c6f720&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基于localStorage封装的可以设置过期时间的库&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;基于localStorage封装的可以设置过期时间的库&lt;/a&gt;&lt;/p&gt;&lt;p&gt;我们常用的vue里的状态管理库vuex,因为状态都是存在内存中的,那么如果要做web离线应用,或者web游戏,我们往往需要考虑持久化缓存, 那么我们也可以借助localStorage来实现状态的持久化功能,但是请记住,localStorage的存储空间在5-10M,如果有更大的需求,可以采用接下来介绍的indexedDB来实现.&lt;/p&gt;&lt;h3 data-id=&quot;heading-18&quot;&gt;&lt;strong&gt;4.基于indexedDB的缓存方案设计以及库的封装&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;IndexedDB主要用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB是一个事务型数据库系统，类似于基于SQL的RDBMS。然而，不像RDBMS使用固定列表，IndexedDB是一个基于JavaScript的面向对象的数据库。它允许我们存储和检索用键索引的对象；可以存储结构化克隆算法支持的任何对象。我们只需要指定数据库模式，打开与数据库的连接，然后检索和更新一系列事务。&lt;/p&gt;&lt;p&gt;我们刚刚接触indexedDB时往往觉得它很难懂, 我们首先需要使用open方法打开数据库,因为indexedDB大部分方法都是异步的,所以我们很难管理, 包括创建事务,创建表(一组数据的对象存储区), 添加对象存储等,这里笔者不会介绍如何使用indexedDB的具体使用方法,而是叫大家如何简化操作indexedDB的使用流程,封装成一个简单好用的缓存库.以下的封装都是基于promise,这样使用起来更优雅.以下是封装的思路:&lt;/p&gt;&lt;section&gt;&lt;img data-height=&quot;610&quot; data-ratio=&quot;0.5820610687022901&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlFhglNCIaZhdwHLW8gCEW0FsPrO4OSv5wEpTJFYp7ht70nT31fCoWVQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1048&quot; data-width=&quot;1048&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们工作中处理的indexedDB无非如上几个操作,所以我们需要将其从indexedDB底层API中抽离出来这几个api.具体实现如下:&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;declare global {&lt;br/&gt;  interface Window { xdb: any; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; xdb = (() =&amp;gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; instance:any = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; dbName = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; DB = &lt;span&gt;function&lt;/span&gt;(args:any) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; cfg = {&lt;br/&gt;      name: args.name || &lt;span&gt;&#x27;test&#x27;&lt;/span&gt;,&lt;br/&gt;      version: args.version || &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;      onSuccess(e:Event) {&lt;br/&gt;        args.onSuccess &amp;amp;&amp;amp; args.onSuccess(e)&lt;br/&gt;      },&lt;br/&gt;      onUpdate(e:Event) {&lt;br/&gt;        args.onUpdate &amp;amp;&amp;amp; args.onUpdate(e)&lt;br/&gt;      },&lt;br/&gt;      onError(e:Event) {&lt;br/&gt;        args.onError &amp;amp;&amp;amp; args.onError(e)&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.dbName = args.name&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.request = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.db = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 打开/创建数据库&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.init = &lt;span&gt;function&lt;/span&gt;() {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;window&lt;/span&gt;.indexedDB) {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;你的浏览器不支持该版本&#x27;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.request = &lt;span&gt;window&lt;/span&gt;.indexedDB.open(&lt;span&gt;this&lt;/span&gt;.dbName, cfg.version)&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.request.onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;        cfg.onError(event)&lt;br/&gt;      }&lt;br/&gt;      &lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.request.onsuccess = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;        _this.db = _this.request.result&lt;br/&gt;        cfg.onSuccess(event)&lt;br/&gt;      }&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.request.onupgradeneeded = &lt;span&gt;function&lt;/span&gt; (event:any) {&lt;br/&gt;        _this.db = event.target.result&lt;br/&gt;        cfg.onUpdate(event)&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.init()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 添加表&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.createTable = &lt;span&gt;function&lt;/span&gt;(name:string, opts:any = {}) {&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; objectStore:any&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.db.objectStoreNames.contains(name)) {&lt;br/&gt;        opts = {&lt;br/&gt;          keyPath: opts.keyPath,&lt;br/&gt;          indexs: &lt;span&gt;Array&lt;/span&gt;.isArray(opts.indexs) ? opts.indexs : []&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// indexs = [{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//   indexName: &#x27;name&#x27;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//   key: &#x27;name&#x27;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//   unique: true&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// }]&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        objectStore = &lt;span&gt;this&lt;/span&gt;.db.createObjectStore(name, { keyPath: opts.keyPath })&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(opts.length) {&lt;br/&gt;          opts.indexs.forEach((item:any) =&amp;gt; {&lt;br/&gt;            objectStore.createIndex(item.indexName, item.key, { unique: item.unique })&lt;br/&gt;          })&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; objectStore&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 访问表中数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.get = &lt;span&gt;function&lt;/span&gt;(tableName:string, keyPathVal:any) {&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; transaction = &lt;span&gt;this&lt;/span&gt;.db.transaction([tableName])&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; objectStore = transaction.objectStore(tableName)&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; request = objectStore.get(keyPathVal)&lt;br/&gt;  &lt;br/&gt;        request.onerror = &lt;span&gt;function&lt;/span&gt;(event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;事务失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;  &lt;br/&gt;        request.onsuccess = &lt;span&gt;function&lt;/span&gt;(event:Event) {&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (request.result) {&lt;br/&gt;            &lt;span&gt;// 判断缓存是否过期&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(request.result.ex &amp;lt; &lt;span&gt;Date&lt;/span&gt;.now()) {&lt;br/&gt;              resolve({status: &lt;span&gt;200&lt;/span&gt;, data: &lt;span&gt;null&lt;/span&gt;})&lt;br/&gt;              _this.del(tableName, keyPathVal)&lt;br/&gt;            }&lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;              resolve({status: &lt;span&gt;200&lt;/span&gt;, data: request.result})&lt;br/&gt;            }&lt;br/&gt;          } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            resolve({status: &lt;span&gt;200&lt;/span&gt;, data: &lt;span&gt;null&lt;/span&gt;})&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 遍历访问表中所有数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.getAll = &lt;span&gt;function&lt;/span&gt;(tableName:string) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((reslove, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; objectStore = &lt;span&gt;this&lt;/span&gt;.db.transaction(tableName).objectStore(tableName)&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; result:any = []&lt;br/&gt;        objectStore.openCursor().onsuccess = &lt;span&gt;function&lt;/span&gt; (event:any) {&lt;br/&gt;          &lt;span&gt;let&lt;/span&gt; cursor = event.target.result&lt;br/&gt;  &lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (cursor) {&lt;br/&gt;            result.push(cursor.value)&lt;br/&gt;            cursor.continue()&lt;br/&gt;          } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            reslove({status: &lt;span&gt;200&lt;/span&gt;, data: result})&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        objectStore.openCursor().onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;事务失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 从表中添加一条数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.add = &lt;span&gt;function&lt;/span&gt;(tableName:string, row:any, ex:number) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((reslove, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; request = &lt;span&gt;this&lt;/span&gt;.db.transaction([tableName], &lt;span&gt;&#x27;readwrite&#x27;&lt;/span&gt;)&lt;br/&gt;          .objectStore(tableName)&lt;br/&gt;          .add(&lt;span&gt;Object&lt;/span&gt;.assign(row, ex ? { ex: &lt;span&gt;Date&lt;/span&gt;.now() + ex } : {}))&lt;br/&gt;&lt;br/&gt;        request.onsuccess = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reslove({status: &lt;span&gt;200&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据写入成功&#x27;&lt;/span&gt;})&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        request.onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据写入失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;      &lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 更新表中的数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.update = &lt;span&gt;function&lt;/span&gt;(tableName:string, row:any) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((reslove, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; request = &lt;span&gt;this&lt;/span&gt;.db.transaction([tableName], &lt;span&gt;&#x27;readwrite&#x27;&lt;/span&gt;)&lt;br/&gt;          .objectStore(tableName)&lt;br/&gt;          .put(row)&lt;br/&gt;&lt;br/&gt;        request.onsuccess = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reslove({status: &lt;span&gt;200&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据更新成功&#x27;&lt;/span&gt;})&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        request.onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据更新失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 删除某条数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.del = &lt;span&gt;function&lt;/span&gt;(tableName:string, keyPathVal:any) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; request = &lt;span&gt;this&lt;/span&gt;.db.transaction([tableName], &lt;span&gt;&#x27;readwrite&#x27;&lt;/span&gt;)&lt;br/&gt;          .objectStore(tableName)&lt;br/&gt;          .delete(keyPathVal)&lt;br/&gt;&lt;br/&gt;        request.onsuccess = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          resolve({status: &lt;span&gt;200&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据删除成功&#x27;&lt;/span&gt;})&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        request.onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据删除失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 清空表数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.clear = &lt;span&gt;function&lt;/span&gt;(tableName:string) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; request = &lt;span&gt;this&lt;/span&gt;.db.transaction([tableName], &lt;span&gt;&#x27;readwrite&#x27;&lt;/span&gt;)&lt;br/&gt;          .objectStore(tableName)&lt;br/&gt;          .clear()&lt;br/&gt;&lt;br/&gt;        request.onsuccess = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          resolve({status: &lt;span&gt;200&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据表已清空&#x27;&lt;/span&gt;})&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        request.onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据表清空失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    loadDB(args:any) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(instance === &lt;span&gt;undefined&lt;/span&gt; || dbName !== args.name) {&lt;br/&gt;        instance = &lt;span&gt;new&lt;/span&gt; (DB &lt;span&gt;as&lt;/span&gt; any)(args)&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; instance&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;})()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;window&lt;/span&gt;.xdb = xdb&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; xdb&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;这样就实现了一个基于promise的且支持过期时间的indexedDB库,实现过期时间也非常简单,就是在创建表的行时在底层添加一个过期时间字段,用户需要设置改行过期时间时, 只需要添加过期时间即可,当我们再次获取表格数据时只需要检测改行是否过期,如果过期就清除重新设置即可.&lt;/p&gt;&lt;h3 data-id=&quot;heading-19&quot;&gt;&lt;strong&gt;5.结合http请求库(axios/umi-request)进行更细粒度的缓存代理层设计&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;为了更大程度的发挥indexedDB存储空间的优势,并且进一步优化缓存策略,我们来可以做缓存拦截.我们都知道,一个应用的有些请求不需要频繁获取,比如省市级联数据, 区位地图数据,或者一些不需要经常更新的数据, 如果我们可以做到只请求一次, 下次请求直接使用内存数据,并设置一个过期时间, 到过期时间之后会重新请求数据, 那么是不是对请求又可以做一次优化?我们第一印象可能会写出这样的代码:&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt;(!store.get(&lt;span&gt;&#x27;xx&#x27;&lt;/span&gt;)){&lt;br/&gt;   http.get(&lt;span&gt;&#x27;xxx&#x27;&lt;/span&gt;).then(res =&amp;gt; {&lt;br/&gt;    res &amp;amp;&amp;amp; store.set(&lt;span&gt;&#x27;xx&#x27;&lt;/span&gt;, res, &lt;span&gt;12&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt;  })&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;这样虽然可以实现功能,但是每一个业务都要写类似的代码, 往往很难受, 所以作为一个有追求的程序员,我们可以在请求上下功夫.我们都有过axios或者fetch库的使用经验,我们也接触过请求/响应拦截器的使用, 那么我们能不能考虑对请求本身也做一层拦截呢?我想实现的效果是我们在业务里还是正常的像之前一样使用请求,比如:&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;req.get(&lt;span&gt;&#x27;/getName?type=xxx&#x27;&lt;/span&gt;).then(res)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;然而内部已经帮我们做好请求缓存了,我们的req实际上不是axios或者fetch的实例,而是一层代理.&lt;/p&gt;&lt;section&gt;&lt;img data-height=&quot;1280&quot; data-ratio=&quot;1.16875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlib9a6lsCpfjhjEkaqMuSvneqH0lBe9JWMFxbGas3oTA6MURKodnB4sw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;960&quot; data-width=&quot;1094&quot;/&gt;&lt;/section&gt;&lt;p&gt;通过这种方式我们对原来的请求方式可以不做任何改变, 完全采用代理机制在请求拦截器中和响应拦截器中布局我们的代理即可,关键点就是存到数据库中的内容要和服务器响应的内容结构一致.&lt;/p&gt;&lt;p&gt;以上方式我们可以对所有的get请求做缓存,如果我们只想对部分请求做缓存,其实利用以上机制实现也很简单,我们只需要设置缓存白名单, 在请求拦截器中判断如果在白名单内才走缓存逻辑即可.&lt;/p&gt;&lt;p&gt;这样,我们再次进行某项数据的搜索时,可以不走任何http请求,直接从indexedDB中获取,这样可以为公司节省大量的流量.&lt;/p&gt;&lt;p&gt;关于indexedDB的库的封装,我也发布到npm和github上了,大家可以直接使用或者进行二次开发.&lt;/p&gt;&lt;h2 data-id=&quot;heading-20&quot;&gt;最后&lt;/h2&gt;&lt;section&gt;如果想学习更多&lt;span&gt;H5游戏&lt;/span&gt;, &lt;span&gt;webpack&lt;/span&gt;，&lt;span&gt;node&lt;/span&gt;，&lt;span&gt;gulp&lt;/span&gt;，&lt;span&gt;css3&lt;/span&gt;，&lt;span&gt;javascript&lt;/span&gt;，&lt;span&gt;nodeJS&lt;/span&gt;，&lt;span&gt;canvas数据可视化&lt;/span&gt;等前端知识和实战，欢迎在公号《趣谈前端》加入我们的技术群一起学习讨论，共同探索前端的边界.&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❤️ 谢谢支持&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上便是本次分享的全部内容，希望对你有所帮助^_^&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;喜欢的话别忘了 &lt;strong&gt;分享、点赞、收藏&lt;/strong&gt; 三连哦~。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎关注公众号 &lt;strong&gt;趣谈前端&lt;/strong&gt; 收货大厂一手好文章~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94385&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94715&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img border=&quot;0&quot; class=&quot;__bg_gif rich_pages wxw-img&quot; data-ratio=&quot;0.08658008658008658&quot; data-type=&quot;gif&quot; data-w=&quot;462&quot; data-width=&quot;100%&quot; height=&quot;&quot; title=&quot;&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/usyTZ86MDicgqjLq0USF6icibfWiaLSV8bz17cBjvXylU7dz9mIMP7lUF50OE2gFrlZDQlIyWvGcUiaprq92fq8tgXg/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247489810&amp;amp;idx=1&amp;amp;sn=2663938569c4d361acae076bce9a9bf5&amp;amp;chksm=fc5300e9cb2489ff48db614f03093d71a81669bc6e0ccdf88b10af4a899b86ce59c6c95198b5&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;从零搭建全栈可视化大屏制作平台V6.Dooring&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247489467&amp;amp;idx=1&amp;amp;sn=be4b2a7f92f1c62e66432158212aee78&amp;amp;chksm=fc530e40cb248756193998c50b2e5e75de96dbde98170f871faa7e6ea043a50f87b7fc4468cf&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;从零设计可视化大屏搭建引擎&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247487877&amp;amp;idx=2&amp;amp;sn=770ff16d69d3e7ac2bbcd78e97ab8f32&amp;amp;chksm=fc53087ecb2481685451a50e892fa889781788ca16a4ce689ec7f7fff1ae99c91ac8b82a160d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;Dooring可视化搭建平台数据源设计剖析&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247487950&amp;amp;idx=1&amp;amp;sn=e674a2f9379b9c9b8a149498a50c17f8&amp;amp;chksm=fc530835cb2481233acc7ac2c856b30c7698dd9d2aec1514b5c2fa4165bc2728f7b261c4938f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;可视化搭建的一些思考和实践&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247486910&amp;amp;idx=2&amp;amp;sn=7ce865dd8a8f6769439f0e8eebb72212&amp;amp;chksm=fc531445cb249d534a7d8a362ad40d26bc90f2d2e867385768ee19575e32826fcbe419fcbe0b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;基于Koa + React + TS从零开发全栈文档编辑器(进阶实战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点个&lt;span data-mid=&quot;&quot;&gt;在看&lt;/span&gt;你最好看&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1211ad88c0c775475bda7ec787b864ea</guid>
<title>HTTP/3 发布！</title>
<link>https://toutiao.io/k/x84l82k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;↓&lt;/span&gt;&lt;span&gt;推荐关注↓&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5NjUxMTM2MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/mshqAkialV7FvgHwjwFbEbT0nNZU2AVPsmAuuZfXfp0Yc8H3FNkbiaKZYUJNichcJ3lZj4HiceOTXAeTnPHJrLFklA/0?wx_fmt=png&quot; data-nickname=&quot;大前端技术之路&quot; data-alias=&quot;frontroute&quot; data-signature=&quot;分享Web前端，Node.js、React Native等大前端技术栈精选&quot; data-from=&quot;2&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;6 月 6 日，IETF QUIC（&lt;/span&gt;&lt;span&gt;Internet Engineering Task Force，互联网工程任务组，简称 IETF&lt;/span&gt;&lt;span&gt;）、比利时的 HTTP 工作组&lt;/span&gt;&lt;span&gt;成员 Robin Mark 在 Twitter 上宣布“历时 5 年，HTTP/3 终于被标准化为 RFC 9114。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将与 RFC 9204（QPACK header 压缩）和 RFC 9218 （可扩展的优先级）一起开启 Web 的新篇章！”，这意味着该协议已经进入了稳定的状态，而 HTTP/3 是 HTTP 超文本传输协议的第三个主要版本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8202054794520548&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSgprnC1BwEEaYg45CHlxnLwBlmhJ0lrUYGSuMr7bvTvsP1uDelaVUda20ScqEZkJaPQiaahibfXnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;584&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时 HTTP/2 也更新为新的 RFC 9113 标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.60625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuhSgprnC1BwEEaYg45CHlxnibtmpM616Vvud4KwtmLiboy0EeVnr8icy4ogiagchIUg4gRRR9CbKYb2Lg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;基于 QUIC 的 HTTP/3&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;据官方介绍，HTTP/3 是基于 QUIC 的，那么，QUIC 究竟是什么？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;正如 IEFT 在简介中写道：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;QUIC 传输协议具有 HTTP 传输所需的几个特性，例如多路复用、流量控制、每个流的流控制和低延迟连接建立。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.13533834586466165&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSgprnC1BwEEaYg45CHlxneRjgRESLNIQLM85aU0apP78eNNTTP1mGia43eUoPUNIibstdS5TiaXhPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1862&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;103675&quot; msttexthash=&quot;10562548997&quot;&gt;&lt;span&gt;简单来看，QUIC 是一个通用的传输层网络协议，是由 Google 在 2012 年实现并部署，最后在 2013 年向公众公开发布。之所以开发 QUIC，Google 的初衷是解决传输控制协议（TCP）需要几次来回才能建立连接并开始传输数据的事实。&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;103675&quot; msttexthash=&quot;10562548997&quot;&gt;&lt;span&gt;原有的协议产生的连接和传输延迟时间较长，带来了较差的用户体验。QUIC 改为使用用户数据报协议 （UDP） 来传输流量。UDP 减少了客户端和服务器之间的往返次数，因此可以加快传输速度，这一点在移动网络上非常重要。&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;103675&quot; msttexthash=&quot;10562548997&quot;&gt;&lt;span&gt;当前，业界已经陆续有不少公司用上了 QUIC 协议。其中，谷歌就非常喜欢 QUIC，以至于在 2020 年其将 QUIC 应用到了 C&lt;/span&gt;&lt;span&gt;hrome 浏览器中，并在 Google 服务器所有的连接中，有一半以上使用了 QUIC。&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;103675&quot; msttexthash=&quot;10562548997&quot;&gt;&lt;span&gt;此外，Cloudflare 在 2018 年也将 QUIC 作为网络协议选项。微软也非常喜欢 QUIC，它不仅创建了自己的版本，还将其开源出来（&lt;/span&gt;&lt;span&gt;https://techcommunity.microsoft.com/t5/networking-blog/msquic-is-open-source/ba-p/1345441&lt;/span&gt;&lt;span&gt;）。NGINX 增加了 HTTP/3 支持。&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;116402&quot; msttexthash=&quot;236443519&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p msthash=&quot;116402&quot; msttexthash=&quot;236443519&quot;&gt;&lt;strong&gt;为什么放着大流行的 HTTP/2 不用，而选择 HTTP/3？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然 HTTP/3 作为新一代超文本传输协议，要比第二代更为先进一些，但 HTTP/2 在 2015 年才被标准化，且据 Cloudflare 数据显示，HTTP/2 仍然是应用最为广泛的 HTTP 版本，排在第二的 HTTP/3 流行度要比 HTTP/2 差了很多。&lt;/span&gt;&lt;span&gt;那么，IETF 为什么如此紧急地推出了 HTTP/3 来代替？&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;116532&quot; msttexthash=&quot;753875291&quot;&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5360730593607306&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSgprnC1BwEEaYg45CHlxn3GXvTNQQXME5zBrpwf1ibbAwOn0S0oAQk5IF7qAicMjsMxGibav3lVkHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2190&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;116532&quot; msttexthash=&quot;753875291&quot;&gt;&lt;span&gt;对此，HTTP 工作组成员 Robin Mark 专门写了一篇稿件解释道，「一开始我们并不需要一个新的 HTTP 版本，而是要让底层传输控制协议（TCP）实现升级」。&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;116532&quot; msttexthash=&quot;753875291&quot;&gt;&lt;span&gt;其表示，几十年来，TCP 作为网络基石，是互联网上使用和部署最广泛的协议之一，但是在互联网早期就已经出现的 TCP 并没有真正考虑到最大效率的问题。相较之下，新传输协议 QUIC 便被众人赋予期望。&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;116532&quot; msttexthash=&quot;753875291&quot;&gt;&lt;span&gt;然而，如果把 QUIC 直接运行在 HTTP/2 上有一定难度，因为其在很多特性上与 TCP 有着很大的不同。于是，HTTP 工作组便在几个关键领域进行了调整，使其与 QUIC 兼容。这个调整后的版本最终被命名为 HTTP / 3，之所以如此命名，主要原因是出于营销和方便用户更加清晰地识别出来区别。&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;116532&quot; msttexthash=&quot;753875291&quot;&gt;&lt;span&gt;简单来看，HTTP/3 本身就是对 HTTP/2 相对较小的改编，以使其与新的 QUIC 协议兼容。因此，&lt;/span&gt;&lt;span&gt;HTTP/1.1 和 HTTP/2 之间的差异要比 HTTP/2 和 HTTP/3 之间的差异要大得多。&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;116532&quot; msttexthash=&quot;753875291&quot;&gt;&lt;span&gt;这样一来，HTTP/3 也被很多人诟病，如 Apache 推迟了将协议添加到其 Web 服务器，它认为自己的 HTTPD 做得很好。也有部分隐私倡导者担心 QUIC，他们发现 QUIC 承诺的速度提升难以捉摸。&lt;/span&gt;&lt;/p&gt;&lt;p msthash=&quot;116532&quot; msttexthash=&quot;753875291&quot;&gt;&lt;span&gt;不过，无论如何，HTTP/3 进入标准化，也是 HTTP 发展历程中重要的一个里程碑事件。如果你对 HTTP/3 也感兴趣，不妨通过官方介绍了解更多内容：https://www.rfc-editor.org/info/rfc9114&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;https://www.theregister.com/2022/06/07/http3_rfc_9114_published/&lt;/span&gt;&lt;/section&gt;&lt;p msthash=&quot;116532&quot; msttexthash=&quot;753875291&quot;&gt;&lt;span&gt;https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;来源：CSDN&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;- EOF&lt;/span&gt;&lt;span&gt; -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNjMxMTA5Mw==&amp;amp;mid=2651349666&amp;amp;idx=1&amp;amp;sn=14982bc66c071d499de84a4e830248e5&amp;amp;chksm=80f39f78b784166ecd920b804352c82f66bd996eb4079c49f7a23ef9d6af79ad8da2fbb4cffe&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Web 3.0，「激发创造」的时代&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Web 3.0，「激发创造」的时代&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNjMxMTA5Mw==&amp;amp;mid=2651349849&amp;amp;idx=1&amp;amp;sn=317171ff843604ac47ef3a3c94dc8230&amp;amp;chksm=80f39e83b78417957ead26b95fd89fb7aca39f78151236f4305c86267db1f0374e77ed710adf&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;PHP 导入大量 CSV 数据&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;PHP 导入大量 CSV 数据&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNjMxMTA5Mw==&amp;amp;mid=2651349792&amp;amp;idx=2&amp;amp;sn=9abb92e9942e6f8ede5b384539012df5&amp;amp;chksm=80f39efab78417ec16be3c7754bb6ff6f774b12052a10f7ac10e20910db108cc37f5bc1beeb9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;PHP 面试经常被问到的知识点汇总，对你非常有用&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;PHP 面试经常被问到的知识点汇总，对你非常有用&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;↓推荐关注↓&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5NjUxMTM2MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/mshqAkialV7FvgHwjwFbEbT0nNZU2AVPsmAuuZfXfp0Yc8H3FNkbiaKZYUJNichcJ3lZj4HiceOTXAeTnPHJrLFklA/0?wx_fmt=png&quot; data-nickname=&quot;大前端技术之路&quot; data-alias=&quot;frontroute&quot; data-signature=&quot;分享Web前端，Node.js、React Native等大前端技术栈精选&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;「大前端技术之路」分享 Web前端，Node.js、React Native等大前端技术栈精选&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f3be15364d150c114931cb42606a3de2</guid>
<title>5 分钟，教你用 Docker 部署一个 Python 应用！</title>
<link>https://toutiao.io/k/7kq3vgz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;568&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;379&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.68828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/atOH362BoysEIibPicac4WeENGOVvlVYaGWeZE5ED3icME3dGM0ibCXwWuQoIBiaV2TBYLNhbKPicvpEAuA6qhaf8Mag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用传统物理机或云服务器上部署项目都会存在一些痛点&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：&lt;span&gt;项目&lt;/span&gt;&lt;span&gt;部署速度慢、&lt;/span&gt;&lt;span&gt;资源浪费、&lt;/span&gt;&lt;span&gt;迁移&lt;/span&gt;&lt;span&gt;难且扩展低&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而使用 Docker 部署项目的优势包含：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;高效利用系统资源&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;服务启动更快&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;环境一致，迁移更加方便&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章将介绍 Docker 部署一个 Python 项目的常规流程&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. Dockerfile 描述文件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Dockerfile 是一个放置在项目根目录下的描述文件，可以利用 Docker 命令基于该文件构建一个镜像&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的指令包含：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 实战一下&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Docker 部署应用的常规流程是：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发项目并本地测试通过&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编写 Dockerfile 放置到项目根目录&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打包镜像文件&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行镜像容器&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了演示方便，这里以一个简单的 Flask 项目为例进行讲解&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2-1  项目开发&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt; Flask&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 安装依赖&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# pip3 install -U flask&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;app = Flask(__name__)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@app.route(&#x27;/&#x27;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;测试容器部署!&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&#x27;__main__&#x27;&lt;/span&gt;:&lt;br/&gt;    app.run(host=&lt;span&gt;&#x27;0.0.0.0&#x27;&lt;/span&gt;, port=&lt;span&gt;8888&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 浏览器访问测试&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# http://127.0.0.1:8888/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目开发完成，并在本地测试通过后就可以编写 Dockerfile 文件了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2-2  编写 Dockerfile&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目根目录下，创建一个 Dockerfile 文件，使用上面的指令编写描述脚本&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，&lt;span&gt;这里使用「 EXPOSE 」指令暴露的端口号与入口文件定义的端口号保持一致&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# Dockerfile&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;FROM&lt;/span&gt; centos:&lt;span&gt;7&lt;/span&gt;.&lt;span&gt;9&lt;/span&gt;.&lt;span&gt;2009&lt;/span&gt;&lt;br/&gt;RUN yum makecache fast;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt; yum install python3-devel python3-pip -y&lt;br/&gt;RUN pip3 install -i https://pypi.douban.com/simple flask&lt;br/&gt;COPY main.py /opt&lt;br/&gt;WORKDIR /opt&lt;br/&gt;EXPOSE &lt;span&gt;8888&lt;/span&gt;&lt;br/&gt;CMD [&lt;span&gt;&quot;python3&quot;&lt;/span&gt;,&lt;span&gt;&quot;main.py&quot;&lt;/span&gt;]&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2-3  构建镜像&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 在当前文件夹下，根据Dockerfile文件构建一个镜像&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 镜像名称：xag/my_flask_web&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# --no-cache：不使用旧的缓存进行镜像构建&lt;/span&gt;&lt;br/&gt;&lt;span&gt;docker&lt;/span&gt; build --&lt;span&gt;no&lt;/span&gt;-cache -t &lt;span&gt;&quot;xag/my_flask_web&quot;&lt;/span&gt; .&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2-4  运行镜像容器&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 docker run 命令基于镜像运行一个容器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;-d：代表容器在后台运行，不是基于前台运行&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;--name：用于执行容器的别名&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;-p：用于配置宿主机与容器的端口映射&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# -d：后台运行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 宿主机（9999）映射容器内的8888（上面Dockerfile已经暴露了8888端口）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;docker&lt;/span&gt; run -d --name flask_web -p &lt;span&gt;9999&lt;/span&gt;:&lt;span&gt;8888&lt;/span&gt; xag/my_flask_web  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2-5  测试一下&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后在浏览器中，通过宿主机暴露的端口号 9999 访问项目了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问地址：&lt;span&gt;http://127.0.0.1:9999/&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章中以一个简单的 Web 项目阐述了利用 Docker 部署项目的常规流程&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，Dockerfile 非常的灵活，它还支持 ARG/ENV 设置环境变量，VOlUME 指令挂载目录，&lt;span&gt;ENTRYPOINT 配置启动程序和参数&lt;/span&gt;&lt;span&gt;等，这部分内容大家可以根据&lt;/span&gt;&lt;span&gt;官网介绍自行进行扩展&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://docs.docker.com/engine/reference/builder/&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你觉得文章还不错，请大家 点赞、分享、留言 下，因为这将是我持续输出更多优质文章的最强动力！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-style-type=&quot;5&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;746064&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1OTI0NjI1NQ==&amp;amp;mid=2247491156&amp;amp;idx=1&amp;amp;sn=6e6a38486bded5fe8c6f5ae22a14eb82&amp;amp;chksm=fc1b6094cb6ce982a912b5c0e8b50d8ca627b5616980561e2a01a359f31b35dd70a79eeb6702&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;自动化篇 | 实现自动化抢茅台超详细过程！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;自动化篇 | 实现自动化抢茅台超详细过程！&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1OTI0NjI1NQ==&amp;amp;mid=2247491221&amp;amp;idx=1&amp;amp;sn=1364ef860cbbfbaeed041298073b6956&amp;amp;chksm=fc1b6055cb6ce943f18e93397e5ccbfc087b20849e035f26a23d8e422e810f065e3c652f1797&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;5 分钟，教你从零快速编写一个油猴脚本！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;5 分钟，教你从零快速编写一个油猴脚本！&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1OTI0NjI1NQ==&amp;amp;mid=2247491083&amp;amp;idx=1&amp;amp;sn=9af0e1f2f6331661a98c985cbfb2ae65&amp;amp;chksm=fc1b60cbcb6ce9dd102fb4e1ecb2635adf78daa60b7a15f5d95eac76909805811bd960c2c6fe&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;如何使用 Python 实现彩票自由（大乐透）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;如何使用 Python 实现彩票自由（大乐透）&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1OTI0NjI1NQ==&amp;amp;mid=2247491097&amp;amp;idx=1&amp;amp;sn=7812afbe26f6895cd94cb3ee7aea4079&amp;amp;chksm=fc1b60d9cb6ce9cfe6b68a99d6082d46de74c9dee5a8ab6bcd0090a2c737e3e99e7c6ac948d7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;如何使用 Python 实现彩票自由（双色球）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;如何使用 Python 实现彩票自由（双色球）&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89428&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;END&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1OTI0NjI1NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/atOH362BoyuUe1icelWmbMyTCRwoFPScmosYQheSZ9wsmr61Bfr2rvNav9j9QpDnUulNpCotEiaAoLzSAm4jZTjA/0?wx_fmt=png&quot; data-nickname=&quot;AirPython&quot; data-alias=&quot;AirPython&quot; data-signature=&quot;专注于Python爬虫/自动化/Web原创技术干货！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93451&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;92877&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;好文和朋友一起看~&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fb47eaab2595030897ccd82897082ac1</guid>
<title>顶级独立游戏开发者谈独立游戏在当前环境下的生存机会</title>
<link>https://toutiao.io/k/oekntvw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;本文原作者：James Brightman&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果上礼拜你有在IOS的APP Store上稍微瞄一眼，你会注意到里面有个醒目的标题“聚焦独立游戏”，除此之外还有99美分下载“精品独立游戏”的活动。终于在今天，独立游戏开发群体出品的游戏有了专属页面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在想要在手游市场中脱颖而出是越发地艰难了，真的，很多平台上的数字生态系统都早已人满为患了。近来苹果、谷歌和任天堂先后都为独具创意的游戏做了类型策划推荐栏。最神奇的不是App Store中为独立游戏做的永久界面，而是一个2人游戏开发团队居然可以像Supercell、King和EA这样的游戏巨头一样，通过一个按钮，就让超过10亿的活跃IOS设备看到他们做的游戏。我们在手机游戏的包容性道路上又迈出了新的一步。跟我聊天的独立游戏人都为这个关于APP Store的新闻感到由衷的欣喜。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“我认为苹果在以前就对独立游戏的推动做出了很大贡献，而现在看到他们仍旧朝着这个方向前进真是太好了。通过一礼拜又一礼拜的观察，种种迹象显示苹果对小型游戏团队的曝光率真的是高得夸张，而现在又有了新的独立游戏专题，看来这种趋势会愈演愈烈。”USTWO游戏工作室负责人如此说道（作品：《纪念谷碑》、《遗忘边际》）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;22Cans（作品：《Godus》、《The trail》）的负责人Peter Molyneux插了一嘴说：“为独立游戏开发者提供专栏——这无论对开发者还是消费者都绝对是个超赞的消息。消费者对独特的游戏内容有着迫切需求，而独立游戏开发者不止一次地在证明着：他们愿意不顾一切地去做内容独特大胆的游戏。有了这样一个发行独立游戏APP的专栏，不用再受到发行商和一般APP发行流程的挑挑拣拣，这对于独立游戏人实在是个超大福利。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后来创建了自己的工作室Mountains的《纪念碑谷》主设计师Ken Wong对此评论道：“‘独立游戏’这个标签在过去几年里变得越发模糊了。但是，作为最大娱乐平台之一的App store,要把那些规模较小、营销开支不足、试验期较长的游戏团队拖出来拉到聚光灯下，这个点子绝对会受到欢迎。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Untame（作品：《Mushroom 11》）的总裁兼创始人Itay Keren补充说：“这个为独立游戏开创的窗口提供了接触到新兴艺术家和艺术其本身的途径。手机游戏跟艺术并不是真的可以拿来相提并论的，但是真正的创新和创造力确实是独立游戏赋予的。所以，给广大群体继续提供这种接触游戏的机会，意味着你同时也在冶炼玩家的品味，甚至能改变人们对手机游戏的定义…… 苹果对独立游戏的支持不仅仅是一个营销活动，他们看到的是游戏这个行业最需要的东西。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.864&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/EpxbB64dftFINpicHjht1s7zOuB5Kc7MZSm1W1rPP7zPEFIjcMnQbHRnHRDgBGdAiamtzXollCBY0x7sJMEoEqXw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot; title=&quot;idea(from nipic)&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;idea(from nipic)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;苹果公司，像很多其他平台运营者一样，他们了解独立游戏开发者能够给游戏生态平衡系统带来怎样的价值。事实上，虽然今天我们通过在APP store的专栏感受到了苹果公司对独立游戏扶持力度的加大，但有开发者告诉我，早在9年前App store首次发行的时候苹果就已经为独立游戏做了很大贡献了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spry Fox（代表作《Road Not Taken》和《Bushido Bear》）的CEO，David Edery谈到：“我和苹果的合作经历非常愉快；我们的中间联系人会让我们实时掌握有关IOS的发展动态，他们也会听取我们的反馈并/或帮助我们，确保我们的游戏能被媒体编辑们看到。对此我们总能感到他们恰如其分的支持。可能我们的游戏赚的钱永远没法达到《皇室战争》那么多（甚至连接近都做不到），而苹果似乎知道：像我们这样努力保持游戏的高质量和原创性是多么难能可贵，他们觉得这才是他们要的……因为我们能从大方向上优化游戏生态系统。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zach Gage（代表作《Typeshift》、《Ridiculous Fishing》）做了一些说明：“我真的很喜欢IOS的生态系统和用户基础。它当然也会像其他电子商店一样起起落落，但是我认为，如果你好好比较比较它当初发行时的样子跟现在这样大的规模，想想它一步步走到今天经历了多少的成长，你会感到非常讶异——讶异他们直到现在还保留着对坚持特色所持有的包容态度”。现在有非常多的编辑偏爱对独立游戏进行报道，并且似乎每过几个月就会有一部独立游戏巨作受到瞩目。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“苹果公司日前对独立游戏的推广、偏爱各种稀奇古怪的独立游戏名字、还甚至为他们颁布的年度游戏奖和苹果设计奖，从这些迹象你可以看出来，这几年来苹果对独立游戏表示了很大的期许。很多创新游戏其实是开发者们在自己的卧室里做出来的，苹果知道也尊重这样的事实，苹果看好他们，也将继续支持他们，以此来鼓励更多的独立游戏开发者。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;NimbleBit（代表作《Tiny Towers》、《Bit City》）的David Marsh补充道：“APP Store真的让我们这些小公司发行了很多游戏；我们从2008年就开始为当时刚出道的App Store做游戏。能够拥有这样一个平台，今天你在这个平台上上传游戏，几天后你就可以通过这个平台得到十亿多的潜在用户，而且他们只要按下下载键就能开始游戏之旅，这在那时候看来就已经很令人惊叹了，即使是现在也仍是如此。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“编辑推荐版块和类型策划推荐栏在APP Store上重磅回归。苹果会根据哪几种不同类型和领域的游戏是玩家喜爱的而重点推荐，但是大部分APP Store的用户可能不会意识到这点，同样地他们也会在社交媒体上展示了很多又酷又有趣的的游戏。当然这些努力也并非万能药，是无法让每个开发者跟每款游戏都能走到聚光灯下的，不过这至少让我们看到了苹果对游戏和游戏开发者多样性的重视，App Store对他们来讲就像家一样温暖。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;独立游戏在App Store受到的重视肯定会给予开发者一种动力，不过那并不表示这样就能对游戏市场来一次乾坤大挪移了。那些经常在手游板块占领导地位的大公司有着雄厚的资源和营销预算。他们在用户获取和保留方面下了大工夫、甚至还在《超级碗》做大屏幕广告。这些独立游戏者可做不到，但是要说的还是那句，他们没什么必要这么做就是了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/EpxbB64dftFINpicHjht1s7zOuB5Kc7MZAcnHia9BPyATRc5a1MllETIZ57uHTAic9OCRstRFllQdBygbZJMhPz1w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot; title=&quot;Moon Hunters(from gamasutra)&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Moon Hunters(from gamasutra)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“在我看来，我们竞争的市场不一样。我们首要关注点是我们的游戏是否给玩家留下情感和情绪方面的影响，我们相信，如果我们在这方面成功地让玩家有所感动，自然就也就能赚到钱。我们绝对不会让一个独具创意的游戏决策以赚用户的钱为基础。”Dan Gray这样说道。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“对于一个想要创造精品游戏的开发者来说，我觉得他们最需要的是要有个让游戏必须付费的好点子。你需要让玩家别无选择只能付费来体验这个游戏。对于游戏开发者来说，做一个每章节都有不同建筑风格的2小时游戏，还要让游戏免费玩，这实在是太艰巨了，所以，我们离开了那样的市场。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Molyneux评论说：“跟游戏巨头竞争难度极其大，毕竟他们有那么大的市场份额。我觉得，如果你想要做出一个比他们‘更好’的同类游戏来跟他们竞争，这注定要输。不过如果你试着做点什么独创有新意的东西，至少你还有机会获得一些消费者的青睐，毕竟他们可能会厌倦了重复相同的游戏机制。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Marsh对这点相当同意，还补充道：“和像Supercell、King和EA这样的巨头公司争实在是吃力不讨好，不过我从来没把他们看做是直接的竞争对手。我们在各自有各自的游戏使命，互相并没有冲突。我们的工作室就3个人……所以我们不用像他们那么费力来保持续航力。我们把这个当做一种优势，这让我们可以自由地做我们认为有趣的游戏，尽管这样的游戏并不会给我们带来每天上百万美元的收入。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Armor Games（代表作《Sonny》、《Gem Hunters》）的老板Daniel McNeeley为苹果支持独立游戏的举动深受感动，不过他仍旧担心着小游戏工作室在移动平台上面临的巨大挑战，他说：“是有人可以做出真的了不起的游戏的，但是可能这些游戏永远都火不起来，因为他们通常无法跟那些大公司比营销，毕竟连规模都没人家大。我觉得没有人会去质疑独立游戏开发者做出的努力，但很多时候总感觉成功取决于——有没有刚好在媒体界的人脉或者刚好很有名的朋友帮你宣传，然后你才能从众多游戏中走出来到聚光灯下。也不是说这是全凭运气、徒劳无功的事！只是说大多数情况下，独立游戏开发者甚至得比大公司尽更多的努力来获得成功或突破。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据独立游戏开发者给我们的反馈，以前开发者在APP Store或者Google Play两个平台之间选择时往往要小心翼翼，但是现在两个平台都分别对独立游戏群体开发的产品表示了浓厚的兴趣，所以若能你将产品目标平台向IOS和Adroid齐头并进就再好不过了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“随着手机游戏市场越来越疯狂的竞争，我认为我们作为独立游戏开发者是相对幸运的，因为现在两大主要平台都如此热捧独立游戏。他们是绝对没有必要这么做的，这都是出自他们对独立游戏的期许。”David Edery这么说道。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Dan Gray还评论说：“也许曾经Google由于他们对独立游戏尤其是精品独立游戏的支持而受到指责，而如今就我看来，人们对于他们的做法有了很明显积极的改观。就在上个月他们还策划了一次活动来为独立游戏庆祝并且给开发者们颁奖，所以独立游戏似乎再次成为了付费游戏一个可行性更高的选择。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;David Marsh还补充说：“如果你想让人们玩你的游戏，我认为Google Play和App Store都会是合适你们新颖作品的好平台——因为我认识的每个人都有一把Adroid或者IOS系统手机，甚至连我祖母都会安装我们的新游戏来玩，这放在10年前我根本不敢相信。现在似乎两个平台都在致力于新的管理和整理方法，以便让海量的游戏能在他们的平台上顺利运行。认可独立游戏开发者是让巨型游戏库发挥其多样性的绝佳方式，我们希望这种趋势能继续延续下去！”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;本文由游戏邦编译，转载请注明来源，或咨询微信zhengjintiao&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>