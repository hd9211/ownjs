<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>995ec60dcbd8f1e6d983b1febb496875</guid>
<title>我在 GitHub 上读清华</title>
<link>https://toutiao.io/k/d749gee</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ffe6d9349157ef9ae0a95971c19afb74</guid>
<title>小团队中微服务的可怕之处</title>
<link>https://toutiao.io/k/qekwna8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务听起来很棒，每一个团队可以彼此独立工作而不影响其他团队。你可以轻松地维护和扩展微服务。你也可以在同一项目中使用不同的技术。它们如此稳定，所以，你的产品会有极好的扩展。在 2021 年，不应该把任何应用作为单体来构建，对吧？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很遗憾，微服务并非在每一种环境下都可以发挥作用，在盲目使用之前，你必须确定它们提供了你所需要的价值。我见过几个典型的项目，有 4~6 名开发者，基本上是一个团队。客户想要构建微服务的应用程序，因为它们非常棒。IT 经理同意了，于是团队开始设计应用程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户管理？是的，这是一个微服务。访问权限管理？也是微服务。管理和预约？同样是微服务！通过连接到几个第三方 API 来管理和发送订单？这绝对是一个微服务。不错，现在每个人都可以得到一个微服务了！有时候你可能会违反物理学法则，每个人都有多个微服务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;恐怖开始&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你开始这个伟大的旅程时，你的团队需要确保每一个微服务都可以独立开发。每一个微服务都有它自己的 CI/CD 管道，自己的数据库和自己的版本化 API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，在启动一个新项目时，你可能只有一个团队。将在同一个团队中构建所有这些微服务。这种情况经常发生：一个人为了实现一个新功能而承担多个微服务。让我们就叫她 Ellie 吧。Ellie 需要在任何地方进行一些调整，同时进行测试。当她遇到问题时，她可以开始对两个微服务进行并行调试，以尝试了解它们之间的通信。如果它实际上是应用程序的一部分，那么 Ellie 就拥有一个更简单的工作环境，并且可以直接在应用程序中进行调试。此外，她还不需要为这些微服务之间的分布式、可能是异步通信编写大量定义和代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，你的应用程序的第一个版本将提供给你的客户。当你更新应用程序并尝试开始滚动更新时，你将面临在某一时间内运行微服务的多个版本。要么它们都与其他版本兼容（这也需要在开发过程中进行一些工作），要么你需要以某种方式优雅地更新它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在最坏的情况下，你正在构建一个分布式的单体应用。而且，在你的小团队里，你会发现微服务的所有缺点，但是很可能并没有从这些中获益。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;微服务的亮点在哪里？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;亚马逊和 Netflix 是最早提到他们使用微服务的大公司之一，他们解释了微服务为何如此有用。亚马逊提出了两个披萨原则，并表示：“如果两个披萨不足以喂饱一个项目团队，那么这个团队可能就显得太大了”。每个团队都应该有自己的微服务，它绝不应该在两个团队之间分割。要获得完全的所有权，团队必须对其组件及其相关的所有东西拥有完全的控制权。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单体应用中管理代码和依赖项，面对庞大的软件和数百人的工作，是相当麻烦的。因为微服务与其他所有东西解耦，这是一个完美的方法，可以扩展开发团队的数量。他们可以在自己的微服务上工作，使用已经构建的 API，并扩展现有产品。他们无须与其他 80 个团队中的每个决策保持一致，而且他们可能不必选择相同的技术或保持版本一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务对于管理大型软件来说并不是必需的，而是管理大量使用这些软件的人。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;我现在该怎么办？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这并不意味着微服务就会陷入混乱。但是，我要你真正思考微服务对你的意义，以及你是否能从中获益。当然，它们可以为你提供许多好处，但同时也增加了许多复杂性。假如这些好处对你无关紧要，你就可以跳过它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个很好的软件开发范式是保持简单。既然可以简单地实现相同的结果，为什么还要选择更复杂的方式呢？你只会让它变得更难理解，以后也更难改变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务同样如此。既然你的团队必须处理所有微服务，并完全控制应用程序，为何还要增加微服务的复杂性？你的产品可能会增长，但是两周内它并不会成为下一个 Netflix。就像俗话所说的：“过早的优化是万恶之源”，所以不要急着优化！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相反，享受一个相当单一的应用程序的好处。尽情享用更快的开发速度，因为你不需要担心改进微服务间的通信，不需要花费更多时间调试和测试微服务间共享通用代码的意义，不需要尝试协调复杂的分阶段微服务发布，甚至不需要在每个微服务上处理巨大的 docker 映像大小和内存需求，因为你正在使用 Spring Boot。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4788732394366197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/PxMzT0Oibf4hVFOU49r75m9OLJibHLicHpL9uicPPZ0lyMicAgHicMIx2zsVwM1uq9ULNzTERjSykbmCAVWhVUpO9hNw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;284&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也不需要全心致力于单体或微服务。你仍可以将应用程序划分为有意义的部分 —— 甚至遵循领域驱动设计的指导原则。有了合适的架构，你的代码和模块仍然可以被恰当地解耦，并且你的应用程序符合 12 要素原则。可以在相同的应用程序中运行这些模块，可以共享相同的构建管道，只需部署一个版本即可进行部署。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;但我如何扩大规模呢？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你发布了你的产品，而且非常成功。你希望构建更多功能并适当地扩展。你雇佣并组建了多个开发团队，你是否真的从微服务中获益？现在正是将你的应用拆分到微服务的绝佳时机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若你的应用程序构建正确，且不同模块已经解耦并易于理解，则拆分它们应该不会太困难。是啊，得费点功工夫。当然，你可以从一开始就直接使用微服务来避免这个问题。但是在这种情况下，你也必须从一开始就直接处理复杂的事情，并且拖拖拉拉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保证在适当的时候选择合适的架构并且保持简单。&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;关注代码架构和质量。&lt;/span&gt;&lt;span data-mpa-emphasize-underline-bg-line=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;原文链接：http://t.hk.uy/yC4&lt;br/&gt;&lt;/span&gt;&lt;span&gt;作者介绍：Manuel Reinfurt，InCloud 首席技术官。负责技术领导与新工作。精通Azure、.NET/C#、云计算开发。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;作者 ｜ Manuel Reinfurt&lt;br/&gt;译者 ｜ Sambodhi&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>19139237ebe9bc1e27f3f836f5c454fc</guid>
<title>Go 语言的 IO 库那么多，我该怎么选？</title>
<link>https://toutiao.io/k/zco3258</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在计算机和信息技术领域里&lt;code&gt;I/O&lt;/code&gt;这个术语表示输入 / 输出 ( 英语：Input / Output ) ，通常指数据在存储器（内部和外部）或其他周边设备之间的输入和输出，是信息处理系统与外部之间的通信。输入是系统接收的信号或数据，输出则是从其发送的信号或数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Go语言中涉及&lt;code&gt;I/O&lt;/code&gt;操作的内置库有很多种，比如：&lt;code&gt;io&lt;/code&gt;库，&lt;code&gt;os&lt;/code&gt;库，&lt;code&gt;ioutil&lt;/code&gt;库，&lt;code&gt;bufio&lt;/code&gt;库，&lt;code&gt;bytes&lt;/code&gt;库，&lt;code&gt;strings&lt;/code&gt;库等等。拥有这么多内置库是好事，但是具体到涉及&lt;code&gt;I/O&lt;/code&gt;的场景我们应该选择哪个库呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;io.Reader/Writer&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go语言里使用&lt;code&gt;io.Reader&lt;/code&gt;和&lt;code&gt;io.Writer&lt;/code&gt;两个 interface 来抽象&lt;code&gt;I/O&lt;/code&gt;，他们的定义如下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Reader &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Read(p []&lt;span&gt;byte&lt;/span&gt;) (n &lt;span&gt;int&lt;/span&gt;, err error)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Writer &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Write(p []&lt;span&gt;byte&lt;/span&gt;) (n &lt;span&gt;int&lt;/span&gt;, err error)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;io.Reader&lt;/code&gt; 接口代表一个可以从中读取字节流的实体，而&lt;code&gt;io.Writer&lt;/code&gt;则代表一个可以向其写入字节流的实体。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;io.Reader/Writer 常用的几种实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;net.Conn: 表示网络连接。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;os.Stdin, os.Stdout, os.Stderr: 标准输入、输出和错误。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;os.File: 网络,标准输入输出,文件的流读取。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;strings.Reader: 字符串抽象成 io.Reader 的实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bytes.Reader: []byte抽象成 io.Reader 的实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bytes.Buffer: []byte抽象成 io.Reader 和 io.Writer 的实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bufio.Reader/Writer: 带缓冲的流读取和写入（比如按行读写）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了这几种实现外常用的还有&lt;code&gt;ioutil&lt;/code&gt;工具库包含了很多IO工具函数，编码相关的内置库&lt;code&gt;encoding/base64&lt;/code&gt;、&lt;code&gt;encoding/binary&lt;/code&gt;等也是通过 io.Reader 和 io.Writer 实现各自的编码功能的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些常用实现和工具库与io.Reader和io.Writer间的关系可以用下图表示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6137339055793991&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/z4pQ0O5h0f4Su3aNL1vDWgHXQ2LcA5E7XTxnlibOhNsMjQvDAEtF7h2vwre0HUVXd61iaRTlrLUsInfU3iayfLeWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;932&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;每种I/O库的使用场景&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;io库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;io&lt;/code&gt;库属于底层接口定义库。它的作用主要是定义个&lt;code&gt;I/O&lt;/code&gt;的基本接口和个基本常量，并解释这些接口的功能。在实际编写代码做&lt;code&gt;I/O&lt;/code&gt;操作时，这个库一般只用来调用它的常量和接口定义，比如用&lt;code&gt;io.EOF&lt;/code&gt;判断是否已经读取完，用&lt;code&gt;io.Reader&lt;/code&gt;做变量的类型声明。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 字节流读取完后，会返回io.EOF这个error&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; {&lt;br/&gt; n, err := r.Read(buf)&lt;br/&gt; fmt.Println(n, err, buf[:n])&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err == io.EOF {&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;os 库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;os&lt;/code&gt;库主要是处理操作系统操作的，它作为Go程序和操作系统交互的桥梁。创建文件、打开或者关闭文件、Socket等等这些操作和都是和操作系统挂钩的，所以都通过&lt;code&gt;os&lt;/code&gt;库来执行。这个库经常和&lt;code&gt;ioutil&lt;/code&gt;，&lt;code&gt;bufio&lt;/code&gt;等配合使用&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;ioutil库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ioutil&lt;/code&gt;库是一个有工具包，它提供了很多实用的 IO 工具函数，例如 ReadAll、ReadFile、WriteFile、ReadDir。唯一需要注意的是它们都是一次性读取和一次性写入，所以使用时，尤其是把数据从文件里一次性读到内存中时需要注意文件的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读出文件中的所有内容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;readByFile&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  data, err := ioutil.ReadFile( &lt;span&gt;&quot;./file/test.txt&quot;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    log.Fatal(&lt;span&gt;&quot;err:&quot;&lt;/span&gt;, err)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;data&quot;&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;(data)) &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将数据一次性写入文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;writeFile&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  err := ioutil.WriteFile(&lt;span&gt;&quot;./file/write_test.txt&quot;&lt;/span&gt;, []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;hello world!&quot;&lt;/span&gt;), &lt;span&gt;0644&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;bufio库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bufio，可以理解为在&lt;code&gt;io&lt;/code&gt;库的基础上额外封装加了一个缓存层，它提供了很多按行进行读写的函数，从io库的按字节读写变为按行读写对写代码来说还是方便了不少。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;readBigFile&lt;/span&gt;&lt;span&gt;(filePath &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  f, err := os.Open(filePath)&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; f.Close()&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    log.Fatal(err)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  buf := bufio.NewReader(f)&lt;br/&gt;  count := &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 循环中打印前100行内容&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    count += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    line, err := buf.ReadString(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;)&lt;br/&gt;    line = strings.TrimSpace(line)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;line&quot;&lt;/span&gt;, line)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; count &amp;gt; &lt;span&gt;100&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ReadLine和ReadString方法：buf.ReadLine()，buf.ReadString(&quot;\n&quot;)都是按行读，只不过ReadLine读出来的是[]byte，后者直接读出了string，最终他们底层调用的都是ReadSlice方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bufio VS ioutil 库：bufio  和 ioutil 库都提供了读写文件的能力。它们之间唯一的区别是 bufio 有一个额外的缓存层。这个优势主要体现在读取大文件的时候。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;bytes 和 strings 库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bytes 和 strings 库里的 bytes.Reader 和string.Reader，它们都实现了&lt;code&gt;io.Reader&lt;/code&gt;接口，也都提供了NewReader方法用来从&lt;code&gt;[]byte&lt;/code&gt;或者&lt;code&gt;string&lt;/code&gt;类型的变量直接构建出相应的Reader实现。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r := strings.NewReader(&lt;span&gt;&quot;abcde&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// 或者是 bytes.NewReader([]byte(&quot;abcde&quot;))&lt;/span&gt;&lt;br/&gt;buf := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; {&lt;br/&gt; n, err := r.Read(buf)&lt;br/&gt; fmt.Println(n, err, buf[:n])&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err == io.EOF {&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个区别是 bytes 库有Buffer的功能，而 strings 库则没有。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; buf bytes.Buffer&lt;br/&gt;fmt.Fprintf(&amp;amp;buf, &lt;span&gt;&quot;Size: %d MB.&quot;&lt;/span&gt;, &lt;span&gt;85&lt;/span&gt;)&lt;br/&gt;s := buf.String()) &lt;span&gt;// s == &quot;Size: 85 MB.&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于&lt;code&gt;io.Reader&lt;/code&gt;和&lt;code&gt;io.Writer&lt;/code&gt;接口，可以简单理解为读源和写源。也就是说，只要实现了&lt;code&gt;Reader&lt;/code&gt;中的&lt;code&gt;Read&lt;/code&gt;方法，这个东西就可以作为读源，里面可以包含数据，被我们读取。&lt;code&gt;Writer&lt;/code&gt;也是如此。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是我对Go语言里做&lt;code&gt;I/O&lt;/code&gt;操作时经常会用到的Go语言内置库在使用场景和每个库要解决的问题上的一些总结，希望能帮大家理清思路，作为参考，在开发任务中需要时正确选择合适的库完成&lt;code&gt;I/O&lt;/code&gt;操作。如果文章中的叙述有错误，欢迎留言指正，也欢迎在留言中对文章内容进行探讨和提出建议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>502afbb813a1666013670b85a715ad03</guid>
<title>如何进行指标质量治理：指标系统（提质篇）</title>
<link>https://toutiao.io/k/qpn3cho</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;作者：小见；数据中台产品负责人；UBDC全域大数据峰会“灯塔人物”；擅长埋点模型、指标治理，数仓架构等；&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;01&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;指标质量治理概述&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;指标质量治理主要分为两个部分：提质与增效。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;可以简单从字面进行理解，提质就是提升指标质量，主要是针对指标本身而言，保障指标在应用的过程中不会出现歧义、误解，并且指导数仓的规范化建设，而增效则是增加指标的效益，主要是针对指标与企业的关系而言，让指标在企业的业务活动中，能更高效、更准确地反映出企业的内在情况与业务问题，为企业的发展方向提供指导。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;本文主要是指标提质为主，指标增效部分择日再续。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;02&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;指标提质的工作主要分为两个阶段&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;A、面对已存在的、混乱的旧指标现状，进行全业务的指标梳理与重建；&lt;/p&gt;&lt;p&gt;B、约束新指标需求，规范化指标开发流程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;03&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;指标提质需要达到的目标&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;A阶段：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1、输出全局指标字典：用于相关使用人员检索、查询、确认；&lt;/p&gt;&lt;p&gt;2、调整指标的呈现：从数仓字段到报表、数据产品的功能上，对梳理后的指标进行优化、重整；&lt;/p&gt;&lt;p&gt;3、指导数仓的重构：重新规划数仓分层与数据加工流程。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;B阶段：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1、制定指标需求审核流程；&lt;/p&gt;&lt;p&gt;2、输出指标作业手册，从指标的变更、动议到方案、执行，制定严格的流程；&lt;/p&gt;&lt;p&gt;3、研发指标系统，规范化指标开发流程，并最终将指标落地到指标字典。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;04&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;针对指标进行前提的调研&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;指标混乱的原因主要有以下 7 个方面（4 个不一致，3 个不清晰）：&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;1、相同指标名称，口径不一致&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如对于 “新用户” 的定义：&lt;/p&gt;&lt;p&gt;运营部的口径是：首次下单并完成支付的用户。&lt;/p&gt;&lt;p&gt;产品部的口径是：当日新增注册的用户。&lt;/p&gt;&lt;p&gt;两者描述的是不同的目标用户群，但由于命名上相同，所以在使用上容易让人混淆。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、相同口径，不同指标名称&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如 “优惠券” 的相关指标：&lt;/p&gt;&lt;p&gt;衡量企业日常经营活动的健康度：优惠券抵扣金额。&lt;/p&gt;&lt;p&gt;衡量市场活动效果：优惠券消耗金额。&lt;/p&gt;&lt;p&gt;两者都是衡量优惠券抵扣的金额，但由于不同名，所以导致认知上出现了偏差。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、限定词不同，但业务事实相同的两个指标，描述事实部分的口径不一致&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如涉及到 “购买” 这个业务事实的相关指标：&lt;/p&gt;&lt;p&gt;白金会员的支付用户数中，“支付用户数” 的口径定义是：统计周期内下单并且成功支付的去重用户数。&lt;/p&gt;&lt;p&gt;黄金会员的支付用户数中，“支付用户数” 的口径定义是：统计周期内下单并且支付成功，并排除退单的去重用户数。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;两者描述的都是 “用户支付商品订单” 的这个业务过程，记录都是 “支付” 这个事实，区别在于，一个限定词是白金会员，另外一个是黄金会员。但根据一致性原则，虽然这两个指标不同，但是“支付”这个事实是相同的，所以“支付用户数”这个指标的业务口径、计算逻辑应该是一致的。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;4、指标口径与计算逻辑不一致&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这个问题的根本是指标的需求方或开发人员对于指标的认识不清晰，导致指标在开发逻辑上产生了错误导致。&lt;span&gt;如 “近 7 日 UV” 这个指标：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正确的定义是：最近 7 天内，有登录过的去重用户数。但是在实际应用场景中，有的会定义成：“7 日日均 UV” 也就是近 7 日，每日的 UV 相加除以 7 取平均值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个问题在梳理的过程中是比较难发现的，因为它涉及到计算逻辑跟口径之间的校准，所以需要更仔细地梳理指标开发逻辑。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5、指标口径不清晰&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;部分指标口径的描述比较笼统，或者部分名词具有多义性。&lt;/p&gt;&lt;p&gt;如&lt;span&gt;描述笼统的 “关单金额” 的口径描述是 “关闭订单的金额”，但关闭订单会有两种理解，1 是支付后退款，2 是支付前取消；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;名词多义性的：“地址” 这个维度，有多种涵义，如户籍地址、常住地地址、IP地址、GPS 地址等；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;指标描述不清晰，就会让使用者产生误解，所以在记录的时候，必须对这些容易产生误解的地方进行标注。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;6、指标命名不清晰&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在实际的业务操作过程中，因为各业务部门只着眼于自己的业务，没有进行全局的设计，所以有很多指标在自己的部门内部使用是没有问题，但是跟其他部门沟通时就会产生歧义，如 ROI、销售额、支付人数等。这些词都是普通名词（也即原子指标），是没有一个具体的指称的，所以必须将这些普通名词都加上具体指称的业务对象（也即指标的聚合粒度），变成专有名词，如：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;xx渠道 ROI，或是xx活动 ROI；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;xx专题销售额，或是全平台销售额；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;xx课程支付人数，或是xx专题支付人数。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;除此之外，所有的指标都包含了一定的统计周期，只要涉及到具体的数值，就必然要加上统计周期，所有的指标，也都是在最小粒度上去累加出来的，如近一个月xx专题支付人数，是 sum 了 30 个近一天xx专题支付人数，而近一天xx专题支付人数，是 sum 了 24 个近一小时xx专题支付人数，然后到分、到秒。具体需要聚合到什么粒度，根据具体的需求来设计，所以上述的指标需要调整成：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;近一周xx渠道 ROI；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;近一月xx专题销售额；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;近一年xx课程支付人数。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;7、指标来源和计算逻辑不清晰&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这个问题主要出现在一个指标可以通过多个数据源，不同的计算逻辑分别统计得出。比如：某个课程的销售额，既可以从课程的角度，对单个课程的销售金额进行累加；也可以从用户的角度，对购买过该课程的用户的子单的支付金额进行计算。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果指标有多个来源，就需要进行来源统一，否则，如果来源不清楚，一旦指标发生问题，很难去溯源定位。另外，有些指标的计算逻辑比较复杂，仅仅凭借业务口径一段描述，使用指标的人还是无法理解这个指标的计算逻辑，这个时候就需要有一些伪码或者  SQL 描述。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;05&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;具体的实施步骤&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1、由数据产品牵头，各业务线数据分析师辅助，成立攻坚小组，进行全局指标的梳理；&lt;/p&gt;&lt;p&gt;2、明确梳理计划，进行全业务的指标收集（以下模版供参考）；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;564&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;502&quot; data-ratio=&quot;0.18013856812933027&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;866&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jWg3EibnYW99v4ribErZboWZzILFBFLcbkloOopAibOI3xhtoTeVpwUdo2fnlLODcjgPibhKcdOjcUyEUxVQAH2hAw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3、对于收集到的指标，进行初步讨论去重，口径相同的进行合并，并与业务方进行确认；&lt;/p&gt;&lt;p&gt;4、将剩余指标进行归集，明确主题域、业务过程；&lt;/p&gt;&lt;p&gt;5、区分指标类型，拆分原子指标与派生指标，对于派生指标，要定义统计的实体、业务修饰词、统计周期等；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.14665127020785218&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;866&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jWg3EibnYW99v4ribErZboWZzILFBFLcbkaIZQpiaVhrJaaiclibM1kDrdpDlRpmGG0Sp17xkSJKSl7FKc1b9XT9U0Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;6、输出全局统一的指标字典；&lt;/p&gt;&lt;p&gt;7、根据指标字典，拆分出的原子指标、派生指标、主题域、业务修饰词等内容，指导数据仓库的重构；&lt;/p&gt;&lt;p&gt;8、进行指标系统的搭建，组件化新指标的开发流程。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.651270207852194&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jWg3EibnYW99v4ribErZboWZzILFBFLcbk3ewzYcu4plBGwwGdbseGEmibqhKe1GuiaV7MsskwDuxjvyHNSfXWiaSOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;866&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6443418013856813&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jWg3EibnYW99v4ribErZboWZzILFBFLcbkMqnQyG7qTMtibMXUrbTGEVcia0jTxGibsMn8hOw1MVt118EUsYqNYOib9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;866&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;06&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;写在最后&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;指标提质的最终成果，就是要形成一个包含生产自动化、开发逻辑规范化、口径一致化的指标系统。它既包含指标的开发工具，可以让各部门业务人员自行组装指标，也提供全局业务口径一致的指标字典，方便使用人员快速了解指标的业务含义和计算逻辑，避免对指标的口径产生歧义。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;转自：&lt;/strong&gt;&lt;strong&gt;一个数据人的自留地；&lt;/strong&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fd3fea96d1a0425a8ac329eb405e104e</guid>
<title>如何利用分层降低复杂度</title>
<link>https://toutiao.io/k/wvcfy97</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content yue&quot;&gt;
          &lt;p&gt;最近，父亲在老家建了一座三层楼的房子，从此在老家有了个根据地。由于时间紧张，三楼还没有装修，但这已不妨碍我们入住体验了。&lt;/p&gt;

&lt;p&gt;如果未来的房子可以用3D打印机打印出来，有两种打印方式：从左到右打印和从下到上打印。你认为哪种方式更好？&lt;/p&gt;
&lt;figure data-type=&quot;image&quot; tabindex=&quot;1&quot;&gt;&lt;img src=&quot;https://wzw.pub/post-images/1624114168883.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;
&lt;p&gt;如果让我来选，我还是会选从下到上一层层打印。因为假设打印机中途发生故障了，我还是有可能住进完整的第一层；而不是一个四面漏风的房子中。&lt;/p&gt;
&lt;p&gt;在软件开发，这种思路叫做&lt;strong&gt;解耦&lt;/strong&gt;。房子的每一层都是解耦的，每一层都可以独立提供一个较为完整的居住体验。从左到右的打印，则把每一层耦合到了一起，除非全部打印完，否则是没法住人的。&lt;/p&gt;
&lt;p&gt;房子可以住人，在软件开发中就如同产品可以&lt;strong&gt;交付&lt;/strong&gt;给用户使用。如果将产品也划分为一层一层进行分层构建，就可以进行持续交付。用户每过一段时间便能体验到新的功能，然后根据用户的反馈进行下一轮的调整，这便是当下流行的敏捷开发思想。&lt;/p&gt;
&lt;h2 id=&quot;导航&quot;&gt;导航&lt;/h2&gt;
&lt;p&gt;从深圳骑行到北京，怎么能以&lt;strong&gt;最快响应速度&lt;/strong&gt;给出一条可行的路线？&lt;/p&gt;
&lt;p&gt;在游戏开发中，这是一个经典的寻路问题。以应用最为广泛的AStar寻路为例，其寻路的时间跟整个路径上要搜索的网格数成正相关。&lt;/p&gt;
&lt;figure data-type=&quot;image&quot; tabindex=&quot;2&quot;&gt;&lt;img src=&quot;https://wzw.pub/post-images/1624114175744.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;
&lt;p&gt;如果以街区类比网格，从深圳骑行到北京，粗略估算要途径上万个街区。这样寻路的时间会变得非常漫长（&lt;em&gt;百度地图甚至无法给出骑行路线&lt;/em&gt;），用户难以接受这么慢的响应时间。&lt;/p&gt;
&lt;p&gt;有没有一个办法可以&lt;strong&gt;立刻&lt;/strong&gt;给出一条可行路线呢？&lt;/p&gt;
&lt;p&gt;答案是&lt;strong&gt;分层寻路&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们可以以简单的行政区划进行分层：省，市，县，乡和街道。&lt;/p&gt;
&lt;figure data-type=&quot;image&quot; tabindex=&quot;3&quot;&gt;&lt;img src=&quot;https://wzw.pub/post-images/1624542047187.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;
&lt;p&gt;首先，在省这一层，我们可以规划出，从广东到北京需要途径哪些省份。中国只有34个省级行政区，所以这一层最多要处理34个网格。&lt;/p&gt;
&lt;p&gt;接着在广东省内，我们可以规划出，从深圳到下一个省需要途径哪些市。广东省有21个地级市，所以这一层最多要处理21个网格。&lt;/p&gt;
&lt;p&gt;接着在深圳市内，我们可以规划出，从我们这个区到下一个市要途径哪些区。深圳市有10个区，所以这一层只需要处理10个网格。&lt;/p&gt;
&lt;p&gt;我在南山区，可以规划出从我住的街道到下一个区要途径哪些街道。南山区共有8个街道，所以这一层只需要处理8个网格。&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;进行分层后，每一层要处理的网格数便降低到一个非常低的量级，这样每一层都可以非常快速的给出答案，最后的时间正比于层数&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\times&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot;/&gt;&lt;span class=&quot;mord&quot;&gt;×&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;层的网格数，远低于总的网格数，所以总耗时将大大降低。&lt;/p&gt;
&lt;p&gt;当然，有人会问了，我并没有给出其他省份和市区的内部路线；但是实际上这些路线可以放到后续进行进一步计算，不耽误你立即出发。&lt;/p&gt;
&lt;p&gt;分层寻路能快速求解的本质在于每一层的添加都&lt;strong&gt;降低了整个问题的复杂度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;复杂度是软件工程师的大敌，一个好的工程师可以管理并驾驭复杂度，使得软件容易维护；而一个差的工程师则容易因管理不好复杂度而失去对代码的控制，要么bug丛生，要么难以维护。&lt;/p&gt;
&lt;h2 id=&quot;组织架构&quot;&gt;组织架构&lt;/h2&gt;
&lt;p&gt;一个集团军通常有5-10万人，假设你是一个集团军司令，请问你该如何去指挥这10万人呢？&lt;/p&gt;
&lt;p&gt;你的精力有限，你无法去指挥每一个人的行动。因为根据邓巴数，每个人通常只能与150个人维持比较紧密的关系，这个数字受到人类大脑皮质的限制。&lt;/p&gt;
&lt;p&gt;作为一个司令，你指挥不过来每一个人，也无需去指挥每一个人。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你手下大概会有5个师或旅，你对这些师长或旅长们发号施令；&lt;/li&gt;
&lt;li&gt;一个师或旅下面会有4个团，他们负责指挥这些团长；&lt;/li&gt;
&lt;li&gt;一个团下面大概会有4个营，团长负责指挥这些营长；&lt;/li&gt;
&lt;li&gt;一个营下面又有4个连；一个连下面又有4个排；&lt;/li&gt;
&lt;li&gt;一个排下面大致有3个班，一个班里有10个人，而班长则负责指挥这10个人进行具体作战任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过分层，每一个长官需要直接管理的下属会少于10个，大大降低了指挥的复杂度。&lt;/p&gt;
&lt;p&gt;军队的层级是一个典型的金字塔结构，越高职位的人越少，越低职位的人越多。这与当今的绝大多数组织的架构一致。&lt;/p&gt;
&lt;figure data-type=&quot;image&quot; tabindex=&quot;4&quot;&gt;&lt;img src=&quot;https://wzw.pub/post-images/1624114315254.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;
&lt;p&gt;然而现在却有一种「扁平化」的趋势盛行于高科技互联网公司，这又是为什么呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;凡事都有双面性，有利也就有弊&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;层的划分，可以使每一层解耦，降低了管理的复杂度；但是同时引入了沟通的问题。&lt;/p&gt;
&lt;p&gt;每一层的沟通都是有代价的，信息在每一层中传递都会伴随着损耗。这些损耗可能是上层表达的含糊不清，中层的误读曲解，抑或是下层没有理解到位。&lt;/p&gt;
&lt;p&gt;这有可能是致命的，层数越多，最上层的信息传到底层时被扭曲的可能性就越大，而基层的真实情况则很难传达到最上层。&lt;/p&gt;
&lt;p&gt;提倡扁平化的原因，就在于通过把层数的缩减，使得沟通的损耗降到最低，从而使高层的战略意图能够更快更准的得到执行，基层的意见和情况能直接传达到高层，为决策提供辅助。&lt;/p&gt;
&lt;p&gt;解放军在某些时期也实行过一段时间的「扁平化」。1965年开始，解放军取消了军衔制，这种情况一直延续了20余年，最终又恢复了军衔制。&lt;/p&gt;
&lt;p&gt;为什么取消了又恢复呢？因为在对越反击战中，军队的建制经常容易打散重建，当一个师长和一个团长都被重建到一支队伍中时，由于他们两可能互相不认识，这时候能唯一快速明确指挥关系的就是军衔。军衔低的服从军衔高的，这是一条简单明了的规则。取消了军衔制后，由于大家都没有了军衔，所以这一简单的规则被打破了，导致了打散重建时的指挥混乱。&lt;/p&gt;
&lt;p&gt;从这里我们能再一次看出硬币的两面：绝对的扁平化既不利于管理，也不利于沟通。&lt;/p&gt;
&lt;h2 id=&quot;扁平化-vs-分层&quot;&gt;扁平化 vs 分层&lt;/h2&gt;
&lt;p&gt;引入了层，可以降低管理复杂度，解耦并促进分工，提高效率；另一面，则提升了沟通复杂度，降低了沟通效率，使信息损耗变大。&lt;/p&gt;
&lt;p&gt;分层或扁平化？这是一个问题。&lt;/p&gt;
&lt;p&gt;有两种解决办法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;严格分层，用其他方法保证信息传达高效且准确&lt;/li&gt;
&lt;li&gt;适当扁平化，通过基层自我管理降低管理复杂度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前者的一种代表就是&lt;strong&gt;军事化管理&lt;/strong&gt;。严格强调纪律，下级无条件服从上级，令行禁止，确保命令能够自上而下得到执行。&lt;/p&gt;
&lt;p&gt;军队从古至今就一直遵守着这种模式。军人的天职就是服从，军纪严明，军法严厉。用纪律这一点来确保命令可以得到彻底的执行，信息从上传递到下的路径非常高效。&lt;/p&gt;
&lt;p&gt;现如今，也有许多企业和学校甚至传销组织采用半军事化管理，实际上就是通过严苛的纪律来规范信息的传达高效且准确。而且作为补充，频繁的洗脑也是一种强化信息传达的手段。&lt;/p&gt;
&lt;p&gt;这种方法的问题在于，基层变成了执行机器，丧失了部分自由和人权，而且容易压力过大，内心会比较压抑。&lt;/p&gt;
&lt;p&gt;后者则是精简层级，适当扁平化。但这样不可避免的引入了管理复杂度，对应的解决办法是使基层进行自我管理，从而降低管理复杂度。&lt;/p&gt;
&lt;p&gt;自我管理要求组织成员有较强的能力和自驱力，能够进行自我管理，从而可以减少上层的监管。&lt;/p&gt;
&lt;p&gt;有两种办法可以让成员自我管理，一种是通过招聘和考核进行筛选；还有一种是培训学习，提升成员能力。创业公司没有太多时间用于培训新员工，所以初创团队成员的自我管理能力就显得非常重要。&lt;/p&gt;
&lt;p&gt;我们可以看到，在劳动密集型的企业，比如富士康，就会采用半军事化管理的策略。因为生产线上的工人可能素质没有那么高，自驱力也没有那么强，需要设立纷繁的规则来进行管理。&lt;/p&gt;
&lt;p&gt;而在硅谷的高科技企业，比如Facebook，则提倡扁平化管理。因为其招聘标准较为严格，招来的人基本都是高手，而技术人也不喜欢受到太多的管制和约束。&lt;/p&gt;
&lt;figure data-type=&quot;image&quot; tabindex=&quot;5&quot;&gt;&lt;img src=&quot;https://wzw.pub/post-images/1624114222554.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;康威定律&lt;/strong&gt;：设计系统的架构受制于产生这些设计的组织的沟通结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，不同的组织架构，具备不同的沟通方式。是分层设计还是追求扁平化，不能一概而论。应该结合组织的实际情况来判别。&lt;/p&gt;
&lt;p&gt;假如组织上是脑力密集型，则应该追求适当扁平化，放权给基层，让基层形成自驱；如果组织是劳动密集型，则需要通过层级去减少管理复杂度，通过纪律和规范来使信息高效传达。&lt;/p&gt;
&lt;p&gt;分层的思想本质是一个分解问题的思想，一个大问题，通过分层进行解耦，从而让复杂度可控。这是一把思想的利剑，可以劈开很多看似复杂的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;锤子定律&lt;/strong&gt;：如果你有的只是一个锤子，那么所有的东西看起来都像一个钉子&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，我们也应避免锤子思想，痴迷于用分层去解决所有问题。该如何用好「层」这把武器？我想爱因斯坦已经给出了答案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事情应该力求简单，不过不能过于简单。&lt;/p&gt;
&lt;/blockquote&gt;

        &lt;/div&gt;

        
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>