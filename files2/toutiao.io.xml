<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>83a909d11a0a861171473419fa935490</guid>
<title>阿里巴巴开源的，支持小程序和 Web 容器的跨端 API 解决方案</title>
<link>https://toutiao.io/k/i93qmjf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Njk2NDAzMA==&amp;amp;mid=2660215615&amp;amp;idx=2&amp;amp;sn=844e0251c92fa230434af84b6e49d5d9&amp;amp;chksm=84bba96eb3cc2078f8bf59ced9b7909530f69cb94e8c5405f7d05fb731e4711b7362bdf7b6c0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;加入「码农周刊VIP会员」，一起牛起来！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1053&quot; data-ratio=&quot;2.176&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/t8lpVibticjQ6Zwt1guiawNjXTcM5CFCSf8ZoBhZU2pwJppqXdib7ib68cQj86NKia6bttaxjDNpp9yvYLBibfG5icyKUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6h6x4EnYInRLic6PibFNWw4zSv28rAxcJu9dumVJF03PwHGOWxOzeJKIsydVa7UJuTo4jOjrct9NZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e0b4f96fb4a3723873334bf6a0ca3dd9</guid>
<title>容易引起雪崩的两个处理</title>
<link>https://toutiao.io/k/uhe6c6r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;先介绍标题&lt;/span&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;容易引起雪崩的两个处理&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;的第一个处理：慢查询。&lt;/section&gt;&lt;section&gt;上周在测试环境遇到一个慢查询问题，虽然是测试环境，但是现象还是很让人担忧的：“在大量执行update操作”“已经执行1个多小时”“负载200多，基本上库都卡死了”。把库都要搞挂了，细思极恐啊。于是，这个事件处理的优先级即刻被升级为S级别，我们进行了点线面的梳理和分析。&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;现象分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;首先针对此问题做一个分析。&lt;/section&gt;&lt;section&gt;慢查询的原因简单可以这么理解：公司创立之初写的代码，当时上线工期紧，做的比较糙(声明：不代表公司水平)。后台有个人工查询操作，这个操作要查询下游，下游是异步返回结果。所以是通过异步转同步实现的，使用了一张表，每次操作将历史记录标识位全部改成“已过期”，再将新结果插入到数据表中。“在大量执行update操作”指的就是批量更新标识位的操作。大概一次操作要更新几十万条，然后插入几条。一次更新要执行几十秒。&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题解决&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;当时同事提出要加索引解决，我第一个反应：最主要的字段只有两个值：“已过期”、“未过期”。对这种字段加索引是不是没什么用？结果实际测试结果是：不加这条索引十几秒执行完的查询和更新操作，加了索引只要几毫秒。&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;原理分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;这里主要分析三个问题。&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1&amp;gt;为什么这条索引如此管用？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;先说说为什么我第一反应觉得不管用，看看某乎上的神回复：&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6767485822306238&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibsicbHxHNficSEZrSPTPlg887gorEmFNlVsu5UCZcr88tzLRYD2C89fFHBrvzLcRqiaMEQ4hToycHTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5921855921855922&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibsicbHxHNficSEZrSPTPlg88upamLYZAiauqfu1sI87pJ2WCm4y48iaB6MUbW34geVMhRSy8icLBnTkHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;819&quot;/&gt;&lt;/p&gt;&lt;section&gt;先说为什么能提高查询速度。&lt;/section&gt;&lt;section&gt;举个例子，假设表中有一千万条记录，状态字段有0和1两个值。某个状态为0的记录总数大概会有100条，那么你想查询状态为0的记录时，有没有索引影响非常大，而查询状态为1的记录，则索引基本无用。如果两种状态的记录数相差无几的话，索引也基本无用。&lt;/section&gt;&lt;section&gt;所有的关于索引的文章，建议你不要为这种字段建索引的依据，都是以值分布是均匀为前提的。但如果值分布不均匀的时候，这个建议就不一定是正确的了。当我们需要查询的记录恰好是分布较少的记录的时候，值分布越是不均匀，索引就越有价值！&lt;/section&gt;&lt;section&gt;那为什么能提高更新速度呢？&lt;/section&gt;&lt;p&gt;对于update/insert/delete的每次执行，字段的索引都必须重新计算更新。听起来很慢，但是更新操作实际上是先select再update的过程，这里因为&lt;span&gt;“未过期”&lt;/span&gt;数据条数很少，所以select效率高，然后更新是按照id进行更新，所以很快。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2&amp;gt;为什么慢查询会导致库卡死？&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;一般慢查询，特别是这样&lt;span&gt;将历史记录标识位全部改成“已过期”&lt;/span&gt;的，必然会引起锁表。这个表的相关操作会受到影响是可以理解的，但是为什么会影响到整个数据库呢?这就涉及一个最基本的问题：资源竞争。慢查询和慢请求一个道理，长时间占用连接不释放、连接数是有限的，其他后到的请求要排队。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;这个问题在生产环境相对好些，因为生产环境一般都会用物理机，而且数据盘至少是SSD的。测试环境资源差很多，所以问题会更明显。&lt;/section&gt;&lt;p&gt;&lt;strong&gt;3&amp;gt;负载200多是什么概念？&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;系统平均负载(load averages)是对当前CPU工作量的度量，被定义为特定时间间隔内运行队列中的平均线程数。可以通过top, htop, uptime这些命令找到它们.&lt;/section&gt;&lt;section&gt;关于负载的含义，网上最广泛的示例，是通过桥梁的通过率来解释的。讲的真心好，所以直接「借鉴」过来，需要看原文的直接从参考引用处自行穿越。注意这里的比喻是基于单核CPU的。&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;105&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;系统负荷为0，意味着大桥上一辆车也没有 &lt;/p&gt;&lt;p&gt;系统负荷为0.5，意味着大桥一半的路段有车&lt;/p&gt;&lt;p&gt;系统负荷为1.0，意味着大桥的所有路段都有车，但任然可以顺次通行 &lt;/p&gt;&lt;p&gt;系统负荷为1.7，除了桥满之外，在桥的入口处还有70%的车辆在等待&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;系统负荷为200，除了桥满之外，在桥的入口处还有19900%的车辆在等待！不卡死才怪！&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;sql问题影响巨大，所以我们针对所有的数据表进行了梳理，排查隐患。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;面&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;还需要梳理所有可能引起稳定性隐患的问题。这里就要引出标题《容易引起雪崩的两个处理》的第二个处理了：递归。&lt;/p&gt;&lt;section&gt;递归如果深度控制不好，会产生栈溢出，也就是StackOverflowError。溢出而使得有用的存储单元被改写，往往会引发不可预料的后果。&lt;/section&gt;&lt;section&gt;怎么改呢？要解决这个问题之前刷的leetcode技能就排上用场了。把递归算法转化为非递归算法有如下三种基本方法&lt;br/&gt;1、对于尾递归和单向递归的算法，可以用循环结构的算法替代&lt;br/&gt;2、自己用堆栈模拟运行时栈，分析只保存必须保存的信息（因而可小幅提高时间效率），从而用非递归算法替代递归算法。&lt;br/&gt;3、利用堆栈保存参数，由于堆栈的后进先出特性吻合递归算法的执行过程，因而可以用非递归算法替代递&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;89年有个电影版的《红楼梦》，演员阵容豪华让人咋舌。赵丽蓉演的刘姥姥、刘晓庆演的王熙凤、傅艺伟演的薛宝钗……。&lt;/section&gt;&lt;section&gt;很小就觉得经典电视剧版的《红楼梦》里薛宝钗优雅端庄，颇有大家闺秀之风。看到了电影版《红楼梦》，特别是有个名场面：宝玉管宝姐姐要她随身挂在脖子上的金锁来看：&lt;span&gt;电视剧版的宝姐姐金锁是挂在贴身内层的，当时宝姐姐是这样的：&lt;/span&gt;&lt;span&gt;宝姐姐脸微红，转过身去解下金锁，又缓缓转过来身来，微微笑着给了宝玉。&lt;/span&gt;&lt;span&gt;电影版&lt;span&gt;的宝姐姐也是金锁&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;挂在贴身内层的&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;宝姐姐听宝玉问他要，她不假思索、干脆利落的解下来给了宝玉。&lt;/span&gt;&lt;span&gt;我看到这里，心里的表情是这样的：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlibsicbHxHNficSEZrSPTPlg88CFqMl5RqTnD87l9fYfMe4uNNqnMWD8QPPIymIA24KibKhLVTsnUBldA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;section&gt;这是哪里来的英姿飒爽的女侠走错了片场？&lt;br/&gt;&lt;/section&gt;&lt;section&gt;而在实际工作，我也经常会遇到类似的反差。咱们的每个软件设计和代码，周围的人，后来的人内心都自有评价。愿他们看到的是最好的我们。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4828d43983080c603416e7500f9b210d</guid>
<title>从 SSO 出发谈谈登录态保护</title>
<link>https://toutiao.io/k/5cpgmtk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;抛砖引玉&lt;/h2&gt;&lt;p&gt;在文章开始前，先看看一个常见的情况👇&lt;/p&gt;&lt;p&gt;在集团内进行开发时，通常会遇到不同组之间的合作，如果是同一个组的前后端，因为交互请求都是在同一个&lt;strong&gt;「域」&lt;/strong&gt;内发生的，所以一般不会存在跨域问题。但如果未做处理，直接从 a.alibaba.com 请求 b.alibaba.com 的接口，就会出现跨域的问题，这是因为浏览器对于不同域请求的限制问题，其实跨域的问题很好解，只要设置了正确的请求头即可，具体的可以参考我的这篇文章 👉&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484965&amp;amp;idx=1&amp;amp;sn=d66b7bf027f87b3faf0eea25dd6f18ad&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《一次跨域问题的分析》&quot; data-linktype=&quot;2&quot;&gt;《一次跨域问题的分析》&lt;/a&gt;&lt;/p&gt;&lt;p&gt;但这是访问不需要登录的接口，那&lt;strong&gt;如果是从 a.alibaba.com 访问 b.alibaba.com 下的一个需要登录的接口呢&lt;/strong&gt;？又该如何解决呢？&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;下文以 A 站点指代 a.alibaba.com，B 站点指代 b.alibaba.com&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;单系统登录&lt;/h2&gt;&lt;p&gt;对于一个 web 应用来说，通信协议通常是 HTTP 协议，该协议是无状态的，也就是说，在请求与请求之间是不会产生关联的。这也就意味着，任何用户都能通过浏览器访问服务器资源，且不会打扰到其他用户。如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.393719806763285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybydU03fnz5BLiat5c1AcbiaBD54TCJLzM7v2qsWUTn0lrdvKaiaOIcCRfdxH356piaiaVDVwWff5kaF2uA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果想要保护某些资源，比如一些珍贵的学习资料，那就必须限制浏览器的请求，对于服务端来说就是要知道&lt;strong&gt;发出这个请求的人是谁&lt;/strong&gt;，也即让请求变得有「状态」，只不过既然 HTTP 协议无状态，那就让浏览器和服务器之间共同维持一个状态吧，而这就是最常见的——会话机制。&lt;/p&gt;&lt;h3&gt;Cookie 和 Session&lt;/h3&gt;&lt;p&gt;在会话机制中，最重要的就是 Cookie 和 Session 了，Session 好理解，服务端保存的用来维护某一个用户的状态，浏览器只需用某种方式记录下这个会话的 ID 然后之后每次请求携带即可，想必有小伙伴会发出疑问了，既然是给浏览器携带参数，那么直接在请求参数里携带不是最简单的吗？&lt;/p&gt;&lt;p&gt;的确，将会话 id 作为每一个请求的参数，服务器接收请求自然能解析参数获得会话 id，并借此判断是否来自同一会话，这个思路当然是可以的，只是这种做法的缺点也十分明显，就是请求的 URL 会变得非常长，隐秘性也很差。&lt;/p&gt;&lt;p&gt;而 Cookie 是浏览器用来存储少量数据的一种机制，数据以”key/value“形式存储，并且浏览器发送 http 请求时自动附带 Cookie 信息。此时，有 Cookie 参与的登录请求的流程就变成了下面这样 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.1894736842105262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybydU03fnz5BLiat5c1AcbiaBDIqWyS524oU0sHvdnBLDa1UtNyR1iaBF0xRze1M5FgXgUMqllLBDhxDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;950&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Cookie 和 Session 的使用原理基本如此，至于这么设置 Cookie，怎么通过 Cookie 校验 Session 就不是本文要说的内容了。有兴趣的可以查阅相资料。&lt;/p&gt;&lt;h2&gt;多系统登录&lt;/h2&gt;&lt;p&gt;不知道你有没有留意过，如果你在浏览器中登录了百度网盘之后，再打开百度贴吧时就会发现此时你已经登录成功了，这种情况就是本节要说的多系统登录了。&lt;/p&gt;&lt;p&gt;随着单系统的蓬勃发展，web 系统由单系统发展成多系统组成的应用群，换一种说法就是&lt;strong&gt;「生态」。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;随着集团的规模不断增加，系统越来越多，复杂性随之巨增，正常情况下，这种复杂性应该由系统内部承担，而不是用户。因为对于一个好的系统应该是，无论 web 系统内部多么复杂，对用户而言，都应该是一个统一的整体，也就是说，用户访问 web 系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了。&lt;/p&gt;&lt;p&gt;如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.49370552818828684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybydU03fnz5BLiat5c1AcbiaBDE9crJbMbK3zXiagadlSumvNutjLRUrTr6qPzbCBFuuyHeaUGS7pcUfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1827&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;单系统登录解决方案的核心是 Cookie，Cookie 携带会话 id 在浏览器与服务器之间维护会话状态。但 Cookie 是有限制的，这个限制就是 Cookie 的域（通常对应网站的域名），浏览器发送 http 请求时会自动携带与该域匹配的 Cookie，而不是所有 Cookie，因此，你在请求淘宝的时候是绝对不会携带上只能在百度域下生效的 Cookie 的。&lt;/p&gt;&lt;h2&gt;SSO&lt;/h2&gt;&lt;p&gt;单点登录全称 Single Sign On（以下简称 SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括&lt;strong&gt;「单点登录」&lt;/strong&gt;与&lt;strong&gt;「单点注销」&lt;/strong&gt;两部分。&lt;/p&gt;&lt;h3&gt;登录&lt;/h3&gt;&lt;p&gt;不同于单系统登录，单点登录需要引入一个&lt;strong&gt;独立的登录中心&lt;/strong&gt;，每个系统可能并不会提供登录入口，所有的登录操作都是通过独立的登录中心实现的。由于这一流程较多，这里以时序图的方式来讲解。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9238699444885012&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybydU03fnz5BLiat5c1AcbiaBDxNwXQFJXFIumRiaWREOcStCOssG77HkhDQdfmzR3jPhQxcfqnXtyBbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1261&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;一个单点登录的时序，简化后如上图所示。文字流程如下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;浏览器访问 A 站点时由于未登录，跳转至 SSO 登录中心&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;完成在 SSO 登录中心的登录后，登录中心创建一个全局会话&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;SSO 登录中心返回一个 tikect 给 A 站点，并在 SSO 登录中心记录下 A 站点&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;下次访问 A 站点时携带包含了这个 ticket 的 Cookie，A 站点收到请求并创建针对 A 站点的局部会话，给用户返回已登录的 A 站点页面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;此时如果用户想要访问 B 站点，那么流程如下所示：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;浏览器访问 B 站点显示未登录，跳转至 SSO 登录中心&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;SSO 登录中心发现用户已经在登录中心完成登录&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;SSO 登录中心返回一个 tikect 给 B 站点&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;B 站点拿到 ticket 后再请求一次 SSO 站点，验证无误后写入 ticket 到 Cookie 中，此时 SSO 登录中心记录下 B 站点&lt;/span&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;下次访问 B 站点时携带包含了这个 ticket 的 Cookie，B 站点收到请求并创建针对 B 站点的局部会话，给用户返回已登录的 B 站点页面&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;注销&lt;/h3&gt;&lt;p&gt;注销相较于登录就简单了许多，假设我在 A 站点注销了，那么 SSO 中心接收到注销请求后，直接销毁保存在 SSO 系统的全局会话，然后向所有注册系统发出注销请求，各系统在接受到注销请求后，分别销毁自己的局部会话即可。篇幅原因，这里就不着重笔墨来写了。感兴趣的同学可以自己画一下时序图。&lt;/p&gt;&lt;h2&gt;实现原理&lt;/h2&gt;&lt;p&gt;SSO 采用的是 Client/Server 模式，为了实现 SSO，A、B 站点都需要接入 sso-client 包，SSO 登录中心需要实现 sso-server 包。这两个包的主要功能如下。&lt;/p&gt;&lt;h3&gt;sso-client&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;拦截子系统未登录用户请求，跳转至 sso 认证中心&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;接收并存储 sso 认证中心发送的令牌&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;与 sso-server 通信，校验令牌的有效性&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;建立局部会话&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;拦截用户注销请求，向 sso 认证中心发送注销请求&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;接收 sso 认证中心发出的注销请求，销毁局部会话&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;sso-server&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;验证用户的登录信息&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;创建全局会话&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;创建授权令牌&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;与 sso-client 通信发送令牌&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;校验 sso-client 令牌有效性&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;系统注册&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;接收 sso-client 注销请求，注销所有会话&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在了解了 sso-client 和 sso-server 的主要功能后，编码实现就容易的多了，互联网上已经有很多相关的资料了，这里就不展开说了。&lt;/p&gt;&lt;h2&gt;登录态保护&lt;/h2&gt;&lt;p&gt;在了解了 SSO 之后，我们知道，在 A 站点登录后，下次再请求 A 站点就会携带诸如「A_USER_COOKIE」的一个 Cookie 值。在 B 站点登录后，下次再请求 B 站点就会携带诸如「B_USER_COOKIE」的一个 Cookie 值。&lt;/p&gt;&lt;p&gt;结合着 SSO 的原理，我们再回到本文一开始的问题，&lt;strong&gt;如果想要从 A 站点跨域请求 B 站点一个需要登录的接口，不可避免的一定要重定向到 SSO 站点。因为从 A 站点发出到 B 站点的请求携带的是来自 A 站点的 Cookie，B 站点是无法直接解析的。&lt;/strong&gt;（这里有点绕，理解一下）&lt;/p&gt;&lt;p&gt;为了解决这个问题，可以从前后端两个方式去着手，提供一下思路。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;前端方向，捕捉重定向的错误单独处理，只是如果重定向过程中有可能会出现跨域问题。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;后端方向，通过某种途径，可以&lt;strong&gt;让 B 站点的后端解析来自 A 站点中包含的已经登录过 SSO 的 Cookie&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;根域 Token（共享 Cookie）&lt;/h3&gt;&lt;p&gt;所谓根域即不同应用共享的域名部分，比如 a.alibaba.com 和 b.alibaba.com，根域就是 alibaba.com。根域 token 是&lt;strong&gt;各个子域名应用共用的 Cookie&lt;/strong&gt;，每个子域名应用的请求都可以接收到这个 Cookie 参数，但是每个应用是否能用这个 Cookie 来建立登录态，则需要满足不同的条件。&lt;/p&gt;&lt;p&gt;这个条件是由分发此根域 Token 的 SSO 中心规定。&lt;/p&gt;&lt;h3&gt;根域 token 的使用时序&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7494052339413164&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybydU03fnz5BLiat5c1AcbiaBDql0KYfMLqefnTzISHs3UmRkhkUaHWu5wpKx3dqeGTPick2mZhnBBv6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1261&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;时序如上图所示，这样的好处是，就算我在 A 站点携带的是 A 站点的 Cookie，也可以去访问 B 站点一个需要登录的接口。因为 A 站点的 Cookie 中有一个全局的根域 token，B 站点在将请求发送到 SSO 校验时只要有这个根域 token 即可返回对应的用户信息了。&lt;/p&gt;&lt;h3&gt;根域 token 的优势&lt;/h3&gt;&lt;p&gt;根域 token 的消费端在应用侧，由 SDK 封装这部分逻辑，根据根域 token 建立登录态。对于原先已经接入了 sso-client 的 B 应用只需升级支持根域 token 的版本即可。&lt;/p&gt;&lt;p&gt;这样做的好处是，部分没有接 SDK 的应用也可以通过该 token 完成登录校验。比如 A 站点的后端应用没有更新 sso-client 也无妨，因为 sso-server 升级后会将根域 token 下发。A 应用只需将根域 token 携带给升级后的 B 应用即可。&lt;/p&gt;&lt;p&gt;这样在 A、B 两个站点的前后端开发者之前真正需要做出改变的就只有 B 站点的服务端开发人员了，极大的减少了沟通带来的低效率与撕逼。（中间件的升级独立与 A、B 站点的开发之外）&lt;/p&gt;&lt;h3&gt;根域 token 的问题&lt;/h3&gt;&lt;p&gt;从上述表述发现，根域 token（即共享 Cookie）的确是一个可行的解决办法，但这种方案有很多限制：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;应用群域名统一，基本限制了必须是同一集团下的域&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;共享 Cookie 无法跨语言，即服务端技术栈需统一&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;Cookie 不安全&lt;/span&gt;&lt;/p&gt;&lt;p&gt;所以，对于大多数情况，共享 Cookie 都无法解决统一登录的问题。&lt;/p&gt;&lt;p&gt;只是，眼尖的小伙伴应该意识到了上述三个问题，对于集团内网来说应该都不是问题。为什么这么说？我们逐一分析下。&lt;/p&gt;&lt;p&gt;第一点，都是集团内网的网站，因此所有的站点都是“*.alibaba.com”，域名统一这一点不存在限制。其二，集团内技术栈统一。其三，大多数系统都是内网使用，几乎不存在 Cookie 不安全的情况。&lt;/p&gt;&lt;p&gt;只不过浏览器针对一个域名（根域及子域）下的 Cookie 数量有数量限制，超过则会按规则逐出部分 Cookie，&lt;span&gt;DevExpress&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;网站给出了一些浏览器对于 Cookie 的限制，如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.574585635359116&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybydU03fnz5BLiat5c1AcbiaBDDvWsVNt7OX4H1Ork6e4Bpa1KoHV3reKRicnDPX6ic9sAQIBfrbXTOIIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1086&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;通俗的说就是，对于 chrome 浏览器而言，每个域名的上限是&lt;strong&gt;180&lt;/strong&gt;个 Cookie，而这 180 个域名是针对&lt;strong&gt;「根域名」&lt;/strong&gt;的，也即：a.alibaba-inc.com, b.alibaba-inc.com 和*.alibaba-inc.com 共享这 180 个限制。&lt;/p&gt;&lt;p&gt;在得知了这个限制之后，我们也就理解了为什么共享 Cookie 的方案即使是在集团内也有诸多的限制了。&lt;/p&gt;&lt;h3&gt;Cookie 的逐出规则&lt;/h3&gt;&lt;p&gt;这里提一下，对于超出数量的 Cookie 的逐出规则，我在查阅资料的过程中发现一些博客写的是 LRA(least-recently accessed)，最近最少使用算法。的确，IETF 标准的&lt;span&gt;RFC-6265&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;对 Cookie 逐出策略的规范确实是 LRA 算法。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2702702702702703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybydU03fnz5BLiat5c1AcbiaBDyIjJWLRpvnXZWaQiaMiaW2E2fx4IUlsKkH9jvniaM4ibpbrrIib12t4aLzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1554&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;IETF 是国际互联网工程任务组的简称，IETF 的主要任务是负责互联网相关技术标准的研发和制定，是国际互联网业界具有一定权威的网络相关技术研究团体。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;不过我们都知道，规矩制定的再好也得看实现规矩的人是什么样的。我们来看看浏览器的霸主，chrome 是如何实现的。下图是从 chromium 项目源码中截取的部分片段，地址如下 👇&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/src/+/refs/heads/main/net/cookies/cookie_monster.cc?spm=ata.21736010.0.0.75512bb3YUmXb0&amp;amp;file=cookie_monster.cc&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8006666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybydU03fnz5BLiat5c1AcbiaBDK8T1iajKzkckMLO91ENDPOaDaiart0Ds9mRb4WS430DkujJCMmvN5FAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;简单翻译一下源码中的注释就是，chromium 在源码中把 Cookie 分为了 6 个优先级，再移除 Cookie 的时候先按照优先级进行排序，然后再依次 LRA 算法删除。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;// 1.  Low-priority non-secure cookies.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 2.  Low-priority secure cookies.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 3.  Medium-priority non-secure cookies.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 4.  High-priority non-secure cookies.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 5.  Medium-priority secure cookies.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 6.  High-priority secure cookies.&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;我们以 &lt;span&gt;www.taobao.com&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt; 为例，打开控制台-应用程序-Cookie，下图中的最后一栏就是Cookie的优先级。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.31933333333333336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybydU03fnz5BLiat5c1AcbiaBDWsp7D1kPlyc79w0TqAUaiaQVpa6xw9TuK1SgnP8n9drDiabcw4RIHSUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;OAuth 和 SSO 之间的关系&lt;/h2&gt;&lt;p&gt;想到统一登录，相信很多人都会想到手机上使用的微信登录、QQ 登录等登入第三方网站的案例。&lt;/p&gt;&lt;p&gt;但事实上，上述这些案例涉及到的是一个名为 OAuth 的协议。只是为用户资源的授权提供了一个安全的、开放而又简易的&lt;strong&gt;标准&lt;/strong&gt;。OAuth 2.0 为客户端开发者开发 Web 应用，桌面端应用程序，移动应用等提供特定的授权流程。这一点和 SSO 有很大的区别。&lt;/p&gt;&lt;p&gt;通俗的讲，OAuth 是为解决&lt;strong&gt;不同公司的不同产品&lt;/strong&gt;实现登录的一种简便授权方案，通常这些授权服务都是由大客户网站提供的，如腾讯，支付宝，淘宝等。而使用这些服务的客户可能是大客户网站，也可能是小客户网站。使用 OAuth 授权的好处是，在为用户提供某些服务时，可减少或避免因用户懒于注册而导致的用户流失问题。&lt;/p&gt;&lt;p&gt;SSO 通常处理的是&lt;strong&gt;同一个公司的不同应用间的访问登录问题&lt;/strong&gt;。如企业应用有很多业务子系统，只需登录一个系统，就可以实现不同子系统间的跳转，而避免了登录操作。&lt;/p&gt;&lt;p&gt;OAuth 与 SSO 的应用场景不同，虽然可以使用 OAuth 实现 SSO，但并不建议这么做。不过，如果 SSO 和 OAuth 结合起来的话，理论上是可以&lt;strong&gt;打通各个公司的各个不同应用间&lt;/strong&gt;的登录，但现实往往是残酷的。&lt;/p&gt;&lt;p&gt;毕竟，这是一个各家都在尽力打造&lt;strong&gt;「生态」&lt;/strong&gt;护城河的互联网时代。&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; DevExpress: &lt;em&gt;https://docs.devexpress.com/AspNet/11912/common-concepts/cookies-support&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; RFC-6265: &lt;em&gt;https://tools.ietf.org/html/rfc6265?spm=ata.21736010.0.0.75512bb3YUmXb0#section-5.3&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; https://chromium.googlesource.com/chromium/src/+/refs/heads/main/net/cookies/cookie_monster.cc?spm=ata.21736010.0.0.75512bb3YUmXb0&amp;amp;file=cookie_monster.cc: &lt;em&gt;https://chromium.googlesource.com/chromium/src/+/refs/heads/main/net/cookies/cookie_monster.cc?spm=ata.21736010.0.0.75512bb3YUmXb0&amp;amp;file=cookie_monster.cc&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; www.taobao.com: &lt;em&gt;http://www.taobao.com&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>268118cb8439131d3895be0d3a4dbe79</guid>
<title>开源单机存储引擎之 LSMTree</title>
<link>https://toutiao.io/k/3znrfgl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;由于工作相关和个人兴趣，之前收集、调研了不少开源的单机存储引擎——精力有限，有些仔细研究过代码，有些只简单浏览和看看文档。整理此文，方便以后参考。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LSMTree&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 是最近几年非常流行的存储引擎，全称是 log-structured merge-tree。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LSMTree 是一种写优化（牺牲读性能）的数据结构。网上关于 LSMTree 的资料很多，这里不多言。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LevelDB&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LevelDB 是我最早接触的 LSMTree 存储引擎，也是曾经学习最深入的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得它最大的特点就是——“精巧”：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;核心代码量只有区区 2 万多行，走读甚至精读一遍代码都花不了太多时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现上，倾向于通用性、简单性，而不是性能。这点对只有 C++ 基础的初学者非常友好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最新版的代码已经用 C++11 简单重构了一遍。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 LevelDB，网上的资料汗牛充栋。我之前也写过一系列 LevelDB 的源码解析文章，这里毛遂自荐一下：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI0NjA1MTU5Ng==&amp;amp;action=getalbum&amp;amp;album_id=1342947967103352833#wechat_redirect&quot; textvalue=&quot;LevelDB 完全解析&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;LevelDB 完全解析&lt;/strong&gt;&lt;/a&gt;（点击跳转），建议搭配官方代码进行品尝。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RocksDB&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7075471698113207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOFlf5wibptRaPlRos5EMrTSdEicSKIWs80mrD2vOpGWXJVvaHKtkyv8OF53r4Xq215b4ysEnBjyPahw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;212&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocksDB 应该是当下最流行的 LSMTree 存储引擎。它是从一个 LevelDB 的 fork 开始的，一路发展过来，加入了许多性能优化和新功能，具体可以参考 &lt;span&gt;RocksDB 的 wiki&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; 和 &lt;span&gt;RocksDB 的官方博客&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比 LevelDB，目前的 RocksDB 要复杂许多，要人肉阅读所有代码逻辑估计有点压力也没必要，建议带着问题去看看 RocksDB 的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，&lt;span&gt;MyRocks&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt; 是一个基于 RocksDB 的 MySQL 存储引擎。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Badger&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1914893617021276&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOFlf5wibptRaPlRos5EMrTSdb1D9lP11JeEM07nFHWdAQbVBSYAfjr5xhvcgZFcorGjLjPZWvkQHVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;235&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Badger 是一个 Go 语言实现的 LSMTree 存储引擎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比 RocksDB，它最大的特点是基于论文 &lt;span&gt;WiscKey: Separating Keys from Values in SSD-conscious Storage&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;，实现了键值分离，有效减小了写放大。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Pebble&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOFlf5wibptRaPlRos5EMrTSdaz7sNEIAQCia2wbTBPVGsKyRbGHnpnyGGPtYwkdsmTxH0Bo9rzCd29g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;340&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pebble 是著名的 NewSQL 项目 &lt;span&gt;CockroachDB&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt; 的存储引擎。CockroachDB 最开始使用的是 RocksDB（&lt;span&gt;Why we built CockroachDB on top of RocksDB&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;），后来因为某些原因（&lt;span&gt;Introducing Pebble: A RocksDB Inspired Key-Value Store Written in Go&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;）替换成 pebble。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pebble 可以认为是 CockroachDB 为自己量身定制（主要是简化，当然也包含一些优化，参考：&lt;span&gt;Pebble vs RocksDB: Implementation Differences&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;）的 RocksDB，用 Go 语言编写（CockroachDB 也是用 Go 语言编写的）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;TerarkDB&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TerarkDB 是一个基于 RocksDB 开发的存储引擎，主要是优化了长尾延迟、吞吐量和压缩率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TerarkDB 并没有大刀阔斧地修改 RocksDB，其最大的特点是实现了一种新的 SST 存储结构 &lt;span&gt;TerarkZipTable&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt;，其特点是拥有极高的压缩率（当然，消耗的 CPU 也会高一些）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;LSMTree: &lt;em&gt;https://en.wikipedia.org/wiki/Log-structured_merge-tree&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;LevelDB: &lt;em&gt;https://github.com/google/leveldb&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;RocksDB: &lt;em&gt;https://github.com/facebook/rocksdb&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;RocksDB 的 wiki: &lt;em&gt;https://github.com/facebook/rocksdb/wiki&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;RocksDB 的官方博客: &lt;em&gt;https://rocksdb.org/blog/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;MyRocks: &lt;em&gt;http://myrocks.io/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;Badger: &lt;em&gt;https://github.com/dgraph-io/badger&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;WiscKey: Separating Keys from Values in SSD-conscious Storage: &lt;em&gt;https://www.usenix.org/system/files/conference/fast16/fast16-papers-lu.pdf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Pebble: &lt;em&gt;https://github.com/cockroachdb/pebble&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;CockroachDB: &lt;em&gt;https://www.cockroachlabs.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;Why we built CockroachDB on top of RocksDB: &lt;em&gt;https://www.cockroachlabs.com/blog/cockroachdb-on-rocksd/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;Introducing Pebble: A RocksDB Inspired Key-Value Store Written in Go: &lt;em&gt;https://www.cockroachlabs.com/blog/pebble-rocksdb-kv-store/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;Pebble vs RocksDB: Implementation Differences: &lt;em&gt;https://github.com/cockroachdb/pebble/blob/master/docs/rocksdb.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;TerarkDB: &lt;em&gt;https://github.com/bytedance/terarkdb&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[15]&lt;/span&gt;&lt;p&gt;TerarkZipTable: &lt;em&gt;https://github.com/bytedance/terark-zip&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3e62aef534f02bd69ab086e10745cc9e</guid>
<title>关于存储技术的最强入门科普</title>
<link>https://toutiao.io/k/xy8d9s9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;a class=&quot;weui-flex original_primary_card appmsg_card_context appmsg_card_active&quot; href=&quot;#&quot; id=&quot;copyright_info&quot;&gt;
                                
                                &lt;div class=&quot;weui-flex__item&quot;&gt;
                                    &lt;strong class=&quot;original_primary_nickname&quot;&gt;鲜枣课堂&lt;/strong&gt;
                                                                            &lt;p class=&quot;original_primary_desc&quot;&gt;学通信，学5G，就上鲜枣课堂！ 我已加入“维权骑士”（rightknights.com）的版权保护计划。&lt;/p&gt;
                                                                    &lt;/div&gt;
                                &lt;p class=&quot;weui-flex__ft&quot;/&gt;
                            &lt;/a&gt;
                        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>