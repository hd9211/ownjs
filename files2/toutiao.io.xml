<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ad5745381a9c1b7947750066369392e2</guid>
<title>困在内卷里的工程师 | 码农周刊第 322 期</title>
<link>https://toutiao.io/k/mb7u8g0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;困在内卷里的工程师 | 码农周刊第 322 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第322期（2020-10-21）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3220&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3220&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;实战经验&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;功能强大、配置简单、完全开源。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;第三代 AI 发展的思路是把第一代的知识驱动和第二代的数据驱动结合起来，通过利用知识、数据、算法和算力等 4 个要素，构造更强大的 AI……&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;斯坦福教授、Tcl 语言发明者 John Ousterhout 的著作《A Philosophy of Software Design》，自出版以来，好评如潮。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;实战经验&lt;/p&gt;
        
        &lt;p&gt;适合新手&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;实用&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 448635 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 429587 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 412364 即可&lt;/p&gt;
        
        &lt;p&gt;编程、成长、正能量！&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 381811 即可&lt;/p&gt;
        
        &lt;p&gt;分享Go语言相关内容&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 133906 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=322&amp;amp;aid=20030&amp;amp;url=https%3A%2F%2Fitem.jd.com%2F12972072.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_322.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;欢迎讨论&lt;/p&gt;
        
        &lt;p&gt;部分适用于百度&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bd2d5ac49dff869824997b9b084c251d</guid>
<title>Java 开发人员必知的常用类库，这些你都知道吗？</title>
<link>https://toutiao.io/k/rxo1rll</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;作为一名程序员，我们要避免重复发明轮子，尽可能使用一些成熟、优秀、稳定的的第三方库，站在巨人的肩膀上搭建可靠、稳定的系统。本篇我整理了Java开发人员经常会使用到的第三方类库，可能不是很全面，还在持续收集整理中，朋友们可以关注我的GitHub上的持续更新，GitHub搜wind7rui/Javalib，或者点击链接https://github.com/wind7rui/Javalib，然后点击watch/Star/Fork，如果您对项目中的内容有建议或者意见，欢迎提出专业方面的建议，共同维护，请直接在GitHub上以issue或者PR的形式提出，以下我们开始本篇的内容。&lt;/p&gt;&lt;h3&gt;应用开发脚手架&lt;/h3&gt;&lt;p&gt;1.Spring Framework&lt;/p&gt;&lt;p&gt;Spring框架为现代基于Java的企业应用程序提供了一个全面的编程和配置模型，使用开发基于Java语言的应用更加简单、便捷。&lt;/p&gt;&lt;p&gt;github：https://github.com/spring-projects/spring-framework/&lt;/p&gt;&lt;p&gt;官网：https://spring.io/projects/spring-framework&lt;/p&gt;&lt;p&gt;2.Spring Boot&lt;/p&gt;&lt;p&gt;Spring Boot使创建独立的、基于Spring的产品级应用程序变得非常容易。&lt;/p&gt;&lt;p&gt;官网：https://spring.io/projects/spring-boot&lt;/p&gt;&lt;p&gt;3.Spring Cloud Spring Cloud为开发人员提供了丰富的使用工具，开发人员基于这些工具可以快速构建分布式系统中的一些常见功能（例如，配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁，领导选举，分布式会话等）。&lt;/p&gt;&lt;p&gt;官网：https://spring.io/projects/spring-cloud&lt;/p&gt;&lt;h3&gt;Web服务接口&lt;/h3&gt;&lt;p&gt;1.Jersey&lt;/p&gt;&lt;p&gt;Jersey是一个REST框架，它提供JAX-RS参考实现等。Jersey提供了自己的api，这些api通过附加的特性和实用程序扩展了JAX-RS工具包，从而进一步简化了RESTful服务和客户端开发。Jersey还公开了许多扩展spi，以便开发人员可以扩展Jersey以最适合他们的需求。&lt;/p&gt;&lt;p&gt;github：https://github.com/eclipse-ee4j/jersey&lt;/p&gt;&lt;p&gt;2.Spring Web MVC&lt;/p&gt;&lt;p&gt;Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就已包含在Spring框架中。正式名称“ Spring Web MVC”来自其源模块的名称（spring-webmvc），但通常称为“Spring MVC”。&lt;/p&gt;&lt;p&gt;官网：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html&lt;/p&gt;&lt;h3&gt;数据持久化框架&lt;/h3&gt;&lt;p&gt;1.MyBatis&lt;/p&gt;&lt;p&gt;MyBatis是一个一流的持久性框架，支持自定义SQL、存储过程和高级映射，它几乎消除了JDBC代码、参数手动设置和结果检索。MyBatis可以使用简单的XML或注释进行配置，并将原语、接口和javapojo（普通的旧Java对象）映射到数据库记录。&lt;/p&gt;&lt;p&gt;官网：https://mybatis.org/mybatis-3/&lt;/p&gt;&lt;p&gt;github：https://github.com/mybatis/mybatis-3&lt;/p&gt;&lt;p&gt;2.Hibernate&lt;/p&gt;&lt;p&gt;Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。&lt;/p&gt;&lt;p&gt;官网：http://hibernate.org/&lt;/p&gt;&lt;h3&gt;Excel读写&lt;/h3&gt;&lt;p&gt;1.Alibaba EasyExcel&lt;/p&gt;&lt;p&gt;Java解析、生成Excel比较有名的框架有Apache poi、jxl。但他们都存在一个严重的问题就是非常的耗内存，poi有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。easyexcel重写了poi对07版Excel的解析，能够原本一个3M的excel用POI sax依然需要100M左右内存降低到几M，并且再大的excel不会出现内存溢出，03版依赖POI的sax模式。在上层做了模型转换的封装，让使用者更加简单方便。&lt;/p&gt;&lt;p&gt;github：https://github.com/alibaba/easyexcel&lt;/p&gt;&lt;p&gt;2.Apache POI&lt;/p&gt;&lt;p&gt;一个用于读写Microsoft Office二进制和OOXML文件格式的Java库，可用于读写Excel 97-2008。&lt;/p&gt;&lt;p&gt;github：https://github.com/apache/poi&lt;/p&gt;&lt;h3&gt;CSV读写&lt;/h3&gt;&lt;p&gt;1.Apache Commons CSV&lt;/p&gt;&lt;p&gt;Apache Commons CSV库提供了用于读取和写入各种类型CSV文件的接口。&lt;/p&gt;&lt;p&gt;github：https://github.com/apache/commons-csv&lt;/p&gt;&lt;p&gt;2.Java CSV&lt;/p&gt;&lt;p&gt;Java CSV是一个小型、快速且开源Java库，用于读、写各种CSV文件。&lt;/p&gt;&lt;p&gt;官网：https://www.csvreader.com/java_csv.php&lt;/p&gt;&lt;p&gt;API：http://javacsv.sourceforge.net/&lt;/p&gt;&lt;p&gt;3.Super CSV&lt;/p&gt;&lt;p&gt;Super CSV是一个快速、免费跨平台的CSV格式数据的读写库，可以方便的处理对象、Map、列表的读写操作，以及自动化的类型转换和数据检查功能。&lt;/p&gt;&lt;p&gt;官网：http://super-csv.github.io/super-csv/index.html&lt;/p&gt;&lt;p&gt;github：https://github.com/super-csv/super-csv&lt;/p&gt;&lt;h3&gt;JSON读写&lt;/h3&gt;&lt;p&gt;1.Jackson&lt;/p&gt;&lt;p&gt;Jackson被称为Java的标准JSON库，号称“Java的最佳JSON解析器”。&lt;/p&gt;&lt;p&gt;github：https://github.com/FasterXML/jackson&lt;/p&gt;&lt;p&gt;2.Gson&lt;/p&gt;&lt;p&gt;Gson是谷歌开源的一个Java库，可用于将Java对象转换为其JSON表示形式。它还可以用于将JSON字符串转换为等效的Java对象。Gson可以处理任意Java对象，包括您没有源代码的现有对象。&lt;/p&gt;&lt;p&gt;github：https://github.com/google/gson&lt;/p&gt;&lt;p&gt;3.fastjson&lt;/p&gt;&lt;p&gt;fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。&lt;/p&gt;&lt;p&gt;github：https://github.com/alibaba/fastjson&lt;/p&gt;&lt;h3&gt;XML读写&lt;/h3&gt;&lt;p&gt;1.dom4j&lt;/p&gt;&lt;p&gt;dom4j是用于处理XML的开源框架，该框架与XPath集成在一起，并完全支持DOM、SAX、JAXP和Java平台。&lt;/p&gt;&lt;p&gt;github：https://github.com/dom4j/dom4j&lt;/p&gt;&lt;p&gt;官网：https://dom4j.github.io/&lt;/p&gt;&lt;p&gt;2.StAX&lt;/p&gt;&lt;p&gt;StAX全称Streaming API for XML，一种全新的、基于流的Java XML解析标准类库。&lt;/p&gt;&lt;p&gt;3.jaxb-api&lt;/p&gt;&lt;p&gt;jaxb-api用于执行XML文档和Java对象之间的映射。&lt;/p&gt;&lt;p&gt;文档：https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXB.html&lt;/p&gt;&lt;p&gt;4.XStream&lt;/p&gt;&lt;p&gt;XStream是一个可以轻易的将Java对象和xml文档相互转换的类库。&lt;/p&gt;&lt;p&gt;官网：http://x-stream.github.io/&lt;/p&gt;&lt;h3&gt;IO读写&lt;/h3&gt;&lt;p&gt;1.Apache Commons IO Apache Commons IO是一个实用程序库，可协助开发IO功能。&lt;/p&gt;&lt;p&gt;官网：https://commons.apache.org/proper/commons-io/&lt;/p&gt;&lt;p&gt;2.Okio&lt;/p&gt;&lt;p&gt;Okio是对java.io和java.nio的补充，使访问、存储和处理数据变得更加容易。&lt;/p&gt;&lt;p&gt;github：https://github.com/square/okio&lt;/p&gt;&lt;h3&gt;HTTP客户端&lt;/h3&gt;&lt;p&gt;1.OkHttp&lt;/p&gt;&lt;p&gt;OkHttp是一个HTTP客户端，使用OkHttp很容易，它的请求/响应API具有流畅的构建器和不变性。它支持同步阻塞调用和带有回调的异步调用。&lt;/p&gt;&lt;p&gt;github：https://github.com/square/okhttp&lt;/p&gt;&lt;p&gt;官网：https://square.github.io/okhttp/&lt;/p&gt;&lt;p&gt;2.Apache HttpClient&lt;/p&gt;&lt;p&gt;Apache HttpClient提供了对基本HTTP协议的强大支持，用于构建基于HTTP的客户端。&lt;/p&gt;&lt;p&gt;官网：http://hc.apache.org/index.html&lt;/p&gt;&lt;p&gt;github：https://github.com/apache/httpcomponents-client&lt;/p&gt;&lt;h3&gt;Java Bean复制&lt;/h3&gt;&lt;p&gt;1.Cglib BeanCopier&lt;/p&gt;&lt;p&gt;Cglib库内的BeanCopier提供了ava Bean到Java Bean的复制功能，性能优于Spring BeanUtils。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;BeanCopier&lt;/span&gt;&lt;span&gt; beanCopier &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;BeanCopier&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;sourceClass&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; targetClass&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;beanCopier&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; target&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;2.Spring BeanUtils&lt;/p&gt;&lt;p&gt;Spring框架的Spring Beans库中的BeanUtils也实现了Java Bean到Java Bean的复制。&lt;/p&gt;&lt;p&gt;3.Dozer&lt;/p&gt;&lt;p&gt;Dozer是Java Bean到Java Bean映射器，它以递归方式将数据从一个对象复制到另一个对象。Dozer支持简单属性映射、复杂类型映射、双向映射、隐式显式映射以及递归映射。Dozer不仅支持属性名称之间的映射，而且还可以在类型之间自动转换。开箱即用地支持大多数转换方案，同时也允许您通过XML或基于代码的配置指定自定义转换。&lt;/p&gt;&lt;p&gt;github：https://github.com/DozerMapper/dozer&lt;/p&gt;&lt;p&gt;文档：https://dozermapper.github.io/gitbook/&lt;/p&gt;&lt;h3&gt;Redis客户端&lt;/h3&gt;&lt;p&gt;1.Redission&lt;/p&gt;&lt;p&gt;Redis推荐的Java客户端Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid），它充分利用了Redis键值数据库提供的一系列优势，基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类，让使用Redis更加简单、便捷，从而让使用者能够将更多精力集中到业务逻辑处理上。&lt;/p&gt;&lt;p&gt;github：https://github.com/redisson/redisson/&lt;/p&gt;&lt;p&gt;2.Jedis&lt;/p&gt;&lt;p&gt;Redis推荐的Java客户端。&lt;/p&gt;&lt;p&gt;github：https://github.com/xetorthio/jedis&lt;/p&gt;&lt;h3&gt;数据库连接池&lt;/h3&gt;&lt;p&gt;数据库连接池提供了一套高效的连接分配、使用策略， 最终实现连接的高效管理。&lt;/p&gt;&lt;p&gt;1.HikariCP&lt;/p&gt;&lt;p&gt;快速、简单、可靠。HikariCP是“零开销”生产就绪的JDBC连接池。&lt;/p&gt;&lt;p&gt;github：https://github.com/brettwooldridge/HikariCP&lt;/p&gt;&lt;p&gt;2.Druid&lt;/p&gt;&lt;p&gt;Druid是Java语言中最好的数据库连接池之一，Druid能够提供强大的监控和扩展功能。&lt;/p&gt;&lt;p&gt;github：https://github.com/alibaba/druid/&lt;/p&gt;&lt;p&gt;3.Tomcat JDBC&lt;/p&gt;&lt;p&gt;JDBC连接池是Apache Commons DBCP连接池的替代品。&lt;/p&gt;&lt;p&gt;官网：http://tomcat.apache.org/tomcat-7.0-doc/jdbc-pool.html&lt;/p&gt;&lt;h3&gt;网络编程&lt;/h3&gt;&lt;p&gt;1.Netty&lt;/p&gt;&lt;p&gt;Netty是一个广泛使用的Java网络编程框架。&lt;/p&gt;&lt;p&gt;github：https://github.com/netty/netty&lt;/p&gt;&lt;p&gt;官网：https://netty.io/&lt;/p&gt;&lt;h3&gt;文件上传&lt;/h3&gt;&lt;p&gt;1.Apache Commons FileUpload&lt;/p&gt;&lt;p&gt;Apache Commons FileUpload使高性能的文件上传功能变得容易。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-fileupload/&lt;/p&gt;&lt;h3&gt;发送邮件&lt;/h3&gt;&lt;p&gt;1.Apache Commons Email&lt;/p&gt;&lt;p&gt;Apache commons Email旨在提供用于发送电子邮件的API，它建立在Java Mail API之上，它的目标就是简便。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-email/&lt;/p&gt;&lt;h3&gt;编码和解码&lt;/h3&gt;&lt;p&gt;1.Apache Commons Codec&lt;/p&gt;&lt;p&gt;Apache Commons Codec提供了常见编码器和解码器的实现，例如Base64，Hex，Phonetic和URL。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-codec/&lt;/p&gt;&lt;h3&gt;IO操作&lt;/h3&gt;&lt;p&gt;1.Apache Commons IO&lt;/p&gt;&lt;p&gt;简单、快捷的IO操作。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-io/index.html&lt;/p&gt;&lt;p&gt;对象池&lt;/p&gt;&lt;p&gt;1.Apache Commons Pool&lt;/p&gt;&lt;p&gt;提供了通用对象池。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-pool/&lt;/p&gt;&lt;h3&gt;java.lang包工具类&lt;/h3&gt;&lt;p&gt;1.Apache Commons Lang&lt;/p&gt;&lt;p&gt;为java.lang中的类提供额外的功能，例如StringUtils、DateUtils、RandomUtils、FastDateFormat(线程安全版本的SimpleDateFormat)。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-lang/index.html&lt;/p&gt;&lt;h3&gt;集合操作&lt;/h3&gt;&lt;p&gt;1.Apache Commons Collections&lt;/p&gt;&lt;p&gt;集合相关操作工具类。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-collections/&lt;/p&gt;&lt;p&gt;2.Guava&lt;/p&gt;&lt;p&gt;Guava是Google的一组核心Java库，除了可以操作我们常用的集合类型之外，还可以操作新的集合类型（例如多图和多集）和不可变的集合。&lt;/p&gt;&lt;p&gt;github：https://github.com/google/guava&lt;/p&gt;&lt;h3&gt;全能型工具类&lt;/h3&gt;&lt;p&gt;1.Guava&lt;/p&gt;&lt;p&gt;Guava是Google的一组核心Java库，其中包括新的集合类型（例如多图和多集），不可变的集合，图形库以及用于并发，I / O，哈希，缓存，基元，字符串等的实用程序！它广泛用于Google的大多数Java项目中，也被许多其他公司广泛使用。&lt;/p&gt;&lt;p&gt;github：https://github.com/google/guava&lt;/p&gt;&lt;p&gt;2.Hutool&lt;/p&gt;&lt;p&gt;Hutool是一个Java工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让Java语言也可以“甜甜的”。&lt;/p&gt;&lt;p&gt;github：https://github.com/looly/hutool&lt;/p&gt;&lt;h3&gt;日期和时间操作&lt;/h3&gt;&lt;p&gt;1.Joda-Time&lt;/p&gt;&lt;p&gt;Joda-Time提供了Java日期和时间类的质量替代。&lt;/p&gt;&lt;p&gt;官网：https://www.joda.org/joda-time/&lt;/p&gt;&lt;h3&gt;单元测试&lt;/h3&gt;&lt;p&gt;1.JUnit&lt;/p&gt;&lt;p&gt;官网：https://junit.org/junit5/&lt;/p&gt;&lt;p&gt;2.Mockito&lt;/p&gt;&lt;p&gt;Mockito是一个Java单元测试模拟框架。&lt;/p&gt;&lt;p&gt;官网：https://site.mockito.org/&lt;/p&gt;&lt;p&gt;3.PowerMock&lt;/p&gt;&lt;p&gt;PowerMock也是一个Java单元测试模拟框架，它可以模拟静态方法、构造函数、最终类和方法、私有方法、删除静态初始化器等。&lt;/p&gt;&lt;p&gt;官网：http://powermock.github.io/&lt;/p&gt;&lt;p&gt;4.moco&lt;/p&gt;&lt;p&gt;在日常接口测试的工作中，经常需要依赖其他系统的API，但是联调不常有，只能自己通过mock完成数据依赖。Moco是一个模拟服务器端服务的项目，可以用于测试打桩。&lt;/p&gt;&lt;p&gt;github：https://github.com/dreamhead/moco&lt;/p&gt;&lt;h3&gt;安全框架&lt;/h3&gt;&lt;p&gt;1.Apache Shiro&lt;/p&gt;&lt;p&gt;Apache Shiro是一个功能强大且易于使用的Java安全框架，它用于身份验证、授权、加密和会话管理。使用Shiro易于理解的API，可以快速轻松地保护任何应用程序，从最小的移动应用程序到最大的Web和企业应用程序。&lt;/p&gt;&lt;p&gt;官网：http://shiro.apache.org/&lt;/p&gt;&lt;h3&gt;日志&lt;/h3&gt;&lt;p&gt;1.SLF4J + Logback&lt;/p&gt;&lt;p&gt;SLF4J是为各种loging APIs提供一个简单统一的接口，从而使得最终用户能够在部署的时候配置自己希望的loging APIs实现，它是一个日志接口。&lt;/p&gt;&lt;p&gt;Logback是由log4j创始人设计的又一个开源日志组件，它是一个日志的实现。&lt;/p&gt;&lt;p&gt;SLF4J官网：http://www.slf4j.org/&lt;/p&gt;&lt;p&gt;Logback官网：https://logback.qos.ch/&lt;/p&gt;&lt;h3&gt;对象池&lt;/h3&gt;&lt;p&gt;1.Apache Commons Pool&lt;/p&gt;&lt;p&gt;Apache Commons Pool提供了对象池API和一系列对象池实现。&lt;/p&gt;&lt;p&gt;官网：https://commons.apache.org/proper/commons-pool/&lt;/p&gt;&lt;h3&gt;基本网络通讯&lt;/h3&gt;&lt;p&gt;1.Apache Commons Net&lt;/p&gt;&lt;p&gt;Apache Commons Net库实现了许多基本互联网协议的客户端。该库的目的是提供基本协议访问，而不是更高级别的抽象。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-net/index.html&lt;/p&gt;&lt;h3&gt;作业调度框架(定时任务)&lt;/h3&gt;&lt;p&gt;1.Quartz&lt;/p&gt;&lt;p&gt;Quartz是一个开源的作业调度框架，它完全由Java编写，能够用它来为执行一个作业而创建简单的或复杂的调度。&lt;/p&gt;&lt;p&gt;官网：http://www.quartz-scheduler.org/&lt;/p&gt;&lt;p&gt;github：https://github.com/quartz-scheduler/quartz&lt;/p&gt;&lt;p&gt;2.ElasticJob&lt;/p&gt;&lt;p&gt;ElasticJob是一种分布式调度解决方案，解决了Quartz不支持分布式的弊端。Elastic job主要的功能有支持弹性扩容，通过Zookepper集中管理和监控job，支持失效转移等。&lt;/p&gt;&lt;p&gt;github：https://github.com/apache/shardingsphere-elasticjob&lt;/p&gt;&lt;h3&gt;配置中心&lt;/h3&gt;&lt;p&gt;1.Nacos&lt;/p&gt;&lt;p&gt;Nacos是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。Nacos的动态配置服务让您能够以中心化、外部化和动态化的方式管理所有环境的配置。动态配置消除了配置变更时重新部署应用和服务的需要。配置中心化管理让实现无状态服务更简单，也让按需弹性扩展服务更容易。&lt;/p&gt;&lt;p&gt;官网：https://nacos.io/&lt;/p&gt;&lt;p&gt;github：https://github.com/alibaba/nacos&lt;/p&gt;&lt;p&gt;2.Spring Cloud Config&lt;/p&gt;&lt;p&gt;Spring Cloud Config为分布式系统中的外部化配置提供服务器端和客户端支持。使用Config Server，您可以在中心位置管理所有环境中应用程序的外部属性。&lt;/p&gt;&lt;p&gt;文档：https://cloud.spring.io/spring-cloud-config/reference/html/&lt;/p&gt;&lt;p&gt;3.Apollo&lt;/p&gt;&lt;p&gt;Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。&lt;/p&gt;&lt;p&gt;github：https://github.com/ctripcorp/apollo&lt;/p&gt;&lt;h3&gt;限流&lt;/h3&gt;&lt;p&gt;1.Guava RateLimiter&lt;/p&gt;&lt;p&gt;RateLimiter基于令牌桶算法，即以用户设定的恒定速率向令牌桶内放置令牌，用户来执行任务时，只有拿到令牌才能执行。&lt;/p&gt;&lt;p&gt;2.Sentinel&lt;/p&gt;&lt;p&gt;Sentinel是面向分布式服务架构的高可用防护组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助用户保障微服务的稳定性。&lt;/p&gt;&lt;p&gt;官网：https://sentinelguard.io/&lt;/p&gt;&lt;p&gt;github：https://github.com/alibaba/Sentinel&lt;/p&gt;&lt;h3&gt;熔断降级&lt;/h3&gt;&lt;p&gt;当调用链路中某个资源出现不稳定，例如，表现为timeout，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。&lt;/p&gt;&lt;p&gt;1.Sentinel&lt;/p&gt;&lt;p&gt;Sentinel通过并发线程数进行限制和通过响应时间对资源进行降级两种手段对资源调用进行限制，让请求快速失败，避免影响到其它的资源。&lt;/p&gt;&lt;p&gt;官网：https://sentinelguard.io/&lt;/p&gt;&lt;p&gt;github：https://github.com/alibaba/Sentinel&lt;/p&gt;&lt;p&gt;2.Hystrix&lt;/p&gt;&lt;p&gt;Hystrix 通过线程池的方式，来对资源进行了隔离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成本，还需要预先给各个资源做线程池大小的分配。Hystrix不再处于主动开发中，并且当前处于维护模式，官方推荐使用Resilience4j替代。&lt;/p&gt;&lt;p&gt;github：https://github.com/Netflix/Hystrix&lt;/p&gt;&lt;p&gt;3.Resilience4j&lt;/p&gt;&lt;p&gt;Resilience4j是受Netflix Hystrix启发的轻量级容错库，但专为Java 8和函数式编程而设计。轻巧，因为该库仅使用Vavr，而Vavr没有任何其他外部库依赖项。&lt;/p&gt;&lt;p&gt;github：https://github.com/resilience4j/resilience4j&lt;/p&gt;&lt;h3&gt;分库分表&lt;/h3&gt;&lt;p&gt;1.Apache ShardingSphere&lt;/p&gt;&lt;p&gt;Apache ShardingSphere定位为关系型数据库中间件，旨在充分合理地在分布式的场景下利用关系型数据库的计算和存储能力，而并非实现一个全新的关系型数据库。支持数据分片、读写分离、多数据副本、数据加密、影子库压测等功能。&lt;/p&gt;&lt;p&gt;官网：https://shardingsphere.apache.org/&lt;/p&gt;&lt;p&gt;github：https://github.com/apache/shardingsphere&lt;/p&gt;&lt;p&gt;2.Mycat&lt;/p&gt;&lt;p&gt;Mycat是数据库分库分表中间件。&lt;/p&gt;&lt;p&gt;官网：http://www.mycat.org.cn/&lt;/p&gt;&lt;p&gt;github：https://github.com/MyCATApache&lt;/p&gt;&lt;h3&gt;序列化&lt;/h3&gt;&lt;p&gt;1.Kryo&lt;/p&gt;&lt;p&gt;Kryo是用于Java的快速高效的二进制对象图序列化框架。该项目的目标是高速，小尺寸和易于使用的API。每当需要将对象持久保存到文件，数据库还是通过网络时，该项目都是有用的。&lt;/p&gt;&lt;p&gt;github：https://github.com/EsotericSoftware/kryo&lt;/p&gt;&lt;p&gt;2.Hessian&lt;/p&gt;&lt;p&gt;Hessian是一款支持多种语言进行序列化操作的框架技术，同时在进行序列化之后产生的码流也较小，处理数据的性能方面远超于java内置的jdk序列化方式。&lt;/p&gt;&lt;p&gt;官网：http://hessian.caucho.com/&lt;/p&gt;&lt;p&gt;3.Protobuf&lt;/p&gt;&lt;p&gt;Protobuf是谷歌开源的一个灵活的、高效的用于序列化数据的协议。相比较XML和JSON格式，protobuf更小、更快、更便捷。&lt;/p&gt;&lt;p&gt;github：https://github.com/protocolbuffers/protobuf&lt;/p&gt;&lt;p&gt;官网：https://developers.google.com/protocol-buffers/&lt;/p&gt;&lt;h3&gt;RPC框架&lt;/h3&gt;&lt;p&gt;1.Dubbo Apache Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。&lt;/p&gt;&lt;p&gt;官网：http://dubbo.apache.org/zh-cn/&lt;/p&gt;&lt;p&gt;github：https://github.com/apache/dubbo&lt;/p&gt;&lt;p&gt;2.Thrift Thrift是一个软件框架（远程过程调用框架），用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml这些编程语言间无缝结合的、高效的服务。Thrift最初由facebook开发，07年四月开放源码，08年5月进入apache孵化器，现在是 Apache 基金会的顶级项目。Thrift允许你定义一个简单的定义文件中的数据类型和服务接口，以作为输入文件，编译器生成代码用来方便地生成RPC客户端和服务器通信的无缝跨编程语言。&lt;/p&gt;&lt;p&gt;官网：http://thrift.apache.org/&lt;/p&gt;&lt;p&gt;3.gRPC gRPC是一个现代的、开源的、高性能的远程过程调用（RPC）框架，可以在任何地方运行。gRPC使客户机和服务器应用程序能够透明地通信，并简化了连接系统的构建。目前提供C、Java和Go语言版本，分别是：grpc, grpc-java, grpc-go. 其中C版本支持C, C++, Node.js, Python, Ruby, Objective-C, PHP和C#支持。&lt;/p&gt;&lt;p&gt;官网：https://www.grpc.io/&lt;/p&gt;&lt;p&gt;github：https://github.com/grpc/grpc&lt;/p&gt;&lt;p&gt;&lt;strong&gt;学之多，而后知之少&lt;/strong&gt;&lt;span&gt;！以上是本次分享的内容，朋友们点【在看】是我持续更新的最大动力，我们下期见！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKSxTAD3licFmGltOsliao1ZVHCicnRtbiarMjXCkm2y0FjRlsJ596O4ibOAoOib1XWGhXlYX8x0wYXIPfxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5555555555555556&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1dbb2bf741b9549e5eef4fc743ce62b2</guid>
<title>工具 | 阿里云开源的，业界首个面向 NLP 场景的深度迁移学习框架</title>
<link>https://toutiao.io/k/6ic2uca</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「码农周刊 VIP 会员」推出 27 周啦！感谢亲们的大力支持！第 027 期「码农周刊 VIP 会员专属邮件周报」已发送完毕，请注意查收。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;告诉大家一个好消息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：已有数位上市公司 CTO 低调订阅了我们的「码农周刊 VIP 会员专属邮件周报」，感谢肯定！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;255&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;255&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ7PeUupLzwuuAibicnrRNxKcfCY7fIva78efKsUzANlCCAeuSQEGkGm34rKkzNRpzy6IiaiaHmBNA6DcA/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1104&quot; data-ratio=&quot;2.3813333333333335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNav8r1ZB0Itre4ibxj1z0OYzNcKXyymnmibCRfGyTQIklAmeUfng7v0qcqLn850ibUTlM0Ns0FGBL99icIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「码农周刊 VIP 会员」是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简介版&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊 VIP 会员 = 全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;详细版&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击「阅读原文」即可查看详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;加入「码农周刊 VIP 会员」，与上市公司 CTO 一起成长！&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利，你值得拥有！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;260&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.3478260869565217&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ55lkiaIfFtAvQ7oklJLhfYEwMXeZORosBgxxRzEaXjYiapBSev2CQfYfl7kTiaFqsoiaicGyvcKIHzcSg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8b65ee28a7a1ab6934d7f6b8679cd6c3</guid>
<title>进阶必看的 RocketMQ ，就这篇了</title>
<link>https://toutiao.io/k/utkv7cg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;每个时代，都不会亏待会学习的人。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继上一篇 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjEyNTk1Ng==&amp;amp;mid=2247485725&amp;amp;idx=1&amp;amp;sn=6a46ae2cd15984d74f0b39cecda271de&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;头条终面：写个消息中间件&lt;/a&gt; ，我提到实现消息中间件的一些关键点，今天就和大家一起深入生产级别消息中间件 - RocketMQ 的内核实现，来看看真正落地能支撑万亿级消息容量、低延迟的消息队列到底是如何设计的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章我会&lt;span&gt;先介绍整体的架构设计，然后再深入各核心模块的详细设计、核心流程的剖析&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还会提及使用的一些&lt;span&gt;注意点和最佳实践&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于消息队列的用处和一些概念不太清楚的同学强烈建议先看&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjEyNTk1Ng==&amp;amp;mid=2247484130&amp;amp;idx=1&amp;amp;sn=0a936cc7f03074f1eb2e0a8d35de1423&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;消息队列面试连环问&lt;/a&gt;，这篇文章介绍了消息队列的使用场景、基本概念和常见面试题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话不多说，上车。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RocketMQ 整体架构设计&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体的架构设计主要分为四大部分，分别是：Producer、Consumer、Broker、NameServer。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5022341376228776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODlxwr76ORc4q0iccPZ698jibp5RvwGmFYyAoibDtNQrxcUmUdwqwiaHlZpFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1119&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更贴合实际，我画的都是集群部署，像 Broker 我还画了主从。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Producer：就是消息生产者，可以集群部署。它会先和 NameServer 集群中的随机一台建立长连接，得知当前要发送的 Topic 存在哪台 Broker Master上，然后再与其建立长连接，支持多种负载平衡模式发送消息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Consumer：消息消费者，也可以集群部署。它也会先和 NameServer 集群中的随机一台建立长连接，得知当前要消息的 Topic 存在哪台 Broker Master、Slave上，然后它们建立长连接，支持集群消费和广播消费消息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Broker：主要负责消息的存储、查询消费，支持主从部署，一个 Master 可以对应多个 Slave，Master 支持读写，Slave 只支持读。&lt;span&gt;Broker 会向集群中的每一台 NameServer 注册自己的路由信息。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;NameServer：是一个很简单的 Topic 路由注册中心，支持 Broker 的动态注册和发现，保存 Topic 和 Borker 之间的关系。通常也是集群部署，但是&lt;span&gt;各 NameServer 之间不会互相通信， 各 NameServer 都有完整的路由信息&lt;/span&gt;，即无状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我再用一段话来概括它们之间的交互：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODln1onPPzgicuPLOS2DtShMZ02ibTLBdCw971N35CAicKsdP27FFOXs3tPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;220&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先启动 NameServer 集群，各 NameServer 之间无任何数据交互，Broker 启动之后会向所有 NameServer 定期（每 30s）发送心跳包，包括：IP、Port、TopicInfo，NameServer 会定期扫描 Broker 存活列表，如果超过 120s 没有心跳则移除此 Broker 相关信息，代表下线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样每个 NameServer 就知道集群所有 Broker 的相关信息，此时 Producer 上线从 NameServer 就可以得知它要发送的某 Topic 消息在哪个 Broker 上，和对应的 Broker （Master 角色的）建立长连接，发送消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer 上线也可以从 NameServer  得知它所要接收的 Topic 是哪个 Broker ，和对应的 Master、Slave 建立连接，接收消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单的工作流程如上所述，相信大家对整体数据流转已经有点印象了，我们再来看看每个部分的详细情况。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;NameServer&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的特点就是轻量级，无状态。角色类似于 Zookeeper 的情况，从上面描述知道其主要的两个功能就是：Broker 管理、路由信息管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体而言比较简单，我再贴一些字段，让大家有更直观的印象知道它存储了些什么。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.10580912863070539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODlBDQNqFQCjLJ5HZzvSD1Y4uLhws7dVEXmFbI2S3TIM6ArSu5P5dna9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Producer&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Producer 无非就是消息生产者，那首先它得知道消息要发往哪个 Broker ，于是每 30s 会从某台 NameServer 获取 Topic 和 Broker 的映射关系存在本地内存中，如果发现新的 Broker 就会和其建立长连接，每 30s 会发送心跳至 Broker 维护连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且会&lt;span&gt;轮询当前可以发送的 Broker 来发送消息&lt;/span&gt;，达到负载均衡的目的，在&lt;span&gt;同步发送情况&lt;/span&gt;下如果发送失败会默认重投两次（retryTimesWhenSendFailed = 2），并且不会选择上次失败的 broker，会向其他 broker 投递。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;span&gt;异步发送&lt;/span&gt;失败的情况下也会重试，默认也是两次 （retryTimesWhenSendAsyncFailed = 2），但是仅在同一个 Broker 上重试。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Producer 启动流程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们再来看看 Producer 的启动流程看看都干了些啥。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6401617250673854&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODlSlFukg4kEwKDSZT7x78T4lvKCiao3yRxsohMvl0nxUs2YtZhmicTrEMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致启动流程图中已经表明的很清晰的，但是有些细节可能还不清楚，比如重平衡啊，TBW102 啥玩意啊，有哪些定时任务啊，别急都会提到的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人可能会问这生产者为什么要启拉取服务、重平衡？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 Producer 和 Consumer 都需要用 MQClientInstance，而同一个 clientId 是共用一个 MQClientInstance 的， clientId 是通过本机 IP 和 instanceName（默认值 default）拼起来的，所以多个 Producer 、Consumer 实际用的是一个MQClientInstance。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于有哪些定时任务，请看下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24500525762355416&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODl7hcdDSD6oH36Y998oicgMGicQI97TLk3wqookcQ5iaP0A8huDp0HtkRdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;951&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Producer 发消息流程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看看发消息的流程，大致也不是很复杂，无非就是找到要发送消息的 Topic 在哪个 Broker 上，然后发送消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8962131837307152&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODlvIaBJHR57OJFZs1ianTtA3iaYMHW2P5JCK2uPHiaXVCzLcOZbbHJTKhvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在就知道 TBW102 是啥用的，就是接受自动创建主题的 Broker 启动会把这个默认主题登记到 NameServer，这样当 Producer 发送新 Topic 的消息时候就得知哪个 Broker 可以自动创建主题，然后发往那个 Broker。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 Broker 接受到这个消息的时候发现没找到对应的主题，但是它接受创建新主题，这样就会创建对应的 Topic 路由信息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;自动创建主题的弊端&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自动创建主题那么有可能该主题的消息都只会发往一台 Broker，起不到负载均衡的作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为创建新 Topic 的请求到达 Broker 之后，Broker 创建对应的路由信息，但是心跳是每 30s 发送一次，所以说 NameServer 最长需要 30s 才能得知这个新 Topic 的路由信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设此时发送方还在连续快速的发送消息&lt;/span&gt;，那 NameServer 上其实还没有关于这个 Topic 的路由信息，所以&lt;span&gt;有机会&lt;/span&gt;让别的允许自动创建的 Broker 也创建对应的 Topic 路由信息，这样集群里的 Broker 就能接受这个 Topic 的信息，达到负载均衡的目的，但也有个别 Broker 可能，没收到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果发送方这一次发了之后 30s 内一个都不发，之前的那个 Broker 随着心跳把这个路由信息更新到 NameServer 了，那么之后发送该 Topic 消息的 Producer 从 NameServer 只能得知该 Topic 消息只能发往之前的那台 Broker ，这就不均衡了，如果这个新主题消息很多，那台 Broker 负载就很高了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以不建议线上开启允许自动创建主题，即 autoCreateTopicEnable 参数。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;发送消息故障延迟机制&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个参数是 sendLatencyFaultEnable，默认不开启。这个参数的作用是对于之前发送超时的 Broker 进行一段时间的退避。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发送消息会记录此时发送消息的时间，如果超过一定时间，那么此 Broker 就在一段时间内不允许发送。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08833922261484099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODln7RiaGMqcicrlScIk8HbY07qcCg1BJ8ibibeJetysuuWicqNQy3DGm8iaUKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;849&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如发送时间超过 15000ms 则在 600000 ms 内无法向该 Broker 发送消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个机制其实很关键，发送超时大概率表明此 Broker 负载高，所以先避让一会儿，让它缓一缓，这也是实现消息发送高可用的关键。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结一下&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Producer 每 30s 会向 NameSrv 拉取路由信息更新本地路由表，有新的 Broker 就和其建立长连接，每隔 30s 发送心跳给 Broker 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要在生产环境开启 autoCreateTopicEnable。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Producer 会通过重试和延迟机制提升消息发送的高可用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Broker&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Broker 就比较复杂一些了，但是非常重要。大致分为以下五大模块，我们来看一下官网的图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5023255813953489&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODl6cY89rZ0fdg9ZqF4hPkoy5faWV8t8MYAavsw4icN7keCOibKPJBKoumQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;860&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Remoting 远程模块，处理客户请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Client Manager 管理客户端，维护订阅的主题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Store Service 提供消息存储查询服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HA Serivce，主从同步高可用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Index Serivce，通过指定key 建立索引，便于查询。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有几个模块没啥可说的就不分析了，先看看存储的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Broker 的存储&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 存储用的是本地文件存储系统，效率高也可靠。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要涉及到三种类型的文件，分别是 CommitLog、ConsumeQueue、IndexFile。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CommitLog&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 的所有主题的消息都存在 CommitLog 中，单个 CommitLog 默认 1G，并且文件名以起始偏移量命名，固定 20 位，不足则前面补 0，比如 00000000000000000000 代表了第一个文件，第二个文件名就是 00000000001073741824，表明起始偏移量为 1073741824，以这样的方式命名用偏移量就能找到对应的文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有消息都是顺序写入的，超过文件大小则开启下一个文件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ConsumeQueue&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConsumeQueue 消息消费队列，可以认为是 CommitLog 中消息的索引，因为 CommitLog 是糅合了所有主题的消息，所以通过索引才能更加高效的查找消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConsumeQueue 存储的条目是固定大小，只会存储 8 字节的 commitlog 物理偏移量，4 字节的消息长度和 8 字节 Tag 的哈希值，固定 20 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际存储中，ConsumeQueue 对应的是一个Topic 下的某个 Queue，每个文件约 5.72M，由 30w 条数据组成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者是先从 ConsumeQueue 来得到消息真实的物理地址，然后再去 CommitLog 获取消息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;IndexFile&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IndexFile 就是索引文件，是额外提供查找消息的手段，不影响主流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 Key 或者时间区间来查询对应的消息，文件名以创建时间戳命名，固定的单个 IndexFile 文件大小约为400M，一个 IndexFile 存储 2000W个索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看看以上三种文件的内容是如何生成的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5296610169491526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODlgrMwbA8FJgiavy2NicTUEQmIyxUGzDP3TGmFlG9vMmGs5fUaHN4OqLjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;944&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息到了先存储到 Commitlog，然后会有一个 ReputMessageService 线程接近实时地将消息转发给消息消费队列文件与索引文件，也就是说是异步生成的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息刷盘机制&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 提供消息同步刷盘和异步刷盘两个选择，关于刷盘我们都知道效率比较低，单纯存入内存中的话效率是最高的，但是可靠性不高，影响消息可靠性的情况大致有以下几种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Broker 被暴力关闭，比如 kill -9&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Broker 挂了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;操作系统挂了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;机器断电&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;机器坏了，开不了机&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;磁盘坏了&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果都是 1-4 的情况，同步刷盘肯定没问题，异步的话就有可能丢失部分消息，5 和 6就得依靠副本机制了，如果同步双写肯定是稳的，但是性能太差，如果异步则有可能丢失部分消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以需要看场景来使用同步、异步刷盘和副本双写机制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;页缓存与内存映射&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Commitlog 是混合存储的，所以所有消息的写入就是顺序写入，对文件的顺序写入和内存的写入速度基本上没什么差别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且 RocketMQ 的文件都利用了内存映射即 Mmap，将程序虚拟页面直接映射到页缓存上，无需有内核态再往用户态的拷贝，来看一下我之前文章画的图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4167424931756142&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODlUMw38VO0lqGCrKP3rQPqUQNcMCwhju5jWERAen3MrfiawkNSpOPVqXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1099&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;页缓存其实就是操作系统对文件的缓存，用来加速文件的读写，也就是说对文件的写入先写到页缓存中，操作系统会不定期刷盘（时间不可控），对文件的读会先加载到页缓存中，并且根据局部性原理还会预读临近块的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实也是因为使用内存映射机制，所以 RocketMQ 的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文件预分配和文件预热&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而内存映射也只是做了映射，只有当真正读取页面的时候产生缺页中断，才会将数据真正加载到内存中，所以 RocketMQ 做了一些优化，防止运行时的性能抖动。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文件预分配&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CommitLog 的大小默认是1G，当超过大小限制的时候需要准备新的文件，而 RocketMQ 就起了一个后台线程 AllocateMappedFileService，不断的处理 AllocateRequest，AllocateRequest 其实就是预分配的请求，会提前准备好下一个文件的分配，防止在消息写入的过程中分配文件，产生抖动。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文件预热&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个 warmMappedFile 方法，它会把当前映射的文件，每一页遍历多去，写入一个0字节，然后再调用mlock 和 madvise(MADV_WILLNEED)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mlock：可以将进程使用的部分或者全部的地址空间锁定在物理内存中，防止其被交换到 swap 空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;madvise：给操作系统建议，说这文件在不久的将来要访问的，因此，提前读几页可能是个好主意。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结一下&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CommitLog 采用混合型存储，也就是所有 Topic 都存在一起，顺序追加写入，文件名用起始偏移量命名。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息先写入 CommitLog 再通过后台线程分发到 ConsumerQueue 和 IndexFile 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者先读取 ConsumerQueue 得到真正消息的物理地址，然后访问 CommitLog 得到真正的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用了 mmap 机制减少一次拷贝，利用文件预分配和文件预热提高性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提供同步和异步刷盘，根据场景选择合适的机制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Broker 的 HA&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 Broker 会和主 Broker 建立长连接，然后获取主 Broker commitlog 最大偏移量，开始向主 Broker 拉取消息，主 Broker 会返回一定数量的消息，循环进行，达到主从数据同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者消费消息会先请求主 Broker ，如果主 Broker 觉得现在压力有点大，则会返回从 Broker 拉取消息的建议，然后消费者就去从服务器拉取消息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费有两种模式，分别是广播模式和集群模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;广播模式：一个分组下的每个消费者都会消费完整的Topic 消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集群模式：一个分组下的消费者瓜分消费Topic 消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般我们用的都是集群模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而消费者消费消息又分为推和拉模式，详细看我这篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjEyNTk1Ng==&amp;amp;mid=2247485324&amp;amp;idx=1&amp;amp;sn=ce900c8438936ab6f3ed21105e099236&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;消息队列推拉模式&lt;/a&gt;，分别从源码级别分析了 RokcetMQ 和 Kafka 的消息推拉，以及推拉模式的优缺点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Consumer 端的负载均衡机制&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer 会定期的获取 Topic 下的队列数，然后再去查找订阅了该 Topic 的同一消费组的所有消费者信息，默认的分配策略是类似分页排序分配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将队列排好序，然后消费者排好序，比如队列有 9 个，消费者有 3 个，那消费者-1 消费队列 0、1、2 的消息，消费者-2 消费队列 3、4、5，以此类推。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果负载太大，那么就加队列，加消费者，通过负载均衡机制就可以感知到重平衡，均匀负载。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Consumer 消息消费的重试&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难免会遇到消息消费失败的情况，所以需要提供消费失败的重试，而一般的消费失败要么就是消息结构有误，要么就是一些暂时无法处理的状态，所以立即重试不太合适。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 会给&lt;span&gt;每个消费组&lt;/span&gt;都设置一个重试队列，Topic 是 &lt;code&gt;%RETRY%+consumerGroup&lt;/code&gt;，并且设定了很多重试级别来延迟重试的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了利用 RocketMQ 的延时队列功能，重试的消息会先保存在 Topic 名称为“SCHEDULE_TOPIC_XXXX”的延迟队列，在消息的扩展字段里面会存储原来所属的 Topic 信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;delay 一段时间后再恢复到重试队列中，然后 Consumer 就会消费这个重试队列主题，得到之前的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果超过一定的重试次数都消费失败，则会移入到死信队列，即 Topic &lt;code&gt;%DLQ%&quot; + ConsumerGroup&lt;/code&gt; 中，存储死信队列即认为消费成功，因为实在没辙了，暂时放过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们可以通过人工来处理死信队列的这些消息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息的全局顺序和局部顺序&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全局顺序就是消除一切并发，一个 Topic 一个队列，Producer 和 Consuemr 的并发都为一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;局部顺序其实就是指某个队列顺序，多队列之间还是能并行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过 MessageQueueSelector 指定 Producer 某个业务只发这一个队列，然后 Comsuer 通过MessageListenerOrderly 接受消息，其实就是加锁消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Broker 会有一个 mqLockTable ，顺序消息在创建拉取消息任务的时候需要在 Broker 锁定该消息队列，之后加锁成功的才能消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而严格的顺序消息其实很难，假设现在都好好的，如果有个 Broker 宕机了，然后发生了重平衡，队列对应的消费者实例就变了，就会有可能会出现乱序的情况，如果要保持严格顺序，那此时就只能让整个集群不可用了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一些注意点&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、订阅消息是以 ConsumerGroup 为单位存储的，所以ConsumerGroup 中的每个 Consumer 需要有相同的订阅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为订阅消息是随着心跳上传的，如果一个 ConsumerGroup 中 Consumer 订阅信息不一样，那么就会出现互相覆盖的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如消费者 A 订阅 Topic a，消费者 B 订阅 Topic b，此时消费者 A 去 Broker 拿消息，然后 B 的心跳包发出了，Broker 更新了，然后接到 A 的请求，一脸懵逼，没这订阅关系啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、RocketMQ 主从读写分离&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从只能读，不能写，并且只有当前客户端读的 offset 和 当前 Broker 已接受的最大 offset 超过限制的物理内存大小时候才会去从读，所以&lt;span&gt;正常情况下从分担不了流量&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、单单加机器提升不了消费速度，队列的数量也需要跟上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、之前提到的，不要允许自动创建主题&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RocketMQ 的最佳实践&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些最佳实践部分参考自官网。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Tags的使用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议一个应用一个 Topic，利用 tages 来标记不同业务，因为 tages 设置比较灵活，且一个应用一个 Topic 很清晰，能直观的辨别。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Keys的使用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有消息业务上的唯一标识，请填写到 keys 字段中，方便日后的定位查找。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;提高 Consumer 的消费能力&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、提高消费并行度：增加队列数和消费者数量，提高单个消费者的并行消费线程，参数 consumeThreadMax。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、批处理消费，设置 consumeMessageBatchMaxSize 参数，这样一次能拿到多条消息，然后比如一个 update语句之前要执行十次，现在一次就执行完。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、跳过非核心的消息，当负载很重的时候，为了保住那些核心的消息，设置那些非核心的消息，例如此时消息堆积 1W 条了之后，就直接返回消费成功，跳过非核心消息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;NameServer 的寻址&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请使用 HTTP 静态服务器寻址（默认），这样 NameServer 就能动态发现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JVM选项&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下抄自官网：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不关心 RocketMQ Broker的启动时间，通过“预触摸” Java 堆以确保在 JVM 初始化期间每个页面都将被分配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那些不关心启动时间的人可以启用它：-XX:+AlwaysPreTouch
禁用偏置锁定可能会减少JVM暂停， -XX:-UseBiasedLocking
至于垃圾回收，建议使用带JDK 1.8的G1收集器。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;-XX:+UseG1GC -XX:G1HeapRegionSize=16m&lt;br/&gt;-XX:G1ReservePercent=25
-XX:InitiatingHeapOccupancyPercent=30&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外不要把-XX:MaxGCPauseMillis的值设置太小，否则JVM将使用一个小的年轻代来实现这个目标，这将导致非常频繁的minor GC，所以建议使用rolling GC日志文件:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;-XX:+UseGCLogFileRotation&lt;br/&gt;-XX:NumberOfGCLogFiles=5
-XX:GCLogFileSize=30m&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Linux内核参数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下抄自官网：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;vm.extra_free_kbytes&lt;/span&gt;，告诉VM在后台回收（kswapd）启动的阈值与直接回收（通过分配进程）的阈值之间保留额外的可用内存。RocketMQ使用此参数来避免内存分配中的长延迟。（与具体内核版本相关）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;vm.min_free_kbytes&lt;/span&gt;，如果将其设置为低于1024KB，将会巧妙的将系统破坏，并且系统在高负载下容易出现死锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;vm.max_map_count&lt;/span&gt;，限制一个进程可能具有的最大内存映射区域数。RocketMQ将使用mmap加载CommitLog和ConsumeQueue，因此建议将为此参数设置较大的值。（agressiveness --&amp;gt; aggressiveness）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;vm.swappiness&lt;/span&gt;，定义内核交换内存页面的积极程度。较高的值会增加攻击性，较低的值会减少交换量。建议将值设置为10来避免交换延迟。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;File descriptor limits&lt;/span&gt;，RocketMQ需要为文件（CommitLog和ConsumeQueue）和网络连接打开文件描述符。我们建议设置文件描述符的值为655350。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Disk scheduler，RocketMQ建议使用I/O截止时间调度器，它试图为请求提供有保证的延迟。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实还有很多没讲，比如流量控制、消息的过滤、定时消息的实现，包括底层通信 1+N+M1+M2 的 Reactor 多线程设计等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是内容太多了，而且也不太影响主流程，所以还是剥离出来之后写吧，大致的一些实现还是讲了的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包括元信息的交互、消息的发送、存储、消费等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于事务消息的那一块我之前文章也分析过了，所以这个就不再贴了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到要实现一个生产级别的消息队列还是有很多很多东西需要考虑的，不过大致的架构和涉及到的模块差不多就这些了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于具体的细节深入，还是得靠大家自行研究了，我就起个抛砖引玉的作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后个人能力有限，如果哪里有纰漏请抓紧联系鞭挞我！还有我搞了个群如果想&lt;span&gt;进群就&lt;/span&gt;&lt;span&gt;备注下进群&lt;/span&gt;&lt;span&gt;，我拉你。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1018711018711018&quot; data-type=&quot;png&quot; data-w=&quot;962&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJia3uojrYUyxpIO8UI1Z51hbYJzn7munuEJBm7yFx3dc97ZJcRosT9xQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;还有当当&lt;/span&gt;&lt;span&gt;四折买书&lt;/span&gt;&lt;span&gt;的优惠码没多少名额了，要囤书的抓紧了哟，下单使用优惠码「&lt;/span&gt;&lt;span&gt;MACNXV&lt;/span&gt;&lt;span&gt;&lt;span/&gt;」，&lt;/span&gt;&lt;span&gt;160买400的书&lt;/span&gt;&lt;span&gt;，&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjEyNTk1Ng==&amp;amp;mid=2247485954&amp;amp;idx=2&amp;amp;sn=42e13e46a558e127707c5d8930416813&amp;amp;chksm=ce0de0e9f97a69ffc2672b5d1673a7881af8415708d7395f44b7f4235147d217ed8d92b2fcb1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;推荐的书单&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;推荐的书单&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是 yes，从一点点到亿点点，我们下篇见&lt;/span&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8e03a2d2a5eb2b5c8cc31541d9752867</guid>
<title>[译] 初识 NGINX 服务网格</title>
<link>https://toutiao.io/k/mc7hwwn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934837&quot; data-style-type=&quot;&quot;&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section data-id=&quot;90196&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.33613445378151263&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGlOmb9wMeibPLCzEiaN4JWCBw6CybZLAEpUZ1fN6CouYoW0SgCe0k10Tvf210sBXvk0ibzozCXG5PR0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1190&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;135编辑器&quot; data-darkmode-bgcolor-16026778760346=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(255, 255, 255)&quot; data-style=&quot;white-space: normal; max-width: 100%; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16026778760346=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section powered-by=&quot;135编辑器&quot; data-darkmode-bgcolor-16026778760346=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16026778760346=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026778760346=&quot;rgb(62, 62, 62)&quot; data-style=&quot;max-width: 100%; box-sizing: border-box; color: rgb(62, 62, 62); border-width: 0px; border-style: none; border-color: initial; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16026778760346=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16026778760346=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026778760346=&quot;rgb(62, 62, 62)&quot;&gt;&lt;section data-darkmode-bgcolor-16026778760346=&quot;rgb(177, 192, 213)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(207, 225, 249)&quot; data-darkmode-color-16026778760346=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026778760346=&quot;rgb(62, 62, 62)&quot; data-style=&quot;padding: 10px; max-width: 100%; box-sizing: border-box; background-color: rgb(207, 225, 249); overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section powered-by=&quot;135编辑器&quot; data-darkmode-bgcolor-16026778760346=&quot;rgb(177, 192, 213)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(207, 225, 249)&quot; data-darkmode-color-16026778760346=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026778760346=&quot;rgb(62, 62, 62)&quot;&gt;&lt;section data-darkmode-bgcolor-16026778760346=&quot;rgb(177, 192, 213)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(207, 225, 249)&quot; data-darkmode-color-16026778760346=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026778760346=&quot;rgb(62, 62, 62)&quot;&gt;&lt;section data-darkmode-bgcolor-16026778760346=&quot;rgb(177, 192, 213)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(207, 225, 249)&quot; data-darkmode-color-16026778760346=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026778760346=&quot;rgb(62, 62, 62)&quot;&gt;&lt;p data-darkmode-bgcolor-16026778760346=&quot;rgb(177, 192, 213)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(207, 225, 249)&quot; data-darkmode-color-16026778760346=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026778760346=&quot;rgb(62, 62, 62)&quot;&gt;&lt;span data-darkmode-bgcolor-16026778760346=&quot;rgb(177, 192, 213)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(207, 225, 249)&quot; data-darkmode-color-16026778760346=&quot;rgb(94, 94, 94)&quot; data-darkmode-original-color-16026778760346=&quot;rgb(136, 136, 136)&quot; data-style=&quot;color: rgb(136, 136, 136); font-size: 13.3333px; visibility: visible;&quot;&gt;两周前 NGINX 发布了自己的服务网格。&lt;/span&gt;&lt;span data-darkmode-bgcolor-16026778760346=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16026778760346=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16026778760346=&quot;rgb(136, 136, 136)&quot; data-style=&quot;background-color: rgb(255, 255, 255); color: rgb(136, 136, 136); font-size: 12px; letter-spacing: 0.544px; visibility: visible;&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;49&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p data-darkmode-bgcolor-16026778760346=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(255, 255, 255)&quot; data-style=&quot;background-color: rgb(255, 255, 255); max-width: 100%; min-height: 1em; box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;span data-darkmode-bgcolor-16026778760346=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16026778760346=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16026778760346=&quot;rgb(136, 136, 136)&quot;&gt;作者：NGINX&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16026778760346=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(255, 255, 255)&quot; data-style=&quot;background-color: rgb(255, 255, 255); max-width: 100%; min-height: 1em; box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;span data-darkmode-bgcolor-16026778760346=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16026778760346=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16026778760346=&quot;rgb(136, 136, 136)&quot;&gt;译者：台慧敏&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16026778760346=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(255, 255, 255)&quot; data-style=&quot;background-color: rgb(255, 255, 255); max-width: 100%; min-height: 1em; letter-spacing: 0.544px; box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;span data-darkmode-bgcolor-16026778760346=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16026778760346=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16026778760346=&quot;rgb(136, 136, 136)&quot;&gt;校对：林静&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16026778760346=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(255, 255, 255)&quot; data-style=&quot;background-color: rgb(255, 255, 255); max-width: 100%; min-height: 1em; letter-spacing: 0.544px; box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;span data-darkmode-bgcolor-16026778760346=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026778760346=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16026778760346=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16026778760346=&quot;rgb(136, 136, 136)&quot;&gt;原文：https://www.nginx.com/blog/introducing-nginx-service-mesh/amp/&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.562&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/06ULcDvaIGlOLCsHcibn5truX0xliaEqREzFgG2Xl44mGxAvOibib3gHh4wvO2Kj2eQbqp1QlGgA5XicLEicyqjErAibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;此版本 NGINX Service Mesh (NSM) 是一个高度集成的轻量级的服务网格的开发版本，它利用 NGINX Plus 支持的数据平面来管理 Kubernetes 环境中的容器流量。NSM 可以免费 下载。非常希望广大开发者们能在开发和测试环境中尝试一下，期待你们在 GitHub 仓库留下对 NSM 的反馈。&lt;/p&gt;&lt;p&gt;随着部署规模的扩大并且变得越来越复杂，微服务的落地也变得很有挑战。服务之间的通信错综复杂，在系统中调试问题可能会更加困难，并且服务增多意味着需要管理更多的资源。&lt;/p&gt;&lt;p&gt;NSM 通过使用户集中配置来解决以上挑战：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;安全——如今安全比以往任何时候都更加重要，数据泄露每年可能使组织损失数百万美元的收入和声誉。NSM 确保所有通信均经过 mTLS 加密，因此网络上没有敏感数据可被黑客窃取。通过访问控制可以定义策略来控制哪些服务可以相互通信。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;流量管理——在部署应用程序的一个新版本时，用户可能希望先限制新版本应用程序接收的流量，以防可能存在 bug。使用 NSM 智能容器流量管理，用户可以指定限制流量到新服务的策略，并随着时间的推移逐渐增加流量。限流和断路器等功能使用户可以完全控制流经服务的流量。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;可视化——管理数千个服务对于调试和可见性可能是一个噩梦。NSM 通过内置的 Grafana 仪表板在 NGINX Plus 中显示可用的全套指标来帮助用户解除这个噩梦。此外，Open Tracing 的集成实现了细粒度的事务跟踪。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;混合部署——如果用户的企业像大多数企业一样，整个基础架构不完全在 Kubernetes 中运行。NSM 确保不会遗漏运行在 Kubernetes 以外的应用程序。通过 NGINX Kubernetes Ingress Controller 集成，它们务可以与网格服务通信，反之亦然。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;NSM 通过将加密和身份验证无缝应用于容器流量来确保零信任环境中的应用程序安全。它具有对进出流量的可观察性和洞察力，来帮助用户快速准确地部署和解决问题。它还提供了细粒度的流量控制，使 DevOps 团队可以部署和优化应用程序组件，同时使 Dev 团队可以构建并轻松连接其分布式应用程序。&lt;/p&gt;&lt;h2&gt;什么是 NGINX 服务网格？&lt;/h2&gt;&lt;p&gt;NSM 有一个用于东西向（服务到服务）流量的统一数据平面，以及一个本地集成的用于南北向流量的 NGINX Plus 入口控制器，它由单独的一个控制平面进行管理。&lt;/p&gt;&lt;p&gt;控制平面是为 NGINX Plus 数据平面设计和优化的，并定义了分配给 NGINX Plus sidecar 容器的流量管理规则。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4921875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGlOLCsHcibn5truX0xliaEqREKODXfxwk64PQBxgldqbdqhUhqic3Wpd4jjX01bOYWBQdWuEDNxo5XNA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;NGINX 服务网格架构图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;通过 NSM，sidecar 容器代理与网格中的每个服务一同部署，它们与以下开源解决方案集成：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Grafana —— Prometheus 指标的可视化；内置的 NSM 仪表板可帮助您入门&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Kubernetes Ingress controllers ——管理网格的入口和出口流量&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;SPIRE ——证书颁发机构，用于管理，分发和轮换网格的证书&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;NATS ——可伸缩的消息传递平面，用于从控制平面向 sidecar 容器传递消息，例如路由更新&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Open Tracing ——分布式跟踪（同时支持 Zipkin 和 Jaeger）&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Prometheus ——从 NGINX Plus sidecar 容器中收集和存储指标，例如请求数，连接数和 SSL 握手数&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;功能和组件&lt;/h2&gt;&lt;p&gt;NGINX Plus 作为数据平面跨越了 sidecar 代理（东西方流量）和入口控制器（南北流量），同时拦截和管理服务容器之间的流量。功能包括：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;TLS (mTLS) 身份验证&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;负载均衡&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;高可用性&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;限速&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;熔断&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;蓝绿和金丝雀部署&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;访问控制&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;NGINX 服务网格入门&lt;/h2&gt;&lt;p&gt;要开始使用 NSM，您首先需要：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;有一个可以访问的 Kubernetes 环境。NGINX Service Mesh 可以支持多个 Kubernetes 平台，包括 Amazon Kubernetes 弹性容器服务 (EKS)，Azure Kubernetes 服务 (AKS)，Google Kubernetes 引擎 (GKE)，VMware vSphere 和独立的裸机群集。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;在要安装 NSM 的机器上安装 kubectl 命令行程序。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;下载 NGINX Service Mesh 发布包。该软件包包括 NSM 镜像，需要将镜像上传到 Kubernetes 集群可访问的私有容器仓库中。该软件包还包括用于部署 NSM 的 nginx-meshctl 二进制文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;要使用默认设置部署 NSM，请运行以下命令。在部署过程中，该跟踪确认网格组件的成功部署，最后确认 NSM 在其自己的命名空间中运行：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ DOCKER_REGISTRY&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;your&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;Docker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;registry &lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; MESH_VER&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0.6&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;./&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;meshctl deploy  \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mesh&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;api&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;&quot;${DOCKER_REGISTRY}/nginx-mesh-api:${MESH_VER}&quot;&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mesh&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;sidecar&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;&quot;${DOCKER_REGISTRY}/nginx-mesh-sidecar:${MESH_VER}&quot;&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mesh&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;&quot;${DOCKER_REGISTRY}/nginx-mesh-init:${MESH_VER}&quot;&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mesh&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;metrics&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;&quot;${DOCKER_REGISTRY}/nginx-mesh-metrics:${MESH_VER}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Created&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;nginx-mesh&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Created&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;SpiffeID&lt;/span&gt;&lt;span&gt; CRD&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Waiting&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Spire&lt;/span&gt;&lt;span&gt; pods to be running&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Deployed&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Spire&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Deployed&lt;/span&gt;&lt;span&gt; NATS server&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Created&lt;/span&gt;&lt;span&gt; traffic policy &lt;/span&gt;&lt;span&gt;CRDs&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Deployed&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Mesh&lt;/span&gt;&lt;span&gt; API&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Deployed&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Metrics&lt;/span&gt;&lt;span&gt; API &lt;/span&gt;&lt;span&gt;Server&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Deployed&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Prometheus&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Server&lt;/span&gt;&lt;span&gt; nginx&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mesh&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;prometheus&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Deployed&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Grafana&lt;/span&gt;&lt;span&gt; nginx&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mesh&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;grafana&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Deployed&lt;/span&gt;&lt;span&gt; tracing server nginx&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mesh&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;zipkin&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;All&lt;/span&gt;&lt;span&gt; resources created&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Testing&lt;/span&gt;&lt;span&gt; the connection to the &lt;/span&gt;&lt;span&gt;Service&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Mesh&lt;/span&gt;&lt;span&gt; API &lt;/span&gt;&lt;span&gt;Server&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Connected&lt;/span&gt;&lt;span&gt; to the NGINX &lt;/span&gt;&lt;span&gt;Service&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Mesh&lt;/span&gt;&lt;span&gt; API successfully&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;NGINX &lt;/span&gt;&lt;span&gt;Service&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Mesh&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; running&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;对于其他命令选项，包括非默认设置，请运行：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ nginx&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;meshctl deploy &lt;/span&gt;&lt;span&gt;–&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;要验证 NSM 控制平面在 nginx-mesh 命名空间中是否正常运行，请运行：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ kubectl &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; pods &lt;/span&gt;&lt;span&gt;–&lt;/span&gt;&lt;span&gt;n nginx&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mesh&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;NAME                                 READY   STATUS    RESTARTS   AGE&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;grafana&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;6cc6958cd9&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;dccj6             &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;2d19h&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;mesh&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;api&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;6b95576c46&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;8npkb&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;2d19h&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;nats&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;6d5c57f894&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;225qn&lt;/span&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;2d19h&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;prometheus&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;65c95b788b&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;zkt95   &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;2d19h&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;smi&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;metrics&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5986dfb8d5&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;q6gfj         &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;2d19h&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;spire&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5cf87&lt;/span&gt;&lt;span&gt;                    &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;2d19h&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;spire&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;rr2tt                    &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;2d19h&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;spire&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;vwjbv                    &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;2d19h&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;spire&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;                       &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;2d19h&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;zipkin&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;6f7cbf5467&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;ns6wc              &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;2d19h&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;根据设置手动或自动注入策略的部署选项，默认情况下，NGINX sidecar 代理会注入已部署的应用程序中。要了解如何禁用自动注入，请参阅我们的 文档。例如，如果我们将 &lt;strong&gt;sleep&lt;/strong&gt; 应用程序部署在&lt;strong&gt;默认&lt;/strong&gt;名称空间中，然后检查 Pod，我们会看到两个容器正在运行—— &lt;strong&gt;sleep&lt;/strong&gt; 应用程序和关联的 NGINX Plus sidecar 容器：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ kubectl apply &lt;/span&gt;&lt;span&gt;–&lt;/span&gt;&lt;span&gt;f sleep&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;yaml &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ kubectl &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; pods &lt;/span&gt;&lt;span&gt;–&lt;/span&gt;&lt;span&gt;n &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;NAME                     READY   STATUS    RESTARTS   AGE&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;sleep&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;674f75ff4d&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;gxjf2   &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;5h23m&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;您还可以通过运行以下命令以将 sidecar 暴露到本地，从而使用 本地 NGINX Plus 仪表板 监视 sleep 应用程序：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;$ kubectl port&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;forward sleep&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;674f75ff4d&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;gxjf2 &lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;8886&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;然后在浏览器中导航到 http://localhost:8080/dashboard.html 您还可以连接到 Prometheus 服务器以监视 &lt;strong&gt;sleep&lt;/strong&gt; 应用程序。&lt;/p&gt;&lt;p&gt;您可以在 Kubernetes 中使用自定义资源来配置流量策略，例如访问控制，速率限制和熔断。有关更多信息，请参见 文档。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;NGINX Service Mesh 可从 F5 portal 免费下载。请在您的开发和测试环境中试用，然后在 GitHub 上提交您的反馈。要试用 NGINX Plus Ingress Controller，请立即开始 30 天免费试用，或与我们联系以讨论您的应用用例。&lt;/p&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; NGINX Plus: &lt;em&gt;https://www.nginx.com/products/nginx/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; 下载: &lt;em&gt;https://downloads.f5.com/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; 文档: &lt;em&gt;https://docs.nginx.com/nginx-service-mesh/usage/inject-sidecar-proxy/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; 本地 NGINX Plus 仪表板: &lt;em&gt;https://www.nginx.com/products/nginx/live-activity-monitoring&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[5]&lt;/code&gt; 文档: &lt;em&gt;https://docs.nginx.com/nginx-service-mesh/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[6]&lt;/code&gt; F5 portal: &lt;em&gt;https://login.f5.com/resource/login.jsp?ctx=719748&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[7]&lt;/code&gt; GitHub: &lt;em&gt;https://github.com/nginxinc/nginx-service-mesh/issues&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/06ULcDvaIGmjSjq9PMFiba6YWotLVmLrJMxNf0ZHU3uFm7ibzPlzbnwogR34NnQKTWvg19RHo10LH7Xgj1NHmkzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;点击下方“阅读原文”查看更多&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;↓↓↓&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>