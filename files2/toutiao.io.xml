<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>424f9e9a8776e7b436b58717582b7806</guid>
<title>Flutter 电商项目最佳实践</title>
<link>https://toutiao.io/k/aldjzoo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entryContent&quot;&gt;&amp;#13;
        &lt;p&gt;该项目为Github开源项目，地址：&lt;a href=&quot;https://github.com/simplezhli/flutter_deer&quot;&gt;https://github.com/simplezhli/flutter_deer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该项目非常适合作为个人学习Flutter的练习项目。&lt;/p&gt;
&lt;p&gt;通过设置、修改、组合自带部件以及自定义来实现具体的设计效果，满足日常开发的需求。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;size-full wp-image-180 aligncenter&quot; src=&quot;http://wiki.i-fanr.com/wp-content/uploads/2021/06/Screenshot_15.png&quot; alt=&quot;&quot; srcset=&quot;http://wiki.i-fanr.com/wp-content/uploads/2021/06/Screenshot_15.png 844w, http://wiki.i-fanr.com/wp-content/uploads/2021/06/Screenshot_15-300x275.png 300w, http://wiki.i-fanr.com/wp-content/uploads/2021/06/Screenshot_15-768x704.png 768w&quot; sizes=&quot;(max-width: 844px) 100vw, 844px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本功能涵盖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mvp模式&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;provider&lt;/code&gt; (5.x 版本)做状态管理&lt;/li&gt;
&lt;li&gt;基于&lt;code&gt;dio&lt;/code&gt; （4.x 版本）的网络请求封装&lt;/li&gt;
&lt;li&gt;完整的集成测试、可访问性测试。&lt;/li&gt;
&lt;li&gt;支持深色模式&lt;/li&gt;
&lt;li&gt;本地化（感谢 @ghedwards）&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;Sliver&lt;/code&gt; 系列组件实现复杂滚动效果&lt;/li&gt;
&lt;li&gt;使用高德地图定位选择地址（支持Web）&lt;/li&gt;
&lt;li&gt;通用Widget的处理封装&lt;/li&gt;
&lt;li&gt;下拉刷新 + 上拉加载更多&lt;/li&gt;
&lt;li&gt;应用检查更新&lt;/li&gt;
&lt;li&gt;PopupWindow&lt;/li&gt;
&lt;li&gt;扫码功能（qr_code_scanner插件）&lt;/li&gt;
&lt;li&gt;菜单切换动画（圆形扩散、3D翻转）&lt;/li&gt;
&lt;li&gt;侧滑删除&lt;/li&gt;
&lt;li&gt;城市选择&lt;/li&gt;
&lt;li&gt;类似京东选择城市的三级联动&lt;/li&gt;
&lt;li&gt;各种自定义Dialog&lt;/li&gt;
&lt;li&gt;列表头部吸顶&lt;/li&gt;
&lt;li&gt;密码输入键盘&lt;/li&gt;
&lt;li&gt;验证码输入框&lt;/li&gt;
&lt;li&gt;自定义简易日历&lt;/li&gt;
&lt;li&gt;曲线图及&lt;a href=&quot;https://dartpad.cn/d06f8f737d6eb2d87978eb2d14b87864&quot; rel=&quot;nofollow&quot;&gt;饼状图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;模块化路由管理&lt;/li&gt;
&lt;li&gt;更多Demo（水波纹动画、刮刮卡、lottie）&lt;/li&gt;
&lt;li&gt;更多的细节优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体可以下载体验：&lt;/p&gt;
&lt;p&gt;Android版安装包：&lt;a href=&quot;https://www.pgyer.com/gYXj&quot; rel=&quot;nofollow&quot;&gt;点击下载&lt;/a&gt;，下载密码：&lt;code&gt;111111&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;iOS需要自行下载代码运行。&lt;/p&gt;
&lt;p&gt;Web体验地址：&lt;a href=&quot;https://simplezhli.github.io/flutter_deer/&quot; rel=&quot;nofollow&quot;&gt;https://simplezhli.github.io/flutter_deer/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;项目运行环境&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1. Flutter version 2.2.1&amp;#13;
 &amp;#13;
2. Dart version 2.13.1&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;注意事项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;debug&lt;/code&gt;模式下会有部分卡顿现象，这属于正常现象。良好的体验需要打&lt;code&gt;release&lt;/code&gt; 包。 iOS可以执行命令&lt;code&gt;flutter build ios&lt;/code&gt; 以创建&lt;code&gt;release&lt;/code&gt;版本。 Android可以执行命令&lt;code&gt;flutter build apk&lt;/code&gt; 以创建&lt;code&gt;release&lt;/code&gt;版本。&lt;/li&gt;
&lt;li&gt;项目运行有问题可以在&lt;a href=&quot;https://github.com/simplezhli/flutter_deer/blob/master/docs/iOS%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.md&quot;&gt;iOS问题汇总&lt;/a&gt;、&lt;a href=&quot;https://github.com/simplezhli/flutter_deer/blob/master/docs/Android%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.md&quot;&gt;Android问题汇总&lt;/a&gt;中尝试寻找解决办法。&lt;/li&gt;
&lt;li&gt;由于部分插件的原因，本项目在Windows、macOS仅做预览（主要为原生功能方面，UI问题不大）。有兴趣的可自行运行体验。&lt;/li&gt;
&lt;li&gt;可以执行集成测试命令&lt;code&gt;flutter drive --target=test_driver/driver.dart&lt;/code&gt; 查看功能演示。&lt;/li&gt;
&lt;li&gt;因为页面有点多，一开始可能会导致页面无法与设计图对应上。我在代码注释中有添加设计图的相对路径，可以搜索或查找到对应页面，希望对你有帮助。&lt;/li&gt;
&lt;li&gt;本项目使用&lt;a href=&quot;https://github.com/zhangruiyu/FlutterJsonBeanFactory&quot;&gt;FlutterJsonBeanFactory&lt;/a&gt;插件来生成Bean。&lt;/li&gt;
&lt;li&gt;Web受制于js等资源过大和部署在Github上，访问会慢一些。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;size-full wp-image-83 aligncenter&quot; src=&quot;http://wiki.i-fanr.com/wp-content/uploads/2021/02/1614247105-wechat-end.png&quot; alt=&quot;&quot; srcset=&quot;http://wiki.i-fanr.com/wp-content/uploads/2021/02/1614247105-wechat-end.png 546w, http://wiki.i-fanr.com/wp-content/uploads/2021/02/1614247105-wechat-end-300x180.png 300w&quot; sizes=&quot;(max-width: 546px) 100vw, 546px&quot;/&gt;&lt;/p&gt;
    &lt;/div&gt;&amp;#13;
&amp;#13;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e478acdf9fcdc2b2dc72f32933f941b4</guid>
<title>快速进行服务接口监控</title>
<link>https://toutiao.io/k/ndgl5lb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                    &lt;h2&gt;1. 背景&lt;/h2&gt; 
&lt;p&gt;在一些业务中，可能会出现以下几种情况：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;1.接口的不稳定导致APP/WEB端上的超时、抛错，而资源级监控不能达到业务健康状况监控的目的。
2.接口众多，服务部署后不知道是否每个接口都正常。
3.不同服务同一接口的响应时间。
5.依赖的其他接口异常导致不可用。
6.重要的接口不能等用户触发异常，需要在用户请求前就发现异常并处理掉
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;为了保证线上服务的稳定运行，除了线上关键服务的资源类监控外，各服务接口也非常重要。对于接口异常这类问题的排查往往比服务异常更耗时费力，那么如何对线上关键接口进行监控呢？&lt;/p&gt; 
&lt;h2&gt;2. 解决思路&lt;/h2&gt; 
&lt;p&gt;获取到服务的所有接口定时对这些进行模拟请求，检测接口返回状态以及返回数据。&lt;/p&gt; 
&lt;h2&gt;3. JPower是什么&lt;/h2&gt; 
&lt;p&gt;&lt;a href=&quot;https://gitee.com/gdzWork/JPower&quot; title=&quot;JPower&quot;&gt;JPower&lt;/a&gt;是一个完全开源的微服务快速开发框架，包含用户管理、系统管理、统一授权等基础模块。用户在此框架上可快速进入业务开发。&lt;/p&gt; 
&lt;p&gt;这里给大家推荐一款JPower里的小工具&lt;a href=&quot;https://gitee.com/gdzWork/JPower/tree/master/jpower-op-server/jpower-log&quot; title=&quot;JPower&quot;&gt;jpower-log&lt;/a&gt;，jpower-log模块就对此实现了对各类接口的健康状态监控。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;实现功能：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;支持单个服务的所有API检测。&lt;/li&gt; 
 &lt;li&gt;自动回滚接口请求产生的数据，不会在数据库保留下任何垃圾数据；&lt;/li&gt; 
 &lt;li&gt;支持HTTP，请求类型可以是GET，POST，HEADER，PUT，DELETE等所有类型&lt;/li&gt; 
 &lt;li&gt;支持任何形式的HTTP接口鉴权配置，只需要简单的配置登录接口以及登录参数&lt;/li&gt; 
 &lt;li&gt;调用API可以设置请求头部，请求参数，并针对单个接口进行定制化配置&lt;/li&gt; 
 &lt;li&gt;可以自定义检测结果判定，比如接口返回状态码为200，返回内容包括/不包括exception等；&lt;/li&gt; 
 &lt;li&gt;可以自定义监控频率，比如30分钟/次，1小时/次等&lt;/li&gt; 
 &lt;li&gt;监控日志汇总，导出&lt;/li&gt; 
 &lt;li&gt;虽然这块小工具是基于JPower开发，但是检测对象不局限于JPower，任何第三方服务的HTTP接口都可进行配置监控&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;使用文档：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.kancloud.cn%2Fguodingzhi%2Fjpower%2F2251824&quot; target=&quot;_blank&quot;&gt;https://www.kancloud.cn/guodingzhi/jpower/2251824&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;使用技术：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;技术框架：maven、Spring Boot、Mybatis、SpringMVC&lt;/li&gt; 
 &lt;li&gt;技术组件：OKHttp、fastjson&lt;/li&gt; 
 &lt;li&gt;UI技术：vue、Echarts&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;运行环境&lt;/strong&gt;&lt;/p&gt; 
 
&lt;p&gt;&lt;strong&gt;截图预览：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-65a5ab191a24f89cb36444e68dd6be4a232.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-e7d7400cc97916628191af0fdca211466eb.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-6fcab56f0b762c9dbef17bc7c145ea875b8.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-ec2c8d89fe3007161c4602a2a37eb626b02.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-8378ee9c1b135b25ef0ed2a030a96190ba3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9da532e50e0925c4a22f2fa2b1806035</guid>
<title>工具 | 一套腾讯广告自研的分布式编译系统</title>
<link>https://toutiao.io/k/ae2auhz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655077223&amp;amp;idx=2&amp;amp;sn=05d40fd92b2ed441b4bfcaaab853a1d2&amp;amp;chksm=bd2913508a5e9a46683351f781991e7e2ad2a4a1c63a4acd499df91a8861e07ba5f713df0f96&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;加入「码农周刊VIP会员」，一起牛起来！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1016&quot; data-ratio=&quot;2.112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNav8cM20qor0d3k7n7br1fFO4uB1JYtp6z9Q3jINfHDSE8ibz6k4rb40miamBwHt03UzuUP57tjczhzww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;322&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.318840579710145&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8pVYfXHFZnJw6GmED4PucZvQd6m3AP8fUG1IKJyBgicmJ3P5ygQjO5r6Bib2x190MFOlb6PwExNQuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6e752c92a1364dc2f2ee55d79bd56a16</guid>
<title>重新思考错误处理（二）</title>
<link>https://toutiao.io/k/0ruh5co</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot;&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;文中的源码在这里: &lt;a href=&quot;https://github.com/gota33/errors&quot;&gt;https://github.com/gota33/errors&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;../20210529&quot;&gt;Part 1&lt;/a&gt; 中我们重新认识了什么是错误. 这次我们就以 Go 语言为例, 看看如何处理下面的问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何告诉机器有没有错误?&lt;/li&gt;
&lt;li&gt;如何告诉机器怎么处理错误: 重试? 返回上层? …&lt;/li&gt;
&lt;li&gt;如何告诉人类错误信息: 操作路径, 上下文信息, …&lt;/li&gt;
&lt;li&gt;如何在语言无关的前提下实现上面两点 (微服务环境)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外我们应该尽量复用现有方案, 除非:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;太过复杂: 增加认知成本&lt;/li&gt;
&lt;li&gt;侵入性过强: 增加耦合度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;go-中的-error&quot;&gt;Go 中的 error&lt;/h2&gt;
&lt;p&gt;既然具体到 Go 语言这个环境, 我就就先看看语言本身对错误的支持.&lt;/p&gt;
&lt;p&gt;早期版本中 Go 只对 error 下了个定义&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// The error built-in interface type is the conventional interface for
&lt;/span&gt;&lt;span&gt;// representing an error condition, with the nil value representing no error.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;error&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;span&gt;Error&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后给了一个基础实现&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// New returns an error that formats as the given text.
&lt;/span&gt;&lt;span&gt;// Each call to New returns a distinct error value even if the text is identical.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;New&lt;/span&gt;(&lt;span&gt;text&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;errorString&lt;/span&gt;{&lt;span&gt;text&lt;/span&gt;} }

&lt;span&gt;// errorString is a trivial implementation of error.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;errorString&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; { &lt;span&gt;string&lt;/span&gt; }

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;e&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;errorString&lt;/span&gt;) &lt;span&gt;Error&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;.&lt;span&gt;s&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其实, 这个接口虽然简单, 但已经处理了上面四个问题中的两个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何告诉机器有没有错误? &lt;code&gt;nil&lt;/code&gt; 代表没有错误, 否则有.&lt;/li&gt;
&lt;li&gt;如何告诉人类错误信息? 通过 &lt;code&gt;Error()&lt;/code&gt; 接口返回.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过第二点非常依赖于具体的实现:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果破坏了约定, 没有在向外层传递时加前缀, 就没有完整的操作路径, 只能看到根错误&lt;/li&gt;
&lt;li&gt;如果没有实现 &lt;code&gt;fmt.Formatter &lt;/code&gt; 接口, 就无法看到详细且工整的错误信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后来 Go 1.13 通过 &lt;code&gt;wrapper&lt;/code&gt; 进一步完善了错误处理:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// Unwrap returns the result of calling the Unwrap method on err, if err&#x27;s
&lt;/span&gt;&lt;span&gt;// type contains an Unwrap method returning error.
&lt;/span&gt;&lt;span&gt;// Otherwise, Unwrap returns nil.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Unwrap&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; 

&lt;span&gt;// Is reports whether any error in err&#x27;s chain matches target.
&lt;/span&gt;&lt;span&gt;// ...
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Is&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt;, &lt;span&gt;target&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) &lt;span&gt;bool&lt;/span&gt;

&lt;span&gt;// As finds the first error in err&#x27;s chain that matches target, and if so, sets
&lt;/span&gt;&lt;span&gt;// target to that error value and returns true. Otherwise, it returns false.
&lt;/span&gt;&lt;span&gt;// ...
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;As&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;, &lt;span&gt;target&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{}) &lt;span&gt;bool&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;于是错误内部的上下文信息就可以跨层传递了.&lt;/p&gt;
&lt;p&gt;然而标准库并没有对如何处理错误给出任何信息, 因为这几乎取决于业务场景. 但我们还是能从标准库内部看到一些痕迹. 比如 &lt;code&gt;net&lt;/code&gt; 包中有个内部使用的 &lt;code&gt;temporary&lt;/code&gt; 接口&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;temporary&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;span&gt;Temporary&lt;/span&gt;() &lt;span&gt;bool&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这也是 &lt;code&gt;net.Error&lt;/code&gt; 接口的一部分&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// An Error represents a network error.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;span&gt;error&lt;/span&gt;
&lt;span&gt;Timeout&lt;/span&gt;() &lt;span&gt;bool&lt;/span&gt;   &lt;span&gt;// Is the error a timeout?
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;Temporary&lt;/span&gt;() &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;// Is the error temporary?
&lt;/span&gt;&lt;span/&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它还出现在了 &lt;code&gt;context&lt;/code&gt; 包中&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// DeadlineExceeded is the error returned by Context.Err when the context&#x27;s
&lt;/span&gt;&lt;span&gt;// deadline passes.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;DeadlineExceeded&lt;/span&gt; &lt;span&gt;error&lt;/span&gt; = &lt;span&gt;deadlineExceededError&lt;/span&gt;{}

&lt;span&gt;type&lt;/span&gt; &lt;span&gt;deadlineExceededError&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{}

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;deadlineExceededError&lt;/span&gt;) &lt;span&gt;Error&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt;   { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;context deadline exceeded&quot;&lt;/span&gt; }
&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;deadlineExceededError&lt;/span&gt;) &lt;span&gt;Timeout&lt;/span&gt;() &lt;span&gt;bool&lt;/span&gt;   { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; }
&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;deadlineExceededError&lt;/span&gt;) &lt;span&gt;Temporary&lt;/span&gt;() &lt;span&gt;bool&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不过 &lt;code&gt;Temporary()&lt;/code&gt; 目前也存在一些争议: &lt;a href=&quot;https://github.com/golang/go/issues/45729&quot;&gt;issue#45729&lt;/a&gt;, 但这个方法的用意正是想提示机器该如何处理这个错误: 重试.&lt;/p&gt;
&lt;h2 id=&quot;微服务中的-error&quot;&gt;微服务中的 error&lt;/h2&gt;
&lt;p&gt;想让错误跨服务传递, 就得有一套独立于语言的标准. 并且最好满足以下三点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轻量级: 降低跨语言难度&lt;/li&gt;
&lt;li&gt;易于理解: 降低认知负担&lt;/li&gt;
&lt;li&gt;扩展性: 适配不同场景&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以这里我选择直接使用 gRPC 的错误标准, 这套标准在 Google 服务中有着广泛的应用, 可以说是比较靠谱了.&lt;/p&gt;
&lt;p&gt;不过序列化还是使用 JSON, 毕竟通用性强, 方便调试. 并且由于格式与 &lt;code&gt;protobuf&lt;/code&gt; 的版本相同, 所以要兼容也很容易.&lt;/p&gt;
&lt;p&gt;详细的文档可以参考 &lt;a href=&quot;https://cloud.google.com/apis/design/errors&quot;&gt;Google API design&lt;/a&gt;, 这里简单总结下.&lt;/p&gt;
&lt;h3 id=&quot;错误模型&quot;&gt;错误模型&lt;/h3&gt;
&lt;p&gt;模型由三部分组成: code 错误码, message 错误信息, details 错误详情.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-protobuf&quot; data-lang=&quot;protobuf&quot;&gt;&lt;span&gt;package&lt;/span&gt; google&lt;span&gt;.&lt;/span&gt;&lt;span&gt;rpc&lt;/span&gt;;&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// The `Status` type defines a logical error model that is suitable for
&lt;/span&gt;&lt;span&gt;// different programming environments, including REST APIs and RPC APIs.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;message&lt;/span&gt; &lt;span&gt;Status&lt;/span&gt; {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// A simple error code that can be easily handled by the client. The
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// actual error code is defined by `google.rpc.Code`.
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;int32&lt;/span&gt; code &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// A developer-facing human-readable error message in English. It should
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// both explain the error and offer an actionable resolution to it.
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;string&lt;/span&gt; &lt;span&gt;message&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;;&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// Additional error information that the client code can use to handle
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// the error, such as retry info or a help link.
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;repeated&lt;/span&gt; google.protobuf.Any details &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;JSON 格式:&lt;/p&gt;
&lt;p&gt;和上面很像, 但是多了一个 status 字段, 并在外面包了一层 wrapper.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-protobuf&quot; data-lang=&quot;protobuf&quot;&gt;&lt;span&gt;// The error format v2 for Google JSON REST APIs.
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;// NOTE: This schema is not used for other wire protocols.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;message&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt; {&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// This message has the same semantics as `google.rpc.Status`. It uses HTTP
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// status code instead of gRPC status code. It has an extra field `status`
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// for backward compatibility with Google API Client Libraries.
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;message&lt;/span&gt; &lt;span&gt;Status&lt;/span&gt; {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;// The HTTP status code that corresponds to `google.rpc.Status.code`.
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;int32&lt;/span&gt; code &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;// This corresponds to `google.rpc.Status.message`.
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;string&lt;/span&gt; &lt;span&gt;message&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;// This is the enum version for `google.rpc.Status.code`.
&lt;/span&gt;&lt;span/&gt;    google.rpc.Code status &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;// This corresponds to `google.rpc.Status.details`.
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;repeated&lt;/span&gt; google.protobuf.Any details &lt;span&gt;=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  }&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// The actual error payload. The nested message structure is for backward
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// compatibility with Google API client libraries. It also makes the error
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// more readable to developers.
&lt;/span&gt;&lt;span/&gt;  Status error &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;JSON 示例:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;{
  &lt;span&gt;&quot;error&quot;&lt;/span&gt;: {
    &lt;span&gt;&quot;code&quot;&lt;/span&gt;: &lt;span&gt;400&lt;/span&gt;,
    &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;API key not valid. Please pass a valid API key.&quot;&lt;/span&gt;,
    &lt;span&gt;&quot;status&quot;&lt;/span&gt;: &lt;span&gt;&quot;INVALID_ARGUMENT&quot;&lt;/span&gt;,
    &lt;span&gt;&quot;details&quot;&lt;/span&gt;: [
      {
        &lt;span&gt;&quot;@type&quot;&lt;/span&gt;: &lt;span&gt;&quot;type.googleapis.com/google.rpc.ErrorInfo&quot;&lt;/span&gt;,
        &lt;span&gt;&quot;reason&quot;&lt;/span&gt;: &lt;span&gt;&quot;API_KEY_INVALID&quot;&lt;/span&gt;,
        &lt;span&gt;&quot;domain&quot;&lt;/span&gt;: &lt;span&gt;&quot;googleapis.com&quot;&lt;/span&gt;,
        &lt;span&gt;&quot;metadata&quot;&lt;/span&gt;: {
          &lt;span&gt;&quot;service&quot;&lt;/span&gt;: &lt;span&gt;&quot;translate.googleapis.com&quot;&lt;/span&gt;
        }
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;错误类型&quot;&gt;错误类型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./image-20210529195147166.png&quot; alt=&quot;image-20210529195147166&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;错误消息&quot;&gt;错误消息&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./image-20210529194548842.png&quot; alt=&quot;message&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;错误详情&quot;&gt;错误详情&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./image-20210529194616203.png&quot; alt=&quot;image-20210529194616203&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;备注&quot;&gt;备注&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有的 5xx 错误都是服务端错误, 其对应的 DebugInfo 是仅限于系统内部记录用的, 错误往系统外传递错误消息时一定记得把 DebugInfo 过滤掉.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有两个错误是可重试的, 重试前要确保幂等性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;503 UNAVAILABLE &lt;/code&gt; : 默认行为应该为 1s 后重试 1 次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;429 RESOURCE_EXHAUSTED&lt;/code&gt;: 由客户端重试, 间隔至少 30s, 并且只用于耗时的后台任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不应该盲目将其他系统的错误传递给自己的用户, 比如其他系统返回的 &lt;code&gt;INVALID_ARGUMENT&lt;/code&gt; 应该内部处理后返回 &lt;code&gt;INTERNAL&lt;/code&gt; 或其他错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现详情和机密信息应在传播前隐藏&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虽然表格中的错误消息示例是中文, 但规范中错误消息应该是英文, i18n 的提示信息应该放在 &lt;code&gt;LocalizedMessage&lt;/code&gt; 详情中.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有三个 400 的错误很容易混淆:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;400 INVALID_ARGUMENT&lt;/code&gt;: 客户端传了无效的参数, 并且校验规则和服务端状态无关, 比如: Email 地址无效&lt;/li&gt;
&lt;li&gt;&lt;code&gt;400 FAILED_PRECONDITION&lt;/code&gt;: 服务器当前状态下无效的参数, 但服务器状态改变后重试可能成功, 比如: 用户申请的资源在初始化中.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;400 OUT_OF_RANGE&lt;/code&gt;: 和上面一条很像, 但用于范围, 比如: 日期范围, 数量范围, ….&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;几个可以重试的错误也需要区别:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;503 UNAVAILABLE&lt;/code&gt;: 因为请求实际上未到达服务器, 客户端可以立即重试&lt;/li&gt;
&lt;li&gt;&lt;code&gt;409 ABORTED&lt;/code&gt;: 进行中的事务被终止, 客户端需要从该事务阶段的起点重试.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;400 FAILED_PRECONDITION&lt;/code&gt;: 服务器状态不满足, 客户端需要等待服务器准备完毕后再重试.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;接口设计&quot;&gt;接口设计&lt;/h2&gt;
&lt;p&gt;首先回顾下需要包含在错误中的必要信息:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;错误码 (标识符, 一定程度上指导如何处理)&lt;/li&gt;
&lt;li&gt;执行路径 (快速定位错误)&lt;/li&gt;
&lt;li&gt;错误详情 (提供上下文信息, 关联其他外部信息)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再回顾下错误处理策略:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;底层错误应当尽量重试&lt;/li&gt;
&lt;li&gt;应当尽量集中处理错误 (程序中处理错误的位置尽量少)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;执行路径&quot;&gt;执行路径&lt;/h3&gt;
&lt;p&gt;在谈错误码之前, 我们先谈谈如何记录错误的执行路径.&lt;/p&gt;
&lt;p&gt;我做 Go 开发之前是做 Java 的, 由于 Java 的 Exception 有内置的 StackTrace, 所以那时并没有意识到其中的问题. 有时望着如山般的错误信息, 也只能叹口气慢慢消化. 但现在回想下, 其实里面 80% 的信息对定位问题并没有帮助. 比如下面这样:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;javax.servlet.ServletException: Something bad happened
    at com.example.myproject.OpenSessionInViewFilter.doFilter(OpenSessionInViewFilter.java:60)
    at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)
    at com.example.myproject.ExceptionHandlerFilter.doFilter(ExceptionHandlerFilter.java:28)
    at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)
    at com.example.myproject.OutputBufferFilter.doFilter(OutputBufferFilter.java:33)
    at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)
    at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:388)
    at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)
    at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:182)
    at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:765)
    at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:418)
    at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)
    at org.mortbay.jetty.Server.handle(Server.java:326)
    at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:542)
    at org.mortbay.jetty.HttpConnection$RequestHandler.content(HttpConnection.java:943)
    at org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:756)
    at org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:218)
    at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:404)
    at org.mortbay.jetty.bio.SocketConnector$Connection.run(SocketConnector.java:228)
    at org.mortbay.thread.QueuedThreadPool$PoolThread.run(QueuedThreadPool.java:582)
Caused by: com.example.myproject.MyProjectServletException
    at com.example.myproject.MyServlet.doPost(MyServlet.java:169)
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:727)
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)
    at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:511)
    at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1166)
    at com.example.myproject.OpenSessionInViewFilter.doFilter(OpenSessionInViewFilter.java:30)
    ... 27 more
Caused by: org.hibernate.exception.ConstraintViolationException: could not insert: [com.example.myproject.MyEntity]
    at org.hibernate.exception.SQLStateConverter.convert(SQLStateConverter.java:96)
    at org.hibernate.exception.JDBCExceptionHelper.convert(JDBCExceptionHelper.java:66)
    at org.hibernate.id.insert.AbstractSelectingDelegate.performInsert(AbstractSelectingDelegate.java:64)
    at org.hibernate.persister.entity.AbstractEntityPersister.insert(AbstractEntityPersister.java:2329)
    at org.hibernate.persister.entity.AbstractEntityPersister.insert(AbstractEntityPersister.java:2822)
    at org.hibernate.action.EntityIdentityInsertAction.execute(EntityIdentityInsertAction.java:71)
    at org.hibernate.engine.ActionQueue.execute(ActionQueue.java:268)
    at org.hibernate.event.def.AbstractSaveEventListener.performSaveOrReplicate(AbstractSaveEventListener.java:321)
    at org.hibernate.event.def.AbstractSaveEventListener.performSave(AbstractSaveEventListener.java:204)
    at org.hibernate.event.def.AbstractSaveEventListener.saveWithGeneratedId(AbstractSaveEventListener.java:130)
    at org.hibernate.event.def.DefaultSaveOrUpdateEventListener.saveWithGeneratedOrRequestedId(DefaultSaveOrUpdateEventListener.java:210)
    at org.hibernate.event.def.DefaultSaveEventListener.saveWithGeneratedOrRequestedId(DefaultSaveEventListener.java:56)
    at org.hibernate.event.def.DefaultSaveOrUpdateEventListener.entityIsTransient(DefaultSaveOrUpdateEventListener.java:195)
    at org.hibernate.event.def.DefaultSaveEventListener.performSaveOrUpdate(DefaultSaveEventListener.java:50)
    at org.hibernate.event.def.DefaultSaveOrUpdateEventListener.onSaveOrUpdate(DefaultSaveOrUpdateEventListener.java:93)
    at org.hibernate.impl.SessionImpl.fireSave(SessionImpl.java:705)
    at org.hibernate.impl.SessionImpl.save(SessionImpl.java:693)
    at org.hibernate.impl.SessionImpl.save(SessionImpl.java:689)
    at sun.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.hibernate.context.ThreadLocalSessionContext$TransactionProtectionWrapper.invoke(ThreadLocalSessionContext.java:344)
    at $Proxy19.save(Unknown Source)
    at com.example.myproject.MyEntityService.save(MyEntityService.java:59) &amp;lt;-- relevant call (see notes below)
    at com.example.myproject.MyServlet.doPost(MyServlet.java:164)
    ... 32 more
Caused by: java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...]
    at org.hsqldb.jdbc.Util.throwError(Unknown Source)
    at org.hsqldb.jdbc.jdbcPreparedStatement.executeUpdate(Unknown Source)
    at com.mchange.v2.c3p0.impl.NewProxyPreparedStatement.executeUpdate(NewProxyPreparedStatement.java:105)
    at org.hibernate.id.insert.AbstractSelectingDelegate.performInsert(AbstractSelectingDelegate.java:57)
    ... 54 more
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这个例子算是比较直观的, 越复杂的系统这个堆栈信息就越长. 如果内部使用了响应式或者函数式的框架, 那绝对头大, 可能盯着看上半小时也看不出个所以然来.&lt;/p&gt;
&lt;p&gt;除非系统特别复杂, 不然大部分时候简单的执行路径足以帮助我们定位问题. 比如我们写个简单的接口:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// 用户对象
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
&lt;span&gt;ID&lt;/span&gt;   &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;id&quot;`&lt;/span&gt;
&lt;span&gt;Name&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;name&quot;`&lt;/span&gt;
}

&lt;span&gt;// HTTP 接口
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;rest&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; { &lt;span&gt;srv&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;business&lt;/span&gt; }

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;h&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;rest&lt;/span&gt;) &lt;span&gt;Welcome&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt; &lt;span&gt;http&lt;/span&gt;.&lt;span&gt;ResponseWriter&lt;/span&gt;, &lt;span&gt;r&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;.&lt;span&gt;Request&lt;/span&gt;) {
&lt;span&gt;name&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;r&lt;/span&gt;.&lt;span&gt;URL&lt;/span&gt;.&lt;span&gt;Query&lt;/span&gt;().&lt;span&gt;Get&lt;/span&gt;(&lt;span&gt;&quot;name&quot;&lt;/span&gt;)
&lt;span&gt;user&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;h&lt;/span&gt;.&lt;span&gt;srv&lt;/span&gt;.&lt;span&gt;WelcomeByName&lt;/span&gt;(&lt;span&gt;r&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;(), &lt;span&gt;name&lt;/span&gt;)
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;span&gt;err&lt;/span&gt; = &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;.&lt;span&gt;Error&lt;/span&gt;{
&lt;span&gt;Op&lt;/span&gt;:  &lt;span&gt;r&lt;/span&gt;.&lt;span&gt;Method&lt;/span&gt;,
&lt;span&gt;URL&lt;/span&gt;: &lt;span&gt;r&lt;/span&gt;.&lt;span&gt;URL&lt;/span&gt;.&lt;span&gt;String&lt;/span&gt;(),
&lt;span&gt;Err&lt;/span&gt;: &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Errorf&lt;/span&gt;(&lt;span&gt;&quot;rest.Welcome: %w&quot;&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;),
}
&lt;span&gt;log&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt;)
&lt;span&gt;http&lt;/span&gt;.&lt;span&gt;NotFound&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt;, &lt;span&gt;r&lt;/span&gt;)
} &lt;span&gt;else&lt;/span&gt; {
&lt;span&gt;message&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Sprintf&lt;/span&gt;(&lt;span&gt;&quot;Hello, %s!&quot;&lt;/span&gt;, &lt;span&gt;user&lt;/span&gt;.&lt;span&gt;Name&lt;/span&gt;)
&lt;span&gt;_&lt;/span&gt;, &lt;span&gt;_&lt;/span&gt; = &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;WriteString&lt;/span&gt;(&lt;span&gt;w&lt;/span&gt;, &lt;span&gt;message&lt;/span&gt;)
}
}

&lt;span&gt;// 业务层
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;business&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; { &lt;span&gt;d&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;dao&lt;/span&gt; }

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;s&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;business&lt;/span&gt;) &lt;span&gt;WelcomeByName&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) (&lt;span&gt;user&lt;/span&gt; &lt;span&gt;User&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) {
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;s&lt;/span&gt;.&lt;span&gt;d&lt;/span&gt;.&lt;span&gt;GetUserByName&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt;); &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;span&gt;err&lt;/span&gt; = &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Errorf&lt;/span&gt;(&lt;span&gt;&quot;business.WelcomeByName: %w&quot;&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;) &lt;span&gt;// 记录错误路径
&lt;/span&gt;&lt;span/&gt;}
&lt;span&gt;return&lt;/span&gt;
}

&lt;span&gt;// DAO 层
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;dao&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{}

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;d&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;dao&lt;/span&gt;) &lt;span&gt;GetUserByName&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) (&lt;span&gt;user&lt;/span&gt; &lt;span&gt;User&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) {
&lt;span&gt;err&lt;/span&gt; = &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Errorf&lt;/span&gt;(&lt;span&gt;&quot;dao.GetUserByName: %w&quot;&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;) &lt;span&gt;// 记录错误路径
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;return&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;客户端收到的错误信息:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;404 page not found
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;服务端记录的日志:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2021/05/29 22:24:41 GET &quot;http://api.demo.com/welcome?name=Bob&quot;: rest.Welcome: business.WelcomeByName: dao.GetUserByName: sql: no rows in result set
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看起来是不是很清爽呢? 再看下记录全堆栈的版本.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2021/05/29 22:32:10 goroutine 1 [running]:
runtime/debug.Stack(0x9ac15f, 0x15, 0xc00011dd98)
C:/code/go/src/runtime/debug/stack.go:24 +0xa5
main.(*dao).GetUserByName(0xc00011df47, 0x9e3a10, 0xc000014040, 0xc00000e367, 0x3, 0xc00000e362, 0x9a74ba, 0x4, 0x92f701, 0xc00007ad80, ...)
C:/Users/a/AppData/Roaming/JetBrains/GoLand2021.1/scratches/scratch_8.go:69 +0xa5
main.(*business).WelcomeByName(0xc00011df50, 0x9e3a10, 0xc000014040, 0xc00000e367, 0x3, 0xc000024240, 0xc0000524e0, 0x38, 0x157fbdd0108, 0xc00014a000, ...)
C:/Users/a/AppData/Roaming/JetBrains/GoLand2021.1/scratches/scratch_8.go:59 +0x7e
main.(*rest).Welcome(0xc00011df58, 0x9e3930, 0xc00005e200, 0xc000152000)
C:/Users/a/AppData/Roaming/JetBrains/GoLand2021.1/scratches/scratch_8.go:39 +0xa5
main.main()
C:/Users/a/AppData/Roaming/JetBrains/GoLand2021.1/scratches/scratch_8.go:24 +0x113
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一般人可能要个反应个 10 秒才能提取出执行路径吧? 如果是较复杂的调用路径, 可能就是上面 Java 版的那个样子了.&lt;/p&gt;
&lt;p&gt;另外, 简单的信息有助于我们解决另一个难题: 如何跨服务传播错误? 堆栈信息其实不太容易传播, 特别是跨语言时更难. 但是只包含业务执行路径的错误消息却十分容易传播. 看起来就像这样:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2021/05/29 22:24:41 
GET &quot;http://api.demo.com/welcome?name=Bob&quot;: rest.Welcome: business.Welcome: api.getUser:
GET &quot;http://api.demo.com/users?name=Bob&quot;: rest.getUser: dao.GetUser: sql: no rows in result set
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以, 我建议只在错误中记录业务相关的执行路径. 只在必要的时候才记录完整的堆栈信息: 通过开关的方式, 或者记录在 DebugInfo 这样的详情中.&lt;/p&gt;
&lt;p&gt;虽说由于我们对微服务可观测性的要求越来越高, 有越来越多的工具可以帮助我们整理凌乱的错误信息. 比如 jaeger, sentry, …&lt;/p&gt;
&lt;p&gt;但是, 这些外部依赖也在无形中提高我们的使用和运维成本. 处理不好的话, 甚至可能出现脱离了特定环境就两眼一抹黑, 或者根本启动不了的情况.&lt;/p&gt;
&lt;p&gt;所以还是应当先处理好核心的东西, 再去享受这些运维工具带来的便利.&lt;/p&gt;
&lt;p&gt;最后, 这部分其实很容易实现, 使用 &lt;code&gt;fmt.Errorf()&lt;/code&gt; 就已经完全足够了.&lt;/p&gt;
&lt;h3 id=&quot;错误码&quot;&gt;错误码&lt;/h3&gt;
&lt;p&gt;错误码算是对错误的一种分类, 我们之前的分类方式粒度太粗, 易于理解但不便于使用.&lt;/p&gt;
&lt;p&gt;回顾一下: (可重试, 不可重试) x (内部, 外部). 一共四个分类.&lt;/p&gt;
&lt;p&gt;所以我们还是使用 gRPC 中久经考验的状态码规范.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;StatusCode&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;

&lt;span&gt;// 错误码枚举
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;const&lt;/span&gt; (
    &lt;span&gt;// 200 OK 为默认值
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;OK&lt;/span&gt; &lt;span&gt;StatusCode&lt;/span&gt; = &lt;span&gt;iota&lt;/span&gt;
&lt;span&gt;//...
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;Unauthenticated&lt;/span&gt;

    &lt;span&gt;// 错误码总数, 总放在最后
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;totalStatus&lt;/span&gt;
)
&lt;span&gt;var&lt;/span&gt; (
    &lt;span&gt;// 错误码名称列表
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;statusList&lt;/span&gt; = [&lt;span&gt;totalStatus&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;{
&lt;span&gt;&quot;OK&quot;&lt;/span&gt;,
&lt;span&gt;// ...
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;&quot;UNAUTHENTICATED&quot;&lt;/span&gt;,
}
    &lt;span&gt;// 错误码对应的 HttpStatusCode 列表
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;httpList&lt;/span&gt; = [&lt;span&gt;totalStatus&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;{
&lt;span&gt;http&lt;/span&gt;.&lt;span&gt;StatusOK&lt;/span&gt;,
&lt;span&gt;// ...
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;http&lt;/span&gt;.&lt;span&gt;StatusUnauthorized&lt;/span&gt;,
}
)

&lt;span&gt;// 错误码可以直接作为 Root Cause 使用
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;c&lt;/span&gt; &lt;span&gt;StatusCode&lt;/span&gt;) &lt;span&gt;Error&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt; {
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Sprintf&lt;/span&gt;(&lt;span&gt;&quot;%d %s&quot;&lt;/span&gt;, &lt;span&gt;c&lt;/span&gt;.&lt;span&gt;Http&lt;/span&gt;(), &lt;span&gt;c&lt;/span&gt;.&lt;span&gt;String&lt;/span&gt;())
}

&lt;span&gt;// 返回错误码名称, 非法错误码如 -1 返回 Code(-1)
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;c&lt;/span&gt; &lt;span&gt;StatusCode&lt;/span&gt;) &lt;span&gt;String&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt; {
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;.&lt;span&gt;Valid&lt;/span&gt;() {
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;statusList&lt;/span&gt;[&lt;span&gt;c&lt;/span&gt;]
}
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Code(&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;strconv&lt;/span&gt;.&lt;span&gt;FormatInt&lt;/span&gt;(int64(&lt;span&gt;c&lt;/span&gt;), &lt;span&gt;10&lt;/span&gt;) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;)&quot;&lt;/span&gt;
}

&lt;span&gt;// 返回错误码对应的 HttpStatusCode, 未知错误返回 500
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;c&lt;/span&gt; &lt;span&gt;StatusCode&lt;/span&gt;) &lt;span&gt;Http&lt;/span&gt;() &lt;span&gt;int&lt;/span&gt; {
&lt;span&gt;if&lt;/span&gt;  &lt;span&gt;c&lt;/span&gt;.&lt;span&gt;Valid&lt;/span&gt;() {
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;httpList&lt;/span&gt;[&lt;span&gt;c&lt;/span&gt;]
}
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;http&lt;/span&gt;.&lt;span&gt;StatusInternalServerError&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以 &lt;code&gt;Internal&lt;/code&gt; 为例:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Http() =&amp;gt; 500&lt;/li&gt;
&lt;li&gt;String() =&amp;gt; INTERNAL&lt;/li&gt;
&lt;li&gt;Error() =&amp;gt; 500 INTERNAL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来, 我们需要一个方便的机制来标记我们的错误类型, 就像 &lt;code&gt;fmt.Errorf()&lt;/code&gt; 那样. 这里我们定义一个 &lt;code&gt;Annotate()&lt;/code&gt; 函数.&lt;/p&gt;
&lt;p&gt;这个函数使用起来应该像这样:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;Annotate&lt;/span&gt;(&lt;span&gt;sql&lt;/span&gt;.&lt;span&gt;ErrNoRows&lt;/span&gt;, &lt;span&gt;NotFound&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Annotation 方法和 annotated 自定义错误:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;annotated&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
&lt;span&gt;cause&lt;/span&gt;   &lt;span&gt;error&lt;/span&gt;
&lt;span&gt;code&lt;/span&gt;    &lt;span&gt;StatusCode&lt;/span&gt;
}

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;e&lt;/span&gt; &lt;span&gt;annotated&lt;/span&gt;) &lt;span&gt;Unwrap&lt;/span&gt;() &lt;span&gt;error&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;.&lt;span&gt;cause&lt;/span&gt; }
&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;e&lt;/span&gt; &lt;span&gt;annotated&lt;/span&gt;) &lt;span&gt;Error&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;.&lt;span&gt;cause&lt;/span&gt;.&lt;span&gt;Error&lt;/span&gt;() }

&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Annotation&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
    &lt;span&gt;Annotate&lt;/span&gt;(&lt;span&gt;a&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;annotated&lt;/span&gt;)
}

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Annotate&lt;/span&gt;(&lt;span&gt;cause&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;, &lt;span&gt;annotations&lt;/span&gt; &lt;span&gt;...&lt;/span&gt;&lt;span&gt;Annotation&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; {
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;cause&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; len(&lt;span&gt;annotations&lt;/span&gt;) &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;cause&lt;/span&gt;
    }
    
    &lt;span&gt;a&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;annotated&lt;/span&gt;{ &lt;span&gt;cause&lt;/span&gt;: &lt;span&gt;cause&lt;/span&gt; }
    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;, &lt;span&gt;annotation&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; &lt;span&gt;annotations&lt;/span&gt; {
        &lt;span&gt;annotation&lt;/span&gt;.&lt;span&gt;Annotate&lt;/span&gt;(&lt;span&gt;a&lt;/span&gt;)
    }
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;让 &lt;code&gt;StatusCode&lt;/code&gt; 实现 &lt;code&gt;Annotation&lt;/code&gt; 接口&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;c&lt;/span&gt; &lt;span&gt;StatusCode&lt;/span&gt;) &lt;span&gt;Annotate&lt;/span&gt;(&lt;span&gt;a&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;annotated&lt;/span&gt;) { &lt;span&gt;a&lt;/span&gt;.&lt;span&gt;code&lt;/span&gt; = &lt;span&gt;c&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;还需要一个 Code() 函数获取当前的错误码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;code&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;Code&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt;)  &lt;span&gt;// 404 NotFound
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Code()&lt;/code&gt; 方法&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Code&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) (&lt;span&gt;out&lt;/span&gt; &lt;span&gt;StatusCode&lt;/span&gt;) {
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;OK&lt;/span&gt;
}
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;a&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;annotated&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;errors&lt;/span&gt;.&lt;span&gt;As&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt;, &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;) {
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;.&lt;span&gt;code&lt;/span&gt;
}
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;Unknown&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;很好, 现在我们就可以为任何错误附加错误码了, 并且可以用新的错误码覆盖原有的.&lt;/p&gt;
&lt;h3 id=&quot;错误详情-1&quot;&gt;错误详情&lt;/h3&gt;
&lt;p&gt;在之前的表格中, 每个错误码都是有对应的详情的. 现在来实现这部分, 就以 DebugInfo 为例.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Any&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
    &lt;span&gt;Annotation&lt;/span&gt;
    &lt;span&gt;TypeUrl&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt;  &lt;span&gt;// 序列化时的 @type 字段需要
&lt;/span&gt;&lt;span/&gt;}

&lt;span&gt;type&lt;/span&gt; &lt;span&gt;DebugInfo&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
&lt;span&gt;StackEntries&lt;/span&gt; []&lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;stackEntries,omitempty&quot;`&lt;/span&gt;
&lt;span&gt;Detail&lt;/span&gt;       &lt;span&gt;string&lt;/span&gt;   &lt;span&gt;`json:&quot;detail,omitempty&quot;`&lt;/span&gt;
}

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;d&lt;/span&gt; &lt;span&gt;DebugInfo&lt;/span&gt;) &lt;span&gt;TypeUrl&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt;       { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;type.googleapis.com/google.rpc.DebugInfo&quot;&lt;/span&gt; }
&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;d&lt;/span&gt; &lt;span&gt;DebugInfo&lt;/span&gt;) &lt;span&gt;Annotate&lt;/span&gt;(&lt;span&gt;a&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;annotated&lt;/span&gt;) { &lt;span&gt;a&lt;/span&gt;.&lt;span&gt;details&lt;/span&gt; = append(&lt;span&gt;a&lt;/span&gt;.&lt;span&gt;details&lt;/span&gt;, &lt;span&gt;d&lt;/span&gt;) }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;给自定义错误加上 &lt;code&gt;details&lt;/code&gt; 字段&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;annotated&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
&lt;span&gt;cause&lt;/span&gt;   &lt;span&gt;error&lt;/span&gt;
&lt;span&gt;code&lt;/span&gt;    &lt;span&gt;StatusCode&lt;/span&gt;
    &lt;span&gt;details&lt;/span&gt; []&lt;span&gt;Any&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用方式和设置状态码一摸一样&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;info&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;DebugInfo&lt;/span&gt;{[]&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;step1&quot;&lt;/span&gt;, &lt;span&gt;&quot;step2&quot;&lt;/span&gt;}, &lt;span&gt;&quot;some message&quot;&lt;/span&gt;}
&lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;Annotate&lt;/span&gt;(&lt;span&gt;sql&lt;/span&gt;.&lt;span&gt;ErrNoRows&lt;/span&gt;, &lt;span&gt;NotFound&lt;/span&gt;, &lt;span&gt;info&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;别忘了详情获取的函数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Details&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) (&lt;span&gt;details&lt;/span&gt; []&lt;span&gt;Any&lt;/span&gt;) {
    &lt;span&gt;next&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;err&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; &lt;span&gt;next&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;, &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;.(&lt;span&gt;*&lt;/span&gt;&lt;span&gt;annotated&lt;/span&gt;); &lt;span&gt;ok&lt;/span&gt; {
&lt;span&gt;details&lt;/span&gt; = append(&lt;span&gt;details&lt;/span&gt;, &lt;span&gt;a&lt;/span&gt;.&lt;span&gt;details&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;)
}
&lt;span&gt;next&lt;/span&gt; = &lt;span&gt;errors&lt;/span&gt;.&lt;span&gt;Unwrap&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt;)
}
&lt;span&gt;return&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用示例:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;details&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;Details&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt;)  &lt;span&gt;// [{[&quot;step1&quot;, &quot;step2&quot;], &quot;some message&quot;}]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;错误处理行为&quot;&gt;错误处理行为&lt;/h3&gt;
&lt;p&gt;顺带支持一下 &lt;code&gt;Temporary()&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Temporary&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) &lt;span&gt;bool&lt;/span&gt; {
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Code&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt;) &lt;span&gt;==&lt;/span&gt; &lt;span&gt;Unavailable&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;只有 &lt;code&gt;503 Unavailable&lt;/code&gt; 是可以 100% 重试的, 因为请求还未到达服务器, 其他错误则要看具体业务才能确认幂等性.&lt;/p&gt;
&lt;h3 id=&quot;encode--decode--formatter&quot;&gt;Encode &amp;amp; Decode &amp;amp; Formatter&lt;/h3&gt;
&lt;p&gt;这部分涉及到格式化, 代码展开占的篇幅就太长了, 可以到 GitHub 上看源码, 简单提下要点.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解码 Detail 时要根据不同的 &lt;code&gt;@type&lt;/code&gt; 选择不同的 Detail 实现&lt;/li&gt;
&lt;li&gt;需要有一个 &lt;code&gt;Register()&lt;/code&gt; 函数注册自定义的 Detail 实现&lt;/li&gt;
&lt;li&gt;需要有一个 &lt;code&gt;Filter&lt;/code&gt; 支持只编码部分 Detail (向外传播时要隐藏内部信息)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再看两个例子, 先是格式化:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;status: &quot;504 DEADLINE_EXCEEDED&quot;
message: &quot;context deadline exceeded&quot;
detail[0]:
type: &quot;type.googleapis.com/google.rpc.DebugInfo&quot;
detail: &quot;heavy job&quot;
stack:
goroutine 1 [running]:
runtime/debug.Stack(0xc00005e980, 0x40, 0x40)
/home/user/go/src/runtime/debug/stack.go:24 +0xa5
github.com/gota33/errors.StackTrace.Annotate(0xfe36af, 0x9, 0x1056490, 0xc00005e980)
/home/user/github/gota33/errors/detail.go:368 +0x2d
github.com/gota33/errors.Annotate(0x1051780, 0x1257e60, 0xc00010fc00, 0x5, 0x5, 0xc00010fba8, 0x10)
/home/user/github/gota33/errors/errors.go:79 +0x97
github.com/gota33/errors.ExampleAnnotate()
/home/user/github/gota33/errors/example_test.go:10 +0x251
testing.runExample(0xfe589a, 0xf, 0xfff6c0, 0xfead08, 0x1a, 0x0, 0x0)
/home/user/go/src/testing/run_example.go:63 +0x222
testing.runExamples(0xc00010fed0, 0x120aee0, 0x3, 0x3, 0x0)
/home/user/go/src/testing/example.go:44 +0x185
testing.(*M).Run(0xc000114100, 0x0)
/home/user/go/src/testing/testing.go:1419 +0x27d
main.main()
_testmain.go:71 +0x145
detail[1]:
type: &quot;type.googleapis.com/google.rpc.RequestInfo&quot;
request_id: &quot;&amp;lt;uuid&amp;gt;&quot;
serving_data: &quot;&quot;
detail[2]:
type: &quot;type.googleapis.com/google.rpc.LocalizedMessage&quot;
local: &quot;en-US&quot;
message: &quot;Background task timeout&quot;
detail[3]:
type: &quot;type.googleapis.com/google.rpc.LocalizedMessage&quot;
local: &quot;zh-CN&quot;
message: &quot;后台任务超时&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还有 JSON 序列化:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;{
  &lt;span&gt;&quot;error&quot;&lt;/span&gt;: {
    &lt;span&gt;&quot;code&quot;&lt;/span&gt;: &lt;span&gt;504&lt;/span&gt;,
    &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;context deadline exceeded&quot;&lt;/span&gt;,
    &lt;span&gt;&quot;status&quot;&lt;/span&gt;: &lt;span&gt;&quot;DEADLINE_EXCEEDED&quot;&lt;/span&gt;,
    &lt;span&gt;&quot;details&quot;&lt;/span&gt;: [
      {
        &lt;span&gt;&quot;@type&quot;&lt;/span&gt;: &lt;span&gt;&quot;type.googleapis.com/google.rpc.RequestInfo&quot;&lt;/span&gt;,
        &lt;span&gt;&quot;requestId&quot;&lt;/span&gt;: &lt;span&gt;&quot;&amp;lt;uuid&amp;gt;&quot;&lt;/span&gt;
      },
      {
        &lt;span&gt;&quot;@type&quot;&lt;/span&gt;: &lt;span&gt;&quot;type.googleapis.com/google.rpc.LocalizedMessage&quot;&lt;/span&gt;,
        &lt;span&gt;&quot;local&quot;&lt;/span&gt;: &lt;span&gt;&quot;en-US&quot;&lt;/span&gt;,
        &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;Background task timeout&quot;&lt;/span&gt;
      },
      {
        &lt;span&gt;&quot;@type&quot;&lt;/span&gt;: &lt;span&gt;&quot;type.googleapis.com/google.rpc.LocalizedMessage&quot;&lt;/span&gt;,
        &lt;span&gt;&quot;local&quot;&lt;/span&gt;: &lt;span&gt;&quot;zh-CN&quot;&lt;/span&gt;,
        &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;后台任务超时&quot;&lt;/span&gt;
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;写到这里篇幅已经很长了, 不过依然有很多方面没有提到. 比如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何用 &lt;code&gt;http.RoundTripper&lt;/code&gt; 让 &lt;code&gt;http.Client&lt;/code&gt; 实现自动错误解码?&lt;/li&gt;
&lt;li&gt;如何用 &lt;code&gt;middleware&lt;/code&gt; 让服务器实现自动错误编码?&lt;/li&gt;
&lt;li&gt;如何用 &lt;a href=&quot;https://github.com/go-playground/validator&quot;&gt;validator&lt;/a&gt; 集中处理错误, 生成 BadRequest 详情?&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再写点 Memo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;错误一般集中在服务边界, 80% 的错误出现在入口 Handler 和对外部服务的调用&lt;/li&gt;
&lt;li&gt;底层错误能重试的应该尽量重试, 比如: 503 错误&lt;/li&gt;
&lt;li&gt;事务级别的重试一般在业务层, 比如: 数据库锁超时要重试事务&lt;/li&gt;
&lt;li&gt;重试一定要记得设置最大超时, 避免无限重试&lt;/li&gt;
&lt;li&gt;处理错误最好的方法: 修改定义, 使原本出错的情景不再是错误.&lt;/li&gt;
&lt;li&gt;任何情况下都不该隐藏错误, 即便是崩溃也好于隐藏.&lt;/li&gt;
&lt;li&gt;机器更关注如何处理错误, 人类更关注错误信息.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有本文的灵感来源：&lt;/p&gt;

&lt;p&gt;最后是本文中错误处理库的源码:&lt;/p&gt;

&lt;p&gt;感谢阅读, 评论可以到 &lt;a href=&quot;https://www.v2ex.com/t/779942&quot;&gt;V2ex&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>547148c62a3bc2ca62f0bc5b96ca3d34</guid>
<title>如何确定图 (Graph) 里有没有环 (Cycle)？</title>
<link>https://toutiao.io/k/97ce002</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;“判断图中是否有&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;环&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;”是一道经常出现在面试中经典的算法题，我们今天就来讲讲这道题的含义和解法，包含Python编码全过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;题目中的概念&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;判断图中是否有环这道题目首先涉及到两个概念：图和环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里的图就是计算机数据结构中说的图结构（Graph），它包括两个要素：顶点和边，前者又称为节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;节点表示事物的抽象，而边则表示事物之间两两的联系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6378947368421053&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfrJth6XOo3LLXXNib6Aar2IpMGXYC4mfPEe8uVqZQPiaws9VeK9fAglLQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;475&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;边可以分为有方向和无方向两种。有方向的边表示两个节点之间单向的连通，而无方向的边则表示双向连通。边有方向的图叫做有向图，反之叫做无向图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4090909090909091&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfxWdGaedmaZTPgBMuU2lUibIjmY3h4iaozFwhiaStb22dbGnVAGjxRWia7A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;704&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;环则是指在途中一条由边组成的路径，从一个节点出发，可以回到这个节点自身。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4659090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfemFI0wHtWLQgoJU5Qk3giabbq2c1zicb3NCKfyd3oSic245ubLaI7kk0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;440&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;判断无向图中是否有环&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上面的定义可知，无论有向图还是无向图中都存在环，但有向图的环涉及到边的方向，要比无向图复杂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，如果你在面试中被要求写一个算法“判断图中是否有环”，首先就应该和面试官确认，要判断的是有向图还是无向图。本文我们讲解的是无向图中是否有环的判断！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如下面这两个无向图，很显然图一里面有环，而图二没有。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfzya2ic5JXcMBtQeDzwwEyZJACrbZ7lbFDlztGdF9iaG20YmHB0IwDf0A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;从算法的原理开始&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用眼睛看起来很简单的事情，如何用程序来实现呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在动手编程之前，我们首先要想清楚如何做，也就是说我们先要能够找到一个用自然语言可以描述的办法，来确定无向图中是否有环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实很多算法最难的一点实在这里，平白的给你一张无向图，你能找出一个切实可行的办法，把它描述出来，别人只要按照指示去做，就一定能正确地确认任何一个无向图里面有没有环吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7643742953776775&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfRc8VoxcWBQdVj5MUIovicnWI7TuqjpMbFxsnryOA1gGTHngGiboRSPaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;887&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你从来没有学过相关的知识，自己拍脑袋就想出这样的一个办法来了！那么恭喜，你已经具备了创造算法的能力！不过对于大多数人来说，我们还是需要寻求前人的帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最简单的方法：在互联网上查找一下。我们在搜索引擎中输入“判断无向图有没有环”这个查询语句，然后看到很多相关的搜索结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfYicaibVd8MaAdibvmEo8wJ7otXuWcdznz3mzMYOz2DZ4hxGabJF2ZtAlQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们直接点击第一个。看到了下面这个文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.80546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfX823FJMYn7Uicic8vXg5CqqiaT7mz1h6Dt4YfYsfrQCiamt7nY97BG2ZOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文中讲的内容比较多，介绍了三种方法：拓扑排序，DFS和Union-Find Set，每一种方法都可以判断无向图或者有向图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;拓扑排序法判断一个无向图中是否有环&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“判断一个无向图有没有环”的方法本文中就有三个。这里，我们先取第一种方法：拓扑排序判断无向图是否有环。这种方法的描述如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用拓扑排序可以判断一个无向图中是否存在环，具体步骤如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;155&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;    1. 求出图中所有节点的度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    2. 将所有度 &amp;lt;= 1 的节点入队。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    3. 当队列不空时进入循环，弹出队首元素，把与队首元素相邻节点的度减一。如果相邻节点的度变为1，则将相邻节点入队。队列为空则退出循环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    4. 循环结束时判断已经访问过（进入过队列）的节点数是否等于 n。等于 n 说明全部节点都被访问过，无环；反之，则有环。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们将算法改写成控制流程图是下面这样：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.798469387755102&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfUEpyzMQ2wlp4Wb7dOS9DX3aeM9FUd7HQZ6hWWWh5QZewQKtJzFqCxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;784&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里面又涉及到了一个概念——节点的度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么叫做节点的度呢？其实很简单，节点的度是指和该节点相关联的边的条数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果是有向图，还要分入度和出度，不过我们现在要处理的是无向图，所以，每条边都是平等的，统一都记作度数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.35609103078982596&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfcrWCahRvZcK9zHj8W86Wfp6iborYYoJHrvxysN5TsYmdIicojibapJCLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;747&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;人肉模拟运行算法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们来找两个例子，按照算法模拟运行一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一个例子&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先看图一，图一中节点1，2，3的度是2，节点4和5的度是3，而节点6和7的度是1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfLLCrEtAtID0au6Nfz4RETbgqkyKsXicLmdfZOibsIcfjkfdlcCAGib85w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那首先，我们要把节点6和7放到队列里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后将节点6弹出，把和节点6相邻的节点5的度减一。从图上，就相当于擦掉了节点5和节点6之间的边。按理说此时节点6的度也应该减掉1，但是因为节点6我们已经处理过，它以后不会再进入队列，我们也不不会再关心它的度，因此也不用去处理它的度了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时队列还没有空，所以我们继续弹出队首并处理。弹出节点7，将和它相邻的节点4的度减一，相当于删除了它们之间的边。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在队列已经弹空，退出了循环。我们再看进入过队列的节点只有2个，而节点一共有7个，2 不等于 7， 所以有环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二个例子&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在再来看图二，一共5个节点，相应的度分别是1，2，2，2，1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6002386634844868&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfjZrZkfrSK8Pc1HokNYliadRj6cfpm9yHdk60ia47xaMjFLrKAr4PWDww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;838&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此第一拨入队列的是&lt;/span&gt;&lt;span&gt;度&lt;/span&gt;&lt;span&gt;为1的节点1和节点5。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;节点1出队列后和它相邻的节点2度数减一，也变成了度为1的节点，因此节点2入队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再度进入循环，弹出节点5，和它相邻的节点4度数减一后入队列。继续循环弹出节点2，节点3入队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;循环弹出节点4，节点3的度变成0，不用再度入栈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后一次循环弹出节点3，和它相邻的再无度为1的节点，循环结束。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至此，所有节点都已经入过队列，因此可知，无环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直观来看，算法是有效的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;确定数据结构&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么下面是不是就该编程实现了？稍等，别忘了，&lt;strong&gt;程序 = 算法 + 数据结构&lt;/strong&gt;。我们现在只有算法，还没有描述无向图的数据结构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图的表示方法不止一种，此处我们采用邻接矩阵表示无向图。很多时候，当面试官出题要求判断图中是否有环时，会特意指出要用邻接矩阵。如果没指出，就是让你自选。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.608&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfic7HKyiaN5tzjKFl1s6ZoGib4kIvSn4JRl6icjvXLxVjLlNw6SqYWQA5vQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;邻接矩阵是一个 n 阶的方阵，n 为图中顶点个数。方阵中每个元素的值只有两种可能，要么 0 ，要么 1。若第 i 行第 j 列的元素为 1，则说明 i 节点和 j 节点相邻，也就是有一条无向边存在于二者之间，若为 0，则说明节点 i 和 j 不相邻。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由此图一和图二对应的矩阵分别是这样：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.41753171856978083&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSf4MO9KJcMP8DoicDBev0ZckXm7m2MIAwtP7TctFYYqZcUHZ0LtGWne3Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;867&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;邻接矩阵也可以用在有向图上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过对无向图而言：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    i) 邻接矩阵一定是对称的，而且主对角线一定为零（自己不可能和自己相邻）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    ii) 在无向图中，节点 i 的度是矩阵第 i 行（或第 i 列）所有非零元素的个数。因为非零元素的取值只能是 1，因此节点 i 的度也是邻接矩阵第 i 行所有值的和。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另一方面，方阵就是一个二维表，在程序内部，正好用一个二位数组或列表（List）来表示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很好，既然如此，我们就可以开始编程了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编程实现算法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们用Python来编。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在正式实现算法之前，我们先要进行数据处理，也就是我们需要将表达无向图的矩阵读取到内存中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里又涉及到该数据在磁盘存储的问题。我们就用最简单的方式，将邻接矩阵直接存储为 csv 文件，就像这样：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfk5qMuYX9daWgR9WJRsKMv7Z5KicLteT4WicBy8LPicL2ibmNlNtqctpqJQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们专门定义一个函数（如下图）做数据处理，那么在读取的时候，我们就可以用 Python的csv library，用csv.reader() 读取 csv文件，然后再转化为列表。&lt;span&gt;这个列表就是算法的输入。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2947761194029851&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfc00ic9ib46antk3WoWZAmmqkiahfAceCDIxK5Hgcn4oXDIiaxdT3hOwvIg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;536&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在来看算法本身。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们定义一个函数，名为 is_undirected_graph_circled，它接受一个输入参数：adj_matrix，这个adj_matrix 是一个二维表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要处理二维表，也就是输入的邻接方阵，我们首先要知道方阵的阶数，那么很好办，我们只要用 len 函数，就可以。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后我们要计算所有节点的度，并且将度  &amp;lt;=1 的节点压入队列。这里要用到队列，我们就用Python自带的queue library，先import，然后直接创建一个队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着计算每个节点的度，将它们存储在degrees列表里，用一个循环，每个循环对用矩阵的一行，然后 sum函数将该行中所有的元素相加。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里有一点要注意，我们直接用csv.reader读取出来的数据是字符串，我们要对其进行数据转换，将其转化为整数型，这样才能有效地计算度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;算出一个节点的度后直接判断是否小于等于 1，若是则入队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里还要注意一件事情，我们的算法最终要判断有多少节点入过队，但是队列本身要不断地压入弹出，里面不可能保留所有入过队的节点。所以要用一个专门的列表存储每个入队的元素。就是这个visited。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3853459972862958&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfReuvcNHu29ecIeebSuHdUcoXG8W8puklgcia6lq29zF53wZsamcVv0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;做完这些就该进入到最核心的循环部分了。循环中的&lt;strong&gt;关键&lt;/strong&gt;则是：把与队首元素相邻节点的度减 1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们该怎么找到与队首节点相邻的节点呢？比如节点 i，在邻接方阵里，第 i 行和第 i 列的所有元素都记录了它的邻居，那么我们可以选取第 i 行作为线索，找到所有值为 1 的元素，该元素所在的列数 j 所对应的 j 节点，就是与 i 相邻的节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么我们需要将degrees里对应 j 元素的值减去 1。然后看看它减掉 1 后的值是否为 1，若是则入队，否则不管。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当队中元素全部弹出后，循环结束，我们看看 visited 列表中的元素个数是否已经达到了 n 个，若是则说明无环，否则有环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5359565807327001&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zxQkPcwCBCEUQkIiaz7qkE5BsUZNUdzSfpw0Kd8bCwv6yDtKTrItYb6CEDYlN6xsU6EU9yUiaWM72aUcibKO51Aew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;算法函数定义好之后，可以在数据处理函数中调用，然后把结果打印出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;完整代码和数据请见： &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;https://github.com/juliali/ClassicAlgorithms/tree/main/undirected_graph&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-id=&quot;90150&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;“众智汇”&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;愿景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;尽职尽才，允公允能 &lt;/span&gt;—— &lt;/strong&gt;本社群不定期举行线上分享，组织群友分享知识、经验、资源，以达到&lt;strong&gt;让我们每个人的职业生涯得到最大程度的发展&lt;/strong&gt;的目的&lt;/span&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎扫面下列二维码关注“悦思悦读”公众微信号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zxQkPcwCBCEmlJImTeETa35r88nRpT8dFLhcEjFmYqBg8picmuaCZUbtXY2EEx9FLNCkNUy1nBEibHicqUfJZ9yeg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>