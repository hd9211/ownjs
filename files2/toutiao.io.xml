<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2fc8817ef976116c28cdbb3b39e106cc</guid>
<title>厉害了！国外顶级计算机大神耗时两年时间整理出来这份 2000 页深入理解计算机系统笔记</title>
<link>https://toutiao.io/k/4hjd6qw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content_views&quot; class=&quot;htmledit_views&quot;&gt;
                    &lt;h1&gt;&lt;strong&gt;计算机系统类别的课程一直是计算机科学与技术专业的主要教学内容之一。由于历史原因，我国的计算机专业的课程体系曾广泛参考ACM和 IEEE 制订的计算机科学与技术专业教学计划(Computing Curricula)设计，计算机系统类课程也参照该计划分为汇编语言、操作系统、组成原理、体系结构、计算机网络等多门课程。应该说，该课程体系在历史上对我国的计算机专业教育起很好的引导作用。&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;进入新世纪以来，计算技术发生了重要的发展和变化，我国的信息技术和产业也得到了迅猛发展，对计算机专业的毕业生提出了更高要求。重新审视原来我们参照 ACM/IEEE计算机专业计划的课程体系，会发现存在以下几个方面的主要问题。&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;1)课程体系中缺乏一门独立的能够贯穿整个计算机系统的基础课程。计算机系统方面的基础知识被分成了很多门独立的课程，课程内容彼此之间缺乏关联和系统性。学生学习之后，虽然在计算机系统的各个部分理解了很多概念和方法，但往往会忽视各个部分之间的关联，难以系统性地理解整个计算机系统的工作原理和方法。&lt;/li&gt;&lt;li&gt;2)现有课程往往偏重理论，和实践关联较少。如现有的系统课程中通常会介绍函数调用过程中的压缩和退栈方式，但较少和实践关联来理解压栈和退栈过程的主要作用。实际上，压栈和退栈与理解C等高级语言的工作原理息息相关，也是常用的攻击手段 Buffer Overflow的主要技术基础。&lt;/li&gt;&lt;li&gt;3）教学内容比较传统和陈旧，基本上是早期PC时代的内容。比如，现在的主流台式机CPU都已经是x86-64指令集，但较多课程还在教授80386 甚至更早的指令集。对于近年来出现的多核/众核处理器、SSD硬盘等实际应用中遇到的内容更是涉及较少。&lt;/li&gt;&lt;li&gt;4）课程大多数从设计者的角度出发，而不是从使用者的角度出发。对于大多数学生来说，毕业之后并不会成为专业的CPU设计人员、操作系统开发人员等，而是会成为软件开发工程师。对他们而言,最重要的是理解主流计算机系统的整体设计以及这些设计因素对于应用软件开发和运行的影响。&lt;/li&gt;&lt;/ul&gt;
&lt;h1&gt;因此小编找出了一系列计算机相关书籍，给大家分享出来：&lt;/h1&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/1c0a6d8c89d741a3b9c0d857e140cd3e.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;需要获取的小伙伴可以直接私信（学习）获取&lt;/p&gt; 
&lt;h1&gt;《深入理解计算机系统》775页&lt;/h1&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/db42d51bd30a2f052779c7c5b162632d.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;本书从程序员的视角详细阐述计算机系统的本质概念，并展示这些概念如何实实在在地影响应用程序的正确性、性能和实用性。全书共12章，主要包括信息的表示和处理、程序的机器级表示、处理器体系结构、优化程序性能、存储器层次结构、链接、异常控制流、虚拟存储器、系统级1/O、网络编程、并发编程等内容。书中提供了大量的例子和练习题，并给出部分答案，有助于读者加深对正文所述概念和知识的理解。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h1&gt;内容介绍&lt;/h1&gt; 
&lt;h1&gt;第一部分程序结构和执行&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第1章计算机系统漫游&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/733227c2df8e90f4b507e1289e7369f3.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第2章信息的表示和处理&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/71621d9db998a6c05e1c75930fe0093b.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第3章程序的机器级表示&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/3ff25eeb229627f7b8fa92c076223a93.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第4章处理器体系结构&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/c737f539a90e4e10a1481d1cfe01e159.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第5章优化程序性能&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/fb6555bbcd4a8573201181ba7dc25ed5.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第6章存储器层次结构&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/cdef5b312ae2704fb1a9798e7a05f5fc.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h1&gt;第二部分在系统上运行程序&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第7章链接&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/70d5adf258f81ea4580dbf5fec513d03.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第8章异常控制流&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d16e568aa4216e22a167c56929581828.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第9章虚拟内存&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/f32439db6d77c65287fa69efdae8661b.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h1&gt;第三部分程序间的交互和通信&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第10章系统级i/O&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/7c0ad8147c69c64e864344663673b235.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第11章网络编程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/ad4dbc387f59065c84f430a25d044c73.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第12章并发编程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/257113b58614996b5663806590565dd5.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;因为这份文档有700多页下面还有很多需要展示。就不给大家一一展示了，需要获取的小伙伴可以直接转发+关注后添加小助理vx：maxiaoanan&lt;/strong&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/2020112115595614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzU5MjA=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt; 
&lt;h1&gt;《逻辑与计算机设计基础》500页&lt;/h1&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/34ca9f7448c8c5db403cf173920a9c88.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;除了提供完整的数字和计算机设计内容之外，第5版还特别强调现代设计的基本原理。从简单的组合逻辑应用到在RISC核上构建CISC结构，多个例子的清晰解释和渐进式的设计过程可以诠释书中内容。完整的传统内容包括计算机辅助设计、问题形式化、解决方案验证，以及综合能力培养，而灵活性则体现在可选的逻辑设计、数字系统设计和计算机设计,以及硬件描述语言的相关内容中(不选、选用VHDL或选用Verilog)。&lt;/strong&gt;&lt;/p&gt; 
&lt;h1&gt;内容介绍&lt;/h1&gt; 
&lt;h1&gt;逻辑设计&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第1章介绍数字计算机、计算机系统抽象层次、嵌入式系统，以及包括数制、算术运算和编码在内的信息表示。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d88d685d80b1117b5d47532e2cce0c2d.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第⒉章研究门电路和它们的类型，以及设计和成本优化的基本方法。概念包括布尔代数、代数优化和卡诺图优化、传播延迟，以及在VHDL和Verilog 中使用结构和数据流模型表示的门级硬件描述语言模型。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/1cb8d36a92d5cede5d3003d263957612.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第3章从一个现代逻辑设计过程的概述开始，设计过程的详细步骤包括问题形式化、逻辑优化、用于非门和或非门进行工艺映射，组合逻辑设计的实例中还包括验证。另外，这一章还包括函数和构建组合设计模块，包括使能和输入定值、译码、编码、代码转换、选择、分配、加法、减法、递增、递减、填充、扩展和移位以及它们的实现。本章还包括许多逻辑模块的VHDL和Verilog模型。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/e074d5d45603143fc62990abd61c9f72.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第4章包括时序电路分析和设计。讨论了锁存器和边沿触发式触发器，并着重讲解了D触发器。本章的重点是状态机图和状态表的形式化表示。时序电路完整的设计过程包括规格说明、形式化、状态分配、触发器输入和输出方程确定、优化、工艺映射以及验证。时序电路通常都太复杂，不能用传统的状态图来表示，但可以用状态机图模型来表示，这一章通过现实世界的两个例子来阐述和说明这一观点。这一章包括用VHDL 和 Verilog来描述触发器和时序电路，介绍了VHDL和 Verilog程序行为的语言结构以及用于验证的测试程序。本章最后介绍了时序电路的延迟和定时，以及异步输入的同步和亚稳态问题。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/ca82efbac23826d32dd5f7c9c3628935.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h1&gt;数字系统设计&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第5章重点介绍当前技术的各个方面，包括MOS晶体管和CMOS电路，以及可编程逻辑技术。可编程逻辑包括只读存储器、可编程逻辑阵列、可编程阵列逻辑和FPGA。这一章包括一些例子，它们用一个简单的FPGA结构来解释在更为复杂的商用FPGA硬件中出现的各种各样的可编程元器件。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/384b6bd71e033390ed5a8945d4023020.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第6章讲解寄存器及其应用。移位寄存器和计数器的设计基于第3章和第4章所讲解的触发器和某些函数及其实现。只有行波计数器作为--个全新的概念加以介绍。讨论了寄存器传输的并行和串行方式，以及如何权衡时间与空间开销。其中有一节侧重于执行多种运算的多功能寄存器的寄存器单元设计。数据通路和控制单元的协同设计过程使用了寄存器传输语言和状态截图，并且用现实世界的两个例子对其进行了解释。对所选的寄存器类型也用Verilog和VHDL语言进行了描述。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/2832cbd579efcab38fd25af2f315df95.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第7章介绍静态随机访问存储器（SRAM）和动态随机访问存储器（DRAM)，以及基本存储器系统,还简单地介绍了动态随机访问存储器的各种不同类型。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/fbdc7459391a69dde5ae7e261c0723bb.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h1&gt;计算机设计&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第8章讲述寄存器文件、功能单元、数据通路，以及两种简单计算机——单周期计算机和多周期计算机。重点讨论数据通路和控制单元设计的形式化概念，以及用它们来设计具有特定指令和指令集的单周期和多周期计算机。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d114fef46455e2bfe1e8e2e1142615f3.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第9章介绍与指令集结构相关的许多内容，包括地址计算、寻址模式、指令结构和类型，并讲解浮点数表示法和浮点运算，以及程序控制方法，包括过程调用与中断。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/31613ef3488d442902db7aee58d3beab.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第10章讨论一些高性能处理器的概念，如流水式RISC和CISC处理器。通过将微编码硬件添加到修改了的RISC处理器上，CISC处理器可以使用RISC的流水线来执行CISC指令集，这是当今CISC处理器中使用的一种方法。除此之外，还介绍了高性能CPU在概念和结构方面的创新，其中包括两个多CPU微处理器的例子。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/193f202708f5414c0d5ffdb951539438.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第11章讲解如何在CPU和内存之间、输入/输出接口和外围设备之间进行数据传送。讨论了键盘、液晶显示器（LCD)、硬盘驱动器等外部设备和键盘接口，以及包括通用串行总线(USB）在内的串行通信和中断系统的实现。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/b5f46d8effbb16b3e5b5d97009e75096.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第12章重点讨论存储器的分层。介绍了“访问的局部性”的概念，并通过cache和内存之间、内存和硬盘之间的关系对其进行了详细讲解。分析了cache设计的各种参数。存储器管理重点关注分页管理和支持虚拟存储的传输后备缓冲器&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/52ba02cf9821ee200a0ce806f0f4ab70.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h1&gt;《计算机文化》534页&lt;/h1&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/7e3f2f1dd4beb8e82c219c225988ae65.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第1章计算机和数字基础知识&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/5b820a3abc02490ba926f0f9d80ecf1a.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第2章计算机硬件&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/171461a384a60fab5051744cc54c899a.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第3章计算机软件&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/af05bcf784e0cecb7501b4efeeb3f5e0.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第4章操作系统和文件管理&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/f0a5786be3cd11fe880e0f082a829f28.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第5章局域网&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/7f274302024290dbd0e1b30a1cffae84.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第6章因特网&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d1b6784a1bcdf0a255b755e606329a48.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第7章Web 和电子邮件&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/241173941142fe5bb7ca2d758e8a5bf0.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第8章数字媒体&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d9ad4a1729be775163fcc414b5710f09.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第9章计算机产业:历史、职业和道德&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/f70d11967db8b8b6835cb13eddc5b192.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第10章信息系统的分析与设计&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/7554c578c6aa02aac7b5eec12c357ba6.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第11章数据库&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/b90eab47eaa28d24cd25b6e7a37e2cbe.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第12章计算机编程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d5fe5603fee7b47e2c83f037a5b153f9.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;因为这份文档有700多页，下面还有很多需要展示。就不给大家一一展示了，需要获取的小伙伴可以直接转发+关注后&lt;/strong&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/20201121160021406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzU5MjA=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e665ab28b13fc87c4fd4fb843fa9ff8a</guid>
<title>用 WebRTC 和 Node.js 开发实时视频聊天应用</title>
<link>https://toutiao.io/k/5shq47n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;elementor-widget-container&quot;&gt;

&lt;p&gt;话不多说，我们直奔主题。这篇文章教大家如何编写一个视频聊天应用，使已连接的两用户端能共享视频和音频。操作很简单，非常适合JavaScript语言训练——更准确地说是WebRTC技术和&lt;a href=&quot;https://tsh.io/services/web-development/node/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot; title=&quot;https://tsh.io/services/web-development/node/&quot;&gt;Node.js&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;什么是WebRTC&lt;/strong&gt;&lt;strong&gt;？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;Web Real-Time Communications 网页实时通信，简称WebRTC。WebRTC是一个HTML5规范，它允许用户在浏览器之间直接进行实时通信，不需要任何第三方插件。WebRTC可用于多种情境（比如文件共享），但端对端实时音频和视频通信是其主要功能。本文将着重为大家介绍这两项。&lt;/p&gt;



&lt;p&gt;WebRTC所做的就是允许接入设备。你可以借WebRTC来实时使用麦克风、摄像头和分享你的屏幕。&lt;/p&gt;



&lt;p&gt;所以，WebRTC可以用最简单的方式在网页中实现音频和视频通信。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;WebRTC JavaScript API&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;WebRTC说起来很复杂，它涉及到很多技术。但建立连接、通信和传输数据的操作是通过一套JS API来实现的，还比较简单。其中主要的API包括：&lt;/p&gt;



&lt;p&gt;RTCPeerConnection：创建和导航端对端连接。&lt;/p&gt;



&lt;p&gt;RTCSessionDescription：描述连接（或潜在连接）的一端，以及它的配置方式。&lt;/p&gt;



&lt;p&gt;navigator.getUserMedia：捕捉音频和视频。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;为什么选择Node.js&lt;/strong&gt;&lt;strong&gt;？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;若要在两个或多个设备之间进行远程连接，你就需要一个服务器。在这种情况下，你也需要一个处理实时通信的服务器。Node.js是为实时可扩展的应用而构建的。要开发自由数据交换的双向连接应用程序，你可能会用到WebSockets，它允许在客户端和服务器之间建立一个会话窗口。来自客户端的请求会以循环的方式，更准确的说是事件循环进行处理，这时Node.js是我们很好的一个选择，因为它采取 “非阻塞（non-blocking） “的方式来解决请求。这样我们在这该过程中就能实现低延迟和高吞吐量。&lt;/p&gt;



&lt;p&gt;如果你对开发微服务感兴趣的话，一定要看看查看我们内含650多位微服务专家意见的&lt;a href=&quot;https://tsh.io/state-of-microservices/?utm_source=tsh.www&amp;amp;utm_medium=referral&amp;amp;utm_campaign=soms_report&amp;amp;utm_content=tshblogc2a&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot; title=&quot;https://tsh.io/state-of-microservices/?utm_source=tsh.www&amp;amp;utm_medium=referral&amp;amp;utm_campaign=soms_report&amp;amp;utm_content=tshblogc2a&quot;&gt;2020年微服务状态报告&lt;/a&gt;！&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;思路拓展：我们要创建的是什么？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;我们会创建一个非常简单的应用程序，它能让我们将音频和视频流传输到连接的设备——一个基础款视频聊天应用程序。我们会用到的技术有:&lt;/p&gt;



&lt;p&gt;Express库，提供静态文件，比如代表用户界面（UI）的HTML文件；&lt;/p&gt;



&lt;p&gt;socket.io库，在两个设备之间用WebSockets建立连接；&lt;/p&gt;



&lt;p&gt;WebRTC，允许媒体设备（摄像头和麦克风）在连接的设备之间传输音频和视频流。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;实现视频会话&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;我们要做的第一件事是给我们的应用程序提供一个作为UI的HTML文件。让我们通过运行：npm init.js来初始化新的node.js项目。然后，我们需要通过运行：npm i -D typescript ts-node nodemon @types/express @types/socket.io安装一些开发依赖项，运行：npm i express socket.io安装生产依赖项。&lt;/p&gt;



&lt;p&gt;之后我们就可以在package.json文件中定义脚本，来运行我们的项目了。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;{
 &quot;scripts&quot;: {
   &quot;start&quot;: &quot;ts-node src/index.ts&quot;,
   &quot;dev&quot;: &quot;nodemon --watch &#x27;src/**/*.ts&#x27; --exec &#x27;ts-node&#x27; src/index.ts&quot;
 },
 &quot;devDependencies&quot;: {
   &quot;@types/express&quot;: &quot;^4.17.2&quot;,
   &quot;@types/socket.io&quot;: &quot;^2.1.4&quot;,
   &quot;nodemon&quot;: &quot;^1.19.4&quot;,
   &quot;ts-node&quot;: &quot;^8.4.1&quot;,
   &quot;typescript&quot;: &quot;^3.7.2&quot;
 },
 &quot;dependencies&quot;: {
   &quot;express&quot;: &quot;^4.17.1&quot;,
   &quot;socket.io&quot;: &quot;^2.3.0&quot;
 }
}&lt;/pre&gt;



&lt;p&gt;当我们运行npm run dev命令时，nodemon会监控src文件夹中每个以.ts结尾的文件有无任何变化。现在，我们要创建一个src文件夹。在这个文件夹中，我们会创建两个typescript文件：index.ts和server.ts。&lt;/p&gt;



&lt;p&gt;在server.ts中，我们会创建server类，并使其与express和socket.io一起工作。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;import express, { Application } from &quot;express&quot;;
import socketIO, { Server as SocketIOServer } from &quot;socket.io&quot;;
import { createServer, Server as HTTPServer } from &quot;http&quot;;
 
export class Server {
 private httpServer: HTTPServer;
 private app: Application;
 private io: SocketIOServer;
 
 private readonly DEFAULT_PORT = 5000;
 
 constructor() {
   this.initialize();
 
   this.handleRoutes();
   this.handleSocketConnection();
 }
 
 private initialize(): void {
   this.app = express();
   this.httpServer = createServer(this.app);
   this.io = socketIO(this.httpServer);
 }
 
 private handleRoutes(): void {
   this.app.get(&quot;/&quot;, (req, res) =&amp;gt; {
     res.send(`&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;`); 
   });
 }
 
 private handleSocketConnection(): void {
   this.io.on(&quot;connection&quot;, socket =&amp;gt; {
     console.log(&quot;Socket connected.&quot;);
   });
 }
 
 public listen(callback: (port: number) =&amp;gt; void): void {
   this.httpServer.listen(this.DEFAULT_PORT, () =&amp;gt;
     callback(this.DEFAULT_PORT)
   );
 }
}&lt;/pre&gt;



&lt;p&gt;为正常运行服务器，我们需要在index.ts文件中创建一个新的Server类实例并调用listen方法。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;import { Server } from &quot;./server&quot;;
 
const server = new Server();
 
server.listen(port =&amp;gt; {
 console.log(`Server is listening on http://localhost:${port}`);
});&lt;/pre&gt;



&lt;p&gt;现在，如果我们运行：npm run dev会看到下面这样的情景：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-1_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;当打开浏览器，输入&lt;a href=&quot;http://localhost:5000/&quot;&gt;http://localhost:5000&lt;/a&gt;，我们应该注意到左上的 “Hello World “信息。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-2_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;然后我们就可以在public/index.html中创建一个新的HTML文件了。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
 &amp;lt;head&amp;gt;
   &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt;
   &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt;
   &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&amp;gt;
   &amp;lt;title&amp;gt;Dogeller&amp;lt;/title&amp;gt;
   &amp;lt;link
     href=&quot;https://fonts.googleapis.com/css?family=Montserrat:300,400,500,700&amp;amp;display=swap&quot;
     rel=&quot;stylesheet&quot;
   /&amp;gt;
   &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot; /&amp;gt;
   &amp;lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
 &amp;lt;/head&amp;gt;
 &amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;container&quot;&amp;gt;
     &amp;lt;header class=&quot;header&quot;&amp;gt;
       &amp;lt;div class=&quot;logo-container&quot;&amp;gt;
         &amp;lt;img src=&quot;./img/doge.png&quot; alt=&quot;doge logo&quot; class=&quot;logo-img&quot; /&amp;gt;
         &amp;lt;h1 class=&quot;logo-text&quot;&amp;gt;
           Doge&amp;lt;span class=&quot;logo-highlight&quot;&amp;gt;ller&amp;lt;/span&amp;gt;
         &amp;lt;/h1&amp;gt;
       &amp;lt;/div&amp;gt;
     &amp;lt;/header&amp;gt;
     &amp;lt;div class=&quot;content-container&quot;&amp;gt;
       &amp;lt;div class=&quot;active-users-panel&quot; id=&quot;active-user-container&quot;&amp;gt;
         &amp;lt;h3 class=&quot;panel-title&quot;&amp;gt;Active Users:&amp;lt;/h3&amp;gt;
      &amp;lt;/div&amp;gt;
       &amp;lt;div class=&quot;video-chat-container&quot;&amp;gt;
         &amp;lt;h2 class=&quot;talk-info&quot; id=&quot;talking-with-info&quot;&amp;gt; 
           Select active user on the left menu.
         &amp;lt;/h2&amp;gt;
         &amp;lt;div class=&quot;video-container&quot;&amp;gt;
           &amp;lt;video autoplay class=&quot;remote-video&quot; id=&quot;remote-video&quot;&amp;gt;&amp;lt;/video&amp;gt;
           &amp;lt;video autoplay muted class=&quot;local-video&quot; id=&quot;local-video&quot;&amp;gt;&amp;lt;/video&amp;gt;
         &amp;lt;/div&amp;gt;
       &amp;lt;/div&amp;gt;
     &amp;lt;/div&amp;gt;
   &amp;lt;/div&amp;gt;
   &amp;lt;script src=&quot;./scripts/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
 &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/pre&gt;



&lt;p&gt;在这个新文件中，我们创建了两个视频元素：一个用于远程视频连接，另一个用于本地视频。你可能已经注意到我们也在导入本地脚本了。现在我们就来创建一个新的文件夹“脚本”，并在这个目录下创建index.js文件。至于样式，你可以从&lt;a href=&quot;https://github.com/Miczeq22/simple-chat-app&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;GitHub库&lt;/a&gt;中下载它们。&lt;/p&gt;



&lt;p&gt;接下来你需要给浏览器提供index.html。首先，你需要告诉express你想提供哪些静态文件。为了实现这一点，我们决定在Server类中实现一个新方法。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;private configureApp(): void {
   this.app.use(express.static(path.join(__dirname, &quot;../public&quot;)));
 }&lt;/pre&gt;



&lt;p&gt;不要忘记在initialize中调用configureApp。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;private initialize(): void {
   this.app = express();
   this.httpServer = createServer(this.app);
   this.io = socketIO(this.httpServer);
 
   this.configureApp();
   this.handleSocketConnection();
 }&lt;/pre&gt;



&lt;p&gt;当你输入&lt;a href=&quot;http://localhost:5000&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;http://localhost:5000&lt;/a&gt;后，你应该能看到你的index.html文件在运行。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-3_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;下一步要实现的是允许摄像头和视频访问并将其流式传输到local-video元素。要做到这一点，你需要打开public/scripts/index.js文件，并用以下方法实现它。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;navigator.getUserMedia(
 { video: true, audio: true },
 stream =&amp;gt; {
   const localVideo = document.getElementById(&quot;local-video&quot;);
   if (localVideo) {
     localVideo.srcObject = stream;
   }
 },
 error =&amp;gt; {
   console.warn(error.message);
 }
);&lt;/pre&gt;



&lt;p&gt;当回到浏览器时，界面会出现一个提示请求访问你的媒体设备，在接受请求后，你电脑的摄像头就开始工作了。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-4_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;更多细节详见&lt;a href=&quot;https://tsh.io/blog/simple-guide-concurrency-node-js/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;A simple guide to concurrency in Node.js and a few traps that come with it&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;如何处理socket&lt;/strong&gt;&lt;strong&gt;连接？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;接下来我们讲讲如何处理socket连接。我们需要将客户端与服务器连接起来。为此，我们将使用socket.io。在public/scripts/index.js中，添加以下代码：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;this.io.on(&quot;connection&quot;, socket =&amp;gt; {
     const existingSocket = this.activeSockets.find(
       existingSocket =&amp;gt; existingSocket === socket.id
     );
 
     if (!existingSocket) {
       this.activeSockets.push(socket.id);
 
       socket.emit(&quot;update-user-list&quot;, {
         users: this.activeSockets.filter(
           existingSocket =&amp;gt; existingSocket !== socket.id
         )
       });
 
       socket.broadcast.emit(&quot;update-user-list&quot;, {
         users: [socket.id]
       });
     }
   }&lt;/pre&gt;



&lt;p&gt;页面刷新后，电脑会弹出一条消息，显示 “Socket已连接”&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-5_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;然后我们回到server.ts中，把已连接的socket存储在内存中，这只是为了保留唯一连接。所以，我们需要在Server类中添加一个新的私有字段，如下：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;private activeSockets: string[] = [];&lt;/pre&gt;



&lt;p&gt;然后我们需要在socket连接中检查socket是否已经存在。如果不存在，把新的socket推送到内存中，并向已连接的用户发送数据。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;this.io.on(&quot;connection&quot;, socket =&amp;gt; {
     const existingSocket = this.activeSockets.find(
       existingSocket =&amp;gt; existingSocket === socket.id
     );
 
     if (!existingSocket) {
       this.activeSockets.push(socket.id);
 
       socket.emit(&quot;update-user-list&quot;, {
         users: this.activeSockets.filter(
           existingSocket =&amp;gt; existingSocket !== socket.id
         )
       });
 
       socket.broadcast.emit(&quot;update-user-list&quot;, {
         users: [socket.id]
       });
     }
   }&lt;/pre&gt;



&lt;p&gt;你还需要在socket断开连接时及时响应，所以在socket连接中，你需要添加：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;disconnect&quot;, () =&amp;gt; {
   this.activeSockets = this.activeSockets.filter(
     existingSocket =&amp;gt; existingSocket !== socket.id
   );
   socket.broadcast.emit(&quot;remove-user&quot;, {
     socketId: socket.id
   });
 });&lt;/pre&gt;



&lt;p&gt;客户端(即public/scripts/index.js)这边，你需要妥善处理那些信息：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;update-user-list&quot;, ({ users }) =&amp;gt; {
 updateUserList(users);
});
 
socket.on(&quot;remove-user&quot;, ({ socketId }) =&amp;gt; {
 const elToRemove = document.getElementById(socketId);
 
 if (elToRemove) {
   elToRemove.remove();
 }
});&lt;/pre&gt;



&lt;p&gt;以下是 updateUserList 函数：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;function updateUserList(socketIds) {
 const activeUserContainer = document.getElementById(&quot;active-user-container&quot;);
 
 socketIds.forEach(socketId =&amp;gt; {
   const alreadyExistingUser = document.getElementById(socketId);
   if (!alreadyExistingUser) {
     const userContainerEl = createUserItemContainer(socketId);
     activeUserContainer.appendChild(userContainerEl);
   }
 });
}&lt;/pre&gt;



&lt;p&gt;以及createUserItemContainer函数:&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;function createUserItemContainer(socketId) {
 const userContainerEl = document.createElement(&quot;div&quot;);
 
 const usernameEl = document.createElement(&quot;p&quot;);
 
 userContainerEl.setAttribute(&quot;class&quot;, &quot;active-user&quot;);
 userContainerEl.setAttribute(&quot;id&quot;, socketId);
 usernameEl.setAttribute(&quot;class&quot;, &quot;username&quot;);
 usernameEl.innerHTML = `Socket: ${socketId}`;
 
 userContainerEl.appendChild(usernameEl);
 
 userContainerEl.addEventListener(&quot;click&quot;, () =&amp;gt; {
   unselectUsersFromList();
   userContainerEl.setAttribute(&quot;class&quot;, &quot;active-user active-user--selected&quot;);
   const talkingWithInfo = document.getElementById(&quot;talking-with-info&quot;);
   talkingWithInfo.innerHTML = `Talking with: &quot;Socket: ${socketId}&quot;`;
   callUser(socketId);
 }); 
 return userContainerEl;
}&lt;/pre&gt;



&lt;p&gt;需要注意的是，我们给用户容器元素添加了一个可以调用callUser函数的点击监听器——但现在，它可以是一个空的函数。接下来，当运行两个浏览器窗口（其中一个作为私人窗口）时，你应该注意到你的Web应用程序中有两个已经连接的socket。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-6_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;点击列表中的活跃用户，这时我们需要调用callUser函数。但是在实现之前，你还需要在window对象中声明两个类。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;const { RTCPeerConnection, RTCSessionDescription } = window;&lt;/pre&gt;



&lt;p&gt;我们会在callUser函数用到这两个类：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;async function callUser(socketId) {
 const offer = await peerConnection.createOffer();
 await peerConnection.setLocalDescription(new RTCSessionDescription(offer));
 
 socket.emit(&quot;call-user&quot;, {
   offer,
   to: socketId
 });
}&lt;/pre&gt;



&lt;p&gt;现在我们要创建一个本地请求并发送给选定的用户。服务器会监听一个叫做call-user的事件、拦截请求并将其转发给选定的用户。让我们用server.ts来实现该操作：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;call-user&quot;, data =&amp;gt; {
   socket.to(data.to).emit(&quot;call-made&quot;, {
     offer: data.offer,
     socket: socket.id
   });
 });&lt;/pre&gt;



&lt;p&gt;对于客户端，你需要就call-made事件作出调整：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;call-made&quot;, async data =&amp;gt; {
 await peerConnection.setRemoteDescription(
   new RTCSessionDescription(data.offer)
 );
 const answer = await peerConnection.createAnswer();
 await peerConnection.setLocalDescription(new RTCSessionDescription(answer));
 
 socket.emit(&quot;make-answer&quot;, {
   answer,
   to: data.socket
 });
});&lt;/pre&gt;



&lt;p&gt;之后，在你从服务器得到的请求上设置一个远程描述，并为这个请求创建一个答复。对于服务器端，你只需要将适当的数据传递给选定的用户即可。然后我们再在server.ts里面添加一个监听器。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;make-answer&quot;, data =&amp;gt; {
   socket.to(data.to).emit(&quot;answer-made&quot;, {
     socket: socket.id,
     answer: data.answer
   });
 });&lt;/pre&gt;



&lt;p&gt;对于客户端，我们需要处理 answer-made 事件。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;answer-made&quot;, async data =&amp;gt; {
 await peerConnection.setRemoteDescription(
   new RTCSessionDescription(data.answer)
 );
 
 if (!isAlreadyCalling) {
   callUser(data.socket);
   isAlreadyCalling = true;
 }
});&lt;/pre&gt;



&lt;p&gt;我们可以使用标志isAlreadyCalling，它能帮助确保我们只需调用一次用户。&lt;/p&gt;



&lt;p&gt;最后你需要做的是添加本地轨道，包括音频和视频到你的连接端。只有做到这一点，我们才能够与连接的用户共享视频和音频。要做到这一点，我们需要在navigator.getMediaDevice回调中调用peerConnection对象的addTrack函数。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;navigator.getUserMedia(
 { video: true, audio: true },
 stream =&amp;gt; {
   const localVideo = document.getElementById(&quot;local-video&quot;);
   if (localVideo) {
     localVideo.srcObject = stream;
   }
 
   stream.getTracks().forEach(track =&amp;gt; peerConnection.addTrack(track, stream));
 },
 error =&amp;gt; {
   console.warn(error.message);
 }
);&lt;/pre&gt;



&lt;p&gt;另外，我们还需要为ontrack事件添加一个适当的处理程序。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;peerConnection.ontrack = function({ streams: [stream] }) {
 const remoteVideo = document.getElementById(&quot;remote-video&quot;);
 if (remoteVideo) {
   remoteVideo.srcObject = stream;
 }
};&lt;/pre&gt;



&lt;p&gt;如图示，我们已经从传递的对象中获取了流，并改变了远程视频中的srcObject来使用接收到的流。所以现在当你点击活跃用户后，你应该建立一个视频和音频连接，像下图这样：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-7_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;欲了解细节，请参阅：&lt;a href=&quot;https://tsh.io/blog/dependency-injection-in-node-js/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Node.js and dependency injection – friends or foes?&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;现在你知道如何编写一个视频聊天应用了吧！&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;WebRTC是一个很大的话题，内容非常庞杂。如果你想了解它的运作原理，就需要花很大功夫。幸运的是，我们可以访问易于使用的JavaScript API，它可以帮助我们创建很简洁的应用程序，例如视频共享、聊天应用程序等等。&lt;/p&gt;



&lt;p&gt;如果你想深入了解WebRTC，点击此&lt;a href=&quot;http://Node.js%20and%20dependency%20injection%20–%20friends%20or%20foes%3F&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;WebRTC官方文档的链接&lt;/a&gt;。另外，我也推荐你阅读&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;MDN的文档说明&lt;/a&gt;，它能帮助你更加了解此技术。&lt;/p&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;文章地址：&lt;a href=&quot;https://tsh.io/blog/how-to-write-video-chat-app-using-webrtc-and-nodejs/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;https://tsh.io/blog/how-to-write-video-chat-app-using-webrtc-and-nodejs/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;原文作者：Mikołaj Wargowski&lt;/p&gt;&lt;/blockquote&gt;



&lt;p/&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bd9782dd26b3b5c105866e1cdcaf410f</guid>
<title>Apache Kylin 的实践与优化</title>
<link>https://toutiao.io/k/anqfsl4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;销售业务的特点是规模大、领域多、需求密。美团到店餐饮擎天销售系统（&lt;/span&gt;&lt;span&gt;以下简称“擎天”&lt;/span&gt;&lt;span&gt;）作为销售数据支持的主要载体，不仅涉及的范围较广，而且面临的技术场景也非常复杂（&lt;/span&gt;&lt;span&gt;多组织层级数据展示及鉴权、超过1/3的指标需要精准去重，峰值查询已经达到数万级别&lt;/span&gt;&lt;span&gt;）。在这样的业务背景下，建设稳定高效的OLAP引擎，协助分析人员快速决策，已经成为到餐擎天的核心目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://kylin.apache.org/cn/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Apache Kylin&lt;/span&gt;&lt;/a&gt;&lt;span&gt;是一个基于Hadoop大数据平台打造的开源OLAP引擎，它采用了多维立方体预计算技术，利用空间换时间的方法，将查询速度提升至亚秒级别，极大地提高了数据分析的效率，并带来了便捷、灵活的查询功能。基于技术与业务匹配度，擎天于2016年采用Kylin作为OLAP引擎，接下来的几年里，这套系统高效地支撑了我们的数据分析体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020年，美团到餐业务发展较快，数据指标也迅速增加。基于Kylin的这套系统，在构建和查询上均出现了严重的效率问题，从而影响到数据的分析决策，并给用户体验优化带来了很大的阻碍。技术团队经过半年左右的时间，对Kylin进行一系列的优化迭代，包括维度裁剪、模型设计以及资源适配等等等，帮助销售业绩数据SLA从90%提升至99.99%。基于这次实战，我们沉淀了一套涵盖了“原理解读”、“过程拆解”、“实施路线”的技术方案。希望这些经验与总结，能够帮助业界更多的技术团队提高数据产出与业务决策的效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题与目标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;销售作为衔接平台和商家的桥梁，包含销售到店和电话拜访两种业务模式，以战区、人力组织架构逐级管理，所有分析均需要按2套组织层级查看。在指标口径一致、数据产出及时等要求下，我们结合Kylin的预计算思想，进行了数据的架构设计。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;560&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;310&quot; data-ratio=&quot;0.5604395604395604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajnGbt0AEtI4BUI0uo5z0MPJN6xOtONQiahiaLQQZmXfSejyYM0t3kicaOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1638&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;而Kylin计算维度组合的公式是2^N（&lt;/span&gt;&lt;span&gt;N为维度个数&lt;/span&gt;&lt;span&gt;），官方提供维度剪枝的方式，减少维度组合个数。但由于到餐业务的特殊性，单任务不可裁剪的组合个数仍高达1000+。在需求迭代以及人力、战区组织变动的场景下，需要回溯全部历史数据，会耗费大量的资源以及超高的构建时长。而基于业务划分的架构设计，虽能够极大地保证数据产出的解耦，保证指标口径的一致性，但是对Kylin构建产生了很大的压力，进而导致资源占用大、耗时长。基于以上业务现状，我们归纳了Kylin的MOLAP模式下存在的问题，具体如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;效率问题命中难（实现原理）&lt;/strong&gt;：构建过程步骤多，各步骤之间强关联，仅从问题的表象很难发现问题的根本原因，无法行之有效地解决问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;构建引擎未迭代（构建过程）&lt;/strong&gt;：历史任务仍采用MapReduce作为构建引擎，没有切换到构建效率更高的Spark。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;资源利用不合理（构建过程）&lt;/strong&gt;：资源浪费、资源等待，默认平台动态资源适配方式，导致小任务申请了大量资源，数据切分不合理，产生了大量的小文件，从而造成资源浪费、大量任务等待。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;核心任务耗时长（实施路线）&lt;/strong&gt;：擎天销售交易业绩数据指标的源表数据量大、维度组合多、膨胀率高，导致每天构建的时长超过2个小时。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;SLA质量不达标（实施路线）&lt;/strong&gt;：SLA的整体达成率未能达到预期目标。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在认真分析完问题，并确定提效的大目标后，我们对Kylin的构建过程进行了分类，拆解出在构建过程中能提升效率的核心环节，通过“原理解读”、“层层拆解”、“由点及面”的手段，达成双向降低的目标。具体量化目标如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5688622754491018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajejUzZWWLib7rYRw3MAAwibn1kyYRibElr6kYPFssuMibFGicIKeVheFygjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;835&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优化前提-原理解读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决效率提升定位难、归因难的问题，我们解读了Kylin构建原理，包含了预计算思想以及By-layer逐层算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;预计算&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据维度组合出所有可能的维度，对多维分析可能用到的指标进行预计算，将计算好的结果保存成Cube。假设我们有4个维度，这个Cube中每个节点（&lt;/span&gt;&lt;span&gt;称作Cuboid&lt;/span&gt;&lt;span&gt;）都是这4个维度的不同组合，每个组合定义了一组分析的维度（&lt;/span&gt;&lt;span&gt;如group by&lt;/span&gt;&lt;span&gt;），指标的聚合结果就保存在每个Cuboid上。查询时，我们根据SQL找到对应的Cuboid，读取指标的值，即可返回。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.896875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajGOqBgGODE6bqB1skc3NlAfDIhcLy7MmibCWtxWFUq6of8Auoia8E1QRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;By-layer逐层算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个N维的Cube，是由1个N维子立方体、N个（N-1）维子立方体、N*(N-1)/2个(N-2)维子立方体、……N个1维子立方体和1个0维子立方体构成，总共有 2^N个子立方体。在逐层算法中，按照维度数逐层减少来计算，每个层级的计算（除了第一层，由原始数据聚合而来），是基于上一层级的计算结果来计算的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如：group by [A,B]的结果，可以基于group by [A,B,C]的结果，通过去掉C后聚合得来的，这样可以减少重复计算，当0维Cuboid计算出来的时候，整个Cube的计算也就完成了。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.39752650176678445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajoibrlicAr12Eibick9rn7oxTNy9r8uNbyGeibv0A5S33Wrib3S45jyicd3bCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;过程分析-层层拆解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在了解完Kylin的底层原理后，我们将优化的方向锁定在“引擎选择”、“数据读取”、“构建字典”、“分层构建”、“文件转换”五个环节，再细化各阶段的问题、思路及目标后，我们终于做到了在降低计算资源的同时降低了耗时。详情如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5307291666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajEHClNJuAYp70NuLxbZiaPhk54iazOxu4KvZoZQfAjEfmZP3iaLIGyCnqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;构建引擎选择&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前，我们已经将构建引擎已逐步切换为&lt;/span&gt;&lt;a href=&quot;http://spark.apache.org/docs/2.2.1/configuration.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Spark&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。擎天早在2016年就使用Kylin作为OLAP引擎，历史任务没有切换，仅仅针对MapReduce做了参数优化。其实在2017年，Kylin官网已启用Spark作为构建引擎（&lt;/span&gt;&lt;a href=&quot;http://kylin.apache.org/cn_blog/2017/02/25/v2.0.0-beta-ready/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;官网启用Spark构建引擎&lt;/span&gt;&lt;/a&gt;&lt;span&gt;），构建效率相较MapReduce提升1至3倍，还可通过Cube设计选择切换，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.18429661941112324&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajcU4mT6oKwkA84WaOaNaRmw2ZV5gwq1W3K8tWErMgZBHhY1slPfSyEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1834&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;读取源数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kylin以外部表的方式读取Hive中的源数据，表中的数据文件（&lt;/span&gt;&lt;span&gt;存储在HDFS&lt;/span&gt;&lt;span&gt;）作为下一个子任务的输入，此过程可能存在小文件问题。当前，Kylin上游数据宽表文件数分布比较合理，无需在上游设置合并，如果强行合并反而会增加上游源表数据加工时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于项目需求，要回刷历史数据或增加维度组合，需要重新构建全部的数据，通常采用按月构建的方式回刷历史，加载的分区过多出现小文件问题，导致此过程执行缓慢。在Kylin级别重写配置文件，对小文件进行合并，减少Map数量，可有效地提升读取效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;合并源表小文件&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：合并Hive源表中小文件个数，控制每个Job并行的Task个数。调整参数如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.12760416666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajV5xiahnHzYia2uibHfco1biaTjiaCWd4GPjINDo1sMd5aRjYARZ9SjDgJDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Kylin级别参数重写&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：设置Map读取过程的文件大小。调整参数如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.08177083333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajOiasC4k0W1Yekriagiaia30Vo7dYXplCkPr0nsfPN4W8nApqHib4tKgiccRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;构建字典&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kylin通过计算Hive表出现的维度值，创建维度字典，将维度值映射成编码，并保存保存统计信息，节约HBase存储资源。每一种维度组合，称为一个Cuboid。理论上来说，一个N维的Cube，便有2^N种维度组合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;组合数量查看&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在对维度组合剪枝后，实际计算维度组合难以计算，可通过执行日志（&lt;/span&gt;&lt;span&gt;截图为提取事实表唯一列的步骤中，最后一个Reduce的日志&lt;/span&gt;&lt;span&gt;），查看具体的维度组合数量。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajZLnRSpmYicpH2nA6eLJDGjQ5s8zpuialhVjelAEql2q38DdA93qSVCug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;全局字典依赖&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;擎天有很多业务场景需要精确去重，当存在多个全局字典列时，可设置列依赖，例如：当同时存在“门店数量”、“在线门店数量”数据指标，可设置列依赖，减少对超高基维度的计算。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3269088213491475&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajXsC8WgUr32uE98MVeuhmvme9fsM1t1G3few2vh4D0o3y2H0Oc7R9icw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1349&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;计算资源配置&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当指标中存在多个精准去重指标时，可适当增加计算资源，提升对高基维度构建的效率。参数设置如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.12447916666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajA697gZlCla7xD73Bhkic3gL03BeicY7IwTauOSuLw58HF5xTWmdLqpzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分层构建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此过程为Kylin构建的核心，切换Spark引擎后，默认只采用By-layer逐层算法，不再自动选择（&lt;/span&gt;&lt;span&gt;By-layer逐层算法、快速算法&lt;/span&gt;&lt;span&gt;）。Spark在实现By-layer逐层算法的过程中，从最底层的Cuboid一层一层地向上计算，直到计算出最顶层的Cuboid（&lt;/span&gt;&lt;span&gt;相当于执行了一个不带group by的查询&lt;/span&gt;&lt;span&gt;），将各层的结果数据缓存到内存中，跳过每次数据的读取过程，直接依赖上层的缓存数据，大大提高了执行效率。Spark执行过程具体内容如下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Job阶段&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Job个数为By-layer算法树的层数，Spark将每层结果数据的输出，作为一个Job。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5479166666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajcy1NQRUnNCiceSQ67Ad2xAiclDicrJBZzzmKASNgibyriamg8SpxJNcibSMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Stage阶段&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个Job对应两个Stage阶段，分为读取上层缓存数据和缓存该层计算后的结果数据。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.45625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajpZuseQmXoZb3m5fSML1IQHx5RoFbNHs5ricYfiadutsaA4UG2KvjlnXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Task并行度设置&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kylin根据预估每层构建Cuboid组合数据的大小（&lt;/span&gt;&lt;span&gt;可通过维度剪枝的方式，减少维度组合的数量，降低Cuboid组合数据的大小，提升构建效率，本文暂不详细介绍&lt;/span&gt;&lt;span&gt;）和分割数据的参数值计算出任务并行度。计算公式如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;资源申请计算&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;平台默认采用动态方式申请计算资源，单个Executor的计算能力包含：1个逻辑CPU（&lt;/span&gt;&lt;span&gt;以下简称CPU&lt;/span&gt;&lt;span&gt;）、6GB堆内内存、1GB的堆外内存。计算公式如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  =  kylin.engine.spark-conf.spark.executor.cores * 实际申请的Executors个数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;内存&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; =（kylin.engine.spark-conf.spark.executor.memory + spark.yarn.executor.memoryOverhead）* 实际申请的Executors个数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;单个Executor的执行能力&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; = kylin.engine.spark-conf.spark.executor.memory / kylin.engine.spark-conf.spark.executor.cores，即：1个CPU执行过程中申请的内存大小。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最大Executors个数&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; = kylin.engine.spark-conf.spark.dynamicAllocation.maxExecutors，平台默认动态申请，该参数限制最大申请个数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在资源充足的情况下，若单个Stage阶段申请1000个并行任务，则需要申请资源达到7000GB内存和1000个CPU，即：&lt;/span&gt;&lt;code&gt;&lt;span&gt;CPU：1*1000=1000；内存：（6+1）*1000=7000GB&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;资源合理化适配&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于By-layer逐层算法的特性，以及Spark在实际执行过程中的压缩机制，实际执行的Task任务加载的分区数据远远小于参数设置值，从而导致任务超高并行，占用大量资源，同时产生大量的小文件，影响下游文件转换过程。因此，合理的切分数据成为优化的关键点。通过Kylin构建日志，可查看各层级的Cuboid组合数据的预估大小，以及切分的分区个数（&lt;/span&gt;&lt;span&gt;等于Stage阶段实际生成的Task个数&lt;/span&gt;&lt;span&gt;）。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.12552083333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajjsicEicGyEribIEJfibcqeVbDblynZTe3jxN80MQxiaVQsPKO6BKcDjLuUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;结合Spark UI可查看实执行情况，调整内存的申请，满足执行所需要的资源即可，减少资源浪费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 整体资源申请最小值大于Stage阶段Top1、Top2层级的缓存数据之和，保证缓存数据全部在内存。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.1546875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajJb4WVTIAbwqy3WCOF5PFuSaSTm501Gyf0ibvR709bW1UBFbKvMuSa5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;计算公式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Stage阶段Top1、Top2层级的缓存数据之和 &amp;lt; kylin.engine.spark-conf.spark.executor.memory * kylin.engine.spark-conf.spark.memory.fraction *   spark.memory.storageFraction *最大Executors个数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 单个Task实际所需要的内存和CPU（&lt;/span&gt;&lt;span&gt;1个Task执行使用1个CPU&lt;/span&gt;&lt;span&gt;）小于单个Executor的执行能力。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.35833333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajgDrbts2cRpNecf9YsAjdSQMmicC7DxvZ7v1P4kebPF7QMb9YtcNOerw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;计算公式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：单个Task实际所需要的内存 &amp;lt; kylin.engine.spark-conf.spark.executor.memory * kylin.engine.spark-conf.spark.memory.fraction *   spark.memory.st·orageFraction / kylin.engine.spark-conf.spark.executor.cores。参数说明如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajOZ0CL4GysqS4UqibPUYV3C8GLXlrkvPOVZANGEiagiawFCZHdkDTibwDrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;文件转换&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kylin将构建之后的Cuboid文件转换成HTable格式的Hfile文件，通过BulkLoad的方式将文件和HTable进行关联，大大降低了HBase的负载。此过程通过一个MapReduce任务完成，Map个数为分层构建阶段输出文件个数。日志如下：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.22014925373134328&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiaj39xxanbmBwnlHiabrfU9Goowbics6Tsd23tUib1bTayHXHakBG5lsx71A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1608&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;此阶段可根据实际输入的数据文件大小（&lt;/span&gt;&lt;span&gt;可通过MapReduce日志查看&lt;/span&gt;&lt;span&gt;），合理申请计算资源，避免资源浪费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;计算公式：Map阶段资源申请 = kylin.job.mr.config.override.mapreduce.map.memory.mb * 分层构建阶段输出文件个数。具体参数如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiaj4NkvcbcFXvuF4s5SQAtnhiajvz3n5YDdTuIpuozOnn2Bia5Wspa9djgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;实施路线-由点及面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;交易试点实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们通过对Kylin原理的解读以及构建过程的层层拆解，选取销售交易核心任务进行试点实践。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5789902280130294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajsr4O1RU0Yqv70dYzmL26TJBVaMmyAzoiceNGSFfG0SicYoGldu7SP1sQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1228&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;实践结果对比&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对销售交易核心任务进行实践优化，对比调整前后资源实际使用情况和执行时长，最终达到双向降低的目标。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5129725722757599&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajC9Ib8BvicOjlQA2pRCzd2NJDCJH1CMoG0mneBwYIgTbiatYNAQpJB9icQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1349&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;成果展示&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;资源整体情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;擎天现有20+的Kylin任务，经过半年时间持续优化迭代，对比Kylin资源队列月均CU使用量和Pending任务CU使用量，在同等任务下资源消耗已明显降低。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.545933734939759&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajRjYiatvGcom2mL59pTcICmfYs7w6lPARWCwCPcFujoa8sQSNaicOGk3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1328&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;SLA整体达成率&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过了由点及面的整体优化，擎天于2020年6月SLA达成率达到100%。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6075268817204301&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajgibaMbNlprgdrtQAGy0yibCMGWT0rxGlszPub1mrMYicYfkU6jvVL1yiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;930&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;展望&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Apache Kylin在2015年11月正式成为Apache基金会的顶级项目。从开源到成为Apache顶级项目，只花了13个月的时间，而且它也是第一个由中国团队完整贡献到Apache的顶级项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前，美团采用比较稳定的V2.0版本，经过近4年的使用与积累，&lt;span&gt;到店餐饮技术团队&lt;/span&gt;在优化查询性能以及构建效率层面都积累了大量经验，本文主要阐述了在Spark构建过程的资源适配方法。值得一提的是，Kylin官方在2020年7月发布了V3.1版本，引入了Flink作为构建引擎，统一使用Flink构建核心过程，包含数据读取阶段、构建字典阶段、分层构建阶段、文件转换阶段，以上四部分占整体构建耗时的95%以上。此次版本的升级也大幅度提高了Kylin的构建效率。详情可查看：&lt;/span&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/KYLIN-3758&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Flink Cube Build Engine&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回顾Kylin构建引擎的升级过程，从MapReduce到&lt;/span&gt;&lt;a href=&quot;http://spark.apache.org/docs/2.2.1/configuration.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Spark&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，再到如今的Flink，构建工具的迭代始终向更加优秀的主流引擎在靠拢，而且Kylin社区有很多活跃的优秀代码贡献者，他们也在帮助扩大Kylin的生态，增加更多的新功能，非常值得大家学习。最后，美团到店餐饮技术团队再次表达对Apache Kylin项目团队的感谢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;岳庆，2019年加入美团，到店餐饮研发中心工程师。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d13eb8383f4251824bbc04c3ec69766e</guid>
<title>优秀！一鼓作气学会 “一致性哈希”，就靠这 18 张图了</title>
<link>https://toutiao.io/k/4jzvanq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，好久不见啦。最近快年底了，公司、部门事情太多：冲刺 KPI、做部门预算……所以忙东忙西的，写文章就被耽搁了。再加上这篇文章比较硬，我想给大家讲得通俗易懂，着实花了很多时间琢磨怎么写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话不多说，小故事开始。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当架构师大刘看到实习生小李提交的&lt;strong&gt;记账流水乱序&lt;/strong&gt;的问题的时候，他知道没错了：这一次，大刘又要用一致性哈希这个老伙计来解决这个问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嗯，一致性哈希，分布式架构师必备良药，让我们一起来尝尝它。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 满眼都是自己二十年前的样子，让我们从哈希开始&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 N 年前，互联网的分布式架构方兴未艾。大刘所在的公司由于业务需要，引入了一套由 IBM 团队设计的业务架构。&lt;img data-ratio=&quot;0.3036551077788191&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92D7sIlpicJLic12SYwcaNu4Uic5QYTXGYyWJUjjzxhO2HSHtHfmPLYToa0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2134&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这套架构采用了分布式的思想，通过 RabbitMQ 的消息中间件来通信。这套架构，在当时的年代里，算是思想超前，技术少见的黑科技架构了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，由于当年分布式技术落地并不广泛，有很多尚不成熟的地方。所以，这套架构在经年日久的使用中，一些问题逐渐突出。其中，最典型的问题有两个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RabbitMQ 是个单点，它一坏掉，整个系统就会全部瘫痪。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;收、发消息的业务系统也是单点。任何一点出现问题，对应队列的消息要么无从消费，要么海量消息堆积。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论哪种问题，最终是整套分布式系统都无法使用，后续处理非常麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 RabbitMQ 的单点问题，由于当时 RabbitMQ 的集群功能非常弱，普通模式有 queue 本身的单点问题，所以，最终使用了 Keepalived 配合了两台无关系的 RabbitMQ 搞出了高可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对于业务系统单点问题，从一开始着手解决的时候就出现了波折。一般来说，我们要解决单点问题，方法就是堆机器，堆应用。收发是单点，我们直接多部署几个应用就可以了。如果仅仅从技术上看，无非就是多个收发消息的应用大家一起竞争往 MQ 中放消息拿消息而已。&lt;img data-ratio=&quot;0.4117117117117117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92D8BSZJAUgQic7XeJPFMNMhq00ApJ1kaheS5y9YwA8zb3dleHrH6wEVnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2220&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，恰恰就是在把收发消息的应用集群化后，系统出现了问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本身这套系统架构会被应用到公司的多类业务上，有些业务对消息的顺序有着苛刻的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，公司内部的 IM 应用，不管是点对点的聊天还是群聊消息，都需要对话消息严格有序。而当我们把生产消息和消费消息的应用集群化后，问题出现了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;聊天记录出现了乱序&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A 和 B 对话，会出现某些消息没有严格按照 A 发出的先后顺序被 B 接收，于是整个聊天顺序乱成了一锅粥。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过排查，发现问题的根源就在于应用集群上。由于没有对应用集群收发消息做特殊的处理，当 A 发出一条聊天信息给B时，发送到 RabbitMQ 中的信息会被在 B 处的消费端所争抢。如果 A 在短时间内发出了几条信息，那么就可能会被集群中的不同应用抢走。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，乱序的问题就出现了。虽然应用业务逻辑是相同的，但是这些集群中的应用依然可能在处理信息速度上出现差异，最终导致用户看到的聊天信息错乱。&lt;img data-ratio=&quot;0.23345817727840198&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DUcPyQibryFGWpl6P1KxYNdaTZrMV42P4BlNkbJtrlVD2F2JicJxFGib4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1602&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题找到了，解决办法是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们说过了，消息顺序错乱是因为集群中不同应用抢消息然后处理速度不一样导致的。如果我们能保证 A 和 B 会话，从开始之后到会话结束之前，永远只会被 B 所在的消费消息集群应用中的同一个应用消费，那么我们就能保证消息有序。这样一来，我们就可以在消费消息的那个应用中，对抢到的消息进行排队，然后依次处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这种保证怎么实现呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们在 RabbitMQ 中会建立有相同前缀的队列，后面跟着队列编号。然后，集群中的不同应用会分别监听这两个有着不同编号的队列。当在 A 发送信息时，我们会对信息做一次简单的哈希:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;m = hash(id) mod n&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，id 是用户的标识。n 是集群中 B 所在业务系统部署的数量。最终的 m 是我们需要发送到的目的队列编号。&lt;img data-ratio=&quot;0.22372528616024975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DzqFWE2y63npKberQ7A28iaw8Clicia6DvxRFEZqr86HbOAIU4ia9WIEwMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1922&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设，hash(id) 的结果为 2000，n 为 2，经过计算 m = 0。此时，A 就会把他和 B 的对话信息都发送到 chat00 的队列里。B 收到消息后，就会依次显示给终端用户。这样，聊天乱序的问题就解决了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，事情到此就结束了吗？这个解决方案是完美的吗？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 看来，我们需要增加应用数量了&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着公司的发展，公司的人数也急剧上升，公司内部的 IM 使用人数也跟着多了起来，新问题又随之出现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最主要的问题是，人们收到聊天信息的速度变慢了。原因也很简单，收取聊天信息的集群机器不够用了。解决办法可以简单直接点，再加台机器就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，由于收消息的集群中新加入了一台机器，这时候，我们还需要额外多做一些事情：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我们需要为新加入的这台机器上的应用额外再多增加一个队列 chat02。&lt;img data-ratio=&quot;0.566350710900474&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DEry4OmAH7pSz8NhpbH48ACxlePK89S6YARQxicSqOs7pYteuj7IcCmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;422&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我们还需要修改下我们的分配消息的规则，把原来的 hash(id) mod 2 修改为 hash(id) mod 3。&lt;img data-ratio=&quot;0.7585365853658537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DZ0CbFRiajCtpDGphjtyFXdMjXscA6rFrd6BNB2QjLngzKm7ppZs4TYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;410&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;重新启动发送消息的项目，以便修改的规则生效。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;把收消息的应用部署到新机器上。&lt;img data-ratio=&quot;1.0997229916897506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DJSJ2QSl17x2icLrUJicdiaKYjO3LjlOwrB9oUu8Hc57hMvUgQzeviaP04A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;722&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这时，一切还都在可控范围。开发人员只需要在需要的时候，新增加个队列，然后把我们的分配规则小小的修改下即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，他们不知道的是，暴风雨就要来了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 新的问题来了，也许这就是人生吧&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于公司内部很多人在使用这个 IM 工具。有些时候，为了方便，公司的客户还有一些合作方也用起了这个 IM。这让事情变得复杂了起来。起初，开发人员还是像往常一样，每当人们抱怨说收消息过慢的时候，他们就会加一台机器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最糟糕的是，公司的客户也会抱怨，他们发现 IM 有时候彻底不可用。这可不是小事情。公司内部人员的问题还可以内部沟通解决。但是公司客户的问题，大意不得，因为这关系到公司产品的名誉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这到底是怎么一回事呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原来，根本原因还在于每次修改完配置规则后的重启服务。每次修改完配置规则，就需要规划好一个恰当的停机时间，去重新对项目做个上线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，这种方法在公司的客户也使用这个 IM 后就行不通了。因为公司的客户有不少是在国外的。也就是说，不管白天还是深夜，很可能总是有人在使用这个 IM。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就迫使开发人员们，在增加机器时，还需要去和多方协调沟通出一个上线时间，然后发布公告，再去上线。这种反复沟通，再上线，再反复沟通，再上线直接把开发人员们折腾了个半死。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;往往沟通完，上线时间直接被放到了半个月以后。而在这半个月里，开发人员还要承受无数内部 IM 使用人的口水。费心竭力的沟通，声嘶力竭的解释，缺眠少觉的上线，这一切的一切推动着开发人员们必须对眼前这套技术方案作出改变了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 思路转起来，队列环起来&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新的技术方案的需求本质就是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是分配消息规则变化还是集群机器添加都不能停机停服务&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这种情况，一个很好的解决方案就是如果我们对项目配置文件进行动态的定时检测，当发现变动时，刷新配置规则即可。&lt;img data-ratio=&quot;0.2762691853600944&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DiaAIZpUuTEA848bt4hcxfK9qU1l7Y3kGw7ME48qKTHQdJzQJT1R295Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;847&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一切看上去很美好，采用了动态的定时检测后，每当我们需要新增集群中的机器时，我们只需要如下三个步骤了:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;增加一个队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改分配消息的规则&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部署新的机器&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户毫无感知，开发人员们也不需要和用户们协调沟通出专门的上线安排。可是，这个方案也存在一些问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;随着我们的系统部署越来越多，我们需要手工修改规则的系统也越来越多。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果消费机器宕机了，我们需要删除队列，同时还需要去删除修改分配消息的规则，等到机器恢复了，我们还要再把分配消息的规则改回去。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个分配消息的规则真讨厌啊，每次有变动，就要去关心这个分配消息的规则。有没有什么办法能把这个分配变得更自动化一些呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们假设在 MQ 中有 100 个收发聊天信息的队列（100：这是对我们的IM不可能达到的一个数字），我们只需要在配置规则中配置成：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;m = hash(id) mod 100&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，我们的发送消息的应用启动后，去动态的探测出真实的所有收发聊天信息的队列信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们通过哈希算出的编号发现没有真实对应的队列存在时，就根据一定的规则，去找到一个真实存在的队列，这个队列，就是我们要发消息的队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们做到这样，那么以后，每次队列有变化，无论增多还是减少，我们都不需要再去考虑分配规则的事情了，只需要移除有问题的队列或者增加有对应消费者的队列即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个思想，就是一致性哈希的思想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体怎么做呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，我们假设有个 100 个收发聊天信息的队列，并且这些队列处于一个环上。&lt;img data-ratio=&quot;0.7205882352941176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92Dlfpf0P0V9ZfxpMwTH9k4DywCOBnJrSaeg9hbbAaXkia0Nm4QXQA0Npw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;340&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，我们获取到真实的收发聊天信息的队列数量，假设有 5 个。&lt;img data-ratio=&quot;0.24251497005988024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92D9P8t8ThlzcBaPb4jTfcNoohXEgyafZPHyHgYHh35Ww8wDoRYEsjw7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步，我们把真实的队列映射到我们第一步假设的环中。&lt;img data-ratio=&quot;0.9688581314878892&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DLduZpibxZ77xC7Hiabwrp4iaqttLkrmm7gHZelAHUZgvxTGib2feB7cmmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;289&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第四步，我们通过分配规则 hash(id) mod 100 计算出对应的队列编号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 hash(id) 的结果为 2000，那么算出的队列编号 m = 0。这时候，我们一查，发现对应编号 0 的 chat00 队列确实存在，那么就直接发送消息到 chat00 中。&lt;img data-ratio=&quot;0.8716417910447761&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DSiaHsmkh07XiaiakcsgX9L0dMvMkaWNUxktwEakzibbeFZe0dsibrb95dVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;335&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们的 hash(id) 的结果为 1999，那么算出的队列编号 m = 99。此时，我们去查队列映射关系，发现 99 编号并没有对应的真实队列。这时候怎么办？很简单，我们顺时针继续往下找，找到谁了呢？0 对应的 chat00 队列，这是真实存在的，这时候，我们就将消息发送到 chat00 队列中。&lt;img data-ratio=&quot;0.6904231625835189&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DunpSomDkibNWpw6PggrPwu5jytxvhcPhUBRmuQ5UCXTianG6BORmGHjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;449&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面四步就是一个基本的一致性哈希算法了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这套一致性哈希算法满足我们不想总是更新消息分配规则的需求吗？让我们验证一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;假设我们需要在消费信息端集群增加一台机器&lt;/strong&gt;&lt;br/&gt;我们如果要增加一台机器，那么同时我们也需要在 MQ 中增加一个队列。这时候，我们的分配规则是 hash(id) mod 100，增加了队列后，真实的队列数假设为 6。此时，如果 hash(id) mod 100 的结果小于 6，那么分配的规则和没有增加机器的时候规则一样，以前分配到哪个队列，现在还是分配到哪个队列。但是对于结果等于 6 的情况，则发生了变化。信息会被自动分配给 chat05。当分配给 chat05 后，新的消费者就会自动开始进入正常工作了，我们不需要做任何人工干预，也不需要考虑分配规则的变化。&lt;/p&gt;&lt;p&gt;增加机器以前：&lt;img data-ratio=&quot;0.6887550200803213&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DTLJNwKCJJI6ogxMOtzgaRLbIIZZibavibjvRugbke1sDVkNIYcKBzsSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;498&quot;/&gt;&lt;/p&gt;&lt;p&gt;增加机器之后：&lt;img data-ratio=&quot;0.6405228758169934&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92Dw3XrRZMMP6NTyklkcxVeIkg1jyufUxnuJGwfTlolvdG6RMb1bDK2Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;459&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;假设消费信息端集群一台机器宕机了&lt;/strong&gt;&lt;br/&gt;模拟宕机，此时我们会去减少一个队列。减少后的真实队列数量为 5，则正好和增加队列相反，m = 5 时，那么行为不会有任何变化，以前分到哪个队列，还是分到哪个队列。如果 m = 6，由于已经不存在真实的队列了，就会做顺时针查找，结果找到 chat00，以前会分到 chat05 的就会被分到 chat00。而此时，chat00 由于正好有消费者，所以，系统的用户是毫无感知的，我们也专心修复我们机器即可。当机器恢复后，就会和新增机器一样，计算结果为 6 的信息会被重新分配回 chat05。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，我们可以看到，当我们引入一致性哈希后，我们不管新增机器还是集群机器宕机，我只需要跟随着机器的状态，做一个操作即可：增加或者减少 MQ 中的队列。一切简单化了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这个方案是否依然还有问题呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 失衡的圆环，压垮骆驼的可能只是一根稻草&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们目前有 5 个队列存在，我们的分配规则是 m = hash(id) mod 100。那么，此时，问题就出来了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 m 的值大于 5，由于没有对应的真实队列存在，系统就会顺时针顺着我们构造出来的哈希环找，最终会找到 chat00 这个队列上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，你会发现，只要是 m 值大于 5 的 id 对应用户发的信息，最终都会落入到 chat00 队列中。&lt;img data-ratio=&quot;0.8550420168067226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92Df5w0glkojPLey3Estb9T3t1LtibqzC5CCc3BNkjowFn5o8icSYTjxhAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;952&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在极端情况下，如果大量的信息涌入到 chat00 队列里，由于对应 chat00 的消费者处理不过来，很可能会导致这个消费者的崩溃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，去除队列后，根据规则，又会有大量的信息涌入到 chat00 后续的队列 chat01 里，这些信息又会导致 chat01 对应应用的崩溃，最终引发整个集群的崩溃，这就是雪崩效应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要一种更巧妙的办法来解决这个问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 从实变虚，也许我们应该更敢想一些&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上面的论述，我们发现，我们在分配队列时，之所以失衡，是因为我们的队列在圆环上的分配失衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们所有的真实队列都是按照顺时针依次排布在圆环上的。在上面的场景里，我们只有 5 个队列。此时，我们假设会有 100 个队列。那么，m = hash(id) mod 100 这个公式里：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;m 大于 5 的概率为 95%&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们的 5 个队列是按照编号顺序依次排列的。那就说明所有 m 大于 5 的信息就都会映射到一个不存在的队列上，最终，根据规则，顺时针滑到了 0 对应的 chat00 队列中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果，我们可以让真实存在的队列均匀分布到环上，那么，这种严重失衡的现象还会再出现吗？&lt;img data-ratio=&quot;0.9032258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DN45RRNDjjicVYv0gDHWR2ElrsYcJBP9MCXuVgXPChuj5WPOnRPFN8TQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;434&quot;/&gt;&lt;img data-ratio=&quot;0.6612529002320185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92D5U0gdyQy3l3PAmg529p53mLcTFLiabDjsyZOYx3GPZbic04brbkiblWLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;862&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的图我们可以看出，如果我们能让真实的队列均匀的在圆环上分布，那么这种严重失衡的现象就会得到极大的缓解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何让这些队列能均匀的分布在这个圆环中呢？还记得我们在苦恼分配信息规则的不断修改时，我们大胆的假设了一个我们的 IM 系统永远也不可能达到的队列数字吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们假设了 MQ 中有 100 个队列，然后，我们去判断这些队列是否真实存在。不存在，我们就顺时针滑动一直找到真实存在的队列为止。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们再大胆一点，偷偷的把我们的假设进一步优化，把一些本来需要判断为不存在的队列去映射到真正已经存在的队列上，那么我们是不是就等于把这些真正存在的队列均匀分布到这个圆环上了？&lt;img data-ratio=&quot;0.6085106382978723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92D1ScYNexrqybHjK8mhAJ8RulHbNRsekDyIMichicVPHkQgYdJY2q1Y0uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像上图这种，把已经存在的少量队列去映射到多个假设队列的方法，就是一致性哈希的虚拟节点办法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对于怎么让少量的队列映射到多个假设队列，是有多种实现算法存在的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我们可以把真实存在的队列名加上一些编号去分别哈希一下, 像hash(chat00) mod 100，hash(chat00#1) mod 100，然后根据得到的余数，去把 chat00 这个真实队列和对应余数的环中的位置映射上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 hash(chat00) mod 100 = 31，那么 31 号的位置就对应于 chat00，以后所有 m = hash(id) mod 100 中 m = 31的所对应的消息就会直接被发送到 chat00 队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 hash(00#1) mod 100 = 56，则 m = 56对应的消息同样也会直接发送到 chat00 队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，我们就间接的把 MQ 中的真实存在的队列做了均匀化分布，从而大大减少了信息失衡的现象。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. 理解算法的思想胜于算法的实现&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，通过实际场景来对于一致性哈希的思想就暂时剖析到这里了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一致性哈希作为一种非常经典的算法思想，被广泛的用于各大分布式项目当中，用于解决各种分片问题，任务分发问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，在这里，我要纠正一个观点：很多人都在网上说 redis 使用了一致性哈希。这是错的，redis 只是使用了一致性哈希的思想。比如一致性哈希中的环分布，再比如虚拟节点对应真实节点的思想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 redis 并没有使用任何哈希算法去计算分布，如果有兴趣的读者，可以仔细去看下有关内容。从 redis 的例子上来说，我们可以看到，只有理解了算法的思想，我们才能更容易更灵活地因地制宜的分解、修正、改进算法，让算法能更切合实际的融入到我们的项目之中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这篇文章我们从哈希开始，一直到用到一致性哈希的虚拟节点分布，怎么样，您觉得一致性哈希这道良药味道如何呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次写图解的文章，大家包容一下直男的审美！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次写图解的文章，画图真是累吐血了！求大家看完点个&lt;strong&gt;在看&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;我准备了一些纯手打的高质量PDF：&lt;br/&gt;&lt;/section&gt;&lt;section&gt;深入浅出Java多线程、HTTP超全汇总、Java基础核心总结、程序员必知的硬核知识大全、简历面试谈薪的超全干货。&lt;/section&gt;&lt;section&gt;别看数量不多，但篇篇都是干货，看完的都说很肝。&lt;/section&gt;&lt;section&gt;领取方式：扫码关注后，在公众号后台回复：666&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.440625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KSnObMQf98GBHlgrmrLrBjnEX3Dhrp6ibhSlBtM0zFXIgUb1Us6CXON4EMJwyCcKhDxLwTulgAb52Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我最近建了一个读者交流群，里面大部分是程序员，一起聊技术、工作、八卦。&lt;/span&gt;&lt;span&gt;欢迎加&lt;/span&gt;&lt;span&gt;我微&lt;/span&gt;&lt;span&gt;信，&lt;/span&gt;&lt;span&gt;拉你入群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9852216748768473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KQibCDibpTo0kqofPehQvDDibibcb3bQUELdY3Knsl4r0RcgsV9l4icr3icmZQfaBXtSFNTxmdQlAZT1OQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;智能人工推荐&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484826&amp;amp;idx=1&amp;amp;sn=35378fc344195edc643c5a68f896bc40&amp;amp;chksm=fcd8c9dbcbaf40cdcad84dd15b972afed8cf477f584748167ee67dc3a2a3532474497aa4d6c1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一个技术总监的忠告：精通那么多技术，你为何还是受不到重用？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484792&amp;amp;idx=1&amp;amp;sn=37b3953abb879837d3ab24a2f943dba5&amp;amp;chksm=fcd8c939cbaf402f82bc0a580212f410736614cc15f1d2061d24f47ca439fa9ae2c6f22e643f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;架构师说了：不想做背锅侠？生产问题要这样查&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484777&amp;amp;idx=1&amp;amp;sn=977e620df6c3b640985e20345aa80a12&amp;amp;chksm=fcd8c928cbaf403ed6e28e6b8aafaa851cd0a5a1404fbb34ba7eeb25b592b7a593852e9bd002&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;恕我直言，微服务挺好，但不适合你&lt;strong/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3b19255dc4adec95c69aa80d79bdcf82</guid>
<title>从贫血模型到领域驱动设计</title>
<link>https://toutiao.io/k/9jmqhyz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;作者 | 吴敌&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibm2sb53lRhxzmebMBaxxdfYu7vs1vknpFTbaibib6VsSdHdWfeshsW7aZELUM21P9fWrZEojchzqgDnBNrXrqjzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;959&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;格物致知 知行合一&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-source-line=&quot;1&quot;&gt;贫血模型&lt;/h3&gt;&lt;p data-source-line=&quot;3&quot;&gt;在编程领域有一个十分著名的公式：&lt;/p&gt;&lt;blockquote data-source-line=&quot;5&quot;&gt;&lt;p&gt;程序 = 数据结构 + 算法&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-source-line=&quot;7&quot;&gt;在面向对象编程的世界中，将现实世界中事物抽象为对应的类，数据结构对应着承载业务数据的各种类的字段，比如一个人可能就抽象为 Person 类，人具有年龄，身高等属性，抽象为Person 类的 age , height 等字段。而算法则对应业务需求的驱动引起的数据变化的过程和方式，比如要表示一个人长高了 10cm ，则可以给 Person 类设计一个 grow(int height) 方法来表示“长高”这一动作。面向对象的话题很多，这里只简单介绍一下，不做深入展开。那么贫血模型又是什么意思呢？&lt;/p&gt;&lt;p data-source-line=&quot;9&quot;&gt;贫血模型是指只有业务字段以及字段 getter 和 setter 的实体对象。这个概念其实对于一个 Java - Spring 应用来说并不陌生，大多数时候在我们项目中都使用了贫血模型。贫血模型中只包含了数据，而不包含任何的业务逻辑。在一些系统中，数据库映射实体、RPC 请求和返回结果等被设计为贫血模型。与贫血模型相对的一个概念是充血模型：在贫血模型的基础上，充血模型的对象拥有了自身的业务方法，能够对外暴露一些“动作”。上文中的 grow 方法就可以看作是充血模型的特征之一。贫血模型就好比只有骨架的生物，加上自身的业务方法后，能变为有血有肉的实体。&lt;/p&gt;&lt;p data-source-line=&quot;11&quot;&gt;下面从面向对象编程 (OOP) 和测试性两个角度对贫血模型和充血模型进行简单对比。&lt;/p&gt;&lt;h3 data-source-line=&quot;13&quot;&gt;贫血模型与 OOP&lt;/h3&gt;&lt;p data-source-line=&quot;15&quot;&gt;假设这样一个场景，一个订单 Order 需要在做取消操作之前，需要检查状态是否正确，如果正确则可以进行取消。使用贫血模型可能有如下设计：&lt;/p&gt;&lt;pre data-source-line=&quot;18&quot;&gt;&lt;code&gt;&lt;span&gt;@Getter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Setter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Order&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer status;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String orderId;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OrderService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Integer ORDER_STATUS_SUBMIT = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Integer ORDER_STATUS_CANCELED = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//&lt;span&gt;取消订单&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;cancel&lt;/span&gt;&lt;span&gt;(Order order)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!canCancel(order)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        order.setStatus(ORDER_STATUS_CANCELED);&lt;br/&gt;        &lt;span&gt;//&lt;span&gt;可能有其他操作。。。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//&lt;span&gt;判断是否可以取消&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;canCancel&lt;/span&gt;&lt;span&gt;(Order order)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ORDER_STATUS_SUBMIT.equals(order.getStatus());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;46&quot;&gt;这里的 Order 就是典型的贫血模型，不包含任何的取消订单的业务逻辑，所有的业务逻辑都交给了 OrderService 进行管理。同样的场景，使用充血模型可能有如下设计：&lt;/p&gt;&lt;pre data-source-line=&quot;49&quot;&gt;&lt;code&gt;&lt;span&gt;@Getter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Order&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Integer STATUS_SUBMIT = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Integer STATUS_CANCELED = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer status;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String orderId;&lt;br/&gt;    &lt;span&gt;//&lt;span&gt;取消订单&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;cancel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!canCancel()) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.status = STATUS_CANCELED;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//&lt;span&gt;是否可以取消&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;canCancel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; STATUS_SUBMIT.equals(status);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;73&quot;&gt;可以看到，只一个类！Order 类具有类 canCancel 方法表示订单能否被取消，cancel 方法对订单进行实际取消动作。&lt;/p&gt;&lt;p data-source-line=&quot;75&quot;&gt;咋一看可以发现两种设计区别不是那么大，贫血模型在借助了 Lombok 等工具后代码量与充血模型相近。那么两种实体模型有什么内在不同呢？以下进行简单的理论分析：&lt;/p&gt;&lt;p data-source-line=&quot;77&quot;&gt;1，从面向对象的特性来考虑：贫血模型对于订单完全没有封装，只是数据容器，借由 OrderService 类进行业务管理，其业务字段完全暴露出去。OrderService 几乎没有任何的业务字段，而是关于订单的业务方法；贫血模型能够使用继承达到字段共享的目的，能够有不同的子类承载差异化的数据，但是缺少业务方法，没办法在实体上利用“多态”这一特性，因为其对象行为完全是由管理类 OrderService 完成的，多态只能由管理类来体现。贫血模型中，实体是数据模型，管理类代表了实体的业务，有没有觉得这两个类本身就该是一个类？&lt;/p&gt;&lt;p data-source-line=&quot;79&quot;&gt;2，高内聚低耦合原则&lt;/p&gt;&lt;p data-source-line=&quot;81&quot;&gt;Order 类与 OrderService 是高度耦合的。假设有这样一个场景：我们拿到第三方提供的贫血模型的 Order 类，想判断订单是否可以取消，怎么展开代码？我们不仅需要了解 Order 类的字段，还需要知道 OrderService 的存在及其使用方法。在我们了解 OrderService 这样的管理类的存在时，调用其 canCancel 方法即可；然而在不知道 OrderService 存在的情况情况下，我们很可能自己写一个，重复代码就这么产生了！假设我们自己写一个方法进行判断，就必须知道 order.status = 1 的时候订单才能取消：作为调用者的我们需要知道字段的业务含义才能进行业务操作，负担太重，而且很容易出错！假如后期 Order 类的提供者业务中增加了可以取消订单的场景，那之前自己写的判断是不是需要作相应的修改？&lt;/p&gt;&lt;p data-source-line=&quot;83&quot;&gt;另外，取消订单时 Order 类应该怎么修改自身数据结构、能不能被取消，应该是 Order 类自己进行管理，让 OrderService 来管理也增加了调用者的使用负担，因为调用者必须知道管理类的存在。&lt;/p&gt;&lt;p data-source-line=&quot;85&quot;&gt;贫血模型设计是低内聚高耦合的。&lt;/p&gt;&lt;h3 data-source-line=&quot;87&quot;&gt;贫血模型与可测试性&lt;/h3&gt;&lt;p data-source-line=&quot;89&quot;&gt;良好的代码设计一定是便于测试的，当发现自己写的代码很难进行测试时，很可能在设计上存在或多或少的问题。接下来从可测试性对两种模型进行分析，考虑一下场景：一个箱子 Box 中，可以放置各种颜色的铅笔 Pencil，数量不限，同时要求 Box 能显示内含所有铅笔的总数。现在业务要求是：去掉 Box 中颜色为红色的铅笔。&lt;/p&gt;&lt;p data-source-line=&quot;91&quot;&gt;数据库表为： &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibm2sb53lRhzLh9GaFeYL00yw1ICYGaibgvk5pSA1o4cJah1icNtHjjWUWbj96hw6FeSpC92SC2oLkG2DiaQSnKnVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;94&quot;&gt;贫血模型可能这么设计：&lt;/p&gt;&lt;pre data-source-line=&quot;95&quot;&gt;&lt;code&gt;&lt;span&gt;@Getter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Setter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Box&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer pencilAmount;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Getter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Setter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Pencil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer boxId;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String color;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoxService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PencilMapper pencilMapper;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; BoxMapper boxMapper;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String COLOR_RED = &lt;span&gt;&quot;red&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//&lt;span&gt;业务方法：移除&lt;/span&gt;box&lt;span&gt;中红色的铅笔&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;removeRedPencils&lt;/span&gt;&lt;span&gt;(Integer boxId)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Pencil&amp;gt; redPencils = pencilMapper.findByBoxIdAndColor(boxId, COLOR_RED);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!redPencils.isEmpty()) {&lt;br/&gt;            Box box = boxMapper.findById(boxId);&lt;br/&gt;            Integer oldAmount = box.getPencilAmount();&lt;br/&gt;            box.setPencilAmount(oldAmount - redPencils.size());&lt;br/&gt;            pencilMapper.batchDelete(redPencils);&lt;br/&gt;            boxMapper.update(box);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//&lt;span&gt;忽略&lt;/span&gt; &lt;span&gt;数据库层的&lt;/span&gt;Mapper&lt;span&gt;相关代码&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;134&quot;&gt;充血模型设计可能如下：&lt;/p&gt;&lt;pre data-source-line=&quot;135&quot;&gt;&lt;code&gt;&lt;span&gt;@NoArgsConstructor&lt;/span&gt; &lt;span&gt;//&lt;span&gt;为了一些框架能反射生成实体&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Box&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; List&amp;lt;Pencil&amp;gt; pencils;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;getId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; id;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Box&lt;/span&gt;&lt;span&gt;(Integer id, List&amp;lt;Pencil&amp;gt; pencils)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = id;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.pencils = (pencils==&lt;span&gt;null&lt;/span&gt;? Collections.emptyList():pencils);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getTotalAmount&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; pencils.size();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//&lt;span&gt;业务方法：移除&lt;/span&gt;box&lt;span&gt;中红色的铅笔&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;removeRedPencil&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        pencils.removeIf(Pencil::isRed);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@NoArgsConstructor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Pencil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String color;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String COLOR_RED = &lt;span&gt;&quot;red&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Pencil&lt;/span&gt;&lt;span&gt;(Integer id, String color)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = id;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.color = color;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isRed&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; COLOR_RED.equals(color);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoxAppService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; BoxRepository boxRepository;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;BoxAppService&lt;/span&gt;&lt;span&gt;(BoxRepository boxRepository)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.boxRepository = boxRepository;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//&lt;span&gt;业务入口&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;removeBoxRedPencil&lt;/span&gt;&lt;span&gt;(Integer boxId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Box box = boxRepository.get(boxId);&lt;br/&gt;        box.removeRedPencils();&lt;br/&gt;        boxRepository.update(box);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//&lt;span&gt;忽略数据库层的代码&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;192&quot;&gt;代码中省略了可能出现的错误处理和数据库层的代码，由于充血模型更加 OOP 一些，其业务方法可读性很好，几乎接近自然语言，同时注意到充血模型的 Box 类由于有较好的封装，并没有无脑暴露 setter，而是按照业务需要暴露必要的方法和属性。&lt;/p&gt;&lt;p data-source-line=&quot;194&quot;&gt;从可测试性来考虑：在贫血模型中，2 个实体类只是数据容器，不用写测试；2 个数据库访问的 Mapper 共 4 个方法需要写数据库集成测试，BoxService 是主业务逻辑实现，也是测试的重点。它的测试怎么写呢？有 2 个选择：（1）作为一个数据库集成测试：则需要准备好数据库初始化 sql ，执行初始化 sql 和业务方法后，需要另写 sql 查询数据库该 Box 的红色 Pencil ，对结果进行为空断言，并检查 Box 的 Pencil 总数是否正确；如果选择此方法，则系统中多了一个集成测试！（2）使用 Mock 的方式模拟 2 个 Mapper，给 2 个查询方法 mock 返回数据，并断言 Mapper 的 batchDelete 和 update 方法有被正确的调用，且参数正确，如下：&lt;/p&gt;&lt;pre data-source-line=&quot;196&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoxServiceTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Mock&lt;/span&gt;&lt;br/&gt;    PencilMapper pencilMapper;&lt;br/&gt;    &lt;span&gt;@Mock&lt;/span&gt;&lt;br/&gt;    BoxMapper boxMapper;&lt;br/&gt;    &lt;span&gt;@InjectMocks&lt;/span&gt;&lt;br/&gt;    BoxService boxService;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String RED = &lt;span&gt;&quot;red&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@BeforeEach&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setUp&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        initMocks(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 2&lt;span&gt;次&lt;/span&gt;mock&lt;span&gt;和测试结果的断言的业务可读性太低&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;should_delete_red_pencil&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//prepare&lt;/span&gt;&lt;br/&gt;        Integer boxId = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        List&amp;lt;Pencil&amp;gt; pencilList = Arrays.asList(&lt;br/&gt;createPencil(&lt;span&gt;100&lt;/span&gt;, boxId, RED),&lt;br/&gt;                createPencil(&lt;span&gt;101&lt;/span&gt;, boxId, RED));&lt;br/&gt;        Box box = createBox(boxId, &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;        when(pencilMapper.findByBoxIdAndColor(&lt;span&gt;1&lt;/span&gt;, RED))&lt;br/&gt;                .thenReturn(pencilList);&lt;br/&gt;        when(boxMapper.findById(boxId)).thenReturn(box);&lt;br/&gt;        &lt;span&gt;//when&lt;/span&gt;&lt;br/&gt;        boxService.removeRedPencils(boxId);&lt;br/&gt;        &lt;span&gt;//then&lt;/span&gt;&lt;br/&gt;        Assertions.assertEquals(box.getPencilAmount(), &lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;        verify(pencilMapper, times(&lt;span&gt;1&lt;/span&gt;)).batchDelete(pencilList);&lt;br/&gt;        verify(boxMapper, times(&lt;span&gt;1&lt;/span&gt;)).update(box);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; Box &lt;span&gt;createBox&lt;/span&gt;&lt;span&gt;(Integer id, Integer amount)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Box box = &lt;span&gt;new&lt;/span&gt; Box();&lt;br/&gt;        box.setId(id);&lt;br/&gt;        box.setPencilAmount(amount);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; box;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; Pencil &lt;span&gt;createPencil&lt;/span&gt;&lt;span&gt;(Integer id, Integer boxId, String color)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Pencil pencil = &lt;span&gt;new&lt;/span&gt; Pencil();&lt;br/&gt;        pencil.setId(id);&lt;br/&gt;        pencil.setBoxId(boxId);&lt;br/&gt;        pencil.setColor(color);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; pencil;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;249&quot;&gt;可以看到，使用 Mock 的形式写的单元测试业务可读性很差。另外一个方面，在贫血模型架构下很难进行一些较好的测试工程实践，比如：测试驱动开发（TDD）。TDD 要求在写出业务代码前，先写它的测试和断言结果，然后再正式开始编码业务方法让测试通过。看看上面的示例，在没有业务代码的情况下准确的 Mock 各个 mapper 方法返回值和断言其实是相当困难的！&lt;/p&gt;&lt;p data-source-line=&quot;251&quot;&gt;再来简单分析充血模型：2 个实体类包含业务逻辑，可读性很好，2 个单元测试就能覆盖主业务场景；BoxAppService 也极为简单，Mock 一下 BoxRepository 即可。充血模型设计将业务操作和数据库操作解耦了。测试业务时，只需要验证业务模型包含的数据是正确的，所有的业务测试都是单元测试，速度很快；对仓储层 BoxRepository 的测试是集成测试。仓储层一般采用成熟的数据库框架，复用率很高。借助于 Hibernate 等 ORM 工具，在足够熟练的情况下甚至可以不写测试。&lt;/p&gt;&lt;p data-source-line=&quot;253&quot;&gt;一个良好的测试体系应该符合金字塔原则：大量的单元测试、中量的集成测试、少量的契约测试。贫血模型的代码与充血模型相比测试性较低，与数据层的高耦合使得测试很难写，而且集成测试占比也会较高，测试运行效率较低。 &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.60390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibm2sb53lRhzLh9GaFeYL00yw1ICYGaibg5ib1mlryWhwPE1iauiaicqA2DEfSgRFQWicJpvjvYSY90Th1ibLCNNOVTZKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h3 data-source-line=&quot;256&quot;&gt;充血模型与领域驱动设计&lt;/h3&gt;&lt;p data-source-line=&quot;257&quot;&gt;大型软件项目的最复杂之处不是实现，而是软件所服务的真正的领域。领域驱动设计（Domain Driven Design）是用来处理这些高度复杂领域一种工程实践方法论，而充血模型在 DDD 的具体实现上占用重要地位。&lt;/p&gt;&lt;p data-source-line=&quot;259&quot;&gt;所谓领域，如管理用户登陆、密码的“用户领域”，负责订单生成、流转的“订单领域“，都是具体的软件业务场景，在微服务架构下甚至可以简单理解为每一个微服务。所谓领域驱动，是指系统设计是由领域业务来驱动的。通过与领域专家的沟通，由领域业务建模抽象指导代码设计，这和数据驱动有很大的不同。数据驱动是针对领域业务，直接设计数据库表、字段，反过来生成领域实体。而领域驱动直接针对领域业务抽象出实体，而后再考虑数据库层面如何设计。领域驱动设计中的聚合根、实体、值对象等领域模型都是充血模型，对象方法提供的领域服务能体现出该领域中最核心的业务。至于数据库访问，对外暴露的 rest 接口等，都只是对领域对象持久化和操作的手段。&lt;/p&gt;&lt;p data-source-line=&quot;261&quot;&gt;下图就是广为流传的 DDD 六边形架构。领域模型位于最中间，包含的实体对象和领域服务构成了整个领域的业务模型，在设计上领域模型尽可能少的依赖外部基础设施，只是纯粹的业务类。应用程序层负责组织领域方法的调用；六边形的各个边表示不同的端口，每个端口要么处理输入（领域操作），要么处理输出（查询或者持久化等）。对于每一种类型都有一个适配器与之适配，这里的适配器是相对领域模型而言的。比如：某个外部客户端使用 Http 协议和领域进行交互，则定义一个 Http 的适配器即可；另一个客户端可能使用 TCP 协议进行交互，则实现一个 TCP 适配器即可；领域对象需要使用 Mysql 进行持久化，则定义一个 Mysql 的适配器，即仓储模型 Repository。端口的含义是抽象的，输入和输出通过适配器转化为核心的领域模型中的对象或者事件，由领域模型内部进行业务处理即可。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibm2sb53lRhzLh9GaFeYL00yw1ICYGaibgQrib6cVcH1BIichVkpNnPUjJkCp6ic6BPlic1gpbkib0d8CGRRBwxkY2eKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h3 data-source-line=&quot;265&quot;&gt;后记&lt;/h3&gt;&lt;p data-source-line=&quot;267&quot;&gt;以上简单的对比了贫血模型和充血模型在面向对象和测试性方面的差异，并简单介绍了充血模型在 DDD 中的使用。&lt;/p&gt;&lt;p data-source-line=&quot;269&quot;&gt;虽然贫血模型有着一些缺点，但是在快速迭代和开发速度上具有很大优势，精准的数据层访问能提高系统性能，与需要快速响应需求的互联网行业甚为匹配。随着业务的复杂和需求的变化，业务方法分散使得重复代码越来越多的出现、可维护性会越来越差。&lt;/p&gt;&lt;p data-source-line=&quot;271&quot;&gt;充血模型虽然更加 OOP，也有着更好的可读性和测试性，在大型固定需求的场景下能明显提高工程质量，但是在需求快速更迭时需要考虑对象的设计的重构，面向对象的数据结构和传统结构化数据库天然的不匹配使得数据库设计较为困难，稍有不慎容易引发性能问题，在一些需求经常变化的小项目中反而可能降低生产力。&lt;/p&gt;&lt;p&gt;&lt;span&gt; 全文完&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;以下文章您可能也会感兴趣：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们正在招聘 Java 工程师，欢迎有兴趣的同学投递简历到 rd-hr@xingren.com 。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3592814371257485&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibm2sb53lRhyEnpttJoHJkhLPHL3C1QdPPb1U3cHrUTtljkNuW3fuSejp4f6sjxUryEXeXBbyT8gebzJia10MFlw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;501&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>