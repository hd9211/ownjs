<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>05a056aa65796ad709a50dcd3f7f0fe1</guid>
<title>反驳：Rust 是 Go 应该成为的样子？</title>
<link>https://toutiao.io/k/71t4gxq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;作为两门服务端的新&lt;/span&gt;&lt;span&gt;语言，这些年受到越来越多的关注。&lt;/span&gt;&lt;span&gt;有人调侃说，关注 Rust 的人中，很大一部分是从 Go 过来的。&lt;/span&gt;&lt;span&gt;经常有人因为 Go 的一些设计和特质而质疑它，同时，Rust 常被誉为解决 Go 问题的几乎完美设计的替代方案。&lt;/span&gt;&lt;span&gt;但实际上，这两门语言并不是直接竞争关系，不能直接互换，更多是互补。&lt;/span&gt;&lt;span&gt;本文就带着大家看看两者的不同。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一篇文章 《I want off Mr. Golang&#x27;s Wild Ride》：https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride，以及围绕它的激烈讨论，不止一次遇到过诸如“Rust 是 Go 应该成为的样子”之类的陈述。这些讨论中观点，显然是由那篇文章推动的，似乎反应出 Go 有太多有问题的特性，而另一方面，Rust 是一个精心设计的 Go 替代品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我看来，这篇文章的讨论揭示了对这两种语言、它们解决的问题以及它们所针对的软件开发范式的严重误解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;01 文章对 Go 的批评&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章主要批评 Go 的简单是一个谎言：标准库中的 API 向用户隐藏了复杂性，而没有真正解决它，这在极端情况下会产生完全错误的结果。以 Go 的&lt;code&gt;filepath.Ext&lt;/code&gt;函数为例：它在某些情况下会产生不准确的结果。作为反例，这篇文章提到了 Rust&lt;code&gt;std::path::extension&lt;/code&gt; 是产生完全正确结果的函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种对 Go 在边缘情况下不准确的不满似乎是可以理解的。我们都知道，在编程中，只有正确和不正确，没有其他结果。因此，由于 Rust 提供了正确的结果，它显然是更好的语言。但事情真的这么简单吗？难道谷歌不能聘请高手来解决这个问题吗？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;02 追根溯源&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 和 Rust 被频繁地比较，因为它们都被宣传为系统编程语言，而且它们都是现代的编程语言，发布时间接近。但是，一旦你内化了它们的来源以及它们的设计目的，你很快就会发现它们是两种完全不同的语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 是一个 Google 项目，主要设计用于后端和网络服务。这些服务在可预测的、同质的、Unix 等基础设施中运行。谷歌完全控制着他们的基础设施，潜在的性能瓶颈可以通过在问题上投入更多的服务器来解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一方面，Rust 是由 Mozilla 在非常不同的情况下启动的。Firefox 和 Servo 等项目是非常长寿的软件产品，必须在各种系统上运行。他们必须在不均匀、未知且可能充满恶意的环境中工作。因此，在每个系统上产生完全相同的结果对于这些应用程序至关重要。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;03 不同的问题，不同的语言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;谷歌和许多其他维护类似基础设施的公司通常必须应对以下挑战——虽然我对谷歌没有深入的了解，但其中一些可能被其庞大的规模放大了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;开发人员流动率高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;短迭代中的快节奏开发。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;快节奏的组织扩展。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高度动态的基础设施和环境。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;短期和可替换的服务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Google 需要一种完全针对这些挑战量身定制的语言，并且不可避免地会设计出与满足 Mozilla 需求的语言不同的语言。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;04 另一种范式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 和 Rust 不仅有不同的语言设计，它们还包含一种相反的软件开发方法。Rust 专注于高效率并为问题找到最漂亮的实现。为了实现这一点，与其他语言相比，它有着更陡峭的学习曲线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比之下——这就是大部分行业的现实——谷歌和许多其他公司不希望他们的开发人员在他们能够高效工作之前花 3 个月时间学习一门新语言。因此，Go 被有意设计为一种快速学习和使用的语言。它不一定是最有效或最漂亮的解决方案。它甚至不必在公司不使用的系统上工作。它只需要工作得足够好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么？因为运行动态基础设施需要高度的自动化、标准化、监控、可观察性、弹性、可扩展性和安全性。对于不在这样的环境中工作的开发人员来说，这听起来可能很奇怪，但在日常业务中，重点往往是这些高级需求而不是代码本身。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;05 底线&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管乍一看 Go 和 Rust 似乎为类似场景提供了类似的好处，但它们是针对不同问题而设计的专业工具。就像大多数其他工具一样，一个并非比另一个“更好”。在寻找适合自己需求的新语言时，Google 和 Mozilla 都没有采取有偏见的方法。他们只是努力寻找最适合他们的解决方案——你也应该如此。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://dominikbraun.io/blog/the-difference-between-go-and-rust/&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-fileid=&quot;503967151&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>824247ed34815f4c3681a0bb985c9cad</guid>
<title>项目中怎样做技术选型？</title>
<link>https://toutiao.io/k/ftrvm6v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引出四个维度&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;工作快十五年了，从十年前开始经常会有新项目，需要从头开始做方案和设计。做技术选型很少成为我的难题。不是因为这方面我多有方法，而通常是很少有选择。在做技术选型的场景下基本有以下四个维度：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;维度一&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;从系统构成上有两种：&lt;/p&gt;&lt;p&gt;第一种，有之前的老系统，需要重构&lt;/p&gt;&lt;p&gt;第二种，从零开始建的服务&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;维度二&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从稳定性要求上有三种：&lt;/p&gt;&lt;p&gt;第一种，现在没有什么业务量，将来估计也不会有什么增长，甚至很可能不成&lt;/p&gt;&lt;p&gt;第二种，现在没有什么业务量，将来对稳定性要求很高&lt;/p&gt;&lt;p&gt;第三种，现在对有稳定性要求很高&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;维度三&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从环境上有三种：&lt;/p&gt;&lt;p&gt;第一种，公司有很多基础设施&lt;/p&gt;&lt;p&gt;第二种，公司有一些基础设施&lt;/p&gt;&lt;p&gt;第三种，公司基本没有基础设施&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;维度四&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从要求上有两种：&lt;/p&gt;&lt;p&gt;第一种，公司有标准化规范，需要用公司的统一组件&lt;/p&gt;&lt;p&gt;第二种，公司没有要求&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;各个维度组合的选项考虑&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;从零开始项目现在没有什么业务量，将来估计也不会有什么增长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;从目标上，遇到这种项目，工作的重心就不在于把项目做好做坏，而在于人员培养。&lt;/p&gt;&lt;p&gt;如果公司对组件上没有什么要求，那我的建议是大家想学什么，就用什么。直接拿学习的试验田来用，一举两得。&lt;/p&gt;&lt;p&gt;如果公司有标准化规范，需要用公司的统一组件。但是公司的组件一般也是开源进行二次开发的，也一样可以想学什么就用什么，弄不明白的，还可以找维护组件的人请教。也可以用公司自研的，但是在业界有一定知名度的产品。研究的好可以作为面试的一个亮点。&lt;/p&gt;&lt;p&gt;瞎举个例子哈：&lt;/p&gt;&lt;p&gt;一六年、一七年做P2P并且不合规的公司，眼看就不行了。有的团队用的kafka，就是为了学习这个东西；有的团队自己搭建redis集群也是为了学习。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;从零开始项目现在没有什么业务量，现在或者&lt;/strong&gt;&lt;strong&gt;将来对稳定性要求很高&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从目标上，这个是产生业绩的最佳项目，要精心规划。&lt;/p&gt;&lt;p&gt;做这种项目需要做好调研，包含业界调研和公司调研。业界的同类产品是怎么做的，有哪些缺点和优点。公司有没有同类或者可以登高类比(登高类比是指先找相似度最高的，找不到在逐渐扩大范围)的，那些项目遇到过哪些坑或者问题，是否和架构或者技术选项有关。&lt;/p&gt;&lt;p&gt;在做好调研基础上，如果公司对组件上没有什么要求，那就需要根据项目本身的特点综合比较。举例如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9288590604026845&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9CmJJia6SPKn3aiat9bnl33qdT7I2fW1QgJNGNoT5WSwMrNsJjuhG9O1iakIfozicuWhUUeeDhLOsteQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;745&quot;/&gt;&lt;/p&gt;&lt;p&gt;不考虑项目本身特性，使用技术通用的考察项主要有：优势、劣势、技术成熟度、社区活跃度、资料丰富程度、是否有大牌公司在持续维护。&lt;/p&gt;&lt;p&gt;可参考我之前的文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484754&amp;amp;idx=1&amp;amp;sn=06ef4e22d3d113f213171330cd5c132c&amp;amp;chksm=fafdeffccd8a66ea04c16e30f75bb09dfad34a1c4866cb14a5783a3450d84a02fe156b67464f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《SpringBoot整合web容器》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《SpringBoot整合web容器》&lt;/a&gt;里面有介绍我当初对tomcat还是jetty选择的考虑点。&lt;/p&gt;&lt;p&gt;如果公司有标准化规范，需要用公司的统一组件。&lt;/p&gt;&lt;p&gt;这时候，如果公司的组件可选性很多，比如之前美团的监控告警组件就有cat、digger、tracing、大白等。这时候一方面考虑各个组件的侧重点和自身是否切合，最重要的是要看其他团队都用什么。周围团队用的很少，咱们也不要用了。兄弟团队有福同享有难同当，如果大家都用这个，组件稳定性有问题了，影响的不止一个团队，也相互有个依靠。就自己用了还出事了，额，让我想起一句歌词：“多少秘密在其中 欲诉无人能懂”-----一帘幽梦。暴露年龄了。&lt;/p&gt;&lt;p&gt;如果公司的组件只有一个，也要看看兄弟团队有没有在用，还需要组件团队给提供相应的SLA，对于还在推广中的组件要谨慎。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重构老系统&lt;strong&gt;现&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;在&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;没有什么业&lt;/strong&gt;&lt;strong&gt;务量，将来估计也不会有什么增长&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;建议放弃重构！&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重构老系统&lt;strong&gt;现&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;在&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;没有什么业&lt;/strong&gt;&lt;strong&gt;务量，&lt;strong&gt;将来对稳定性要求很高&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;参考从零开始项目现在没有什么业务量，现在或者将来对稳定性要求很高的方法。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重构老系统&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;，现在&lt;strong&gt;对稳定性要求很高&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;建议选型尽量和之前保持一致，以便于和之前的逻辑尽量一致。避免踩到特殊需求导致的特殊逻辑等坑。&lt;/p&gt;&lt;p&gt;实在不能一致，比如十二年前我们有个“新鲜事”中间件，类似于网页版的发朋友圈吧。之前是用c++写的，后来c++的同事都离职了，要求我们改成java。这时候要考虑的主要是技术的成熟度。这个成熟度包含业界技术本身的成熟度和团队成员对技术的熟练度。&lt;/p&gt;&lt;p&gt;对于这种类型，还有几句忠告：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;不要特立独行，要合群！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用成熟的技术！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用成熟技术的成熟功能！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;最后对使用成熟技术的成熟功能做个解释说明：比如redis很成熟了，redis有很多高级特性，比如订阅转发，稳定性要求高的不要用。用更加成熟的常用做订阅转发的比如MQ!&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;往期推荐&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cf7a650e72453bd78df1397ca31de218</guid>
<title>脑洞：让页面白屏的 8 种方式和防御方法</title>
<link>https://toutiao.io/k/xsdoi2k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在页面上加些代码，让页面白屏幕，有哪些方式呢？如何防御呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍了 8 种让页面白屏的方法。在防御方法中，包含了一些你可能不知道的冷知识，如：判断元素是否被遮挡。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法1: 隐藏根节点&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;display&lt;/span&gt;:none &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择器用 &lt;code&gt;body&lt;/code&gt; 也能达到一样的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当页面是深色模式时，添加上面的代码页面后，页面是黑色的。需要取消深色模式：删除下面的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;meta&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;color-scheme&quot;&lt;/span&gt; &lt;span&gt;content&lt;/span&gt;=&lt;span&gt;&quot;dark&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法2: 让根节点不可见&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置可见性的属性：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;visibility&lt;/span&gt;: hidden &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者，设置透明度为完全透明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法3: 大小设为0，超出隐藏&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;body&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;overflow&lt;/span&gt;: hidden &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择器用 &lt;code&gt;html&lt;/code&gt; 没有效果。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法4: 偏移出屏幕&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 &lt;code&gt;fixed&lt;/code&gt; 定位：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: fixed;&lt;br/&gt;  &lt;span&gt;left&lt;/span&gt;: -&lt;span&gt;99999px&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者，用 &lt;code&gt;transform&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;translateX&lt;/span&gt;(-&lt;span&gt;99999px&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法5: 遮挡页面&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用全屏的白色元素遮挡页面。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;::before&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;content&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: fixed;&lt;br/&gt;  &lt;span&gt;z-index&lt;/span&gt;: &lt;span&gt;999999&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;top&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;100vw&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;100vh&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;background&lt;/span&gt;: &lt;span&gt;#fff&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法6: 缩小&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;0.0000000000001&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法7: 清空页面内容&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;document&lt;/span&gt;.documentElement.innerHTML = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法8: 页面跳转到一个空白页面&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;location.href = &lt;span&gt;&#x27;空白页面URL&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法有点皮~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;防御&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;检测白屏的样式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过轮训检查根节点上，是否有导致白屏的样式。如果有，则刷新页面。例如:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;setInterval(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(hasWhitePageStyle()) {&lt;br/&gt;        location.reload()&lt;br/&gt;    }&lt;br/&gt;},  &lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这种方式，可以防御方法 1 ~ 6。我们来看具体的检查方法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;根节点是否隐藏检查&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; root = &lt;span&gt;document&lt;/span&gt;.documentElement&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; body = &lt;span&gt;document&lt;/span&gt;.body&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;br/&gt;  getComputedStyle(root, &lt;span&gt;null&lt;/span&gt;).display === &lt;span&gt;&#x27;none&#x27;&lt;/span&gt; ||&lt;br/&gt;  getComputedStyle(body, &lt;span&gt;null&lt;/span&gt;).display === &lt;span&gt;&#x27;none&#x27;&lt;/span&gt;&lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 根节点被隐藏&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;根节点是否可见检查&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(&lt;br/&gt;  getComputedStyle(root, &lt;span&gt;null&lt;/span&gt;).visibility === &lt;span&gt;&#x27;hidden&#x27;&lt;/span&gt; ||&lt;br/&gt;  getComputedStyle(body, &lt;span&gt;null&lt;/span&gt;).visibility === &lt;span&gt;&#x27;hidden&#x27;&lt;/span&gt;&lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 不可见&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;br/&gt;  getComputedStyle(root, &lt;span&gt;null&lt;/span&gt;).opacity &amp;lt; &lt;span&gt;0.1&lt;/span&gt; || &lt;br/&gt;  getComputedStyle(body, &lt;span&gt;null&lt;/span&gt;).opacity &amp;lt; &lt;span&gt;0.1&lt;/span&gt; ||&lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 不可见&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大小为 0 检查&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; {width, height } = body.getBoundingClientRect()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(width === &lt;span&gt;0&lt;/span&gt; || height === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 大小为 0&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;偏移出屏幕检查&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; {left, right, top, bottom } = body.getBoundingClientRect()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;br/&gt;  left &amp;gt; &lt;span&gt;window&lt;/span&gt;.innerWidth || &lt;br/&gt;  right &amp;lt; &lt;span&gt;0&lt;/span&gt; || &lt;br/&gt;  top &amp;gt; &lt;span&gt;window&lt;/span&gt;.innerHeight || &lt;br/&gt;  bottom &amp;lt; &lt;span&gt;0&lt;/span&gt; &lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 偏移出屏幕&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;遮挡检查&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;document.elementFromPoint(x, y)&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 返回某个坐标点下最上层的元素。如果元素没有被遮挡，则在该 API 中传入元素的上下左右四个坐标点，返回的均为该元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设页面上有个 id 为 tar 的元素，如果该元素未被遮挡，则认为页面被遮挡。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; tarElem = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;tar&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; {left, right, top, bottom} = tarElem.getBoundingClientRect()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.elementFromPoint(left, top) === tar &amp;amp;&amp;amp;&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.elementFromPoint(left, bottom) === tar &amp;amp;&amp;amp;&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.elementFromPoint(right, top) === tar &amp;amp;&amp;amp;&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.elementFromPoint(right, bottom) === tar &amp;amp;&amp;amp;&lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;// 未被遮挡&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;防止修改 DOM&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MutationObserver API&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 可以监控 DOM 的变动。用该 API 可以防御页面内容被清空。代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 监控 属性，子节点和后代节点的变动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; config = { &lt;span&gt;attributes&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;childList&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;subtree&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; observer = &lt;span&gt;new&lt;/span&gt; MutationObserver(&lt;span&gt;(&lt;span&gt;mutationsList&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; mutation &lt;span&gt;of&lt;/span&gt; mutationsList) {&lt;span&gt;// 页面DOM变动&lt;/span&gt;&lt;br/&gt;    location.reload()&lt;br/&gt;  }&lt;br/&gt;})&lt;br/&gt;&lt;span&gt;window&lt;/span&gt;.addEventListener(&lt;span&gt;&#x27;DOMContentLoaded&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;  observer.observe(&lt;span&gt;document&lt;/span&gt;.documentElement, config);&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;防止页面跳转&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前没有找到防御的方法。尝试过以下方法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重置 window.location&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;window&lt;/span&gt; = {}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;window.location 仍然在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; location = &lt;span&gt;&#x27;&#x27;&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;location&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;都会报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;window.location = {} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;页面直接跳转了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;将 window.location 设置为只读&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做了如下尝试，均不行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;.freeze(&lt;span&gt;window&lt;/span&gt;) &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.freeze(&lt;span&gt;window&lt;/span&gt;.location) &lt;span&gt;// 无效&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.defineProperty(&lt;span&gt;window&lt;/span&gt;, &lt;span&gt;&quot;location&quot;&lt;/span&gt;, {&lt;span&gt;&quot;writable&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;})&lt;br/&gt;&lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.defineProperty(location, &lt;span&gt;&quot;false&quot;&lt;/span&gt;, {&lt;span&gt;&quot;writable&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最后&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还有其他让页面白屏的方法吗？公众号留言告诉我吧~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;document.elementFromPoint(x, y): &lt;em&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementFromPoint&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;MutationObserver API: &lt;em&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver&lt;/em&gt;&lt;span/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>80fb3c8afe60861f8fd37207b5923134</guid>
<title>一增两减，助力深度学习在实时推理场景中的应用</title>
<link>https://toutiao.io/k/63xmx6j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;本文整理自英伟达史永明博士在 AI 技术专场所做出的演讲。在演讲中他主要介绍了为实现 DIGITAL JENSEN，利用 Audio2Face 实现语音生成对应面部视频、用 Audio2Gestures 实现语音生成对应肢体动作的主要技术流程、算法细节和评估效果的介绍，以及 NVIDIA Ampere Architect &amp;amp; SDK 在其他更多方面的应用。关注本文标签「RTE 技术分享」，我们将陆续更新更多演讲干货。以下为演讲整理。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibX31dlfMkdxTS9VOhDmUjLiciavrtEevPzDadlrhGqLC1PP3MT3AHh0wA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;▲图：NVIDIA 深度学习资深解决方案架构师 史永明&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.22037037037037038&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmib26m7BXac8ibef3LPvZaib2hNS9hAyN9KeeIpticG1zC1ZQyf7c30PIGyg/640?wx_fmt=png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;会议开始之初，史永明博士先介绍了之前在英伟达 GTC 大会上展示的虚拟人视频的制作过程，在视频制作里面，包括英伟达 CEO 黄仁勋本人，以及代表性的皮衣和整体的场景，全部都用AI合成。史永明博士在演讲中展示了 Audio2Face 在 DIGITAL JENSEN 上的算法工作流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5634638196915777&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmib1xCtCI8N6BAGTfygRkmjic6AChWy5FbbC1qEq0b8RiauSJicuYtg879bw/640?wx_fmt=png&quot; data-w=&quot;843&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Audio2Face 可以将输入的音频流数据转换为对应的音频驱动的面部动画，使用到的输入数据是一段音频信息和面部模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5634638196915777&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibYMgqsk0RkLHcw1CUpY0awD7rbyBryHvqLDvKGNGz5pdMwmgicGNHPOw/640?wx_fmt=png&quot; data-w=&quot;843&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;算法过程分成两步走，第一步，真正意义上的 Audio2Face，通过音频驱动，驱动预先创建好的头部模型表情，此时这个模型并不是我们最终想要的模型，所以还需要做一步 face retargeting 的转换，需要把预置头部模型的一些关键点和目标所需要驱动的头部模型的关键点匹配，最终实现音频驱动的面部动画。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5660377358490566&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibWbLnDPSYeE0LZtt8WpPKdW3fCibjxQ1OibjIeUkmDSWoDYdsI5pNz98g/640?wx_fmt=png&quot; data-w=&quot;848&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一步详细阐述如下：在 SDK 右边，输入一段音频信息，可以是事先录制的，也可以是通过 TTS 或者其他方式合成的音频，根据输入的音频流数据产生预置模型的面部动画，此时输入为音频，输出为音频驱动的预置模型的面部动画（非目标模型）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5591397849462365&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibnnACscb4VXia1WdOw1SGgfSICyWDmZp5RWdk6nnXibgsHBOCWW2jRUcg/640?wx_fmt=png&quot; data-w=&quot;837&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二步：将产生的预置模型的动画重映射到最终目标模型上。因为最终需要的是一个真实的或者是一个期望的目标头部的动画，所以需要做一个映射，可以在目标模型上选一些点，比如眼角、嘴角、鼻子、眉毛等等，选取 20 个左右，越多越好，做一步映射，最后可以用一个音频驱动，用音频带动目标头部模型，生成我们想要的动画。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5687203791469194&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibEKjjIIPJfQDmHD1IeG0ia0yyemEeZPC3ldXmHIbnGJ0kBAbInIy6Xqw/640?wx_fmt=png&quot; data-w=&quot;844&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里所使用的算法逻辑，可以参考之前的文章，输入是 520 毫秒的时间窗口，以当前时刻为基准，前后各 260 毫秒。同时需要一个情感向量输入，因为我们讲话通常不可能一点情感都没有。模型的输出是 5022 个特征点，即预置的人脸有 5022 个点组成，每个点是 X、Y、Z 三个坐标，是需要乘以 3。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5634638196915777&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmiblrpvzBTnxiaBjliabIezaRIKib6yN1Bm7vcxN9Ndic4jwzueuIR4Vf8UGQ/640?wx_fmt=png&quot; data-w=&quot;843&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;算法细节：这里的 loss function 有三个部分，第一个是 position loss，即预测值和真实值之间的位置差异；第二个是 Motion loss，指的是动作差异，之所以有这个 loss，是因为不希望输出的关键点有跳变，所以要增加平滑性；第三个是情感正则化损失 Emotion regularization loss，我们的情感是一个长时稳定的，所以要对表情特征进行正则化，避免情感向量在不同帧之间有突变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.566350710900474&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmibu22VXYeUj9F4NFtxHV7d81oiczvSC914pUVibzIX3pUYbzDIQ52w5Avw/640?wx_fmt=png&quot; data-w=&quot;844&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;模型运行参照时间评估：最终可以实现在单卡上做到 6.3 毫秒一帧；一批次输入 100 个 frame 的话，单帧可以达到 0.2 毫秒。延迟由音频窗口大小决定（目前是 260ms）；如果想降低延时，可对时间窗口进行调整。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.562953995157385&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibNeyMUpSABavbfUgiaSo3Wff3QpYjrhffYIgbdviczae5ll4EYsVQpm3w/640?wx_fmt=png&quot; data-w=&quot;826&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.22037037037037038&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibHzAVa0lgdjnVPiaUWPwgYrQSACvc92IyHL1OJErPaTXeiaemc4AicyY6A/640?wx_fmt=png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Audio2Gestures 算法在 DIGITAL JENSEN 上的工作流程：Audio2Gestures 是将输入的语音流生成对应的语言肢体动作。在 Audio2Gesture 中，身体的动作和语言之间的关系有很大的不确定性。在用音频生成内容的几种方式中，确定性最强的是 ASR，即用声音去生成一段文本，虽然有些同音字，但是在我们大的文本里边概率比较小。此外，上面提到的 audio2face，即用音频生成面部表情，也有一定确定性，因为发音和面部肌肉相关。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5699052132701422&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibaYcjzK0xC4aibw6SX6tPuE1O02EzLib51SPvLY8SPAZz07BmAXaicIZGA/640?wx_fmt=png&quot; data-w=&quot;844&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;训练数据集介绍：这里使用的训练数据集，是通过特定设备，请动作演员，模仿 Jensen 的身体动作，从而将动作通过设备采集下来，总共采集了两小时四十分钟。最后还需要让动作演员去根据之前对两小时四十分钟理解，自由发挥 15 分钟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5672169811320755&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibETdPoSBYrafYJoKL5axiblt9IzmjvbG9AVRDOF1VbMoZxogyetmMxeg/640?wx_fmt=png&quot; data-w=&quot;848&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Aduio2Gesturede 的实现细节目前尚未公开，大家可持续关注 NV 的后续报道，特别是可以到 NVIDIA2021 年的 GTC 大会了解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5625&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibgciboMBEhf4oxnTyAJIibItDDfWLHUm5wF7yKbEeUSe7M5tWkBoiciauAA/640?wx_fmt=png&quot; data-w=&quot;800&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.22037037037037038&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibibaK1e6LxmMNtNWhBjpp3IVMHsCtRCkR34OStPXKdXhYQeDJu075WnQ/640?wx_fmt=png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;史永明谈到：尽管使用的是 3D 模型，但是在屏幕上呈现的都是 2D 的，并且头部通常是注意力最集中的地方，故需要对头部进行一些精细的调整。Face Vid2Vid 输入的头部模型是通过 Audio2Face 生成的，在 Audio2Face 中有一个 Jensen 的头部模型输入，是 3D 的 Jensen 头部模型，是通过很多单反相机扫描建模的，通常这种建模的方式，肉眼很明显的分别出是建模出来的，不是真实拍摄的效果，用这个模型对 Jensen 头部做渲染，对结果与期望进行了对比，最终发现图看上去不太真实。故需要使用 Face Vid2Vid 算法改进模型的生成效果，使得其更加自然真实。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5626477541371159&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibCz2IHxXmyXteExCpOluhKGqQsQiaOkiad7XXByaE0lUjsZzHAtjJ1CcA/640?wx_fmt=png&quot; data-w=&quot;846&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;NVIDIA之前的方法有图片到图片的变换 Image-to-Image Translation、视频到视频的迁移 Video-to-Video Translation。通过一个人脸，通过模型使其变成另一个风格，但是这样会造成每一种风格，都需要寻找相应风格的模型，比如脸形、发型的模型，故这种模型不适用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5644970414201184&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibgJnQYd3menWVRsOZbzAln4a3ACzkX0pl8kHiayiahdZw2HACwbFazyFw/640?wx_fmt=png&quot; data-w=&quot;845&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Face Vid2Vid 算法中有三个关键步骤，第一步是对图片提取特征点，然后是驱动视频进行特征转换，最后产生目标视频。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5648584905660378&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibWg5BHfQDtTATria7cw7mvia0ErAjsic5f5pibzAdKfdLd99WFeicUvQFcow/640?wx_fmt=png&quot; data-w=&quot;848&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里需要对脸进行标准化，然后使用空间变换包括旋转变换，平移变换等方式，把表情加上去，可以把目标任务表情和原始表情关联起来，最后生成我们想要的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5687203791469194&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibkgMZaOCOaXicCOvJic9ib7Gmu01H8o2KXhjkVYUzXCQWUOOJSpwQJibeRQ/640?wx_fmt=png&quot; data-w=&quot;844&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里使用到的数据集部分一个是公开数据集，里面很多名人头部的动画，还有英伟达自己构建的独立数据集，目前不公开。视频时长 1000 小时，对于这个数据集请参考他们构建的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5621301775147929&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibZ2oJ5Fpib6P2yEop8aekCHTsGJKSn8NrxMiaBOY2peOOayGZdnuaco1w/640?wx_fmt=png&quot; data-w=&quot;845&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.1638888888888889&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibYeHUUD6ZTnplCDGgPmh6ibjibibgA3vZYSGZcU19oOdE3T6L7iaJIQzzBw/640?wx_fmt=png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;英伟达有很多其他新颖的技术，比如 AI 渲染里面的光线追踪、路径追踪等。一般来说，在渲染时，图像采样点少，速度快，但效果不好，采样点多它效果好，但算得不够快，用英伟达的AI渲染，在较少采样点的时候，可以用 AI 技术把噪声噪点消除掉。另外，为解决低采样率时的噪声问题，可以用 AI denoiser 获得跟 4096SPP 高采样率时相似的效果。另外还可以使用直接光照和全局光照，让画面看起来更饱和。最后是 DLSS，它的用法是，如果是对很高分辨率的图片进行渲染时，显卡通常没法达到实时的高帧率，所以通过在相对低分辨率下渲染，渲染后通过深度学习超载采样技术，把它转换到高分辨率上，这样既保证相同质量输出的前提下，又获得了实时的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5625&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmibd6L7kQnrhVoJHkTSJ8N79oYOmbF5YHlk5rAG2XmODWv3TeQP9ria6tg/640?wx_fmt=png&quot; data-w=&quot;800&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;英伟达三大硬件介绍：分别是渲染里面的着色，光线追踪的 RT core 和深度学习的 Tensor core。以上一代图灵架构为例，要渲染一张图片，如果全用 shader，是需要 51 毫秒，如果是打游戏，二十多帧。如果把光线追踪的部分放在 shader 上，把判断光线和哪个部分要相交的BVH的部分放到RT core 上，可以使时间大幅度缩减，20 毫秒就可以生成一帧。如果再使用 DLSS，可以达到 12 毫秒。在安培架构里，这些数值有不同程度的提升。三项技术全开，渲染相同的一帧画面只需要 6.7 毫秒。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5671819262782402&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibnI9yM2UicNAmWWejPq0GtAvx0lM8mZuMWMPgVx96iajkrx4icCIH2EWVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;841&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一增两减：这里所说的一增两减”，一增指的是算力的提升。两减是两部分，第一部分是在安培架构下，有一个结构化稀疏的特性，把无效的计算去除，提升单位算力的效率。第二个是支持很多量化方式，支持 QAT 量化方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5658362989323843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibPibKOuRIJW3jNycLWz3myd5SNYQ1xppbsNxS2bK1ibqlEncv0rfLuUqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;843&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5675355450236966&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmib4IfG2FTq0rJ74ib6oTYPrnGEt2tA0iabBOWYUIQsF9xjsttWriaYlIkWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;史永明博士通过对 A100 和 A100 的上一代训练卡 V100 数值的对比，对英伟达所提升的部分做了展示，各项性能都达到了几倍或者十几倍的性能提升，这是“一增两减“中的一增。而“一增两减”两减中的一减，即结构化稀疏，是因为在模型里面通常有些激活函数，会把激活值映射到 0，这对后续的矩阵计算是没有意义的值，但这些消耗了计算资源，所以提出了结构化稀疏的概念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5655253837072018&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibgUpY9lZGulBHOSVjNxPVWibCN9rD3VTbSM30dhHaOVS468TwcHQMsNQ/640?wx_fmt=png&quot; data-w=&quot;847&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5655253837072018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmib5undNlgZQ5weTXe9DdNTNicTrsW6wzv4oBoXU0W79vCPSmBa4iaSVpnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;847&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在模型的量化中，英伟达在工程化部署里，使用 TensorRT。考虑到模型训练有不同的框架训练，但是应用场景需要把它部署在不同的硬件设备上，这些硬件设备对应的就是英伟达不同的 GPU。TensorRT 会在相应的 GPU 上找到一种最快的实现，找到算子最优的运算方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibIaLa0pGht4miciaNCEqyYibDvQGC2KGfloVvg4KBx1qfJkgQavBOibovPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在模型路径推理中，正常训练是常使用 FP32 精度，而混合训练使用的是 FP16+FP32。现在随着量化技术的发展，TensorRT已支持 QAT（量化感知训练），即在模型里面插一些 Q/DQ （量化/反量化）节点，让模型在训练的时候就知道这个模型后面是要为量化服务的，它能比较好的恢复量化带来的精度损失。同时在 TensorRT 里面还做一些 Q/DQ 节点的优化，让 Q 和 DQ 分别做不同的前移或者后移，保证整个计算图大部分都运行在 INT8 的精度。&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>940e34cc825342fe77f340069c1308fd</guid>
<title>[译] 在嵌入式系统中运行 eBPF</title>
<link>https://toutiao.io/k/rby5frf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;作者：Adrian Ratiu&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;译者：狄卫华&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;注：本文已取得作者本人的翻译授权！&lt;/p&gt;&lt;p&gt;原文链接：https://www.collabora.com/news-and-blog/blog/2019/05/06/an-ebpf-overview-part-4-working-with-embedded-systems/&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本系列的&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NTU0MzEyMg==&amp;amp;mid=2247493590&amp;amp;idx=1&amp;amp;sn=69f5272cc486fc0f72d84da01fabbe7d&amp;amp;chksm=cfa5fe6bf8d2777dfe1b208fa55e1603e28896878f84c5458df6281988985f8d081b823a7b15&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第 1 部分&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;第 1 部分&lt;/span&gt;&lt;/a&gt;和&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NTU0MzEyMg==&amp;amp;mid=2247493681&amp;amp;idx=1&amp;amp;sn=497f67295144231d9ba3d3c53260328d&amp;amp;chksm=cfa5f18cf8d2789a7188f2f83cca93ced881b6cc04cd3f9ad53de7775b726b79fa594af2817b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第 2 部分&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;第 2 部分&lt;/span&gt;&lt;/a&gt;，我们介绍了 eBPF 虚拟机内部工作原理，在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NTU0MzEyMg==&amp;amp;mid=2247494118&amp;amp;idx=1&amp;amp;sn=0f48c98e52834660e460c4040fd7148b&amp;amp;chksm=cfa5f05bf8d2794d78418cda5568c26a3e0dce8a9ca16c691acd0037e2f17dd35bc6c85ac7b8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第 3 部分&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;第 3 部分&lt;/span&gt;&lt;/a&gt;我们研究了基于底层虚拟机机制之上开发和使用 eBPF 程序的主流方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这一部分中，我们将从另外一个视角来分析项目，尝试解决嵌入式 Linux 系统所面临的一些独特的问题：如需要非常小的自定义操作系统镜像，不能容纳完整的 BCC LLVM 工具链/python 安装，或试图避免同时维护主机的交叉编译（本地）工具链和交叉编译的目标编译器工具链，以及其相关的构建逻辑，即使在使用像 OpenEmbedded/Yocto 这样的高级构建系统时也很重要。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 关于可移植性&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NTU0MzEyMg==&amp;amp;mid=2247494118&amp;amp;idx=1&amp;amp;sn=0f48c98e52834660e460c4040fd7148b&amp;amp;chksm=cfa5f05bf8d2794d78418cda5568c26a3e0dce8a9ca16c691acd0037e2f17dd35bc6c85ac7b8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第 3 部分&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;第 3 部分&lt;/span&gt;&lt;/a&gt;研究的运行 eBPF/BCC 程序的主流方式中，可移植性并不是像在嵌入式设备上面临的问题那么大：eBPF 程序是在被加载的同一台机器上编译的，使用已经运行的内核，而且头文件很容易通过发行包管理器获得。嵌入式系统通常运行不同的 Linux 发行版和不同的处理器架构，与开发人员的计算机相比，有时具有重度修改或上游分歧的内核，在构建配置上也有很大的差异，或还可能使用了只有二进制的模块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;eBPF 虚拟机的字节码是通用的（并未与特定机器相关），所以一旦编译好 eBPF 字节码，将其从 x86_64 移动到 ARM 设备上并不会引起太多问题。当字节码探测内核函数和数据结构时，问题就开始了，这些函数和数据结构可能与目标设备的内核不同或者会不存在，所以至少目标设备的内核头文件必须存在于构建 eBPF 程序字节码的主机上。新的功能或 eBPF 指令也可能被添加到以后的内核中，这可以使 eBPF 字节码向前兼容，但不能在内核版本之间向后兼容（参见&lt;span&gt;内核版本与 eBPF 功能&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;）。建议将 eBPF 程序附加到稳定的内核 ABI 上，如跟踪点（tracepoint），这可以缓解常见的可移植性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近一个重要的工作已经开始，通过在 LLVM 生成的 eBPF 对象代码中嵌入数据类型信息，通过增加 BTF（BTF 类型格式）数据，以增加 eBPF 程序的可移植性（CO-RE 一次编译，到处运行）。更多信息见这里的&lt;span&gt;补丁&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;和&lt;span&gt;文章&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;。这很重要，因为 BTF 涉及到 eBPF 软件技术栈的所有部分（内核虚拟机和验证器、clang/LLVM 编译器、BCC 等），但这种方式可带来很大的便利，允许重复使用现有的 BCC 工具，而不需要特别的 eBPF 交叉编译和在嵌入式设备上安装 LLVM 或运行 BPFd。截至目前，CO-RE BTF 工作仍处于早期开发阶段，还需要付出相当多的工作才能可用【译者注：当前在高版本内核已经可以使用或者编译内核时启用了 BTF 编译选项】。也许我们会在其完全可用后再发表一篇博文。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. BPFd&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;BPFd&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;（项目地址 &lt;span&gt;👉&lt;/span&gt;https://github.com/joelagnel/bpfd）更像是一个为 Android 设备开发的概念验证，后被放弃，转而通过 &lt;span&gt;adeb&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 包运行一个完整的设备上的 BCC 工具链【译者注：BCC 在 adeb 的编译文档参见&lt;span&gt;这里&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;】。如果一个设备足够强大，可以运行 Android 和 Java，那么它也可能可以安装 BCC/LLVM/python。尽管这个实现有些不完整（通信是通过 Android USB 调试桥或作为一个本地进程完成的，而不是通过一个通用的传输层），但这个设计很有趣，有足够时间和资源的人可以把它拿起来合并，继续搁置的 &lt;span&gt;PR 工作&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简而言之，BPFd 是一个运行在嵌入式设备上的守护程序，作为本地内核/libbpf 的一个远程过程调用（RPC）接口。Python 在主机上运行，调用 BCC 来编译/部署 eBPF 字节码，并通过 BPFd 创建/读取 map。BPFd 的主要优点是，所有的 BCC 基础设施和脚本都可以工作，而不需要在目标设备上安装 BCC、LLVM 或 python，BPFd 二进制文件只有 100kb 左右的大小，并依赖 libc。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;102&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.17647058823529413&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/u5Pibv7AcsEUeica6doRh2mEQA4DWhOruAsMHkxosSoickkhWfxHbuJGWhSjv9EUTIlBhemQBIHfh7pdcSOUiajA7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Ply&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ply&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt; 项目实现了一种与 BPFtrace 非常相似的高级领域特定语言（受到 AWK 和 C 的启发），其明确的目的是将运行时的依赖性降到最低。它只依赖于一个现代的 libc（不一定是 GNU 的 libc）和 shell（与 sh 兼容）。Ply 本身实现了一个 eBPF 编译器，需要根据目标设备的内核头文件进行构建，然后作为一个单一的二进制库和 shell 包装器部署到目标设备上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;104&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.18030690537084398&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/u5Pibv7AcsEUeica6doRh2mEQA4DWhOruAlyoU5JxUhiaziaGw4dqJoHu2Ltf5P1HcDRIYYIDCl0OPgQBVffy6RDnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好解释 ply，我们把第 3 部分中的 BPFtrace 例子和与 ply 实现进行对比：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;BPFtrace：要运行该例子，你需要数百 MB 的 LLVM/clang、libelf 和其他依赖项：&lt;/p&gt;&lt;p&gt;&lt;code&gt;bpftrace -e &#x27;tracepoint:raw_syscalls:sys_enter {@[pid, comm] = count();}&#x27;&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ply：你只需要一个 ~50kb 的二进制文件，它产生的结果是相同的，语法几乎相同：&lt;/p&gt;&lt;p&gt;&lt;code&gt;ply &#x27;tracepoint:raw_syscalls/sys_enter {@[pid, comm] = count();}&#x27;&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Ply 仍在大量开发中（最近的 v2.0 版本是完全重写的）【译者注：当前最新版本为 2.1.1，最近一次代码提交是 8 个月前，活跃度一般】，除了一些示例之外，该语言还不不稳定或缺乏文档，它不如完整的 BCC 强大，也没有 BPFtrace 丰富的功能特性，但它对于通过 ssh 或串行控制台快速调试远程嵌入式设备仍然非常有用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. Gobpf&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Gobpf&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt; 及其合并的子项目（goebpf, gobpf-elf-loader），是 IOVisor 项目的一部分，为 BCC 提供 Golang 语言绑定。eBPF 的内核逻辑仍然用 &quot;限制性 C&quot; 编写，并由 LLVM 编译，只有标准的 python/lua 用户空间脚本被 Go 取代。这个项目对嵌入式设备的意义在于它的 eBPF &lt;span&gt;elf 加载模块&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;，其可以被交叉编译并在嵌入式设备上独立运行，以加载 eBPF 程序至内核并与与之交互。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;121&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.20971867007672634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/u5Pibv7AcsEUeica6doRh2mEQA4DWhOruAtkAfY0QXls6cJpicLBYKOTkTmJia6b3rMpKibneJgyBm7qVTCBMqhUMEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，go 加载器可以被写成通用的（我们很快就会看到），因此它可以加载和运行任何 eBPF 字节码，并在本地重新用于多个不同的跟踪会话。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 gobpf 很痛苦的，主要是因为缺乏文档。目前最好的 &quot;文档&quot; 是 &lt;span&gt;tcptracer 源码&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;，它相当复杂（他们使用 kprobes 而不依赖于特定的内核版本！），但从它可以学到很多。Gobpf 本身也是一项正在进行的工作：虽然 elf 加载器相当完整，并支持加载带有套接字、(k|u)probes、tracepoints、perf 事件等加载的 eBPF ELF 对象，但 bcc go 绑定模块还不容易支持所有这些功能。例如，尽管你可以写一个 socket_ilter ebpf 程序，将其编译并加载到内核中，但你仍然不能像 BCC 的 python 那样从 go 用户空间轻松地与 eBPF 进行交互，BCC 的 API 更加成熟和用户友好。无论如何，gobpf 仍然比其他具有类似目标的项目处于更好的状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们研究一个简单的例子来说明 gobpf 如何工作的。首先，我们将在本地 x86_64 机器上运行它，然后交叉编译并在 32 位 ARMv7 板上运行它，比如流行的 Beaglebone 或 Raspberry Pi。我们的文件目录结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ find . -&lt;span&gt;type&lt;/span&gt; f&lt;br/&gt;./src/open-example.go&lt;br/&gt;./src/open-example.c&lt;br/&gt;./Makefile&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;open-example.go&lt;/strong&gt;：这是建立在 gobpf/elf 之上的 eBPF ELF 加载器。它把编译好的 &quot;限制性 C&quot; ELF 对象作为参数，加载到内核并运行，直到加载器进程被杀死，这时内核会自动卸载 eBPF 逻辑【译者注：通常情况是这样的，也有场景加载器退出，ebpf 程序继续运行的】。我们有意保持加载器的简单性和通用性（它加载在对象文件中发现的任何探针），因此加载器可以被重复使用。更复杂的逻辑可以通过使用 &lt;span&gt;gobpf 绑定&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt; 模块添加到这里。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os/signal&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;github.com/iovisor/gobpf/elf&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {mod := elf.NewModule(os.Args[&lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;&lt;br/&gt;    err := mod.Load(&lt;span&gt;nil&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {fmt.Fprintf(os.Stderr, &lt;span&gt;&quot;Error loading&#x27;%s&#x27;ebpf object: %v\n&quot;&lt;/span&gt;, os.Args[&lt;span&gt;1&lt;/span&gt;], err)os.Exit(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    err = mod.EnableKprobes(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {fmt.Fprintf(os.Stderr, &lt;span&gt;&quot;Error loading kprobes: %v\n&quot;&lt;/span&gt;, err)&lt;br/&gt;        os.Exit(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    sig := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; os.Signal, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    signal.Notify(sig, os.Interrupt, os.Kill)&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;open-example.c&lt;/strong&gt;：这是上述加载器加载至内核的 &quot;限制性 C&quot; 源代码。它挂载在 do_sys_open 函数，并根据 &lt;span&gt;ftrace format&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt; 将进程命令、PID、CPU、打开文件名和时间戳打印到跟踪环形缓冲区，（详见 &quot;输出格式&quot; 一节）。打开的文件名作为 &lt;span&gt;do_sys_open call&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt; 的第二个参数传递，可以从代表函数入口的 CPU 寄存器的上下文结构中访问。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;uapi/linux/bpf.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;uapi/linux/ptrace.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;bpf/bpf_helpers.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;SEC(&lt;span&gt;&quot;kprobe/do_sys_open&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;kprobe__do_sys_open&lt;/span&gt;&lt;span&gt;(struct pt_regs *ctx)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;span&gt;char&lt;/span&gt; file_name[&lt;span&gt;256&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;    bpf_probe_read(file_name, &lt;span&gt;sizeof&lt;/span&gt;(file_name), PT_REGS_PARM2(ctx));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; fmt[] = &lt;span&gt;&quot;file %s\n&quot;&lt;/span&gt;;&lt;br/&gt;    bpf_trace_printk(fmt, &lt;span&gt;sizeof&lt;/span&gt;(fmt), &amp;amp;file_name);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;char&lt;/span&gt; _license[] SEC(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) = &lt;span&gt;&quot;GPL&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;__u32 _version &lt;span&gt;SEC&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;version&quot;&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;= &lt;span&gt;0xFFFFFFFE&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的代码中，我们定义了特定的 &quot;SEC&quot; 区域，这样 gobpf 加载器就可获取到哪里查找或加载内容的信息。在我们的例子中，区域为 kprobe、license 和 version。特殊的 0xFFFFFFFE 值告诉加载器，这个 eBPF 程序与任何内核版本都是兼容的，因为打开系统调用而破坏用户空间的机会接近于 0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Makefile&lt;/strong&gt;：这是上述两个文件的构建逻辑。注意我们是如何在 include 路径中加入 &quot;arch/x86/...&quot; 的；在 ARM 上它将是 &quot;arch/arm/...&quot;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SHELL=/bin/bash -o pipefail&lt;br/&gt;LINUX_SRC_ROOT=&lt;span&gt;&quot;/home/adi/workspace/linux&quot;&lt;/span&gt;&lt;br/&gt;FILENAME=&lt;span&gt;&quot;open-example&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;ebpf-build: clean go-build&lt;/span&gt;&lt;br/&gt; clang \&lt;br/&gt; -D__KERNEL__ -fno-stack-protector -Wno-int-conversion \&lt;br/&gt; -O2 -emit-llvm -c &lt;span&gt;&quot;src/${FILENAME}.c&quot;&lt;/span&gt; \&lt;br/&gt; -I ${LINUX_SRC_ROOT}/&lt;span&gt;include&lt;/span&gt; \&lt;br/&gt; -I ${LINUX_SRC_ROOT}/tools/testing/selftests \&lt;br/&gt; -I ${LINUX_SRC_ROOT}/arch/x86/&lt;span&gt;include&lt;/span&gt; \&lt;br/&gt; -o - | llc -march=bpf -filetype=obj -o &lt;span&gt;&quot;${FILENAME}.o&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;go-build:&lt;/span&gt;&lt;br/&gt; go build -o ${FILENAME} src/${FILENAME}.go&lt;br/&gt;&lt;br/&gt;&lt;span&gt;clean:&lt;/span&gt;&lt;br/&gt; rm -f ${FILENAME}*&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上述 makefile 在当前目录下产生两个新文件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;open-example：这是编译后的 src/*.go 加载器。它只依赖于 libc 并且可以被复用来加载多个 eBPF ELF 文件运行多个跟踪。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;open-example.o：这是编译后的 eBPF 字节码，将在内核中加载。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“open-example&quot; 和 &quot;open-example.o&quot; ELF 二进制文件可以进一步合并成一个；加载器可以包括 eBPF 二进制文件作为资产，也可以像 &lt;span&gt;tcptracer&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt; 那样在其源代码中直接存储为字节数。然而，这超出了本文的范围。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行例子显示以下输出（见 [ftrace 文档](&amp;lt;(https://raw.githubusercontent.com/torvalds/linux/v4.20/Documentation/trace/ftrace.rst &quot;ftrace 文档&quot;)&amp;gt;) 中的 &quot;输出格式&quot; 部分）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# (./open-example open-example.o &amp;amp;) &amp;amp;&amp;amp; cat /sys/kernel/debug/tracing/trace_pipe&lt;/span&gt;&lt;br/&gt;electron-17494 [007] ...3 163158.937350: 0: file /proc/self/maps&lt;br/&gt;systemd-1      [005] ...3 163160.120796: 0: file /proc/29261/cgroup&lt;br/&gt;emacs-596      [006] ...3 163163.501746: 0: file /home/adi/&lt;br/&gt;(...)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;沿用我们在本系列的第 3 部分中定义的术语，我们的 eBPF 程序有以下部分组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;后端&lt;/strong&gt;：是 open-example.o ELF 对象。它将数据写入内核跟踪环形缓冲区。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;加载器&lt;/strong&gt;：这是编译过的 open-example 二进制文件，包含 gobpf/elf 加载器模块。只要它运行，数据就会被添加到跟踪缓冲区中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;前端&lt;/strong&gt;：这就是 &lt;code&gt;cat /sys/kernel/debug/tracing/trace_pipe&lt;/code&gt;。非常 UNIX 风格。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;数据结构&lt;/strong&gt;：内核跟踪环形缓冲区。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在将我们的例子交叉编译为 32 位 ARMv7。基于你的 ARM 设备运行的内核版本：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内核版本&amp;gt;=5.2：只需改变 makefile，就可以交叉编译与上述相同的源代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内核版本&amp;lt;5.2：除了使用新的 makefile 外，还需要将 PT_REGS_PARM* 宏从 &lt;span&gt;这个 patch&lt;/span&gt;&lt;sup&gt;[16]&lt;/sup&gt; 复制到 &quot;受限制 C&quot; 代码。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新的 makefile 告诉 LLVM/Clang，eBPF 字节码以 ARMv7 设备为目标，使用 32 位 eBPF 虚拟机子寄存器地址模式，以便虚拟机可以正确访问本地处理器提供的 32 位寻址内存（还记得第 2 部分中介绍的所有 eBPF 虚拟机寄存器默认为 64 位宽），设置适当的包含路径，然后指示 Go 编译器使用正确的交叉编译设置。在运行这个 makefile 之前，需要一个预先存在的交叉编译器工具链，它被指向 CC 变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SHELL=/bin/bash -o pipefail&lt;br/&gt;LINUX_SRC_ROOT=&lt;span&gt;&quot;/home/adi/workspace/linux&quot;&lt;/span&gt;&lt;br/&gt;FILENAME=&lt;span&gt;&quot;open-example&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;ebpf-build: clean go-build&lt;/span&gt;&lt;br/&gt; clang \&lt;br/&gt;  --target=armv7a-linux-gnueabihf \&lt;br/&gt;  -D__KERNEL__ -fno-stack-protector -Wno-int-conversion \&lt;br/&gt;  -O2 -emit-llvm -c &lt;span&gt;&quot;src/${FILENAME}.c&quot;&lt;/span&gt; \&lt;br/&gt;  -I ${LINUX_SRC_ROOT}/&lt;span&gt;include&lt;/span&gt; \&lt;br/&gt;  -I ${LINUX_SRC_ROOT}/tools/testing/selftests \&lt;br/&gt;  -I ${LINUX_SRC_ROOT}/arch/arm/&lt;span&gt;include&lt;/span&gt; \&lt;br/&gt;  -o - | llc -march=bpf -filetype=obj -o &lt;span&gt;&quot;${FILENAME}.o&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;go-build:&lt;/span&gt;&lt;br/&gt; GOOS=linux GOARCH=arm CGO_ENABLED=1 CC=arm-linux-gnueabihf-gcc \&lt;br/&gt; go build -o ${FILENAME} src/${FILENAME}.go&lt;br/&gt;&lt;br/&gt;&lt;span&gt;clean:&lt;/span&gt;&lt;br/&gt; rm -f ${FILENAME}*&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行新的 makefile，并验证产生的二进制文件已经被正确地交叉编译：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[adi@iwork]$ file open-example*&lt;br/&gt;open-example:   ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter (...), stripped&lt;br/&gt;open-example.o: ELF 64-bit LSB relocatable, *unknown arch 0xf7* version 1 (SYSV), not stripped&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后将加载器和字节码复制到设备上，与在 x86_64 主机上使用上述相同的命令来运行。记住，只要修改和重新编译 C eBPF 代码，加载器就可以重复使用，用于运行不同的跟踪。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@ionelpi adi]&lt;span&gt;# (./open-example open-example.o &amp;amp;) &amp;amp;&amp;amp; cat /sys/kernel/debug/tracing/trace_pipe&lt;/span&gt;&lt;br/&gt;ls-380     [001] d..2   203.410986: 0: file /etc/ld-musl-armhf.path&lt;br/&gt;ls-380     [001] d..2   203.411064: 0: file /usr/lib/libcap.so.2&lt;br/&gt;ls-380     [001] d..2   203.411922: 0: file /&lt;br/&gt;zcat-397   [002] d..2   432.676010: 0: file /etc/ld-musl-armhf.path&lt;br/&gt;zcat-397   [002] d..2   432.676237: 0: file /usr/lib/libtinfo.so.5&lt;br/&gt;zcat-397   [002] d..2   432.679431: 0: file /usr/bin/zcat&lt;br/&gt;gzip-397   [002] d..2   432.693428: 0: file /proc/&lt;br/&gt;gzip-397   [002] d..2   432.693633: 0: file config.gz&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于加载器和字节码加起来只有 2M 大小，这是一个在嵌入式设备上运行 eBPF 的相当好的方法，而不需要完全安装 BCC/LLVM。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本系列的第 4 部分，我们研究了可以用于在小型嵌入式设备上运行 eBPF 程序的相关项目。不幸的是，当前使用这些项目还是比较很困难的：它们有的被遗弃或缺乏人力，在早期开发时一切都在变化，或缺乏基本的文档，需要用户深入到源代码中并自己想办法解决。正如我们所看到的，gobpf 项目作为 BCC/python 的替代品是最有活力的，而 ply 也是一个有前途的 BPFtrace 替代品，其占用空间最小。随着更多的工作投入到这些项目中以降低使用者的门槛，eBPF 的强大功能可以用于资源受限的嵌入式设备，而无需移植/安装整个 BCC/LLVM/python/Hover 技术栈。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引用链接&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;内核版本与 eBPF 功能: &lt;em&gt;https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;补丁: &lt;em&gt;https://lwn.net/Articles/750695/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;文章: &lt;em&gt;https://lwn.net/Articles/773198/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;BPFd: &lt;em&gt;https://lwn.net/Articles/744522/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;adeb: &lt;em&gt;https://github.com/joelagnel/adeb&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;这里: &lt;em&gt;https://github.com/joelagnel/adeb/blob/master/BCC.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;PR 工作: &lt;em&gt;https://github.com/iovisor/bcc/pull/1675&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;ply: &lt;em&gt;https://wkz.github.io/ply/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Gobpf: &lt;em&gt;https://github.com/iovisor/gobpf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;elf 加载模块: &lt;em&gt;https://github.com/iovisor/gobpf/tree/master/elf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;tcptracer 源码: &lt;em&gt;https://github.com/weaveworks/tcptracer-bpf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;gobpf 绑定: &lt;em&gt;https://github.com/iovisor/gobpf/blob/master/bcc/module.go&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;ftrace format: &lt;em&gt;https://raw.githubusercontent.com/torvalds/linux/v4.20/Documentation/trace/ftrace.rst&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;do_sys_open call: &lt;em&gt;https://github.com/torvalds/linux/blob/v4.20/fs/open.c#L1048&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[15]&lt;/span&gt;&lt;p&gt;tcptracer: &lt;em&gt;https://github.com/weaveworks/tcptracer-bpf/blob/master/pkg/tracer/tcptracer-ebpf.go#L80&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[16]&lt;/span&gt;&lt;p&gt;这个 patch: &lt;em&gt;https://lore.kernel.org/bpf/20190304205019.15071-1-adrian.ratiu@collabora.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>