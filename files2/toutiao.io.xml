<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f6028e8ba849eb9de903657e10280d3a</guid>
<title>我很久没写代码了，但我是个好架构师</title>
<link>https://toutiao.io/k/gauwubg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章还是架构师大刘的故事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;故事之前先说个题外话，最近到了金三银四跳槽季，有不少读者问我一些简历、面试的问题，这些问题大部分在之前的一篇硬核文章里都写过，传送门在这里：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484503&amp;amp;idx=1&amp;amp;sn=c7a006ddd9acb1cb104128c7d8601eab&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;最全干货：从写简历，到面试、谈薪酬的那些技巧和防坑指南&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常全面的一篇程序员找工作的干货文章，基本涵盖了求职的整个流程，最难得的是除了经验，还有很多需要的坑。还没看过的读者，推荐看一下，肯定有帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;题外话结束，故事开始。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;俗子胸襟谁识我？英雄末路当磨折。莽红尘何处觅知音？青衫湿！&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作这首词的本是近代女英雄秋瑾。说的却是蔑视世俗、不畏挫折磨难的壮志雄心。此时，大刘却亦有戚戚然焉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大刘是个架构师，随着工作的日益繁忙，已经逐渐离开了在一线写代码的工作。但是在离开一线的时候，也不免听到了一些不和谐的声音。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;什么架构师不写底层代码，不知道还有何用……&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么架构师成天不写代码，以后肯定废了……&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些靡靡杂音不绝于耳，大刘难免就有了上面的情绪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构师无论从何角度来讲，本质就是一位技术专家。那些架构师们因为公司的发展和职责的扩充，有的离开了一线，有的尚未离开一线。但是，无论在不在一线，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;都不影响一位技术专家的核心价值。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有某些理论说，技术专家吃技术饭的，技术是个手艺活，几天不练就手生。但是这套理论和实际不一样的是，这套“手艺活理论”，并没有考虑现实里的公司对架构师本人的核心价值定位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以这样说，是因为“手艺活理论”，只定义了技术问题就是手艺活能解决的问题，认为技术问题都是靠写代码搞定的。这就跟产品经理告诉你“这个需求很简单”一样可笑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构师不写代码不会成为公司吃干饭的——要说明这个，首先得先说明下架构师的核心价值在哪里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些人糊里糊涂过日子，分不出来啥叫核心价值啥叫附属价值。刚入行，拿着还算可以的薪资，以为这就是他们一辈子的状态。素不知这其实就是个温柔乡，慢慢把人套牢，然后到了中年，一切轰然崩塌，那时候，后悔也晚了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;价值这东西，放在现在打工人身上，就是你能给公司带来多少利润。就拿技术举例，你给公司开发出个新产品，公司盈利了，你就体现了你的价值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更进一步，如果你给公司弄出了新的产品，公司预估时间为一个月，你半个月搞定了，给公司了个小 suprise，你不仅体现了你应有的价值，你还买一送一，给了公司一些小小的快乐，那么就创造出了更多的价值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以你给公司创造出了更大价值为前提，咱们看个公式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你实际创造的价值 = 你本来就应该给公司挣的钱 + 你优秀的能力让公司意外赚（省）的钱&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这个公式你就可以看出来了，价值这事儿得分成两个，一个是公司需要你为公司挣钱的价值，一个是你自己能力可能比同行优秀，多搞出来的价值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一部分就是核心价值。那个你比同行优秀或者公司让你搞产品，你不仅搞了产品，你还把地板给扫干净了的价值是一些附带的，是附属价值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OK，知道这事儿了，咱们就得嘀咕嘀咕架构师这事儿了。大刘郁闷在哪里？本来架构师开不开发代码，这事儿不是判断架构师够不够格的标准。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是呢，有些人可能从小土里刨食儿惯了，出来搞些码农的事情，觉得不敲代码了，就不配搞技术。手里拿着在 2.14 还亲密接触的键盘，在互联网上苟且的发表着一些阴阳怪气的意见，这就很让人不待见了，也很容易误导后来的年轻人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公司为什么需要架构师？鲁迅先生说过&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;公司里本来没有架构师，系统复杂了，也就有了架构师。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构师这岗位不是地里长出来的，是有需求创造出来的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到了吧，架构师的核心价值出来了：专门用来搞定公司复杂的系统的。当然，资本家的事儿能叫剥削吗？那叫帮你成长。为了帮助架构师的成长，所以架构师的责任链条又拉长了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从搞定一个复杂系统 -&amp;gt; 搞定所有的复杂系统 -&amp;gt; 搞定所有系统 -&amp;gt; 所有技术你都做主了吧&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，架构师也是拥有自己的血泪成长史的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，话题扯远了，说回来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公司需要搞出复杂的系统产品来运营，需要复杂的技术链条来运维，需要复杂的工具来加快产品开发速度……这些事儿，其实都是架构师要关心的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这些里面，编码就是其中一小部分工作，架构师忙不过来了，自然要放弃编码，去考虑别的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构师编码编的好，那是他高级程序员做的到位，但是这是所有技术工作中的很小的一部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如大刘编码做好了，上线无 Bug 了，但是精力没顾上整体技术架构，也没顾上整体的系统分析，比如&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;业务数据需要高可用还是高一致？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在线运营的系统运行了很久了，是不是要搞代码重构了？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为大刘深入了编码细节，疏忽了更重要的，出现了判断问题，那大刘的核心价值就被损害了。就算他写代码写的全程丝滑，但整体系统却没搞的到位，对公司来说就是损失，这个架构师就不合格。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在一些新入行的年轻人，一边编写着代码，一边被人灌输架构师必须写代码，不写代码，他就是伪架构师，这是完全的以偏概全。架构师其实挺难当的，上面说过，随着你干的活变化，很可能架构师一下子就把公司的技术活全捞来负责了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多有技术追求的人，他们很想当架构师，但是又不知道该怎么学习。根据大刘自己的经验，你得先培养自己的三种能力：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1. 快速分析问题的能力&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为架构师有一个很重要的工作，就是负责解决公司的系统问题，很多系统的问题其实解决不难，但是定位非常困难，所以，定位问题能力就需要有意识的训练。定位问题的能力需要能快速梳理整体流程，然后准确的找到流程中断的地方，那个地方很可能就是问题点。当然，多见识各种系统问题也是必须的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2. 快速学习的能力&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构师其实负责的工作很杂，几乎任何技术工作，你都能扯上架构师。架构师就是技术工作的主负责人的各种备胎。但是，架构师也是人，他也不是万事通。为了能完成这些备胎工作，架构师就得能够快速学习，对一些新鲜领域能快速技术调研给出结论，对一些不熟悉的技术领域能快速的深入学习然后找到瓶颈并解决。而且，平时也得多关注技术领域，持久化，快速化的不断学习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3. 快速资源调配的能力&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;快速资源调配的能力则是因为很可能运维、开发、测试他们面临了一些技术问题，需要这些人一起配合搞清楚。比如网络问题，很可能运维、开发、测试都是互相埋怨甩锅，这时候，就需要架构师们快速确定问题，调配人员，看如何把存在的技术问题给干掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看，上面哪个都不是干写代码可以搞定的事情，所以，架构师这事儿，真的不能光看什么写代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构师嘛，不写代码不寒碜，写代码不是一切。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是四猿外。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一家上市公司的技术总监，管理的技术团队一百余人。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我从一名非计算机专业的毕业生，转行到程序员，一路打拼，一路成长。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我会通过公众号，&lt;br/&gt;把自己的成长故事写成文章，&lt;br/&gt;把枯燥的技术文章写成故事。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我建了一个读者交流群，里面大部分是程序员，一起聊技术、工作、八卦。欢迎加我微信，拉你入群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9852216748768473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KQibCDibpTo0kqofPehQvDDibibcb3bQUELdY3Knsl4r0RcgsV9l4icr3icmZQfaBXtSFNTxmdQlAZT1OQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247485172&amp;amp;idx=1&amp;amp;sn=7cd1bc6dc224969d8e5f8449ba480e64&amp;amp;chksm=fcd8cab5cbaf43a3f362b3a5f4fbeb8f201fb23399deb0344dcfd23278d63bd2ad8c915058c3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;我，第一次做项目经理，干赔了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247485152&amp;amp;idx=1&amp;amp;sn=65d8fd3ce30714917dca3605428ae9c1&amp;amp;chksm=fcd8caa1cbaf43b7b7c3b4579f5eabc1a64b0bd837b42925d1594de1746913469b4a852cb0b2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;大刘跌倒，老田吃饱——首席架构师之争&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247485134&amp;amp;idx=1&amp;amp;sn=f8c35fd83d5290e8aabf66f219ab518f&amp;amp;chksm=fcd8ca8fcbaf439945fb0dad200f948763329c8817b60af2fce333ae5e15bbd6381d265e6987&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;你们要的学Java的练手项目，来了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247485048&amp;amp;idx=1&amp;amp;sn=53f8475521377094101aa11a6054f9d8&amp;amp;chksm=fcd8ca39cbaf432f26d8826f3a14461a2c09c1908f9bf10ea700125d9073d616376fd0f90354&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;在主动要求涨工资这事上，不要学我！&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>eb1927a032510fa2f0e902327187cdfc</guid>
<title>JVM 集合之类加载子系统</title>
<link>https://toutiao.io/k/ibt6mlt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;181&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.32344763670064874&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpOjRJj3rEmVIcZ4cxnPGXMbOToA3HQiafTrfmjfvOVQH0fLtCJwj3DkfC1GoPIRVmLY5oTemAhXibRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;阅读本文大概需要 7.2 分钟。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上篇文章中我们知道了&lt;code&gt;JVM&lt;/code&gt;是个啥？这篇文章（通篇文章都是以&lt;code&gt;HotSpot JVM&lt;/code&gt;为例）就让我们来了解一下类加载子系统（&lt;code&gt;ClassLoader&lt;/code&gt;）--负责从文件系统或者网络中加载&lt;code&gt;Class&lt;/code&gt;字节码文件，并将加载的类信息（DNA元数据模版，jvm会根据这个模版实例化出n个一模一样的实例）存放于“方法区”(接下来的文章中会做具体的介绍)中。&lt;code&gt;ClassLoader&lt;/code&gt;只负责文件的加载，而文件是否可以运行，则由执行引擎（&lt;code&gt;Exection Engine&lt;/code&gt;，接下来的文章中会做具体的介绍）决定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图是类加载子系统构造图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5204582651391162&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNu6satnH8CvfG0vNTyzNnCygSOHVr6Exia2Pj1S7fibic6iadhHlAl9tcCcOREUD2rNnOibQrP1qNmLyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;611&quot;/&gt;&lt;figcaption&gt;类加载子系统&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类的加载过程&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6880570409982175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNu6satnH8CvfG0vNTyzNnC3d5iazHoI0JlwM9gG0r8q2piblAe6m4aibTo3J5UmIic02ZicLebj1ZBhUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;561&quot;/&gt;&lt;figcaption&gt;类加载过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;加载（Loading）&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;加载流程&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过一个类的全限定名获取定义此类的二进制字节流；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在内存中生成一个代表这个类的&lt;code&gt;java.lang.Class&lt;/code&gt;对象，作为方法区这个类的各种数据的访问入口。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;加载&lt;code&gt;.class&lt;/code&gt;文件的方式&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从本地系统中直接加载；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过网络获取，典型场景：&lt;code&gt;Web Applet&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从zip压缩包中读取，成为日后&lt;code&gt;jar&lt;/code&gt;、&lt;code&gt;war&lt;/code&gt;格式的基础；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行时计算生成，使用最多的是：动态代理技术；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由其他文件生成，典型场景：&lt;code&gt;jsp&lt;/code&gt;应用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从专有数据库中提取&lt;code&gt;.class&lt;/code&gt;文件，比较少见；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从加密文件中读取，典型的防&lt;code&gt;Class&lt;/code&gt;文件被反编译的保护措施。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;链接（Linking）&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）验证（Verify）&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;目的是保证&lt;code&gt;Class&lt;/code&gt;文件的字节流中包含的信息符合当前虚拟机的要求，保证被加载类的正确性，不会危害虚拟机的自身安全。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主要分为四种验证方式：文件格式验证、元数据验证、字节码验证、符号引用验证。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件格式验证：主要验证字节流是否符合Class文件格式规范，并且能被当前的虚拟机加载处理。例如：主、次版本号是否在当前虚拟机处理的范围之内。常量池中是否有不被支持的常量类型。指向常量的中的索引值是否存在不存在的常量或不符合类型的常量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;元数据验证：对字节码描述的信息进行语义的分析，分析是否符合java的语言语法的规范。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字节码验证：最重要的验证环节，分析数据流和控制，确定语义是合法的，符合逻辑的。主要的针对元数据验证后对方法体的验证。保证类方法在运行时不会有危害出现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;符号引用验证：主要是针对符号引用转换为直接引用的时候，是会延伸到第三解析阶段，主要去确定访问类型等涉及到引用的情况，主要是要保证引用一定会被访问到，不会出现类等无法访问的问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;&lt;code&gt;java&lt;/code&gt;虚拟机字节码文件起始编码CAFEBABE（使用&lt;code&gt;Binary Viewer&lt;/code&gt;软件）&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）准备（Prepare）&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为类变量（静态变量）分配内存并且设置该类变量的默认初始值，即零值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public class HelloWord{&lt;br/&gt;  //准备阶段：a=0 -&amp;gt; 初始化阶段：a=1&lt;br/&gt;  private static int a = 1;&lt;br/&gt;  &lt;br/&gt;  public static void &lt;span&gt;main&lt;/span&gt;(){&lt;br/&gt;    System.out.println(a);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这里不包含&lt;code&gt;final&lt;/code&gt;修饰的&lt;code&gt;static&lt;/code&gt;，因为&lt;code&gt;final&lt;/code&gt;在编译的时候就会分配了，准备阶段会显示初始化；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这里不会为实例变量（new的对象）分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到&lt;code&gt;java&lt;/code&gt;堆中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）解析（Resolve）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将常量池内的符号引用（符号引用就是一组符号来描述所引用的目标）转换为直接引用（直接引用就是直接指向目标的指针、相对偏移量或一个简洁定位到目标的句柄）的过程。事实上，解析操作往往会伴随着&lt;code&gt;JVM&lt;/code&gt;在执行完初始化之后再执行。解析动作主要针对类或接口、字段、类方法、方法类型等。对应常量池中的&lt;code&gt;CONSTANT_Class_info&lt;/code&gt;、&lt;code&gt;CONSTANT_Fieldref_info&lt;/code&gt;、&lt;code&gt;CONSTANT_Methodref_info&lt;/code&gt;等。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;解析的执行过程等后边讲到字节码文件时再做具体解释。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;初始化（Initialization）&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始化阶段就是执行类构造器方法 &lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;的过程。此方法不需要定义，是&lt;code&gt;javac&lt;/code&gt;编译器自动收集类中的所有&lt;code&gt;类变量&lt;/code&gt;的赋值动作和&lt;code&gt;静态代码块&lt;/code&gt;中的语句合并而来。构造器方法中的指令按语句在源文件中出现的顺序执行。&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;不同于类的构造器，构造器是虚拟机视角下的&lt;code&gt;&amp;lt;init&amp;gt;()&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若该类具有父类，JVM会保证子类的&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;执行前，父类的&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;已经执行完毕。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虚拟机必须保证一个类的&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法在多线程下被同步加锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;样例：&lt;/strong&gt;&lt;img data-ratio=&quot;0.44201680672268906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNu6satnH8CvfG0vNTyzNnCFxIC0XibbKlSxAOVa3GZez0TIjmoibq3saAOVastBicano52a5rkZrrMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1785&quot;/&gt;字节码阅读器插件&lt;img data-ratio=&quot;0.29245283018867924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNu6satnH8CvfG0vNTyzNnC1k6aAkjicFEcGv4PJiaJXG9BoPoGWwhfp4yRLf2wkuGERSwibdTYbTaDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在未定义前进行调用会导致“非法前向引用”错误&lt;img data-ratio=&quot;0.8649386084583902&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNu6satnH8CvfG0vNTyzNnCgMUCDwOwZ867Rt00mAZJZ3yu8FiaQ7iaGA1bhFDBibMHlyeNhic3vO2w9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;733&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;类的初始化时机&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java程序对类的使用方式可以分为两种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1. 主动使用&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建类的实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;访问某个类或接口的静态变量，或者对该静态变量赋值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用类的静态方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;反射&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初始化一个类的子类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java虚拟机启动被标明为启动类的类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JDK 7 开始提供的动态语言支持：&lt;code&gt;java.lang.invoke.MethodHandle&lt;/code&gt;实例的解析结果，&lt;code&gt;REF_getStatic&lt;/code&gt;、&lt;code&gt;REF_putStatic&lt;/code&gt;、&lt;code&gt;REF_invokeStatic&lt;/code&gt;句柄对应的类没有初始化，则初始化。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2. 被动使用&lt;/strong&gt;：除了以上七种情况，其他都被看作是类的被动使用，都不会导致类的初始化。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类的加载器&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;加载器分类&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM支持两种类型的类加载器，分别为引导类加载器（&lt;code&gt;Bootstrap ClassLoader&lt;/code&gt;）和自定义加载器（&lt;code&gt;User-Defined ClassLoader&lt;/code&gt;），他们之间不是继承关系，而是包含关系。&lt;img data-ratio=&quot;0.5049614112458655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNu6satnH8CvfG0vNTyzNnCN9NK9kHVT9yFQasq4UpPAvpyrToc0IaciaP9pqkjNiaOMrCHxLte9T2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;引导类加载器&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引导类加载器又称为启动类加载器，该类是使用&lt;code&gt;C/C++&lt;/code&gt;语言实现的，嵌套在&lt;code&gt;JVM&lt;/code&gt;内部。它用来加载&lt;code&gt;Java&lt;/code&gt;的核心类库（&lt;code&gt;JAVA_HOME/jre/lib/rt.jar&lt;/code&gt;、&lt;code&gt;resources.jar&lt;/code&gt;或&lt;code&gt;sun.boot.class.path&lt;/code&gt;路径下的内容），用于提供&lt;code&gt;jvm&lt;/code&gt;自身需要的类，出于安全考虑，&lt;code&gt;Bootstrap&lt;/code&gt;启动类只加载包名为&lt;code&gt;java&lt;/code&gt;、&lt;code&gt;javax&lt;/code&gt;、&lt;code&gt;sun&lt;/code&gt;等开头的类。它并不继承自&lt;code&gt;java.lang.ClassLoader&lt;/code&gt;，没有父加载器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//String属于java的核心类库---&amp;gt;使用引导类加载器进行加载&lt;/span&gt;&lt;br/&gt;ClassLoader classLoader1 = String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getClassLoader&lt;/span&gt;()&lt;/span&gt;;&lt;br/&gt;System.out.println(classLoader1);&lt;span&gt;//null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;自定义加载器&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自定义加载器是指所有派生于抽象类&lt;code&gt;CLassLoader&lt;/code&gt;的类加载器，它分为扩展类加载器、应用程序（系统）加载器、用户自定义加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）扩展类加载器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java语言编写，由&lt;code&gt;sun.misc.Launcher.ExtClassLoader&lt;/code&gt;实现。其父类加载器为启动类加载器，从&lt;code&gt;java.ext.dirs&lt;/code&gt;系统属性所指定的目录中加载类库，或从&lt;code&gt;jdk&lt;/code&gt;的安装目录的&lt;code&gt;jre/lib/ext&lt;/code&gt;子目录（扩展目录）下加载类库。如果用户创建的&lt;code&gt;jar&lt;/code&gt;放在此目录下，也会自动由扩展类加载器加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）系统加载器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java语言编写，由&lt;code&gt;sun.misc.Launcher.AppClassLoader&lt;/code&gt;实现。父类加载器为扩展类加载器，负责加载环境变量&lt;code&gt;classpath&lt;/code&gt;或系统属性，&lt;code&gt;java.class.path&lt;/code&gt;指定路径下的类库。该类加载是程序中默认的类加载器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//获取系统类加载器&lt;/span&gt;&lt;br/&gt;ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();&lt;br/&gt;System.out.println(systemClassLoader);&lt;span&gt;//sun.misc.Launcher$AppClassLoader@18b4aac2&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//获取其上层：扩展类加载器&lt;/span&gt;&lt;br/&gt;ClassLoader extClassLoader = systemClassLoader.getParent();&lt;br/&gt;System.out.println(extClassLoader);&lt;span&gt;//sun.misc.Launcher$ExtClassLoader@4554617c&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//获取引导类加载器&lt;/span&gt;&lt;br/&gt;ClassLoader bootstrapClassLoader = extClassLoader.getParent();&lt;br/&gt;System.out.println(bootstrapClassLoader);&lt;span&gt;//null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）用户自定义加载器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发人员可以通过继承抽象类&lt;code&gt;java.lang.ClassLoader&lt;/code&gt;，并实现&lt;code&gt;findClass()&lt;/code&gt;方法来实现自定义类加载器。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承&lt;code&gt;URLClassLoader&lt;/code&gt;类，这样就可以避免自己去编写&lt;code&gt;findClass()&lt;/code&gt;方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;//用户自定义类：默认使用系统类加载器进行加载&lt;/span&gt;&lt;br/&gt;ClassLoader classLoader = ClassLoaderTest&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getClassLoader&lt;/span&gt;()&lt;/span&gt;;&lt;br/&gt;System.out.println(classLoader);&lt;span&gt;//sun.misc.Launcher$AppClassLoader@18b4aac2&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要自定义加载器？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;隔离加载类；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改类加载方式；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩展加载源；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;防止源码泄漏；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;ClassLoader的获取与API&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;获取&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取当前类的&lt;code&gt;ClassLoader&lt;/code&gt;：&lt;code&gt;clazz.getClassLoader()&lt;/code&gt;;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取当前线程上下文的&lt;code&gt;ClassLoader&lt;/code&gt;：&lt;code&gt;Thread.currentThread().getContextClassLoader()&lt;/code&gt;;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取系统的&lt;code&gt;ClassLoader&lt;/code&gt;：&lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt;;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取调用者的&lt;code&gt;ClassLoader&lt;/code&gt;：&lt;code&gt;DriverManager.getCallerClassLoader()&lt;/code&gt;;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Class loadClass(String name) ：name参数指定类装载器需要装载类的名字，必须使用全限定类名，如：&lt;code&gt;com.smart.bean.Car&lt;/code&gt;。该方法有一个重载方法 &lt;code&gt;loadClass(String name,boolean resolve)``，&lt;/code&gt;resolve`参数告诉类装载时候需要解析该类，在初始化之前，因考虑进行类解析的工作，但并不是所有的类都需要解析。如果JVM只需要知道该类是否存在或找出该类的超类，那么就不需要进行解析。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Class defineClass(String name,byte[] b,int len)：将类文件的字节数组转换成JVM内部的&lt;code&gt;java.lang.Class&lt;/code&gt;对象。字节数组可以从本地文件系统、远程网络获取。参数name为字节数组对应的全限定类名。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Class findSystemClass(String name)：从本地文件系统加载&lt;code&gt;Class&lt;/code&gt;文件。如果本地系统不存在该&lt;code&gt;Class&lt;/code&gt;文件。则抛出&lt;code&gt;ClassNotFoundException&lt;/code&gt;异常。该方法是JVM默认使用的装载机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Class findLoadedClass(String name)：调用该方法来查看&lt;code&gt;ClassLoader&lt;/code&gt;是否已载入某个类。如果已载入，那么返回&lt;code&gt;java.lang.Class&lt;/code&gt;对象；否则返回&lt;code&gt;null&lt;/code&gt;。如果强行装载某个已存在的类，那么则抛出链接错误。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ClassLoader getParent()：获取类装载器的父装载器。除根装载器外，所有的类装载器都有且仅有一个父装载器。&lt;code&gt;ExtClassLoader&lt;/code&gt;的父装载器是根装载器，因为根装载器非&lt;code&gt;java&lt;/code&gt;语言编写，所以无法获取，将返回&lt;code&gt;null&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派机制&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Java&lt;/code&gt;虚拟机对&lt;code&gt;class&lt;/code&gt;文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的&lt;code&gt;class&lt;/code&gt;文件加载到内存生成&lt;code&gt;class&lt;/code&gt;对象。而且加载某个类的&lt;code&gt;class&lt;/code&gt;文件时，&lt;code&gt;Java&lt;/code&gt;虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;工作原理&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6753507014028056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNu6satnH8CvfG0vNTyzNnCzkEwDy1oTzGIA0ew9AzgGbK19K3eKiakZCPzbIdSba0CGynbgc7koWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;499&quot;/&gt;&lt;figcaption&gt;双亲委派原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行。如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器。如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;优势&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;避免类的重复加载，当父亲已经加载了该类时，就没有必要子&lt;code&gt;ClassLoader&lt;/code&gt;再加载一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保护程序安全，防止核心API被随意篡改。举例代码截图如下&lt;img data-ratio=&quot;0.5295404814004376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNu6satnH8CvfG0vNTyzNnCribEbyxjgts8icQS5UcSOTZy4CwqQeuOQclmHJdHnBicgcMB8LCicg5XgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1371&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示，我们创建&lt;code&gt;java.lang.String&lt;/code&gt;类，当在加载自定义类的时候会先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载&lt;code&gt;jdk&lt;/code&gt;自带的文件（&lt;code&gt;rt.jar&lt;/code&gt;包中的&lt;code&gt;java/lang/String.class&lt;/code&gt;）。报错信息说没有&lt;code&gt;main&lt;/code&gt;方法，就是因为加载的是&lt;code&gt;rt.jar&lt;/code&gt;包下的&lt;code&gt;String&lt;/code&gt;类。这样我们就能保证对&lt;code&gt;java&lt;/code&gt;的核心源代码进行保护，这就是&lt;strong&gt;沙箱安全机制&lt;/strong&gt;。由此可知&lt;code&gt;JVM&lt;/code&gt;中判断两个&lt;code&gt;Class&lt;/code&gt;对象是否是同一个类存在两个必要条件：一是类的完整类名必须保持一致，包括包名；二是加载该类的类加载器必须相同。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;对类加载器的引用&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;JVM&lt;/code&gt;必须知道一个类是由启动类加载器还是用户类加载器加载的，如果一个类是由用户类加载器加载的，那么&lt;code&gt;jvm&lt;/code&gt;会将这个类加载器的一个引用作为类信息的一部分保存到方法区中，当解析一个类到另一个类的引用的时候，&lt;code&gt;jvm&lt;/code&gt;需要保证两个类的类加载器是相同的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;类加载器部分的内容就说到这里了，下篇我们将聊一下运行时数据区，如果你感兴趣的话，可以关注微信公众号“阿Q说”！你也可以后台留言说出你的疑惑，阿Q将会在后期的文章中为你解答。&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;内容推荐&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0040322580645162&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPT7S5RYgFtCUAsTef19QwUcef3OposVMvMTicibTxGu35MiadwnDqqicK9CXgx7hG4nNxoDTY8Ql4BBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;496&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>322d6bff8e7e0636df6267a1dcc1ee7e</guid>
<title>Spring Boot 集成 Kafka</title>
<link>https://toutiao.io/k/bd6mhey</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心、分布式配置等常用开源组件，大概有几十篇文章，陆续会开放出来，感兴趣同学请提前关注&amp;amp;收藏&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息通信有两种基本模型，即发布-订阅（Pub-Sub）模型和点对点（Point to Point）模型，发布-订阅支持生产者消费者之间的一对多关系，而点对点模型中有且仅有一个消费者。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka高效地处理实时流式数据，可以实现与Storm、HBase和Spark的集成。作为聚类部署到多台服务器上，Kafka处理它所有的发布和订阅消息系统使用了四个API，即生产者API、消费者API、Stream API和Connector API。它能够传递大规模流式消息，自带容错功能，已经取代了一些传统消息系统，如JMS、AMQP等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么使用kafka？&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;削峰填谷。缓冲上下游瞬时突发流量，保护 “脆弱” 的下游系统不被压垮，避免引发全链路服务 “雪崩”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统解耦。发送方和接收方的松耦合，一定程度简化了开发成本，减少了系统间不必要的直接依赖。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步通信：消息队列允许用户把消息放入队列但不立即处理它。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可恢复性：即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI5NDAwMzM0MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/3Ohm6WHibeXJY3p8ibo9XeCic0sLhnu7GGMo7TiacVcs0wM8dKUzwjjsX9CVPLTZqZsVNgWCWgjTiaFhZ2elNs9RB8Q/0?wx_fmt=png&quot; data-nickname=&quot;微观技术&quot; data-alias=&quot;weiguanjishu&quot; data-signature=&quot;业务架构、职业规划、源码解读等，畅想技术改变人生&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;业务场景&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一些同步业务流程的非核心逻辑，对时间要求不是特别高，可以解耦异步来执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统日志收集，采集并同步到kafka，一般采用ELK组合玩法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一些大数据平台，用于各个系统间数据传递&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基本架构&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 运行在一个由一台或多台服务器组成的集群上，并且分区可以跨集群节点分布&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、Producer 生产消息，发送到Broker中&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、Leader状态的Broker接收消息，写入到相应topic中。在一个分区内，这些消息被索引并连同时间戳存储在一起&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、Leader状态的Broker接收完毕以后，传给Follow状态的Broker作为副本备份&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、 Consumer 消费者的进程可以从分区订阅，并消费消息&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;常用术语&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Broker。负责接收和处理客户端发送过来的请求，以及对消息进行持久化。虽然多个 Broker 进程能够运行在同一台机器上，但更常见的做法是将不同的 Broker 分散运行在不同的机器上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主题：Topic。主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分区：Partition。一个有序不变的消息序列。每个主题下可以有多个分区。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息：这里的消息就是指 Kafka 处理的主要对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息位移：Offset。表示分区中每条消息的位置信息，是一个单调递增且不变的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;副本：Replica。Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。每个分区可配置多个副本实现高可用。一个分区的N个副本一定在N个不同的Broker上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Leader：每个分区多个副本的“主”副本，生产者发送数据的对象，以及消费者消费数据的对象，都是 Leader。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Follower：每个分区多个副本的“从”副本，实时从 Leader 中同步数据，保持和 Leader 数据的同步。Leader 发生故障时，某个 Follower 还会成为新的 Leader。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者：Producer。向主题发布新消息的应用程序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者：Consumer。从主题订阅新消息的应用程序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者位移：Consumer Offset。表示消费者消费进度，每个消费者都有自己的消费者位移。offset保存在broker端的内部topic中，不是在clients中保存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者组：Consumer Group。多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码演示&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;外部依赖：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 pom.xml 中添加 Kafka 依赖：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.springframework.kafka&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;spring-kafka&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;由于spring-boot-starter-parent 指定的版本号是2.1.5.RELEASE，spring boot 会对外部框架的版本号统一管理，spring-kafka 引入的版本是 2.2.6.RELEASE&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;配置文件：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在配置文件 application.yaml 中配置 Kafka 的相关参数，具体内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Spring:&lt;br/&gt;  kafka:&lt;br/&gt;    bootstrap-servers: localhost:9092&lt;br/&gt;    producer:&lt;br/&gt;      retries: 3  &lt;span&gt;# 生产者发送失败时，重试次数&lt;/span&gt;&lt;br/&gt;      batch-size: 16384&lt;br/&gt;      buffer-memory: 33554432&lt;br/&gt;      key-serializer: org.apache.kafka.common.serialization.StringSerializer &lt;span&gt;# 生产者消息key和消息value的序列化处理类&lt;/span&gt;&lt;br/&gt;      value-serializer: org.apache.kafka.common.serialization.StringSerializer&lt;br/&gt;    consumer:&lt;br/&gt;      group-id: tomge-consumer-group  &lt;span&gt;# 默认消费者group id&lt;/span&gt;&lt;br/&gt;      auto-offset-reset: earliest&lt;br/&gt;      &lt;span&gt;enable&lt;/span&gt;-auto-commit: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;      auto-commit-interval: 100&lt;br/&gt;      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer&lt;br/&gt;      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的配置类 &lt;code&gt;org.springframework.boot.autoconfigure.kafka.KafkaProperties&lt;/code&gt;，来初始化kafka相关的bean实例对象，并注册到spring容器中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;发送消息：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Boot 作为一款支持快速开发的集成性框架，同样提供了一批以 &lt;code&gt;-Template&lt;/code&gt; 命名的模板工具类用于实现消息通信。对于 Kafka 而言，这个工具类就是&lt;code&gt;KafkaTemplate&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;KafkaTemplate 提供了一系列 send 方法用来发送消息，典型的 send 方法定义如下代码所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public ListenableFuture&amp;lt;SendResult&amp;lt;K, V&amp;gt;&amp;gt; send(String topic, @Nullable V data) {&lt;br/&gt; 。。。。 省略&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产端提供了一个restful接口，模拟发送一条创建新用户消息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@GetMapping(&lt;span&gt;&quot;/add_user&quot;&lt;/span&gt;)&lt;br/&gt;public Object &lt;span&gt;&lt;span&gt;add&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    try {&lt;br/&gt;        Long id = Long.valueOf(new Random().nextInt(1000));&lt;br/&gt;        User user = User.builder().id(id).userName(&lt;span&gt;&quot;TomGE&quot;&lt;/span&gt;).age(29).address(&lt;span&gt;&quot;上海&quot;&lt;/span&gt;).build();&lt;br/&gt;        ListenableFuture&amp;lt;SendResult&amp;gt; listenableFuture = kafkaTemplate.send(addUserTopic, JSON.toJSONString(user));&lt;br/&gt;        &lt;br/&gt;        // 提供回调方法，可以监控消息的成功或失败的后续处理&lt;br/&gt;        listenableFuture.addCallback(new ListenableFutureCallback&amp;lt;SendResult&amp;gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public void onFailure(Throwable throwable) {&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;发送消息失败，&quot;&lt;/span&gt; + throwable.getMessage());&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            @Override&lt;br/&gt;            public void onSuccess(SendResult sendResult) {&lt;br/&gt;                // 消息发送到的topic&lt;br/&gt;                String topic = sendResult.getRecordMetadata().topic();&lt;br/&gt;                // 消息发送到的分区&lt;br/&gt;                int partition = sendResult.getRecordMetadata().partition();&lt;br/&gt;                // 消息在分区内的offset&lt;br/&gt;                long offset = sendResult.getRecordMetadata().offset();&lt;br/&gt;                System.out.println(String.format(&lt;span&gt;&quot;发送消息成功，topc：%s, partition: %s, offset：%s &quot;&lt;/span&gt;, topic, partition, offset));&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;消息发送成功&quot;&lt;/span&gt;;&lt;br/&gt;    } catch (Exception e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;消息发送失败&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实际上开发使用的Kafka默认允许自动创建Topic，创建Topic时默认的分区数量是1，可以通过server.properties文件中的num.partitions=1修改默认分区数量。在生产环境中通常会关闭自动创建功能，Topic需要由运维人员先创建好。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消费消息：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Kafka 中消息通过服务器推送给各个消费者，而 Kafka 的消费者在消费消息时，需要提供一个监听器（Listener）对某个 Topic 实现监听，从而获取消息，这也是 Kafka 消费消息的唯一方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义一个消费类，在处理具体消息业务逻辑的方法上添加 &lt;code&gt;@KafkaListener&lt;/code&gt; 注解，并配置要消费的topic，代码如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Component&lt;br/&gt;public class UserConsumer {&lt;br/&gt;&lt;br/&gt;    @KafkaListener(topics = &lt;span&gt;&quot;add_user&quot;&lt;/span&gt;)&lt;br/&gt;    public void receiveMesage(String content) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;消费消息：&quot;&lt;/span&gt; + content);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;是不是很简单，添加kafka依赖、使用KafkaTemplate、@KafkaListener注解就完成消息的生产和消费，其实是SpringBoot在背后默默的做了很多工作，如果感兴趣可以研究下&lt;code&gt;spring-boot-autoconfigure&lt;/code&gt; ，里面提供了常用开源框架的客户端实例封装。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;演示工程代码&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https://github.com/aalansehaiyang/spring-boot-bulking  &lt;br/&gt;&lt;br/&gt;模块：spring-boot-bulking-kafka&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5fd1c9d8894df49073048bf2e4b98d8a</guid>
<title>数据结构与算法之基本概念</title>
<link>https://toutiao.io/k/0krawf7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据结构与算法是程序员内功体现的重要标准之一，且数据结构也应用在各个方面，业界更有&lt;strong&gt;程序=数据结构+算法&lt;/strong&gt;这个等式存在。各个中间件开发者，架构师他们都在努力的优化中间件、项目结构以及算法提高运行效率和降低内存占用，在这里数据结构起到相当重要的作用。此外数据结构也蕴含一些面向对象的思想，故学好掌握数据结构对逻辑思维处理抽象能力有很大提升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么学习数据结构与算法？如果你还是学生，那么这门课程是必修的，考研基本也是必考科目。工作在内卷严重的大厂中找工作数据结构与算法也是面试、笔试必备的非常重要的考察点。如果工作了数据结构和算法也是内功提升一个非常重要的体现，对于程序员来说，想要得到满意的结果，数据结构与算法是必备功力！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据结构&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4945414847161572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThw6s7c4zuKv11xXlYAWCqdLTT8HDFV6Pe0HheH7DsvrzdbOPIzw30qkCib2Ua0Gkg3DJpW39zAGtHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1832&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;概念&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简言之，数据结构是一系列的存储结构按照一定&lt;code&gt;执行规则&lt;/code&gt;、配合&lt;code&gt;一定执行算法&lt;/code&gt;所形成的高效的存储结构。在我们所熟知的关系数据库、非关系数据库、搜索引擎存储、消息队列等都是比较牛的大型数据结构良好的运用。当然这些应用中间件不单单要考虑单纯的结构问题。还考虑实际os、网络等其他因素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对于数据结构与算法这个专栏。我们程序员更改掌握的首先是在&lt;code&gt;内存&lt;/code&gt;中运行的&lt;code&gt;抽象的数据结构&lt;/code&gt;。是一个相对比较单一的数据结构类型，比如&lt;code&gt;线性结构&lt;/code&gt;、&lt;code&gt;树&lt;/code&gt;、&lt;code&gt;图&lt;/code&gt;等等.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;相关术语&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据结构与算法中，&lt;strong&gt;数据、数据对象、数据元素、数据项&lt;/strong&gt;很多人搞不清其中的关系。通过画一张图来捋一捋，然后下面举个例子给大家分享一下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40561797752808987&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThw6s7c4zuKv11xXlYAWCqdLkmibjPBIVunORU0KV8kWVuIrXcAJf7He2HW48rI7OEmIUMbLnywtldQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1780&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;用户信息表users&lt;/code&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;sex&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;001&lt;/td&gt;&lt;td&gt;bigsai&lt;/td&gt;&lt;td&gt;man&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;002&lt;/td&gt;&lt;td&gt;smallsai&lt;/td&gt;&lt;td&gt;man&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;003&lt;/td&gt;&lt;td&gt;菜虚鲲&lt;/td&gt;&lt;td&gt;woman&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;users的pojo对象&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;users&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{ &lt;br/&gt;     &lt;span&gt;//略&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;     String name;&lt;br/&gt;     String sex;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//list和woman是数据&lt;/span&gt;&lt;br/&gt;List&amp;lt;users&amp;gt;list;&lt;span&gt;//数据对象list&lt;/span&gt;&lt;br/&gt;List&amp;lt;users&amp;gt;woman;&lt;span&gt;//数据对象woman&lt;/span&gt;&lt;br/&gt;list.add(&lt;span&gt;new&lt;/span&gt; users(&lt;span&gt;001&lt;/span&gt;,&lt;span&gt;&quot;bigsai&quot;&lt;/span&gt;,&lt;span&gt;&quot;man&quot;&lt;/span&gt;));&lt;span&gt;//添加数据元素 一个users由（001，bigsai，man）三个数据项组成 &lt;/span&gt;&lt;br/&gt;list.add(&lt;span&gt;new&lt;/span&gt; users(&lt;span&gt;002&lt;/span&gt;,&lt;span&gt;&quot;smallsai&quot;&lt;/span&gt;,&lt;span&gt;&quot;man&quot;&lt;/span&gt;));&lt;span&gt;//数据元素&lt;/span&gt;&lt;br/&gt;list.add(&lt;span&gt;new&lt;/span&gt; users(&lt;span&gt;003&lt;/span&gt;,&lt;span&gt;&quot;菜虚鲲&quot;&lt;/span&gt;,&lt;span&gt;&quot;woman&quot;&lt;/span&gt;));&lt;span&gt;//数据元素&lt;/span&gt;&lt;br/&gt;woman.add(list.get(&lt;span&gt;2&lt;/span&gt;));&lt;span&gt;//003,&quot;菜虚鲲&quot;,&quot;woman&quot;三个数据项构成的一个数据元素&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据&lt;/strong&gt;：对客观事物的符号表示，指所有能输入到计算机中并被计算机程序处理的符号的集合总称。上述表中的三条用户信息的记录就是数据(也可能多表多集合这里只有一个)。这些数据一般都是&lt;code&gt;用户输入&lt;/code&gt;或者是自定义构造完成。当然，还有一些图像、声音也是数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据元素&lt;/strong&gt;：数据元素是&lt;strong&gt;数据的基本单位&lt;/strong&gt;。一个数据元素由若干&lt;code&gt;数据项&lt;/code&gt;构成！可认为是一个pojo对象、或者是数据库的一条记录。比如&lt;code&gt;菜虚鲲&lt;/code&gt;那条记录就是一个数据元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据项&lt;/strong&gt;：而构成用户字段/属性的有&lt;code&gt;id&lt;/code&gt;、&lt;code&gt;name&lt;/code&gt;、&lt;code&gt;sex&lt;/code&gt;等，这些就是数据项.数据项是构成数据元素的&lt;code&gt;最小不可分割字段&lt;/code&gt;。可以看作一个pojo对象或者一张表(people)的一个&lt;code&gt;属性/字段&lt;/code&gt;的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据对象&lt;/strong&gt;：是相同性质数据元素的集合。是数据的一个子集。比如上面的&lt;code&gt;users&lt;/code&gt;表、&lt;code&gt;list&lt;/code&gt;集合、&lt;code&gt;woman&lt;/code&gt;集合都是数据对象。单独一张表，一个集合都可以是一个数据对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的捋一捋，数据范围最广，所有数据即数据，而数据对象仅仅是有相同性质的一个集合，这个集合是数据的子集，但并不是数据的基本单位，而数据元素才是数据的基本单位。举个例子表cat和表dog都是数据，然后表cat是个数据对象(因为都描述cat这种对象)，但是数据的基本单位并不是猫和狗，而是他们的具体的每一条，比如小猫咪1号，大猫咪二号，哈士奇1号，藏獒2号这些每一条才是数据的基本单位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于数据类型和抽象数据类型两者容易混淆注意区分开：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据类型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;原子类型&lt;/code&gt;：其值不可再分的类型。比如int，char，double，float等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;结构类型&lt;/code&gt;：其值可以再分为若干成分的数据类型。比如结构体构造的各种结构等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;抽象数据类型(ADT)&lt;/strong&gt;：抽象数据类型（ADT）是一个实现包括储存数据元素的存储结构以及实现基本操作的算法。使得只研究和使用它的结构而不用考虑它的实现细节成为可能。比如我们使用List、Map、Set等等只需要了解它的api和性质功能即可。而具体的实现可能是不同的方案，比如List的实现有数组和链表不同选择。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三要素&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逻辑结构&lt;/strong&gt;：数据元素之间的&lt;code&gt;逻辑关系&lt;/code&gt;。逻辑结构分为&lt;code&gt;线性结构&lt;/code&gt;和&lt;code&gt;非线性结构&lt;/code&gt;。线性结构就是顺序表、链表之类。而非线性就是集合、树、图这些结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;存储结构&lt;/strong&gt;：数据结构在计算机中的表示(又称映像，也称物理结构)，存储结构主要分为&lt;code&gt;顺序存储&lt;/code&gt;、&lt;code&gt;链式存储&lt;/code&gt;、&lt;code&gt;索引存储&lt;/code&gt;和&lt;code&gt;散列(哈希)存储&lt;/code&gt;，这几种存储通过下面这张图简单了解一下(仅仅为理解不考虑更多)：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4934823091247672&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThw6s7c4zuKv11xXlYAWCqdLLmaoqSmMxtBL4pGj4l0rEGVpfA6CzcqbLppbcV5LUXicf2X0j2nzydw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2148&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据的运算&lt;/strong&gt;：施加在数据上的运算包括运算的&lt;code&gt;定义&lt;/code&gt;和&lt;code&gt;实现&lt;/code&gt;,运算的定义基于逻辑结构，运算的实现基于存储结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里容易混淆的是逻辑结构与存储结构的概念。对于&lt;strong&gt;逻辑结构&lt;/strong&gt;，不难看得出逻辑二字，逻辑关系也就是两者存在数据上的关系而不考虑物理地址的关系，比如线性结构和非线性结构，它描述的是一组&lt;strong&gt;数据中联系&lt;/strong&gt;的方式和形式，他针对的是&lt;strong&gt;数据&lt;/strong&gt;。看中的是数据结构的功能，比如线性表就是前后有序的，我需要一个有序的集合就可以使用线性表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;strong&gt;存储结构&lt;/strong&gt;就是跟物理地址挂钩的。因为同样逻辑结构采用不同存储结构实现适用场景和性能可能不同。比如同样是&lt;strong&gt;线性表&lt;/strong&gt;,可能有多种存储结构的实现方式。比如&lt;code&gt;顺序表&lt;/code&gt;和&lt;code&gt;链表&lt;/code&gt;(Arraylist,Linkedlist)它们的存储结构就不同，一个是顺序存储(数组)实现，一个是链式存储(链表)实现。它关注的是计算机运行物理地址的关系。但通常同一类存储结构实现的一些数据结构有一些类似的共同点和缺点(线性易查难插、链式易插难查等等)。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;算法分析&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面讲了数据结构相关概念，下面对算法分析的一些概念进行描述。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThw6s7c4zuKv11xXlYAWCqdLfzZxOqJMnZ23smT2Lmx2pqQUpdeEIxVPuiaD4gXj7HYulK8zyeXY5BA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法的五个重要特征：&lt;strong&gt;有穷性、确定性、可行性、输入、输出&lt;/strong&gt;。这些从字面意思即可理解，其中&lt;span&gt;有&lt;/span&gt;&lt;span&gt;穷性强调算法要有结束的时候不能无限循环；&lt;/span&gt;&lt;span&gt;而确定性是每条指令有它意义&lt;/span&gt;&lt;span&gt;，相同的输入得到相同的输出；&lt;/span&gt;&lt;span&gt;可行性是指算法每个步骤经过若干次执行可以实现；输入是0个或多个输入(可0);输出是1个或多个输出(一定要有输出)。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;而一个好的算法，通常更要着重考虑的是效率和空间资源占用(时间复杂度和空间复杂度)，通常复杂度更多描述的是一个&lt;code&gt;量级&lt;/code&gt;程度而很少用具体数字描述。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;空间复杂度&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;概念&lt;/strong&gt;：是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;空间复杂度其实在算法的衡量占比是比较低的(我们经常使用牺牲空间换时间的数据结构和算法)，但是不能忽视空间复杂度中重要性。无论在刷题还是实际项目生产内存都是一个极大额指标。对于Java而言更是如此。本身内存就大，如果采用的存储逻辑不太好会占用更多的系统资源，对服务造成压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而算法很多情况都是牺牲空间换取时间(效率)。就比如我们熟知的字符串匹配&lt;code&gt;String.contains()&lt;/code&gt;方法，我们都知道他是暴力破解，时间复杂度为O(n^2),不需要借助额外内存。而&lt;code&gt;KMP&lt;/code&gt;算法在效率和速度上都原生暴力方法，但是KMP要借助其他数组(&lt;code&gt;next[]&lt;/code&gt;)进行标记储存运算。就用到了空间开销。再比如归并排序也会借助新数组在递归分冶的适合进行逐级计算，提高效率，但增加点影响不大的内存开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，算法的空间花销最大不能超过jvm设置的最大值，一般为2G.(2147483645)如果开二维数组多种多维数据不要开的太大，可能会导致&lt;code&gt;heap OutOfMemoryError&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;时间复杂度&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;概念&lt;/strong&gt;：计算机科学中，算法的时间复杂度是一个&lt;code&gt;函数&lt;/code&gt;，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，&lt;strong&gt;不包括这个函数的低阶项和首项系数&lt;/strong&gt;。使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;时间复杂度的排序&lt;/strong&gt;：O(1) &amp;lt; O(logn) &amp;lt; O(n) &amp;lt; O(nlogn) &amp;lt; O(n^2) &amp;lt; O(n^3) &amp;lt; O(2^n) &amp;lt;O(n!) &amp;lt; O(n^n)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;常见时间复杂度&lt;/strong&gt;：对于时间复杂度，很多人的概念是比较模糊的。下面举例子说明一些时间复杂度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;O(1):  常数函数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;O(logn): 对数函数&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;for(int i=1;i&amp;lt;n;i*=2)&lt;/code&gt;分析：假设执行&lt;code&gt;t&lt;/code&gt;次使得&lt;code&gt;i=n&lt;/code&gt;;有2^t=n; t=log2~n,为log级别时间复杂度为O(logn)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;还有典型的二分查找，拓展欧几里得，快速幂等算法均为O(logn)。属于高效率算法。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;O(n): 线性函数&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;for (int i=0;i&amp;lt;n;i++)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比较常见，能够良好解决大部分问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;O(nlogn):&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;for (int i=1;i&amp;lt;n;i++)&lt;/code&gt;&lt;code&gt;for (int j=1;j&amp;lt;i;j*=2)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常见的排序算法很多正常情况都是nlogn，比如快排、归并排序。这种算法效率大部分也还不错。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;O(n^2)&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;for(int i=0;i&amp;lt;n;i++)&lt;/code&gt;&lt;code&gt;for(int j=0;j&amp;lt;i;j++)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其实O(n^2)的效率就不敢恭维了。对于大的数据O(n^2)甚至更高次方的执行效果会很差。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然如果同样是n=10000.那么不同时间复杂度额算法执行次数、时间也不同。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;具体&lt;/th&gt;&lt;th&gt;n&lt;/th&gt;&lt;th&gt;执行次数&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;O(1)&lt;/td&gt;&lt;td&gt;10000&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;O(log2n)&lt;/td&gt;&lt;td&gt;10000&lt;/td&gt;&lt;td&gt;14&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;O( n^1/2)&lt;/td&gt;&lt;td&gt;10000&lt;/td&gt;&lt;td&gt;100&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;O(n)&lt;/td&gt;&lt;td&gt;10000&lt;/td&gt;&lt;td&gt;10000&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;O(nlog2 n)&lt;/td&gt;&lt;td&gt;10000&lt;/td&gt;&lt;td&gt;140000&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;O(n^2)&lt;/td&gt;&lt;td&gt;10000&lt;/td&gt;&lt;td&gt;100000000&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;O(n^3)&lt;/td&gt;&lt;td&gt;10000&lt;/td&gt;&lt;td&gt;1000000000000&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;降低算法复杂度有些会靠数据结构的特性和优势，比如二叉排序树的查找，线段树的动态排序等等，这些数据结构解决某些问题有些非常良好的性能。还有的是靠算法策略解决，比如同样是排序，冒泡排序这种笨而简单的方法就是O(n2),但快排、归并等聪明方法就能O(nlogn)。要想变得更快，那就得掌握更高级的数据结构和更精巧的算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;时间复杂度计算&lt;/strong&gt;时间复杂度计算一般&lt;code&gt;步骤&lt;/code&gt;：1、找到执行次数最多的语句; 2、计算语句执行的数量级 ; 3、用O表示结果。并且有两个规则：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加法规则：同一程序下如果多个并列关系的执行语句那么取最大的那个,eg:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;T(n)=O(m)+O(n)=max(O(m),O(n)); &lt;br/&gt;T(n)=O(n)+O(nlogn)=max(O(n),O(nlogn))=O(nlogn);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;乘法规则：循环结构，时间复杂度按乘法进行计算,eg：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;T(n)=O(m)*O(n)=O(mn)&lt;br/&gt;T(n)=O(m)*O(m)=O(m^2)(两层&lt;span&gt;for&lt;/span&gt;循环)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然很多算法的时间复杂度还跟输入的数据有关，分为还会有最优时间复杂度(可能执行次数最少时)，最坏时间复杂度(执行次数最少时)，平均时间复杂度，这在排序算法中已经具体分析，但我们通常使用&lt;strong&gt;平均时间复杂度&lt;/strong&gt;来衡量一个算法的好坏。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据结构与算法学习&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;捋过数据结构与算法基本概念的介绍，在学习数据结构与算法方面，个人把经典的数据结构与算法学习过程步骤写在下面，希望能给大家一个参考：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据结构&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;单链表(带头结点、不带头结点)设计与实现(增删改查)，双链表设计与实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;栈设计与实现(数组和链表)，队列设计与实现(数组和链表)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;二叉树概念学习，二叉树前序、中序、后序遍历递归、非递归实现 ，层序遍历&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;二叉排序树设计与实现(插入删除)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;堆(优先队列、堆排序)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AVL(平衡)树设计与实现(四种自旋方式理解实现)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;伸展树、红黑树原理概念理解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B、B+原理概念理解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;哈夫曼树原理概念理解(贪心策略)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;哈希(散列表)原理概念理解(几种解决哈希冲突方式)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并查集/不相交集合(优化和路径压缩)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;图论拓扑排序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;图论dfs深度优先遍历、bfs广度优先遍历&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最短路径Dijkstra算法、Floyd算法、spfa算法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最小生成树prim算法、kruskal算法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他数据结构线段树、后缀数组等等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;经典算法&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;递归算法(求阶乘、斐波那契、汉诺塔问题)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;二分查找&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分治算法(快排、归并排序、求最近点对等问题)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;贪心算法(使用较多，区间选点问题，区间覆盖问题)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常见动态规划(LCS(最长公共子序列) LIS(最长上升子序列)背包问题等等)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回溯算法(经典八皇后问题、全排列问题)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;位运算常见问题(参考剑指offer和LeetCode问题)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;快速幂算法(快速求幂乘、矩阵快速幂)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;kmp等字符串匹配算法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一切其他数论算法(欧几里得、拓展欧几里得、中国剩余定理等等)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信看完这篇文章，你应该对数据结构与算法有个不错的认知。数据结构与算法有着非常密切的关联，数据结构是为了实现某种算法，算法是核心目的。学习数据结构与算法之前，可以先参考书本或者博客先了解其功能，再研究其运行原理，再动手实战(编写数据结构或者相关题目)这样层次渐进，想要深入的学习数据结构与算法光理解是不行的，需要有大量代码实战才可。并且这条路是没有止境的，活到老，学到老，刷到老。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2020的最后一篇技术文，愿大家2021一起加油，2021我会把专栏数据结构与算法系列文章进行优化分享出来！这是第一篇，敬请期待！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e0c3d115febadaf7483777fdb3391c12</guid>
<title>跟读者聊 Goroutine 泄露的 N 种方法，真刺激</title>
<link>https://toutiao.io/k/qri822e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几天分享 Go 群友提问的文章时，有读者在朋友圈下提到，希望我能够针对 Goroutine 泄露这块进行讲解，他在面试的时候经常被问到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外我也相信很多小伙伴，在做救火队长时排查过 Goroutine 泄露的问题，因为 &lt;span&gt;Goro&lt;/span&gt;&lt;span&gt;uti&lt;/span&gt;&lt;span&gt;ne&lt;/span&gt; 作为一个载体，基本跑不了干系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此今天的男主角，就是 Go 语言的著名品牌标识 Goroutine，一个随随便便就能开几十万个快车进车道的大杀器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {}()&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文会聚焦于 Goroutine 泄露的 N 种方法，进行详解和说明。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么要问&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官为啥会问 Goroutine（协程）泄露这种奇特的问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以猜测是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Goroutine 实在是使用门槛实在是太低了，随手就一个就能起，出现了不少滥用的情况。例如：并发 map。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Goroutine 本身在 Go 语言的标准库、复合类型、底层源码中应用广泛。例如：HTTP Server 对每一个请求的处理就是一个协程去运行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多 Go 工程在线上出事故时，基本 Goroutine 的关联，大家都会作为救火队长，风风火火的跑去看指标、看日志，通过 PProf 采集 Goroutine 运行情况等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自然他也就是最受瞩目的那颗 “星” 了，所以在日常面试中，被问几率也就极高了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Goroutine 泄露&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解清楚大家爱问的原因后，我们开始对 Goroutine 泄露的 N 种方法进行研究，希望通过前人留下的 “坑”，了解其原理和避开这些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泄露的原因大多集中在：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Goroutine 内正在进行 channel/mutex 等读写操作，但由于逻辑问题，某些情况下会被一直阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Goroutine 内的业务逻辑进入死循环，资源一直无法释放。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Goroutine 内的业务逻辑进入长时间等待，有不断新增的 Goroutine 进入等待。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我会引用在网上冲浪收集到的一些 Goroutine 泄露例子（会在文末参考注明出处）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;channel 使用不当&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Goroutine+Channel 是最经典的组合，因此不少泄露都出现于此。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最经典的就是上面提到的 channel 进行读写操作时的逻辑问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;发送不接收&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++ {&lt;br/&gt;        queryAll()&lt;br/&gt;        fmt.Printf(&lt;span&gt;&quot;goroutines: %d\n&quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;queryAll&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++ {&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; { ch &amp;lt;- query() }()&lt;br/&gt;     }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;lt;-ch&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;query&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    n := rand.Intn(&lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;    time.Sleep(time.Duration(n) * time.Millisecond)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; n&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;goroutines: 3&lt;br/&gt;goroutines: 5&lt;br/&gt;goroutines: 7&lt;br/&gt;goroutines: 9&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个例子中，我们调用了多次 &lt;code&gt;queryAll&lt;/code&gt; 方法，并在 &lt;code&gt;for&lt;/code&gt; 循环中利用 Goroutine 调用了 &lt;code&gt;query&lt;/code&gt; 方法。其重点在于调用 &lt;code&gt;query&lt;/code&gt; 方法后的结果会写入 &lt;code&gt;ch&lt;/code&gt; 变量中，接收成功后再返回 &lt;code&gt;ch&lt;/code&gt; 变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后可看到输出的 goroutines 数量是在不断增加的，每次多 2 个。也就是每调用一次，都会泄露 Goroutine。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因在于 channel 均已经发送了（每次发送 3 个），但是在接收端并没有接收完全（只返回 1 个 ch），所诱发的 Goroutine 泄露。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;接收不发送&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        fmt.Println(&lt;span&gt;&quot;goroutines: &quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;    }()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; ch &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        ch &amp;lt;- &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;    }()&lt;br/&gt;    &lt;br/&gt;    time.Sleep(time.Second)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;goroutines:  2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个例子中，与 “发送不接收” 两者是相对的，channel 接收了值，但是不发送的话，同样会造成阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在实际业务场景中，一般更复杂。基本是一大堆业务逻辑里，有一个 channel 的读写操作出现了问题，自然就阻塞了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;nil channel&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        fmt.Println(&lt;span&gt;&quot;goroutines: &quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;    }()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; ch &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &amp;lt;-ch&lt;br/&gt;    }()&lt;br/&gt;    &lt;br/&gt;    time.Sleep(time.Second)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;goroutines:  2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个例子中，可以得知 channel 如果忘记初始化，那么无论你是读，还是写操作，都会造成阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常的初始化姿势是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &amp;lt;-ch&lt;br/&gt;    }()&lt;br/&gt;    ch &amp;lt;- &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    time.Sleep(time.Second)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用 &lt;code&gt;make&lt;/code&gt; 函数进行初始化。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;奇怪的慢等待&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第四个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            _, err := http.Get(&lt;span&gt;&quot;https://www.xxx.com/&quot;&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;                fmt.Printf(&lt;span&gt;&quot;http.Get err: %v\n&quot;&lt;/span&gt;, err)&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// do something...&lt;/span&gt;&lt;br/&gt;    }()&lt;br/&gt;&lt;br/&gt;    time.Sleep(time.Second * &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;goroutines: &quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;goroutines:  5&lt;br/&gt;goroutines:  9&lt;br/&gt;goroutines:  13&lt;br/&gt;goroutines:  17&lt;br/&gt;goroutines:  21&lt;br/&gt;goroutines:  25&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个例子中，展示了一个 Go 语言中经典的事故场景。也就是一般我们会在应用程序中去调用第三方服务的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是第三方接口，有时候会很慢，久久不返回响应结果。恰好，Go 语言中默认的 &lt;code&gt;http.Client&lt;/code&gt; 是没有设置超时时间的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此就会导致一直阻塞，一直阻塞就一直爽，Goroutine 自然也就持续暴涨，不断泄露，最终占满资源，导致事故。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 工程中，我们一般建议至少对 &lt;code&gt;http.Client&lt;/code&gt; 设置超时时间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    httpClient := http.Client{&lt;br/&gt;        Timeout: time.Second * &lt;span&gt;15&lt;/span&gt;,&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且要做限流、熔断等措施，以防突发流量造成依赖崩塌，依然吃 P0。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;互斥锁忘记解锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第五个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    total := &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        time.Sleep(time.Second)&lt;br/&gt;        fmt.Println(&lt;span&gt;&quot;total: &quot;&lt;/span&gt;, total)&lt;br/&gt;        fmt.Println(&lt;span&gt;&quot;goroutines: &quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; mutex sync.Mutex&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            mutex.Lock()&lt;br/&gt;            total += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        }()&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;total:  1&lt;br/&gt;goroutines:  10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个例子中，第一个互斥锁 &lt;code&gt;sync.Mutex&lt;/code&gt; 加锁了，但是他可能在处理业务逻辑，又或是忘记 &lt;code&gt;Unlock&lt;/code&gt; 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此导致后面的所有 &lt;code&gt;sync.Mutex&lt;/code&gt; 想加锁，却因未释放又都阻塞住了。一般在 Go 工程中，我们建议如下写法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;var&lt;/span&gt; mutex sync.Mutex&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            mutex.Lock()&lt;br/&gt;            &lt;span&gt;defer&lt;/span&gt; mutex.Unlock()&lt;br/&gt;            total += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    }()&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;同步锁使用不当&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第六个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;handle&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt;    wg.Add(&lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; v; i++ {&lt;br/&gt;        fmt.Println(&lt;span&gt;&quot;脑子进煎鱼了&quot;&lt;/span&gt;)&lt;br/&gt;        wg.Done()&lt;br/&gt;    }&lt;br/&gt;    wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        fmt.Println(&lt;span&gt;&quot;goroutines: &quot;&lt;/span&gt;, runtime.NumGoroutine())&lt;br/&gt;    }()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; handle(&lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;    time.Sleep(time.Second)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个例子中，我们调用了同步编排 &lt;code&gt;sync.WaitGroup&lt;/code&gt;，模拟了一遍我们会从外部传入循环遍历的控制变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于 &lt;code&gt;wg.Add&lt;/code&gt; 的数量与 &lt;code&gt;wg.Done&lt;/code&gt; 数量并不匹配，因此在调用 &lt;code&gt;wg.Wait&lt;/code&gt; 方法后一直阻塞等待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 工程中使用，我们会建议如下写法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; v; i++ {&lt;br/&gt;        wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;        fmt.Println(&lt;span&gt;&quot;脑子进煎鱼了&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    wg.Wait()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;排查方法&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以调用 &lt;code&gt;runtime.NumGoroutine&lt;/code&gt; 方法来获取 Goroutine 的运行数量，进行前后一比较，就能知道有没有泄露了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在业务服务的运行场景中，Goroutine 内导致的泄露，大多数处于生产、测试环境，因此更多的是使用 PProf：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt;     _ &lt;span&gt;&quot;net/http/pprof&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;http.ListenAndServe(&lt;span&gt;&quot;localhost:6060&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要我们调用 &lt;code&gt;http://localhost:6060/debug/pprof/goroutine?debug=1&lt;/code&gt;，PProf 会返回所有带有堆栈跟踪的 Goroutine 列表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以利用 PProf 的其他特性进行综合查看和分析，这块参考我之前写的《Go 大杀器之性能剖析 PProf》，基本是全村最全的教程了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在今天这篇文章中，我们针对 Goroutine 泄露的 N 种常见的方式方法进行了一一分析，虽说看起来都是比较基础的场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但结合在实际业务代码中，就是一大坨中的某个细节导致全盘皆输了，希望上面几个案例能够给大家带来警惕。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而面试官爱问，怕不是自己踩过许多坑，也希望进来的同僚，也是身经百战了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;靠谱的工程师，而非只是八股工程师。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;波罗学大佬的《Go 笔记之如何防止 goroutine 泄露》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;二斗斗的《怎么看待Goroutine 泄露》&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxMDI4MDc1NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iac2xQZIq5icSiaTepuae8zLIUMiaxibbUM8ic735ewo6e89GRtjGbUBlgNYibwCjAicglQcvz6dCQ6yTKOw/0?wx_fmt=png&quot; data-nickname=&quot;脑子进煎鱼了&quot; data-alias=&quot;eddycjy&quot; data-signature=&quot;分享计算机基础、Go 语言、微服务架构和系统设计；著有图书《Go 语言编程之旅》。&quot;/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.07106598984771574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/486RHs1WbcgGib6o96dHbvGUGGwPicd8wusUGH1cXR29tM4bO0lNzialzkQhvU6m5ZUdaKibmcF2OQayjMe9Bia6iaXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是煎鱼。高一折腾过前端，参加过国赛拿了奖，大学搞过 PHP。现在整 Go，在公司负责微服务架构等相关工作推进和研发。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;从大学开始靠自己赚生活费和学费，到出版 Go 畅销书《Go 语言编程之旅》，再到获得 GOP（Go 领域最有观点专家）荣誉，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247483854&amp;amp;idx=1&amp;amp;sn=ec422fbf4d846975f2930ddeb5e81373&amp;amp;chksm=f9041493ce739d85a4b987eece14da627206cdad798f645cc770868312e4a22b6df24804f186&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点击蓝字查看我的出书之路&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;点击蓝字查看我的出书之路&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日常分享高质量文章，输出 Go 面试、工作经验、架构设计，记得点赞。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>