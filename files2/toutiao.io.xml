<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ad74e7676957b46695d55c75973fcfc1</guid>
<title>2021 年快结束了！抓紧啦！</title>
<link>https://toutiao.io/k/809c4m6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>001e1a62a6dde4f97c0e35b80cd743cb</guid>
<title>小心陷入 MySQL 索引的坑</title>
<link>https://toutiao.io/k/gucqkq4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;索引可以说是数据库中的一个大心脏了，如果说一个数据库少了索引，那么数据库本身存在的意义就不大了，和普通的文件没什么两样。所以说一个好的索引对数据库系统尤其重要，今天来说说 MySQL 索引，从细节和实际业务的角度看看在 MySQL 中 B+ 树索引好处，以及我们在使用索引时需要注意的知识点。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 合理利用索引&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在工作中，我们可能判断数据表中的一个字段是不是需要加索引的最直接办法就是：这个字段会不会经常出现在我们的 where 条件中。&lt;/span&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从宏观的角度来说，这样思考没有问题，但是从长远的角度来看，有时可能需要更细致的思考，比如我们是不是不仅仅需要在这个字段上建立一个索引？多个字段的联合索引是不是更好？&lt;/span&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以一张用户表为例，用户表中的字段可能会有用户的姓名、用户的身份证号、用户的家庭地址等等。&lt;/span&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/figure&gt;&lt;/figure&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUHAvRwQMxpJ0YDj4icc1ibwoERjs4E9v2DAxLvW9PIQtlUBWqIcia6tLsblYic5VDr3KqskRZGY9PIxV5qMuqtBmw/640?wx_fmt=png&quot; data-cropx1=&quot;235.4325259515571&quot; data-cropx2=&quot;878.2006920415225&quot; data-cropy1=&quot;33.63321799307958&quot; data-cropy2=&quot;384.91349480968853&quot; data-fileid=&quot;510168174&quot; data-ratio=&quot;0.5474339035769828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eZzl4LXykQwbM0dAtHdzIqKgibcmicic2gwLpXZQvicRFy1a3dRuAnqia4AevArurEFXvqUWjdzVZAJ9nISuLcB3fzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;643&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1.1 普通索引的弊端&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在有个需求需要根据用户的身份证号找到用户的姓名。这时候很显然想到的第一个办法就是在 id_card 上建立一个索引，严格来说是唯一索引，因为身份证号肯定是唯一的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么当我们执行以下查询的时候：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;WHERE&lt;/span&gt; id_card=xxx&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它的流程应该是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;先在 id_card 索引树上搜索，找到 id_card 对应的主键 id；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过 id 去主键索引上搜索，找到对应的 name。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从效果上来看，结果是没问题的。但是从效率上来看，似乎这个查询有点昂贵，因为它检索了两棵 B+ 树。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设一颗树的高度是3，那么两颗树的高度就是6。因为根节点在内存里（此处两个根节点），所以最终要在磁盘上进行 IO 的次数是 4 次。以一次磁盘随机 IO 的时间平均耗时是 10ms 来说，那么最终就需要 40ms。这个数字一般，不算快。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;510168175&quot; data-ratio=&quot;0.4575757575757576&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUHAvRwQMxpJ0YDj4icc1ibwoERjs4E9v2nG46UCGdPx7regemdo4vwVWVVJ3FF4XGzv3uLF9wXBMFfT7wwVZlYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1320&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1.2 主键索引的陷阱&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;既然问题是回表，造成了在两棵树都检索了，那么核心问题就是看看能不能只在一棵树上检索。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里从业务的角度你可能发现了一个切入点：身份证号是唯一的，那么我们的主键是不是可以不用默认的自增 id 了？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们把主键设置成我们的身份证号，这样整个表的只需要一个索引，并且通过身份证号可以查到所有需要的数据包括我们的姓名。&lt;/span&gt;&lt;span&gt;简单一想似乎有道理，只要每次插入数据的时候，指定 &lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;是身份证号就行了，但是仔细一想似乎有问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里要从 B+ 树的特点来说，B+ 树的数据都存在叶子节点上，并且数据是页式管理的，一页是 16K。&lt;/span&gt;&lt;span&gt;这是什么意思呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;span&gt;哪怕我们现在是一行数据，它也要占用 16K 的数据页。只有当我们的数据页写满了之后才会写到一个新的数据页上，新的数据页和老的数据页在物理上不一定是连续的。而且有一点很关键，虽然数据页物理上是不连续的，但是数据在逻辑上是连续的。&lt;/span&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUHAvRwQMxpJ0YDj4icc1ibwoERjs4E9v2icPGJbIAv5ia9hTa7C9P5HGQlVNolLTicyU8nKfK141UHG6T3aiaOicFthQ/640?wx_fmt=png&quot; data-cropx1=&quot;130.79584775086505&quot; data-cropx2=&quot;962.2837370242214&quot; data-cropy1=&quot;44.844290657439444&quot; data-cropy2=&quot;364.3598615916955&quot; data-fileid=&quot;510168172&quot; data-ratio=&quot;0.38461538461538464&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eZzl4LXykQwbM0dAtHdzIqKgibcmicic2gwU0bNbPgEAHzV05nTBm7DsYIQcvXUFeIbibfaqtyvGgrOkeAEu13JEnw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;832&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;也许你会好奇，这和我们说的身份证号当主键ID有什么关系？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这时你应该关注「连续」这个关键字。身份证号不是连续的，这意味着什么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当我们插入一条不连续的数据的时候，为了保持连续，需要移动数据。比如，原来在一页上的数据有1-&amp;gt;5，这时候插入了一条3，那么就需要把5移到3后面。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;也许你会说这也没多少开销。但是如果当新的数据 3 造成这个页 A 满了，那么就要看它后面的页 B 是否有空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果有空间，这时候页 B 的开始数据应该是这个从页 A 溢出来的那条，对应的也要移动数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;span&gt;如果此时页 B 也没有足够的空间，那么就要申请新的页 C，然后移一部分数据到这个新页 C 上，并且会切断页 A 与页 B 之间的关系。在两者之间插入一个页 C，从代码的层面来说，就是切换链表的指针。&lt;/span&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUHAvRwQMxpJ0YDj4icc1ibwoERjs4E9v2VNTxmd2X0RpMfib0zgiaZf6EpibTQTWcOhVzvhG0RSf1Q3VoJhEX3AfLw/640?wx_fmt=png&quot; data-cropx1=&quot;295.2249134948097&quot; data-cropx2=&quot;835.2249134948097&quot; data-cropy1=&quot;22.422145328719722&quot; data-cropy2=&quot;321.3840830449827&quot; data-fileid=&quot;510168173&quot; data-ratio=&quot;0.5537037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eZzl4LXykQwbM0dAtHdzIqKgibcmicic2gwTURNDaep8GosfnLB10HHp4xHXx46YWicTaOYx7z7zXOKib7nVstfRvng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;540&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结来说，不连续的身份证号当主键可能会造成页数据的移动、随机 IO、频繁申请新页相关的开销。如果我们用的是自增的主键，那么对于 id 来说一定是顺序的，不会因为随机 IO 造成数据移动的问题，在插入方面开销一定是相对较小的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实不推荐用身份证号当主键的还有另外一个原因：身份证号作为数字来说太大了，得用 bigint 来存。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;正常来说一个学校的学生用 int 已经足够了。我们知道一页可以存放 16K，当一个索引本身占用的空间越大时，会导致一页能存放的数据越少。所以在一定数据量的情况下，使用 bigint 要比 int 需要更多的页也就是更多的存储空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1.3 联合索引的矛与盾&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由上面两条结论可以得出：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以自然而然地想到了联合索引。创建一个【身份证号+姓名】的联合索引，注意联合索引的顺序，要符合最左原则。这样当我们同样执行以下 SQL 时：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; id_card=xxx&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不需要回表就可以得到我们需要的 name 字段。然而，还是没有解决身份证号本身占用空间过大的问题。这是业务数据本身的问题，如果你要解决它的话，我们可以通过一些转换算法将原本大的数据转换成小的数据，比如 crc32：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;crc32.ChecksumIEEE([]&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;341124199408203232&quot;&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以将原本需要 8 个字节存储空间的身份证号用 4 个字节的 crc 码替代。因此，我们的数据库需要再加个字段 crc_id_card，联合索引也从【身份证号+姓名】变成了【crc32(身份证号)+姓名】，联合索引占的空间变小了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是这种转换也是有代价的：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每次额外的 crc，导致需要更多 CPU 资源；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;额外的字段。虽然让索引的空间变小了，但是本身也要占用空间；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;crc 会存在冲突的概率。这需要我们查询出来数据后，再根据 id_card 过滤一下。过滤的成本根据重复数据的数量而定，重复越多过滤越慢。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于联合索引存储优化，这里有个小细节。假设现在有两个字段 A 和 B，分别占用 8 个字节和 20 个字节，我们在联合索引已经是 [A,B] 的情况下，还要支持 B 的单独查询。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，自然而然我们在 B 上也建立个索引。那么，两个索引占用的空间为 8+20+20=48。现在，无论我们通过 A 还是通过 B 查询都可以用到索引。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果在业务允许的条件下，我们是否可以建立 [B,A] 和 A 索引？这样的话，不仅满足单独通过 A 或者 B 查询数据用到索引，还可以占用更小的空间：20+8+8=36。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1.4 前缀索引的短小精悍&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有时候我们需要索引的字段是字符串类型的，并且这个字符串很长。我们希望这个字段加上索引，但是我们又不希望这个索引占用太多的空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这时可以考虑建立个前缀索引，以这个字段的前一部分字符建立个索引，这样既可以享受索引的好处，又可以节省空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需要注意的是在前缀重复度较高的情况下，前缀索引和普通索引的速度应该是有差距的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;table&lt;/span&gt; xx &lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;index&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;name&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;7&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; xx &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; xx &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;JamesBond&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1.5 唯一索引的快与慢&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在说唯一索引之前，我们先了解下普通索引的特点，我们知道对于 B+ 树而言，叶子节点的数据是有序的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUHAvRwQMxpJ0YDj4icc1ibwoERjs4E9v2VdPOZD5dBKMTlKzUBUdibjmn0rkw98Pv7LCMp13sKexpbuhiayibFicdCg/640?wx_fmt=png&quot; data-cropx1=&quot;171.40484429065745&quot; data-cropx2=&quot;905.2318339100347&quot; data-cropy1=&quot;80.34602076124568&quot; data-cropy2=&quot;237.46712802768167&quot; data-fileid=&quot;510168181&quot; data-ratio=&quot;0.21389645776566757&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eZzl4LXykQwbM0dAtHdzIqKgibcmicic2gwQS6HY5lzj2NBhurpTVM0u7nsbjGpa2tsB37iccAhpTp8C7YbbwgHhFg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;734&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设现在我们要查询 2 这条数据，那么在通过索引树找到 2 的时候，存储引擎并没有停止搜索。&lt;/span&gt;&lt;span&gt;因为可能存在多个 &lt;/span&gt;&lt;span&gt;2，这表现为存储引擎会在叶子节点上接着向后查找&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;在找到第二个2之后，就停止了吗？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案是“否”，因为存储引擎并不知道后面还有没有更多的2，所以得接着向后查找，直至找到第一个不是2的数据，也就是3。找到3之后，停止检索，这就是普通索引的检索过程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;唯一索引就不一样了，因为唯一性，不可能存在重复的数据。所以，在检索到我们的目标数据之后直接返回，不会像普通索引那样还要向后多查找一次。从这个角度来看，唯一索引是要比普通索引快的。但是当普通索引的数据都在一个页内的话，其实也并不会快多少。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在数据的插入方面，唯一索引可能就稍逊色。因为唯一性，每次插入的时候，都需要将判断要插入的数据是否已经存在，而普通索引不需要这个逻辑，并且很重要的一点是唯一索引会用不到 change buffer（见下文）。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.&lt;span&gt;6 不要盲目加索引&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在工作中，你可能会遇到这样的情况：&lt;/span&gt;&lt;span&gt;这个字段我需不需要加索引？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于这个问题，我们常用的判断手段就是：查询会不会用到这个字段，如果这个字段经常在查询的条件中，我们可能会考虑加个索引。&lt;/span&gt;&lt;span&gt;但是如果只根据这个条件判断，你可能会加了一个错误的索引。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;我们来看个例子：&lt;/span&gt;&lt;span&gt;假设有张用户表，大概有 100 万的数据。用户表中有个性别字段表示男女，男女差不多各占一半。现在我们要统计所有男生的信息，然后我们给性别字段加了索引，并且我们这样写下了 SQL：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; sex=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;男&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果不出意外的话，InnoDB 是不会选择性别这个索引的。如果走性别索引，那么一定是需要回表的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在数据量很大的情况下，回表会造成什么样的后果？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我贴一张和上面一样的图想必大家都知道了：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUHAvRwQMxpJ0YDj4icc1ibwoERjs4E9v2o3rr8t4gWfVFcHM9P0ZnZCibqbM95FkhMQTuibiaiaFkO8jKW7ac1jLsAA/640?wx_fmt=png&quot; data-cropx1=&quot;166.2975778546713&quot; data-cropx2=&quot;874.4636678200692&quot; data-cropy1=&quot;89.68858131487889&quot; data-cropy2=&quot;457.7854671280276&quot; data-fileid=&quot;510168180&quot; data-ratio=&quot;0.519774011299435&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eZzl4LXykQwbM0dAtHdzIqKgibcmicic2gw4kO9xoGBSYavckJh1SQ4Dr00asJoZPStlUWUpVjcMpSzKRYvgDOhgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;708&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主要就是大量的 IO。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一条数据需要 4 次，那么 50 万的数据呢？结果可想而知。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此针对这种情况，MySQL 的优化器大概率走全表扫描，直接扫描主键索引。因为这样性能可能会更高。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1.7 索引失效那些事&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;某些情况下，因为我们自己使用的不当，导致 &lt;span&gt;MySQL&lt;/span&gt; 用不到索引。这一般很容易发生在类型转换方面。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;也许你会说，&lt;span&gt;MySQL&lt;/span&gt; 不是已经支持隐式转换了吗？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如现在有个整型的 user_id 索引字段，我们因为查询的时候没注意，写成了：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; xx &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; user_id=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;1234&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意：这里是字符的 1234。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当发生这种情况下，MySQL 确实足够聪明，会把字符的 1234 转成数字的 1234，然后愉快的使用了 user_id 索引。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是如果我们有个字符型的 user_id 索引字段，还是因为我们查询的时候没注意，写成了：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; xx &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; user_id=&lt;span class=&quot;code-snippet__number&quot;&gt;1234&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这时候就有问题了，这样不会用到索引。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;也许你会问，这时 MySQL 为什么不会转换了，把数字的 1234 转成字符型的 1234 不就行了？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里需要解释下转换的规则了。当出现字符串和数字比较的时候，要记住：MySQL 会把字符串转换成数字。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;也许你又会问：为什么把字符型 user_id 字段转换成数字就用不到索引了?&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这又要说到 B+ 树索引的结构了。我们知道 B+ 树的索引是按照索引的值来分叉和排序的，当我们把索引字段发生类型转换时会发生值的变化。比如原来是 A 值，如果执行整型转换可能会对应一个 B 值（int(A)=B），这时这颗索引树就不能用了，因为索引树是按照 A 来构造的，不是 B，所以会用不到索引。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2. 索引优化&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2.1 change buffer&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们知道在更新一条数据的时候，要先判断这条数据的页是否在内存里。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果在内存中的话，直接更新对应的内存页；如果不在的话，只能去磁盘把对应的数据页读到内存中来，然后再更新。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这会有什么问题呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;去磁盘的读这个动作稍显的有点慢；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果同时更新很多数据，那么即有可能发生很多离散的 IO。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决这种情况下的速度问题，change buffer 出现了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，不要被 buffer 这个单词误导。change buffer 除了会在公共的 buffer pool 里之外，也是会持久化到磁盘的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;span&gt;当有了 change buffer 之后，我们更新的过程中，如果发现对应的数据页不在内存里的话，也不去磁盘读取相应的数据页了，而是把要更新的数据放入到 change buffer 中。&lt;/span&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那 change buffer 的数据何时被同步到磁盘上去？如果此时发生读动作怎么办？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;span&gt;首先，后台有个线程会定期把 change buffer 的数据同步到磁盘上去的。如果线程还没来得及同步，但是又发生了读操作，那么也会触发把 change buffer 的数据 merge 到磁盘的事件。&lt;/span&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUHAvRwQMxpJ0YDj4icc1ibwoERjs4E9v22n1frVbnLMNu5uGpwoib4U53WzPnJbsK30oVHBsRvkaZ6QPicAyeWULQ/640?wx_fmt=png&quot; data-cropx1=&quot;115.8477508650519&quot; data-cropx2=&quot;952.9411764705882&quot; data-cropy1=&quot;57.92387543252595&quot; data-cropy2=&quot;388.65051903114187&quot; data-fileid=&quot;510168178&quot; data-ratio=&quot;0.3954599761051374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eZzl4LXykQwbM0dAtHdzIqKgibcmicic2gww6ZAjbaibBsOpG7QibH35WfFvuyQVzibL4BGFZyC4hSIZIkSCNeGiaXL3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;837&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需要注意的是，并不是所有的索引都能用到 changer buffer。像主键索引和唯一索引就用不到。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为唯一性，所以它们在更新的时候要判断数据存不存在。如果数据页不在内存中，就必须去磁盘上把对应的数据页读到内存里，而普通索引就没关系了，不需要校验唯一性。&lt;/span&gt;&lt;span&gt;change buffer &lt;/span&gt;&lt;span&gt;越大，理论收益就越大，这是因为首先离散的读 &lt;/span&gt;&lt;span&gt;IO &lt;/span&gt;&lt;span&gt;变少了&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其次，当一个数据页上发生多次变更，只需 merge 一次到磁盘上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然并不是所有的场景都适合 change buffer。如果你的业务是更新之后，需要立马去读，change buffer 会适得其反。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为需要不停地触发 merge 动作，导致随机 IO 的次数不会变少，反而增加了维护 change buffer 的开销。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2.2 索引下推&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面我们说了联合索引，联合索引要满足最左原则，即在联合索引是 [A,B] 的情况下，我们可以通过以下的 SQL 用到索引：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; A=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;xx&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; A=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;xx&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;AND&lt;/span&gt; B=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;xx&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实联合索引也可以使用最左前缀的原则，即：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; A &lt;span class=&quot;code-snippet__keyword&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;赵%&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;AND&lt;/span&gt; B=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;上海市&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是这里需要注意的是，因为使用了 A 的一部分，在 MySQL 5.6 之前，上面的 SQL 在检索出所有 A 是“赵”开头的数据之后，就立马回表（使用的 select *）。&lt;/span&gt;&lt;span&gt;然后，&lt;/span&gt;&lt;span&gt;再对比 B &lt;/span&gt;&lt;span&gt;是不是“上海市”这个判断&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里是不是有点懵？&lt;/span&gt;&lt;span&gt;为什么 &lt;/span&gt;&lt;span&gt;B &lt;/span&gt;&lt;span&gt;这个判&lt;/span&gt;&lt;span&gt;断不直接在联合索引上判断，这样的话回表的次数不就少了吗？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;造成这个问题的原因还是因为使用了最左前缀的问题。导致索引虽然能使用部分 A，但是完全用不到 B，看起来是有点“傻”。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;于是在 MySQL5.6 之后，就出现了索引下推这个优化（Index Condition Pushdown）。有了这个功能以后，虽然使用的是最左前缀，但是也可以在联合索引上搜索出符合 A% 的同时也过滤非 B 的数据，大大减少了回表的次数。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUHAvRwQMxpJ0YDj4icc1ibwoERjs4E9v2YqVZlpJYkPWbRhiaAcEGN6icG6Q4FIWiccSuXEvGk8ZK8icNrkjjXXQBNQ/640?wx_fmt=png&quot; data-cropx1=&quot;166.2975778546713&quot; data-cropx2=&quot;837.0934256055364&quot; data-cropy1=&quot;61.66089965397923&quot; data-cropy2=&quot;517.5778546712802&quot; data-fileid=&quot;510168177&quot; data-ratio=&quot;0.6795827123695977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eZzl4LXykQwbM0dAtHdzIqKgibcmicic2gwdLC4rtO91sbas86FJwtlU1BMQHEYZypxokbCBribXQibCoG1NoVeEBxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;671&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2.3 刷新邻接页&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在说刷新邻接页之前，我们先说下脏页。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们知道在更新一条数据的时候，得先判断这条数据所在的页是否在内存中。如果不在内存中的话，需要把这个数据页先读到内存中，然后再更新内存中的数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这时会发现内存中的页有最新的数据，但是磁盘上的页却依然是老数据，那么此时这条数据所在的内存中的页就是脏页，需要刷到磁盘上来保持一致。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以问题来了，何时刷？每次刷多少脏页才合适？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果每次变更就刷，那么性能会很差，如果很久才刷，脏页就会堆积很多，造成内存池中可用的页变少，进而影响正常的功能。所以刷的速度不能太快但要及时。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MySQL 有个清理线程会定期执行，保证了不会太快。当脏页太多或者 redo log 已经快满了也会立刻触发刷盘，保证了及时。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUHAvRwQMxpJ0YDj4icc1ibwoERjs4E9v2WPiahhD7g72hEDD8icRUBypZktDpToB0G9Calw87oJiaA58mY8pyiaPgZg/640?wx_fmt=png&quot; data-cropx1=&quot;123.32179930795847&quot; data-cropx2=&quot;939.8615916955017&quot; data-cropy1=&quot;50.44982698961937&quot; data-cropy2=&quot;575.5017301038062&quot; data-fileid=&quot;510168179&quot; data-ratio=&quot;0.6433823529411765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eZzl4LXykQwbM0dAtHdzIqKgibcmicic2gwHosIa5WicZyVKTz4jxnxKmMk98kpsOj98fWMkKT1x3EmiaxrquLCHLfA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;816&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在脏页刷盘的过程中，InnoDB 这里有个优化：如果要刷的脏页的邻居页也脏了，那么就顺带一起刷。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样的好处就是可以减少随机 IO，在机械磁盘的情况下，优化应该挺大。但是这里可能会有坑。如果当前脏页的邻居脏页在被一起刷入后，邻居页立马因为数据的变更又变脏了，那此时是不是有种多此一举的感觉，并且反而浪费了时间和开销。更糟糕的是如果邻居页的邻居也是脏页...，那么这个连锁反应可能会出现短暂的性能问题。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2.4 MRR&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在实际业务中，我们可能会被告知尽量使用覆盖索引，不要回表。因为回表需要更多 IO，耗时更长。但是有时候我们又不得不回表，回表不仅仅会造成过多的 IO，更严重的是过多的离散 IO。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; grade &lt;span class=&quot;code-snippet__keyword&quot;&gt;between&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;70&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在要查询成绩在 60-70 之间的用户信息，于是我们的 SQL 写成上面的那样。当然，我们的 grade 字段是有索引的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;按照常理来说，会先在 grade 索引上找到 grade=60 这条数据，然后再根据 grade=60 这条数据对应的 id 去主键索引上找，最后再次回到 grade 索引上，不停重复同样的动作……&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设现在：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;grade=60 对应的 id=1，数据是在 page_no_1 上；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;grade=61 对应的 id=10，数据是在 page_no_2 上；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;grade=62 对应的 id=2，数据是在 page_no_1上。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，真实的情况就是先在 page_no_1 上找数据，然后切到 page_no_2，最后又切回 page_no_1 上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但其实 id=1 和 id=2 完全可以合并，读一次 page_no_1 即可。不仅节省了 IO，同时避免了随机 IO，这就是 MRR。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当使用 MRR 之后，辅助索引不会立即去回表，而是将得到的主键 id，放在一个 buffer中。然后再对其排序，排序后再去顺序读主键索引，大大减少了离散的 IO。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/WUHAvRwQMxpJ0YDj4icc1ibwoERjs4E9v20b679sEkE5JUIFcn1UiaqIIHAttib0Zw6gO2cKviczdIde1tuzPXFgZDA/640?wx_fmt=png&quot; data-cropx1=&quot;162.56055363321798&quot; data-cropx2=&quot;928.6505190311418&quot; data-cropy1=&quot;28.027681660899653&quot; data-cropy2=&quot;254.11764705882354&quot; data-fileid=&quot;510168186&quot; data-ratio=&quot;0.2950391644908616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eZzl4LXykQwbM0dAtHdzIqKgibcmicic2gwib4lJvY4icXgbsWaQQBXtR2NpzmAITEicxnBiaOOfLoaeCkjiadn2wc7Yug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;766&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651487035&amp;amp;idx=2&amp;amp;sn=62fed3c8081eacd8a81a90544c51c90d&amp;amp;chksm=bd2517448a529e5216b4d278ce28b4e83212cc85b09572b77f712d730699a9cf8e8e19ed52f2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一次关于 Mysql 索引优化的思考&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一次关于 Mysql 索引优化的思考&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651481295&amp;amp;idx=2&amp;amp;sn=1e0752b79e3eade8ba1e29a05820ca46&amp;amp;chksm=bd2508b08a5281a6a5a37cb5508b7229013da8417ef29b033e5567546d5cc4d48ce7ee8fa9ca&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;MySQL 性能优化 : 索引和查询优化&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;MySQL 性能优化 : 索引和查询优化&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651503922&amp;amp;idx=2&amp;amp;sn=abb8da9ee2c524c72259bc0743bce7d4&amp;amp;chksm=bd25d14d8a52585b012867371463fe6813bad93e3c625bdcd7d37494845716016a1a3ede10dc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;这篇 MySQL 索引和 B+Tree 讲的太通俗易懂！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;这篇 MySQL 索引和 B+Tree 讲的太通俗易懂！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ab346c25cbff89cadc215b0f4a249ff5</guid>
<title>整洁架构设计分析--架构设计的本质是什么?</title>
<link>https://toutiao.io/k/10u1cak</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信很多同学也看过整洁架构之道这本书啦，我之前也是查阅过网上的一些读书笔记，大部分都是简短总结性的，看了之后记忆不是很深刻(一方面看得次数不够)。So土拨鼠决定好好读一下Bob大叔的 &lt;strong&gt;《Clean Architecture-A CRAFTSMAN’S GUIDE TO SOFTWARE STRUCTURE AND DESIGN》&lt;/strong&gt; ，土拨鼠这里看的在线双语版的（主要是便于做笔记、方便回顾），中文翻译版参考的是福哥创建的&lt;span&gt;书栈网&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;的上&lt;span&gt;《架构整洁之道》中文翻译版&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;。发现书中的一些图是缺失的，土拨鼠就拿着英文版本的对照着看。暂时先阅读了第一部分，其中Bob大叔也举了几个现实中真真切切的例子。下面主要记录一下第一部分的关于整洁架构的概述内容。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Bob大叔的站点介绍&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;bob大叔的个人简介&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;The Clean Code Blog&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;Uncle Bob Martin 博客&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;曹大的《clean architecture》读书笔记&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;曹大笔记中评价还是很犀利的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;书评：《Clean Architecture》 写的很好，就是有点反反复复。最核心的观点实际上就是借助 interface 实现的多态和依赖反转。不过能把软件工程发展史串起来还是挺不错的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;clean architecture(上)&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;clean architecture(下)&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;lailin的架构整洁之道阅读笔记&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lailin总结的也很细致，主要对书中的每个章节做了总结。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第一部分的主题内容&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一部分主要是关于本书的概述，概述中Bob大叔通过软件系统好坏的简短例子说明了一个好的架构的重要性（节省成本、简单稳定、易于实施维护、灵活）。两个章节主要解释了设计和架构关系、介绍了行为和架构两个价值维度。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Chap1. WHAT IS DESIGN AND ARCHITECTURE? &lt;strong&gt;设计与架构到底是什么&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;The Signature Of A Mess  一个混乱系统的特点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;The Executive View 管理层视角&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;What Went Wrong? 问题到底在哪里&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;The Goal? 目标是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Case Study 案例分析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Conclusion 小结&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Chap2.  A Tale of Two Value &lt;strong&gt;两个价值维度&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Behavior  行为的价值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Architecture  架构的价值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;The Greater Value   哪个价值维度更重要&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Eisenhower’s Matrix  艾森豪威尔矩阵&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Fight for the Architecture 为好的软件架构而持续斗争&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Chap1.设计与架构到底是什么&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本书的一个重要的目标就是要清晰、明确地对设计（Design）与架构（Architecture）进行定义。Bob大叔看来二者没有任何区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;架构&lt;/strong&gt;一般使用于“高层级”的讨论中，然而往往会把“底层”的实现细节排除在外。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;设计往往用来指代具体的系统底层组织结构和实现的细节&lt;/strong&gt;。但对于一个真正的系统架构师的日常工作来看，这样的区分是根本不成立的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿新房子来说应该包括房屋的形状、外观设计、垂直高度、房间的布局等等，还有每个插座、开关以及每个电灯具体的安装位置等具体的说明。总的来说，架构图里实际上包含了所有的底层设计细节，底层设计信息和顶层架构设计共同组成了整个房屋的架构文档。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件设计也是如此。底层设计细节和高层架构信息是不可分割的。它们组合在一起，共同定义了整个软件系统，缺一不可。所谓的底层和高层本身就是一系列决策组成的连续体，并没有清晰的分界线。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;目标&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个好的软件设计的终极目标是什么呢：&lt;strong&gt;软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个软件架构的优劣，可以用它满足用户需求所需要的成本来衡量。&lt;strong&gt;如果该系统的每次发布都会提升下一次变更的成本，那么这个设计就是不好的。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;案例分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图1.1展示的是 &lt;strong&gt;工程师团队规模随着产品的增长&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6340579710144928&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1104&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqYqgGubZaKwfdzaYLaQxicIfF0NHYYuEUd4CyHR3ZUM28NibfjqfkwqDdYc7Y2wic9Qfw14lkMW2eUsA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图1.2展示的是 &lt;strong&gt;公司同期的生产效率（productivity）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;纵坐标KLOC：&lt;/strong&gt;千行代码（&lt;strong&gt;KLOC&lt;/strong&gt;）是一种用于评估软件程序大小的度量。&lt;strong&gt;KLOC&lt;/strong&gt;通常用于估计团队构建项目所需的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6848739495798319&quot; data-type=&quot;png&quot; data-w=&quot;952&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqYqgGubZaKwfdzaYLaQxicIfgqVbDg2R5W0dibjz9XeH7xtO2uVfnpvwfvQaXMLh6I1dg19yPqqg4MA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图 1.3 展示的是&lt;strong&gt;同期内每行代码的变更成本&lt;/strong&gt;。可以看出变更代码成本越来越高，按这个趋势下去，公司的利润甚至会被一点点榨干。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7982832618025751&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;932&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqYqgGubZaKwfdzaYLaQxicIfrYsgOle4pogdXaWZzWtdG9DvReFe7EEOdnncoKrS5TSptRdNNs8pEg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一个混乱系统的特点&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;混乱系统一般都是&lt;/span&gt;&lt;strong&gt;没有经过设计&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;strong&gt;匆匆忙忙被构建起来的&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;然后为了加快发布的速度，拼命地往团队里加入新人，同时加上决策层对代码质量提升和设计结构优化存在着持续的、长久的忽视。&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图 1.4 展示了&lt;strong&gt;系统开发者的生产力的切身体会&lt;/strong&gt;。他们一开始的效率都接近 100%，然而伴随着每次产品的发布，他们的生产力直线下降。到了产品的第 4 版本时，很明显大家的生产力已经不可避免地趋近为零了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7393075356415478&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqYqgGubZaKwfdzaYLaQxicIfibOOibpOyzCPlE2wqYUicvM3xBRJsLD7NqOxeicwMfP6ogyI7icuklUJ3ww/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工程师的大部分时间都消耗在对现有系统的修修补补上，而不是真正完成实际的新功能。这些工程师真正的任务是：拆了东墙补西墙，周而复始。偶尔有精力能顺便实现一点小功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;管理层视角&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图 1.5展示的是&lt;strong&gt;该部门同期的月工资图&lt;/strong&gt;。也许我们可以指望该公司的营收增长远远超出成本增长，这样公司就还能维持正常运转。但是这么惊人的曲线还是值得我们深入挖掘其中存在的巨大问题的。是什么造成了工程师生产力的直线下降？高管们除了跺脚、发飙，还能做什么呢？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6428571428571429&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;952&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqYqgGubZaKwfdzaYLaQxicIfMbvSgpKZXKibv9x3nsDxrgiaYiayoZibkg2ibOSAJTwrHoibicQDtfdXKksow/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;问题到底出在了哪里&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里Bob大叔举了一个龟兔赛跑的例子，这里归纳了一下主题思想：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;慢而稳，才是成功的秘诀。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该比赛并不是拼谁开始跑得快，也不是拼谁更有力气。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;心态越急，反而跑得越慢。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个故事本身揭露的是过度自信的愚蠢行为。这和现代软件研发工作有点类似，现在的软件研发工程师都有点过于自信。但他们确实不会偷懒。但是他们真正偷懒的地方在于——&lt;strong&gt;持续低估那些精心设计的、整洁的代码的重要性&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而工程师们常常会这样欺骗自己：“我们可以未来再重构代码，产品上线最重要！”但是结果大家都知道，产品上线以后重构工作就再没人提起了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工程师们经常相信的另外一个错误观点是：“在项目中容忍糟糕的代码存在可以在短期内加快该工程上线的速度，未来这些代码会造成一些额外的工作量，但并没有什么大不了。”相信这些鬼话的工程师对自己清理混乱代码的能力过于自信了。但是更重要的是，他们还忽视了一个自然规律：&lt;strong&gt;无论是从短期还是长期来看，胡乱编写代码的工作速度其实比循规蹈矩更慢。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图 1.6 展示的是 &lt;strong&gt;Jason Gorman 进行的一次为期 6 天的实验&lt;/strong&gt;。可以看出往后完成工作所需的时间越来越少。同时，也可以看到当采用了 TDD 方法编程后，比未采用 TDD 方法编程少用 10%的时间，并且采用 TDD 方法编程时最差的一天也比未采用 TDD 方法编程时最好的一天用时要短。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这个结果，它其实揭示了软件开发的一个核心特点：&lt;strong&gt;要想跑得快，先要跑得稳。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以管理层扭转局面的唯一选择就是扭转开发者的观念，让他们从过度自信的兔子模式转变回来，为自己构建的混乱系统负起责任来。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8013100436681223&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;916&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqYqgGubZaKwfdzaYLaQxicIfe0NTt2Pyib0nc14XYiawBzVSicpw0icjKkh8NoFSVWB27ZhQBZB6T7DkZQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这本书的主题就是为读者描述了什么是优秀的、整洁的软件架构与设计，读者可以参考这些设计来构建一个长期稳定的、持久优秀的系统。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;不管怎么看，研发团队最好的选择是清晰地认识并避开工程师们过度自信的特点，开始认真地对待自己的代码架构，对其质量负责。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;要想提高自己软件架构的质量，就需要先知道什么是优秀的软件架构。而为了在系统构建过程中采用好的设计和架构以便减少构建成本，提高生产力，就需要先了解系统架构的各种属性与成本和生产力的关系。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Chap2.两个价值维度&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于每个软件系统，我们都对以通过行为和架构两个维度来体现它的实际价值。然而工程师往往只关注一个维度，而忽视了另外一个维度。而且常常关注的还是错误的维度，这导致了系统的价值最终趋降为零。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;行为价值&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;软件系统的行为是其最直观的价值维度。&lt;/strong&gt; 大部分程序员认为他们的工作是且仅是：按照需求文档编写代码，并且修复任何 Bug。这真是大错特错。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;架构价值&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;软件系统的第二个价值维度&lt;/strong&gt;，就体现在软件这个英文单词上：software。“ware” 的意思是“产品”，而 “soft” 的意思，不言而喻，是指&lt;strong&gt;软件的灵活性。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件系统必须保持灵活。软件发明的目的，就是让我们可以以一种灵活的方式来改变机器的工作行为。对机器上那些很难改变的工作行为，我们通常称之为硬件（hardware）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了达到软件的本来目的，软件系统必须够“软” 也就是说，软件应该容易被修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;需求变更的范畴与形状，是决定对应软件变更实施成本高低的关键。&lt;/strong&gt; 这就是为什么有的代码变更的成本与其实现的功能改变不成比例。这也是为什么第二年的研发成本比第一年的高很多，第三年又比第二年更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题的实际根源当然就是系统的架构设计。如果系统的架构设计偏向某种特定的“形状”，那么新的变更就会越来越难以实施。所以，好的系统架构设计应该尽可能做到与“形状”无关。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;哪个价值维度更重要呢？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务部门来回答，他们通常认为系统正常工作很重要。系统开发人员常常也就跟随采取了这种态度。bob大叔这里用了下面简单的逻辑推导来证明这个态度的错误性。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果某程序可以正常工作，但是无法修改，那么当需求变更的时候它就不再能够正常工作了，我们也无法通过修改让它能继续正常工作。因此，这个程序的价值将成为 0。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果某程序目前无法正常工作，但是我们可以很容易地修改它，那么将它改好，并且随着需求变化不停地修改它，都应该是很容易的事。因此，这个程序会持续产生价值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你问业务部门，是否想要能够变更需求，他们的回答一般是肯定的，而且他们会增加一句：完成现在的功能比实现未来的灵活度更重要。但讽刺的是，如果事后业务部门提出了一项需求，而你的预估工作量大大超出他们的预期，这帮家伙通常会对你放任系统混乱到无法变更的状态而勃然大怒。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;艾森豪威尔矩阵&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图2.1展示的是&lt;strong&gt;美国前总统艾森豪威尔的紧急/重要矩阵&lt;/strong&gt;。面对这个矩阵，艾森豪威尔曾说道：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我有两种难题：紧急的和重要的，而紧急的难题永远是不重要的，重要的难题永远是不紧急的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确实，紧急的事情常常没那么重要，而重要的事情则似乎永远也排不上优先级。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件系统的第一个价值维度：&lt;strong&gt;系统行为，是紧急的，但是并不总是特别重要。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件系统的第二个价值维度：&lt;strong&gt;系统架构，是重要的，但是并不总是特别紧急。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出软件的系统架构——那些重要的事情——占据了该列表的前两位，而系统行为——那些紧急的事情——只占据了第一和第三位。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6603375527426161&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;948&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqYqgGubZaKwfdzaYLaQxicIfT8TaAesxZVFSiaPxhJHvw70328icUfWAic3pzgFXLGMuhN7lGaf0moKvg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平衡系统架构的重要性与功能的紧急程度这件事，是软件研发人员自己的职责。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;为好的软件架构而持续斗争&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了做好上述职责，软件团队必须做好斗争的准备——或者说“长期抗争”的准备。现状就是这样。研发团队必须从公司长远利益出发与其他部门抗争，这和管理团队的工作一样，甚至市场团队、销售团队、运营团队都是这样。公司内部的抗争本来就是无止境的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你是软件架构师，那么这项工作就加倍重要了。软件架构师这一职责本身就应更关注系统的整体结构，而不是具体的功能和系统行为的实现，&lt;strong&gt;软件架构师必须创建出一个可以让功能实现起来更容易、修改起来更简单、扩展起来更轻松的软件架构&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记住：如果忽视软件架构的价值，系统将会变得越来越难以维护，终会有一天，系统将会变得再也无法修改。如果系统变成了这个样子，那么说明软件开发团队没有和需求方做足够的抗争，没有完成自己应尽的职责。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;名言警句：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;底层设计和高层架构是密不可分的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无论是从短期还是长期来看，胡乱编写代码的工作速度其实比循规蹈矩更慢。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;要想跑得快，先要跑得稳。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软件系统两个价值维度：系统行为，是紧急的，但是并不总是特别重要。系统架构，是重要的，但是并不总是特别紧急。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为好的软件架构而持续斗争。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于整洁架构之道的第一部分关于本书的概述读书笔记土拨鼠今天就介绍到这里了。第二部分从编程范式开始，敬请期待。如果有不同见解欢迎留言讨论。&lt;/p&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1640181116488_0.7938122147892885&quot; data-uid=&quot;1640181116397&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;12447192&quot; data-categoryid=&quot;3&quot; data-appuin=&quot;3208869061&quot;/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;书栈网: &lt;span&gt;https://www.bookstack.cn/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;《架构整洁之道》中文翻译版: &lt;span&gt;https://www.bookstack.cn/books/Clean-Architecture-zh&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;bob大叔的个人简介: &lt;span&gt;http://cleancoder.com/files/about.md&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;The Clean Code Blog: &lt;span&gt;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Uncle Bob Martin 博客: &lt;span&gt;http://cleancoder.com/products&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;clean architecture(上): &lt;span&gt;https://xargin.com/clean-architecture-1/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;clean architecture(下): &lt;span&gt;https://xargin.com/clean-architecture-2/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;Go工程化(一) 架构整洁之道阅读笔记: &lt;span&gt;https://lailin.xyz/post/go-training-week4-clean-arch.html&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>120e47da5d2ff84c5135eea5eebc3303</guid>
<title>巧用符号链接迁移 HDFS 数据，业务完全无感知！</title>
<link>https://toutiao.io/k/aogsbx6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post_content markdown&quot;&gt;&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;&lt;p&gt;JuiceFS 是一个基于对象存储的分布式文件系统，在之前跟对象存储比较的&lt;a href=&quot;https://juicefs.com/blog/cn/posts/globalegrow-big-data-platform-user-case&quot;&gt;文章&lt;/a&gt;中已经介绍了 JuiceFS 能够保证数据的强一致性和极高的读写性能，因此完全可以用来替代 HDFS。但是数据平台整体迁移通常是一个费时费力的大工程，需要做到迁移超大规模数据的同时尽量不影响上层业务。下面将会介绍如何通过 JuiceFS 的迁移工具来实现平滑迁移 HDFS 中的海量数据到 JuiceFS。&lt;/p&gt;&lt;h2 id=&quot;平滑迁移方案&quot;&gt;平滑迁移方案&lt;/h2&gt;&lt;p&gt;数据平台除了我们在 HDFS 上实际看到的文件以外，其实还有一些同样重要的信息，也就是所谓的「元数据」，这些元数据存储在类似 Hive Metastore 这样的系统里。因此当我们谈论数据迁移时不能把这两种数据拆分开来，必须同时考虑，迁移完数据以后需要同时更新 Hive 表或者分区的位置（&lt;code&gt;LOCATION&lt;/code&gt;）信息，如果任何一种数据出了问题都会对业务方造成影响。&lt;/p&gt;&lt;p&gt;为了保证数据和元数据的一致性，通常的做法是在迁移完数据以后同步更新元数据中的位置信息，但当数据规模比较大，并且业务又可能更新数据时，很难保证数据拷贝和更新位置信息是个原子操作，迁移过程中可能导致数据丢失，影响整体迁移的可靠性。甚至需要以暂停业务为代价来实现，或者在业务中采用双写等机制来实现在线迁移，侵入业务逻辑，费时费力。&lt;/p&gt;&lt;p&gt;如果能够在迁移过程中为数据访问提供统一的路径来屏蔽实际的数据位置，实现元数据和真实数据位置的解耦，将会大大降低整体迁移的风险。文件系统的符号链接就可以达到这个效果，JuiceFS 也支持符号链接，并且支持跨文件系统的符号链接，借助它可以为多个文件系统提供统一的访问入口，形成统一命名空间。&lt;/p&gt;&lt;p&gt;符号链接是操作系统中广泛应用的概念，你可以通过符号链接实现在一个目录树中管理分散在各个地方的数据。对应的，我们也可以通过 JuiceFS 的符号链接特性实现在一个文件系统中管理多个存储系统。其实符号链接这个功能早在 2013 年 Hadoop 社区就已经想要在 HDFS 上实现（&lt;a href=&quot;https://issues.apache.org/jira/browse/HADOOP-10019&quot;&gt;HADOOP-10019&lt;/a&gt;），但遗憾的是目前为止还没完整支持。借助符号链接即可在 JuiceFS 上管理包括但不限于 HDFS、对象存储在内的各种存储系统，表面上看起来访问的是 JuiceFS，但实际访问的是底层真实的存储。&lt;/p&gt;&lt;p&gt;同时，JuiceFS 的原子重命名（rename）操作也能在数据迁移过程中发挥关键作用。JuiceFS 通过符号链接来跳转回原始数据，但当数据完全拷贝过来以后需要覆盖这个符号链接，这个时候原子重命名就能保证数据的安全性和可靠性，避免出现数据丢失和损坏。&lt;/p&gt;&lt;p&gt;此外，JuiceFS 还可以通过配置文件和特殊的标志文件来动态感知到迁移过程，并在新增和删除文件时进行额外的检查，确保新创建的文件也会出现在迁移后的目录中，并且确保要删除的文件也能从新系统中删掉。对于更复杂的重命名操作，也有类似的机制来保证正确性。&lt;/p&gt;&lt;p&gt;有了刚才介绍的 JuiceFS 的这些特性，就可以实现在数据迁移时分别迁移数据和元数据，同时整个迁移过程对于业务是完全透明的。下面讲解具体的迁移操作步骤。&lt;/p&gt;&lt;h2 id=&quot;操作步骤&quot;&gt;操作步骤&lt;/h2&gt;&lt;h3 id=&quot;步骤一-将-juicefs-作为-hdfs-的访问入口&quot;&gt;步骤一：将 JuiceFS 作为 HDFS 的访问入口&lt;/h3&gt;&lt;p&gt;在 JuiceFS 上给 HDFS 的所有第一级目录（或文件）创建对应的符号链接（假定不会再在 HDFS 根目录创建内容），之后通过 &lt;code&gt;jfs://name/&amp;lt;path&amp;gt;&lt;/code&gt; 就能完整访问 HDFS 里面的内容，两者是完全等价的。如下图所示。&lt;/p&gt;&lt;h3 id=&quot;步骤二-使用-juicefs-来访问-hdfs-中的数据&quot;&gt;步骤二：使用 JuiceFS 来访问 HDFS 中的数据&lt;/h3&gt;&lt;p&gt;这一步有两种实现方法。第一种是修改 Hive Metastore 中表或者分区的 &lt;code&gt;LOCATION&lt;/code&gt; 为对应的 JuiceFS 路径，例如之前是 &lt;code&gt;hdfs://ns/user/test.db/table_a&lt;/code&gt;，新路径则为 &lt;code&gt;jfs://name/user/test.db/table_a&lt;/code&gt;。第二种方法是将 &lt;code&gt;fs.hdfs.impl&lt;/code&gt; 修改为 &lt;code&gt;com.juicefs.MigratingFileSystem&lt;/code&gt;，这样可以维持 &lt;code&gt;LOCATION&lt;/code&gt; 不变。&lt;/p&gt;&lt;p&gt;这两种方法的目的都是为了将所有访问 HDFS 的入口改成访问 JuiceFS，因为步骤一已经创建了指向 HDFS 的符号链接，所以不会影响现有业务访问 HDFS。&lt;/p&gt;&lt;h3 id=&quot;步骤三-迁移目录结构&quot;&gt;步骤三：迁移目录结构&lt;/h3&gt;&lt;p&gt;从这一步开始我们会正式进行迁移工作，不过先不着急把数据拷贝过来，我们需要先把目录结构从 HDFS 中映射过来。你可以选择你想要迁移的表或目录，然后通过 JuiceFS 提供的工具快速将 HDFS 上的目录结构迁移到 JuiceFS 上。以迁移 &lt;code&gt;hdfs://ns/user/test.db/table_a&lt;/code&gt; 为例，这个目录中的所有子目录将会逐级在 JuiceFS 中创建。因为这一步仅涉及元数据操作，没有数据拷贝，因此可以以极快的速度将历史数据的目录结构从 HDFS 迁移到 JuiceFS 上。同时需要注意的是，所有文件仍然通过符号链接的方式指向 HDFS 中的路径。如下图所示，红色部分即表示在 JuiceFS 上新创建的目录。&lt;/p&gt;&lt;p&gt;同样的，完成这一步以后不会影响现有业务访问 HDFS，但是新写入的数据将会直接存储到 JuiceFS 中。&lt;/p&gt;&lt;h3 id=&quot;步骤四-迁移数据&quot;&gt;步骤四：迁移数据&lt;/h3&gt;&lt;p&gt;这一步将会真正开始拷贝数据，通过 JuiceFS 的迁移工具并发地将上一步遗留的指向 HDFS 中普通文件的符号链接替换为真实的数据。最终迁移目录中将不再会有符号链接，也就表示这个目录已经迁移完成。如下图所示，红色部分已经从符号链接变成了普通文件。&lt;/p&gt;&lt;h3 id=&quot;步骤五-删除-hdfs-中的数据&quot;&gt;步骤五：删除 HDFS 中的数据&lt;/h3&gt;&lt;p&gt;经过前面几个步骤，已经完成数据和元数据的整体迁移，因此可以放心删除 HDFS 中的数据。&lt;/p&gt;&lt;h3 id=&quot;反向迁移&quot;&gt;反向迁移&lt;/h3&gt;&lt;p&gt;在数据迁移过程中也可以通过反向迁移随时回滚，来撤销迁移操作。如果已经修改了元数据中的位置信息，JuiceFS 迁移工具能确保反向迁移时恢复回原来的状态。如果已经有新增的数据写入到 JuiceFS 中，也能把这些新增数据拷贝回原始的存储系统。&lt;/p&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;通过前面的操作步骤介绍，可以看到整个迁移过程完全不会影响现有业务继续访问 HDFS，从开始到结束对于业务来说都是无感知的。JuiceFS 提供了完善的工具来简化迁移流程，详细的操作指南请参考 JuiceFS &lt;a href=&quot;https://juicefs.com/docs/zh/migrate-data-from-hdfs-to-jfs.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;本篇文章以将 HDFS 迁移到 JuiceFS 为例说明了 JuiceFS 的符号链接特性，其实你完全可以发挥脑洞，把 JuiceFS 的符号链接应用在更多更广的场景，例如在不同 HDFS 集群之间进行数据迁移、跨云跨区的数据迁移等。正是因为有了强大的符号链接特性，通过 JuiceFS 来提供统一的数据访问层和视图，才使得很多时候无法平滑操作的事情成为了可能。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>31f1b4a09334f42611abdfc306fbbcdf</guid>
<title>Kafka集群突破百万partition 的技术探索</title>
<link>https://toutiao.io/k/4lw8h50</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXohrAwRjLmn4EpPFJFoGDjVmFjzY5GzHRC9mhdKiaAocsyf8asib81ibLN4gRYUc7d0eciaONx10WibPA/640?&quot; data-ratio=&quot;0.062037037037037036&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section label=&quot;powered by 135editor.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;导语：&lt;/span&gt;&lt;span&gt;本篇文章主要从元数据，controller 逻辑等方面介绍了如何解决支撑百万 partition 的问题，运营大规模集群其实还涉及到磁盘故障、冷读、数据均衡等数据方面的问题，监控和报警服务同样非常的重要。（编辑：中间件小Q妹）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;01&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于小业务量的业务，往往多个业务共享 kafka 集群，随着业务规模的增长需要不停的增加 topic 或者是在原 topic 的基础上扩容 partition 数，另外一些后来大体量的业务在试水阶段也可能不会部署独立的集群，当业务规模爆发时，需要迅速扩容扩容集群节点。在不牺牲稳定性的前提下单集群规模有限，常常会碰到业务体量变大后无法在原集群上直接进行扩容，只能让业务创建新的集群来支撑新增的业务量，这时用户面临系统变更的成本，有时由于业务关联的原因，集群分开后涉及到业务部署方案的改变，很难短时间解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了快速支持业务扩容，就需要我们在不需要业务方做任何改动的前提下对集群进行扩容，大规模的集群，往往意味着更多的 partition 数，更多的 broker 节点，下面会描述当集群规模增长后主要面临哪些方面的挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;02&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;挑战&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. ZK 节点数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Kafka 的 topic 在 broker 上是以 partition 为最小单位存放和进行复制的, 因此集群需要维护每个 partition 的 Leader 信息，单个 partition 的多个副本都存放在哪些 broker 节点上，处于复制同步状态的副本都有哪些。为了存放这些元数据，kafka 集群会为每一个 partition 在 zk 集群上创建一个节点，partition 的数量直接决定了 zk 上的节点数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设集群上有 1 万个 topic，每个 topic 包含 100 个 partition，则 ZK 上节点数约为 200 多万个，快照大小约为 300MB，ZK 节点数据变更，会把数据会写在事务日志中进行持久化存储，当事务日志达到一定的条目会全量写入数据到持久化快照文件中，partition 节点数扩大意味着快照文件也大，全量写入快照与事务日志的写入会相互影响，从而影响客户端的响应速度，同时 zk 节点重启加载快照的时间也会变长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. Partition 复制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka 的 partition 复制由独立的复制线程负责，多个 partition 会共用复制线程，当单个 broker 上的 partition 增大以后，单个复制线程负责的 partition 数也会增多，每个 partition 对应一个日志文件，当大量的 partition 同时有写入时，磁盘上文件的写入也会更分散，写入性能变差，可能出现复制跟不上，导致 ISR 频繁波动，调整复制线程的数量可以减少单个线程负责的 partition 数量，但是也加剧了磁盘的争用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. Controller 切换时长&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于网络或者机器故障等原因，运行中的集群可能存在 controller 切换的情况，当 controller 切换时需要从 ZK 中恢复 broker 节点信息、topic 的 partition 复制关系、partition 当前 leader 在哪个节点上等，然后会把 partition 完整的信息同步给每一个 broker 节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在虚拟机上测试，100 万 partition 的元数据从 ZK 恢复到 broker 上约需要 37s 的时间，100 万 partition 生成的元数据序列化后大约 80MB（数据大小与副本数、topic 名字长度等相关），其他 broker 接收到元数据后，进行反序列化并更新到本机 broker 内存中，应答响应时间约需要 40s（测试时长与网络环境有关）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Controller 控制了 leader 切换与元数据的下发给集群中其他 broker 节点，controller 的恢复时间变长增加了集群不可用风险，当 controller 切换时如果存在 partition 的 Leader 需要切换，就可能存在客户端比较长的时间内拿不到新的 leader，导致服务中断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. broker 上下线恢复时长&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日常维护中可能需要对 broker 进行重启操作，为了不影响用户使用，broker 在停止前会通知 controller 进行 Leader 切换，同样 broker 故障时也会进行 leader 切换，leader 切换信息需要更新 ZK 上的 partition 状态节点数据，并同步给其他的 broker 进行 metadata 信息更新。当 partition 数量变多，意味着单个 broker 节点上的 partitiion Leader 切换时间变长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上述几个影响因素，我们知道当 partition 数量增加时会直接影响到 controller 故障恢复时间；单个 broker 上 partition 数量增多会影响磁盘性能，复制的稳定性；broker 重启 Leader 切换时间增加等。当然我们完全可以在现有的架构下限制每个 broker 上的 partition 数量，来规避单 broker 上受 partition 数量的影响，但是这样意味着集群内 broker 节点数会增加，controller 负责的 broker 节点数增加，同时 controller 需要管理的 partition 数并不会减少，如果我们想解决大量 partition 共用一个集群的场景，那么核心需要解决的问题就是要么提升单个 controller 的处理性能能力，要么增加 controller 的数量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;03&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 单 ZK 集群&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从提升单个 controller 处理性能方面可以进行下面的优化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Controller 在拉取 zk 上的元数据时，虽然采用了异步等待数据响应的方式，请求和应答非串行等待，但是单线程处理消耗了大约 37s，我们可以通过多线程并行拉取元数据，每个线程负责一部分 partition，从而缩减拉取元数据的时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在虚拟机上简单模拟获取 100 万个节点数据，单线程约花费 28s，分散到 5 个线程上并行处理，每个线程负责 20 万 partition 数据的拉取，总时间缩短为 14s 左右（这个时间受虚拟机本身性能影响，同虚拟机上如果单线程拉取 20 万 partition 约只需要 6s 左右），因此在 controller 恢复时，并行拉取 partition 可以明显缩短恢复时间。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上文中提到 100 万 partition 生成的元数据约 80MB，如果我们限制了单 broker 上 partition 数量，意味着我们需要增加 broker 的节点数，controller 切换并行同步给大量的 broker，会给 controller 节点带来流量的冲击，同时同步 80MB 的元数据也会消耗比较长的时间。因此需要改变现在集群同步元数据的方式，比如像存放消费位置一样，通过内置 topic 来存放元数据，controller 把写入到 ZK 上的数据通过消息的方式发送到内置存放元数据的 topic 上，broker 分别从 topic 上消费这些数据并更新内存中的元数据，这类的方案虽然可以在 controller 切换时全量同步元数据，但是需要对现在的 kafka 架构进行比较大的调整（当然还有其他更多的办法，比如不使用 ZK 来管理元数据等，不过这不在本篇文章探讨的范围内）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那有没有其他的办法，在对 kafka 架构改动较小的前提下来支持大规模 partition 的场景呢？我们知道 kafka 客户端与 broker 交互时，会先通过指定的地址拉取 topic 元数据，然后再根据元数据连接 partition 相应的 Leader 进行生产和消费，我们通过控制元数据，可以控制客户端生产消费连接的机器，这些机器在客户端并不要求一定在同一个集群中，只需要客户端能够拿到这些 partition 的状态信息，因此我们可以让不同的 topic 分布到不同的集群上，然后再想办法把不同集群上的 topic 信息组合在一起返回给客户端，就能达到客户端同时连接不同集群的效果，从客户端视角来看就就是一个大的集群。这样不需要单个物理集群支撑非常大的规模，可以通过组合多个物理集群的方式来达到支撑更大的规模，通过这种方式，扩容时不需要用户停机修改业务，下面我们就来描述一下怎么实现这种方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 小&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;集群组建逻辑集群&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当我们需要组建逻辑集群时，有几个核心问题需要解决：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、当客户端需要拉取元数据时，怎么把多个小的物理集群上的元数据组装在一起返回给客户端；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、不同集群上的元数据变更时怎么及时地通知变更；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、多个集群上保存消费位置和事务状态的 topic 怎么分布。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;下面针对这些问题一一进行讲解：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4491758241758242&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHWdQ8Ns3uPkgUHI2mBHibI8dK7q3XMIyHGZpDBGicd1fnLyFicCp3pvDPLt5Qhlc1HIiafJToCyhhKduw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对 metadata 组装问题，我们可以在逻辑集群里的多个物理集群中选一个为主集群，其他集群为扩展集群，由主集群负责对外提供 metadata、消费位置、事务相关的服务，当然主集群也可以同时提供消息的生产消费服务，扩展集群只能用于业务消息的生产和消费。我们知道当 partition 的 Leader 切换时需要通过集群中的 controller 把新的 metadata 数据同步给集群中的 broker。当逻辑集群是由多个相互独立的物理集群组成时，controller 无法感知到其他集群中的 Broker 节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以对主集群中的 metada 接口进行简单的改造，当客户端拉取 metadata 时，我们可以跳转到其他的集群上拉取 metadata, 然后在主集群上进行融合组装再返回给客户端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然跳转拉取 metadata 的方式有一些性能上的消耗，但是正常情况下并不在消息生产和消费的路径上，对客户端影响不大。通过客户端拉取时再组装 metadata，可以规避跨物理集群更新 metadata 的问题，同时也能够保证实时性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当消费分组之间的成员需要协调拉取数据的 partition 时，服务端会根据保存消费位置 topic 的 partition 信息返回对应的协调节点，因此我们在一个逻辑集群中需要确定消费位置 topic 分布的集群，避免访问不同物理集群的节点返回的协调者不一样，从不同集群上拉取到的消费位置不一样等问题。我们可以选主集群的 broker 节点提供消费和事务协调的服务，消费位置也只保存在主集群上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上述的一些改造，我们就可以支持更大的业务规模，用户在使用时只需要知道主集群的地址就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;组建逻辑集群除了上述的核心问题外，我们也需要关注 topic 的分配，由于腾讯云的 ckafka 本身就会把 broker 上创建 topic 的请求转发给管控模块创建，因此可以很方便的解决 topic 在多个物理集群的分布，也可以规避同一逻辑集群上，不同物理集群内可能出现同名 topic 的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4783821478382148&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHWdQ8Ns3uPkgUHI2mBHibI8dyoU88EcJKSriadaCqEGzDcal1tbdWTHrXtaLLkuuhgibDqmmVNoo3fKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;717&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;前面讲述了多个物理集群怎么组建成单个逻辑集群，有时可能面临一个问题，就是单个物理集群由于一些原因需要在现有的 topic 上不断的扩充 partition，如果多个 topic 同时需要扩容可能出现单个物理集群过大的情况，因此需要对现有的集群进行分裂，一个物理集群拆分成两个物理集群。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进行集群的分裂涉及到 ZK 集群的分裂和对 broker 节点进行分组拆分，首先对集群中的 broker 节点分成两组，每组连接不同的 ZK 节点，比如我们可以在原来的 zk 集群中增加 observer 节点，新增的 broker 为一组，原来集群中的 broker 为一组，我们让新 broker 只填写 observer 的地址。ZK 集群分裂前，通过 KAFKA 内置迁移工具可以很方便地把不同的 topic 迁移到各自的 broker 分组上，同一个 topic 的 partition 只会分布在同一个分组的 broker 节点上，后续把 observer 节点从现有的 ZK 集群中移除出去，然后让 observer 与别的 ZK 节点组成新的 ZK 集群，从而实现 kafka 集群的分裂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;04&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;结束语&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;通过提升 controller 的性能，和通过把多个物理集群组装成一个逻辑集群的做法都可以提升单集群承载 partition 的规模。但是相比而言，通过组建多个物理集群的方式对 kafka 现有的架构改动更小一些，故障恢复的时间上更有保障一些，服务更稳定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然业务在使用 kafka 服务时，如果业务允许保持一个 partition 数量适度的集群规模，通过业务拆分的方式连接不同的集群也是一种很好的实践方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;30&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;作者介绍&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;丁俊，&lt;/span&gt;腾讯云消息队列Ckafka负责人，拥有多年消息、缓存、NOSQL 等基础设施的研发经验。腾讯云 CKafka 团队一直在不断探索，致力于为用户提供可靠的消息服务。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;05&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;福利&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0029154518950438&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHVsf6A0mzk3uo1zj2O2gOdica4hiaeEAtCWf5VRicNynBtsB6ycMulqyF1B06N85Io8ftRgJN3iar6Nuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;686&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;95098&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;50%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.37423312883435583&quot; data-type=&quot;gif&quot; data-w=&quot;163&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/7QRTvkK2qC6aqek98EtTHUKcyP8jibR2dMpmVDlnHv7DyMlWaib0sO2Qib2XtVPL8wictxAoKMch1iancskn5BpaYcg/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;section data-width=&quot;50%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247483846&amp;amp;idx=1&amp;amp;sn=bfe1d7e3843e0499a1738f54008e5a15&amp;amp;chksm=9b41f9f5ac3670e37f559a49de1d8e853edca063536c1b7cf0b6c97e10021f70cb3e40b31557&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《JS引擎中的Inline Cache技术内幕，你知道多少？》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;span&gt;《JS引擎中的Inline Cache技术内幕，你知道多少？》&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247483805&amp;amp;idx=1&amp;amp;sn=35acc7c7811ab162acba28815f6b9b9d&amp;amp;chksm=9b41f9aeac3670b896a730043d6f9625b7376fb51c62ab108ced90d736e7ba2e0d4fba6ffc52&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《揭秘Kafka的硬盘设计方案，快速完成PB级数据扩容需求！》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;揭秘Kafka的硬盘设计方案，快速完成PB级数据扩容需求！&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247483773&amp;amp;idx=1&amp;amp;sn=ab5d5788cd4a894e79101af15075613b&amp;amp;chksm=9b41f94eac367058ce2412eae50a1a8096c965dbe34d53b91b305fa571825dc3e81c73e381e7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《腾讯课堂百万师生同时在线，如何实现消息的稳定互动？》&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《腾讯课堂百万师生同时在线，如何实现消息的稳定互动？&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247483763&amp;amp;idx=1&amp;amp;sn=f90f34ba2592fd32b5d8385bf7500587&amp;amp;chksm=9b41f940ac36705646bf4a0a1159c25fb9ae946cb15b1bfc1c21b1363ccec3418c1956a13870&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《宅家学习，如何进行Kubernetes Ingress控制器的技术选型》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;宅家学习，如何进行Kubernetes Ingress控制器的技术选型》&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247483693&amp;amp;idx=1&amp;amp;sn=10650f9217806c18b301d41155cb5752&amp;amp;chksm=9b41f91eac3670083756ffe540d9baaf857e29d833bd1a9a1127556afcc10467504e5e26d5db&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《趣谈GC技术，解密垃圾回收的玄学理论》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《趣谈GC技术，解密垃圾回收的玄学理论》&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93679&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;95428&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.7272727272727273&quot; data-type=&quot;gif&quot; data-w=&quot;55&quot; data-width=&quot;100%&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/7QRTvkK2qC4wGnbF5amRQQKTVrzcJtD7ZQwDcQRLs9LnN4HDVzlgmraiaeHnVbkhZZC9UroxSoQfxOe646XIjhg/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;扫描下方二维码&lt;/span&gt;&lt;span&gt;关注本公众号&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;了解更多有关腾讯云中间件的相关信息&lt;/span&gt;！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5560488346281909&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;901&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXWa3qntCtcsFhOnLP26ERNdoiaX1SVaa3fWKpxLFQmBgwc9UOz5hoRzPicnvW7Fjyh3TianDRVbbic5Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87578&quot;&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yqVAqoZvDibHW4ynpBjRrolMxOZtKTiaYgT0HG1BkTeIUjfS0zrwEYVMy6Fj54m58z6pH9yWNOnFkbflRtKVicx0w/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;戳原文，了解&lt;span&gt;更多&lt;/span&gt;腾讯云CKafka的相关信息&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;！&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87578&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94252&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0740740740740742&quot; data-type=&quot;png&quot; data-w=&quot;81&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7QRTvkK2qC5ricrpxA0Tln6U4mt6c9God8owkFMgicqnvogW8znAX84Syp3PSlsnkPKnE2n4ZyZs8E73qZj6XgyA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;点亮&lt;span&gt;在看&lt;/span&gt;，你最好看&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>