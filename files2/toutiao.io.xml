<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6d54429192265cce9e30925f098af914</guid>
<title>工具 | 腾讯开源的一套运维脚本管理系统</title>
<link>https://toutiao.io/k/6b7chfm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655077223&amp;amp;idx=2&amp;amp;sn=05d40fd92b2ed441b4bfcaaab853a1d2&amp;amp;chksm=bd2913508a5e9a46683351f781991e7e2ad2a4a1c63a4acd499df91a8861e07ba5f713df0f96&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;加入「码农周刊VIP会员」，一起牛起来！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1239&quot; data-ratio=&quot;2.584&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavibrjuslbgA22ac28mmKSkmofwBgZl57TTsoqIvmibTK9IjT5ZGkghkWlRibOgROfezWLcibjtIl1Ug1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8Byw4xNoV6O2YGutfKmQLKuMZEIhBJF6MrQvoShfIAT6u3dXs6VZRzwSa2eT9jcekfaYuaOD6Hhw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>74ac97a80f1c58ba45a80842d2e3896a</guid>
<title>MySQL 索引连环 18 问</title>
<link>https://toutiao.io/k/x7420rp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-topic-des nc-post-content&quot;&gt;
&lt;p&gt;MySQL作为互联网中非常热门的数据库，现在大厂面试题横竖绕不开MySQL，其中MySQL索引是大厂必考面试题。今天带来了MySQL索引的常考面试题，看看你能答对多少~ &lt;/p&gt; 
&lt;p&gt;这是本期的MySQL索引面试题目录，不会的快快查漏补缺~&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;目录&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752025/image-20210411230042052.png&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;1. 索引是什么？&lt;/h2&gt; 
&lt;p&gt;索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;索引是一种数据结构。数据库索引，是数据库管理系统中一个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。而且索引是一个文件，它是要占据物理空间的。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。&lt;/p&gt; 
&lt;h2&gt;2. 索引有哪些优缺点？&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;索引的优点&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 &lt;/li&gt;
 &lt;li&gt;通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;索引的缺点&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率； &lt;/li&gt;
 &lt;li&gt;空间方面：索引需要占物理空间。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;3. MySQL有哪几种索引类型？&lt;/h2&gt; 
&lt;p&gt;1、从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，&lt;/p&gt; 
&lt;p&gt;2、从应用层次来分：普通索引，唯一索引，复合索引。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;普通索引：即一个索引只包含单个列，一个表可以有多个单列索引&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;唯一索引：索引列的值必须唯一，但允许有空值&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;非聚簇索引： 不是聚簇索引，就是非聚簇索引&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;3、根据中数据的物理顺序与键值的逻辑（索引）顺序关系： 聚集索引，非聚集索引。&lt;/p&gt; 
&lt;h2&gt;4. 说一说索引的底层实现？&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;Hash索引&lt;/strong&gt; &lt;/p&gt; 
&lt;p&gt;&lt;span&gt;基于&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;哈希表&lt;/a&gt;实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;图片来源：&lt;a href=&quot;https://www.javazhiyin.com/40232.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.javazhiyin.com/40232.html&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752261/image-20210411215012443.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;B-Tree索引&lt;/strong&gt;（MySQL使用B+Tree）&lt;/p&gt; 
&lt;p&gt;B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752112/image-20210411215023820.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;B+Tree索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。&lt;/p&gt; 
&lt;p&gt;B+tree性质：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;B+ 树中，数据对象的插入和删除仅在叶节点上进行。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752195/image-20210411215044332.png&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span&gt;5. 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;二叉树&lt;/a&gt;，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;？&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;B-tree： 从两个方面来回答&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B(B-)树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对&lt;code&gt;IO读写次数就降低&lt;/code&gt;了。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在&lt;code&gt;区间查询&lt;/code&gt;的情况，所以通常B+树用于数据库索引。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;Hash： &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;虽然可以快速定位，但是没有顺序，IO复杂度高；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;基于Hash表实现，只有Memory存储引擎显式支持哈希索引 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;适合&lt;strong&gt;等值查询&lt;/strong&gt;，如=、in()、&amp;lt;=&amp;gt;，不支持范围查询 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成&lt;a target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;排序&lt;/a&gt; ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;Hash索引在查询等值时非常快 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;因为Hash索引始终索引的&lt;strong&gt;所有列的全部内容&lt;/strong&gt;，所以不支持部分索引列的匹配查找 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;二叉树&lt;/a&gt;： 树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;： 树的高度随着数据量增加而增加，IO代价高。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;6. 讲一讲聚簇索引与非聚簇索引？&lt;/h2&gt; 
&lt;p&gt;在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。&lt;/p&gt; 
&lt;p&gt;而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引、二级索引。&lt;/p&gt; 
&lt;p&gt;聚簇索引与非聚簇索引的区别：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号） &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为&lt;strong&gt;回表&lt;/strong&gt;。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可 &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;7. 非聚簇索引一定会回表查询吗？&lt;/h2&gt; 
&lt;p&gt;不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为&quot;覆盖索引&quot;。&lt;/p&gt; 
&lt;p&gt;举个简单的例子，假设我们在学生表的成绩上建立了索引，那么当进行&lt;code&gt;select score from student where score &amp;gt; 90&lt;/code&gt;的查询时，在索引的叶子节点上，已经包含了score 信息，不会再次进行回表查询。&lt;/p&gt; 
&lt;h2&gt;8. 联合索引是什么？为什么需要注意联合索引中的顺序？&lt;/h2&gt; 
&lt;p&gt;MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。&lt;/p&gt; 
&lt;p&gt;具体原因为:&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;MySQL使用索引时需要索引有序，假设现在建立了&quot;name，age，school&quot;的联合索引，那么索引的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;为: 先按照name&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;，如果name相同，则按照age&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;，如果age的值也相等，则按照school进行&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。&lt;/p&gt; 
&lt;h2&gt;9. 讲一讲MySQL的最左前缀原则?&lt;/h2&gt; 
&lt;p&gt;最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。&lt;br/&gt;mysql会一直向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &amp;gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。&lt;/p&gt; 
&lt;p&gt;=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。&lt;/p&gt; 
&lt;h2&gt;10. 讲一讲前缀索引？&lt;/h2&gt; 
&lt;p&gt;因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，order by不支持前缀索引 。&lt;/p&gt; 
&lt;p&gt; 流程是： &lt;/p&gt; 
&lt;p&gt; 先计算完整列的选择性 :&lt;code&gt;select count(distinct col_1)/count(1) from table_1&lt;/code&gt;&lt;/p&gt; 
&lt;p&gt; 再计算不同前缀长度的选择性 :&lt;code&gt;select count(distinct left(col_1,4))/count(1) from table_1&lt;/code&gt;&lt;/p&gt; 
&lt;p&gt; 找到最优长度之后，创建前缀索引 :&lt;code&gt;create index idx_front on table_1 (col_1(4))&lt;/code&gt;&lt;/p&gt; 
&lt;h2&gt;11. 了解索引下推吗？&lt;/h2&gt; 
&lt;p&gt;MySQL 5.6引入了索引下推优化。默认开启，使用SET optimizer_switch = ‘index_condition_pushdown=off’;可以将其关闭。 &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;有了索引下推优化，可以在&lt;strong&gt;减少回表次数&lt;/strong&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;在InnoDB中只针对二级索引有效&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;官方文档中给的例子和解释如下：&lt;/p&gt; 
&lt;p&gt;在 people_table中有一个二级索引(zipcode，lastname，address)，查询是SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’; &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;如果没有使用索引下推技术，则MySQL会通过zipcode=’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断数据是否符合条件 &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=’95054’的索引，然后根据lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;12. 怎么查看MySQL语句有没有用到索引？&lt;/h2&gt; 
&lt;p&gt;通过explain，如以下例子：&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&#x27;10001&#x27; AND title=&#x27;Senior Engineer&#x27; AND from_date=&#x27;1986-06-26&#x27;;&lt;/code&gt;&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;id&lt;/th&gt; 
   &lt;th&gt;select_type&lt;/th&gt; 
   &lt;th&gt;table&lt;/th&gt; 
   &lt;th&gt;partitions&lt;/th&gt; 
   &lt;th&gt;type&lt;/th&gt; 
   &lt;th&gt;possible_keys&lt;/th&gt; 
   &lt;th&gt;key&lt;/th&gt; 
   &lt;th&gt;key_len&lt;/th&gt; 
   &lt;th&gt;ref&lt;/th&gt; 
   &lt;th&gt;filtered&lt;/th&gt; 
   &lt;th&gt;rows&lt;/th&gt; 
   &lt;th&gt;Extra&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt;
  &lt;tr&gt; 
   &lt;td&gt;1&lt;/td&gt; 
   &lt;td&gt;SIMPLE&lt;/td&gt; 
   &lt;td&gt;titles&lt;/td&gt; 
   &lt;td&gt;null&lt;/td&gt; 
   &lt;td&gt;const&lt;/td&gt; 
   &lt;td&gt;PRIMARY&lt;/td&gt; 
   &lt;td&gt;PRIMARY&lt;/td&gt; 
   &lt;td&gt;59&lt;/td&gt; 
   &lt;td&gt;const,const,const&lt;/td&gt; 
   &lt;td&gt;10&lt;/td&gt; 
   &lt;td&gt;1&lt;/td&gt; 
   &lt;td/&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt;
&lt;/table&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;id：在⼀个⼤的查询语句中每个&lt;strong&gt;SELECT&lt;/strong&gt;关键字都对应⼀个唯⼀的id ，如explain select * from s1 where id = (select id from s1 where name = &#x27;egon1&#x27;);第一个select的id是1，第二个select的id是2。有时候会出现两个select，但是id却都是1，这是因为优化器把子查询变成了连接查询 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;select_type：select关键字对应的那个查询的类型，如SIMPLE,PRIMARY,SUBQUERY,DEPENDENT,SNION 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;table：每个查询对应的表名 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;type：&lt;code&gt;type&lt;/code&gt; 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 &lt;code&gt;type&lt;/code&gt; 字段, 我们判断此次查询是 &lt;code&gt;全表扫描&lt;/code&gt; 还是 &lt;code&gt;索引扫描&lt;/code&gt; 等。如const(主键索引或者唯一二级索引进行等值匹配的情况下),ref(普通的⼆级索引列与常量进⾏等值匹配),index(扫描全表索引的覆盖索引) 。&lt;/p&gt; &lt;p&gt;通常来说, 不同的 type 类型的性能关系如下:&lt;br/&gt;&lt;code&gt;ALL &amp;lt; index &amp;lt; range ~ index_merge &amp;lt; ref &amp;lt; eq_ref &amp;lt; const &amp;lt; system&lt;/code&gt;&lt;br/&gt;&lt;code&gt;ALL&lt;/code&gt; 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.&lt;br/&gt;而 &lt;code&gt;index&lt;/code&gt; 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;possible_key：查询中可能用到的索引&lt;em&gt;(可以把用不到的删掉，降低优化器的优化时间)&lt;/em&gt; 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;key：此字段是 MySQL 在当前查询时所真正使用到的索引。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;filtered：查询器预测满足下一次查询条件的百分比 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.&lt;br/&gt;这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;extra：表示额外信息，如Using where,Start temporary,End temporary,Using temporary等。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;13. 为什么官方建议使用自增长主键作为索引？&lt;/h2&gt; 
&lt;p&gt;结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。&lt;/p&gt; 
&lt;p&gt;插入连续的数据：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;图片来自：&lt;a href=&quot;https://www.javazhiyin.com/40232.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.javazhiyin.com/40232.html&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752160/java10-1562726251.gif&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;插入非连续的数据：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752674/java8-1562726251.gif&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;14. 如何创建索引？&lt;/h2&gt; 
&lt;p&gt;创建索引有三种方式。&lt;/p&gt; 
&lt;p&gt;1、 在执行CREATE TABLE时创建索引&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-sql&quot; from-niu=&quot;default&quot;&gt;CREATE TABLE user_index2 (
    id INT auto_increment PRIMARY KEY,
    first_name VARCHAR (16),
    last_name VARCHAR (16),
    id_card VARCHAR (18),
    information text,
    KEY name (first_name, last_name),
    FULLTEXT KEY (information),
    UNIQUE KEY (id_card)
);
&lt;/pre&gt; 
&lt;p&gt;2、 使用ALTER TABLE命令去增加索引。&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-sql&quot; from-niu=&quot;default&quot;&gt;ALTER TABLE table_name ADD INDEX index_name (column_list);&lt;/pre&gt; 
&lt;p&gt;ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。&lt;/p&gt; 
&lt;p&gt;其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。&lt;/p&gt; 
&lt;p&gt;索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。&lt;br/&gt;3、 使用CREATE INDEX命令创建。&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-sql&quot; from-niu=&quot;default&quot;&gt;CREATE INDEX index_name ON table_name (column_list);&lt;/pre&gt; 
&lt;h2&gt;15. 创建索引时需要注意什么？&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值； &lt;/li&gt;
 &lt;li&gt;取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高； &lt;/li&gt;
 &lt;li&gt;索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;16. 建索引的原则有哪些？&lt;/h2&gt; 
&lt;p&gt;1、最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &amp;gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。&lt;/p&gt; 
&lt;p&gt;2、=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。&lt;/p&gt; 
&lt;p&gt;3、尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。&lt;/p&gt; 
&lt;p&gt;4、索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。&lt;/p&gt; 
&lt;p&gt;5、尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。&lt;/p&gt; 
&lt;h2&gt;17. 使用索引查询一定能提高查询的性能吗？&lt;/h2&gt; 
&lt;p&gt;通常通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。&lt;/p&gt; 
&lt;p&gt;索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的I* NSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;基于一个范围的检索，一般查询返回结果集小于表中记录数的30%。 &lt;/li&gt;
 &lt;li&gt;基于非唯一性索引的检索。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;18. 什么情况下不走索引（索引失效）？&lt;/h2&gt; 
&lt;h5&gt;1、使用!= 或者 &amp;lt;&amp;gt; 导致索引失效&lt;/h5&gt; 
&lt;h5&gt;2、类型不一致导致的索引失效&lt;/h5&gt; 
&lt;h5&gt;3、函数导致的索引失效&lt;/h5&gt; 
&lt;p&gt;如：&lt;/p&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE DATE(create_time) = &#x27;2020-09-03&#x27;;&lt;/pre&gt;
&lt;p&gt;如果你的索引字段使用了函数，对不起，他是真的不走索引的。&lt;/p&gt; 
&lt;h5&gt;4、运算符导致的索引失效&lt;/h5&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE age - 1 = 20;&lt;/pre&gt;
&lt;p&gt;如果你对列进行了（+，-，*，/，!）, 那么都将不会走索引。&lt;/p&gt; 
&lt;h5&gt;5、OR引起的索引失效&lt;/h5&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE `name` = &#x27;张三&#x27; OR height = &#x27;175&#x27;;&lt;/pre&gt;
&lt;p&gt;OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。&lt;/p&gt; 
&lt;h5&gt;6、模糊搜索导致的索引失效&lt;/h5&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE `name` LIKE &#x27;%冰&#x27;;&lt;/pre&gt;
&lt;p&gt;当&lt;code&gt;%&lt;/code&gt;放在匹配字段前是不走索引的，放在后面才会走索引。&lt;/p&gt; 
&lt;h5&gt;7、NOT IN、NOT EXISTS导致索引失效&lt;/h5&gt; 
&lt;h2 id=&quot;end&quot;&gt;End&lt;/h2&gt; 
&lt;p&gt;整理不易，点个赞呗！&lt;/p&gt; 
&lt;h2&gt;巨人的肩膀&lt;/h2&gt; 
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ThinkWon/article/details/104778621&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://blog.csdn.net/ThinkWon/article/details/104778621&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.javazhiyin.com/40232.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.javazhiyin.com/40232.html&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844904039860142088&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://juejin.cn/post/6844904039860142088&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ThinkWon/article/details/104778621&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://blog.csdn.net/ThinkWon/article/details/104778621&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008131735&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://segmentfault.com/a/1190000008131735&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b16f6de03361c8fc84754f1a633cb48d</guid>
<title>Golang 官方限流器的用法详解</title>
<link>https://toutiao.io/k/xvjaiyz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限流器是提升服务稳定性的非常重要的组件，可以用来限制请求速率，保护服务，以免服务过载。限流器的实现方法有很多种，常见的限流算法有&lt;strong&gt;固定窗口、滑动窗口、漏桶、令牌桶&lt;/strong&gt;，我在前面的文章 &lt;strong&gt;「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486937&amp;amp;idx=1&amp;amp;sn=d4ea6ebb38c52e8004e73f235bde9848&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;常用限流算法的应用场景和实现原理&lt;/a&gt;」&lt;/strong&gt; 中给大家讲解了这几种限流方法自身的特点和应用场景，其中令牌桶在限流的同时还可以应对一定的突发流量，与互联网应用容易因为热点事件出现突发流量高峰的特点更契合。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简单来说，令牌桶就是想象有一个固定大小的桶，系统会以恒定速率向桶中放 Token，桶满则暂时不放。在请求比较的少的时候桶可以先&quot;攒&quot;一些Token，应对突发的流量，如果桶中有剩余 Token 就可以一直取。如果没有剩余 Token，则需要等到桶中被放置了 Token 才行。&lt;/p&gt;&lt;p&gt;关于令牌桶限流更详细的解释请参考文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486937&amp;amp;idx=1&amp;amp;sn=d4ea6ebb38c52e8004e73f235bde9848&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;常用限流算法的应用场景和实现原理&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的同学在看明白令牌桶的原理后就非常想去自己实现一个限流器应用到自己的项目里，em... 怎么说呢，造个轮子确实有利于自己水平提高，不过要是应用到商用项目里的话其实大可不必自己去造轮子，Golang官方已经替我们造好轮子啦 ......~！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 官方提供的扩展库里就自带了限流算法的实现，即 &lt;code&gt;golang.org/x/time/rate&lt;/code&gt;。该限流器也是基于 Token Bucket(令牌桶) 实现的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限流器的内部结构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;time/rate&lt;/code&gt;包的&lt;code&gt;Limiter&lt;/code&gt;类型对限流器进行了定义，所有限流功能都是通过基于&lt;code&gt;Limiter&lt;/code&gt;类型实现的，其内部结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Limiter &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; mu     sync.Mutex&lt;br/&gt; limit  Limit&lt;br/&gt; burst  &lt;span&gt;int&lt;/span&gt; &lt;span&gt;// 令牌桶的大小&lt;/span&gt;&lt;br/&gt; tokens &lt;span&gt;float64&lt;/span&gt;&lt;br/&gt; last time.Time &lt;span&gt;// 上次更新tokens的时间&lt;/span&gt;&lt;br/&gt; lastEvent time.Time &lt;span&gt;// 上次发生限速器事件的时间（通过或者限制都是限速器事件）&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其主要字段的作用是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;limit：&lt;code&gt;limit&lt;/code&gt;字段表示往桶里放Token的速率，它的类型是Limit，是int64的类型别名。&lt;strong&gt;设置&lt;code&gt;limit&lt;/code&gt;时既可以用数字指定每秒向桶中放多少个Token，也可以指定向桶中放Token的时间间隔&lt;/strong&gt;，其实指定了每秒放Token的个数后就能计算出放每个Token的时间间隔了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;burst: 令牌桶的大小。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tokens: 桶中的令牌。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;last: 上次往桶中放 Token 的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lastEvent：上次发生限速器事件的时间（通过或者限制都是限速器事件）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;可以看到在 &lt;code&gt;timer/rate&lt;/code&gt; 的限流器实现中，并没有单独维护一个 Timer 和队列去真的每隔一段时间向桶中放令牌，而是仅仅通过计数的方式表示桶中剩余的令牌。每次消费取 Token 之前会先根据上次更新令牌数的时间差更新桶中Token数&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概了解了&lt;code&gt;time/rate&lt;/code&gt;限流器的内部实现后，下面的内容我们会集中介绍下该组件的具体使用方法：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;构造限流器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用以下方法构造一个限流器对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;limiter := rate.NewLimiter(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两个参数：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一个参数是 &lt;code&gt;r Limit&lt;/code&gt;，设置的是限流器Limiter的&lt;code&gt;limit&lt;/code&gt;字段，代表每秒可以向 Token 桶中产生多少 token。Limit 实际上是 float64 的别名。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二个参数是 &lt;code&gt;b int&lt;/code&gt;，b 代表 Token 桶的容量大小，也就是设置的限流器 Limiter 的&lt;code&gt;burst&lt;/code&gt;字段。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，对于以上例子来说，其构造出的限流器的令牌桶大小为 100, 以每秒 10 个 Token 的速率向桶中放置 Token。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了给&lt;code&gt;r Limit&lt;/code&gt;参数直接指定每秒产生的 Token 个数外，还可以用 Every 方法来指定向桶中放置 Token 的间隔，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;limit := rate.Every(&lt;span&gt;100&lt;/span&gt; * time.Millisecond);&lt;br/&gt;limiter := rate.NewLimiter(limit, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就表示每 100ms 往桶中放一个 Token。本质上也是一秒钟往桶里放 10 个。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用限流器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Limiter 提供了三类方法供程序消费 Token，可以每次消费一个 Token，也可以一次性消费多个 Token。每种方法代表了当 Token 不足时，各自不同的对应手段，可以阻塞等待桶中Token补充，也可以直接返回取Token失败。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Wait/WaitN&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;Wait&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt; &lt;span&gt;(err error)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;WaitN&lt;/span&gt;&lt;span&gt;(ctx context.Context, n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(err error)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wait 实际上就是 &lt;code&gt;WaitN(ctx,1)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用 Wait 方法消费 Token 时，如果此时桶内 Token 数组不足 (小于 N)，那么 Wait 方法将会阻塞一段时间，直至 Token 满足条件。如果充足则直接返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里可以看到，Wait 方法有一个 context 参数。我们可以设置 context 的 Deadline 或者 Timeout，来决定此次 Wait 的最长时间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 一直等到获取到桶中的令牌&lt;/span&gt;&lt;br/&gt;err := limiter.Wait(context.Background())&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;Error: &quot;&lt;/span&gt;, err)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 设置一秒的等待超时时间&lt;/span&gt;&lt;br/&gt;ctx, _ := context.WithTimeout(context.Background(), time.Second * &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;err := limiter.Wait(ctx)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;Error: &quot;&lt;/span&gt;, err)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Allow/AllowN&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;Allow&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;AllowN&lt;/span&gt;&lt;span&gt;(now time.Time, n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Allow 实际上就是对 &lt;code&gt;AllowN(time.Now(),1)&lt;/code&gt; 进行简化的函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AllowN 方法表示，截止到某一时刻，目前桶中数目是否至少为 n 个，满足则返回 true，同时从桶中消费 n 个 token。反之不消费桶中的Token，返回false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应线上的使用场景是，如果请求速率超过限制，就直接丢弃超频后的请求。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; limiter.AllowN(time.Now(), &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;event allowed&quot;&lt;/span&gt;)&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;event not allowed&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Reserve/ReserveN&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;Reserve&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;Reservation&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(lim *Limiter)&lt;/span&gt; &lt;span&gt;ReserveN&lt;/span&gt;&lt;span&gt;(now time.Time, n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;Reservation&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Reserve 相当于 &lt;code&gt;ReserveN(time.Now(), 1)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReserveN 的用法就相对来说复杂一些，当调用完成后，无论 Token 是否充足，都会返回一个 &lt;code&gt;*Reservation&lt;/code&gt; 对象。你可以调用该对象的&lt;code&gt;Delay()&lt;/code&gt;方法，该方法返回的参数类型为&lt;code&gt;time.Duration&lt;/code&gt;，反映了需要等待的时间，必须等到等待时间之后，才能进行接下来的工作。如果不想等待，可以调用&lt;code&gt;Cancel()&lt;/code&gt;方法，该方法会将 Token 归还。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一个简单的例子，我们可以这么使用 Reserve 方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r := limiter.Reserve()&lt;br/&gt;f !r.OK() {&lt;br/&gt;    &lt;span&gt;// Not allowed to act! Did you remember to set lim.burst to be &amp;gt; 0 ?&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;time.Sleep(r.Delay())&lt;br/&gt;Act() &lt;span&gt;// 执行相关逻辑&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;动态调整速率和桶大小&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Limiter 支持创建后动态调整速率和桶大小：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SetLimit(Limit) 改变放入 Token 的速率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SetBurst(int) 改变 Token 桶大小&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这两个方法，可以根据现有环境和条件以及我们的需求，动态地改变 Token 桶大小和速率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们总结了 Golang 官方限流器的使用方法，它是一种令牌桶算实现的限流器。其中 &lt;strong&gt;Wait/WaitN&lt;/strong&gt;，&lt;strong&gt;Allow/AllowN&lt;/strong&gt; 这两组方法在平时用的比较多，前者是消费Token时如果桶中Token不足可以让程序等待桶中新Token的放入（最好设置上等待时长）后者则是在桶中的Token不足时选择直接丢弃请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了Golang官方提供的限流器实现，Uber公司开源的限流器&lt;code&gt;uber-go/ratelimit&lt;/code&gt;也是一个很好的选择，与Golang官方限流器不同的是Uber的限流器是通过漏桶算法实现的，不过对传统的漏桶算法进行了改良，有兴趣的同学可以自行去体验一下。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzNTY5MzU2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4pGhLz2xEbRFHnAQon2QLYgbBibCJo1ibJHesLWshPJeRibateRtAqkaf6BgjlbhYiaxHLq6Zu07CRPw/0?wx_fmt=png&quot; data-nickname=&quot;网管叨bi叨&quot; data-alias=&quot;kevin_tech&quot; data-signature=&quot;分享软件开发和系统架构设计基础、Go 语言和Kubernetes。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b03ede1a502030c675c5d5eef557c17e</guid>
<title>如何开发一个文件文档在线预览的网站？</title>
<link>https://toutiao.io/k/p3i66hk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;col-md-12 text-center&quot;&gt;&lt;p&gt;总访问量：&lt;span&gt;31012&lt;/span&gt;    今日访问量：&lt;span&gt;37&lt;/span&gt;    您是今天第：&lt;span&gt;37&lt;/span&gt; 个访问者&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7dfd4cf15a08238bc9478039a9bbb610</guid>
<title>以少胜多的基本逻辑</title>
<link>https://toutiao.io/k/p4347f6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content yue&quot;&gt;
          &lt;p&gt;几天前，天立跟我说他在看「毛泽东兵法精要」这本书。我跟他说兵法的要义其实非常简单，有一种以少胜多的基本逻辑。&lt;/p&gt;

&lt;p&gt;基本逻辑是一种底层的思考模型，就是「道」，而实践中的具体策略则是「术」。&lt;/p&gt;
&lt;p&gt;在理解「道」之前，掌握太多「术」是不好的。因为「术」是人在不同的环境下总结出来的应对策略，它们带有太多偶然性；而「道」是一种规律，它更加普遍，也更加长久。任何「术」的出发点应该基于正确的「道」，然后随机应变，这样我们才不会走偏。&lt;/p&gt;
&lt;p&gt;「道」应该越精简越好，这样才没有杂质，也方便记忆，理解和扩展。&lt;/p&gt;
&lt;p&gt;什么是以少胜多的「道」呢？&lt;/p&gt;
&lt;p&gt;很简单，就是&lt;strong&gt;以多胜少&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有人会问，这不是自相矛盾吗？稍安勿躁，让我用这篇文章来解释。&lt;/p&gt;
&lt;h2 id=&quot;幂律分布&quot;&gt;幂律分布&lt;/h2&gt;
&lt;p&gt;幂律分布是一种统计上的概率分布，在现实世界中存在着很多幂律分布的影子。&lt;/p&gt;
&lt;figure data-type=&quot;image&quot; tabindex=&quot;1&quot;&gt;&lt;img src=&quot;https://wzw.pub/post-images/1624190061702.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;
&lt;p&gt;比如世界上20%的人拥有80%的财富，而剩下的80%则只拥有20%的财富。&lt;/p&gt;
&lt;p&gt;这就是著名的&lt;strong&gt;二八定律&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在任何特定群体中，重要的因子通常只占少数，而不重要的因子则占多数，因此只要能控制具有重要性的少数因子即能控制全局。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;做过开发的人都明白，通常影响性能的代码模块很少，只要去优化少数几个模块，甚至只改动一两行代码，就能获得100%以上的性能提升。&lt;/p&gt;
&lt;p&gt;拿我们游戏来举例，大额付费玩家（大R）的付费比其余所有玩家加起来还多，然而大R数量占总玩家数量的比重不到1%。&lt;/p&gt;
&lt;p&gt;汉字有几万字，但我们每天日常使用到最多的都是「的、是、了、我」等常见字，诸如「巗、巘、巙、巚」等生僻字你可能一辈子都见不到一次。&lt;/p&gt;
&lt;p&gt;幂律分布告诉我们：真理往往掌握在少数人手里。&lt;/p&gt;
&lt;p&gt;做对一件关键的事情，比做对一百件无关紧要的事情要更有价值，而且关键事情的发生往往是具有决定性意义的。&lt;/p&gt;
&lt;h2 id=&quot;以少胜多&quot;&gt;以少胜多&lt;/h2&gt;
&lt;p&gt;有人会说，上面的道理我都懂，可这跟以少胜多有什么关系呢？&lt;/p&gt;
&lt;p&gt;让我们回到开头的问题：如何以少胜多？&lt;/p&gt;
&lt;p&gt;答：以多胜少。&lt;/p&gt;
&lt;p&gt;我都少了，还哪来的以多胜少呢？&lt;/p&gt;
&lt;p&gt;答：&lt;strong&gt;在我们弱小，劣势的时候，我们要将资源集中起来，劲往一块使。针对(敌人)薄弱的关键点发起集火，从而形成在关键点上以多打少的局部优势&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简言之，就是&lt;strong&gt;集中力量去做重要的事情&lt;/strong&gt;，建立起关键点上的局部优势。再简单一点，就是&lt;strong&gt;聚焦&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;毛主席曾说过：伤其十指，不如断其一指。意思就是要集中火力去彻底歼灭敌人一个师，而不是四面出击，谁都打一下。&lt;/p&gt;
&lt;p&gt;伤其十指，假以时日，十指还能恢复战斗力。然而断其一指，则永不能复生，这就造成了彻底的杀伤。&lt;/p&gt;
&lt;p&gt;孟良崮战役就是一个典型案例。&lt;/p&gt;
&lt;p&gt;1947年，解放军还处于战略防御的阶段，论兵力和装备都不及国军。国军整编第七十四师是国军的王牌中的王牌，全师美械装备，中将师长张灵甫还是一个常胜将军。&lt;/p&gt;
&lt;p&gt;3月，国军出动45万兵力对山东解放区发动重点攻击，其中就有张灵甫的王牌74师。守卫山东的华野总计27万兵力，在兵力和装备上都处于劣势。&lt;/p&gt;
&lt;p&gt;起初战局的进展对华野不利，这也让国军司令部产生了华野疲软的错觉，于是下令74师快速挺进，占领重要据点。&lt;/p&gt;
&lt;p&gt;粟裕立刻察觉到74师的挺进是孤军深入，于是连夜电令各纵队放弃之前作战任务。安排四个纵队外围切断敌军援助，五个纵队对74师驻地孟良崮发动狂风骤雨般的围攻。&lt;/p&gt;
&lt;p&gt;于是，一个晚上，一半以上的华野主力便投入了对74师的围歼。在孟良崮这个局部战场，瞬间形成了极大局部优势。最后，历经3天3夜的激战，74师被全歼，师长张灵甫阵亡。&lt;/p&gt;
&lt;p&gt;下图很直观的展示了孟良崮的被围攻（创造局部优势）过程，红色为解放军。&lt;/p&gt;
&lt;figure data-type=&quot;image&quot; tabindex=&quot;2&quot;&gt;&lt;img src=&quot;https://wzw.pub/post-images/1624190070825.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;
&lt;p&gt;王牌师的全军覆灭，对国军的心理造成了极大的打击，却空前的提振了解放军的士气。此战过后，全国的战争形势也发生扭转，解放军逐渐从战略防御转向战略进攻，为后来的全面胜利奠定了基础。&lt;/p&gt;
&lt;p&gt;官渡之战也是一样。袁绍兵力是曹操的五倍，然而曹操听从许攸建议，连夜集中优势兵力偷袭了袁绍的粮仓乌巢，使得袁绍十万大军失去了粮食，军中大乱，溃败而逃。&lt;/p&gt;
&lt;p&gt;赢得了官渡之战后，曹操也奠定了北方统一的基础，后续灭三袁，征乌丸便成了常规操作。&lt;/p&gt;
&lt;p&gt;集中优势兵力去攻击敌人的薄弱点和关键点，就能够形成局部优势，而关键点的胜利则又会由于二八定律转化为全局的胜利。&lt;/p&gt;
&lt;p&gt;这便是以少胜多，甚至求胜的一种基本逻辑。&lt;/p&gt;
&lt;p&gt;现实世界的阴谋往往是不得已而为之，而这种&lt;strong&gt;积极捕捉局部优势&lt;/strong&gt;的思考，却不依赖于太多阴谋诡计。把各个局部优势累积，通过一个关键点的局部优势放大，就能转化为全局的胜势。&lt;/p&gt;
&lt;h2 id=&quot;不止战争&quot;&gt;不止战争&lt;/h2&gt;
&lt;p&gt;在我喜爱的游戏DOTA2中也一样。如果我方处于劣势时，这时候不应该跟对方硬碰硬，来一场5v5的团战。而是应该五人开雾（隐身），找到落单的一两个敌方英雄，形成局部多打少，从而击杀敌方落单英雄，制造人数优势。然后顺理成章的推线拿塔，把劣势扳回。&lt;/p&gt;
&lt;p&gt;田忌赛马也是一样，齐王的每个等级的马都要比田忌的好，看似田忌处于绝对劣势，无法获胜。孙膑却让田忌故意求败，让田忌的下等马去对阵齐王的上等马；而用上等马对阵齐王的中等马，中等马对阵齐王的下等马，形成两次局部优势，2比1，从而获得整体的胜利。&lt;/p&gt;
&lt;p&gt;在资源有限的情况下，如何突围？聚焦于自己的核心要素，砍掉或者忽略掉其他不重要的地方。&lt;/p&gt;
&lt;p&gt;我在读「大败局2」和「史玉柱自述」时都读到了史玉柱和巨人的故事。巨人在做巨人汉卡获得空前成功后，心态膨胀，一下子就把业务扩张到了十几个行业。最后资金周转不过来，层层雪崩，资金链断裂，不得不欠下巨额债务，最后还是靠着脑白金的成功才还清了债务。&lt;/p&gt;
&lt;p&gt;最后史玉柱总结道：&lt;strong&gt;一个人的时间和精力是有限的，只能聚焦于一件事情&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;乔布斯也说过类似的话。1997年乔布斯重返苹果时，苹果已在破产边缘。乔布斯回归后，砍掉了70%的业务，聚焦于用户体验。十年后，苹果推出iPhone，征服了全世界的消费者，如今市值万亿美元。&lt;/p&gt;
&lt;p&gt;对于人这个个体来说也是一样，门门都是70分的人是平庸的；而一个一门100分，其余60分的人才则能够显露出来，博得别人的关注。&lt;/p&gt;
&lt;p&gt;最后总结，以少胜多的基本逻辑便是&lt;strong&gt;搜寻局部优势&lt;/strong&gt;，&lt;strong&gt;聚焦于关键点&lt;/strong&gt;，在关键点上形成局部优势，通过局部的优势转化为全局的胜势。&lt;/p&gt;

        &lt;/div&gt;

        
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>