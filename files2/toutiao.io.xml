<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8a38282634e25c3894dc500979da6058</guid>
<title>树莓派家用指北</title>
<link>https://toutiao.io/k/h2njn7z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;前两天刚刚入职，最近几天忙着租房搬家，忙活了几天总算是住进了自己小屋里，作为一个软件工程师，怎么可以没有一台家用服务器呢？方案有很多种，上至几千元的 NAS，下至淘汰的老电脑，但是旧电脑响声大功耗高，NAS 动辄三四千的价格对我这个刚毕业的大学生来说着实有些困难，于是我将目光放到了另一个小玩意上——树莓派。&lt;/p&gt;&lt;p&gt;我选择树莓派的原因也很简单，第一便宜，第二可查阅的资料非常多，基本上你之后使用过程中的问题网络上都有解决方案了，因此本文不会介绍怎么使用树莓派，怎么烧录系统，这些东西有太多人写过了，我重复写也没什么意思，因此这块内容我就一笔带过了，本文是我自己的家用服务器方案，更多的是提供一个方向性的指导，如果你觉得我的文章对你有所帮助，欢迎点个关注支持一下哦～&lt;/p&gt;&lt;h2&gt;什么是树莓派？&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTx7ehOiaRuJMA9FtXlibB7ibljibpn3sUAWiasLccmXIRaVfH9UxDmu6lZGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;打开任何一个搜索引擎在里面输入&lt;strong&gt;「树莓派」&lt;/strong&gt;三个字都会出现很多内容，其实树莓派本质上就是一台小电脑，虽然外形只有信用卡大小，却具有电脑的所有基本功能。和我们平常用的电脑不一样的是，树莓派自身是没有屏幕、键盘、鼠标这些东西的，但是它提供了网口、USB 口以及视频输出口（其实意思就是让你自己配）。&lt;/p&gt;&lt;p&gt;当然了，树莓派和主流电脑一个很大的区别就是他的芯片，和主流的 x86 桌面级电脑不同的是，树莓派用的是低功耗的 ARM 芯片，因此在性能上和常规电脑还是有些差距的，不过随着近年来 ARM 芯片的不断发展，其性能已经和传统 x86 处理器不相伯仲，甚至在某些方面遥遥领先，例如苹果的 M1 芯片。这里推荐阅读我之前写的两篇文章 👉&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484658&amp;amp;idx=1&amp;amp;sn=58a2c7cde1ed027b26f1e2e41deb8bdb&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《M1 暴打 Intel？——x86 与 ARM 的爱恨情仇》&quot; data-linktype=&quot;2&quot;&gt;《M1 暴打 Intel？——x86 与 ARM 的爱恨情仇》&lt;/a&gt;和&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484681&amp;amp;idx=1&amp;amp;sn=aa4ec453f111157205111ec3d6022c5c&amp;amp;chksm=ceb3d1bbf9c458ad33758e466664d1b0bcdc3e5a348f8ad47a6ac068c8102414cdfee6a1140d&amp;amp;scene=21&amp;amp;cur_album_id=1418449495750311936#wechat_redirect&quot; title=&quot;《M1 暴打 Intel？——这次的芯片有何不同》&quot; data-linktype=&quot;2&quot;&gt;《M1 暴打 Intel？——这次的芯片有何不同》&lt;/a&gt;&lt;/p&gt;&lt;p&gt;好在在学校的这些年，有一些闲置的键盘、鼠标和移动硬盘没来得及出手，于是我便果断的选择了树莓派作为我的家用服务器。&lt;/p&gt;&lt;h2&gt;树莓派的选择&lt;/h2&gt;&lt;p&gt;打开淘宝搜索树莓派，眼花缭乱的，那应该如何选择呢？&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7046979865771812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTvJgOL4qMmulyZyrHhXsry9rHS0GZbQsiaGSP0cdECshnpDQEl1nGfFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;其实很简单，虽然树莓派的型号众多，但是细分下来也只有三类：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;Model B 系列：旗舰版，接口全，性能强&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;Model A 系列：青春版，外形小，性能一般，配置和接口略有阉割&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;Zero 系列：迷你版，拥有超小身材，性能较弱&lt;/span&gt;&lt;/p&gt;&lt;p&gt;目前，树莓派已经发展到了第四代了，如果资金不是非常紧张的，推荐购买树莓派 4B 版，官网对他的介绍如下：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4879194630872483&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicThVHIcc2Kkkn9X0E0otjPahP5F2ojRwh4PHlNxH8V7gsJ13CFtUMGzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;相较于前代，处理器性能大幅增强，并且最高支持 8G 内存，支持 4K 视频输出，同时使用 USB- C 供电，完全可以作为一个桌面级电脑使用了，用作家用服务器绰绰有余了。&lt;/p&gt;&lt;h2&gt;操作系统选择&lt;/h2&gt;&lt;p&gt;说完了树莓派的硬件，怎么可以离开软件呢？树莓派相较于传统电脑另一个好处就是可以自由选择烧录的操作系统，官方推荐的是 Raspberry Pi OS，系统的烧录网上的教程太多了，这里我推荐直接使用官方提供的烧录软件&lt;strong&gt;「Raspberry Pi Imager」&lt;/strong&gt;，从下面的图中也可以看出来是一个非常容易上手的软件了。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6588235294117647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTKcrB20hDj7GAVX2ZiaYp2gsEp8MC3B63lXxM63dJN1ibfhxFunUZy92g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1360&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;SD 卡选择 16G 的即可，如果容量大一些也是可以的，读写速度自然也是越快越好了，这里我烧录的系统是官方推荐的 Raspberry Pi OS，针对树莓派进行了性能优化，由于是基于 Debian 开发的操作系统，经常使用 Ubuntu 的同学上手难度会稍微低一些。&lt;/p&gt;&lt;p&gt;当然了，你也可以选择烧录其他的操作系统，例如 Ubuntu、Manjaro、Android 等操作系统，甚至有人成功烧录了最近新出的 Windows11，链接在这里，有兴趣的小伙伴自行阅读 👉&lt;span&gt;How to Install Windows 11 on a Raspberry Pi 4&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.0615640599001663&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT1jkQy4JIjMvAfGCWC2NzB3YsTQcfOcBviaup2p6gia2JRZdKTrHBgfjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;家用树莓派方案指北&lt;/h2&gt;&lt;p&gt;说了树莓派软硬件的选择后，终于可以进入本文的正题了。&lt;/p&gt;&lt;p&gt;树莓派的玩法有很多，网上有很多控制机器人、外接灯泡控制开关等，说实话，这些玩法教育意义大于实用意义，毕竟家用也不会把灯泡接到树莓派上，直接买个小米的智能灯泡控制体验不比这个好吗？&lt;/p&gt;&lt;p&gt;之所以一开始就舍弃使用旧电脑作为家用服务器这一方案的一个原因就是功耗，网上有人对树莓派的功耗进行过测试，4B 的功耗：空闲时 2.7 W，负载时到 6.4 W。按照家里电费 0.7 元一度电的价格计算，一年 365 天每天 24 小时高负荷运行的电费也才&lt;strong&gt;6.4×24×365÷1000×0.7=39.2448 元&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4318181818181818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT7EIlMpGUIsHYLiaB12VcHTYb14mUFibcIcdSWLnMFDh9gongpAE2w3Yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;968&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;因此树莓派适用于一些适合 24 小时在线的服务，我的服务有：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;离线下载（Aria2、qbittorrent）&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;米家、HomeKit 等智能家居中转控制（HomeAssistant）&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;局域网文件共享（Samba）&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;Linux Server（Docker）&lt;/span&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;家庭 Dashboard 中控面板（Flutter Web）&lt;/span&gt;&lt;span&gt;&lt;span&gt;6.&lt;/span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;接下来我将会按照顺序逐一介绍。&lt;/p&gt;&lt;h3&gt;连接树莓派——连通性测试&lt;/h3&gt;&lt;p&gt;想要使用树莓派第一步肯定是连接上树莓派，连接树莓派的方式有很多种，直接接键盘、鼠标、显示器，或者通过 SSH/VNC/FTP，无论用何种方式只要能连接上网络即可。方便起见，建议先连接显示器，然后开启 SSH 和 VNC 服务。网络上的教程很多很详细，这里不再赘述。&lt;/p&gt;&lt;p&gt;本节主要来介绍一个很关键但是很多文章都忽略的内容，即树莓派与个人电脑间的&lt;strong&gt;网络连通性测试&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;如果要实现诸如上述局域网共享文件、离线下载等功能，一个很重要的特点是工作电脑与树莓派之间的&lt;strong&gt;传输速度要快&lt;/strong&gt;，不然我离线下载完文件后传到自己电脑上还要好久，那岂不是多此一举吗？&lt;/p&gt;&lt;p&gt;由于大多数教程中工作电脑与树莓派的连接都是通过 WI-FI 而非网线的方式，因此在一开始就有必要针对二者的网络传输速度做一个测试，这里我推荐使用&lt;strong&gt;「iPerf3」&lt;/strong&gt;，安装和使用都很简单。&lt;/p&gt;&lt;p&gt;我们需要在树莓派上使用 apt 安装 iPerf3，然后启动 iPerf3 的服务。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 安装 iPerf3&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo apt install iperf3&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 启动 iPerf3 服务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;iperf3 -p 3005 -s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;-p&lt;/code&gt;设置监听的端口号，客户端需要使用该端口与服务端进行通信。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;-s&lt;/code&gt;设置为服务模式运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;然后在工作电脑上也安装上 iPerf3 即可，mac 电脑直接执行 &lt;code&gt;brew install iperf3&lt;/code&gt; 即可安装，然后我们只需执行下面的命令即可。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 测试 Mac 与树莓派之间的网速（我的树莓派内网 ip 为192.168.31.189）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;iperf3 -c 192.168.31.189 -p 3005&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;我的测试结果如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6466165413533834&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTibITmOLGJkricBnYcc9YS7yKH1ib0eb7u1mPuqv9WaawysuQx2GxGngjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;换算一下，上传下载大约能有 7MB/s 的速度，虽然速度不是很快，但是基本可以用。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;PS：如果有小伙伴测试结束后发现连通速度有些慢，不妨检查下你的树莓派是否连接到 5GHz 的 Wi-Fi 上。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;确认连接速度可以正常使用后，我们便可以来安装使用一个非常重要的工具了——Docker。&lt;/p&gt;&lt;h3&gt;使用 Docker 为树莓派赋能&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7486263736263736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT2Fr6cZjH9WACvSLh0dYO9fFZIEibCMOMWZotfhwkYK1Zu46gDuorF4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Docker 的存在使得开发者可以快速搭建自己所需要的开发环境，只需指定好镜像后即可快速生成所需要的容器环境。并且由于树莓派使用的是 ARM 架构的芯片，很多常用软件如果想要正常安装使用需要自行编译，这对于性能不够强悍的树莓派来说无疑是一种负担，为了让我们的精力聚焦在在实际的开发中，而不是纠缠着应用运行环境的问题上，这次我们使用 Docker 搭建所需要的开发环境，为树莓派赋能。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;对 Docker 还不了解的小伙伴可以移步 👉https://yeasy.gitbook.io/docker_practice/&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在树莓派上安装 Docker、配置镜像加速在上面的链接中都已给出，值得一提的是，Docker 的定位在于将容器内的环境搭建起来，但如果我们想将多个容器的运行方式和配置固定下来，应用于容器编排，则需要使用 Docker Compose。&lt;/p&gt;&lt;p&gt;举个例子，我们有一个应用容器，需要 mysql 存储数据， nginx 作转发，消息队列作数据转化，那在每次启动前，需要将每个前置容器先启动，再把应用容器跑起来，这本身就是一个重复的动作。而且在启动时，还需要针对每个容器进行不同的配置，所以为了&lt;strong&gt;实现对多个容器的组合管理&lt;/strong&gt;，例如规定容器启动顺序，规定好配置内容等行为，Docker Compose 便应运而生了。&lt;/p&gt;&lt;p&gt;Docker Compose 的安装方式有很多种，但由于 ARM 架构的限制，树莓派上的 Docker Compose 建议使用 pip 安装。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo pip3 install -U docker-compose&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;！！！一定是 Python3 版本的 pip，所以建议直接使用 pip3&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;监管你的 Docker——Portainer&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5233333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTD9wIsaZOzkA31AuYvX5IzGcuW6mrjLLZeuHQomW5Gr1iajwpvXKoD5w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Portainer 是 Docker 的轻量级，跨平台和开源管理 UI。你可以通过 WebUI 管理你的 docker 容器，镜像，网络和卷。他的安装也很简单，直接执行以下命令即可。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;安装完成后如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.41005291005291006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTpD94aK3Lky6cAdpGibBtEpkTwytqAcsLJguV7ib3liaVXsnXRSKxpBcoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1512&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;监控面板——Pi Dashboard&lt;/h3&gt;&lt;p&gt;有了 Docker 之后，我们便可以方便快速的进行各种软件的安装了。为了方便监控我们的树莓派情况，首当其冲的便是 Pi Dashboard。&lt;/p&gt;&lt;p&gt;安装很简单，只需执行下面一行命令 👇&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo docker run -d --name docker-pi-dashboard -e &#x27;LISTEN=1024&#x27; --net=host ecat/docker-pi-dashboard&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;启动完毕后可以通过&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo docker ps | grep docker-pi-dashboard&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;来确认我们的容器是否启动成功，如果启动成功，在浏览器中输入&lt;code&gt;&amp;lt;你的IP地址&amp;gt;:1024&lt;/code&gt;即可访问到 pi dashboard 了。如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6252676659528907&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTOCVPxErLfCYfmw2fO5kJAwX9bibyoqmmUOicfxPCLUXWl1F1NPXOBVvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;智能家居——HomeAssistant&lt;/h3&gt;&lt;p&gt;智能家居是眼下最火的领域之一，小米、苹果、华为等都在布局该领域，旗下的米家、HomeKit 等都已经提供了非常完善的服务，那么我们为什么要在树莓派上搭建一套智能家居系统呢？&lt;/p&gt;&lt;p&gt;其实原因很简单，虽然目前智能家居产品众多，但是尚未有一种智能家居解决方案同时满足设备种类多、交互体验好、成本低廉的特性，为此很多情况我们都会选择某一家的某一些产品，这就有可能会造成整个家里出现小米的台灯、华为的传感器、苹果的音箱等多种混乱的局面，然后你还要安装多个 App，这种体验无疑是非常差的。&lt;/p&gt;&lt;p&gt;在计算机领域有一句名言——&lt;strong&gt;所有兼容问题都可以通过加一层抽象解决，所有性能问题都可以通过去掉一层抽象解决。&lt;/strong&gt;既然这样，何不在这些智能家居平台基础上再抽出一层，提供一个统一的控制入口？&lt;/p&gt;&lt;p&gt;答案自然是可以的，并且已经有人将方案开源出来了，这就是本节要介绍的 HomeAssistant。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.45717344753747324&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTXkKkHVKzL0Yncs1I7KQIjaZJMwQfMKbelBzQ2bv24KY8ODf4aJsD1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;无论是米家还是 HomeKit 都只能在各自的生态中使用，米家只有移动端 App，HomeKit 虽然覆盖了平板、手机、电脑、手表等，但也仅限苹果生态。（互联网发展了这么多年，却忘记了他最开始的形态，真不知道这是一种进步还是一种悲哀）&lt;/p&gt;&lt;p&gt;扯了这么远，回到正题，HomeAssistant 的安装使用非常简单，官网已经写的非常详细了 👉https://www.home-assistant.io/installation/raspberrypi#docker-compose&lt;/p&gt;&lt;p&gt;推荐使用 Docker Compose 安装。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;version: &quot;3&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;services:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  homeassistant:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    container_name: homeassistant&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    image: &quot;ghcr.io/home-assistant/raspberrypi4-homeassistant:stable&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    volumes:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - /PATH_TO_YOUR_CONFIG:/config&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - /etc/localtime:/etc/localtime:ro&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    restart: unless-stopped&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    privileged: true&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    network_mode: host&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;指定好 volumes 的路径后执行&lt;code&gt;docker-compose up -d&lt;/code&gt;指令即可。&lt;/p&gt;&lt;h3&gt;米家的接入&lt;/h3&gt;&lt;p&gt;安装好之后你的家庭应该是空的，如果想要绑定米家设备，可以接入米家的 MIoT 插件，文档 👉https://github.com/al-one/hass-xiaomi-miot/blob/master/README_zh.md&lt;/p&gt;&lt;p&gt;填写好自己的小米账号和密码后，即可利用网页在 HomeAssistant 中查看使用自己的米家设备，以此达到跨平台的目的。下图是我自己配置的控制页面 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3484848484848485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTsR1YcHs9vBAibtibTwU5zdHvibbxlCCuLyZS8LdUhJMQ6YBxIZ1vn26lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1914&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;开放能力——REST API&lt;/h3&gt;&lt;p&gt;如果只是提供了一个网页用于控制，那么本质上也就是在交互体验上进行了优化，并不值得单独开一小节。HomeAssistant 作为一个开源产品，最大的优势在于提供了开放的能力，使每个用户按照自己的想法去进行更改设置，我们完全可以根据 HA 提供的 REST API 针对自己的需求定制化。（例如制作一个属于你自己的家庭枢纽，后面会提到）&lt;/p&gt;&lt;p&gt;HomeAssistant 默认是不会开放 REST API 功能，你需要在&lt;code&gt;configuration.yaml&lt;/code&gt;文件中配置一下&lt;code&gt;api&lt;/code&gt;选项，如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.39290586630286495&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTHfG7yg2o5nCMjVsWoXXYpwx2IElEsrm71gUeibH9EicPOWsQicecp8QQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;733&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;关于 HomeAssistant 可配置的选项还有很多，具体的可以参考文档 👉https://developers.home-assistant.io/&lt;/p&gt;&lt;h3&gt;离线下载——Aria2&lt;/h3&gt;&lt;p&gt;有些资源下载时间较长，不适合电脑长期挂机下载的，这时就可以将我们的树莓派变成一个离线下载的服务器。提到下载，不可不提的一个神器便是 Aria2。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2391713747645951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTUXus5gHY0Q8YibCGOhBU1epNMlme8PEVP8ibE4htSbckTJw0wreZ3xkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;531&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Aria2 是一款自由、跨平台&lt;strong&gt;命令行界面&lt;/strong&gt;的下载管理器，和 wget 这类下载器不同的是，Aria2 不仅支持 BitTorrent，还能够从各种来源多路检索所请求的文件。包括 HTTP，HTTPS，FTP 和 BitTorrent 协议。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;对种子下载原理感兴趣的同学可以阅读我的这篇文章 👉&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484780&amp;amp;idx=1&amp;amp;sn=f4c12708e159821f700811b1dc1be35c&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《人人都是 LSP？—— 种子与文件下载的相爱相杀》&quot; data-linktype=&quot;2&quot;&gt;《人人都是 LSP？—— 种子与文件下载的相爱相杀》&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;而且 Raspbain 系统默认已经安装了 Aria2，运行 apt-cache show aria2 即可查看安装信息，因此我们要做的就是为 Aria2 找一个图形化界面即可，使用 Docker 的一大好处就是可以直接去找别人已经打包好的镜像文件，让安装使用变得十分易用。&lt;/p&gt;&lt;p&gt;只需执行下述命令即可启动一个 Aira2 的图形化界面了 👇&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;docker run -d --name aria2-ui-pi -p 8888:80 -p 6800:6800 -v /data:/data --restart=always huangzulin/aria2-ui-pi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;默认下载路径是在容器内的 /data 文件夹，为了方便使用最好指定一个 volume 映射&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;局域网文件共享——Samba&lt;/h3&gt;&lt;p&gt;现在，手机是 Android/iOS，电脑是 Win/Mac，除去苹果生态，设备与设备之间的文件传输直至今日仍然是一个大问题。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.42875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTXa1WnX0lGtFUcY4WpuByyFDrQ89H8M8L5F7Ytu1CVR8MTScyZaIr8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Samba 是在 Linux 和 UNIX 系统上实现 SMB 协议的一个免费软件，SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。通过该协议，你可以快速方便的在 Win 与 Linux/Unix 之间分享文件，而不是通过 QQ 在线传文件。&lt;/p&gt;&lt;p&gt;安装过程也十分简单，你可以选择 apt 安装也可以选择 docker 直接安装，网上的教程非常多，详情可参考 👉&lt;span&gt;在树莓派上配置 Samba 服务教程&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;打造属于你自己的家庭枢纽&lt;/h3&gt;&lt;p&gt;无论是 HomeAssistant 还是 Aria2，这些都是别人写好的东西，如果你想让树莓派更加定制化，你可以按照自己的想法去边写一些小程序（这也就是为什么之前要提一下开放 HomeAssistant 的 REST API）。&lt;/p&gt;&lt;p&gt;如果想要让自己的程序运行在树莓派上，大致有以下几条路可以走 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5580568720379147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT6ZX8icIuZPtCNtvIHdJ6Ply072d2icJjr1icTgPPAs3mZefHpw4RC4wAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;为了打造一个属于自己的家庭枢纽，我的想法是在一块&lt;strong&gt;可以触摸的屏幕&lt;/strong&gt;上控制自己家的智能家居设备（借助 HomeAssistant），直观地查看天气（和风天气），追踪快递行程（爬虫）、时钟、纪念日/倒数日/照片墙等，因此这是一个完整的网页，我选择的技术栈是 SpringBoot + Flutter Web + Nginx，然后使用 Docker 打包成一个镜像启动整个服务。&lt;/p&gt;&lt;p&gt;部分页面如下 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4071573261309926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTQODBvtibq3uNmOM6nHcfU9ckyDenX7jMALXWp1ygakePmAicDDN1WW8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1481&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;我在做的就是 Java 相关的工作，后端选择 SpringBoot 无可厚非，之所以选择 Flutter Web 而不是传统的 Vue 或者 React，一方面是因为 Flutter 的声明式 UI 写起来确实比传统 Web 页面编写更舒服，效率更高，另一方面是因为用 Flutter 写的网页可以无缝转换成在 Android/iOS/PC/Linux/macOS 这些平台上的原生 App，有助于后期针对多个平台的覆盖（当然更多还是因为我已经把 Vue 和 React 忘的差不多了)。&lt;/p&gt;&lt;p&gt;目前这个网页比较简陋，还有很多我想做的功能没来得及做上去，但后续我准备持续更新这个代码，后续如果在家里运行效果还不错的话，甚至有想开源出去的想法，不过这就是后话了。&lt;/p&gt;&lt;h3&gt;随时随地访问——内网穿透&lt;/h3&gt;&lt;p&gt;玩了这么多东西，有没有发现一个最大的问题？&lt;/p&gt;&lt;p&gt;没错，就是这些所有的东西必须要求你的电脑和树莓派处在同一个网络里，即局域网环境里。虽然我一开始的使用场景就是在家里使用，但如果我在公司突然想看一部美剧了，但是用公司电脑下载视频显然是不现实的，如果这时候我可以在外网直接访问家里树莓派的离线下载服务，那么下班回家后岂不就可以看到自己想看的电影了吗？&lt;/p&gt;&lt;p&gt;所以，最好的方式就是联系你的宽带运营商，并申请一个公网 IP，这样你就可以通过这个公网 IP 访问到你的树莓派了。&lt;/p&gt;&lt;p&gt;据我所知，目前只有电信的部分地区会给公网 IP，大多数运营商是不会提供公网 IP 的，而且申请流程很麻烦，所以为了可以随时随地的从外网访问家里服务器的文件或其他服务，我们可以为树莓派做一个&lt;strong&gt;「内网穿透」&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.32531824611032534&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTLLziazMtXZicKqhIu94GufrehGj2OZPvDRlqxI7FNybPLx5HBZfjRxuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;「计算机领域的大多数问题都可以通过增加一层来解决」，所谓内网穿透，无非是在内部网络和互联网之间增加一个中转服务器，这个中转服务器负责接收你的请求并转发到内部服务器，也即&lt;strong&gt;「代理」&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;当然了，内网穿透的原理肯定不会这么简单，这里只是通俗的解释一下，如果之后有机会来详细说下。所以为了实现内网穿透，我们需要有一台可以公网访问的服务器作为中转桥梁，这时我突然想到我毕业前买的学生机还没到期呢，现在刚好在吃灰，拿它来做中转岂不是最好的？&lt;/p&gt;&lt;p&gt;内网穿透服务器的选择有很多，FRP 是用的最多的，但我这里选择的是 👉&lt;span&gt;nps&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;，原因也很简单，页面好看，交互简单，性能够用。&lt;/p&gt;&lt;p&gt;nps 是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持 tcp、udp 流量转发，可支持&lt;strong&gt;任何 tcp、udp 上层协议&lt;/strong&gt;（访问内网网站、本地支付接口调试、ssh 访问、远程桌面，内网 dns 解析等等……），此外还支持内网 http 代理、内网 socks5 代理、p2p 等，并带有功能强大的 web 管理端。&lt;/p&gt;&lt;p&gt;我们只需要在云主机上安装好服务端，并按照后台提示在树莓派上安装好客户端，简单设置自己要转发的端口即可实现内网穿透。&lt;/p&gt;&lt;p&gt;官方文档在 👉https://ehang-io.github.io/nps/#/?id=nps&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTLzqYLx5Eus5D03LDor9OCorJn6Licv6QtLg3NibpdpicEia3Zf4eZhPAeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;最后&lt;/h2&gt;&lt;p&gt;拥有一台树莓派最大的好处就是可以充分发挥你的灵感与创意，如果你有想法、有能力、有时间，不妨让树莓派成为你实现想法的载体。&lt;/p&gt;&lt;p&gt;最后扯一点文章之外的，工作之后的时间果然少了很多，这篇文章从开始写到现在完成差不多花了一个星期，阿里的工作强度的确很大，每天下班到家多半也是 10 点之后的事情了，能留出来码字的时间实在有限，难得周末有空，把近期搬家捣鼓自己家的想法写下来，也算是自己新阶段的开始。这段时间阅读了很多内部的优秀文档，也希望自己未来的文章可以像内网的大神们一样更专业，新的征程加油！&lt;/p&gt;&lt;p&gt;以上就是本文的全部内容了，如果觉得还不错的话，不妨给我一个点赞关注支持一下哦 👍&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; How to Install Windows 11 on a Raspberry Pi 4: &lt;em&gt;https://www.tomshardware.com/how-to/install-windows-11-raspberry-pi#xenforo-comments-3710927&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; 在树莓派上配置 Samba 服务教程: &lt;em&gt;https://ee-fans.com/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E9%85%8D%E7%BD%AEsamba%E6%9C%8D%E5%8A%A1%E6%95%99%E7%A8%8B/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; nps: &lt;em&gt;https://github.com/ehang-io/nps&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0706634c580426206aa5bbac7e0a5c28</guid>
<title>送给水深火热的 Gopher 们的一剂解药</title>
<link>https://toutiao.io/k/jzpfpqy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;看了看日历，现在已经是 2021 年了，偶尔还是能看到有人在发诸如 《http body 未关闭导致线上事故》，或者 《sql.Rows 未关闭半夜惊魂》类的文章，令人有一种梦回 2015 的感觉。&lt;/p&gt;&lt;p&gt;在这个 Go 的静态分析工具已经强到烂大街的时代，写这些文章除了暴露这些人所在的公司基础设施比较差，代码质量低以外，并不能体现出什么其它的意思了。毕竟哪怕是不懂怎么读源码，这样的问题你 Google 搜一下也知道是怎么回事了。&lt;/p&gt;&lt;p&gt;特别是有些人还挂着大公司的 title，让人更加不能理解了。下面是简单的静态分析工具的科普，希望给那些还在水深火热的 Gopher 们送点解药。&lt;/p&gt;&lt;h1&gt;何谓静态分析&lt;/h1&gt;&lt;p&gt;静态分析是通过扫描并解析用户代码，寻找代码中的潜在 bug 的一种手段。&lt;/p&gt;&lt;p&gt;静态分析一般会集成在项目上线的 CI 流程中，如果分析过程找到了 bug，会直接阻断上线，避免有问题的代码被部署到线上系统。从而在部署早期发现并修正潜在的问题。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5189437428243399&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbfVk2pichYsECSBZ1nM445vAPZNUbIrlvOYzwvFynWKic4dOYOugicqeLtNOeicia5tLXOUKTPSO4e1enQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;871&quot;/&gt;&lt;/p&gt;&lt;h2&gt;社区常见 linter&lt;/h2&gt;&lt;p&gt;时至今日，社区已经有了丰富的 linter 资源供我们使用，本文会挑出一些常见 linter 进行说明。&lt;/p&gt;&lt;h3&gt;go lint&lt;/h3&gt;&lt;p&gt;go lint 是官方出的 linter，是 Go 语言最早期的 linter 了，其可以检查：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;导出函数是否有注释&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;变量、函数、包命名不符合 Go 规范，有下划线&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;receiver 命名是否不符合规范&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;但这几年社区的 linter 蓬勃发展，所以这个项目也被官方 deprecated 掉了。其主要功能被另外一个 linter：revive[^1] 完全继承了。&lt;/p&gt;&lt;h3&gt;go vet&lt;/h3&gt;&lt;p&gt;go vet 也是官方提供的静态分析工具，其内置了锁拷贝检查、循环变量捕获问题、printf 参数不匹配等工具。&lt;/p&gt;&lt;p&gt;比如新手老手都很容易犯的 loop capture 错误：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt; {&lt;span&gt;1&lt;/span&gt; : &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;}&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; b = &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]*&lt;span&gt;int&lt;/span&gt;{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; k, r := &lt;span&gt;range&lt;/span&gt; a {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   b[k] = &amp;amp;r&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;go vet 会直接把你骂醒：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;~/test git:master ❯❯❯ go vet ./clo.go&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &lt;span&gt;command&lt;/span&gt;-line-arguments&lt;/span&gt;&lt;br/&gt;./clo.go:8:6: loop variable k captured by func literal&lt;br/&gt;./clo.go:8:12: loop variable r captured by func literal&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行 go tool vet help 可以看到 go vet 已经内置的一些 linter。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;~ ❯❯❯ go tool vet help&lt;br/&gt;vet is a tool for static analysis of Go programs.&lt;br/&gt;&lt;br/&gt;vet examines Go source code and reports suspicious constructs,&lt;br/&gt;such as Printf calls whose arguments do not align with the format&lt;br/&gt;string. It uses heuristics that do not guarantee all reports are&lt;br/&gt;genuine problems, but it can find errors not caught by the compilers.&lt;br/&gt;&lt;br/&gt;Registered analyzers:&lt;br/&gt;&lt;br/&gt;    asmdecl      report mismatches between assembly files and Go declarations&lt;br/&gt;    assign       check for useless assignments&lt;br/&gt;    atomic       check for common mistakes using the sync/atomic package&lt;br/&gt;    bools        check for common mistakes involving boolean operators&lt;br/&gt;    buildtag     check that +build tags are well-formed and correctly located&lt;br/&gt;    cgocall      detect some violations of the cgo pointer passing rules&lt;br/&gt;    composites   check for unkeyed composite literals&lt;br/&gt;    copylocks    check for locks erroneously passed by value&lt;br/&gt;    errorsas     report passing non-pointer or non-error values to errors.As&lt;br/&gt;    httpresponse check for mistakes using HTTP responses&lt;br/&gt;    loopclosure  check references to loop variables from within nested functions&lt;br/&gt;    lostcancel   check cancel func returned by context.WithCancel is called&lt;br/&gt;    nilfunc      check for useless comparisons between functions and nil&lt;br/&gt;    printf       check consistency of Printf format strings and arguments&lt;br/&gt;    shift        check for shifts that equal or exceed the width of the integer&lt;br/&gt;    stdmethods   check signature of methods of well-known interfaces&lt;br/&gt;    structtag    check that struct field tags conform to reflect.StructTag.Get&lt;br/&gt;    tests        check for common mistaken usages of tests and examples&lt;br/&gt;    unmarshal    report passing non-pointer or non-interface values to unmarshal&lt;br/&gt;    unreachable  check for unreachable code&lt;br/&gt;    unsafeptr    check for invalid conversions of uintptr to unsafe.Pointer&lt;br/&gt;    unusedresult check for unused results of calls to some functions&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;默认情况下这些 linter 都是会跑的，当前很多 IDE 在代码修改时会自动执行 go vet，所以我们在写代码的时候一般就能发现这些错了。&lt;/p&gt;&lt;p&gt;但 &lt;code&gt;go vet&lt;/code&gt; 还是应该集成到线上流程中，因为有些程序员的下限实在太低。&lt;/p&gt;&lt;h3&gt;errcheck&lt;/h3&gt;&lt;p&gt;Go 语言中的大多数函数返回字段中都是有 error 的：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sayhello&lt;/span&gt;&lt;span&gt;(wr http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; io.WriteString(wr, &lt;span&gt;&quot;hello&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/&quot;&lt;/span&gt;, sayhello)&lt;br/&gt; http.ListenAndServe(&lt;span&gt;&quot;:1314&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;) &lt;span&gt;// 这里返回的 err 没有处理&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个例子中，我们没有处理 &lt;code&gt;http.ListenAndServe&lt;/code&gt; 函数返回的 error 信息，这会导致我们的程序在启动时发生静默失败。&lt;/p&gt;&lt;p&gt;程序员往往会基于过往经验，对当前的场景产生过度自信，从而忽略掉一些常见函数的返回错误，这样的编程习惯经常为我们带来意外的线上事故。例如，规矩的写法是下面这样的：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;data, err := getDataFromRPC()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// do business logic&lt;/span&gt;&lt;br/&gt;age := data.age&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而自信的程序员可能会写成这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;data, _ := getDataFromRPC()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// do business logic&lt;/span&gt;&lt;br/&gt;age := data.age&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果底层 RPC 逻辑出错，上层的 data 是个空指针也是很正常的，如果底层函数返回的 err 非空时，我们不应该对其它字段做任何的假设。这里 data 完全有可能是个空指针，造成用户程序 panic。&lt;/p&gt;&lt;p&gt;errcheck 会强制我们在代码中检查并处理 err。&lt;/p&gt;&lt;h3&gt;gocyclo&lt;/h3&gt;&lt;p&gt;gocyclo 主要用来检查函数的圈复杂度。圈复杂度可以参考下面的定义：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;圈复杂度(Cyclomatic complexity)是一种代码复杂度的衡量标准，在 1976 年由 Thomas J. McCabe, Sr. 提出。在软件测试的概念里，圈复杂度用来衡量一个模块判定结构的复杂程度，数量上表现为线性无关的路径条数，即合理的预防错误所需测试的最少路径条数。圈复杂度大说明程序代码可能质量低且难于测试和维护，根据经验，程序的可能错误和高的圈复杂度有着很大关系。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;看定义较为复杂但计算还是比较简单的，我们可以认为：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个 if，圈复杂度 + 1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个 switch 的 case，圈复杂度 + 1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个 for 循环，圈复杂度 + 1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个 &amp;amp;&amp;amp; 或 ||，圈复杂度 + 1&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在大多数语言中，若函数的圈复杂度超过了 10，那么我们就认为该函数较为复杂，需要做拆解或重构。部分场景可以使用表驱动的方式进行重构。&lt;/p&gt;&lt;p&gt;由于在 Go 语言中，我们使用 &lt;code&gt;if err != nil&lt;/code&gt; 来处理错误，所以在一个函数中出现多个 &lt;code&gt;if err != nil&lt;/code&gt; 是比较正常的，因此 Go 中函数复杂度的阈值可以稍微调高一些，15 是较为合适的值。&lt;/p&gt;&lt;p&gt;下面是在个人项目 elasticsql 中执行 gocyclo 的结果，输出 top 10 复杂的函数：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;~/g/s/g/c/elasticsql git:master ❯❯❯ gocyclo -top 10  ./&lt;br/&gt;23 elasticsql handleSelectWhere select_handler.go:289:1&lt;br/&gt;16 elasticsql handleSelectWhereComparisonExpr select_handler.go:220:1&lt;br/&gt;16 elasticsql handleSelect select_handler.go:11:1&lt;br/&gt;9 elasticsql handleGroupByFuncExprDateHisto select_agg_handler.go:82:1&lt;br/&gt;9 elasticsql handleGroupByFuncExprDateRange select_agg_handler.go:154:1&lt;br/&gt;8 elasticsql buildComparisonExprRightStr select_handler.go:188:1&lt;br/&gt;7 elasticsql TestSupported select_test.go:80:1&lt;br/&gt;7 elasticsql Convert main.go:28:1&lt;br/&gt;7 elasticsql handleGroupByFuncExpr select_agg_handler.go:215:1&lt;br/&gt;6 elasticsql handleSelectWhereOrExpr select_handler.go:157:1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;bodyclose&lt;/h3&gt;&lt;p&gt;使用 bodyclose[^2] 可以帮我们检查在使用 HTTP 标准库时忘记关闭 http body 导致连接一直被占用的问题。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;resp, err := http.Get(&lt;span&gt;&quot;http://example.com/&quot;&lt;/span&gt;) &lt;span&gt;// Wrong case&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// handle error&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;body, err := ioutil.ReadAll(resp.Body)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;像上面这样的例子是不对的，使用标准库很容易犯这样的错。bodyclose 可以直接检查出这个问题：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &lt;span&gt;command&lt;/span&gt;-line-arguments&lt;/span&gt;&lt;br/&gt;./httpclient.go:10:23: response body must be closed&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以必须要把 Body 关闭：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;resp, err := http.Get(&lt;span&gt;&quot;http://example.com/&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// handle error&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; resp.Body.Close() &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;body, err := ioutil.ReadAll(resp.Body)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;HTTP 标准库的 API 设计的不太好，这个问题更好的避免方法是公司内部将 HTTP client 封装为 SDK，防止用户写出这样不 Close HTTP body 的代码。&lt;/p&gt;&lt;h3&gt;sqlrows&lt;/h3&gt;&lt;p&gt;与 HTTP 库设计类似，我们在面向数据库编程时，也会碰到 sql.Rows 忘记关闭的问题，导致连接大量被占用。sqlrows[^3] 这个 linter 能帮我们避免这个问题，先来看看错误的写法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;rows, err := db.QueryContext(ctx, &lt;span&gt;&quot;SELECT * FROM users&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; rows.Next() {&lt;br/&gt; err = rows.Scan(...)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err &lt;span&gt;// NG: this return will not release a connection.&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;正确的写法需要在使用完后关闭 sql.Rows：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;rows, err := db.QueryContext(ctx, &lt;span&gt;&quot;SELECT * FROM users&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; rows.Close() &lt;span&gt;// NG: using rows before checking for errors&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与 HTTP 同理，公司内也应该将 DB 查询封装为合理的 SDK，不要让业务使用标准库中的 API，避免上述错误发生。&lt;/p&gt;&lt;h3&gt;funlen&lt;/h3&gt;&lt;p&gt;funlen[^4] 和 gocyclo 类似，但是这两个 linter 对代码复杂度的视角不太相同，gocyclo 更多关注函数中的逻辑分支，而 funlen 则重点关注函数的长度。默认函数超过 60 行和 40 条语句时，该 linter 即会报警。&lt;/p&gt;&lt;h2&gt;linter 集成工具&lt;/h2&gt;&lt;p&gt;一个一个去社区里找 linter 来拼搭效率太低，当前社区里已经有了较好的集成工具，早期是 gometalinter，后来性能更好，功能更全的 golangci-lint 逐渐取而代之。目前 golangci-lint 是 Go 社区的绝对主流 linter。&lt;/p&gt;&lt;h3&gt;golangci-lint&lt;/h3&gt;&lt;p&gt;golangci-lint[^5] 能够通过配置来 enable 很多 linter，基本主流的都包含在内了。&lt;/p&gt;&lt;p&gt;在本节开头讲到的所有 linter 都可以在 golangci-lint 中进行配置，&lt;/p&gt;&lt;p&gt;使用也较为简单，只要在项目目录执行 golangci-lint run . 即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;~/g/s/g/c/elasticsql git:master ❯❯❯ golangci-lint run .&lt;br/&gt;main.go:36:9: S1034: assigning the result of this type assertion to a variable (switch stmt := stmt.(type)) could eliminate type assertions in switch cases (gosimple)&lt;br/&gt; switch stmt.(type) {&lt;br/&gt;        ^&lt;br/&gt;main.go:38:34: S1034(related information): could eliminate this type assertion (gosimple)&lt;br/&gt;  dsl, table, err = handleSelect(stmt.(*sqlparser.Select))&lt;br/&gt;                                 ^&lt;br/&gt;main.go:40:23: S1034(related information): could eliminate this type assertion (gosimple)&lt;br/&gt;  return handleUpdate(stmt.(*sqlparser.Update))&lt;br/&gt;                      ^&lt;br/&gt;main.go:42:23: S1034(related information): could eliminate this type assertion (gosimple)&lt;br/&gt;  return handleInsert(stmt.(*sqlparser.Insert))&lt;br/&gt;                      ^&lt;br/&gt;select_handler.go:192:9: S1034: assigning the result of this type assertion to a variable (switch expr := expr.(type)) could eliminate type assertions in switch cases (gosimple)&lt;br/&gt; switch expr.(type) {&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;参考资料&lt;/h2&gt;&lt;p&gt;[1] https://revive.run/&lt;/p&gt;&lt;p&gt;[2] https://github.com/timakin/bodyclose&lt;/p&gt;&lt;p&gt;[3] https://github.com/gostaticanalysis/sqlrows&lt;/p&gt;&lt;p&gt;[4] https://github.com/ultraware/funlen&lt;/p&gt;&lt;p&gt;[5] https://github.com/golangci/golangci-lint&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e13213ecdfb6cc70adb7cfbf7eff97c2</guid>
<title>最多能创建多少个 TCP 连接？</title>
<link>https://toutiao.io/k/x2l5h9z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tools=&quot;新媒体管家&quot; data-label=&quot;powered by xmt.cn&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我是一个 Linux 服务器上的进程，名叫小进。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老是有人说我最多只能创建 65535 个 TCP 连接。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我不信这个邪，今天我要亲自去实践一下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我走到操作系统老大的跟前，说：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&quot;老操，我要建立一个 TCP 连接！&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操不慌不忙，拿出一个表格递给我，&lt;/span&gt;&lt;span&gt;&quot;小进，先填表吧&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1990521327014218&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRym7ShrNKibX2uogdzjXe1XQrLfClo3Jea9ETQz4POtSnA3kibWnkYrkkASfNcuLH7ZUK6FSfBe0uA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;844&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我一看这个表，这不就是经典的 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;socket 四元组&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;嘛。我只有一块网卡，其 IP 地址是 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;123.126.45.68&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，我想要与 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;110.242.68.3&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 的 80 端口建立一个 TCP 连接，我将这些信息填写在了表中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1990521327014218&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRym7ShrNKibX2uogdzjXe1XuOibqiav23w24anZnBkG04ibuz6B6m1JeuEhqQY2ACGicO04ziarc9Iniclg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;844&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;源端口号填什么呢？我记得端口号是 16 位的，可以有 0 ~ 65535 这个范围的数字，那我随便选一个吧！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正当我犹豫到底选什么数字的时候，老操一把抢过我的表格。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&quot;你墨迹个啥呢小进？源端口号不用你填，我会给你分配一个可用的数字。源IP也不用你填，我知道都有哪些网卡，并且会帮你选个合适的。真是个新手，回去等消息吧。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&quot;哦&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操带着我的表格，走了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;过了很长时间，老操终于回来了，并且带着一个纸条。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7760416666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRym7ShrNKibX2uogdzjXe1XZvSdIGaHHkJfnicIG6aXDlgoowasDibPzh6MMo8VzdaC5LCIZeBK8alA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&quot;小进，你把这个收好了。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我问道，&quot;这是啥呀？&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操不耐烦地说道，&lt;/span&gt;&lt;span&gt;&quot;刚刚说你是新手你还不服，这个 5 表示文件描述符，linux 下一切皆文件，你待会和你那个目标 IP 进行 TCP &lt;/span&gt;&lt;span&gt;通信的时候，就对着这个文件描述符读写就好啦。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&quot;这么方便！好的，谢谢老操。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我拿着这个文件描述符，把它放到属于我的内存中裱起来了，反正我只是想看看最多能创建多少 TCP 连接，又不是去真的用它，嘻嘻。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;端口号&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;过了一分钟，我又去找老操了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&quot;老操，我要建立一个 TCP 连接！&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操不慌不忙，拿出一个表格递给我，&lt;/span&gt;&lt;span&gt;&quot;小进，先填表吧&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1990521327014218&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRym7ShrNKibX2uogdzjXe1XDoMAWhLa3kVPNn6Rsp6sb6InByLZR9C6VP0emVZhU53hT25xDZSzYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这回我熟悉了，只把目标IP和目标端口填好。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1990521327014218&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRym7ShrNKibX2uogdzjXe1XUdMyUddapXu33RJ2pTOaa26Eg5liaInTczogTic81u1iaRa9knbDY6GDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;844&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操办好事之后，又带着一个纸条回来，上面写着数字&quot;6&quot;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;就这样，我每隔一分钟都去找老操建立一个新的 TCP 连接，目标 IP 都是110.242.68.3，目标端口都是 80。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操也很奇怪，不知道我在这折腾啥，他虽然权力大，但无权拒绝我的指令，每次都兢兢业业地把事情办好，并给我一张一张写着文件描述符的纸条。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;直到有一次，我收到的纸条有些不同。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.34452296819787986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRym7ShrNKibX2uogdzjXe1XwUmAQ5UXxJfOLUPQBfCyWzEBzVDtQZianS6tDNDBmyenzXBLeciaLMlw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;566&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我带着些许责怪的语气问，&quot;老操，这是怎么回事呀？&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操也没好气地说，&lt;/span&gt;&lt;span&gt;&quot;这表示端口号不够用啦！早就觉得你小子不对劲了，一个劲地对着同一个 IP 和端口创建 TCP 连接，之前没办法必须执行你给的指令，现在不行了，端口号不够用了，源端口那里我没法给你填了。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我也不是那么好骗的，质疑道。&quot;老操，你也别欺负我这个新手，我可是知道端口号是 16 位的，范围是 1~65535，一共可以创建 65535 个 TCP 连接，我现在才创建了 63977 个，怎么就不够了！&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操鄙视地看了我一眼，&lt;/span&gt;&lt;span&gt;&quot;你小子可真是闲的蛋疼啊，还真一个个数，来我告诉你吧，Linux 对可使用的端口范围是有具体限制的，具体可以用如下命令查看。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[root]&lt;span&gt;# cat /proc/sys/net/ipv4/ip_local_port_range &lt;/span&gt;&lt;br/&gt;&lt;span&gt;1024&lt;/span&gt; &lt;span&gt;65000&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&quot;看到没，当前的限制是1024~65000，所以你就只能有63977个端口号可以使用。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5454545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRym7ShrNKibX2uogdzjXe1XkmbXnmQS72MesCZnH4PFP24K8FzKCDeYqmGClxQOk80CnX6q1QcMhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我赶紧像老操道歉，&quot;哎哟真是抱歉，还是我见识太少，那这个数可以修改么？&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操也没跟我一般见识，还是耐心地回答我，&lt;/span&gt;&lt;span&gt;&quot;可以的，具体可以 vim /etc/sysctl.conf 这个文件进行修改，我们在这个文件里添加一行记录&quot;&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;net.ipv4.ip_local_port_range = &lt;span&gt;60000&lt;/span&gt; &lt;span&gt;60009&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&quot;保存好后执行 sysctl -p /etc/sysctl.conf 使其生效。这样你就只有 10 个端口号可以用了，就会更快报出端口号不够用的错误&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&quot;原来如此，谢谢老操又给我上了一课。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;哎不对，建立一个 TCP 连接，需要将通信两端的套接字（socket）进行绑定，如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;源 IP 地址：源端口号 &amp;lt;----&amp;gt;  目标 IP 地址：目标端口号&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;只要这套绑定关系构成的四元组不重复即可，刚刚端口号不够用了，是因为我一直对同一个目标IP和端口建立连接，那我换一个目标端口号试试。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1990521327014218&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRym7ShrNKibX2uogdzjXe1XnecyBMhczS5RAlQErhVyE3BRQpicTqAZY0fwACNyzXcjsO8papoMeUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;844&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我又把这个表交给老操，老操一眼就看破了我的小心思，可是也没办法，马上去给我建立了一个新的TCP连接，并且成功返回给我一个新的文件描述符纸条。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;看来成功了，只要源端口号不用够用了，就不断变换目标 IP 和目标端口号，保证四元组不重复，我就能创建好多好多 TCP 连接啦！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这也证明了有人说最多只能创建 65535 个TCP连接是多么荒唐。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;文件描述符&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;找到了突破端口号限制的办法，我不断找老操建立TCP连接，老操也拿我没有办法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;直到有一次，我又收到了一张特殊的纸条，上面写的不是文件描述符。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.34452296819787986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRym7ShrNKibX2uogdzjXe1X1x68P8r25CnhuiaibuStV0UCjfQcdcVEW9QuFGr24QPWK9ibVfPbAxZOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;566&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我又没好气地问老操，&quot;这又是咋回事？&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操幸灾乐祸地告诉我，&lt;/span&gt;&lt;span&gt;&quot;呵呵，你小子以为突破端口号限制就无法无天了？现在文件描述符不够用啦！&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&quot;怎么啥啥都有限制啊？你们操作系统给我们的限制也太多了吧？&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&quot;废话，你看看你都建了多少个TCP连接了！每建立一个TCP连接，我就得分配给你一个文件描述符，linux 对可打开的文件描述符的数量分别作了三个方面的限制。&quot;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;系统级&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：当前系统可打开的最大数量，通过 cat /proc/sys/fs/file-max 查看&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;用户级&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：指定用户可打开的最大数量，通过 cat /etc/security/limits.conf 查看&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;进程级&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：单个进程可打开的最大数量，通过 cat /proc/sys/fs/nr_open 查看&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5454545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRym7ShrNKibX2uogdzjXe1XAykbxcAe4LSLTicP9HbXKicXcz5o2TUuPloQ1b4aW7BAybdgG2blOClA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;天呢，真是人在屋檐下呀，我赶紧看了看这些具体的限制。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[root ~]&lt;span&gt;# cat /proc/sys/fs/file-max&lt;/span&gt;&lt;br/&gt;&lt;span&gt;100000&lt;/span&gt;&lt;br/&gt;[root ~]&lt;span&gt;# cat /proc/sys/fs/nr_open&lt;/span&gt;&lt;br/&gt;&lt;span&gt;100000&lt;/span&gt;&lt;br/&gt;[root ~]&lt;span&gt;# cat /etc/security/limits.conf&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;* soft nproc &lt;span&gt;100000&lt;/span&gt;&lt;br/&gt;* hard nproc &lt;span&gt;100000&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;原来如此，我记得刚刚收到的最后一张纸条是。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7075471698113207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRym7ShrNKibX2uogdzjXe1X2fD0uTvv9Sau2GSh8xBrOOaQleXIWPU1jSHk416LgJHGgdn8EK2XeA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;212&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;再之后就收到文件描述符不够的错误了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我又请教老操，&quot;老操，那这个限制可以修改么？&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操仍然耐心地告诉我，&lt;/span&gt;&lt;span&gt;&quot;当然可以，比如你想修改单个进程可打开的最大文件描述符限制为100，可以这样。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;echo &lt;span&gt;100&lt;/span&gt; &amp;gt; /proc/sys/fs/nr_open&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&quot;原来如此，我这就去把各种文件描述符限制都改大一点，也不多，就在后面加个0吧&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&quot;额，早知道不告诉你小子了。&quot;&lt;/span&gt;&lt;span&gt;老操再次用鄙视的眼睛看着我。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;线程&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;突破了文件描述符限制，我又开始肆无忌惮地创建起了TCP连接。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但我发现，老操的办事效率越来越慢，建立一个TCP连接花的时间越来越久。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有一次，我忍不住责问老操，&quot;你是不是在偷懒啊？之前找你建一个TCP连接就花不到一分钟时间，你看看最近我哪次不是等一个多小时你才搞好？&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操也忍不住了，&lt;/span&gt;&lt;span&gt;&quot;小进啊你还好意思说我，你知不知道你每建一个TCP连接都需要消耗一个线程来为你服务？现在我和CPU老大那里都忙得不可开交了，一直在为你这好几十万个线程不停地进行上下文切换，我们精力有限啊，自然就没法像以前那么快为你服务了。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5454545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRym7ShrNKibX2uogdzjXe1X8yLaR4FDwoD9fpEwEjQHucWw0En716dGbFViagFGdDqzUFwJLPibH7WQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;听完老操的抱怨，我想起了之前似乎有人跟我说过&lt;/span&gt;&lt;strong&gt;&lt;span&gt; C10K&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 问题，就是当服务器连接数达到 1 万且每个连接都需要消耗一个线程资源时，操作系统就会不停地忙于线程的上下文切换，最终导致系统崩溃，这可不是闹着玩的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我赶紧像操作系统老大请教，&quot;老操，实在不好意思，一直以为你强大无比，没想到也有忙得不可开交的时候呀，那我们现在应该怎么办呀？&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操无奈地说，&lt;/span&gt;&lt;span&gt;&quot;我劝你还是别再继续玩了，没什么意义，不过我想你也不会听我的，那我跟你说两句吧。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;你现在这种每建一个TCP连接就创建一个线程的方式，是最传统的多线程并发模型，早期的操作系统也只支持这种方式。但现在我进化了，我还支持 IO 多路复用的方式，简单说就是一个线程可以管理多个 TCP 连接的资源，这样你就可以用少量的线程来管理大量的 TCP 连接了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5454545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRym7ShrNKibX2uogdzjXe1XuXVPicOpwFl2xuDb1VDRgRf7iaoibALhNbLiaD6ZFznFiaP7ECIIwN09A9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我一脸疑惑，&quot;啥是 IO 多路复用啊？&quot;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操一脸鄙视，&lt;/span&gt;&lt;span&gt;&lt;span&gt;&quot;你这... 你去看看闪客的&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666555795&amp;amp;idx=1&amp;amp;sn=c412269d17238660f0da71e5370d11a6&amp;amp;chksm=80dcad38b7ab242e5a2cbc95ff2c8a92fc1ed568baeb5de3985a9ce087b8202f56b79b14bb11&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《你管这破玩意叫 IO 多路复用》&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《你管这破玩意叫 IO 多路复用》&lt;/a&gt;&lt;span&gt;，就明白了。&quot;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这次真是大开眼界了，我赶紧把代码改成了这种 IO 多路复用的模型，将原来的 TCP 连接销毁掉，改成同一个线程管理多个 TCP 连接，很快，操作系统老大就恢复了以往的办事效率，同时我的 TCP 连接数又多了起来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;内存&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;突破了端口号、文件描述符、线程数等重重限制的我，再次肆无忌惮地创建起了TCP连接。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;直到有一次，我又收到了一张红牌。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.34452296819787986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GLeh42uInXRym7ShrNKibX2uogdzjXe1X6SzKzO0auJjwOP7J9OXe2C4vxND0mgrwH6jSwxhvSW9SEqP3ABTDMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;566&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;嗨，又是啥东西限制了呀，改了不就完了。我不耐烦地问老操，&quot;这回又是啥毛病？&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操说道。&lt;/span&gt;&lt;span&gt;&quot;这个错误叫内存溢出，每个TCP连接本身，以及这个连接所用到的缓冲区，都是需要占用一定内存的，现在内存已经被你占满了，不够用了，所以报了这个错。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5454545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRym7ShrNKibX2uogdzjXe1XmULNiaYCGOibTEnRHIghL2SibY3cmsU8ZdhxkkJlqdTGzlwtdqQLlb9Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我看这次老操特别耐心，也没多说什么，但想着被内存限制住了，有点不太开心，于是我让老操帮我最后一个忙。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&quot;老操呀，帮小进我最后一个忙吧，你权利大，你看看把那些特别占内存的进程给杀掉，给我腾出点地方，我今天要完成我的梦想，看看TCP连接数到底能创建多少个！&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操见我真的是够拼的，便答应了我，杀死了好多进程，我很是感动。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有了老操为我争取的内存资源，我又开始日以继日地创建TCP连接。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操也不再说什么，同样日以继日地执行着我的指令。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有一次，老操语重心长地对我说，&lt;/span&gt;&lt;span&gt;&quot;差不多了，我劝你就此收手吧，现在 CPU 的占用率已经快到 100% 了。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5454545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRym7ShrNKibX2uogdzjXe1XfTQ4hWicpiaGAsKr2In5d3uYvdkaVTvGIhXfvnVxyibn3TOHnkPEfSEAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我觉得老操这人真的可笑，经过这几次的小挫折，我明白了只要思想不滑坡，方法总比苦难多，老操这人就是太谨慎了，我岂能半途而废，不管他。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我仍然继续创建着 TCP 连接。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;直到有一天，老操把我请到一个小饭馆，一块吃了顿饭，吃好后说道。&lt;/span&gt;&lt;span&gt;&quot;咱哥俩也算是配合了很久啦，今天我是来跟你道个别的。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我很不解地问，&quot;怎么了老操，发生什么事了？。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操说，&lt;/span&gt;&lt;span&gt;&quot;由于你的 TCP 连接，CPU 占用率已经很长时间维持在 100%，我们的使用者，也就是我们的上帝，几乎什么事情都做不了了，连鼠标动一下都要等好久，所以他给我下达了一个重启的指令，我执行这个指令后，你，以及像你一样的所有进程，包括我这个操作系统本身，一切都就消失了。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我大惊失色，&quot;啊，这么突然么？这条指令什么时候执行？&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老操缓缓起身，&lt;/span&gt;&lt;span&gt;&quot;就现在了，刚刚这条指令还没得到 CPU 运行的机会，不过现在到了。&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;突然，我眼前一黑，一切都没了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6397694524495677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRym7ShrNKibX2uogdzjXe1Xd6BEnFELpWfHqN03MbK0tOMRku9MGfIiaofaKHdoyVRoywicBxwibvQ4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;selected&quot; guid=&quot;bS7A&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;0&quot; col=&quot;0&quot;&gt;&lt;p line=&quot;5Y4v&quot;&gt;&lt;strong&gt;资源&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;WOfk&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;0&quot; col=&quot;1&quot;&gt;&lt;p line=&quot;2LSy&quot;&gt;&lt;strong&gt;一台Linux服务器的资源&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;Daba&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;0&quot; col=&quot;2&quot;&gt;&lt;p line=&quot;MYoX&quot;&gt;&lt;strong&gt;一个TCP连接占用的资源&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;2IrX&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;0&quot; col=&quot;3&quot;&gt;&lt;p line=&quot;yE7s&quot;&gt;&lt;strong&gt;占满了会发生什么&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;selected&quot; guid=&quot;F4gs&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;1&quot; col=&quot;0&quot;&gt;&lt;p line=&quot;2yEJ&quot;&gt;&lt;strong&gt;CPU&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;nCXN&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;1&quot; col=&quot;1&quot;&gt;&lt;p line=&quot;uH91&quot;&gt;看你花多少钱买的&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;QqSX&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;1&quot; col=&quot;2&quot;&gt;&lt;p line=&quot;XB7v&quot;&gt;看你用它干嘛&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;V2ip&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;1&quot; col=&quot;3&quot;&gt;&lt;p line=&quot;HdPt&quot;&gt;电脑卡死&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;selected&quot; guid=&quot;M7WX&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;2&quot; col=&quot;0&quot;&gt;&lt;p line=&quot;UxYB&quot;&gt;&lt;strong&gt;内存&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;0DCk&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;2&quot; col=&quot;1&quot;&gt;&lt;p line=&quot;e8s0&quot;&gt;看你花多少钱买的&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;5hW2&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;2&quot; col=&quot;2&quot;&gt;&lt;p line=&quot;m3C1&quot;&gt;取决于缓冲区大小&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;KYQZ&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;2&quot; col=&quot;3&quot;&gt;&lt;p line=&quot;k3Kc&quot;&gt;OOM&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;selected&quot; guid=&quot;4NUk&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;3&quot; col=&quot;0&quot;&gt;&lt;p line=&quot;qRuG&quot;&gt;&lt;strong&gt;临时端口号&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;GkOq&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;3&quot; col=&quot;1&quot;&gt;&lt;p line=&quot;t7pa&quot;&gt;ip_local_port_range&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;9Hkv&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;3&quot; col=&quot;2&quot;&gt;&lt;p line=&quot;tMeF&quot;&gt;1&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;CMgW&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;3&quot; col=&quot;3&quot;&gt;&lt;p line=&quot;3MBK&quot;&gt;cannot assign requested address&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;selected&quot; guid=&quot;tO6K&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;4&quot; col=&quot;0&quot;&gt;&lt;p&gt;&lt;strong&gt;文件描述符&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;9NMe&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;4&quot; col=&quot;1&quot;&gt;&lt;p&gt;fs.file-max&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;eQqJ&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;4&quot; col=&quot;2&quot;&gt;&lt;p&gt;1&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;cbb2&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;4&quot; col=&quot;3&quot;&gt;&lt;p&gt;too many open files&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;selected&quot; guid=&quot;JbPt&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;5&quot; col=&quot;0&quot;&gt;&lt;p line=&quot;UuxM&quot;&gt;&lt;strong&gt;进程\线程数&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;RUaa&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;5&quot; col=&quot;1&quot;&gt;&lt;p line=&quot;aLu2&quot;&gt;ulimit -n&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;Pvpi&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;5&quot; col=&quot;2&quot;&gt;&lt;p line=&quot;Nu1X&quot;&gt;看IO模型&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;selected&quot; guid=&quot;TvYS&quot; autocorrect=&quot;off&quot; autocomplete=&quot;off&quot; spellcheck=&quot;false&quot; row=&quot;5&quot; col=&quot;3&quot;&gt;&lt;p line=&quot;zO4v&quot;&gt;系统崩溃&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;后记&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/h2&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;其实这个问题，我觉得结论不重要，最重要的是思考过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而思考过程其实相当简单，就是，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;寻找限制条件而已&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，其实一开始这篇文章，我写了个故事在开头，但后来感觉放在后记更合适。故事是这样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;闪客：小宇，我问你，你一天最多能吃多少个汉堡？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小宇：额，你这问的太隐私了吧，不过看在你教我技术的份上，我就告诉你，最多能吃 4 个左右吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;闪客：咳咳真的么？好吧，那你一分钟最多能吃多少个汉堡？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小宇：快的话可能 2 个，不过正常应该最多就能吃完 1 个了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;闪客：好的，那我问你，刚刚这两个问题你为什么能不假思索地回答出来呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小宇：哈哈你这是什么话，我自己我当然了解了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;闪客：不，你仔细想想你回答这两个问题的逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小宇：哦我明白你的意思了，当你问我一天最多能吃多少个汉堡时，我考虑的是我的胃的容量最多能容下多少个汉堡。而当你问我一分钟最多能吃多少个汉堡时，我考虑的时我吃汉堡的速度，按照这个速度在一分钟内能吃多少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;闪客：没错，你总结得很好！一天最多吃多少个汉堡，此时时间非常充裕，所以主要是胃的容量限制了这个汉堡最大值，计算公式应该是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最多汉堡数 = 胃的容量 ÷ 汉堡的体积&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9506493506493506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXRym7ShrNKibX2uogdzjXe1X5aibo1kb8TtLhOwpyt3QlTKiaF0eicZiaUHc6SibEYGJebY97x1SJIHB8Yg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;385&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而一分钟最多吃多少个汉堡，此时胃的容量非常充裕，限制汉堡最大值的是时间因素，计算公式是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最多汉堡数 = 一分钟 ÷ 吃一个汉堡的耗时&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9506493506493506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXRym7ShrNKibX2uogdzjXe1X7J4IGkt2wzXY9dSLonicFkL83Ew1U6aBCK4TmuFr8I8sf0SINGC9xNg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;385&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，取决于最先触达的那个限制条件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而最大 TCP 连接数这个问题，假如面试被问到了，即使你完全不会，也应该有这样的思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而如果你有了这样的思路，你多多少少都能回答出让面试官满意的答案，因为计算机很多时候，更看重思路，而不是细枝末节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;amp;mid=2650574414&amp;amp;idx=2&amp;amp;sn=530e994ac790fda402bf28035179841a&amp;amp;chksm=f1fe38cdc689b1dbc489e355e99da61a53cf515e08f6bee48a40448cea710c1ef9206f0ec49b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;来自 Google 的 TCP BBR 拥塞控制算法深度解析&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;amp;mid=2650573296&amp;amp;idx=2&amp;amp;sn=ce5466dc62d71ecabe4eaab2eeaf2564&amp;amp;chksm=f1fe3f73c689b66500e3525e6eb88088d6d5bd41d0d733cebf6f31c2e96e75ec520441bdae33&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;淘宝二面，面试官居然把 TCP 三次握手问的这么详细&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;amp;mid=2650571227&amp;amp;idx=1&amp;amp;sn=83ae50d0754884e11802897c24943d26&amp;amp;chksm=f1fe3758c689be4ee280e9785c0fdfe8dd6b47cb1590a1f2c89459643b257fb30014b0caa448&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;漫画：一台 Linux 服务器最多能支撑多少个 TCP 连接&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;觉得本文有帮助？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐关注「算法爱好者」&lt;/span&gt;&lt;/strong&gt;，修炼编程内功&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI1MTIzMzI2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/QtPIxk7nOVeJWFaicUDrq2RhPE6p4Faq7XHibsSTRkzIvIJVBibAbHFaQupL8dAsC2qf6vVJvhX0Zyy0tCFOohf7g/0?wx_fmt=png&quot; data-nickname=&quot;算法爱好者&quot; data-alias=&quot;AlgorithmFans&quot; data-signature=&quot;算法是程序员的内功！「算法爱好者」专注分享算法相关文章、工具资源和算法题，帮程序员修炼内功。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d6d66b247b16b0941ea36723ed241ae</guid>
<title>Abp 太重了？轻量化 Abp 框架</title>
<link>https://toutiao.io/k/jwxxjl6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;本文首发于个人博客（https://blog.zhangchi.fun/）&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在进行框架的选型时，经常会听到“***框架太重了”之类的声音，比如“Abp太重了，不适合我们...”。事实上，Abp框架真的很重吗？&lt;/p&gt;&lt;p&gt;框架的“轻”和“重”，我没有在网上找到明确的定义，通过阅读一些技术博客，大致可以把框架的“轻”和“重”通过以下几个方面进行区分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;所依赖程序集的数量&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;所实现的功能的多少&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;上手难度及易用性&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;“轻量级”的框架，大概指的是一个程序集依赖少且程序集文件小、功能虽少但足够满足需求、上手容易使用简单的框架；“重量级”的框架，大概指的是一个程序集依赖多且程序集文件大、功能丰富但大多数用不到、上手困难且使用困难的框架。&lt;/p&gt;&lt;p&gt;这篇文章将从上述几个方面来探索Abp是一个“轻量级”还是“重量级”的框架。&lt;/p&gt;&lt;h2&gt;最小依赖&lt;/h2&gt;&lt;p&gt;Abp开发了一些启动模板来为我们生成项目。启动模板采用了领域驱动设计的分层方案来建立项目层级，包括了&lt;strong&gt;展示层&lt;/strong&gt;、&lt;strong&gt;应用层&lt;/strong&gt;、&lt;strong&gt;领域层&lt;/strong&gt;与&lt;strong&gt;基础设施层&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gak2lhVxV6JK0Hq5Psqon1LXadBDibBNEcREztb0AHZS5GfCWnYI6SLDEJCMRb61MUaLPKuRhe1lhq4dt7gkFEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.1979434447300772&quot; data-w=&quot;389&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们通常都会通过Abp CLI或Abp.io来创建类似上图架构的项目。Abp为我们生成的项目，减少了我们初始化项目的工作量，开箱即用，因此将我们可能会使用的Nuget包预先引入到我们的项目中，也就给我们一种依赖项太多的感觉。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gak2lhVxV6JK0Hq5Psqon1LXadBDibBNEhcSWWDYib7lVwXqr8w0wZ9mdHwNv7GibI0JuTibqib5S3yjxNz8wJ1lg4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.1533980582524272&quot; data-w=&quot;515&quot;/&gt;&lt;/p&gt;&lt;p&gt;从架构设计上来讲，&lt;strong&gt;模块化&lt;/strong&gt;是Abp的核心；而从技术角度来看，&lt;strong&gt;依赖注入&lt;/strong&gt;则是Abp实现众多功能的一个主要手段。只要了解Abp的&lt;strong&gt;模块化&lt;/strong&gt;和&lt;strong&gt;依赖注入&lt;/strong&gt;，我们就能够基于Abp框架来进行项目开发。&lt;/p&gt;&lt;p&gt;接下来将创建一个原生的&lt;code&gt;ASP.NET Core Web API&lt;/code&gt;项目，围绕&lt;strong&gt;模块化&lt;/strong&gt;和&lt;strong&gt;依赖注入&lt;/strong&gt;两个核心概念，来展示如何以最小依赖的方式使用Abp。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;通过VS或者dotNet cli新建一个原生的&lt;code&gt;ASP.NET Core Web API&lt;/code&gt;项目，命名为&lt;code&gt;LightweightAbp&lt;/code&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;安装Nuget包&lt;code&gt;Volo.Abp.Autofac&lt;/code&gt;和&lt;code&gt;Volo.Abp.AspNetCore.Mvc&lt;/code&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将项目进行&lt;strong&gt;模块化&lt;/strong&gt;：在项目根目录新建一个Abp&lt;strong&gt;模块&lt;/strong&gt;代码文件&lt;code&gt;LightweightAbpModule.cs&lt;/code&gt;，并复制以下代码：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;[DependsOn(&lt;br/&gt;    typeof(AbpAutofacModule),&lt;br/&gt;    typeof(AbpAspNetCoreMvcModule))]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;LightweightAbpModule&lt;/span&gt; : AbpModule&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ConfigureServices&lt;/span&gt;(ServiceConfigurationContext context)&lt;br/&gt;    {&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;OnApplicationInitialization&lt;/span&gt;(ApplicationInitializationContext context)&lt;br/&gt;    {&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;[DependsOn(&lt;br/&gt;    typeof(AbpAutofacModule),&lt;br/&gt;    typeof(AbpAspNetCoreMvcModule))]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;LightweightAbpModule&lt;/span&gt; : AbpModule&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ConfigureServices&lt;/span&gt;(ServiceConfigurationContext context)&lt;br/&gt;    {&lt;br/&gt;        context.Services.AddControllers();&lt;br/&gt;        context.Services.AddSwaggerGen(c =&amp;gt;&lt;br/&gt;        {&lt;br/&gt;            c.SwaggerDoc(&lt;span&gt;&quot;v1&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; OpenApiInfo { Title = &lt;span&gt;&quot;LightweightAbp&quot;&lt;/span&gt;, Version = &lt;span&gt;&quot;v1&quot;&lt;/span&gt; });&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;OnApplicationInitialization&lt;/span&gt;(ApplicationInitializationContext context)&lt;br/&gt;    {&lt;br/&gt;        var app = context.GetApplicationBuilder();&lt;br/&gt;        var env = context.GetEnvironment();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (env.IsDevelopment())&lt;br/&gt;        {&lt;br/&gt;            app.UseDeveloperExceptionPage();&lt;br/&gt;            app.UseSwagger();&lt;br/&gt;            app.UseSwaggerUI(c =&amp;gt; c.SwaggerEndpoint(&lt;span&gt;&quot;/swagger/v1/swagger.json&quot;&lt;/span&gt;, &lt;span&gt;&quot;LightweightAbp v1&quot;&lt;/span&gt;));&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        app.UseRouting();&lt;br/&gt;&lt;br/&gt;        app.UseAuthorization();&lt;br/&gt;&lt;br/&gt;        app.UseEndpoints(endpoints =&amp;gt;&lt;br/&gt;        {&lt;br/&gt;            endpoints.MapControllers();&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Startup&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ConfigureServices&lt;/span&gt;(IServiceCollection services)&lt;br/&gt;    {&lt;br/&gt;        services.AddApplication&amp;lt;LightweightAbpModule&amp;gt;();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Configure&lt;/span&gt;(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory)&lt;br/&gt;    {&lt;br/&gt;        app.InitializeApplication();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder &lt;span&gt;CreateHostBuilder&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;br/&gt;            Host.CreateDefaultBuilder(args)&lt;br/&gt;                .ConfigureWebHostDefaults(webBuilder =&amp;gt;&lt;br/&gt;                {&lt;br/&gt;                    webBuilder.UseStartup&amp;lt;Startup&amp;gt;();&lt;br/&gt;                })&lt;br/&gt;                .UseAutofac();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至此项目的创建完成了。可以看到，仅仅依赖了&lt;code&gt;Volo.Abp.Autofac&lt;/code&gt;和&lt;code&gt;Volo.Abp.AspNetCore.Mvc&lt;/code&gt;两个Nuget包，即可利用Abp进行开发。若从所依赖Nuget包数量来评估框架的“轻”和“重”，那么Abp不可谓不轻。&lt;/p&gt;&lt;h2&gt;功能按需使用&lt;/h2&gt;&lt;p&gt;得益于&lt;strong&gt;模块化&lt;/strong&gt;设计，Abp将其所能提供的功能，划分并封装到了不同的&lt;strong&gt;模块&lt;/strong&gt;中。要想使用Abp提供的某一功能，只需引入相关的Nuget包并依赖（&lt;code&gt;DependsOn&lt;/code&gt;）模块即可。&lt;/p&gt;&lt;h3&gt;数据访问&lt;/h3&gt;&lt;p&gt;要想实现数据访问功能，首先我们需要定义&lt;code&gt;Entity&lt;/code&gt;、&lt;code&gt;DbContext&lt;/code&gt;并配置数据库支持。在Abp的层次架构中，&lt;code&gt;Entity&lt;/code&gt;、&lt;code&gt;Repository&lt;/code&gt;属于领域层，&lt;code&gt;Service&lt;/code&gt;属于应用层，&lt;code&gt;DbContext&lt;/code&gt;则属于&lt;code&gt;EntityFramework Core&lt;/code&gt;模块，因此我们按需引入所需模块即可。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;安装Nuget包&lt;code&gt;Volo.Abp.Ddd.Application&lt;/code&gt;、&lt;code&gt;Volo.Abp.Ddd.Domain&lt;/code&gt;和&lt;code&gt;Volo.Abp.EntityFrameworkCore.Sqlite&lt;/code&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在&lt;code&gt;LightweightAbpModule&lt;/code&gt;类中配置&lt;code&gt;DependsOn&lt;/code&gt;特性，将&lt;code&gt;AbpDddApplicationModule&lt;/code&gt;、&lt;code&gt;AbpDddDomainModule&lt;/code&gt;和&lt;code&gt;AbpEntityFrameworkCoreSqliteModule&lt;/code&gt;模块依赖到我们的项目模块中。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;    [DependsOn(&lt;br/&gt;        typeof(AbpAutofacModule),&lt;br/&gt;        typeof(AbpAspNetCoreMvcModule),&lt;br/&gt;        typeof(AbpDddApplicationModule),&lt;br/&gt;        typeof(AbpDddDomainModule),&lt;br/&gt;        typeof(AbpEntityFrameworkCoreSqliteModule))]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;LightweightAbpModule&lt;/span&gt; : AbpModule&lt;br/&gt;    { ... }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;using&lt;/span&gt; System;&lt;br/&gt;&lt;span&gt;using&lt;/span&gt; Volo.Abp.Domain.Entities;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;namespace&lt;/span&gt; LightweightAbp&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Book&lt;/span&gt; : Entity&amp;lt;Guid&amp;gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { get; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;[ConnectionStringName(&lt;span&gt;&quot;Default&quot;&lt;/span&gt;)]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;LightweightAbpDbContext&lt;/span&gt; : AbpDbContext&amp;lt;LightweightAbpDbContext&amp;gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;LightweightAbpDbContext&lt;/span&gt;(DbContextOptions&amp;lt;LightweightAbpDbContext&amp;gt; options)&lt;br/&gt;        : &lt;span&gt;base&lt;/span&gt;(options)&lt;br/&gt;    { }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Book&amp;gt; Books { get; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;OnModelCreating&lt;/span&gt;(ModelBuilder builder)&lt;br/&gt;    {&lt;br/&gt;        base.OnModelCreating(builder);&lt;br/&gt;&lt;br/&gt;        builder.Entity&amp;lt;Book&amp;gt;(b =&amp;gt;&lt;br/&gt;        {&lt;br/&gt;            b.ToTable(nameof(Books));&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ConfigureServices&lt;/span&gt;(ServiceConfigurationContext context)&lt;br/&gt;{&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    context.Services.AddAbpDbContext&amp;lt;LightweightAbpDbContext&amp;gt;(options =&amp;gt;&lt;br/&gt;    {&lt;br/&gt;        options.AddDefaultRepositories(includeAllEntities: &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    Configure&amp;lt;AbpDbContextOptions&amp;gt;(options =&amp;gt;&lt;br/&gt;    {&lt;br/&gt;        options.UseSqlite();&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  ...&lt;br/&gt;  &lt;span&gt;&quot;ConnectionStrings&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;Default&quot;&lt;/span&gt;: &lt;span&gt;&quot;Data Source=LightweightAbp.db&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;dotnet ef migrations add InitialCreate&lt;br/&gt;dotnet ef database update&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; interface IBookAppService&lt;br/&gt;{&lt;br/&gt;    Task &lt;span&gt;CreateAsync&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; name);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BookAppService&lt;/span&gt; : ApplicationService, IBookAppService&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; IRepository&amp;lt;Book, Guid&amp;gt; Repository =&amp;gt; LazyServiceProvider.LazyGetRequiredService&amp;lt;IRepository&amp;lt;Book, Guid&amp;gt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; async Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; &lt;span&gt;CreateAsync&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; name)&lt;br/&gt;    {&lt;br/&gt;        var book = await Repository.InsertAsync(&lt;span&gt;new&lt;/span&gt; Book()&lt;br/&gt;        {&lt;br/&gt;            Name = name&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; book.Name;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;[ApiController]&lt;br/&gt;[Route(&lt;span&gt;&quot;[controller]&quot;&lt;/span&gt;)]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BookController&lt;/span&gt; : AbpController&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; readonly IBookAppService _service;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;BookController&lt;/span&gt;(IBookAppService service)&lt;br/&gt;    {&lt;br/&gt;        _service = service;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    [HttpGet]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; &lt;span&gt;CreateAsync&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; name)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; _service.CreateAsync(name);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gak2lhVxV6JK0Hq5Psqon1LXadBDibBNEBbtmfgFew2qicbX1ibDCCg532icN21ibt64HB0rx8gmBH3tXOzbBmI1lBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.0629629629629629&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里我们实现了简单的数据插入。可以看到，项目中并没有使用复杂架构和复杂的领域驱动设计，仅引用并配置Abp模块，即可使用常规的 &lt;code&gt;ASP.NET Core Web API&lt;/code&gt;方式进行开发。&lt;/p&gt;&lt;h3&gt;缓存&lt;/h3&gt;&lt;p&gt;接下来我们将继续实现缓存功能。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; interface IBookAppService&lt;br/&gt;{&lt;br/&gt;    Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; &lt;span&gt;CreateAsync&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; name);&lt;br/&gt;&lt;br/&gt;    Task&amp;lt;&lt;span&gt;string&lt;/span&gt;[]&amp;gt; &lt;span&gt;GetAllAsync&lt;/span&gt;();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BookAppService&lt;/span&gt; : ApplicationService, IBookAppService&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; readonly IRepository&amp;lt;Book, Guid&amp;gt; _repository;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; readonly IDistributedCache&amp;lt;&lt;span&gt;string&lt;/span&gt;[]&amp;gt; _cache;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;BookAppService&lt;/span&gt;(&lt;br/&gt;        IRepository&amp;lt;Book, Guid&amp;gt; repository,&lt;br/&gt;        IDistributedCache&amp;lt;&lt;span&gt;string&lt;/span&gt;[]&amp;gt; cache)&lt;br/&gt;    {&lt;br/&gt;        _repository = repository;&lt;br/&gt;        _cache = cache;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; async Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; &lt;span&gt;CreateAsync&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; name)&lt;br/&gt;    { ... }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; async Task&amp;lt;&lt;span&gt;string&lt;/span&gt;[]&amp;gt; &lt;span&gt;GetAllAsync&lt;/span&gt;()&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; await _cache.GetOrAddAsync(&lt;br/&gt;            &lt;span&gt;&quot;AllBooksName&quot;&lt;/span&gt;,&lt;br/&gt;            async () =&amp;gt; await _repository.Select(b =&amp;gt; b.Name).ToArrayAsync(),&lt;br/&gt;            () =&amp;gt; &lt;span&gt;new&lt;/span&gt; DistributedCacheEntryOptions&lt;br/&gt;            {&lt;br/&gt;                AbsoluteExpiration = DateTimeOffset.Now.AddHours(1)&lt;br/&gt;            }&lt;br/&gt;        );&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BookController&lt;/span&gt; : AbpController&lt;br/&gt;{&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    [HttpGet(&lt;span&gt;&quot;all&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;[]&amp;gt; &lt;span&gt;GetAllAsync&lt;/span&gt;()&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; _service.GetAllAsync();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我们实现了缓存功能。显而易见，按需使用缓存功能所在的Nuget包及模块即可，并没有很多繁杂的操作。&lt;/p&gt;&lt;p&gt;众所周知，Abp实现了相当多的功能，其中有些功能也许整个项目生命周期中都不会用到。得益于&lt;strong&gt;模块化&lt;/strong&gt;的方式，我们可以只依赖我所需要的Nuget包和Abp模块。如果根据功能多少来评判框架的“轻”和“重”，我们按需依赖不同模块时Abp框架不可谓不轻。由此可见，一个框架的“轻”和“重”，有时还会取决于使用方式。&lt;/p&gt;&lt;h2&gt;上手难度及易用性&lt;/h2&gt;&lt;p&gt;学习一门新技术最好的起点便是官方文档，Abp也是如此，Abp的官方文档非常详尽介绍了各个功能。Abp还为我们提供了启动模板，模板遵循了领域驱动设计的最佳实践来进行项目分层，并且为我们继承了很多项目中常用的功能模块。&lt;/p&gt;&lt;p&gt;对于初学者而言，面对一个复杂的分层架构及丰富的功能特性支持，一瞬间需要接受非常多的知识，因此会产生无从下手的感觉，进而得出一种上手难度高，框架很“重”的结论。&lt;/p&gt;&lt;p&gt;如果从另外一种角度来学习Abp的话，也许情况会有所不同。在本文之初，我便提出了Abp的核心是&lt;strong&gt;模块化&lt;/strong&gt;及&lt;strong&gt;依赖注入&lt;/strong&gt;的观点，当我们将入门的重点放在&lt;strong&gt;模块化&lt;/strong&gt;和&lt;strong&gt;依赖注入&lt;/strong&gt;上，那么会发现Abp是一个极易上手并且学习曲线很平缓的框架。正如上文我所进行的代码演示，如果感觉这个演示项目简单易学，那么就证明了我这一观点。&lt;/p&gt;&lt;p&gt;至于易用性，首先Abp实现的功能很全面，我们可以按需使用；其次，随着对Abp框架的逐步深入，会发现&lt;strong&gt;模块化&lt;/strong&gt;的设计让我们的项目集成多种功能变得简单，并且随着项目的演进，Abp的&lt;strong&gt;模块化&lt;/strong&gt;给我们提供了轻易切换到微服务方案的能力；&lt;strong&gt;依赖注入&lt;/strong&gt;系统让我们能够轻易的定制并替换Abp默认实现的功能。因此，我认为Abp是一个易于使用的框架。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;在这里我们从一个不同的角度来认识了Abp框架，显而易见，对于Abp来讲，是否太“重”，和我们对他的认知及使用方式有很大的关联。&lt;/p&gt;&lt;p&gt;项目示例代码将托管在Github中。&lt;/p&gt;&lt;h2&gt;致谢&lt;/h2&gt;&lt;p&gt;感谢Abp群（QQ群：48039003）的群友们提供的热心帮助。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>de6d3d0a32bedca1e4f85ae9e8b82c80</guid>
<title>写给小白看的 LockSupport</title>
<link>https://toutiao.io/k/81i3vn4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java并发编程系列第三篇&lt;code&gt;LockSupport&lt;/code&gt;，上一篇&lt;code&gt;Synchronized&lt;/code&gt;文章中有提过，不推荐读者们使用&lt;code&gt;Object&lt;/code&gt;的&lt;code&gt;wait、notify、notifyAll&lt;/code&gt;等函数做多线程间的通信协同，使用&lt;code&gt;LockSupport&lt;/code&gt;会是更好的选择，本篇就来谈谈&lt;code&gt;LockSupport&lt;/code&gt;，也正好为下篇的&lt;code&gt;A Q S（AbstractQueuedSynchronized）&lt;/code&gt;打基础。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;内容大纲&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6470588235294118&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxrMibJgQLnmBG0KViaVj30mwdWYkdgt2XfzPeO55AGx6zSalHOxuD4ASOvDO0A2NhzuvIvmrJKEPaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;425&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;LockSupport基本概念&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LockSupport&lt;/code&gt;是线程工具类，主要作用是阻塞和唤醒线程，底层实现依赖&lt;code&gt;Unsafe&lt;/code&gt;，同时它还是锁和其他同步类实现的基础，&lt;code&gt;LockSupport&lt;/code&gt;提供两类静态函数分别是&lt;code&gt;park&lt;/code&gt;和&lt;code&gt;unpark&lt;/code&gt;，即阻塞与唤醒线程，下面是两段代码示例&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例-1&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        Thread th = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            &lt;span&gt;//阻塞当前线程&lt;/span&gt;&lt;br/&gt;            LockSupport.park();&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;子线程执行---------&quot;&lt;/span&gt;);&lt;br/&gt;        });&lt;br/&gt;        th.start();&lt;br/&gt;        &lt;span&gt;//睡眠2秒&lt;/span&gt;&lt;br/&gt;        Thread.sleep(&lt;span&gt;2000&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;主线程执行---------&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//唤醒线程&lt;/span&gt;&lt;br/&gt;        LockSupport.unpark(th);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;输出结果：&lt;br/&gt;主线程执行---------&lt;br/&gt;子线程执行---------&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述示例中，子线程&lt;code&gt;th&lt;/code&gt;调用&lt;code&gt;LockSupport.park()&lt;/code&gt;阻塞，主线程睡眠&lt;code&gt;2&lt;/code&gt;秒后，执行&lt;code&gt;LockSupport.unpark(th)&lt;/code&gt;唤醒&lt;code&gt;th&lt;/code&gt;线程，先阻塞后唤醒非常好理解，接下来读者们再看下面的示例&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例-2&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        Thread th = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            &lt;span&gt;//唤醒当前线程&lt;/span&gt;&lt;br/&gt;            LockSupport.unpark(Thread.currentThread());&lt;br/&gt;            &lt;span&gt;//阻塞当前线程&lt;/span&gt;&lt;br/&gt;            LockSupport.park();&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;子线程执行---------&quot;&lt;/span&gt;);&lt;br/&gt;        });&lt;br/&gt;        th.start();&lt;br/&gt;        &lt;span&gt;//睡眠2秒&lt;/span&gt;&lt;br/&gt;        Thread.sleep(&lt;span&gt;2000&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;主线程执行---------&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;输出结果：&lt;br/&gt;子线程执行---------&lt;br/&gt;主线程执行---------&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嗯？先唤醒&lt;code&gt;th&lt;/code&gt;线程，再阻塞&lt;code&gt;th&lt;/code&gt;线程，最终&lt;code&gt;th&lt;/code&gt;线程没有被阻塞，这是为什么？下面&lt;code&gt;LockSupport&lt;/code&gt;的设计思路会为读者们解开疑惑，并更进一步明确是&lt;code&gt;park&lt;/code&gt;和&lt;code&gt;unpark&lt;/code&gt;的语义（&lt;strong&gt;从广义上来说&lt;code&gt;park&lt;/code&gt;和&lt;code&gt;unpark&lt;/code&gt;代表阻塞和唤醒&lt;/strong&gt;）。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;设计思路&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LockSupport&lt;/code&gt;的设计思路是通过许可证来实现的，就像汽车上高速公路，入口处要获取通行卡，出口处要交出通行卡，如果没有通行卡你就无法出站，当然你可以选择补一张通行卡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LockSupport&lt;/code&gt;会为使用它的线程关联一个许可证（&lt;code&gt;permit&lt;/code&gt;）状态，&lt;code&gt;permit&lt;/code&gt;的语义「是否拥有许可」，&lt;code&gt;0&lt;/code&gt;代表否，&lt;code&gt;1&lt;/code&gt;代表是，默认是&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;LockSupport.unpark&lt;/code&gt;：指定线程关联的&lt;code&gt;permit&lt;/code&gt;直接更新为&lt;code&gt;1&lt;/code&gt;，如果更新前的&lt;code&gt;permit&amp;lt;1&lt;/code&gt;，唤醒指定线程&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;LockSupport.park&lt;/code&gt;：当前线程关联的&lt;code&gt;permit&lt;/code&gt;如果&lt;code&gt;&amp;gt;0&lt;/code&gt;，直接把&lt;code&gt;permit&lt;/code&gt;更新为&lt;code&gt;0&lt;/code&gt;，否则阻塞当前线程&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1127895266868078&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxrMibJgQLnmBG0KViaVj30mwoQibFrKHYz7706DhjicG2AwGnArmDMt4hvWSetxZvwSsuH1nmWszKfGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;993&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;A&lt;/code&gt;执行&lt;code&gt;LockSupport.park&lt;/code&gt;，发现&lt;code&gt;permit&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;，未持有许可证，阻塞线程&lt;code&gt;A&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;B&lt;/code&gt;执行&lt;code&gt;LockSupport.unpark&lt;/code&gt;（入参线程&lt;code&gt;A&lt;/code&gt;），为&lt;code&gt;A&lt;/code&gt;线程设置许可证，&lt;code&gt;permit&lt;/code&gt;更新为&lt;code&gt;1&lt;/code&gt;，唤醒线程&lt;code&gt;A&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;B&lt;/code&gt;流程结束&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;A&lt;/code&gt;被唤醒，发现&lt;code&gt;permit&lt;/code&gt;为&lt;code&gt;1&lt;/code&gt;，消费许可证，&lt;code&gt;permit&lt;/code&gt;更新为&lt;code&gt;0&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;A&lt;/code&gt;执行临界区&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;A&lt;/code&gt;流程结束&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上面的分析得出结论&lt;code&gt;unpark&lt;/code&gt;的语义明确为「&lt;strong&gt;使线程持有许可证&lt;/strong&gt;」，&lt;code&gt;park&lt;/code&gt;的语义明确为「&lt;strong&gt;消费线程持有的许可&lt;/strong&gt;」，所以&lt;code&gt;unpark&lt;/code&gt;与&lt;code&gt;park&lt;/code&gt;的执行顺序没有强制要求，只要控制好使用的线程即可，&lt;code&gt;unpark=&amp;gt;park&lt;/code&gt;执行流程如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2027972027972027&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nxrMibJgQLnmBG0KViaVj30mwQYoMulHibEBYfibLKic1JQVqIX6jWeDFia83SJGUgtm2VJJDiahniarOiag8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;715&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;permit&lt;/code&gt;默认是&lt;code&gt;0&lt;/code&gt;，线程&lt;code&gt;A&lt;/code&gt;执行&lt;code&gt;LockSupport.unpark&lt;/code&gt;，&lt;code&gt;permit&lt;/code&gt;更新为&lt;code&gt;1&lt;/code&gt;，线程&lt;code&gt;A&lt;/code&gt;持有许可证&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;线程&lt;code&gt;A&lt;/code&gt;执行&lt;code&gt;LockSupport.park&lt;/code&gt;，此时&lt;code&gt;permit&lt;/code&gt;是&lt;code&gt;1&lt;/code&gt;，消费许可证，&lt;code&gt;permit&lt;/code&gt;更新为&lt;code&gt;0&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;执行临界区&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;流程结束&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后再补充下&lt;code&gt;park&lt;/code&gt;注意点，因&lt;code&gt;park&lt;/code&gt;阻塞的线程不仅仅会被&lt;code&gt;unpark&lt;/code&gt;唤醒，还可能会被线程中断（&lt;code&gt;Thread.interrupt&lt;/code&gt;）唤醒，而且不会抛出&lt;code&gt;InterruptedException&lt;/code&gt;异常，所以建议在&lt;code&gt;park&lt;/code&gt;后自行判断&lt;strong&gt;线程中断状态&lt;/strong&gt;，来做对应的业务处理。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;优点&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么推荐使用&lt;code&gt;LockSupport&lt;/code&gt;来做线程的阻塞与唤醒（&lt;strong&gt;线程间协同工作&lt;/strong&gt;），因为它具备如下优点&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;以线程为操作对象更符合阻塞线程的直观语义&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;操作更精准，可以准确地唤醒某一个线程（&lt;code&gt;notify&lt;/code&gt;随机唤醒一个线程，&lt;code&gt;notifyAll&lt;/code&gt;唤醒所有等待的线程）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;无需竞争锁对象（以线程作为操作对象），不会因竞争锁对象产生死锁问题&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;unpark&lt;/code&gt;与&lt;code&gt;park&lt;/code&gt;没有严格的执行顺序，不会因执行顺序引起死锁问题，比如「&lt;code&gt;Thread.suspend&lt;/code&gt;和&lt;code&gt;Thread.resume&lt;/code&gt;」没按照严格顺序执行，就会产生死锁&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外&lt;code&gt;LockSupport&lt;/code&gt;还提供了&lt;code&gt;park&lt;/code&gt;的重载函数，提升灵活性&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;void parkNanos(long nanos)&lt;/code&gt;：增加了超时机制&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;void parkUntil(long deadline)&lt;/code&gt;：加入超时机制（指定到某个时间点，&lt;code&gt;1970&lt;/code&gt;年到指定时间点的毫秒数）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;void park(Object blocker)&lt;/code&gt;：设置&lt;code&gt;blocker&lt;/code&gt;对象，当线程没有许可证被阻塞时，该对象会被记录到该线程的内部，方便后续使用诊断工具进行问题排查&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;void parkNanos(Object blocker, long nanos)&lt;/code&gt;：设置&lt;code&gt;blocker&lt;/code&gt;对象，加入超时机制&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;void parkUntil(Object blocker, long deadline)&lt;/code&gt;：设置&lt;code&gt;blocker&lt;/code&gt;对象，加入超时机制（指定到某个时间点，&lt;code&gt;1970&lt;/code&gt;年到指定时间点的毫秒数）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议使用时，传入&lt;code&gt;blocker&lt;/code&gt;对象，至于超时根据业务场景选择&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实践&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;LockSupport&lt;/code&gt;来完成一道阿里经典的多线程协同工作面试题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有&lt;code&gt;3&lt;/code&gt;个独立的线程，一个只会输出&lt;code&gt;A&lt;/code&gt;，一个只会输出&lt;code&gt;B&lt;/code&gt;，一个只会输出&lt;code&gt;C&lt;/code&gt;，在三个线程启动的情况下，请用合理的方式让他们按顺序打印&lt;code&gt;ABCABC&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思路如下&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;准备&lt;code&gt;3&lt;/code&gt;个线程，分别固定打印&lt;code&gt;A、B、C&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程输出完&lt;code&gt;A、B、C&lt;/code&gt;后需要阻塞等待唤醒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;额外准备第&lt;code&gt;4&lt;/code&gt;个线程，作为另外&lt;code&gt;3&lt;/code&gt;个线程的调度器，有序的控制&lt;code&gt;3&lt;/code&gt;个线程执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是很简单，下面通过代码来实践&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] agrs)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        LockSupportMain lockSupportMain = &lt;span&gt;new&lt;/span&gt; LockSupportMain();&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;//定义线程t1、t2、t3执行的函数方法&lt;/span&gt;&lt;br/&gt;        Consumer&amp;lt;String&amp;gt; consumer = str -&amp;gt; {&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;//线程消费许可证，并传入blocker，方便后续排查问题&lt;/span&gt;&lt;br/&gt;                LockSupport.park(lockSupportMain);&lt;br/&gt;                &lt;span&gt;//防止线程是因中断操作唤醒&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (Thread.currentThread().isInterrupted()){&lt;br/&gt;                    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;线程被中断，异常结束&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;                System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;:&quot;&lt;/span&gt; + str);&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * 定义分别输出A、B、C的线程&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            consumer.accept(&lt;span&gt;&quot;A&quot;&lt;/span&gt;);&lt;br/&gt;        },&lt;span&gt;&quot;T1&quot;&lt;/span&gt;);&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            consumer.accept(&lt;span&gt;&quot;B&quot;&lt;/span&gt;);&lt;br/&gt;        },&lt;span&gt;&quot;T2&quot;&lt;/span&gt;);&lt;br/&gt;        Thread t3 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            consumer.accept(&lt;span&gt;&quot;C&quot;&lt;/span&gt;);&lt;br/&gt;        },&lt;span&gt;&quot;T3&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * 定义调度线程&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        Thread dispatch = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt;((i%&lt;span&gt;3&lt;/span&gt;)==&lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                        &lt;span&gt;//线程t1设置许可证，并唤醒线程t1&lt;/span&gt;&lt;br/&gt;                        LockSupport.unpark(t1);&lt;br/&gt;                    }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;((i%&lt;span&gt;3&lt;/span&gt;)==&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;                        &lt;span&gt;//线程t2设置许可证，并唤醒线程t2&lt;/span&gt;&lt;br/&gt;                        LockSupport.unpark(t2);&lt;br/&gt;                    }&lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;//线程t3设置许可证，并唤醒线程t3&lt;/span&gt;&lt;br/&gt;                        LockSupport.unpark(t3);&lt;br/&gt;                    }&lt;br/&gt;                    i++;&lt;br/&gt;                    TimeUnit.MILLISECONDS.sleep(&lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//启动相关线程&lt;/span&gt;&lt;br/&gt;        t1.start();&lt;br/&gt;        t2.start();&lt;br/&gt;        t3.start();&lt;br/&gt;        dispatch.start();&lt;br/&gt;        &lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;输出内容：&lt;br/&gt;T1:A&lt;br/&gt;T2:B&lt;br/&gt;T3:C&lt;br/&gt;T1:A&lt;br/&gt;T2:B&lt;br/&gt;T3:C&lt;br/&gt;T1:A&lt;br/&gt;T2:B&lt;br/&gt;T3:C&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后再留个题目给读者们思考，使用包含但不限于&lt;code&gt;Synchronized&lt;/code&gt;、&lt;code&gt;ReentrantLock&lt;/code&gt;来完成这个功能&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;唠叨唠叨&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LockSupport&lt;/code&gt;十分简单好用，是作为并发编程的必备基础，阿星觉得是十分有必要掌握的，所以出了这篇文章，后续的计划安排&lt;code&gt;AbstractQueuedSynchronizer、ReentrantLock、ReentrantReadWriteLock&lt;/code&gt;文章，大概两周内出一篇，因为最近公司业务比较忙，所以周更有点困难，但是阿星会尽力做到周更，如果觉得阿星的文章对您有帮助，也请一键三连支持阿星（&lt;strong&gt;点赞、再看、转发&lt;/strong&gt;）&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;历史好文推荐&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关于我&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是阿星，一个热爱技术的Java程序猿，公众号  &lt;strong&gt;&lt;span&gt;「程序猿阿星」&lt;/span&gt;&lt;/strong&gt; 里将会定期分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章，2021，与您在 Be Better 的路上共同成长！。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5763888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/23OQmC1ia8nxrMibJgQLnmBG0KViaVj30mwvvhIvn9UlVC1AdEa655V9SJdD10wNdkxx1gDum94Kc014FsN5Kok2g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;288&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢各位小哥哥小姐姐们能看到这里，原创不易，文章有帮助可以关注、点个赞、分享与评论，都是支持（莫要白嫖）！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;愿你我都能奔赴在各自想去的路上，我们下篇文章见&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;个人二维码&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.2472222222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nwdondRWSMM7IJzkw0XIdsYbYVpSNtbYwaZaxRzVprVibmlEm904iaUWWUpepibTK2cft6uGzKBcX9Kg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公众号&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMDg2OTAxNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nziaXQQjkzSxQkAmbFAzI9BLo4UHedGwVNmDuNZa8BvPSOI7V8ibNdHXFt89c7xrY9YvibafERPUubtQ/0?wx_fmt=png&quot; data-nickname=&quot;程序猿阿星&quot; data-alias=&quot;cxyax1993&quot; data-signature=&quot;一起成长进阶！专注技术原理、源码，通过图解方式输出技术，这里将会分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章&quot;/&gt;&lt;/section&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>