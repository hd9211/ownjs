<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>93d8035f6cafa2da040c511b9b3055bc</guid>
<title>收钱吧多泳道环境的演进</title>
<link>https://toutiao.io/k/59oz4qo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5241545893719807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1Qj2bOmgI3Y2DxYAylSr8zHHJQUbMqPea7iaCpErbfx1h8hRFia2Zy42h21417sZIxAQfAXdHbFVbvyMtibczh3MA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，在研发过程中往往需要多套环境以满足不同的阶段的研发需求，如开发、测试、预发布环境。好的环境方案可以提高开发调试、项目测试的效率，也可以降低上线的风险，从而缩短整个需求的交付周期，提高生产效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为应对业务快速发展的需求，收钱吧在多环境的治理上经历了数个版本的迭代。本文主要介绍这几代测试环境的发展与技术实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;早期测试环境&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2018年之前，收钱吧的测试环境是两套物理隔离的环境：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;给予独立的硬件资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个服务为每个环境准备独立的配置文件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;span&gt;Jenkins&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;+&lt;span&gt;Docker&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;部署，两套环境之间互不影响。这套部署方案，技术上相对成熟，操作上简单直观，但存在以下的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;测试环境新增服务需要运维介入，创建Jenkins任务、配置Jenkins脚本、配置域名解析等，流程繁琐&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要切换服务分支时，Jenkins需要checkout源码、编译源码、构建Docker镜像、部署服务，整个流程耗时较久&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同一个服务只能有两个需求并行开发测试，无法满足快速增长的需求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个服务的配置文件是工程师手动维护，如果配置出错，有可能造成两套环境的交叉调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;很难拓展出第三、四套环境，需要大量的硬件资源以及需要为每个服务新增配置文件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.363855421686747&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3Y2DxYAylSr8zHHJQUbMqPeiaVa6fqhT3MNTwZt27KPOXLzZck6zKFtXGI4fcQZPnL4FJqHRfVJBrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上问题也对应着我们的各种诉求：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;我们想要研发同学不需要太多的运维知识就能快速部署新服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们想要服务分支的切换更加快捷容易&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们不想要跟其他人抢环境，不想测试到一半被人切了分支&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们想要减少一些重复的工作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多泳道环境 1.0&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2018年，收钱吧决定将服务迁往&lt;span&gt;Kubernetes&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;集群，原来的CI构建也从Jenkins迁移到&lt;span&gt;Gitlab CI&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;。Gitlab CI的使用，使得从checkout源码到构建Docker镜像的整个流程透明化，而依托于Kubernetes的能力，服务部署、升级等操作流程也不再繁琐，更容易与内部系统集成，实现自动化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然将服务迁移到Kubernetes集群解决了测试环境中的很多问题，但在业务需求快速迭代的场景下，测试环境最核心的诉求：&lt;strong&gt;同一个服务在环境中能够多版本共存&lt;/strong&gt;，并没有得到有效解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Kubernetes原生网络中，让请求访问同一个服务的两个不同版本，我们只有两种选择：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;多个版本的Pod配置相同label，Service中配置对应selector。这种情况下，流量在不同版本的Pod之间随机路由，显然无法在这样的场景下做测试。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不同版本配置不同的Service。这种情况相当于把服务的不同版本当成不同的服务处理。想要让下游服务访问特定版本，需要下游服务修改配置文件，这也不是可行的方案。流量的路由应该由用户决定，而不是由链路中的某个节点决定。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多泳道环境的构思&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然Kubernetes原生网络无法提供足够的支持，我们需要能够精确控制流量路由到哪个版本。在此背景下，受到&lt;span&gt;阿里特性环境&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;的启发，我们提出了多泳道环境的构想。蓝图如下，同时引入了环境泳道的概念。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4892578125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3Y2DxYAylSr8zHHJQUbMqPeZeefgExs9rWkHU1bpVMvibpI7TIiaEgmcDzSx6hC7pReH6mgkbbWQzeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;环境泳道是逻辑而非物理上的概念，同一泳道的服务之间可以直接访问，跨泳道的访问需要携带对应标识，访问的服务在泳道内不存在，请求也不携带标识，则默认路由到基础泳道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若干个环境泳道，组成了多泳道环境：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;同一服务不同版本，使用同一个域名，服务发现由底层设施负责&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环境泳道可以任意创建和释放&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;入口请求的流量需要带上特殊标识，来标识流量所属泳道&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个服务透传请求携带的标识&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的设计之下，我们认为传统的物理上的多环境将转变成逻辑上的多环境，从而可以大量节省硬件资源，处于开发、测试阶段的项目不会再因为环境数量限制而导致排队等待了，另外通过底层设施来控制路由，也不会再出现不同环境交叉使用的乱象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;依托于Istio的实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上构想，正是当时&lt;span&gt;Service Mesh&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;着力解决的问题。不管是RedHat，还是&lt;span&gt;Nginx&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;，给出的Service Mesh方案都是使用Control Plane + &lt;span&gt;Sidecar&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt; Proxy的模式。所以工程效率团队调研了当时相对成熟的解决方案&lt;span&gt;Istio&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从Istio的&lt;span&gt;Bookinfo&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;这个样例上可以了解到，Istio流量管理的核心功能是通过两份&lt;span&gt;CRD&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;--&lt;code&gt;VirtualService&lt;/code&gt;和&lt;code&gt;DestinationRule&lt;/code&gt;的配置来完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中&lt;code&gt;VirtualService&lt;/code&gt;用于配置路由规则，它可以作用于L4、L7，对于常见的HTTP流量还可以对header、uri、queryParams等进行匹配路由，如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;VirtualService&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;reviews-route&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;hosts:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;reviews.prod.svc.cluster.local&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;http:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;&quot;reviews-v2-routes&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;match:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;uri:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;prefix:&lt;/span&gt; &lt;span&gt;&quot;/wpcatalog&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;route:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;destination:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;host:&lt;/span&gt; &lt;span&gt;reviews.prod.svc.cluster.local&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;subset:&lt;/span&gt; &lt;span&gt;v2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;&quot;reviews-v1-route&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;route:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;destination:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;host:&lt;/span&gt; &lt;span&gt;reviews.prod.svc.cluster.local&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;subset:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;DestinationRule&lt;/code&gt;定义了服务的不同版本，如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;DestinationRule&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;bookinfo-ratings&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;host:&lt;/span&gt; &lt;span&gt;ratings.prod.svc.cluster.local&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;subsets:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;testversion&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;version:&lt;/span&gt; &lt;span&gt;v3&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;trafficPolicy:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;loadBalancer:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;simple:&lt;/span&gt; &lt;span&gt;ROUND_ROBIN&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样来，对于多泳道环境的构思，依托于Istio的能力，可以被简化成以下逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; headers.x-env-flag == v2:&lt;br/&gt;    route(subset_v2)&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; request.sourceLabels.version == v2:&lt;br/&gt;    request.headers.x-env-flag = v2&lt;br/&gt;    route(subset_v2)&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;    route(subset_v1)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用基础设施层进行流量的路由的实现还有个显而易见的好处：&lt;strong&gt;对当前服务的改造成本极小&lt;/strong&gt;。当时第一批接入的后端服务，只需要升级&lt;code&gt;RPC&lt;/code&gt;库的版本即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，我们也配套开发了多泳道环境管理平台——Volac。它的作用便是创建环境泳道，并根据环境泳道配置对应的VirtualService和DestinationRule。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改造后测试环境的控制逻辑如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7293447293447294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3Y2DxYAylSr8zHHJQUbMqPe8JVlzv0m2bBicAdoTiapIviapoxCsJ3GpHtPbm8F0icicQXgVIWyPfCM9Zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Volac创建&lt;code&gt;VirtualService&lt;/code&gt;和&lt;code&gt;DestinationRule&lt;/code&gt;，并部署服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Istio给服务注入&lt;code&gt;Envoy&lt;/code&gt;容器作为sidecar，同时Istio控制面监听&lt;code&gt;VirtualService&lt;/code&gt;和&lt;code&gt;DestinationRule&lt;/code&gt;的变化，动态地给&lt;code&gt;Envoy&lt;/code&gt;下发路由配置。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改造后的业务流量如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6133720930232558&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3Y2DxYAylSr8zHHJQUbMqPeaCtvkVgnyQRH3trACEdxWycibfEsPMgib9wfuib70nibiaElQ9ApJqcvGfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;688&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;带特定标识的请求，会路由到特定的环境&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环境泳道中没有对应服务，请求会路由到基础泳道&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多泳道环境 2.0&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上述改造，基本解决了早期测试环境中的问题，但是却带来了新的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公司内部服务部署系统涉及很多业务方面的需求，例如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也涉及很多技术方面的细节，如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;调用Kubernetes接口部署服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用Istio API创建资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综合以上，在多泳道环境管理平台Volac的实现过程中，还存在一些问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;业务和技术的过度耦合&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;过度依赖第三方的实现实现，即Istio，Service Mesh解决方案可能存在更好的实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务配置状态存储在数据库，无法迅速完成多集群迁移和扩展&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上原因，我们将Volac的业务逻辑与技术细节拆解：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;业务逻辑演变为Next平台：收钱吧内部集应用发布、项目管理、研发效能报表等于一体的平台&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;技术细节实现演变为&lt;span&gt;elastic-env-operator&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;更&lt;span&gt;Kubernetes的方式&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终，测试环境的控制逻辑如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6440251572327044&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3Y2DxYAylSr8zHHJQUbMqPe4ECboNxOwbFcR8NxrWkK8zibicQoicVvxibRG5uhw059mIyiaBrhyIh50VA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;795&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，依托于Kubernetes的CRD扩展和operator，测试环境实现了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不依赖于业务，可以独立存在&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更好的扩展性，如支持监控系统的VictoriaMetrics&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不与第三方实现紧耦合，可在业务无感知的情况下替换实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以迅速将环境扩展或迁移到多个集群&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多泳道环境1.0在2019年上线，最终带来了很多直接和间接收益。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接收益：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;去掉了一套固定环境，节省了将近一半云服务器资源。随着服务数量的不断增长，这项收益也在不断变大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目不再需要维护两份测试配置，节省了人力，减少了出错成本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环境按需伸缩（现在运行着近600套环境），需求交付不再需要排队等待测试环境，提高了交付效率。随着业务发展，这项收益也越发明显&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;间接收益：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;环境实现自动化，更容易与CI/CD集成，减少人工维护，节省成本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环境更易迁移与扩展，为异云部署打下基础&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于作者&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刘宁，来自技术平台部&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Jenkins: &lt;em&gt;https://www.jenkins.io/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Docker: &lt;em&gt;https://www.docker.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Kubernetes: &lt;em&gt;https://kubernetes.io/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;Gitlab CI: &lt;em&gt;https://docs.gitlab.com/ee/ci/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;在阿里，我们如何管理测试环境: &lt;em&gt;https://developer.aliyun.com/article/688852&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;What&#x27;s a service mesh?: &lt;em&gt;https://www.redhat.com/en/topics/microservices/what-is-a-service-mesh&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;What Is a Service Mesh?: &lt;em&gt;https://www.nginx.com/blog/what-is-a-service-mesh/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;Microsoft: Sidecar Pattern: &lt;em&gt;https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Istio: &lt;em&gt;https://istio.io/latest/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;Bookinfo Application: &lt;em&gt;https://istio.io/latest/docs/examples/bookinfo/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;Extend the Kubernetes API with CustomResourceDefinitions: &lt;em&gt;https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;Wosai/elastic-env-operator: &lt;em&gt;https://github.com/WoSai/elastic-env-operator&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;Extending Kubernetes: Operator Pattern: &lt;em&gt;https://kubernetes.io/docs/concepts/extend-kubernetes/operator/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>28b2fa63c0545cb6d028d523349f7c35</guid>
<title>国内再添开源图形引擎：蚂蚁 Oasis Engine 实践之路</title>
<link>https://toutiao.io/k/9h9igaa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;采访嘉宾 | 烧鹅&lt;/section&gt;&lt;section&gt;
编辑 | 闫园园&lt;/section&gt;&lt;p&gt;随着互联网技术的发展，Web 前端也出现了不同分支，除了传统网页开发以外，前端图形领域也逐渐独立为一个重要方向。虽然目前从整体上来看，前端图形领域还是比较小众的领域，但从发展势头来看，其未来发展前景还是值得关注。&lt;/p&gt;&lt;p&gt;然而，进入 3D 图形世界除了能看到炫酷的效果以外还是非常令人生畏的，如果不了解 3D 渲染的原理，反而很容易让自己陷入泥潭。那么目前国内外前端图形领域现状究竟怎样？入手前端图形领域又该有怎样的准备？带着以上疑问，InfoQ 特别采访了蚂蚁 Oasis &lt;span&gt;Engine &lt;/span&gt;团队负责人烧鹅。Oasis Engine （以下简称 &lt;span&gt;Oasis&lt;/span&gt;）是驱动支付宝五福、打年兽等互动游戏的图形引擎，由蚂蚁集团 RichLab 互动科技团队自研，刚刚度过开源一周年生日。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;图形学现状与发展前景&lt;/span&gt;
&lt;/section&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：首先请您聊聊前端与图形学的关系。&lt;/section&gt;&lt;p&gt;&lt;strong&gt;烧鹅：&lt;/strong&gt;前端与图形学的关系，我们从两方面来谈：&lt;/p&gt;&lt;p&gt;第一，标准方面。往 Web 图形技术的底层去深究，首先要追溯到国际组织 Khronos Group ，Khronos Group 专注于创立开放标准，免授权费的移动设备接口程序 API , 其制定了 OpenGL 标准，这也是行业领域中最为广泛接纳的 2D/3D 图形 API。&lt;/p&gt;&lt;p&gt;而后基于 OpenGL 在移动端的分支标准 OpenGL ES，Khronos Group 制定了 WebGL 标准，WebGL 标准提供了 3D 图形的 API，允许使用 HTML5 中的 Canvas 调用相关接口。后来 W3C 组织制定了 WebGPU 标准，与 WebGL 不同的是，WebGPU 不是 OpenGL 的包装，而是直接驱动 Vulkan、Metal 和 DirectX 12 等新生代图形接口，最新版的 Chrome 100 已经默认开启了 WebGPU 的能力。目前，WebGPU 还是一个草案阶段，WebGL 已经发展到 2.0 阶段，这两个标准也是前端实现图形应用的基础 API。&lt;/p&gt;&lt;p&gt;第二，领域方面。前端图形开发可以说是平行于传统前端开发的领域，通常情况下，普通的前端开发基于 React、Vue 等框架，而前端图形开发则依靠图形引擎与游戏开发框架去开发应用，这一点类似于游戏开发与传统软件开发的区别。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：目前国内外前端图形领域的技术发展现状是怎样的？未来前景如何？&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;目前从国内外总体发展现状来看，前端图形领域还是相对比较年轻的，毕竟从标准上来看，2011 年 3 月 WebGL 1.0 规范发布，距今也仅仅 11 年的时间。不过随着标准的逐渐成熟，前端图形引擎也像雨后春笋般涌现出来，就像游戏开发依赖于游戏引擎，前端图形开发也依赖于前端图形引擎，而一个优秀的前端图形引擎的出现势必将会带动整个生态的发展。&lt;/p&gt;&lt;p&gt;另外，目前整个前端图形领域发展滞后的原因，除了标准的滞后还有就是人才的缺失。在大多数开发者眼里，在 Web 里运行图形的性能远远不如原生图形，与其费力不讨好研究 Web 图形，不如转而研究原生图形，这种根深蒂固观念的影响也导致很多人才并没有引入到前端图形领域。&lt;/p&gt;&lt;p&gt;不过，从未来发展趋势来看，前端图形领域还是值得关注的。之前受限于各种软硬件的条件，3D 图形效果在 Web 上往往不能很好实现，而随着硬件设备和网络带宽的不断升级，情况已经大大改善。可以预见，前端在未来业务方面也会面临越来越多的 3D 图形需求。&lt;/p&gt;&lt;p&gt;其次，目前互联网公司内前端图形开发工作大多数还是由 Web 前端工程师担任，相关需求的增多必然会要求前端工程师逐步具备 3D 图形开发能力。总的来说，前端图形领域虽然可能不会有一个爆发式的增长趋势，但长期会出现相对缓慢的增长趋势。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;Oasis 的前端图形学实践&lt;/span&gt;
&lt;/section&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：Oasis 的发展历程中经历了几个重要节点？&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;Oasis 的发展历程可以分为两个重要时期：内部孵化和开源时期。2016 年底，阿里巴巴和蚂蚁的移动端业务发展迅速，在 Web 3D 引擎方面，主要依赖于 Three.js 引擎。虽然 Three.js 引擎本身已经成熟，但其毕竟不是为移动端而生，而且本身功能局限于渲染，三方生态又良莠不齐。另一方面，从技术发展战略上，公司当时已经认识到，面向移动端图形业务，自身有必要去做一个引擎。&lt;/p&gt;&lt;p&gt;在此契机下，仙剑三游戏主程景夫加入蚂蚁开始了引擎的开发，这也是 Oasis 的前身— R3 项目 ，当时，R3 服务的项目还是比较少的，不过直到现在依旧有迹可循，比如我们经常玩的蚂蚁庄园，里面“星星球”的项目就是由这个引擎驱动的，后来，项目也暂停过一个阶段，并没有太多技术上的突破。&lt;/p&gt;&lt;p&gt;直到 2018 年，RichLab 团队接手，开始确定做一个开源引擎。2020 年，拥有多年图形引擎架构和开发经验的尘沫加入团队，主导了整个引擎的重构，也是从这时候开始，团队对引擎功能、性能、易用性等方面有了更高的要求。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：聊聊 Oasis 组件化设计的初衷是什么？组件化架构的设计对于引擎开发有没有带来相关挑战，团队是怎样解决的。&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;组件化架构初衷有两方面， 首先，就图形引擎或者游戏引擎而言，其本身的功能是非常复杂的，除了需要具备三维渲染能力，还需要包含非常多细分领域的功能，比如 2D、3D、UI、音频、物理、VR/AR、逻辑编写等等。采用组件化架构，功能本身就是一个模块，以组件的形式插拔，灵活组合。这样可以更加优雅地组织场景，避免面向对象编程中继承式设计带来的嵌套以及性能损耗。&lt;/p&gt;&lt;p&gt;其次，组件化架构设计对编辑器的可视化展示也是非常友好的。在编辑器上，功能的展示也是扁平罗列出来，从视觉上就可以清楚的判断哪个功能需要，这对于使用者来说也比较简单。&lt;/p&gt;&lt;p&gt;当然组件化架构设计也并非一帆风顺，在重构过程中，团队也面临了诸多挑战。在组件化架构第一版，我们简单粗暴地去递归遍历场景中的每个节点和节点下的组件，而非用缓存组件队列，也没有设计配套的脚本组件接口，导致性能和功能都存在较大缺陷。后期通过引擎的进一步重构，组件化性能问题才得以解决。&lt;/p&gt;&lt;p&gt;另外，组件化架构和编辑器的有机融合，即组件功能在编辑器里的展示，中间也多涉及交互层的设计，目前团队也仍在持续解决中。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：Oasis 应用的是 TypeScript 语言，是如何考虑的，有怎样的意义？&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;Oasis 的开发语言采用了 TypeScript，TypeScript 是 JavaScript 的超集，相比弱类型的 JavaScript 具有非常大的优势。尤其对于大型复杂项目来说，TypeScript 带来的研发效率优势非常明显。&lt;/p&gt;&lt;p&gt;我们用 Typescript 有两方面的原因，首先对于引擎用户开发者来说，Typescript 最大的优势是有代码提示。作为一个 API 功能非常复杂的引擎来说，查 API 手册就像翻阅一本新华字典，这对于开发者来说是一种压力，这种情况下，代码提示显得尤为重要。&lt;/p&gt;&lt;p&gt;其次，对于引擎开发者来说，TypeScript 定义了弱类型语言缺失的能力，比如装饰器、枚举、类型转换等等。这些新的类型和方法，能够帮助开发者减少引擎的代码量，比如我们用了装饰器之后，代码设计非常干净，而运用了枚举，能够高效地组织代码结构、提升代码的健壮性。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：除了功能，Oasis 在提升性能方面做了哪些技术上的努力？&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;Web 图形引擎性能优化一个核心的思想就是：重 GPU 轻 CPU，在这个思想下面再去做一些针对细节的优化 。&lt;/p&gt;&lt;p&gt;虽然 GPU 在复杂计算方面能力弱一点，但是它能够同时进行更多简单的任务，而且就目前现状来看，JS 相对 C++ 等原生 CPU 语言运行效率更低，所以引擎整体性能优化即重 GPU 轻 CPU，一方面把骨骼动画、粒子动画等较大规模的原本 CPU 的计算量转嫁到 GPU 中，另一方面减少 CPU 到 GPU 的资源传输，包括传输量和传输频率，通过这种方式，提升了引擎本身性能。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;Oasis 未来发展规划&lt;/span&gt;
&lt;/section&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：能否介绍一下 Oasis 下一步技术规划是怎样的？&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;第一，我们继续深入完善引擎本身更多高级功能，包括物理系统、动画等，增加更多项目案例，进一步降低开发者的上手成本；第二，我们计划在年底开放编辑器，打造一些插件功能；第三，我们也将进一步加强开源影响力建设，不拘泥于国内，而是增加国际影响力。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：您认为 Oasis 作为一个 Web 3D 互动图形引擎开源的意义是什么？建立一个持续、健康的开源项目需要哪些准备或者要素。&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;首先，Oasis 开源的意义在于把引擎往更丰富的业务场景里面去应用，同时也能依靠社区的力量进一步扩大引擎的生态，举个例子，比如适配微信小程序，可能我们没有精力去做，但社区里的开发者会进行相应的完善；其次，开源能够让团队不再拘泥于开发思维而是扩展更多产品、业务思维，这对于自身发展成长也是大有裨益；最重要的一点，选择开源也希望引擎对整个前端图形领域有一定的贡献。很多前端工程师都表示 Oasis Engine 是接触的第一个图形引擎，容易上手，这也可以帮助更多对图形学感兴趣的前端工程师们增加对此领域的了解。&lt;/p&gt;&lt;p&gt;当然，真正的开源，是一种可持续、健康的状态。做开源的话需要做到三点：第一，不要去做所谓的代码开源，而要做到流程规划、问题管理等全部开源；第二，不要只停留在国内，而要多接触国外开发者；第三，持续地做出社区感兴趣的应用，扩大影响力。比如，Unity 每年都会做开发者大会，展示引擎的新功能以及酷炫、让人眼前一亮的效果，他们在内容制作这方面也是值得大家学习的。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：最后，您有没有想跟打算学习或者入行前端图形领域的前端工程师们分享的经验或者看法。&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;随着时代的变化，一些传统的前端工程师已经不满足于现在的界面开发，想去拓宽自己的技术栈，比如图形学方向。&lt;/p&gt;&lt;p&gt;首先，如果前端开发者不满足控制 CSS 的盒模型，而是渴望控制的屏幕上的每个像素，去绘制更有想象力的空间，我认为现在是一个转向前端图形领域不错的时机；其次，经验方面，可以先学图形学的基础课程，对图形学有高屋建瓴的认知，这是很关键的，进一步判断自己是否真正感兴趣，如果感兴趣的话可以开始上手使用一些引擎，比如 Unity 、Oasis 等，通过对引擎的使用，掌握常见的图形学里面的概念，比如灯光、材质等。&lt;/p&gt;&lt;p&gt;另一方面，如果有同学想转引擎开发工程师的话，需要更深度的学习。因为引擎里面的分支也是非常复杂的，包括像我们现在做的互动，也只是一个比较窄和小众的领域。计算机图形领域是一个非常庞大的领域，需要有很深的知识储备，掌握基础知识之后再去挑选自己感兴趣的分支领域发展，比如渲染、物理、动画等等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Oasis 官网：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://oasisengine.cn/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Github 地址：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://github.com/oasis-engine/engine&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
嘉宾介绍：&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅（徐乾伟）&lt;/span&gt;：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;蚂蚁集团 Oasis Engine 团队负责人，高级前端技术专家，主导了阿里集团和蚂蚁集团互动图形方向的技术发展，目前致力于 Oasis Engine 引擎和编辑器的产品化建设。&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a5e5dc1f0903dbbc26719bb841ca45d6</guid>
<title>Go 语言整洁架构实践</title>
<link>https://toutiao.io/k/uco7j8y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大家好，我是 frank。&lt;br/&gt;欢迎大家点击标题下方&lt;span&gt;蓝色&lt;/span&gt;文字「Golang 语言开发栈」关注公众号。&lt;br/&gt;&lt;strong&gt;设为星标&lt;/strong&gt;，第一时间接收推送文章。&lt;br/&gt;&lt;strong&gt;文末扫码&lt;/strong&gt;，加群一起学 Golang 语言。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bob 大叔在他的一篇标题为「整洁架构」的博客中提及，现在一些流行的系统架构，都采用软件分层设计，都主张以下 5 个规则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;独立于框架&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可测试的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独立于用户界面&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独立于数据库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独立于任何外部依赖&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bob 大叔的架构设计遵循依赖规则，他画了一张同心圆的图，共分为 4 层，同心圆由内向外依次为 Entities、Use Cases、Interface Adapters 和 Frameworks and Drivers，该规则规定依赖只能是由外向内，内圈不关心外圈，外圈不要影响内圈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，不要认为必须是分为这四层，这里描述的四层只是一个示例，也许你会发现你的业务不仅仅需要这四层，重点是要遵循由外向内的依赖规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们介绍整洁架构在 Go 语言中的实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整洁架构分层设计&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参照 Bob 大叔的整洁架构软件分层设计，我们将架构分层分为以下 4 层：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Models&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Repository&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Usecase&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Delivery&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，Models 与 Entities 相同，将在所有层中使用，我们可以将所有对象的结构体和方法，以及其他需要在所有层中使用的变量、常量和函数放在 Models 层。这也可以避免遇到循环导入的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Repository 层，我们可以将处理数据库的程序和调用微服务的程序放在该层，仅处理数据输入和输出，不要有其它关于业务逻辑的代码。该层依赖操作的数据库或调用的微服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Usecase 层，我们可以将业务逻辑代码放在该层，它负责接收表示层的输入数据，将数据处理之后，调用 Repository 层，将处理后的数据存储在数据库或传递给调用的微服务。反之，将数据库中的数据或调用微服务的返回数据，处理之后，返回给 &lt;span&gt;Delivery &lt;/span&gt;层。该层依赖 Repository 层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Delivery 层，负责将处理后的数据展示出来，可以采用 RESTful、HTML 或 gRPC 等各种形式。同时，它也负责接收用户输入的数据，将数据传递给 Usecase 层。该层依赖 Usecase 层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实践应用的目录：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;.&lt;br/&gt;├── app&lt;br/&gt;│   └── main.go&lt;br/&gt;├── go.mod&lt;br/&gt;├── go.sum&lt;br/&gt;└── todoList&lt;br/&gt;    ├── delivery&lt;br/&gt;    │   └── http&lt;br/&gt;    │       └── todoList.go&lt;br/&gt;    ├── models&lt;br/&gt;    │   └── todoList.go&lt;br/&gt;    ├── repository&lt;br/&gt;    │   └── mysql&lt;br/&gt;    │       └── todoList.go&lt;br/&gt;    └── usecase&lt;br/&gt;        └── todoList.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;03 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分层之间通信&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分层之间是怎么通信的，除了 Models 层之外，其它层之间通过接口通信，例如 Usecase 层与 Repository 层之间通信，Repository 层定义接口，并实现接口中的所有方法。Usecase 层通过接口与 Repository 层通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; TodoListRepository &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Create(ctx context.Context, t *Todolist) (err error)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，Delivery 层与 Usecase 层之间通信，Usecase 层定义接口，并实现接口中的所有方法。Delivery 层通过接口与 Usecase 层通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; TodoListUsecase &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Create(context.Context, *Todolist) (err error)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们介绍整洁架构的软件分层设计，并且通过一个简单的 TodoList 项目，在 Go 语言中实践「整洁架构」的架构设计。但是，在 Go 语言中实际上并没有标准的架构设计，我们可以尝试构建自己的标准。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;完整代码，请查阅 github。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485863&amp;amp;idx=1&amp;amp;sn=6e119515e734fddacc87713bb3b26ce8&amp;amp;chksm=9f81a3c9a8f62adf7d4b6e2b91538919799dd0b27ff0064780db052a1e5636f2a46a6f51a446&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言微服务的服务发现组件 Consul 的系统架构介绍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言微服务的服务发现组件 Consul 的系统架构介绍&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247486020&amp;amp;idx=1&amp;amp;sn=0782a4791d0e5262ad46ecd7d5a1c198&amp;amp;chksm=9f81a02aa8f6293c9cf5db8f8945433dde8ec3c264a94877a7af7c23a8e327a227473ea2c42d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Go 微服务工具包 Go kit 怎么集成 gRPC？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Go 微服务工具包 Go kit 怎么集成 gRPC？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485896&amp;amp;idx=1&amp;amp;sn=7f13caa0a4a0efc9aa52f91449f1eee7&amp;amp;chksm=9f81a3a6a8f62ab0e4476eab641b65fc0376f817c7393dabdefeb239fcf8fb879bec353df558&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言的多种变量声明方式和使用场景&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言的多种变量声明方式和使用场景&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485871&amp;amp;idx=1&amp;amp;sn=5e9eac1cce46b90fdab7be5ea14be9ef&amp;amp;chksm=9f81a3c1a8f62ad7f00ae7659154d87c2790097944d8606cf440aa5cd58e29c9b13cedad2099&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言 vendor 在 GOPATH 和 Modules 中的区别&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言 vendor 在 GOPATH 和 Modules 中的区别&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247483747&amp;amp;idx=1&amp;amp;sn=2cd231dba19ef72a6d507ddb3d275cfd&amp;amp;chksm=9f81ab0da8f6221b3f3c8760eb2489d8aaad017178f443fe4012b623ec727510297a8ab9b537&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Go 语言学习之运算符&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Go 语言学习之运算符&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;br/&gt;https://hackernoon.com/golang-clean-archithecture-efd6d7c43047 &lt;br/&gt;https://hackernoon.com/trying-clean-architecture-on-golang-2-44d615bf8fdf &lt;br/&gt;https://github.com/bxcodec/go-clean-arch &lt;br/&gt;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html &lt;br/&gt;https://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/ &lt;/p&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001962&quot; data-ratio=&quot;0.07625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gf7zJ2NXUibGWic6DENZvSZyv968a9qRfrBXx1yLA8pfI2WO7LLeQfpBswpBndJyBCibkLibqoBkjFfw31ticEBdAEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;扫描二维码或回复「微信群」，加入微信群&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001964&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gf7zJ2NXUibHZrWwlicibPeLk8qoykuL5yg6tiaXRStcfNOX4aSO8uH7gjibKglg1Qmfd8SAfDbn0Fnbn5aMLDXkqqg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点「赞」和「在看」是最大的支持&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages __bg_gif wxw-img&quot; data-backh=&quot;122&quot; data-backw=&quot;578&quot; data-fileid=&quot;100001963&quot; data-ratio=&quot;0.21066666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/gf7zJ2NXUibGWic6DENZvSZyv968a9qRfr90n88LFic7fPLv6sQuibcpcpCsEDguL2rIdxvkoQ96YU1XGgTfhKMNgA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;👇更多精彩内容，请点击&lt;strong&gt;「&lt;/strong&gt;&lt;span&gt;阅读原文&lt;/span&gt;」&lt;/strong&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>08205541f462154a92b25faeb17365d7</guid>
<title>FastDFS 海量小文件存储解决之道</title>
<link>https://toutiao.io/k/d85mi3w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一、FastDFS原理介绍&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;FastDFS是一个C语言实现的开源轻量级分布式文件系统 。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;支持 Linux、FreeBSD、AID 等Unix系统，解决了大容量的文件存储和高并发访问问题，文件存取实现了负载均衡，适合存储 4KB~500MB 之间的小文件，特别适合以文件为载体的在线服务，如图片、视频、文档等等。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、FastDFS 架构&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;FastDFS 由三个部分构成：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;客户端（Client）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;跟踪服务器（TrackerServer）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;存储服务器（StorageServer）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6766766766766766&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4dOWd7AD0U8Vfo8XnXGsmib5icASNXjTkOEF2HhXibT9B5QQ5RRPKiclFBzRsddicbbBGhvgyFhXO8wQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;999&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2.1 Tracker Server (跟踪服务器)&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Tracker Server (跟踪服务器) &lt;/strong&gt;主要是做调度工作，起到负载均衡的作用。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（1）【服务注册】&lt;/strong&gt;管理StorageServer存储集群，StorageServer启动时，会把自己注册到TrackerServer上，并且定期报告自身状态信息，包括磁盘剩余空间、文件同步状况、文件上传下载次数等统计信息。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（2）【服务发现】&lt;/strong&gt;Client访问StorageServer之前，必须先访问TrackerServer，动态获取到StorageServer的连接信息，最终数据是和一个可用的StorageServer进行传输。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（3）【负载均衡】&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;store group分配策略：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;0：轮询方式&lt;/p&gt;&lt;p&gt;1：指定组&lt;/p&gt;&lt;p&gt;2：平衡负载(选择最大剩余空间的组(卷)上传)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;store server分配策略：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;0：轮询方式&lt;/p&gt;&lt;p&gt;1：根据 IP 地址进行排序选择第一个服务器（ IP 地址最小者）&lt;/p&gt;&lt;p&gt;2：根据优先级进行排序（上传优先级由storage server来设置，参数名为upload_priority）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;stroe path分配 ：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;0：轮流方式，多个目录依次存放文件&lt;/p&gt;&lt;p&gt;2：选择剩余空间最大的目录存放文件（注意：剩余磁盘空间是动态的，因此存储到的目录或磁盘可能也是变化的）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 Tracker Server (跟踪服务器)&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Tracker Server (跟踪服务器) &lt;/strong&gt;主要提供容量和备份服务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;【分组管理】&lt;/strong&gt;以Group为单位，每个Group包含多台Storage Server，数据互为备份，存储容量以Group内容量最小的 storage 为准，已 Group 为单位组织存储方便应用隔离、负载均衡和副本数据定制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;Group容量受单机存储容量的限制，数据恢复只能依赖Group其他机器重新同步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;【数据同步】&lt;/strong&gt;文件同步只能在 Group 内的Storage Server之间进行，采用push方式，即源服务器同步给目标服务器。源服务器读取 binlog 文件，将文件内容解析后，按操作命令发送给目标服务器，有目标服务按命令进行操作。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、上传下载流程&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 上传流程解析&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;404&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6997578692493946&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4dOWd7AD0U8Vfo8XnXGsmibLotQ2hpib6mhCOzqTxEiaUl6HJibEWR7GdaD6oom7Twk9F0uy5DkpxfzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.1.1 选择Tracker Server&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;集群中的 tracker 之间都是对等的，客户端在上传文件时可任意选择一个 tracker 即可。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.1.2 分配Group、Stroage Server 和storage path（磁盘或者挂载点）&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;tracker 接收到上传请求时会先给该文件分配一个可以存储的 Group ，然后在Group中分配一个Storage Server给客户端，最后在接收到客户端写文件请求时，Storage Server 会分配一个数据存储目录并写入。&lt;/p&gt;&lt;p&gt;（该过程中的分配策略详见：【负载均衡】）&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.1.3 生成file_id写入并返回&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Storage 会生成一个 file_id 来作为当前文件名，file_id 采用 base64 编码，包含：&lt;span&gt;源 storage server ip&lt;/span&gt;、&lt;span&gt;文件创建时间&lt;/span&gt;、&lt;span&gt;文件大小&lt;/span&gt;、&lt;span&gt;文件CRC32校验码&lt;/span&gt; 和 &lt;span&gt;随机数&lt;/span&gt;。每个存储目录下 有两个256*256个子目录。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Storage 会根据 file_id 进行两次 hash 路由到其中一个子目录中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后以file_id为文件名存储文件到该子目录下并返回文件路径给客户端。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最终文件存储路径：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;**分组 |磁盘|子目录| 文件名 **&lt;/p&gt;&lt;p&gt;group1/M00/00/89/eQ6h3FKJf_PRl8p4AUz4wO8tqaA688.apk&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2  下载流程解析&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6233031674208145&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4dOWd7AD0U8Vfo8XnXGsmibaKu9AJsQoomwukErdshic8j380rqWgKnRFnm8OVn907icAqiaJSt0Vsww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;884&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.1 解析路径并路由&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;tracker 接收 client 发送的下载请求时，tracker 从文件名中解析出 Group、大小、创建时间等信息，然后根据Group 选择一个 storage server 返回。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.2 校验读取并返回&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;客户端和 Storage Server 建立链接，校验文件是否存在，最终返回文件数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;Group之间文件同步是异步进行的，可能上传的文件还未同步到当前访问的 Storage Server 这台机器上或者延迟原因，将导致下载文件出现404。所以引入nginx_fastdfs_module 可以很好的解决同步和延迟问题。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.3 引入fastdfs_nginx_module组件后的下载架构&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7222222222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4dOWd7AD0U8Vfo8XnXGsmibVH7OAsApfgVV3xqSHLPJFicskkkpicajDcTibgxX7eneXnnz1n059juibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;990&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;FastDFS Nginx Module功能介绍&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（1）【防盗链检查】&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;利用 FastDFS nginx 扩展功能动态生成token，设置http.conf 配置。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;【token 生成算法】：md5(fileid_without_group + privKey + ts) 同时ts没有超过 ttl 范围。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;服务器会自动根据token,st 以及设置的秘钥来验证合法性。访问链接形式如：&lt;/p&gt;&lt;p&gt;http://localhost/G1/M00/00/01/wKgBD01c15nvKU1cAABAOeCdFS466570.jpg?token=b32cd06a53dea4376e43d71cc882f9cb&amp;amp;ts=1297930137&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（2）【文件元数据解析】&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;根据 file_id 获取元数据信息, 包括：&lt;strong&gt;源&lt;/strong&gt;&lt;strong&gt;storage ip，文件路径，名称，大小&lt;/strong&gt; 等。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（3）【文件访问路由】&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因文件的file_Id 包含了上传文件时的源 Storage Server IP ，所以在获取不到本机下的文件时（未同步或者延迟情况下）FastDFS 扩展组件，会根据源服务器IP 来重定向或者代理方式获取文件。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、同步机制&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.1 同步规则&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;同步只发生在本组的 Storage Server 之间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;源头数据才需要同步，备份数据不需要再次同步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;新增 Storage Server 时，会由已有一台 Storage Server 将已有的所有数据（源头数据和备份数据）同步给新增服务器。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 Binlog 复制&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;FastDFS 文件同步采用binlog异步复制方式，Storage Server 使用binlog文件记录文件上传、删除等操作，根据Binlog进行文件同步。Binlog中只记录文件ID和操作，不记录文件内容 .binlog 格式如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;时间戳 | 操作类型 | 文件名&lt;/p&gt;&lt;p&gt;1490251373 C M02/52/CB/&lt;/p&gt;&lt;p&gt;CtAqWVjTbm2AIqTkAAACd_nIZ7M797.jpg&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;操作类型（部分）：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;C表示源创建、c表示副本创建&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A表示源追加、a表示副本追加&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;D表示源删除、d表示副本删除&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;. . . . . . .&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.3 同步流程&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5050890585241731&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4dOWd7AD0U8Vfo8XnXGsmibO7Wrm8TaTS84U08MlYbEocjb6Xic4JaZPjHEb4cRJf2iauzUic8uwaBxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;新增 Storage Server 后，组内其他 Storage Server 服务器会启动同步线程，在 tracker的协调下向新增服务器发起全量和增量同步操作。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（1）Storage C启动后向tracker 上报所属group、ip、port、版本号、存储目录数、子目录数、启动时间、老数据是否同步完成，当前状态等信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（2）tracker 收到Storage C 加入申请请求后，更新本地storage list，返回给C，并适时同步给A、B。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（3）storage C向tracker 申请同步请求，响应后变更自身状态为WAIT_SYNC。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（3）storage A 和B 在心跳周期内从同步到的新storage list 发现没有C，则启动同步线程，先向tracker发起同步申请&lt;/p&gt;&lt;p&gt;（TRACKER_PROTO_CMD_STORAGE_SYNC_SRC_REQ）,tracker会把同步源IP级同步时间戳返回给A和B,如果源IP和自己本地IP一致，则标记自己作为同步源用来做老数据同步（全量同步源），如果不一致，则标记自己作为增量同步源（只有在C节点状态为Active时才同步）。该决策是由tracker 选择产生的，不可A、B同时作为同步源，同时同步给C。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（3）同步源（假设是storage A）以 .mark为后缀的文件记录目标机器同步信息，并上报变更storage C状态为SYNCING。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（4）从/data.sync目录下读取binlog.index 中的，binlog文件Id，binlog.000读取逐行读取，进行解析.(详见上面binlog 内格式) 发送数据给storage C ，C接收并保存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（5）数据同步过程中 storage C 的状态变更过程OFFLINE-&amp;gt;ONLINE-&amp;gt;ACTIVE。ACTIVE 是最终状态，表示storage C 已对外提供服务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、文件存储&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.1 LOSF问题&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;小文件存储（LOSF）面临的问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对小文件存储问题，FastDFS 提供了文件合并解决方案。FastDFS 默认创建大文件为 64M，大文件可以存储很多小文件，容纳一个小文件的空间叫slot，solt 最小256字节，最大16M。小于256字节当256字节存储，超过16M文件单独存储。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.2 存储方式&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（1）【默认存储方式】&lt;/strong&gt;未开启合并 ，FastDFS生成的file_id 和磁盘上实际存储的文件一一对应。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2）【合并存储方式】&lt;/strong&gt;多个file_id对应文件被存储成了一个大文件 。trunk文件名格式：/fastdfs/data/00/000001 文件名从1开始递增。而生成的file_id 更长，会新增16个字节额外内容用来保存偏移量等信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;【file_size】：占用大文件的空间（注意按照最小slot-256字节进行对齐）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【mtime】：文件修改时间 &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【crc32】：文件内容的crc32码 &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【formatted_ext_name】：文件扩展名 &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【alloc_size】：文件大小与size相等 &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【id】：大文件ID如000001&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【offset】：文件内容在trunk文件中的偏移量 &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【size】：文件大小。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.4 存储空间管理&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（1）【Trunk Server】&lt;/strong&gt;由tracker leader 在一组Storage Server 选择出来的，并通知给该组内所有Storage Server，负责为该组内所有upload操作分配空间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2）【空闲平衡树】&lt;/strong&gt;trunk server 会为每个store_path构造一个空闲平衡树，相同大小的空闲块保存在链表中，每次上传请求时会到根据上传的文件大小到平衡树中查找获取大于或者接近的空闲块，然后从空闲块中分割出多余的作为新的空闲块，重新加入平衡树。如果找不到则会重建一个新的trunk文件，并加入到平衡树中。该分配过程即是一个维护空闲平衡树的过程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（3）【Trunk Binlog】&lt;/strong&gt;开启了合并存储后，Trunk Server 会多出一个TrunkBinlog同步。TrunkBinlog记录了TrunkServer 所有分配与回收的空闲块操作，并由Trunk Server同步给同组中其他storage server。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;TrunkBinlog格式如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;时间戳 | 操作类型 | store_path_index | &lt;/p&gt;&lt;p&gt;sub_path_high| sub_path_low | &lt;/p&gt;&lt;p&gt;file.id| offset | &lt;/p&gt;&lt;p&gt;size 1410750754 A 0 0 0 1 0 67108864&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;各字段含义如下： &lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;六、文件去重&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;FastDFS不具备文件去重能力，必须引入FastDHT 来配合完成。FastDHT 是一个键值对的高效分布式hash系统，底层采用Berkeley DB 来做数据库持久化，同步方式使用binlog复制方式。在FastDFS去重场景中，对文件内容做hash，然后判断文件是否一致。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在文件上传成功后，查看 Storage存储对应存储路径，会发现返回的是一个软链接，之后每次重复上传都是返回一个指向第一次上传的文件的软链接。也就保证了文件只保存了一份。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（注意：FastDFS不会返回原始文件的索引，返回的全部都是软链接，当所有的软链接都被删除的时候，原始文件也会从FastDFS中被删除）。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;七、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;FastDFS 真正意义上只是一个管理文件的系统（应用级文件系统），比如管理上传文件、图片等。并不像系统磁盘文件系统NTFS或者FAT 等这种系统级文件系统。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:1.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo互联网技术&quot; data-alias=&quot;vivoVMIC&quot; data-signature=&quot;分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>98856ba13e3cfcb386a5b84245878140</guid>
<title>为什么需要可编程代理</title>
<link>https://toutiao.io/k/paowtzr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经常会有人问 “当你们说可编程代理的时候，那么什么是可编程代理，为什么需要可编程代理”？本文从不同角度回答这个问题。首先会简单的介绍代理；然后讨论下代理在发展过程中的阶段划分；基于这些阶段的划分，讨论每一个阶段相比于上一个阶段的改进之处，以及为什么需要这些改进，同时我们讨论下 “可编程” 所包含的几个层面；最后我们总结下 “为什么需要可编程代理”。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是代理及代理的功能&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代理是代理服务器的简称，代理服务器通常部署在两个互相隔离的网络的中间处，既能访问一侧网络也能访问另一侧网络，通过把一侧的数据搬运到另一侧，实现了网络的连通。代理是一种串路网络设备，自从计算机网络诞生，代理就存在了。由于代理是串路的，因此代理在实现网络连通功能的同时也衍生出新的功能和使用场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;路由：代理在转发数据的时候，根据数据的特征，转发到不同的目的地&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;负载均衡：在转发过程中，通过把数据分发到不同的目的地，提高吞吐量、避免目的地单点故障。负载均衡逐渐成为代理细分功能的一个领域&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;故障迁移：在转发过程中，当目的地出现故障时候，代理可以把数据转发到备用的目标，对请求方提供不间断的服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;访问控制：代理可以决定某些流量可以通过，哪些流量需要被拦截。WAF 是典型的代理在细分领域的应用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;身份识别：访问控制很多时候需要基于身份信息，因此代理通常也具有身份识别的功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网络加速：代理通过缓存数据的方式加速网络访问&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指标采集：代理对经过的数据进行统计，汇总给 NPM 软件用于网络优化及网络规划&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;信息安全：除了访问控制外，代理还可以用于安全审计、TLS/SSL 卸载、数据加密等，满足安全需求&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提供桥接两个网络功能的除了代理还有路由器。路由器工作在网络的 3 层；而代理工作在 3 层以上，或者说 4 层和 7 层。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;软件代理的发展&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件代理服务器在发展过程中，大致上经历了如下几个阶段：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;配置文件时代。代理类软件（最主要是开源软件），占到了网络基础设施类软件的大多数，这些软件在细分领域提供了不同的功能，比如针对不同协议的代理、比如侧重负载均衡的代理、比如侧重缓存加速的代理。这一代类软件，都是基于配置的。用户在配置文件中设置参数、配置规则，然后启动服务进程执行这些规则&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置语言时代。配置难于表达复杂逻辑，所以很多代理软件在配置基础上引入了很薄的脚本能力，我们一般称为 “配置语言” 或者说 DSL，比如 Haprxoy 的 ACL，Varnish 的 VCL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;脚本语言时代。当逻辑进一步复杂的时候，配置语言也会难于表达；同时，当配置语言数量多到一定程度时候，配置语言本身的管理，会有很大难度。就像 shell 脚本可以写简单的逻辑，但是当 shell 代码多到一定程度的时候，通常会进一步选择 Perl 或者 Python 这些更加结构化的脚本语言。Proxy 支持脚本语言，既有脚本语言的便利性，也有编程语言结构化的优势。这类的例子如 Openresty(Nginx + Lua)、Nginx Plus(Nginx + NJS). 同时，这类例子里也包括大量应用类编程语言实现的代理服务器，比如基于 NodeJS 的 StrongLoop、Spring Gateway 等，这些应用类编程语言往往自己就有脚本支持能力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集群时代。脚本语言解决了代理中复杂逻辑的模块化、结构化实现难点。此时进一步的需求是把代理和其他的管理控制工具集成，因此需要有 REST 接口。外部的控制平面可以通过 REST 接口动态的设置脚本中的逻辑。同时，人们对代理的使用也从单实例上升到集群化，因此这一类代理通常都自身支持集群能力，比如 Enovy 和基于 Openresty 的 Kong，他们通过某种集中或者共享方式实现集群能力，同时对外提供 REST 接口。对于上边说的 #4 类型的代理，通过配置管理，一般也可以实现集群管理；并且配置管理工具也可以对外暴露 REST 接口。比如使用 Ansible + Nginx 的方案，实现了和 #5 类似的能力。相比之下，#4 的方案需要要更多的组件形成方案，而 #5 的方案更收敛&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;云时代。在 #5 的基础上，代理采用分布式的方式部署，最常见的场景是为每个应用进程部署一个代理，也就是 sidecar proxy 模式。在采用分布式以后，针对不同的上游服务，采用不同的规则和策略，也就是多租户能力。不同上游服务，不仅在逻辑上有独立的规则和策略；在物理上也进一步提供了隔离，实现进程级和接口级的细粒度管理。如果我们把服务网格的控制平面和数据平面看作一个整体，那么服务网格是这个领域的代表，典型的比如 Istio+Envoy，Linkerd+Linkerd Proxy。Pipy 就是这个阶段的产物&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在如上的各个阶段里，每一个阶段都比上一个阶段有所改进，概要的说：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;#2 比 #1 增加了基本的脚本能力。这种基本的脚本能力，在配置文件的基础上，增加了动态能力。比如在运行期获取请求的特征（如获取 HTTP Header），然后根据这些特征做动态的逻辑判断，进行特定的操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;#3 比 #2 增加完整的脚本能力，此时可以结构化和模块化的编写脚本逻辑。在 #2 的时代，当逻辑复杂的时候，脚本的量也会大幅增加，此时结构化的脚本能力成为一种必需&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;#4 比 #3 多了 REST 接口和集群能力。当需要水平扩容代理能力的时候，需要把多个代理实例组成集群；集群内的实例共享配置和脚本，并且用户可以通过 REST 接口去管理配置和脚本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;#5 比 #4 多了分布式能力，主要体现在同一个集群内不同的实例所运行的脚本和配置是不同的。在 #4 模式下，对于不同的上游服务，通常会有不同的配置和策略，比如不同的认证方式、不同的访问控制机制等；当上游服务逐渐增多的时候，这些不同上游服务的配置在逻辑上是分离的，但是在物理上都运行在同一个代理进程里。这种逻辑上分离的配置和策略运行在同一个物理进程中的情况，带来一些弊端：更多的逻辑运行在一个进程内，带来了更多的复杂性；不同上游服务的共享 CPU 和内存等资源，导致互相影响；如果某一个上游服务的脚本出现了安全漏洞，会导致其他上游服务的配置泄漏，存在安全隐患。#5 模式对于 #4 模式的改进在于每个上游服务的代理进程是独立的、彼此隔离的。他们受同一个集群管理者管理，但是在运行中的配置和脚本是独立和隔离的。这种隔离的特性，是多租户环境中的一种强需求 -- 不同的上游服务属于不同的租户，租户之间不应该互相影响，也不应该知道彼此的配置。#5 可以认为是 &quot;#4 多集群 &quot; 的极限模式 -- 最极端情况下，每一个进程都有自己的配置&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代理的需求演化&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我再从另一个视角看下代理的演化过程--需求的演化。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一代的代理主要是实现了代理功能，并且提供了基础的&lt;strong&gt;可配置&lt;/strong&gt;能力；同时，网络设备，尤其是串路网络设备的特性，要求代理是&lt;strong&gt;高可靠&lt;/strong&gt;的；网络的海量数据实时传输的特性，要求代理高吞吐、低延迟、低资源。和所有的软件一样，代理也需要支持模块化和可扩展，这个阶段的代理主要采用 C 语言开发，相应的开发扩展模块也使用 C 语言，模块在进程启动是加载。概括起来说，这个阶段的代理需求是：&lt;strong&gt;连通性&lt;/strong&gt;（网络功能）、&lt;strong&gt;易用性&lt;/strong&gt;（可以通过配置文件配置）、&lt;strong&gt;可靠性&lt;/strong&gt;（串路设备的要求）、&lt;strong&gt;高性能&lt;/strong&gt;、&lt;strong&gt;扩展性&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二代代理的改进体现在进一步提高了扩展性和灵活性，如一些动态的数据获取和配套的逻辑判断。脚本的引入，进一步增强了&lt;strong&gt;易用性&lt;/strong&gt;；对于组合逻辑和动态数据获取的支持，提供了&lt;strong&gt;灵活性&lt;/strong&gt;，同时改进了&lt;strong&gt;扩展性&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三代代理相比于第二代代理的改进主要是&lt;strong&gt;可管理性&lt;/strong&gt;、&lt;strong&gt;开发者友好&lt;/strong&gt;和&lt;strong&gt;可编程&lt;/strong&gt;。脚本大量的使用，一方面是因为使用 C 语言等做扩展开发难度大、维护难度大，一方面是脚本在现场开发的效率要优于编译型语言。开发者的开发效率和大量脚本维护带来的难度，要求这一代代理使用更为结构化的脚本语言，并且需要保持不低于上一代的性能、资源占用等核心能力。结构化和模块化的脚本语言的使用，开启了代理的&lt;strong&gt;可编程&lt;/strong&gt;时代，此时扩展代理服务器的功能就包含了两个层面和可能性，一个是使用 C 语言等开发&lt;em&gt;核心模块&lt;/em&gt;，一个是使用脚本开发&lt;em&gt;动态逻辑&lt;/em&gt;；或者说&lt;strong&gt;可编程&lt;/strong&gt;包含了&lt;em&gt;核心模块&lt;/em&gt; &lt;strong&gt;可编程&lt;/strong&gt; 和&lt;em&gt;动态逻辑&lt;/em&gt; &lt;strong&gt;可编程&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第四代代理开始了集群支持能力，属于&lt;strong&gt;可管理性&lt;/strong&gt;的改进。对 REST 接口的支持，使得代理作为网络基础设施（network infra），开始融入到了整体的管理中，是 infra as code 的一个落地点。REST 接口能力，提升了代理的&lt;strong&gt;被管理&lt;/strong&gt;能力，也是&lt;strong&gt;管理易用性&lt;/strong&gt;的一部分。&lt;em&gt;外部接口&lt;/em&gt;也是&lt;strong&gt;可编程&lt;/strong&gt;的一个重要特征，而 REST 作为最常用的接口形式也广泛的出现在代理服务器领域。此时&lt;strong&gt;可编程&lt;/strong&gt;就包含了三个层面：#3 中描述的&lt;em&gt;核心模块&lt;/em&gt;可编程，&lt;em&gt;动态逻辑&lt;/em&gt;可编程，以及提供对外接口供调用的&lt;em&gt;外部接口&lt;/em&gt; &lt;strong&gt;可编程&lt;/strong&gt;。代理服务器集群的出现，体现了&lt;strong&gt;扩展性&lt;/strong&gt;从&lt;em&gt;功能扩展&lt;/em&gt;向&lt;em&gt;资源扩展&lt;/em&gt;的变化。REST 接口的出现，为进一步的&lt;strong&gt;自服务&lt;/strong&gt;与&lt;strong&gt;托管服务&lt;/strong&gt;提供了技术基础&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第五代代理的演化是云计算普及和高速发展驱动的。云的弹性、自服务、租户、隔离、计量，要求代理服务软件具备&lt;strong&gt;云化&lt;/strong&gt;的能力。如果说第四代代理是面向&lt;em&gt;系统管理员&lt;/em&gt;的，那么第五代代理就是面向&lt;em&gt;云服务&lt;/em&gt;的。在充分保持了之前几代代理软件特征的同时，进一步实现了&lt;strong&gt;Cloud Ready&lt;/strong&gt;；而随着云计算向边缘侧拓展，第五代代理也向着硬件异构、软件异构、低能耗的方向发展，因此这一代代理开始呈现了&lt;strong&gt;云边一体&lt;/strong&gt;的能力。第五代代理在&lt;strong&gt;可编程&lt;/strong&gt;方面进一步演化，从&lt;em&gt;核心模块&lt;/em&gt;、&lt;em&gt;动态逻辑&lt;/em&gt;、&lt;em&gt;外部接口&lt;/em&gt;，增加了&lt;em&gt;云化&lt;/em&gt;的能力；包括支持分布式、多租户、可计量等。可计量是多租户的衍生需求，多租户一方面要求隔离，另一方面要求资源可以被尽可能小的粒度进行计量&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把如上的讨论汇总成一个表格，第一列标识代理所满足的某方面需求；第一行表示不同阶段的代理；在每个单元格里，我们用&lt;em&gt;来表示是否有该类能力，以及能力的程度（1-5个&lt;/em&gt;，5个&lt;em&gt;表示充分支持，1个&lt;/em&gt;表示基本支持）。同时，我们还列出了各个阶段的标志性软件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;配置文件阶段：Squid、Httpd、Nginx。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置语言阶段：Varnish、Haproxy&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;脚本语言阶段：Nginx+Lua、Nginx+JS&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集群阶段：Kong、Envoy&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;云时代：Istio+Envoy、Linkerd、Pipy&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3414161008729388&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxdxUdm2OHuR6ibSRtXHqwiaaKCkhGxHmWv0NAOMVftvUg0DtVeP2tic2yS2NC5PRQdEIWVybPiaoLGvVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2062&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上表中的 #11～#17 是代理 &lt;strong&gt;可编程&lt;/strong&gt; 的具体的多个方面，这些方面也同时构成了 &lt;strong&gt;Why Programming Proxy&lt;/strong&gt; 的答案：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;代理的内部功能需要扩展，既包括底层核心能力的扩展，也包括支持更多协议的扩展，还包括面向七层的处理能力（转发、路由、判断、访问控制等）；这些七层的处理能力，要求更为便捷的编程方式，也就是脚本化、结构化的编程能力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代理需要对外部提供接口，以集成到更大的管理体系中（如云平台），包括配置管理、资源管理等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代理需要提供面向不同角色的扩展能力，包括运维、管理员、资源提供者、租户，这些扩展能力在某种程度上都需要 &lt;strong&gt;可编程&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时，就像任何 &lt;strong&gt;可编程&lt;/strong&gt; 组件一样，&lt;strong&gt;可编程代理&lt;/strong&gt; 需要有配套的文档、开发手册、代码管理、依赖管理、构建和部署工具，并且最好有可视化的开发、调试环境。这些得到充分满足以后，用户才能够更好的管理网络流量，以及流量之上所承载的业务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>