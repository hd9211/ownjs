<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6c90b68742c6a5dd955a3886ac1853a0</guid>
<title>疫情下的失业程序员；参与开源项目很难吗？Go语言之父介绍泛型｜码农周刊VIP会员专属邮件周报 Vol.086</title>
<link>https://toutiao.io/k/07qzhk3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2fcca9fc02fa57f74259e12fc987c578</guid>
<title>系统架构的11条原则</title>
<link>https://toutiao.io/k/xbwjqgj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;基本原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则一：价值为王&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;价值为王的另一种说法叫做YAGNI。YAGNI 是 You aren’t gonna need it 的缩写。该原则的基本含义就是，不应该开发任何当前不使用的功能。因为这些占用开发成本的功能，可能根本没有人用。而且不仅仅是开发成本打了水漂，你还要不断投入维护成本，来保证这些无人使用的功能可以正常运行。&lt;/p&gt;&lt;p&gt;要了解阿姆达尔定律，它告诉我们，我们不可能无限制的提升系统某一部分的效率。要提升的总体效果有没有产生相应的价值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则二：以终为始&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484524&amp;amp;idx=1&amp;amp;sn=471a7ea978dece958c3b0285435551fe&amp;amp;chksm=fafdeec2cd8a67d43af8ef1a346b2f2b012eb738b44d0755e3b6d5a49f2ccede10fae94efe72&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;以终为始&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;以终为始&lt;/strong&gt;&lt;/a&gt;是一种思维模式，最早出自《黄帝内经》，先人是在告诫后人要在人生的春天就认真思考人生终点的意义和价值。其引申义有三：一是凡事要有目标；二是凡事要有计划；三是凡事要有原则。正所谓“凡事预则立，不预则废”。&lt;/p&gt;&lt;p&gt;白话来说，以终为始，就是在做事之前，先想想结果是什么样子的，这个结果是否能达到最初的目标。小心X-Y问题：为了解决 X问题，觉得用 Y 可以解，于是研究 Y 问题，结果搞到最后，发现原来要解决的 X 问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则三：分治原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;做架构时不要想着一次性把所有的功能都做好，要拥抱 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485060&amp;amp;idx=1&amp;amp;sn=02720887a28154ede413f85fa0af29f6&amp;amp;chksm=fafdec2acd8a653cbbbc8995eb9dd17053288aaa1509a2fc5f74d1ccc7f33d9d307ca76dbe7f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;MVP&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;MVP&lt;/strong&gt;&lt;/a&gt;（Minimal Viable Product），最小可运行版本。先让程序完成最基本功能上线，根据反馈调整和决定下一步的迭代。&lt;/p&gt;&lt;p&gt;迭代着去做事情，敏捷开发的思路。对于每个功能点，创建里程碑，然后去迭代。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则四：服务自治&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;在系统设计时，要考虑服务上线后，对于问题要自感知、自修复、自优化、自运维及自安全。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则五：拥抱变化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;h1&gt;&lt;span&gt;重视架构扩展性和可运维性。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484368&amp;amp;idx=1&amp;amp;sn=b3c8d41b98ecf2b976d0b025c0322055&amp;amp;chksm=fafde97ecd8a6068cc4d25f2766261870a67baa4cbf9dc0d4920302fcf09e74ee682025efabc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;无状态的系统&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;无状态的系统&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的是可扩展的和直接的。任何时候都要考虑这一点，不要搞个不可扩展的，有状态的东东出来。否则，一旦需要改变，成本很高。&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则六：简单即正义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解析：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485195&amp;amp;idx=1&amp;amp;sn=9aa72718cdcc24d872f0a89cf63ea34f&amp;amp;chksm=fafdeda5cd8a64b3a55f4de3fdc48d2ee396074d851f686b70a7e679dbcf26862348a79182eb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;简单即正义&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;简单即正义&lt;/strong&gt;&lt;/a&gt;的另一种说法叫做KISS。KISS(Keep it simple,sutpid)保持每件事情都尽可能的简单。用最简单的解决方案来解决问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则七：尽量自动化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;人力成本既慢又贵，还有经常不断的人工失误。如果不能降低人力成本，反而需要更多的人，那么这个架构设计一定是失败的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;稳定性原则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则八：依赖最简&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解释：&lt;/p&gt;&lt;p&gt;依赖原则是&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484076&amp;amp;idx=1&amp;amp;sn=0c2b291a31ed53e9c8af06d131aabdd4&amp;amp;chksm=fafde802cd8a6114430a5c1eb8609481059341089ba2c4113012764578152570b6149780e3d5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;去除依赖、弱化依赖、控制依赖&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;去除依赖、弱化依赖、控制依赖&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;。多一个依赖多一分风险。能不依赖则不依赖，能异步弱依赖不要同步强依赖。实在不能弱依赖的，比如必须要调用加密存储来获取数据库的密码，不然无法连接数据库，可以控制获取密码在服务启动时进行，如果获取不到则服务启动失败，因为现在都是集群部署，一台无法启动不影响整体提供服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;原则九：不作不死&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解释：&lt;/p&gt;&lt;p&gt;尽可能的做较少的功能。当有疑问的时候，就不要去做，甚至干掉。很多功能从来不会被使用。最多留个扩展点就够了。&lt;/p&gt;&lt;p&gt;等到有人提出再说（除非是影响核心流程，否则就等到需要的时候再去做）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则十：容灾容错&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485188&amp;amp;idx=1&amp;amp;sn=3618568ba3bf9c396195d8e2c4e6723d&amp;amp;chksm=fafdedaacd8a64bca74024452fb88a56ff99aa6bcd9ae841fca1b91cbff40d4dd78698b09dcc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Everything fails! &quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;Everything fails!&lt;/span&gt; &lt;/strong&gt;&lt;/a&gt;人都是要死的，机器都是要坏的。&lt;span&gt;如果一件事情有可能发生则在生产环境中一定会发生，架构中要做好容错设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则十一：用成熟的技术&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484324&amp;amp;idx=1&amp;amp;sn=78986320566babe59cc2c0da81c7f5b6&amp;amp;chksm=fafde90acd8a601ceff0bb501a0c1f6cd10b5408d3e4fed43d9e6c8605f800297abead8abdf5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;不要给别人的技术当小白鼠&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;不要给别人的技术当小白鼠&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;，不要因技术本身的问题影响系统的稳定。尽可能的使用红利大的主流技术，而不要自己发明轮子，更不要魔改。在技术选型上，千万不要被——“你看某个公司也在用这个技术”，或是一些在论坛上看到的一些程序员吐槽技术的观点（没有任何的数据，只有自己的喜好）来决定自己的技术，还是看看主流大多数公司实际在用的技术栈，会更靠谱一些。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一张图总结今天的内容：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.939443535188216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRliccwBMXSp9icdrUcDBcn7aU7asr1qCfg79N67CR0uKsu5FONagZrGE0x2WgiaMVChYcPYMvSYGqzjtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;611&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;&lt;span&gt;编程一生&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;因&lt;/span&gt;&lt;span&gt;为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下“在看”，加个“星标”，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486113&amp;amp;idx=1&amp;amp;sn=f3623b2cf257aa37ea83768fd4325762&amp;amp;chksm=fafde00fcd8a691928c66f7e484ab2b7f6fa7797dc32833a7f777bb4ebde58c010750f13c118&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;PDCA方法论&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;PDCA方法论&lt;/strong&gt;&lt;/a&gt;&lt;span&gt;，检查自己是否错过更新：&lt;/span&gt;&lt;span&gt;每周三晚上8点左右，我都会更新文章，如果你没有收到，记得点开【编程一生】公众号找一下(*^▽^*)&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>98156602effec14cab5bc7b963b6b55f</guid>
<title>谷歌工程最佳实践</title>
<link>https://toutiao.io/k/q19mmjh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近公司同事作了个Code Review的分享，于是乎我系统学习了下《谷歌工程实践》，里面主要讲的是Code Review。写下本文作为笔记。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;前言&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;术语&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;代码审查者指南&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Code Review 标准&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Code Review 要点&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查看CL的步骤&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Code Review 速度&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如何撰写 Code Review 评论&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;处理 Code Review 中的拖延&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;代码开发者指南&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;总结&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《谷歌工程实践》是 Google 团队长期以来的内部项目最佳实践。其目的是帮助开发者更好地进行代码审查工作，通过 Code Review 来提升并优化当前项目的代码质量，便于开发人员维护和维护旧项目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管你是代码开发者还是代码的审查者都值得读一读。&lt;span&gt;本文主要是基于&lt;/span&gt;&lt;span&gt;《谷歌工程实践》&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;span&gt;，摘取了关键部分，并做了笔记和扩展。&lt;/span&gt;&lt;span&gt;建议看下英文原版&lt;/span&gt;&lt;span&gt;《Google Engineering Practices Documentation
》&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;术语&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;CL（&lt;span&gt;Change List&lt;/span&gt;）&lt;/section&gt;&lt;section&gt;表示变更列表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LGTM（&lt;span&gt;Looks Good to &lt;/span&gt;&lt;span&gt;Me&lt;/span&gt;）&lt;/section&gt;&lt;section&gt;我觉得不错。表示认可这次PR，同意merge合并代码到远程仓库。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;扩展&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;MR（&lt;span&gt;Merge Request&lt;/span&gt;）&lt;/section&gt;&lt;section&gt;合并请求，GitLab中术语。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PR（Pull Request）&lt;/section&gt;&lt;section&gt;合并请求，GitHub中术语。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CR（Code Review）&lt;/section&gt;&lt;section&gt;代码审查。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ACK（Acknowledgement）&lt;/section&gt;&lt;section&gt;我确认了或者我接受了,我承认了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WIP（Work in progress）&lt;/section&gt;&lt;section&gt;do not merge yet.   开发中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ASAP（As Soon As Possible）&lt;/section&gt;&lt;section&gt;尽快。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TL;DR（Too Long; Didn’t Read）&lt;/section&gt;&lt;section&gt;「太长懒得看」README 文档常见。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PTAL（Please take a look ）&lt;/section&gt;&lt;section&gt;帮我看下，一般都是请别人 review 自己的 PR。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CC（Carbon copy ）&lt;/section&gt;&lt;section&gt;一般代表抄送别人的意思。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RFC（Request for comments）&lt;/section&gt;&lt;section&gt;我觉得这个想法很好, 我们来一起讨论下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NACK/NAK（Negative acknowledgement）&lt;/section&gt;&lt;section&gt;不同意。i.e. disagree with change and/or concept。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RFC（Request For Comments）&lt;/section&gt;&lt;section&gt;请求进行讨论 i.e. I think this is a good idea, lets discuss。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AFAIK/AFAICT（&lt;span&gt;As Far As I Know / Can Tell &lt;/span&gt;）&lt;/section&gt;&lt;section&gt;据我所知；就我所知。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TBR（&lt;span&gt;To Be Reviewed&lt;/span&gt;）&lt;/section&gt;&lt;section&gt;提示维护者进行 review。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展参考&lt;span&gt;Git 团队协作常用术语&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;、&lt;span&gt;LGTM : code review 行话&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码审查者指南&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Code Review 标准&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有 Code Review 指南中的高级原则：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一般来说，审核人员应该倾向于批准CL，只要CL确实可以提高系统的整体代码健康状态，即使CL并不完美。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Code Review 要点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;设计：主要是看CL整体设计是否合理，比如代码的分层是否合理等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;功能：主要看是否符合开发者的意图，并考虑到一些边缘情况，如并发问题等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;复杂度：阅读代码的人无法快速理解。还要注意过度工程（over-engineering）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试：确保 CL 中的测试正确，合理且有用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命名：一个好名字应该足够长，可以完全传达项目的内容或作用，但又不会太长，以至于难以阅读。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注释：是否所有注释都是必要的？通常，注释解释为什么某些代码存在时很有用，且不应该用来解释某些代码正在做什么。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;风格：参考&lt;span&gt;《Google Style Guides》&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; ，里面包含Google的多种语言的风格指南。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文档：如果 CL 变更了，请检查相关文档是否有更新。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每一行：查看分配给您审查的每行代码。如果不了解某些部分的审查，请确保 CL 上有一个合格的审查人，特别是对于安全性、并发性、可访问性、国际化等复杂问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上下文：通常，代码审查工具只会显示变更的部分的周围的几行。有时您必须查看整个文件以确保变更确实有意义。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;好的事情：&lt;/span&gt;&lt;span&gt;比起告诉他们做错了什么，有时更有价值的是告诉开发人员他们做&lt;/span&gt;&lt;span&gt;对了什么。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;查看CL的步骤&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第一步：全面了解变更。&lt;span/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第二步：检查 CL 的主要部分。&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通常，包含大量的逻辑变更的文件就是 CL 的主要部分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 CL 太大而无法确定哪些部分是主要部分，请向开发人员询问您应该首先查看的内容或者要求他们将 CL 拆分为多个 CL。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果在该部分发现存在一些主要的设计问题时，即使没有时间立即查看 CL 的其余部分，也应立即留下评论告知此问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第三步：以适当的顺序查看CL的其余部分。&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通常在查看主要文件之后，最简单的方法是按照代码审查工具向您提供的顺序浏览每个文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有时在阅读主代码之前先阅读测试也很有帮助，因为这样您就可以了解该变更应当做些什么。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Code Review 速度&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么尽快进行 Code Review？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不然就会发生：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;整个团队的速度降低了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开发者开始抗议代码审查流程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码健康状况可能会受到影响。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Code Review 应该有多快？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您没有处于重点任务的中，那么您应该在收到代码审查后尽快开始。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;速度 vs. 中断&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果您正处于重点任务中，例如编写代码，请不要打断自己进行代码审查。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在回复审查请求之前，请等待工作中断点。可能是当你的当前编码任务完成，午餐后，从会议返回等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;快速响应&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;快速的个人响应比整个过程快速发生更为重要。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;带评论的LGTM&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了加快代码审查，在某些情况下，即使他们也在 CL 上留下未解决的评论，审查者也应该给予 LGTM/Approva。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大型CL&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有人向您发送了代码审查太大，您不确定何时有时间查看，那么您应该要求开发者将 CL 拆分为几个较小的 CL 而不是一次审查的一个巨大的 CL。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码审查随时间推移而改进&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要为了提高想象中的代码审查速度，而在代码审查标准或质量方面妥协，实际上这样做对于长期来说不会有任何帮助。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;紧急情况&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CL必须非常快速地通过整个审查流程，并且质量准则将放宽。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧急 CL 是这样的小更新：允许主要发布继续而不是回滚，修复显著影响用户生产的错误，处理紧迫的法律问题，关闭主要安全漏洞等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何撰写 Code Review 评论&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;保持友善。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解释你的推理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在给出明确的指示与只指出问题并让开发人员自己决定间做好平衡。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;鼓励开发人员简化代码或添加代码注释，而不仅仅是向你解释复杂性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;礼貌&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般而言，对于那些正在被您审查代码的人，除了保持有礼貌且尊重以外，重要的是还要确保您（的评论）是非常清楚且有帮助的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;糟糕的示例&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为什么这里你使用了线程，显然并发并没有带来什么好处？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;好的示例&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这里的并发模型增加了系统的复杂性，但没有任何实际的性能优势，因为没有性能优势，最好是将这些代码作为单线程处理而不是使用多线程。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解释为什么&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于上面的“好”示例，您会注意到的一件事是，它可以帮助开发人员理解您发表评论的原因。并不总是需要您在审查评论中包含此信息，但有时候提供更多解释，对于表明您的意图，您在遵循的最佳实践，或为您建议如何提高代码健康状况是十分恰当的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;给予指导&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，修复 CL 是开发人员的责任，而不是审查者。您无需为开发人员详细设计解决方案或编写代码。但这并不意味着审查者应该没有帮助。一般来说，您应该在指出问题和提供直接指导之间取得适当的平衡。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;接受解释&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您要求开发人员解释一段您不理解的代码，那通常会导致他们更清楚地重写代码。偶尔，在代码中添加注释也是一种恰当的响应，只要它不仅仅是解释过于复杂的代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;处理 Code Review 中的拖延&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时开发人员会拖延（Pushback）代码审查。他们要么不同意您的建议，要么抱怨您太严格。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;谁是对的？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当开发人员不同意您的建议时，请先花点时间考虑一下是否正确。通常，他们比你更接近代码，所以他们可能真的对它的某些方面有更好的洞察力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时需要几轮解释一个建议才能才能让对方真正理解你的用意。只要确保始终保持礼貌，让开发人员知道你有听到他们在说什么，只是你不同意该论点而已。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;沮丧的开发者&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;审查者有时认为，如果审查者人坚持改进，开发人员会感到不安。有时候开发人员会感到很沮丧，但这样的感觉通常只会持续很短的时间，后来他们会非常感谢您在提高代码质量方面给他们的帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，如果您在评论中表现得很有礼貌，开发人员实际上根本不会感到沮丧，这些担忧都仅存在于审核者心中而已。开发者感到沮丧通常更多地与评论的写作方式有关，而不是审查者对代码质量的坚持。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;稍后清理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经验表明，在开发人员编写原始 CL 后，经过越长的时间这种清理发生的可能性就越小。实际上，通常除非开发人员在当前 CL 之后立即进行清理，否则它就永远不会发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，在代码进入代码库并“完成”之前，通常最好坚持让开发人员现在清理他们的 CL。让人们“稍后清理东西”是代码库质量退化的常见原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 CL 引入了新的复杂性，除非是紧急情况，否则必须在提交之前将其清除。如果 CL 暴露了相关的问题并且现在无法解决，那么开发人员应该将 bug 记录下来并分配给自己，避免后续被遗忘。又或者他们可以选择在程序中留下 TODO 的注释并连结到刚记录下的 bug。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关于严格性的抱怨&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您以前有相当宽松的代码审查，并转而进行严格的审查，一些开发人员会抱怨得非常大声。通常提高代码审查的速度会让这些抱怨逐渐消失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时，这些投诉可能需要数月才会消失，但最终开发人员往往会看到严格的代码审查的价值，因为他们会看到代码审查帮助生成的优秀代码。而且一旦发生某些事情时，最响亮的抗议者甚至可能会成为你最坚定的支持者，因为他们会看到审核变严格后所带来的价值。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解决冲突&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上述所有操作仍无法解决您与开发人员之间的冲突，请参阅 “Code Review 标准”以获取有助于解决冲突的指导和原则。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码开发者指南&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写好 CL 描述&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CL 描述是进行了哪些更改以及为何更改的公开记录。CL 将作为版本控制系统中的永久记录，可能会在长时期内被除审查者之外的数百人阅读。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;首行&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;正在做什么的简短摘要。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;完整的句子，使用祈使句。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后面跟一个空行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Body 是信息丰富的&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其余描述应该是提供信息的。可能包括对正在解决的问题的简要描述，以及为什么这是最好的方法。如果方法有任何缺点，应该提到它们。如果相关，请包括背景信息，例如错误编号，基准测试结果以及设计文档的链接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使是小型 CL 也需要注意细节。在 CL 描述中提供上下文以供参照。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;糟糕的 CL 描述&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“Fix bug ”是一个不充分的 CL 描述。什么 bug？你做了什么修复？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他类似的不良描述包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;“Fix build.”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“Add patch.”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“Moving code from A to B.”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“Phase 1.”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“Add convenience functions.”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“kill weird URLs.”&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中一些是真正的 CL 描述。他们的作者可能认为自己提供了有用的信息，却没有达到 CL 描述的目的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;好的 CL 描述&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是一些很好的描述示例。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;功能变化例子：&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;rpc：删除 RPC 服务器消息空闲列表的大小限制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;像 FizzBuzz 这样的服务器有非常大的消息，并且可以从重用中受益。使 freelist 更大，并添加一个 goroutine，随着时间的推移缓慢释放 freelist 条目，以便空闲服务器最终释放所有 freelist 条目。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几个词描述了 CL 的实际作用。描述的其余部分讨论了正在解决的问题，为什么这是一个好的解决方案，以及有关具体实现的更多信息。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重构例子：&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;使用 TimeKeeper 构造一个 Task 以使用其 TimeStr 和 Now 方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;给Task添加一个Now方法，这样borglet()的getter方法就可以被移除了（它只被OOMCandidate用来调用borglet的Now方法）。这替换了 Borglet 上委托给 TimeKeeper 的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;允许 Tasks 提供 Now 是消除对 Borglet 依赖的一步。最终，依赖于从 Task 获取 Now 的协作者应
该改为直接使用 TimeKeeper，但这是对小步骤重构的一种适应。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;继续重构 Borglet Hierarchy 的长期目标。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一行描述了 CL 的作用以及与过去相比的变化。描述的其余部分讨论了具体的实现、CL 的上下文、解决方案并不理想以及可能的未来方向。它还解释了为什么要进行这种更改。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;需要一些上下文的小型 CL例子：&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为 status.py 创建一个 Python3 构建规则。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这允许已经在 Python3 中使用它的消费者依赖于原始状态构建规则旁边的规则，而不是他们自己树中的某个位置。它鼓励新消费者尽可能使用 Python3，而不是 Python2，并显着简化当前正在开发的一些自动构建文件重构工具。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一句话描述了实际正在做的事情。描述的其余部分解释了为什么要进行更改，并为审阅者提供了很多背景信息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小型 CL&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么提交小型 CL?&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小且简单的 CL 是指：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;审查更快&lt;/strong&gt;。审查者更容易抽多次五分钟时间来审查小型 CL，而不是留出 30 分钟来审查一个大型 CL。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;审查得更彻底&lt;/strong&gt;。如果是大的变更，审查者和提交者往往会因为大量细节的讨论翻来覆去而感到沮丧——有时甚至到了重要点被遗漏或丢失的程度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不太可能引入错误&lt;/strong&gt;。由于您进行的变更较少，您和您的审查者可以更轻松有效地推断 CL 的影响，并查看是否已引入错误。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;如果被拒绝，减少浪费的工作&lt;/strong&gt;。如果您写了一个巨大的 CL，您的评论者说整个 CL 的方向都错误了，你就浪费了很多精力和时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;更容易合并&lt;/strong&gt;。处理大型 CL 需要很长时间，在合并时会出现很多冲突，并且必须经常合并。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;更容易设计好&lt;/strong&gt;。打磨一个小变更的设计和代码健康状况比完善一个大变更的所有细节要容易得多。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;减少对审查的阻碍&lt;/strong&gt;。发送整体变更的自包含部分可让您在等待当前 CL 审核时继续编码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;更简单的回滚&lt;/strong&gt;。大型 CL 更有可能触及在初始 CL 提交和回滚 CL 之间更新的文件，从而使回滚变得复杂（中间的 CL 也可能需要回滚）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是小型 CL？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，CL 的正确大小是自包含的变更。这意味着：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;CL 进行了一项最小的变更，只解决了一件事。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;审查者需要了解的关于 CL 的所有内容（除了未来的开发）都在 CL 的描述、现有的代码库或已经审查过的 CL 中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对其用户和开发者来说，在签入 CL 后系统能继续良好的工作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CL 不会过小以致于其含义难以理解。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于多大算“太大”没有严格的规则。对于 CL 来说，100 行通常是合理的大小，1000 行通常太大，但这取决于您的审查者的判断。变更中包含的文件数也会影响其“大小”。一个文件中的 200 行变更可能没问题，但是分布在 50 个文件中通常会太大。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么时候大 CL 是可以的？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些情况下，大变更也是可以接受的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;您通常可以将整个文件的删除视为一行变更，因为审核人员不需要很长时间审核。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有时一个大的 CL 是由您完全信任的自动重构工具生成的，而审查者的工作只是检查并确定想要这样的变更。但这些 CL 可以更大，尽管上面的一些警告（例如合并和测试）仍然适用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分离出重构&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常最好在功能变更或错误修复的单独 CL 中进行重构。例如，移动和重命名类应该与修复该类中的错误的 CL 不同。审查者更容易理解每个 CL 在单独时引入的更改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，修复本地变量名称等小清理可以包含在功能变更或错误修复 CL 中。如果重构大到包含在您当前的 CL 中，会使审查更加困难的话，需要开发者和审查者一起判断是否将其拆开。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;将相关的测试代码保存在同一个 CL 中&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免将测试代码拆分为单独的 CL。验证代码修改的测试应该进入相同的 CL，即使它增加了代码行数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，独立的测试修改可以首先进入单独的 CL，类似于重构指南。包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用新测试验证预先存在的已提交代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重构测试代码（例如引入辅助函数）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入更大的测试框架代码（例如集成测试）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不要破坏构建&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您有几个相互依赖的 CL，您需要找到一种方法来确保在每次提交 CL 后整个系统能够继续运作。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如果不能让它足够小&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时你会遇到看起来您的 CL 必须如此庞大，但这通常很少是正确的。习惯于编写小型 CL 的提交者几乎总能找到将功能分解为一系列小变更的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在编写大型 CL 之前，请考虑在重构 CL 之前是否可以为更清晰的实现铺平道路。与你的同伴聊聊，看看是否有人想过如何在小型 CL 中实现这些功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果以上的努力都失败了（这应该是非常罕见的），那么请在事先征得审查者的同意后提交大型 CL，以便他们收到有关即将发生的事情的警告。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何处理审查者的评论&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当您发送 CL 进行审查时，您的审查者可能会对您的 CL 发表一些评论。以下是处理审查者评论的一些有用信息。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不是针对您&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;审查的目标是保持代码库和产品的质量。当审查者对您的代码提出批评时，请将其视为在帮助您、代码库，而不是对您或您的能力的个人攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;永远不要愤怒地回应代码审查评论。这严重违反了专业礼仪且将永远存在于代码审查工具中。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;修复代码&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果审查者说他们不了解您的代码中的某些内容，那么您的第一反应应该是澄清代码本身。如果无法澄清代码，请添加代码注释，以解释代码存在的原因。只有在想增加的注释看起来毫无意义时，您才能在代码审查工具中进行回复与解释。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果审查者不理解您的某些代码，那么代码的未来读者可能也不会理解。在代码审查工具中回复对未来的代码读者没有帮助，但澄清代码或添加代码注释确可以实实在在得帮助他们。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自我反思&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编写 CL 可能需要做很多工作。在终于发送一个 CL 用于审查后，我们通常会感到满足的，认为它已经完成，并且非常确定不需要进一步的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这通常是令人满意的。因此，当审查者回复对可以改进的事情的评论时，很容易本能地认为评论是错误的，审查者正在不必要地阻止您，或者他们应该让您提交 CL。但是，无论您目前多么确定，请花一点时间退一步，考虑审查者是否提供有助于对代码库和公司有价值的反馈。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解决冲突&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决冲突的第一步应该是尝试与审查者达成共识。如果您无法达成共识，请参阅“代码审查标准”，该标准提供了在这种情况下遵循的原则。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码审查者视角&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;以制定审核标准为前提，尽可能快速、及时的反馈代码开发者的合并请求。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于评论要保持友善、提供引导，以最终代码质量、公司价值为导向。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;做好沟通，有疑问及时沟通、接受解释。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码开发者视角&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;写好CL的描述。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;提供小的CL、相关测试代码不分离、重构代码分离、不破坏构建。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;以代码质量、公司价值为结果导向，及时修复、做好沟通。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;《谷歌工程实践》: &lt;em&gt;https://jimmysong.io/eng-practices/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;《Google Engineering Practices Documentation
》: &lt;em&gt;https://github.com/google/eng-practices&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Git 团队协作常用术语: &lt;em&gt;https://blog.csdn.net/qq_15988951/article/details/108331701&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;LGTM : code review 行话: &lt;em&gt;&quot;https://blog.csdn.net/weixin_41287260/article/details/108676433&quot;&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;《Google Style Guides》: &lt;em&gt;https://google.github.io/styleguide/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e9e0956fd5d81283ffff14889c9651ad</guid>
<title>聊聊API网关</title>
<link>https://toutiao.io/k/3fpi68y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.558858501783591&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBiadDzUu6SLBAWxOG7gsbjFRKDzVGIibM9xCNUxhvB5sIcbagibjofjBJg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1682&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;常用API网关的对比和选型，并讲解我司自研的微服务网关，干货满满！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是苏三！微服务近几年非常火，围绕微服务的技术生态也比较多，比如微服务网关、Docker、Kubernetes等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是于2019年开始接触微服务网关，当时和公司的一位同事一起开发，由于技术能力有限，我只负责网关后台，后续微服务网关的迭代，我其实没有参与，不过后来抽空看了微服务网关前台的代码，所以对这套微服务网关的实现原理算是基本掌握。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近在写技术栈相关的文章，刚好写到微服务网关，就把之前学习的知识进行简单总结，同时也把市面上常用的微服务网关进行梳理，一方面便于后续技术选型，另一方面也算是给自己一个交代。下面是文章目录：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7199533255542591&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBytlvnBaaMt3GQALHibIdRscawJFeUvRmceHek3icklwiaib04b5icicysRfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1714&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;API网关基础&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是API网关&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API网关是一个服务器，是系统的唯一入口。&lt;/strong&gt; 从面向对象设计的角度看，它与外观模式类似。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、协议转换、限流熔断、静态响应处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务&lt;/strong&gt;，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关的主要功能&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务网关作为微服务后端服务的统一入口，它可以统筹管理后端服务，主要分为数据平面和控制平面：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;数据平面主要功能是接入用户的HTTP请求和微服务被拆分后的聚合。使用微服务网关统一对外暴露后端服务的API和契约，路由和过滤功能正是网关的核心能力模块。另外，微服务网关可以实现拦截机制和专注跨横切面的功能，包括协议转换、安全认证、熔断限流、灰度发布、日志管理、流量监控等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;控制平面主要功能是对后端服务做统一的管控和配置管理。例如，可以控制网关的弹性伸缩；可以统一下发配置；可以对网关服务添加标签；可以在微服务网关上通过配置Swagger功能统一将后端服务的API契约暴露给使用方，完成文档服务，提高工作效率和降低沟通成本。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9646697388632872&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBZVlibLMicx9QEwvmaRhCfoZmeHu0VNHI76GL8OAYnN5v7Wgh1GCjI2rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;651&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;路由功能&lt;/strong&gt;：路由是微服务网关的核心能力。通过路由功能微服务网关可以将请求转发到目标微服务。在微服务架构中，网关可以结合注册中心的动态服务发现，实现对后端服务的发现，调用方只需要知道网关对外暴露的服务API就可以透明地访问后端微服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;：API网关结合负载均衡技术，利用Eureka或者Consul等服务发现工具，通过轮询、指定权重、IP地址哈希等机制实现下游服务的负载均衡。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;统一鉴权&lt;/strong&gt;：一般而言，无论对内网还是外网的接口都需要做用户身份认证，而用户认证在一些规模较大的系统中都会采用统一的单点登录（Single Sign On）系统，如果每个微服务都要对接单点登录系统，那么显然比较浪费资源且开发效率低。API网关是统一管理安全性的绝佳场所，可以将认证的部分抽取到网关层，微服务系统无须关注认证的逻辑，只关注自身业务即可。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;协议转换&lt;/strong&gt;：API网关的一大作用在于构建异构系统，API网关作为单一入口，通过协议转换整合后台基于REST、AMQP、Dubbo等不同风格和实现技术的微服务，面向Web Mobile、开放平台等特定客户端提供统一服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;指标监控&lt;/strong&gt;：网关可以统计后端服务的请求次数，并且可以实时地更新当前的流量健康状态，可以对URL粒度的服务进行延迟统计，也可以使用Hystrix Dashboard查看后端服务的流量状态及是否有熔断发生。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;限流熔断&lt;/strong&gt;：在某些场景下需要控制客户端的访问次数和访问频率，一些高并发系统有时还会有限流的需求。在网关上可以配置一个阈值，当请求数超过阈值时就直接返回错误而不继续访问后台服务。当出现流量洪峰或者后端服务出现延迟或故障时，网关能够主动进行熔断，保护后端服务，并保持前端用户体验良好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;黑白名单&lt;/strong&gt;：微服务网关可以使用系统黑名单，过滤HTTP请求特征，拦截异常客户端的请求，例如DDoS攻击等侵蚀带宽或资源迫使服务中断等行为，可以在网关层面进行拦截过滤。比较常见的拦截策略是根据IP地址增加黑名单。在存在鉴权管理的路由服务中可以通过设置白名单跳过鉴权管理而直接访问后端服务资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;灰度发布&lt;/strong&gt;：微服务网关可以根据HTTP请求中的特殊标记和后端服务列表元数据标识进行流量控制，实现在用户无感知的情况下完成灰度发布。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;流量染色&lt;/strong&gt;：和灰度发布的原理相似，网关可以根据HTTP请求的Host、Head、Agent等标识对请求进行染色，有了网关的流量染色功能，我们可以对服务后续的调用链路进行跟踪，对服务延迟及服务运行状况进行进一步的链路分析。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;文档中心&lt;/strong&gt;：网关结合Swagger，可以将后端的微服务暴露给网关，网关作为统一的入口给接口的使用方提供查看后端服务的API规范，不需要知道每一个后端微服务的Swagger地址，这样网关起到了对后端API聚合的效果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;日志审计&lt;/strong&gt;：微服务网关可以作为统一的日志记录和收集器，对服务URL粒度的日志请求信息和响应信息进行拦截。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;API网关选型&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常用API网关&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先简单看一下市面上常用的API网关：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5245&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBian5sEsbeASkxkEichmicX08CibiamBiaZVfmb4WBG9fr1klvGkvIYDHt7Yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Nginx&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx是一个高性能的HTTP和反向代理服务器。&lt;strong&gt;Nginx一方面可以做反向代理，另外一方面可以做静态资源服务器，接口使用Lua动态语言可以完成灵活的定制功能。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx 在启动后，会有一个 Master 进程和多个 Worker 进程，Master 进程和 Worker 进程之间是通过进程间通信进行交互的，如图所示。Worker 工作进程的阻塞点是在像 select()、epoll_wait() 等这样的 I/O 多路复用函数调用处，以等待发生数据可读 / 写事件。Nginx 采用了异步非阻塞的方式来处理请求，也就是说，Nginx 是可以同时处理成千上万个请求的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Zuul&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul 是 Netflix 开源的一个API网关组件，它可以和 Eureka、Ribbon、Hystrix 等组件配合使用。社区活跃，融合于 SpringCloud 完整生态，是构建微服务体系前置网关服务的最佳选型之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul 的核心是一系列的过滤器，这些过滤器可以完成以下功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;统一鉴权 + 动态路由 + 负载均衡 + 压力测试&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;审查与监控&lt;/strong&gt;：与边缘位置追踪有意义的数据和统计结果，从而带来精确的生产视图。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;多区域弹性&lt;/strong&gt;：跨越 AWS Region 进行请求路由，旨在实现 ELB（Elastic Load Balancing，弹性负载均衡）使用的多样化，以及让系统的边缘更贴近系统的使用者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul 目前有两个大的版本：&lt;strong&gt;Zuul1 和 Zuul2&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul1 是基于 Servlet 框架构建，如图所示，采用的是阻塞和多线程方式，即一个线程处理一次连接请求，这种方式在内部延迟严重、设备故障较多情况下会引起存活的连接增多和线程增加的情况发生。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5943152454780362&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBZdzBxickmfRynE9lYs9fejz3cYHOl7MCc0yooklJicpqxOFu12KLrR1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1548&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netflix 发布的 Zuul2 有重大的更新，它运行在异步和无阻塞框架上，每个 CPU 核一个线程，处理所有的请求和响应，请求和响应的生命周期是通过事件和回调来处理的，这种方式减少了线程数量，因此开销较小。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7749077490774908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBDCQiaKu7Xu8uPV38I4YorohFoTCughI0lkLSDq97CWWrKicxSuGRrjiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1626&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Spring Cloud GeteWay&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Cloud Gateway 是Spring Cloud的一个全新的API网关项目，目的是为了替换掉Zuul1，它基于Spring5.0 + SpringBoot2.0 + WebFlux（基于⾼性能的Reactor模式响应式通信框架Netty，异步⾮阻塞模型）等技术开发，性能⾼于Zuul，官⽅测试，&lt;strong&gt;Spring Cloud GateWay是Zuul的1.6倍&lt;/strong&gt;，旨在为微服务架构提供⼀种简单有效的统⼀的API路由管理⽅式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Cloud Gateway可以与Spring Cloud Discovery Client（如Eureka）、Ribbon、Hystrix等组件配合使用，&lt;strong&gt;实现路由转发、负载均衡、熔断、鉴权、路径重写、⽇志监控等，并且Gateway还内置了限流过滤器，实现了限流的功能。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6675712347354138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBVBMzzNTMrVpMXojqqtoFGADsroLSPic5BibTgn5nWUEmMoTaTPOjcRIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1474&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kong&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong是一款基于OpenResty（Nginx + Lua模块）编写的高可用、易扩展的，由Mashape公司开源的API Gateway项目。&lt;strong&gt;Kong是基于NGINX和Apache Cassandra或PostgreSQL构建的&lt;/strong&gt;，能提供易于使用的RESTful API来操作和配置API管理系统，所以它可以水平扩展多个Kong服务器，通过前置的负载均衡配置把请求均匀地分发到各个Server，来应对大批量的网络请求。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6701986754966888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBYIld46qNHXmzg1DvMExI09l3icQuibtapAR87H1VhQCRFFPQo2waQd9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1510&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong主要有三个组件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Kong Server ：基于Nginx的服务器，用来接收API请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Apache Cassandra/PostgreSQL ：用来存储操作数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kong dashboard：官方推荐UI管理工具，也可以使用 restfull 方式管理admin api。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong采用插件机制进行功能定制，插件集（可以是0或N个）在API请求响应循环的生命周期中被执行。插件使用Lua编写，目前已有几个基础功能：&lt;strong&gt;HTTP基本认证、密钥认证、CORS（Cross-Origin Resource Sharing，跨域资源共享）、TCP、UDP、文件日志、API请求限流、请求转发以及Nginx监控。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4054441260744986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBf3I4xvqwte7ibc6yJqlQBH3dWXBzniaKtsWEIFOUrdxiaDcMZTMvRlAFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong网关具有以下的特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;可扩展性: 通过简单地添加更多的服务器，可以轻松地进行横向扩展，这意味着您的平台可以在一个较低负载的情况下处理任何请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模块化: 可以通过添加新的插件进行扩展，这些插件可以通过RESTful Admin API轻松配置；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在任何基础架构上运行: Kong网关可以在任何地方都能运行。您可以在云或内部网络环境中部署Kong，包括单个或多个数据中心设置，以及public，private 或invite-only APIs。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Traefik&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Træfɪk 是一个为了让部署微服务更加便捷而诞生的现代HTTP反向代理、负载均衡工具。它支持多种后台 (Docker, Swarm, Kubernetes, Marathon, Mesos, Consul, Etcd, Zookeeper, BoltDB, Rest API, file…) 来自动化、动态的应用它的配置文件设置。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBx2Npyq1VKYXJiclK5lknus5cdykFgyoZT8KPdPmCwLDVJvvndMvlXLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重要特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;它非常快，无需安装其他依赖，通过Go语言编写的单一可执行文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;多种后台支持：Docker, Swarm, Kubernetes, Marathon, Mesos, Consul, Etcd；&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持支持Rest API、Websocket、HTTP/2、Docker镜像；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;监听后台变化进而自动化应用新的配置文件设置；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置文件热更新，无需重启进程；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后端断路器、负载均衡、容错机制；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;清爽的前端页面，可监控服务指标。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于Traefik的更多内容，可以查看官网：https://traefik.cn/&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;API网关对比&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7698795180722892&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBPg6u5rcZm6TraAYx2jEm9Ak9QCxxGBZnmU72ccMPGl4hjTujvEmDcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1660&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7158403869407497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBUBQ4IABfcv8unwSibnIXTjCyfYia2OOlTM4fmIkCAkZMicEM1LaPHr3XA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1654&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26964933494558646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBDx2y075cDiaIhcP6BkibPicPFicNXaOP6cxzbTN08cGrBOyh8N4Y0IXfWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1654&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是网关对比截图，偷个懒，大家主要关注Kong、Traefik和Zuul即可：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;开源社区活跃度&lt;/strong&gt;来看，无疑是Kong和Traefik较好；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;成熟度&lt;/strong&gt;来看，较好的是Kong、Tyk、Traefik；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;性能&lt;/strong&gt;来看，Kong要比其他几个领先一些；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;架构优势&lt;/strong&gt;的扩展性来看，Kong、Tyk有丰富的插件，Ambassador也有插件但不多，而Zuul是完全需要自研，但Zuul由于与Spring Cloud深度集成，使用度也很高，近年来Istio服务网格的流行，Ambassador因为能够和Istio无缝集成也是相当大的优势。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是其它网友的思考结论，可供参考：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;性能&lt;/strong&gt;：Nginx+Lua形式必然是高于Java语言实现的网关的，Java技术栈里面Zuul1.0是基于Servlet实现的，剩下都是基于webflux实现，性能是高于基于Servlet实现的。&lt;strong&gt;在性能方面我觉得选择网关可能不算那么重要，多加几台机器就可以搞定。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;可维护性和扩展性&lt;/strong&gt;：Nginx+Lua这个组合掌握的人不算多，如果团队有大神，大佬们就随意了，当没看到这段话，对于一般团队来说的话，选择自己团队擅长的语言更重要。Java技术栈下的3种网关，对于Zuul和Spring Cloud Gateway需要或多或少要搞一些集成和配置页面来维护，但是对于Soul我就无脑看看文章，需要哪个搬哪个好了，尤其是可以无脑对接Dubbo美滋滋，此外Soul2.0以后版本可以摆脱ZK，在我心里再无诟病，我就喜欢无脑操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高可用&lt;/strong&gt;：对于网关高可用基本都是统一的策略都是采用多机器部署的方式，前面挂一个负载，对于而外需要用的一些组件大家注意一下。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基于Traefik自研的微服务网关&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是我司自研的微服务网关，基于Traefik进行开发，下面从技术选型、网关框架、网关后台、协议转换进行讲解，绝对干货！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;技术栈选型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Traefik&lt;/strong&gt;：一款开源的反向代理与负载均衡工具，它最大的优点是能够与常见的微服务系统直接整合，可以实现自动化动态配置。traefik较为轻量，非常易于使用和设置，性能比较好，已在全球范围内用于生产环境。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Etcd&lt;/strong&gt;：一个Go言编写的分布式、高可用的一致性键值存储系统，用于提供可靠的分布式键值存储、配置共享和服务发现等功能。（更多内容可以查看文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&amp;amp;mid=2247485759&amp;amp;idx=1&amp;amp;sn=41957e94a2c69426befafd373fbddcc5&amp;amp;chksm=cf034bddf874c2cb52a7aafea5cd194e70308c7d4ad74183db8a36d3747122be1c7a31b84ee3&amp;amp;token=179167416&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;肝了一个月的ETCD，从Raft原理到实践&lt;/a&gt; ）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Go&lt;/strong&gt;：并发能力强，性能媲美C，处理能力是PHP的4倍，效率高，语法简单，易上手，开发效率接近PHP。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43399810066476735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBibRxyvnVxEXXoibc7HRS13FiajiaibGVGlOT0ReqWUrMR8say8PibeCFqDEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2106&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关框架&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个网关框架分为3块：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;网关后台&lt;/strong&gt;（hal-fe和hal-admin）：用于应用、服务和插件的配置，然后将配置信息发布到ETCD；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Traefik&lt;/strong&gt;：读取ETCD配置，根据配置信息对请求进行路由分发，如果需要鉴权，会直接通过hal-agent模块进行统一鉴权。鉴权完毕后，如果是Http请求，直接打到下游服务，如果是Grpc和Thrift协议，会通过hal-proxy模块进行协议转换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;协议转换模块&lt;/strong&gt;：读取ETCD配置，对Traefik分发过来的请求，进行Grpc和Thrift协议转换（更多内容可以查看文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&amp;amp;mid=2247486405&amp;amp;idx=1&amp;amp;sn=e03722a78de27f7aacea2189461b1848&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;RPC框架：从原理到选型，一文带你搞懂RPC&lt;/a&gt;），并通过服务发现机制，获取服务下游机器，并通过负载均衡，将转换后的数据打到下游服务机器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5683333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBYBticvj5L2INK3jt4ibqymSmHNzBv9BR0VdfLicavrjgMxR5hsv5s3rMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关后台&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要由3大模块组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;应用&lt;/strong&gt;：主要包括应用名、域名、路径前缀、所属组、状态等，比如印度海外商城、印度社区；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;服务&lt;/strong&gt;：主要包括服务名、注册方式、协议类型、所属组、状态等，比如评论服务、地址服务、搜索服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;插件&lt;/strong&gt;：主要包括插件名称、插件类型、插件属性配置等，比如路径前缀替换插件、鉴权插件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4255&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBVIt0CPjryQ2vAQtbIgymqKExAtwicG57z8xhMd2wgNcsibZFt4Ria1Ficg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一个应用只能绑定一个服务，但是可以绑定多个插件。&lt;/strong&gt; 通过后台完成网关配置后，将这些配置信息生成Config文件，发布到ETCD中，Config文件需要遵循严格的数据格式，比如Traefix配置需要遵循官方的文件配置格式，才能被Traefik识别。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bByLQreTUBd7WOW8zW2ichnQRLrjgE3x7n4ibowYdefMzE7se5uy3LdhcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;协议转换模块&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hal-proxy模块是整个微服务网关最复杂，也是技术含量最高的模块，所以给大家详细讲解一下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题引入&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在讲这个模块前，我们先看下面几个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当请求从上游的trafik过来时，需要知道访问下游的机器IP和端口，才能将请求发送给下游，这些机器如何获取呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有了机器后，我们需要和下游机器建立连接，如果连接用一次就直接释放，肯定对服务会造成很大的压力，这就需要引入Client缓存池，那这个Client缓存池我们又该如何实现呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后就是需要对协议进行转换，因为不同的下游服务，支持的协议类型是不一样的，这个网关又是如何动态支持的呢？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6163175303197354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBtjZLKhJdgInAgDOicm3WEic5CagBQL0ZPoaqicvLic2SueWicutFJjP1UeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1814&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现原理&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5095&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bB0CQAStBiapHJOGKsCbIVCEnTkLPDwusicrqk4TJ5mnM4aak39IYicGu1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是先看一下hal-proxy内部有哪些模块，首先是Resolver模块，这个模块的是什么作用呢？这里我简单介绍一下，目前公司内部通过服务获取到机器列表的方式有多种，比如MIS平台、服务树等，也就是有的是通过平台配置的，有的是直接挂在服务树下，无论哪种方式，我们都通过服务名，通过一定的方式，找到该服务下面所有的主机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以Resolver模块的作用，其实就是通过服务名，找到该服务下的所有机器的IP和服务端口，然后持久化到内存中，并定时更新。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协议模块就是支持不同的协议转换，每个协议类型的转换，都需要单独实现，&lt;strong&gt;这些协议转换，无非就是先通过机器IP和端口初始化Client，然后再将数据进行转换后，直接发送到下游的机器。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后就是连接池，之前我们其实也用到go自带的pool来做，但是当对pool数据进行更新时，需要加锁，所以性能一直起不来，后来&lt;strong&gt;改成了环形队列，然后对数据的操作全部通过原子操作方式，就实现了无锁操作，大大提高的并发性能。&lt;/strong&gt; 环形队列的代码，也给你安排上，可以直接看这篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&amp;amp;mid=2247484024&amp;amp;idx=1&amp;amp;sn=8345b28106df822b7299dc1efaf49f30&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Go语言核心手册-10.原子操作&lt;/a&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现逻辑&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是hal-proxy的逻辑实现图，画了2天，包含所有核心对象的交互方式，这里就不去细讲，能掌握多少，靠大家自己领悟，如果有任何疑问(或者看不清图片)，可以关注我公众号，加我微信沟通。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6637788778877888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBTW2LnXaNDLWwaWdNF1nich33BBmkAxvcsNn7A5homx0f4K3ZkziadfuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2424&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;尽信书则不如无书，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>78d9e03f834958f43decd9f963f884ad</guid>
<title>kratos分布式事务最佳实践</title>
<link>https://toutiao.io/k/8z1w9b2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;随着业务的快速发展、业务复杂度越来越高，微服务作为最佳解决方案之一，它解耦服务，降低复杂度，增加可维护性的同时，也带来一部分新问题。&lt;/p&gt;&lt;p&gt;当我们需要跨服务保证数据一致性时，原先的数据库事务力不从心，无法将跨库、跨服务的多个操作放在一个事务中。这样的应用场景非常多，我们可以列举出很多：&lt;/p&gt;&lt;p&gt;面对这些本地事务无法解决的场景，我们需要分布式事务的解决方案，保证跨服务、跨数据库更新数据的一致性。&lt;/p&gt;&lt;p&gt;dtm作为一款非常流行的分布式事务框架，已经支持接入多种微服务框架，下面我们就来着重介绍一下 https://github.com/go-kratos/kratos 如何接入dtm，解决分布式事务的问题&lt;/p&gt;&lt;h2&gt;运行一个例子&lt;/h2&gt;&lt;p&gt;我们来看一个可运行的例子，然后再看如何自己开发完成一个完整的分布式事务&lt;/p&gt;&lt;p&gt;下面以etcd作为注册服务中心，可以按照如下步骤运行一个kratos的示例：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;配置dtm&lt;/p&gt;&lt;pre&gt;MicroService:&lt;br/&gt; Driver: &lt;span&gt;&#x27;dtm-driver-kratos&#x27;&lt;/span&gt; # name of the driver to handle register/discover&lt;br/&gt; Target: &lt;span&gt;&#x27;discovery://127.0.0.1:2379/dtmservice&#x27;&lt;/span&gt; # register dtm server to this url&lt;br/&gt; EndPoint: &lt;span&gt;&#x27;grpc://localhost:36790&#x27;&lt;/span&gt;&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;启动etcd&lt;/p&gt;&lt;pre&gt;&lt;span&gt;# 前提：已安装etcd&lt;/span&gt;&lt;br/&gt;etcd&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;启动dtm&lt;/p&gt;&lt;pre&gt;&lt;span&gt;# 请先配置好dtm的数据库&lt;/span&gt;&lt;br/&gt;go &lt;span&gt;run&lt;/span&gt;&lt;span&gt; app/main.go -c conf.yml &lt;span&gt;# conf.yml 为你对应的 dtm 配置文件&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;运行一个kratos的服务&lt;/p&gt;&lt;pre&gt;git &lt;span&gt;clone&lt;/span&gt; https://github.com/dtm-labs/dtmdriver-clients &amp;amp;&amp;amp; &lt;span&gt;cd&lt;/span&gt; dtmdriver-clients&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; kratos/trans&lt;br/&gt;make build &amp;amp;&amp;amp; ./bin/trans -conf configs/config.yaml&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;发起一个 kratos 使用 dtm 的事务&lt;/p&gt;&lt;pre&gt;&lt;span&gt;# 在 dtmdriver-clients 的目录下&lt;/span&gt;&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; kratos/app &amp;amp;&amp;amp; go run main.go&lt;/pre&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当您在trans的日志中看到&lt;/p&gt;&lt;pre&gt;&lt;span&gt;INFO&lt;/span&gt; &lt;span&gt;msg&lt;/span&gt;=config loaded: config.yaml format: yaml&lt;br/&gt;&lt;span&gt;INFO&lt;/span&gt; msg=[gRPC]&lt;span&gt; server &lt;/span&gt;listening on: [::]:9000&lt;br/&gt;2022/03/30 09:35:36 transfer out 30 cents &lt;span&gt;from&lt;/span&gt; 1&lt;br/&gt;2022/03/30 09:35:36 transfer &lt;span&gt;in&lt;/span&gt; 30 cents &lt;span&gt;to&lt;/span&gt; 2&lt;/pre&gt;&lt;p&gt;那就是事务正常完成了&lt;/p&gt;&lt;h2&gt;开发接入&lt;/h2&gt;&lt;p&gt;参考 https://github.com/dtm-labs/dtmdriver-clients 的代码&lt;/p&gt;&lt;pre&gt;&lt;span&gt;// 下面这些导入 kratos 的 dtm 驱动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    _ &lt;span&gt;&quot;github.com/dtm-labs/driver-kratos&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// dtm 已经经过前面的配置，注册到下面这个地址，因此在 dtmgrpc 中使用该地址&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; dtmServer = &lt;span&gt;&quot;discovery://localhost:2379/dtmservice&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 业务地址，下面的 busi 换成实际在 server 初始化设置的名字&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; busiServer = &lt;span&gt;&quot;discovery://localhost:2379/busi&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 发起一个msg事务，保证TransOut和TransIn都会完成&lt;/span&gt;&lt;br/&gt;gid := dtmgrpc.MustGenGid(dtmServer)&lt;br/&gt;m := dtmgrpc.NewMsgGrpc(dtmServer, gid).&lt;br/&gt;  Add(busiServer+&lt;span&gt;&quot;/api.trans.v1.Trans/TransOut&quot;&lt;/span&gt;, &amp;amp;busi.BusiReq{Amount: &lt;span&gt;30&lt;/span&gt;, UserId: &lt;span&gt;1&lt;/span&gt;}).&lt;br/&gt;  Add(busiServer+&lt;span&gt;&quot;/api.trans.v1.Trans/TransIn&quot;&lt;/span&gt;, &amp;amp;busi.BusiReq{Amount: &lt;span&gt;30&lt;/span&gt;, UserId: &lt;span&gt;2&lt;/span&gt;})&lt;br/&gt;m.WaitResult = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;err := m.Submit()&lt;br/&gt;logger.FatalIfError(err)&lt;/pre&gt;&lt;h2&gt;深入理解动态调用&lt;/h2&gt;&lt;p&gt;在 kratos 使用 dtm 的分布式事务时，许多的调用是从 dtm 服务器发起的，例如 TCC 的Confirm/Cancel，SAGA/MSG 的所有调用。&lt;/p&gt;&lt;p&gt;dtm 无需知道组成分布式事务的相关业务 api 的强类型，它是动态的调用这些api。&lt;/p&gt;&lt;p&gt;grpc 的调用，可以类比于 HTTP 的 POST，其中：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&quot;/api.trans.v1.Trans/TransIn&quot; 相当于 URL 中的 Path。请注意这个Path一定是要从TransIn的Invoke函数实现里面找&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&amp;amp;busi.BusiReq{Amount: 30, UserId: 1} 相当于 Post 中 Body&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;v1.Response 相当于HTTP请求的响应&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通过下面这部分代码，dtm就拿到了完整信息，就能够发起完整的调用了&lt;/p&gt;&lt;p&gt;&lt;code&gt;Add(busiServer+&quot;/api.trans.v1.Trans/TransIn&quot;, &amp;amp;busi.BusiReq{Amount: 30, UserId: 1})&lt;/code&gt;&lt;/p&gt;&lt;h2&gt;其他方式接入&lt;/h2&gt;&lt;p&gt;kratos 的微服务还有非 etcd 的其他方式，下面列出它们的接入方式&lt;/p&gt;&lt;h4&gt;直连&lt;/h4&gt;&lt;p&gt;对于直连这种方式，您只需要在上面 dtm 的 etcd 配置基础上，将 Target 设置为空字符串即可。&lt;/p&gt;&lt;p&gt;直连的情况，不需要将 dtm 注册到注册中心&lt;/p&gt;&lt;h2&gt;联系我们&lt;/h2&gt;&lt;p&gt;项目地址：https://github.com/dtm-labs/dtm 欢迎访问，并star支持我们&lt;/p&gt;&lt;p&gt;kratos地址：https://github.com/go-kratos/kratos&lt;/p&gt;&lt;p&gt;关注【分布式事务】公众号，获得更多分布式事务相关知识&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNzQ2NzMyNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/9m9OfQX94Vv04GUcaMFCzcfHeGnTECibTEibP26ByiaHcdD7qYLNFAyQcDvbVBerQs55hXppwia3XpPjIYF3MKGzVQ/0?wx_fmt=png&quot; data-nickname=&quot;分布式事务&quot; data-alias=&quot;wangxiyan0901&quot; data-signature=&quot;介绍分布式事务相关理论与实践知识。 开源项目yedf/dtm的相关信息发布。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;dtm社区：添加dtm作者微信进入社群&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9m9OfQX94VscRTgetU9ibThVcRxicFMxaq1j4COA8ibmQsfzDnEDxswYWmXZ5Vwuiaicy7sMTvjfoicKsr7lWIQHL73A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>