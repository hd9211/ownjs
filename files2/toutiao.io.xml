<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>34f5d544750e794f0bc96c53e8ed9983</guid>
<title>汤楚熙：美团实时数仓架构演进与建设实践</title>
<link>https://toutiao.io/k/ctkg4cp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-backh=&quot;156&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;561&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;156&quot; data-fileid=&quot;100072321&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjicBGnN2Sv2xfMf0eh07fxe53FSEJr7ogaf9QJMSV0iboV8bKNibavEhvl3VqpqOQVXI1r4kwgIhLjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjdrlkyhHH3BZDV05IvhuKOic0so28M9B0cD8Hqia6HMpWBZhzfsTqP48RHZwSfonCSA3OtgJoM212A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: -10px; margin-left: -8px; max-width: 100%; width: 18px; height: 18px; border-top: 8px solid rgb(54, 65, 173); border-left: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-style=&quot;max-width: 100%; width: 543.333px; background: rgb(247, 247, 247); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;分享嘉宾：汤楚熙 美团&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;编辑整理：李瑶 DataFun&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;出品平台：DataFunTalk&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; width: 18px; height: 18px; border-bottom: 8px solid rgb(54, 65, 173); border-right: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;大家好，我叫汤楚熙，来自美团数据平台中心的计算平台团队，当前主要工作内容是实时数仓平台的研发。&lt;/span&gt;&lt;span&gt;今天和大家分享一下实时数据在美团的典型应用场景，实时数仓建设中的挑战和解决方案，包括一些关键的设计细节。主要介绍以下几方面内容：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;建设背景&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;首先，来介绍一下美团实时数据的典型应用场景以及建设过程遇到的一些问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;实时数据在美团的典型应用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBYFqejv3H9cOFUiaYZMMtWHlQIFU2ZNicMOHo0Ir7xFmoHEvlZPE1t8icg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美团作为本地生活领域的头部公司，在内部孵化了许多独立业务，可以看到有大家所熟悉的美团外卖、酒店、美团优选等，这些业务通过实时数据来支撑其内部各种各样的数据应用场景，比如BI、算法、骑手调度等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBUZBnjRrm4hw0O5g2e6zS26FpavVq3eMN4N0Zu10MTTiaw18TIQl2C3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们对业务场景做了一个简单的分类：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;指标监控：比如有实时大盘，用来即时反馈业务当日运转的健康度等场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实时特征：比如搜索、广告CTR预估、骑手调度等，对算法特征数据新鲜度要求较高的场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事件处理：比如一些风控类、运营活动发券等事件驱动型场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据对账：比如&lt;/span&gt;&lt;span&gt;金融的支付业务，支付部门与业务部门各自独立，当业务部门的支付单据与支付部门不一致时，会造成资损，这时数据的实时对账就非常关键。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBltMbWY2ZMQeDxvVmvlkUbEBbmibAml51DKUby922H1AnDu1UU2Y32RA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图可以看到，截至目前，实时计算平台所支撑的实时数据处理场景的整体规模，&lt;/span&gt;&lt;span&gt;说明实时数据在美团已经影响到了业务的方方面面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB0uzg3I8AelZ5NWuGWj9aphsyvuhaHIgLcnk6bXZibDJC4gPicLwcfyuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时计算平台从成立以来，经历了上图中的几个关键发展阶段。&lt;/span&gt;&lt;span&gt;平台正式成立于2014年，我们引入Storm和Spark Streaming作为美团的第一代实时计算引擎，并且发布了第一版作业托管平台。接下来在2017年，平台正式引进了Flink，并开始初步探索以Flink SQL为主的实时数仓开发方式。并于2019年，正式将Flink SQL作为主要编程接口暴露给业务，将以任务为中心的开发模式，升级为以数据为中心的开发模式。当前，计算平台紧跟业界发展潮流，将工作内容都聚焦在数仓增量化生产、流批语义统一、统一实时离线数仓建模方式等几个方向上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 实时数仓建设过程中的问题及痛点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBGQLyjJ6tk2ItdkURNXZKD5wcZAQhjBxoVFhnN18Qcy6oHP8wFZQARA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在正式开始介绍数仓平台的建设实践之前，先来回顾下平台初期所遇到的问题。&lt;/span&gt;&lt;span&gt;实时数据开始建设之初，是没有离&lt;/span&gt;&lt;span&gt;线数仓那样成熟的建设方法论的，而且也没有离线数仓领域那样成熟的开发工具，所以带来了以下几点问题&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先就是高昂的开发运维成本，每次计算框架的升级，业务都需要学习一遍计算框架的API。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码本地开发，再去线上调试，本地的case难以覆盖线上的数据问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务各自的数据协议不统一，相互之间进行数据交换，沟通协作的成本也是比较高昂的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数仓的建设方式没有统一规范，导致数据的冗余和重复建设，给后期的资源治理带来了非常大的麻烦。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBvM4Pjq9dOW3mX6JKWKtEefZNS8GJ7EqUH5dulF3cZ0iaQZdhoAW2MFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面的问题出发，我们制定了平台的建设路线。&lt;/span&gt;&lt;span&gt;主要集中在两个层面，&lt;/span&gt;&lt;span&gt;首先是降低业务的开发运维门槛，让实时数仓开发可以像离线数仓开发那样简单高效。&lt;/span&gt;&lt;span&gt;比如我们提供了标准的ETL作业模板，web集成开发环境，并且扩展了SQL的能力，使业务可以尽量以符合其认知的形式去进行代码开发。&lt;/span&gt;&lt;span&gt;还有数仓建设中业务最关心的数据质量问题，我们也提供了相应的配套工具，帮助业务以尽可能低的成本将可靠的数据交付应用方。&lt;/span&gt;&lt;span&gt;可用性在离线数仓建设过程中可能大多体现在数据是否按时就绪，那么实时数仓对数据的时延要求更高，所以可用性的保障也非常关键。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面提到的都是在开发运维效率方面我们所做的一些建设规划，在大数据领域，一个&lt;/span&gt;&lt;span&gt;底层算子性能的小小改进，都会使执行效率成倍的放大，所以我们也会花费一些精力在底层算子的优化上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两横三纵，其中&lt;/span&gt;&lt;span&gt;两横包括&lt;/span&gt;&lt;span&gt;开发迭代效率，面向人的优化，重点在于对工作流。&lt;/span&gt;&lt;span&gt;三纵包括&lt;/span&gt;&lt;span&gt;能做（&lt;/span&gt;&lt;span&gt;看得见、摸得着的问题）、&lt;/span&gt;&lt;span&gt;做好和&lt;/span&gt;&lt;span&gt;最优化。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;平台架构设计&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来开始着重介绍我们是如何解决上面所提到的问题的。&lt;/span&gt;&lt;span/&gt;&lt;span&gt;首先从整体上来介绍下平台解决上面问题的思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB98QiaZpChXWSFTYzbS2nRYAxb3sWicmzfxFnmsxJPXL7cEJ13kRdIibUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是平台整体架构。&lt;/span&gt;&lt;span&gt;从下向上来看，存储、计&lt;/span&gt;&lt;span&gt;算、调度加上日志服务构成了我们的基础服务层。&lt;/span&gt;&lt;span&gt;基础服务层之上是平台对业务提供的一些中间件。&lt;/span&gt;&lt;span&gt;上层是平台抽象出的一些可自行组合的微服务集合，比如作业模板服务、&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;托管服务、元数据服务、指标采集监控、数据质量管理等，这些服务业务可以按自身的场景需要来在自己的业务内部自行组合，也可以直接使用平台包装好的大而全的集成开发平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB4HY4vx39LcKJPn4eNW2DAdGw3bkicP69ve7H8xVnSs3wYNQcGaCYuwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图展示了平台基础服务中最关键的计算服务的选型过程。&lt;/span&gt;&lt;span&gt;实时数仓场景的最根本业务诉求是数据的时效性，这里的时效性通常指的是秒级的延迟，所以这里Flink和Storm胜出。&lt;/span&gt;&lt;span&gt;其次是数据的正确性，Flink是这里唯一能够保证Exectly-Once计算语义的框架，所以Flink要优于storm。&lt;/span&gt;&lt;span&gt;之后我们有做了benchmark测试，通过实验证明了，在绝大多数场景下Flink任务的吞吐要优于Storm，而且Flink还提供了更加成熟的SQL编程接口，&lt;/span&gt;&lt;span&gt;所以我们最终确认选择Flink作为实时数仓的核心计算框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBaWbN38PIibEQB6ubYWibEejXRlvYgXnm52IwRMXs6fyEdENhBIE4Nhpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决了计算框架的问题，接下来我们要从上层概念入手，让熟悉离线数仓开发的同学能够更快的上手实时数仓的开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从下向上看，我们先统一了离线和实时数仓的数据模型，无论是&lt;/span&gt;&lt;span&gt;HiveT&lt;/span&gt;&lt;span&gt;able&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt;Topic&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span&gt;的一个域，在上层暴露给业务的都是一张&lt;/span&gt;&lt;span&gt;Table&lt;/span&gt;&lt;span&gt;，这样业务没有过多认知上的负担了，可以在不同开发场景的概念之间轻松切换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上向下看，我们又统一了编程接口，使用SQL作为数仓开发的首选，这样实时和离线数仓的ETL逻辑甚至可以完全共用一套，对开发效率上也有显著的提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBgVSWYyNU8mM1d2LhfUIuZrlaccT4TLLngd9wOxn2r2DW1nicicdFcRvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有同学可能会问，实时和离线场景的计算语义不完全相同，实时计算场景需要包含大量跟时态相关的语法，比如window，interval等，离线场景上没有，那么怎么统一呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;的确如此，所以我们独立出一套SQL服务，短期用户也可以在SQL中加入HINT提升或者是直接提供一些参数，来告诉我们这是什么离线还是实时场景的ETL，未来我们会自动根据业务的输入、输出表的存储类型，ETL的模式，自动判断使用哪种类型的执行模式更有效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;跟社区如果对不齐怎么办：&lt;/span&gt;&lt;span&gt;先对内解问题，如果效果真的不错，可以推回社区，如果社区有更好的方案，我们可以判断是否能够&lt;/span&gt;&lt;span&gt;merge&lt;/span&gt;&lt;span&gt;进来，如果不行，说明我们的架构设计本身就是有问题的。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;平台建设实践&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 实时数仓开发解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBneF2W9VxhscZ6DEaWnny3PeCM8POTNvllHQ4DsiatwQjQR9ibPx586lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们对数仓平台的定位是：集需求准备、开发测试、发布和运维监控能力的一站式实时数仓生产解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面简单来介绍一下用户在平台上的工作流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在需求准备阶段，用户可以结合业务需求先来检索是否有满足需求的数据模&lt;/span&gt;&lt;span&gt;型，如果没有找到，那么可以选择从源头开始接入，或者新建模型。模型接入或创建好之后，进入&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;开发阶段，开发过程可能会伴随着一些简单的任务调试，这些工作也全部都可以在平台上完成。在开发完成准备上线之前，用户可以创建一条发布流水线，这块内容后面还有详细的介绍，待流水线执行通过后，就可以正式发布作业了，作业上线后，平台会自动收集作业的运行时指标，用来监控作业的运行状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBp5Mumbhu569BCsOKajL31De9oB7CLzib58sGzEV1mPOE2rqZ4yG7Inw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面介绍下，平台是如何规范业务的数仓接入流程的。&lt;/span&gt;&lt;span&gt;从上图（左）&lt;/span&gt;&lt;span&gt;大家可以看到，跟离线数仓的入仓流程相比，在没有数仓平台前，实时数仓的入参过程突出了一个乱字，而这样会带来如下问题：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数&lt;/span&gt;&lt;span&gt;据建设过程没有规范，后面接手的同学不知道从何入手。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接着上面的问题，如果后面同学按照自己的理解，重新接入一遍数据，长此以往，会造成大量的冗余数据，造成烟囱林立，资源浪费，后面还&lt;/span&gt;&lt;span&gt;需要花大量的时间治理。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数仓接入这个动作本身是没有过多业务逻辑的，是可以标准化和系统化的，这样重复机械的工作内容，会造成人力资源的浪费。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQB88KCrrpm37m535yQ9ZbicE1NMtvE8sNQYzxjJY3x4uvA47G6sfFwoQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面对上述问题，数仓平台提供了一套完整的实时数仓接入方案。&lt;/span&gt;&lt;span&gt;明确的帮用户生成&lt;/span&gt;&lt;span&gt;ODS&lt;/span&gt;&lt;span&gt;层，这样同项目成员之间的合作，有了共同的规范和约束，不会再有因信息未对齐而造成的数据重复接入。&lt;/span&gt;&lt;span&gt;我们不光帮助用户规范了入仓的流程，还提供了一系列数据正确性、作业稳定性的保障机制，使业务同学可以将精力集中在数仓的建设上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBvIQ1OCelPys7JeKECarpg3YZcb1I47fB43V6nvUNlCNhaghCJNFfDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在规范化业务数仓接入流程的方案设计过程中，有个小小的挑战，那就是我们的数据源并不仅仅来自MySQL binlog和nginx日志，还有大量业务自行通过SDK上报的日志，这些日志的格式难以从整体上进行抽象，而且不同业务因为服务场景不同，数据的序列化方式也难以统一，所以我们抽象出一个Adapter模块，专门用来解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;P&lt;span&gt;arser&lt;/span&gt;&lt;span&gt;用来适配业务自定义消息格式，&lt;/span&gt;&lt;span&gt;Formatter&lt;/span&gt;&lt;span&gt;将用来监控作业稳定性和数据正确性的元数据信息融入到消息中，最后按照业务场景的实际诉求，允许业务根据自身场景定义序列化方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBiaBtOvNsHeZA481jLn7UzEsm5sJLNGcXJuhtFHKPNNPFAMHtYXT9e0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面介绍了平台在数据入仓阶段如何提升开发效率。&lt;/span&gt;&lt;span&gt;接下来介绍如何帮助业务更低门槛的进行实时数据的开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;平台上线之初是基于&lt;/span&gt;&lt;span&gt;Flink1.&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;实现的模板任务，在当时来看，他们的能力并不成熟，一些在离线场景比如&lt;/span&gt;&lt;span&gt;SparkSQL&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;HiveSQL&lt;/span&gt;&lt;span&gt;都支持的语法，在&lt;/span&gt;&lt;span&gt;Flink&lt;/span&gt;&lt;span&gt;上支持的并不好。&lt;/span&gt;&lt;span&gt;所以我们决定先由平台自行根据业务需求对语法进行扩展。&lt;/span&gt;&lt;span&gt;比如t&lt;/span&gt;&lt;span&gt;able&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;的声明，还有insert into&lt;/span&gt;&lt;span&gt;等语法的支持。&lt;/span&gt;&lt;span&gt;当然这并不是全部。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBGsYT3LRI7PkSXdGoVsj4AeRa91oHTc0V8qpFbNBLuc90cwHEgbCLVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们不仅仅在&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语法层面进行了改进，&lt;/span&gt;&lt;span&gt;还对作业模板进行了增强。像&lt;/span&gt;&lt;span&gt;watermark&lt;/span&gt;&lt;span&gt;提取对业务时间格式有一些要求，&lt;/span&gt;&lt;span&gt;这种业务场景强相关的逻辑并不适合直接写死在我们的模板程序代码中。&lt;/span&gt;&lt;span&gt;所以我们在作业模板中加入了几个切面，可以由业务自行上传代码来扩充这部分能力。&lt;/span&gt;&lt;span&gt;比如我们会在&lt;/span&gt;&lt;span&gt;Source&lt;/span&gt;&lt;span&gt;注册之后，提供一个切面，引入用户代码，进行日期格式转换，再执行&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;官方虽然已经提供了计算列，我们也调研了相关能力，但是我们认为除非有一个数量级的开发效率优化效果，否则我们没必要一定&lt;/span&gt;&lt;span&gt;follow&lt;/span&gt;&lt;span&gt;官方的语法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBwOuETjKDeaBYib0If5Bvy6iczgCk8omeU2uQ0I2eZEBg9BmQhw0DrDWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经&lt;/span&gt;&lt;span&gt;过对模板的升级改造，可以看到平台能够支持的&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;模式已经非常丰富了，后面我们也会继续迭代，目标是可以覆盖&lt;/span&gt;&lt;span&gt;95%&lt;/span&gt;&lt;span&gt;以上的实时&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBjNMjAURAQpcYyrQWNcxj1tlLQ4Tr6Fke0icTMnlQPb9ymZqNh6nTBjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;UDF是一种扩展SQL表意能力的重要功能，在没有平台的时候，用户UDF都是散布在各自的代码仓库中的，这样一些较通用的UDF，不能被其他业务直接使用，业务在代码中执行一些有安全风险的行为，平台也无法有效管控。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以我们建设了一套&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;托管服务，帮助业务集中托管&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;代码，可以编译打包时，进行提前检查、并暴露安全风险，而且通用&lt;/span&gt;&lt;span&gt;UDF&lt;/span&gt;&lt;span&gt;可以在业务之间共享，也能够帮助业务提升开发效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBAIZ160SJIQjjicC9Eibs6zlYoQlMWveRaiaz6VRM6M8LcSBpoaewAFPicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面的内容，主要是如何解决开发效率的问题，下&lt;/span&gt;&lt;span&gt;部分内容的重点是，如何保证业务的数据质量。&lt;/span&gt;&lt;span&gt;可能在场的各位同学，有后台开发的相关经验，大家可能都了解&lt;/span&gt;&lt;span&gt;Devops&lt;/span&gt;&lt;span&gt;方法论的核心目标，是保证迭代效率和工程质量。&lt;/span&gt;&lt;span&gt;实时数据开发其实与后台服务开发过程有相似的地方，作业发布后，数据就会立即生效，&lt;/span&gt;&lt;span&gt;并作用于线上，所以我们也需要一套流程，来保证我们每次实时任务发布的数据质量不用影响到我们的数据服务质量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们设计了一套数仓发布的&lt;/span&gt;&lt;span&gt;Pipeline&lt;/span&gt;&lt;span&gt;，在每次任务迭代上线过程都会执行一次&lt;/span&gt;&lt;span&gt;Pipeline&lt;/span&gt;&lt;span&gt;过程，&lt;/span&gt;&lt;span&gt;TestCase&lt;/span&gt;&lt;span&gt;就类似于单测用例，理论上所有&lt;/span&gt;&lt;span&gt;TestCase&lt;/span&gt;&lt;span&gt;都通过才可以发布作业。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pipeline服务是通过一个异步任务调度框架来实现的，每个Worker内会启动一个Flink的MiniCluster进程，执行后会将结果存入DB并在前端打印执行结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBfz5pZlAyAB3MsjTdZicicjQjzSQQHQ1cibIGd7RANicq2INkicwb7DDVn0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于数据质量，业务还有一项非常关心的事项，也就是数据的时延。时延一方面可以说明业务交付的数据是否符合应用方的预期，另一方面也方便业务自己去排查问题，确定作业的性能瓶颈点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Flink&lt;/span&gt;&lt;span&gt;官方提供了一个用来计算延迟情况的机制，&lt;/span&gt;&lt;span&gt;Latency Marker&lt;/span&gt;&lt;span&gt;，这个东西近似于&lt;/span&gt;&lt;span&gt;Watermark&lt;/span&gt;&lt;span&gt;，是一类与业务数据无关的，由框架周期性产生的消息，我们要做的是根据业务的流量和业务延迟时间精度的要求，控制这类消息的发送频率和发送量，&lt;/span&gt;&lt;span&gt;并支持跨任务传递&lt;/span&gt;&lt;span&gt;Marker&lt;/span&gt;&lt;span&gt;。因为平台收口了数仓接入层，所以这也使我们获取到真正的端到端延迟成为可能，&lt;/span&gt;&lt;span&gt;我们会通过&lt;/span&gt;&lt;span&gt;emitter&lt;/span&gt;&lt;span&gt;向下游发送特殊的消息协议，并且下游任务的&lt;/span&gt;&lt;span&gt;Reciver&lt;/span&gt;&lt;span&gt;会对这类消息做特殊判断，在发送和接受数据时都会将指标上报到&lt;/span&gt;&lt;span&gt;Raptor&lt;/span&gt;&lt;span&gt;，即美团内部的一个业务指标监控，并最终提供给业务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBOPQP4lGiaWIM7etaHsiaicaznYjOKRLdS2ic0otEEsuPbcCwlwVIWgucNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面我们分别介绍了平台是如何提升开发效率和保证业务的数据质量的，主要解决的是数仓开发者的问&lt;/span&gt;&lt;span&gt;题。&lt;/span&gt;&lt;span&gt;平台还有一类用户是数仓架构师，他们不仅仅要参与数仓的建设，还需要对数仓的建设情况做整体性把控。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以前大家都是通过wiki的形式来进行数仓的规范和约束。数仓平台提出了一个项目空间的概念，每个项目空间都可以由架构师定义符合自身业务场景的一些约束项，比如架构师可以定义数仓的主题、分层规范，表、字段的命名规则，同项目空间下的实体都必须遵守负责人做定义的规范。&lt;/span&gt;&lt;span&gt;这样可以在开发之前就保证数仓的建设质量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 算子性能优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面来分享下我们在flink算子层面所做的一些优化工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBsib9hIGK6FWianKfdhLpibIlYTf7KhcQ1tSzj3XYNHZQak2CeDh8SFdXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先实时数仓有很大一部分计算场景是用来做扩维的，也就是流表关联。流数据来自kafka，表数据通常是借助redis、hbase等分布式kv存储，当流量小的时候，每一条流数据都请求一次外存，发起一次网络io，也没有多大影响。但是像基础流量等业务，每天几百上千亿条消息，都去单独请求外存，压力可想而知。所以平台为用户准备了本地缓存机制，通过一个多级缓存的架构，来缓解超大流量下外存访问的IO的压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBAY2Z54cKqOjGDQmSRcJibxVA85Sia23apphkRaaicoWzxb2JKm7MXicDEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数仓&lt;/span&gt;&lt;span&gt;ETL&lt;/span&gt;&lt;span&gt;会包含大量聚合、关联和排序等逻辑，在有界数据处理的时候，我们对算子行为能够做出较准确的判断。&lt;/span&gt;&lt;span&gt;但是在无界数据处理的情况下，像关联、聚合等逻辑为了保证数据的正确性，会在更新一条记录的同时产生一条回撤消息，用来修复下游已经受到影响的数据，所以实际向下游传递的消息量可能会翻倍。而当涉及到多层算子嵌套，比如聚合嵌套关联，那么消息量还会继续膨胀。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决这个问题，我们研究了框架的源码，并分析了业务数据的特征，发现实际上大多数情况消息在极短的时间内会被频繁更新多次，这也就意味着我们可以将多次请求合并成一次请求，来减少状态更新的次数，从而减少向下游发送的消息量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBeuh9E26WdjtRQqPLxgP1qeGTt6ibpxydfeSKXwWBuMG3icf1hiaHCeMhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是一个&lt;/span&gt;&lt;span&gt;Join&lt;/span&gt;&lt;span&gt;算子的&lt;/span&gt;&lt;span&gt;优化案例，在分析了原理后，&lt;/span&gt;&lt;span&gt;我们认为可以分三个阶段来对算子进行优化：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先在输入阶段，可以对输入的消息做预处理，如果发现同key数据紧跟一条回撤事件，我们这两条消息可以同时消除，而保留最新的一条消息；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接下来在计算阶段，因为双流关联需要缓存左右流各自的状态，这样我们可以将短时间同&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;对状态的访问，合并成一次，减少状态访问次数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最后在事件下发阶段，可以判断消息之间的关系，重复记录直接可被直接消除。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 建设成果展示&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBs4diaNcHdWBcSlVorf9jOzzlan7QcgVMmRw7RfBORhIIbjEtLsz8a4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是我们的Web IDE，左面是菜单栏，可以用来管理项目空间，右面是一个web编辑器，用来开发ETL脚本，编辑器下还提供了控制台，用来查看调试日志和对比调试结果，还有语法错误提示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBeOmVm0x2IXh98nicBibbv3c0pIHD9TOq3orVL2Sqe6YOhFx721SRwDXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图是我们的逻辑模型管理模块，在此我们可以编辑自己的模型信息，查看血缘，资源占用量，数仓相关的业务属性等元数据，来辅助业务更好地进行数仓建模。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBROVS5khzLInia3S8YkT6bMIdxoovquk1HU6a0LC8CXVwMt51FicLajcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后展示的是运维中心，所有的作业运行状况，运行指标，操作日志都可以通过这个平台来管理。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;未来计划&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBFrJatQcJlib3YQDHc9FSSns7LL5NqPxqXibKYaPtb0gUmkUac2oHJkwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从前面的分享大家可能会看出，平台前期的大部分精力都集中在解决业务实时数仓建设流程方面的问题上。&lt;/span&gt;&lt;span&gt;随着数仓平台在业务上的逐渐推广，以及业务的深度使用，问题更多的出现在框架的&lt;/span&gt;&lt;span&gt;runtime&lt;/span&gt;&lt;span&gt;层面，比如超大作业的调度成功率和时长问题，&lt;/span&gt;&lt;span&gt;超大数据量作业的状态访问性能问题。&lt;/span&gt;&lt;span&gt;希望通过流批一套语义、一套执行层、一套存储，来彻底解决开发运维的成本问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，&lt;/span&gt;&lt;span&gt;随着实时数据扩展至一些ToC业务场景，这些应用有着非常高的可用性要求，所以在这个方向上我们也要继续攻关下去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后就是终极问题，资源和性能比的问题，也就是在确定性的条件下，用最少的资源做最多的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgibXIibpMibxcUJCjgYnuTJQBDafUPSRtF5CoibhFle6iaIj2b4EhZZia3Gc4rOKcxicyRN54tibkSo21gYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是我们平台当前在建设的一个重点项目——数仓增量化生产，为达成真正的流批一体做一些前置性的技术储备和路径探索。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;今天的分享就到这里，谢谢大家。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在文末分享、点赞、在看，给个3连击呗~&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享嘉宾：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;289&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjdrlkyhHH3BZDV05IvhuKOLmiagvjMPlliaqSQNYsx5T6c3b9RgSj29egrVabhnl5n6Av9MqAGUhibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;电子书下载&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;389&quot; data-backw=&quot;578&quot; data-fileid=&quot;100072355&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6733909702209414&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjicBGnN2Sv2xfMf0eh07fxem4LZeMGOo8FKqdlPdbTWZtXDDHYfNS78E3QkgUh68DMRia11ayJcyOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1041&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;《大数据典藏版合集》&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;电子书目录如上，感兴趣的小伙伴，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;欢迎识别二维码&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，添加小助手微信，回复&lt;/span&gt;&lt;strong&gt;&lt;span&gt;『大数据典藏版合集』&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，即可下载。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;146&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;145&quot; data-fileid=&quot;100072351&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9927007299270073&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;274&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lAStFsJ0Pm0T9eZG6MS4grBiaJAPvOxCotLBIwWiceTLXicvMa6pq5s7ZmCgDFrQQnlWEvhAG1iaKkicXymMicpeVWFA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关于我们：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;DataFun：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;专注于大数据、人工智能技术应用的分享与交流。发起于2017年，在北京、上海、深圳、杭州等城市举办超过100+线下和100+线上沙龙、论坛及峰会，已邀请近1000位专家和学者参与分享。其公众号 DataFunTalk 累计生产原创文章500+，百万+阅读，12万+精准粉丝。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1NTMyOTI4Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgiaIKm4YqA09u83TvzKbfsabjfX1TLzaXLAK9MWmC4qI6cuTBJnxygZLZPU49O8g6j8QI9264NMqQ/0?wx_fmt=png&quot; data-nickname=&quot;DataFunTalk&quot; data-alias=&quot;datafuntalk&quot; data-signature=&quot;专注于大数据、人工智能技术应用的分享与交流。致力于成就百万数据科学家。定期组织技术分享直播，并整理大数据、推荐/搜索算法、广告算法、NLP 自然语言处理算法、智能风控、自动驾驶、机器学习/深度学习等技术应用文章。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;🧐&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;，给个&lt;strong&gt;3连击&lt;/strong&gt;呗！&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bf324c0145bf8fd4ce336df91d09b125</guid>
<title>糟糕程序员的20个坏习惯，你命中几个？</title>
<link>https://toutiao.io/k/9ohal9c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwOTIxNDQ3OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8YRIaicYx5pzj5Cxwick8DamnOgbTJu96QTibKyHEDZt1815yOV1r27oZ6HgoYTEYWYLRz4jIV4iasHgg/0?wx_fmt=png&quot; data-nickname=&quot;dbaplus社群&quot; data-alias=&quot;dbaplus&quot; data-signature=&quot;围绕Database、BigData、AIOps的企业级专业社群。资深大咖、技术干货，每天精品原创文章推送，每周线上技术分享，每月线下技术沙龙，每季度Gdevops&amp;amp;DAMS行业大会.&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;今天我想和你聊一聊优秀程序员的基本素养。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我想你肯定遇到过这样一类程序员：他们无论是写代码，还是写文档，又或是和别人沟通，都显得特别专业。每次遇到这类人，我都在想，他们到底是怎么做到的？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着工作时间的增长，渐渐地我也总结出一些经验，他们身上都保持着一些看似很微小的优秀习惯，但正是因为这些习惯，体现出了一个优秀程序员的基本素养。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;糟糕程序员的坏习惯&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;但今天我们来换个角度，来看看一个糟糕程序员有哪些坏习惯？只要我们都能避开这些问题，就可以逐渐向一个优秀程序员靠近。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;1、技术名词拼写不规范&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;无论是个人简历，还是技术文档，我经常看到拼写不规范的技术名词，例如 JAVA、javascript、python、MySql、Hbase、restful。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正确的拼写应该是 Java、JavaScript、Python、MySQL、HBase、RESTful，不要小看这个问题，很多面试官很有可能因为这一点刷掉你的简历。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;2、写文档，中英文混排不规范&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;中文描述使用英文标点符号，英文和数字使用了全角字符，中文与英文、数字之间没有空格等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中很多人会忽视中文和英文、数字之间加一个「空格」，这样排版阅读起来会更舒服。之前我的文章排版，都是遵循了这些细节。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;3、重要逻辑不写注释，或写得很拖沓&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;复杂且重要的逻辑代码，很多程序员不写注释，除了自己能看懂代码逻辑，其他人根本看不懂。或者是注释虽然写了，但写得很拖沓，没有逻辑可言。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重要的逻辑不止要写注释，还要写得简洁、清晰。如果是一眼就能读懂的简单代码，可以不加注释。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;4、写复杂冗长的函数&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;一个函数几百行，一个文件上千行代码，复杂函数不做拆分，导致代码变得越来越难维护，最后谁也不敢动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基本的设计模式还是要遵守的，例如单一职责，一个函数只做一件事，开闭原则，对扩展开放，对修改关闭。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果函数逻辑确实复杂，也至少要保证主干逻辑足够清晰。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;5、不看官方文档，只看垃圾博客&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;很多人遇到问题不先去看官方文档，而是热衷于去看垃圾博客，这些博客的内容都是互相抄袭，错误百出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实很多软件官方文档写得已经非常好了，常见问题都能找到答案，认真读一读官方文档，比看垃圾博客强一百倍，要养成看官方文档的好习惯。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;6、宣扬内功无用论&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;有些人天天追求日新月异的开源项目和框架，却不肯花时间去啃一啃底层原理，常见问题虽然可以解决，但遇到稍微深一点的问题就束手无策。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多高大上的架构设计，思路其实都源于底层。想一想，像计算机体系结构、操作系统、网络协议这些东西，经过多少年演进才变为现在的样子，演进过程中遇到的复杂问题比比皆是，理解了解决这些问题的思路，再看上层技术会变得很简单。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;7、乐于炫技&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;有些人天天把「高大上」的技术名词挂在嘴边，生怕别人不知道自己学了什么高深技术，嘴上乐于炫技，但别人一问他细节就会哑口无言。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;8、不接受质疑&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;自己设计的方案，别人提出疑问时只会回怼，而不是理性分析利弊，抱着学习的心态交流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些人学了点东西就觉得自己很有本事，殊不知只是自己见识太少。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;9、接口协议不规范&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;和别人定 API 协议全靠口头沟通，不给规范的文档说明，甚至到了测试联调时会发现，竟然和协商的还不一样，或者改协议了却不通知对接方，合作体验极差。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;10、遇到问题自己死磕&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;很初级程序员容易犯的问题，遇到问题只会自己死磕，拖到 deadline 也没有产出，领导来问才知道有问题解决不了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有问题及时反馈才是对自己负责，对团队负责。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;11、一说就会，一写就废&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;平时技术方案吹得天花乱坠，一让他写代码就废，典型的眼高手低选手。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;12、表达没有逻辑，不站在对方角度看问题&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;讨论问题不交代背景，上来就说自己的方案，别人听得云里雾里，让你从头描述你又讲不明白。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;学会沟通和表达，是合作的基础。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;13、不主动思考，伸手党&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;遇到问题不去 google，不做思考就向别人提问，喜欢做伸手党。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个人的时间都很宝贵，大家都更喜欢你带着自己的思考来提问，一来可以规避很多低级问题，二来可以提高交流质量。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;14、经常犯重复的错误&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;出问题后说下次会注意，但下次问题依旧，对自己不负责任，说到底是态度问题。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;15、加功能不考虑扩展性&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;加新功能只关注某一小块业务，不考虑系统整体的扩展性，堆代码行为严重。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要学会分析需求和未来可能发生的变化，设计更通用的解决方案，降低后期开发成本。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;16、接口不自测，出问题不打日志&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;自己开发的接口不自测就和别人联调，出了问题又说没打日志，协作效率极低。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;17、提交代码不规范&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;很多人提交代码不写描述，或者写的是无意义的描述，尤其是修改很少代码时，这种情况会导致回溯问题成本变高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;制定代码提交规范，能让你在每一次提交代码时，不会做太随意的代码修改。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;18、手动修改生产环境数据库&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;直连生产环境数据库修改数据，更有 UPDATE / DELETE SQL 忘写 WEHRE 条件的情况，产生数据事故。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;修改生产环境数据库一定要谨慎再谨慎，建议操作前先找同事 review 代码再操作。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;19、没理清需求就直接写代码&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;很多程序员接到需求后，不怎么思考就开始写代码，需求和自己理解的有偏差，造成无意义返工。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;多花些时间梳理需求，能规避很多不合理的问题。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; placeholder=&quot;请输入标题&quot;&gt;&lt;span&gt;&lt;strong&gt;20、重要设计不写文档&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;重要的设计没有文档输出，和别人交接系统时只做口头描述，丢失关键信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有时候理解一个设计方案，一个好的文档要比看几百行代码更高效。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;以上这些不良习惯，你命中几个呢？或者你身边有没有碰到这样的人？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我认为提早规避这些问题，是成为一个优秀程序员必须要做的。这些习惯总结起来大致分为这 4 个方面：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;良好的编程修养&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;谦虚的学习心态&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;良好的沟通和表达&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;注重团队协作&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优秀程序员的专业技能，我们可能很难在短时间内学会，但这些基本的职业素养，是可以在短期内做到的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;希望你我可以有则改之，无则加勉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你认为还有哪些程序员的坏习惯，欢迎在评论区留言讨论~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;作者丨Kaito&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源丨公众号：水滴与银弹（ID：waterdrop_bullet）&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;dbaplus社群欢迎广大技术人员投稿，投稿邮箱：&lt;/span&gt;&lt;span&gt;editor@dbaplus.cn&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>49b88dce795696cbfa44fb0b7013a6fb</guid>
<title>宣布Kubernetes策略管理白皮书</title>
<link>https://toutiao.io/k/m17h97v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;285&quot; data-backw=&quot;540&quot; data-ratio=&quot;0.5277777777777778&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJykl78gSWLQ2BgZksNPibndNocPwMVzKNtDfsfv3SOwcYJM1Ypwib7uPlyXjMLMCnxwYxkBHhgvFJNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;540&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：Jim Bugwadia&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CNCF Kubernetes 安全 SIG 和策略工作组（WG）刚刚发布了&lt;span&gt;Kubernetes 策略管理白皮书&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，以帮助社区了解使用策略管理 Kubernetes 配置的最佳实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该白皮书旨在提供一个清晰的理解为什么 Kubernetes 策略管理对 Kubernetes 集群和工作负载的安全和自动化是重要的。它还描述了 Kubernetes 策略可以帮助解决哪些问题，以及如何实现 Kubernetes 策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“策略可以简化开发人员、操作人员、安全工程师和合规官员对 Kubernetes 配置和安全控制的管理。在云原生环境中，除了应用运行时安全外，在连续交付流水线和准入控制中执行策略有助于将安全性向左转移，加强软件供应链安全。本白皮书代表了社区的努力，在阐明 Kubernetes 集群操作、安全、持续遵从性和管理策略的作用方面迈出了重要的一步。”CNCF Kubernetes 策略工作组 Aradhna Chetal 说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该白皮书介绍了跨云原生生命周期的基于策略的操作的新指导，并讨论了 Kubernetes 策略管理的参考架构，提供了所需的每个组件的描述。该白皮书还讨论了策略如何映射到其他安全领域，如威胁建模、保证和遵从性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes 安全 SIG 安全专注于提高 Kubernetes 项目跨所有组件的安全性。如果你对参与安全 SIG 感兴趣，请查看&lt;span&gt;宪章&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;以获得更多信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes 工作组的组织是为了解决跨 SIG 的特定主题。&lt;span&gt;Kubernetes 策略工作组&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;专注于 Kubernetes 的策略实现、架构和最佳实践。如果你对推进 Kubernetes 策略管理感兴趣，请加入&lt;span&gt;即将召开的会议&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;或在&lt;span&gt;Slack 频道&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;上向小组发送消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes 策略管理文白皮书可以在&lt;span&gt;GitHub&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;上找到。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Kubernetes 策略管理白皮书: &lt;em&gt;https://github.com/kubernetes/sig-security/blob/main/sig-security-docs/papers/policy/CNCF_Kubernetes_Policy_Management_WhitePaper_v1.pdf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;宪章: &lt;em&gt;https://github.com/kubernetes/community/blob/master/sig-security/charter.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Kubernetes 策略工作组: &lt;em&gt;https://github.com/kubernetes/community/tree/master/wg-policy&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;即将召开的会议: &lt;em&gt;https://github.com/kubernetes/community/tree/master/wg-policy#meetings&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Slack 频道: &lt;em&gt;https://kubernetes.slack.com/messages/wg-policy&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;GitHub: &lt;em&gt;https://github.com/kubernetes/sig-security/tree/main/sig-security-docs/papers/policy&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击【阅读原文】阅读网站原文。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;161&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;161&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJyjIvCTT9MHACYHrhxPr4WTsLl4cia1yECXm3kibDvzgdhicxAibuG9mokxesEs2e3wxL9sj1ApfdOKCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CNCF概况（幻灯片）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;161&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;161&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJxyapkOjiazruKNQ7DZ6t8TSh0QSYM4DlI86xnXiayciayIgBUaG8q8lFZ3FsibPJiaeCqAahrKicB220aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;301&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫描二维码联系我们！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;CNCF (Cloud Native Computing Foundation)成立于2015年12月，隶属于Linux  Foundation，是非营利性组织。 &lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;&lt;em&gt;CNCF&lt;/em&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;（&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;&lt;em&gt;云原生计算基金会&lt;/em&gt;&lt;/strong&gt;）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。我们通过将最前沿的模式民主化，让这些创新为大众所用。请长按以下二维码进行关注。&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJyq2qDvc7MWGZxI4RSwuQcDYF9lD2fuOvw9rvdXWTxODu56IibWa0R8mibibhqExqurr6168Wjf2VstQ/640?wx_fmt=png&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;165&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;165&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GpkQxibjhkJxKPX3Ywf6bvZic6ibE8EzomstVhFq0ua8p8KI8PdVve5Q6YwRzHYQ4j63hKakYPcbqAdDoRHrgcFLg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>26130370a415c0b19e3a55c1ad8f5936</guid>
<title>『每周译Go』Golang 在大规模流处理场景下的最小化内存使用</title>
<link>https://toutiao.io/k/1asw7xf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为公司平台团队的一员，我接触了很多文件处理的场景，比如管理一个通用文件上传中心服务，处理邮件附件，处理和导出大文件。在过去，这项工作要容易得多，因为我们可以完全支配整个服务器。我们可以写入一个文件让它持久化在服务器磁盘上，尽管这个作业所需的资源是非常多的。而现在，你的代码库是在更小的处理单元上发布的，比如 pods 。它的资源是虚拟分配的，并且在许多情况下是有限的，所以你需要知道如何有效地使用它们。实现优雅的处理和解决 OOM 退出问题也许对于那些已经熟悉自由地使用内存的人来说是一个大麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我看来，&lt;code&gt;Reader&lt;/code&gt; 和 &lt;code&gt;Writer&lt;/code&gt; 是 Golang 最重要的部分。它给 goroutine 和并发处理提供了重要支持，是 Go 编程模型精简且具有良好性能的关键。因此，为了更进一步掌握 Go 编程语言，你应该能够优雅地操作 go buffers 和 goroutines。在本文中，我将讨论在文件上传到云存储引擎之前，处理从卫星客户端的文件流到中央文件上传器时遇到的问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Multipart 文件转发&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.4595436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbCyXP3z23wev93ayibMU82aoibhxSxYyhTMesew1jdNn8iaDN7icQt1HJJZ22hvydSYfdRfQ6wbEcEPVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Golang，如果你搜索任何类似 &lt;code&gt;reader&lt;/code&gt; 操作，你应该得到过下面这些内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r := strings.NewReader(&lt;span&gt;&quot;Go is a general-purpose language designed with systems &lt;br/&gt;programming in mind.&quot;&lt;/span&gt;)&lt;br/&gt;b, err := ioutil.ReadAll(r)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;   log.Fatal(err)&lt;br/&gt;}&lt;br/&gt;// Playing with your loaded bytes&lt;br/&gt;fmt.Printf(&lt;span&gt;&quot;%s&quot;&lt;/span&gt;, b)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在你的代码中看到这样的东西是很常见的，因为在互联网上的许多实践都使用了这种方法。自从我第一次使用 &lt;code&gt;Reader&lt;/code&gt;，我也确实习惯了这样用。但是，如果你过度使用它，可能会对内存使用造成很大的损耗，这将极大地影响你可以处理的数据量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;典型场景当你读取的数据是已经预定义好格式的，这意味着在你读取它之后，还必须将它传递给另一个数据处理器再返回你的工作。你可能会使用的一种选择是 &lt;code&gt;io.Copy&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r := strings.NewReader(&lt;span&gt;&quot;some io.Reader stream to be read\n&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; _, err := io.Copy(os.Stdout, r); err != nil {&lt;br/&gt;  log.Fatal(err)&lt;br/&gt;}&lt;br/&gt;// The data have been copied from Reader r to Stdout&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Copy&lt;/code&gt; 是一种非常方便的操作，因为在将数据写入另一个文本进程之前，我们不需要读取数据。然而要小心的是这可能会导致你落入一个不想踏入的陷阱。官方文件中写道:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从 src 复制副本到 dst，直到在 src 上到达 EOF 或发生错误。它返回复制的字节数和复制时遇到的第一个错误(如果有的话)。— Go 官方文档&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文件离线处理时，你可以打开一个带缓冲的 &lt;code&gt;writer&lt;/code&gt; 然后完全复制 &lt;code&gt;reader&lt;/code&gt; 中内容，并且不用担心任何其他影响。然而，&lt;code&gt;Copy&lt;/code&gt; 操作将持续地将数据复制到 &lt;code&gt;Writer&lt;/code&gt;，直到 &lt;code&gt;Reader&lt;/code&gt; 读完数据。但这是一个无法控制的过程，如果你处理 &lt;code&gt;writer&lt;/code&gt; 中数据的速度不能与复制操作一样快，那么它将很快耗尽你的缓冲区资源。此外，选择丢弃或者撤销缓冲区分配也是一件很难考虑的事情。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;buf := new(bytes.Buffer)&lt;br/&gt;writer := multipart.NewWriter(buf)&lt;br/&gt;defer writer.Close()&lt;br/&gt;part, err := writer.CreateFormFile(&lt;span&gt;&quot;file&quot;&lt;/span&gt;, &lt;span&gt;&quot;textFile.txt&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;file, err := os.Open(name)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;defer file.Close()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; _, err = io.Copy(part, file); err != nil {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;http.Post(url, writer.FormDataContentType(), buf)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里 &lt;code&gt;io.Pipe&lt;/code&gt; 就出现来解决这类问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r, w := io.Pipe()&lt;br/&gt;go &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;   fmt.Fprint(w, &lt;span&gt;&quot;some io.Reader stream to be read\n&quot;&lt;/span&gt;)&lt;br/&gt;   w.Close()&lt;br/&gt;}()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; _, err := io.Copy(os.Stdout, r); err != nil {&lt;br/&gt;   log.Fatal(err)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt; 提供一对 &lt;code&gt;writer&lt;/code&gt; 和 &lt;code&gt;reader&lt;/code&gt;，并且读写操作都是同步的。利用内部缓冲机制，直到之前写入的数据被完全消耗掉才能写到一个新的 &lt;code&gt;writer&lt;/code&gt; 数据快。这样你就可以完全控制如何读取和写入数据。现在，数据吞吐量取决于处理器读取文本的方式，以及 &lt;code&gt;writer&lt;/code&gt; 更新数据的速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我用它来做我的微服务文件转发器，实际工作效果非常好。能够以最小的内存使用量来复制和传输数据。有着 &lt;code&gt;Pipe&lt;/code&gt; 提供的写阻塞功能 ，&lt;code&gt;Pipe&lt;/code&gt; 和 &lt;code&gt;Copy&lt;/code&gt; 就形成了一个完美的组合。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;r, w := io.Pipe()&lt;br/&gt;m := multipart.NewWriter(w)&lt;br/&gt;go &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;   defer w.Close()&lt;br/&gt;   defer m.Close()&lt;br/&gt;   part, err := m.CreateFormFile(&lt;span&gt;&quot;file&quot;&lt;/span&gt;, &lt;span&gt;&quot;textFile.txt&quot;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   file, err := os.Open(name)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   defer file.Close()&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; _, err = io.Copy(part, file); err != nil {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;}()&lt;br/&gt;http.Post(url, m.FormDataContentType(), r)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文件到达文件上传服务的最终目的地之前，这实际上就是我们的文件在各个服务之间传输的方式。文件流可以通过 &lt;code&gt;os.Open()&lt;/code&gt; 在本地加载，也可以通过 &lt;code&gt;multipart reader&lt;/code&gt; 从其他请求中加载。&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;预取和补偿文件流&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.4595436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbCyXP3z23wev93ayibMU82aoibhxSxYyhTMesew1jdNn8iaDN7icQt1HJJZ22hvydSYfdRfQ6wbEcEPVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的中央文件上传服务中，我们使用云引擎进行存储，它的 API 接受一个提供文件原始数据的 &lt;code&gt;reader&lt;/code&gt;。除此之外，我们还需要识别上传的内容类型，以确定是否将其删除，还是将其分类到可用的 bucket 中。但是，读取操作是不可逆的，我们必须找到一种方法，为类型检测器读取最小长度的嗅探字节，同时也需要为后一个过程保留原始数据流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个可行的解决方案是使用 &lt;code&gt;io.TeeReader&lt;/code&gt;，它会将从 reader 读取的数据写入另一个 &lt;code&gt;writer&lt;/code&gt; 中。&lt;code&gt;TeeReader&lt;/code&gt; 最常见的用例是将一个流克隆成一个新的流，在保持流不被破坏的情况下为 &lt;code&gt;reader&lt;/code&gt; 提供服务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var r io.Reader = strings.NewReader(&lt;span&gt;&quot;some io.Reader stream to be read\n&quot;&lt;/span&gt;)&lt;br/&gt;var buf = bytes.NewBufferString(&lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt;r = io.TeeReader(r, buf)&lt;br/&gt;// Everything &lt;span&gt;read&lt;/span&gt; from r will be copied to buf.&lt;br/&gt;_, _ = io.ReadAtLeast(r, mimeType, 512)&lt;br/&gt;// Continue to copy the stream to write it to buf, to use buf &lt;span&gt;in&lt;/span&gt; the following operation&lt;br/&gt;io.Copy(io.Discard, r)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但问题是，如果在将其传递给 GCP 文件处理程序之前同步运行它，它最终还是会将所有数据复制到准备好的缓冲区。一个可行的方法是再次使用 &lt;code&gt;Pipe&lt;/code&gt; 来操作它，达到无本地缓存效果。但另一个问题是，&lt;code&gt;TeeReader&lt;/code&gt; 要求在完成读取过程之前必须完成写入过程，而 &lt;code&gt;Pipe&lt;/code&gt;则相反。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以最后我们设计了一个定制化的预取 &lt;code&gt;reader&lt;/code&gt;，专门用来处理这种情况。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package services&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;   &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; prefetchReader struct {&lt;br/&gt;   reader   io.Reader&lt;br/&gt;   prefetch []byte&lt;br/&gt;   size     int&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func newPrefetchReader(reader io.Reader, prefetch []byte) *prefetchReader {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &amp;amp;prefetchReader{&lt;br/&gt;      reader:   reader,&lt;br/&gt;      prefetch: prefetch,&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (r *prefetchReader) Read(p []byte) (n int, err error) {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; len(p) == 0 {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; 0, fmt.Errorf(&lt;span&gt;&quot;empty buffer&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   defer &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;      r.size += n&lt;br/&gt;   }()&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; len(r.prefetch) &amp;gt; 0 {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; len(p) &amp;gt;= len(r.prefetch) {&lt;br/&gt;         copy(p, r.prefetch)&lt;br/&gt;         n := len(r.prefetch)&lt;br/&gt;         r.prefetch = nil&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; n, nil&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;         copy(p, r.prefetch[:len(p)])&lt;br/&gt;         r.prefetch = r.prefetch[len(p):]&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; len(p), nil&lt;br/&gt;      }&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; r.reader.Read(p)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用这个 &lt;code&gt;reader&lt;/code&gt;，你可以预取一些嗅探字节以进行处理，然后使用补偿字节创建一个新的嵌套 &lt;code&gt;reader&lt;/code&gt; 用于后面的操作。&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4595436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbCyXP3z23wev93ayibMU82aoibhxSxYyhTMesew1jdNn8iaDN7icQt1HJJZ22hvydSYfdRfQ6wbEcEPVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是我在工作中遇到的问题。操作这些 &lt;code&gt;readers&lt;/code&gt; 和 &lt;code&gt;writers&lt;/code&gt; 是非常麻烦的，但还是非常值得一试，因为这其中包含了很多乐趣。我希望你能学习到一种处理与它们相关的各种问题的方法，并能有一个更好的 Go 使用体验。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>15cf6b9f50a6596d21e6d4b4026e56a9</guid>
<title>微服务通信设计模式</title>
<link>https://toutiao.io/k/mp88imm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;&lt;em&gt;微服务之间的通信，需要根据业务需求和架构的实际情况选择合适的方案，基于HTTP的REST API是最常见的选择，但并不是唯一的选择，需要考虑复杂性、性能、可扩展性等方面的权衡。原文：My Favorite Interservice Communication Patterns for Microservices&lt;span&gt;[1]&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0V2omHAfSdvw7SicrKSTAay2IlndQIiacGjYtQZnhXOTn8sf9ZUcOIQRPq1p1GEPZI62ySibR6voSh5A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;微服务很有意思，可以帮助我们创建可伸缩的、高效的架构，因此当前几乎所有主流平台都基于微服务架构系统。如果没有微服务，就不可能有现在的Netflix、Facebook或Instagram。&lt;/p&gt;&lt;p&gt;然而，将业务逻辑分解为更小的单元并以分布式方式部署它们只是第一步。我们还必须理解怎样才能让服务之间更好的通信。没错，微服务不仅仅是面向外部的——或者换句话说，为外部客户服务——很多时候它们也是同一系统中其他服务的客户。&lt;/p&gt;&lt;p&gt;那么，如何使两个服务相互通信呢？简单的方案是继续使用呈现给外部客户的API。例如，如果我们面向外部客户的API是REST HTTP API，那么内部服务也可以通过这些API进行交互。&lt;/p&gt;&lt;p&gt;这是一个很合理的设计，但让我们看看有没有其他改进方案。&lt;/p&gt;&lt;p&gt;注：通信是基于商定的协议，微服务之间以及服务和客户之间的通信都是如此，始终确保协议一致的一种方法是在这些解耦的代码库之间共享描述这些协议的代码，可以是类、类型、模拟数据对象等，Bit&lt;span&gt;[2]&lt;/span&gt;就是有助于实现这一目标的工具。&lt;/p&gt;&lt;p&gt;Bit从源头独立的控制TS/JS模块，即使它们被部署到独立的远程主机上，也能维护它们之间的依赖关系，从而使得对某一模块的更新能够触发其所有依赖模块的持续集成。&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;HTTP API&lt;/h3&gt;&lt;p&gt;HTTP API毕竟是非常有效的设计，就让我们从这儿开始。HTTP API本质上意味着让服务就像响应浏览器或者Postman&lt;span&gt;[3]&lt;/span&gt;这样的桌面客户端那样发送信息。&lt;/p&gt;&lt;p&gt;HTTP API基于CS模式，意味着通信只能由客户端发起。这也是一种同步通信，意味着一旦通信由客户端发起，要一直等到服务端返回响应才会结束。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13406940063091483&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0V2omHAfSdvw7SicrKSTAay2UQWcDPdJVsgaic9Cvm3u5hEhI2agAKs5E0PdQmO3HlTDfxGf9BKR2sw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;634&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经典的CS微服务通信&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;因为这和我们访问互联网的方式一致，因此这种方法非常流行。HTTP是互联网的支柱，因此所有编程语言都通过某种方式支持HTTP功能，从而使其成为一种非常流行的方法。&lt;/p&gt;&lt;p&gt;但这种方式并不完美，我们来分析一下。&lt;/p&gt;&lt;p&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;容易实现。&lt;/span&gt;HTTP协议并不难实现，而且所有主要的编程语言都已经对它提供了原生支持，开发人员几乎不需要担心其内部是如何工作的，复杂性被类库所隐藏和抽象。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以被标准化。&lt;/span&gt;如果在HTTP之上添加了REST之类的东西（正确实现的），其实就是创建了一个标准API，允许任何客户端可以快速学习如何与我们的业务逻辑进行通信。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;技术中立。&lt;/span&gt;由于HTTP充当了客户端和服务器之间的数据传输通道，因此和两端的具体实现技术无关。可以用Node.js实现服务端，用JAVA或C#实现客户端（或其他服务），只要遵循相同的HTTP协议，就能够彼此通信。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;额外的时延。&lt;/span&gt;作为HTTP协议的一部分，有若干个步骤确保了数据被正确发送，因此HTTP非常可靠。然而，该这样也给通信增加了延迟（额外的步骤意味着额外的时间）。因此，考虑这样一个场景：在最后一个微服务完成之前，3个或更多的微服务需要在彼此之间交换数据。换句话说，需要让A向B发送数据，这样B才可以向C发送数据，然后C才能够发送响应。除了每个服务的处理时间外，还必须考虑在它们之间建立3个HTTP通道所增加的延迟。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;超时。&lt;/span&gt;虽然可以在大多数场景中配置超时时间，但默认情况下，如果服务器占用的时间太长，将导致客户端关闭连接。多长时间是“太长”？这取决于配置和当前的服务，但是总会有这么个时间。这为业务逻辑增加了额外的约束：需要快速执行，否则将失败。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;失败难以解决。&lt;/span&gt;解决服务器故障并不是不可能的，但是需要有额外的基础设施。默认情况下，如果服务器关闭，将不会通知客户端。客户端只有在试图访问服务器时才会意识到这一点，但已经为时已晚。有一些方法可以缓解这种情况，例如使用负载平衡器或API网关，但需要在CS通信之上进行额外的工作，以使其更可靠。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此，如果我们的业务逻辑快速可靠，并且需要被许多不同的客户端访问，HTTP API是一个很好的解决方案。多个团队在不同的客户端上工作时，可以基于一个标准、一致的接口通信，这会非常有用。&lt;/p&gt;&lt;p&gt;如果多个服务需要互相交互，或者其中一些服务中的业务逻辑需要大量时间才能完成，那么就不要使用HTTP API。&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;异步消息（Asynchronous Messaging）&lt;/h3&gt;&lt;p&gt;这种模式还包括了一个在消息生产者和接收端之间的消息代理。&lt;/p&gt;&lt;p&gt;这绝对是我最喜欢的多服务之间通信的方式之一，尤其是当我们需要横向扩展平台的处理能力时。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3487394957983193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0V2omHAfSdvw7SicrKSTAay2JgryiaOKw5RueDCJ0Oha9ma4KxSlpBf7z3pGeBnIvuHIqpmumicvuXfQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;714&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;微服务之间的异步通信&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这种模式通常需要引入消息代理，因此会增加额外的复杂性。然而，这样做的好处远不止于抽象。&lt;/p&gt;&lt;p&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;容易扩展。&lt;/span&gt;客户端和服务器之间直接通信的一个主要问题是，为了让客户端能够发送消息，服务器需要有空闲的处理能力，但这受到单个服务可以执行的并行处理量的限制。如果客户端需要发送更多的数据，那么服务就需要扩容并拥有更多的处理能力。这有时可以通过扩展服务部署的基础设施来解决，使用更好的处理器或更多的内存，但总会有上限。相反，我们可以继续使用较低规格的基础设施，并让多个副本并行工作。消息代理可以将接收到的消息分发到多个目标服务，可以根据需求，让副本接收相同的数据或不同的消息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;易于添加新服务。&lt;/span&gt;创建新服务、订阅希望接收的消息类型、将新服务连接到工作流，都会很简单。生产者不需要知道新服务，只需要知道需要发送什么样的消息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;简单的重试机制。&lt;/span&gt;如果消息的传递由于服务器宕机而失败，只要消息代理愿意，可以自动继续尝试，不需要编写特殊的逻辑。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事件驱动。&lt;/span&gt;异步消息可以帮助我们创建事件驱动体系架构，这是微服务交互的最有效方式之一。与其让单个服务因为等待同步响应而被阻塞，或者更糟的是，让它不断轮询某个存储介质来等待响应，还不如编写服务代码，以便在数据准备就绪时通知它们。当需要等待响应时，服务可以处理其他事情（比如处理下一个传入的请求）。这种架构可以更快的数据处理、更有效的使用资源和提供更好的整体通信体验。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;调试困难。&lt;/span&gt;&lt;span&gt;由于没有明确的数据流，只是承诺消息会被尽快处理，因此调试数据流和数据处理路径可能会成为一场噩梦。&lt;/span&gt;&lt;span&gt;这就是为什么通常需要在接收到消息时生成一个&lt;/span&gt;唯&lt;span&gt;一ID，这样就可以通过日志跟踪消息在内部系统中的路径。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;没有明确的直接响应。&lt;/span&gt;考虑到此模式的异步特性，一旦从客户端接收到请求，唯一可能的响应是“OK，收到了，一旦准备好，我会让您知道”。对于无效请求，还可以发送400错误。问题是，客户端不能直接访问服务端的执行逻辑返回的输出，而是需要单独请求。作为一种替代方法，客户端可以订阅响应消息类型。通过这种方式，一旦响应消息到达，客户端将立即得到通知。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代理成为单点故障。&lt;/span&gt;如果没有正确配置消息代理，它可能会成为架构的问题。虽然不必忍受自己编写的不稳定的服务，但却被迫维护一个几乎不知道如何使用的消息代理。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这绝对是一个有趣的模式，并且提供了很大的灵活性。如果生产者端需要产生大量消息，那么在生产者和消费者之间有一个类似缓冲区的结构将增加系统的稳定性。&lt;/p&gt;&lt;p&gt;虽然处理过程可能会很慢，但有了缓冲区后，扩展将变得容易得多。&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;Socket链接（Direct socket connection）&lt;/h3&gt;&lt;p&gt;有时候我们不必依赖古老的HTTP来发送和接收消息，而是可以采用一些完全不同的路径，使用一些更快的技术，比方说socket。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31512605042016806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0V2omHAfSdvw7SicrKSTAay2hJ2cBGjwRgMsB4guJr1aicGymNtktSv5MWpxTia7qyicTqicS8et5CohWw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;714&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为微服务通信打开socket通道&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;乍一看，基于socket的通信很像在HTTP中实现的客户端-服务器模式，然而，如果仔细看，还是有一些区别：&lt;/p&gt;&lt;p&gt;话虽如此，还是来看看这种方法的利弊：&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;没有真正的标准。&lt;/span&gt;与HTTP相比，基于socket的通信似乎有点混乱，没有任何结构化的标准（比如SOAP和REST）。因此，需要实现方来定义通信结构。反过来又使得创建和实现新客户端有点困难。但是，如果只是为了自己的服务可以相互交互，那么实际上是在实现自定义协议。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;容易使接收端过载。&lt;/span&gt;如果一个服务产生太多的消息让另一个服务无法处理，那么可能会导致第二个服务无法承受并崩溃。这就是上一个模式解决的问题。在这里，发送和接收消息之间的延迟非常小，这意味着吞吐量可以更高，但也意味着接收服务必须足够快的处理所有事情。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;轻量级。&lt;/span&gt;实现基本的socket通信只需要很少的工作和设置。当然，这取决于使用的编程语言，但其中一些，例如带有Socket.io&lt;span&gt;[4]&lt;/span&gt;的Node.js，可以通过几行代码就实现两个服务的通信。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;非常优化的通信流程。&lt;/span&gt;由于在两个服务之间有一个长时间打开的通道，因此双方都能够在消息到达时作出反应。和拉取数据库来获取新消息的方式不一样，这是一个反射性的方法（reactive approach），没有比这个更快的方式了。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;基于socket的通信是让服务彼此通信的非常有效的方式。例如，当部署为集群时，Redis使用这个方法来自动检测失败的节点，并将它们从集群中移除。由于通信速度快且成本低（意味着几乎没有额外的延迟，并且只需要很少的网络资源），才可以做到这一点。&lt;/p&gt;&lt;p&gt;如果能够控制服务之间交换的信息量，并且不介意定义自己的标准协议，那么就可以使用这种方法。&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;轻量级事件（Lightweight events）&lt;/h3&gt;&lt;p&gt;此模式混合了前两种模式。一方面，它提供了一种让多个服务通过消息总线相互通信的方式，从而允许异步通信。另一方面，由于它只通过该通道发送非常轻量级的载荷，并要求调用相应服务的REST API将额外信息与载荷结合起来。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45938375350140054&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0V2omHAfSdvw7SicrKSTAay2q7uRgsGPquYeckJPXWicL1Xq3GrJR0odQeC41cQ0agPktCCNeByrDbw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;714&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;微服务通信中的轻量级事件和API的混合作用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;当我们希望尽可能控制网络流量，或者当消息队列有包大小限制时，这种通信模式非常方便。在这种情况下，最好让事情尽可能简单，然后只在需要的时候要求额外的信息。&lt;/p&gt;&lt;p&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;两全其美。&lt;/span&gt;因为有80-90%的数据通过类似缓冲区的结构发送，因此这种方法提供了异步通信模式的优点，并且只需要通过效率较低但标准的、基于API的方法来完成一小部分网络流量。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重点优化最常见的场景。&lt;/span&gt;如果我们知道在大多数情况下不需要使用额外的信息来填充事件，那么将其保持在最低限度将有助于优化网络流量，并将消息代理的需求保持在非常低的水平。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基本的缓冲区。&lt;/span&gt;通过这种方法，每个事件的额外细节都是保密的，并且远离缓冲区。这反过来又消除了在需要为这些消息定义schema的情况下可能有的耦合。保持缓冲区的“哑（dumb）”使它更容易与其他系统交互，特别是在需要迁移或扩展的情况下（例如从RabbitMQ迁移到AWS SQS）。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可能会有太多API请求。&lt;/span&gt;如果不小心为不适合的用例实现此模式，那么最终将面临API请求的开销，而这会增加响应服务的额外延迟，更不用说服务之间发送的所有HTTP请求所增加的额外网络流量了。如果面临这样的场景，请考虑切换到完全基于异步的通信模型。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;两倍的通信接口。&lt;/span&gt;服务必须提供两种不同的通信方式。一方面，需要实现消息队列所需的异步模型，但另一方面，还必须具有类似于API的接口。考虑到两种方法使用的不同，这可能会变得难以维护。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这是一种非常有趣的混合模式，考虑到需要将两种方法混合在一起，需要花费一些精力编写代码。&lt;/p&gt;&lt;p&gt;这可以是一种非常好的网络优化技术，确保对于对应用例的载荷混合请求只发生大约10 - 20%的比例，否则带来的好处将不值得为其编写额外的代码。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;微服务之间通信的最佳方式是提供了我们想要的东西的方式，可以是性能、可靠性或者安全性，我们必须知道想要什么，然后基于这些信息来选择最佳模式。&lt;/p&gt;&lt;p&gt;没有通信模式的银弹，即使像我一样更喜欢其中一种模式，现实的说，还是必须找到适应当前用例的模式。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;References:&lt;/span&gt;&lt;br/&gt;[1] My Favorite Interservice Communication Patterns for Microservices: https://blog.bitsrc.io/my-favorite-interservice-communication-patterns-for-microservices-d746a6e1d7de&lt;br/&gt;[2] bit: https://github.com/teambit/bit&lt;br/&gt;[3] Postman: https://www.postman.com/&lt;br/&gt;[4] Socket.io: https://socket.io/&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>