<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5151016486f50b46b366b2bddb61f2e0</guid>
<title>@Value 竟然能玩出这么多花样</title>
<link>https://toutiao.io/k/1xelgdh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于从事java开发工作的小伙伴来说，spring框架肯定再熟悉不过了。spring给开发者提供了非常丰富的api，满足我们日常的工作需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要创建bean实例，可以使用@Controller、@Service、@Repository、@Component等注解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要依赖注入某个对象，可以使用@Autowired和@Resource注解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要开启事务，可以使用@Transactional注解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要动态读取配置文件中的某个系统属性，可以使用@Value注解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等等，还有很多。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面几种常用的注解，在我以往的文章《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODkzNTQ3Nw==&amp;amp;mid=2247488466&amp;amp;idx=1&amp;amp;sn=1e63e6991b5fb47e067d2edf055981d3&amp;amp;chksm=f9801508cef79c1ea208906ceef09593a9f594b3926478eb65b7ef64e0311f13ac5aaf4135ce&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;@Autowired的这些骚操作，你都知道吗？&lt;/a&gt;》《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODkzNTQ3Nw==&amp;amp;mid=2247489032&amp;amp;idx=1&amp;amp;sn=20b5be9bbc2991309d4af3cb9b4a8ae7&amp;amp;chksm=f98010d2cef799c423df29f7bcda0b619efdff626ea65d8a64e7c151557b8d4e3aa2f9265c62&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊聊spring事务失效的12种场景，太坑了&lt;/a&gt;》《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODkzNTQ3Nw==&amp;amp;mid=2247487517&amp;amp;idx=1&amp;amp;sn=f2de07ab34a554f33a57b536b8240e93&amp;amp;chksm=f98016c7cef79fd1948f886274a1af726e66f919aafb628f04b32aa64d32f1c9597cb295bd10&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;惊呆了，spring中竟然有12种定义bean的方法&lt;/a&gt;》中已经介绍过了，在这里就不过多讲解了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天咱们重点聊聊&lt;code&gt;@Value&lt;/code&gt;注解，因为它是一个非常有用，但极其容易被忽视的注解，绝大多数人可能只用过它的一部分功能，这是一件非常遗憾的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以今天有必要和大家一起，重新认识一下&lt;code&gt;@Value&lt;/code&gt;。&lt;img data-ratio=&quot;0.9086021505376344&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDGb81QziavqgchX5nNfSSh9c4U5ueiaytI5aNEZaK0OCOoFt94ghN9rhE5XW01NjS8QeWiaIEefWWJmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxODkzNTQ3Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uL371281oDHlDcdbjNJic1yCwAu2dmJ9AunIQh9DXdm5JE7v9libnPgJQicoaGs9Eiaee2kPeFGWJxsPkZ9zCQbrIw/0?wx_fmt=png&quot; data-nickname=&quot;苏三说技术&quot; data-alias=&quot;susanSayJava&quot; data-signature=&quot;作者就职于知名互联网公司，掘金月度优秀作者，从事开发、架构和部分管理工作。实战经验丰富，对jdk、spring、springboot、springcloud、mybatis等开源框架源码有一定研究，欢迎关注，和我一起交流。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 由一个例子开始&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如在UserService类中，需要注入系统属性到userName变量中。通常情况下，我们会写出如下的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.userName}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String userName;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(userName);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; userName;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;@Value&lt;/code&gt;注解指定系统属性的名称&lt;code&gt;susan.test.userName&lt;/code&gt;，该名称需要使用&lt;code&gt;${}&lt;/code&gt;包起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样spring就会自动的帮我们把对应的系统属性值，注入到userName变量中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，上面功能的重点是要在&lt;code&gt;applicationContext.properties&lt;/code&gt;文件（简称：配置文件）中配置同名的系统属性：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;#张三&lt;br/&gt;susan.test.userName=\u5f20\u4e09&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，名称真的必须完全相同吗？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 关于属性名&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，有些朋友可能会说：在&lt;code&gt;@ConfigurationProperties&lt;/code&gt;配置类中，定义的参数名可以跟配置文件中的系统属性名不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，在配置类MyConfig类中定义的参数名是userName：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span&gt;&quot;susan.test&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String userName;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而配置文件中配置的系统属性名是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;susan.test.user-name=\u5f20\u4e09&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类中用的&lt;code&gt;userName&lt;/code&gt;，而配置文件中用的&lt;code&gt;user-name&lt;/code&gt;，不一样。但测试之后，发现该功能能够正常运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置文件中的系统属性名用 &lt;code&gt;驼峰标识&lt;/code&gt; 或 &lt;code&gt;小写字母加中划线的组合&lt;/code&gt;，spring都能找到配置类中的属性名userName进行赋值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，配置文件中的系统属性名，可以跟配置类中的属性名不一样。不过，有个前提，前缀susan.test必须相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，&lt;code&gt;@Value&lt;/code&gt;注解中定义的系统属性名也可以不一样吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：不能。如果不一样，启动项目时会直接报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24835988753514526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDGb81QziavqgchX5nNfSSh9cKb5WXuTqN9dVMRwQwYFQRqoUrlFv17Ze7bnU5yvO00u1PG8lepiadqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2134&quot;/&gt;此外，如果只在@Value注解中指定了系统属性名，但实际在配置文件中没有配置它，也会报跟上面一样的错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，&lt;strong&gt;@Value注解中指定的系统属性名，必须跟配置文件中的相同。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 乱码问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道细心的小伙伴们有没有发现，我配置的属性值：&lt;code&gt;张三&lt;/code&gt;，其实是&lt;code&gt;转义&lt;/code&gt;过的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;susan.test.userName=\u5f20\u4e09&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要做这个转义？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如在配置文件中配置中文的张三：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;susan.test.userName=张三&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后获取数据时，你会发现userName竟然出现了乱码：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;å¼ ä¸&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;what？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么会出现乱码？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：在springboot的&lt;code&gt;CharacterReader&lt;/code&gt;类中，默认的编码格式是&lt;code&gt;ISO-8859-1&lt;/code&gt;，该类负责&lt;code&gt;.properties&lt;/code&gt;文件中系统属性的读取。如果系统属性包含中文字符，就会出现乱码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5565693430656934&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDGb81QziavqgchX5nNfSSh9czDAcVtgAxJjzykcOHEUbKXIsTEcHAR5CFz3xuib5XLsFZ96BxFvZ9ww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1096&quot;/&gt;那么，如何解决乱码问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前主要有如下三种方案：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;手动将ISO-8859-1格式的属性值，转换成UTF-8格式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置encoding参数，不过这个只对@PropertySource注解有用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将中文字符用unicode编码转义。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然@Value不支持encoding参数，所以方案2不行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如使用方案1，具体实现代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(value = &lt;span&gt;&quot;${susan.test.userName}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String userName;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String userName1 = &lt;span&gt;new&lt;/span&gt; String(userName.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8);&lt;br/&gt;        System.out.println();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; userName1;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确实可以解决乱码问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果项目中包含大量中文系统属性值，每次都需要加这样一段特殊转换代码。出现大量重复代码，有没有觉得有点恶心？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反转我被恶心到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决代码重复问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：将属性值的中文内容转换成unicode。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似于这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;susan.test.userName=\u5f20\u4e09&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式同样能解决乱码问题，不会出现恶心的重复代码。但需要做一点额外的转换工作，不过这个转换非常容易，因为有现成的在线转换工具。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;推荐使用这个工具转换：http://www.jsons.cn/unicode/&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里顺便告诉你一个小秘密：如果你使用的是&lt;code&gt;.yml&lt;/code&gt;或&lt;code&gt;.yaml&lt;/code&gt;格式的配置文件，并不会出现中文乱码问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这又是为什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为.yml或.yaml格式的配置文件，最终会使用&lt;code&gt;UnicodeReader&lt;/code&gt;类进行解析，它的&lt;code&gt;init&lt;/code&gt;方法中，首先读取BOM文件头信息，如果头信息中有UTF8、UTF16BE、UTF16LE，就采用对应的编码，如果没有，则采用默认&lt;code&gt;UTF8&lt;/code&gt;编码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8870481927710844&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDGb81QziavqgchX5nNfSSh9cjVbNCMSB3hEAUfTmXcnRQaM7KoofOILUD1qQwytuA2lgM5AzrWp0RQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1328&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要注意的是：乱码问题一般出现在本地环境，因为本地直接读取的.properties配置文件。在dev、test、生产等环境，如果从zookeeper、apollo、nacos等配置中心中获取系统参数值，走的是另外的逻辑，并不会出现乱码问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.默认值&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，默认值是我们非常头疼的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么这样说呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为很多时候使用java的默认值，并不能满足我们的日常工作需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有这样一个需求：如果配置了系统属性，userName就用配置的属性值。如果没有配置，则userName用默认值susan。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些朋友可能认为可以这样做：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(value = &lt;span&gt;&quot;${susan.test.userName}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; String userName = &lt;span&gt;&quot;susan&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在定义参数时直接给个默认值，但如果仔细想想这招是行不通的的。因为设置userName默认值的时机，比@Value注解依赖注入属性值要早，也就是说userName初始化好了默认值，后面还是会被覆盖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，到底该如何设置默认值呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;:&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(value = &lt;span&gt;&quot;${susan.test.userName:susan}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; String userName;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在需要设置默认值的系统属性名后，加&lt;code&gt;:&lt;/code&gt;符号。紧接着，在&lt;code&gt;:&lt;/code&gt;右边设置默认值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议大家平时在使用@Value时，尽量都设置一个默认值。如果不需要默认值，宁可设置一个空。比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(value = &lt;span&gt;&quot;${susan.test.userName:}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; String userName;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么这么说？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如有这种场景：在business层中包含了UserService类，business层被api服务和job服务都引用了。但UserService类中@Value的userName只在api服务中有用，在job服务中根本用不到该属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于job服务来说，如果不在.properties文件中配置同名的系统属性，则服务启动时就会报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个坑，我之前踩过多次。所以，建议大家，使用@Value注解时，最好给参数设置一个默认值，以防止出现类似的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. static变量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们已经见识过，如何使用@Value注解，给类的&lt;code&gt;成员变量&lt;/code&gt;注入&lt;code&gt;系统属性值&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，问题来了，&lt;code&gt;静态变量&lt;/code&gt;可以自动注入系统属性值不？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一起看看，假如将上面的userName定义成&lt;code&gt;static&lt;/code&gt;的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.userName}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String userName;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序可以正常启动，但是获取到userName的值却是null。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，被&lt;code&gt;static&lt;/code&gt;修饰的变量通过@Value会注入失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为好奇宝宝的你，此时肯定想问：如何才能给静态变量注入系统属性值呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：这就需要使用如下的骚代码了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String userName;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.userName}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setUserName&lt;/span&gt;&lt;span&gt;(String userName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        UserService.userName = userName;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; userName;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提供一个静态参数的&lt;code&gt;setter&lt;/code&gt;方法，在该方法上使用@Value注入属性值，并且同时在该方法中给静态变量赋值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些细心的朋友可能会发现，@Value注解在这里竟然使用在setUserName方法上了，也就是对应的setter方法，而不是在变量上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有趣，有趣，这种用法有点高端喔。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，通常情况下，我们一般会在pojo实体类上，使用lombok的@Data、@Setter、@Getter等注解，在编译时动态增加setter或getter方法，所以@Value用在方法上的场景其实不多。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.变量类型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的内容，都是用的字符串类型的变量进行举例的。其实，@Value注解还支持其他多种类型的系统属性值的注入。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.1 基本类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，在Java中的基本数据类型有4类8种，然我们一起回顾一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;整型：byte、short、int、long&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;浮点型：float、double&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;布尔型：boolean&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字符型：char&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对应地提供了8种包装类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;整型：Byte、Short、Integer、Long&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;浮点型：Float、Double&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;布尔型：Boolean&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字符型：Character&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@Value注解对这8中基本类型和相应的包装类，有非常良好的支持，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.a:1}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; a;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.b:100}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;short&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.c:3000}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.d:4000000}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; d;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.e:5.2}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; e;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.f:6.1}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; f;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.g:false}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; g;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.h:h}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; h;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.a:1}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; a1;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.b:100}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Short b1;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.c:3000}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Integer c1;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.d:4000000}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Long d1;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.e:5.2}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Float e1;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.f:6.1}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Double f1;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.g:false}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Boolean g1;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.h:h}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Character h1;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这些常用的数据类型，我们在定义变量类型时，可以非常愉快的玩耍了，不用做额外的转换。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.2 数组&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但只用上面的基本类型是不够的，特别是很多需要批量处理数据的场景中。这时候可以使用&lt;code&gt;数组&lt;/code&gt;，它在日常开发中使用的频率很高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在定义数组时可以这样写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.array:1,2,3,4,5}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] array;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring默认使用逗号分隔参数值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用空格分隔，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Value(&lt;span&gt;&quot;&lt;span&gt;${susan.test.array:1 2 3 4 5}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;private int[] array;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring会自动把空格去掉，导致数据中只有一个值：12345，注意千万别搞错了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便说一下，定义数组的时候，里面还是有挺多门道的。比如上面列子中，我的数据是：1,2,3,4,5。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们把数组定义成：short、int、long、char、string类型，spring是可以正常注入属性值的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果把数组定义成：float、double类型，启动项目时就会直接报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26626506024096386&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDGb81QziavqgchX5nNfSSh9cb1KzKyOiaGIcF7v4MEgncMEbqKq8q6NiaiaibWCvY8QmRzBzxH8Z2BJHPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1660&quot;/&gt;小伙伴们，下巴惊掉了没？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按理说，1,2,3,4,5用float、double是能够表示的呀，为什么会报错？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用int的包装类，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.array:1,2,3,4,5}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Integer[] array;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动项目时同样会报上面的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，定义数组时一定要注意属性值的类型，必须完全一致才可以，如果出现下面这种情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.array:1.0,abc,3,4,5}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] array;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;属性值中包含了1.0和abc，显然都无法将该字符串转换成int。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.3 集合类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了基本类型和数组，的确让我们更加方便了。但对数据的处理，只用数组这一种数据结构是远远不够的，下面给大家介绍一下其他的常用数据结构。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3.1 List&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;List是数组的变种，它的长度是可变的，而数组的长度是固定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看看List是如何注入属性值的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${susan.test.list}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt; list;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最关键的是看配置文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;susan.test.list[&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;susan.test.list[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;11&lt;/span&gt;&lt;br/&gt;susan.test.list[&lt;span&gt;2&lt;/span&gt;]=&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;susan.test.list[&lt;span&gt;3&lt;/span&gt;]=&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你满怀希望的启动项目，准备使用这个功能的时候，却发现竟然报错了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23603793466807166&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDGb81QziavqgchX5nNfSSh9chYVVzV8k3g8aPZU6EympiayynYtJlTe9cwtNn6skTb89kyM5DZMPSjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1898&quot;/&gt;what?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看来@Value不支持这种直接的List注入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人说用&lt;code&gt;@ConfigurationProperties&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要定义一个MyConfig类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span&gt;&quot;susan.test&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt; list;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在调用的地方这样写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; MyConfig myConfig;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(myConfig.getList());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方法确实能够完成List注入。但是，只能说明@ConfigurationProperties注解的强大，跟@Value有半毛钱的关系？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：没有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，问题来了，用@Value如何实现这个功能呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用spring的EL表达式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;List的定义改成：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{&#x27;${susan.test.list}&#x27;.split(&#x27;,&#x27;)}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt; list;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;#&lt;/code&gt;号加大括号的EL表达式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后配置文件改成：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;susan.test.list=&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟定义数组时的配置文件一样。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3.2 Set&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Set也是一种保存数据的集合，它比较特殊，里面保存的数据不会重复。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以这样定义Set：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{&#x27;${susan.test.set}&#x27;.split(&#x27;,&#x27;)}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Set&amp;lt;String&amp;gt; set;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置文件是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;susan.test.set=&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Set跟List的用法极为相似。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但为了证明本节的独特之处，我打算说点新鲜的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何给List或者Set设置默认值空呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些朋友可能会说：这还不简单，直接在@Value的$表达式后面加个:号不就行了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{&#x27;${susan.test.set:}&#x27;.split(&#x27;,&#x27;)}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Set&amp;lt;String&amp;gt; set;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果却跟想象中不太一样：&lt;img data-ratio=&quot;0.9277899343544858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDGb81QziavqgchX5nNfSSh9cKyFr1738aKYIibecxqFtf0ZekIibiaE0SnrdFqWHl0HZ9MomPCEcDvRug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;914&quot;/&gt;Set集合怎么不是空的，而是包含了一个空字符串的集合？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好吧，那我在:号后加null，总可以了吧？&lt;img data-ratio=&quot;0.8638297872340426&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDGb81QziavqgchX5nNfSSh9cH8tFn6YRMlODIHHxeLor1F5magogicDX92wNegx55ibwttna9KrmO1iag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;Set集合也不是空的，而是包含了一个&quot;null&quot;字符串的集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也不行，那也不行，该如何是好？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用EL表达式的&lt;code&gt;empty&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{&#x27;${susan.test.set:}&#x27;.empty ? null : &#x27;${susan.test.set:}&#x27;.split(&#x27;,&#x27;)}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Set&amp;lt;String&amp;gt; set;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行之后，结果对了：&lt;img data-ratio=&quot;0.6109422492401215&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDGb81QziavqgchX5nNfSSh9coBjufBbCgRGuJqWn3EmEiawCkkepB78eGSy17BLElSwZIjsLOp1c2uQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1316&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实List也有类似的问题，也能使用该方法解决问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在这里温馨的提醒一下，该判断的表达式比较复杂，自己手写非常容易写错，建议复制粘贴之后根据实际需求改改。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3.3 Map&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种比较常用的集合是map，它支持key/value键值对的形式保存数据，并且不会出现相同key的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以这样定义Map：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{${susan.test.map}}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt; map;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置文件是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;susan.test.map={&lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;苏三&quot;&lt;/span&gt;, &lt;span&gt;&quot;age&quot;&lt;/span&gt;:&lt;span&gt;&quot;18&quot;&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种用法跟上面稍微有一点区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置默认值的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{&#x27;${susan.test.map:}&#x27;.empty ? null : &#x27;${susan.test.map:}&#x27;}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt; map;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7 EL高端玩法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们已经见识过spring EL表达式的用法了，在设置空的默认值时特别有用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，&lt;code&gt;empty&lt;/code&gt;方法只是它很普通的用法，还有更高端的用法，不信我们一起看看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.1 注入bean&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前我们注入bean，一般都是用的@Autowired或者@Resource注解。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getRoleName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;管理员&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(roleService.getRoleName());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我要告诉你的是@Value注解也可以注入bean，它是这么做的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{roleService}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这种方式，可以注入id为roleService的bean。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.2 bean的变量和方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过EL表达式，@Value注解已经可以注入bean了。既然能够拿到bean实例，接下来，可以再进一步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在RoleService类中定义了：成员变量、常量、方法、静态方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_AGE = &lt;span&gt;18&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id = &lt;span&gt;1000&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getRoleName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;管理员&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getParentId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;2000&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在调用的地方这样写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{roleService.DEFAULT_AGE}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; myAge;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{roleService.id}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{roleService.getRoleName()}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String myRoleName;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{roleService.getParentId()}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String myParentId;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(myAge);&lt;br/&gt;        System.out.println(id);&lt;br/&gt;        System.out.println(myRoleName);&lt;br/&gt;        System.out.println(myParentId);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在UserService类中通过@Value可以注入：成员变量、常量、方法、静态方法获取到的值，到相应的成员变量中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一下子有没有豁然开朗的感觉，有了这些，我们可以通过@Value注解，实现更多的功能了，不仅仅限于注入系统属性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.3 静态类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的内容都是基于bean的，但有时我们需要调用静态类，比如：Math、xxxUtil等静态工具类的方法，该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：用T加括号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{T(java.io.File).separator}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; String path;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以注入系统的路径分隔符到path中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例2：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{T(java.lang.Math).random()}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; randomValue;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以注入一个随机数到randomValue中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.4 逻辑运算&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面介绍的内容，我们可以获取到绝大多数类的变量和方法的值了。但有了这些值，还不够，我们能不能在EL表达式中加点逻辑？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拼接字符串：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{roleService.roleName + &#x27;&#x27; + roleService.DEFAULT_AGE}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; String value;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;逻辑判断：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{roleService.DEFAULT_AGE &amp;gt; 16 and roleService.roleName.equals(&#x27;苏三&#x27;)}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; String operation;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三目运算：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{roleService.DEFAULT_AGE &amp;gt; 16 ? roleService.roleName: &#x27;苏三&#x27; }&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; String realRoleName;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有很多很多功能，我就不一一列举了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;EL表达式实在太强大了，对这方面如果感兴趣的小伙伴可以找我私聊。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8 ${}和#{}的区别&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面巴拉巴拉说了这么多@Value的牛逼用法，归根揭底就是&lt;code&gt;${}&lt;/code&gt;和&lt;code&gt;#{}&lt;/code&gt;的用法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面重点说说${}和#{}的区别，这可能是很多小伙伴比较关心的话题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;8.1 ${}&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要用于获取配置文件中的系统属性值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(value = &lt;span&gt;&quot;${susan.test.userName:susan}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; String userName;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;:&lt;/code&gt;可以设置默认值。如果在配置文件中找不到susan.test.userName的配置，则注入时用默认值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在配置文件中找不到susan.test.userName的配置，也没有设置默认值，则启动项目时会报错。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;8.2 #{}&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要用于通过spring的EL表达式，获取bean的属性，或者调用bean的某个方法。还有调用类的静态常量和静态方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{roleService.DEFAULT_AGE}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; myAge;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{roleService.id}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{roleService.getRoleName()}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; String myRoleName;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;#{T(java.lang.Math).random()}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; randomValue;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是调用类的静态方法，则需要加T(包名 + 方法名称)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：T(java.lang.Math)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，今天的内容就介绍到这里，希望对你会有所帮助。随便剧透一下，后面的文章会继续介绍：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;@Value的原理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Value动态刷新属性值的原因&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@ConfigurationProperties注解的用法，它也非常强大。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好不好奇？赶紧关注一波呀。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1b9e3faf0ace23e39114e0fd258c7ce1</guid>
<title>Golang Context 这三个应用场景，你知吗</title>
<link>https://toutiao.io/k/fej10u7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4311797752808989&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHPkqJklltMPpJmMPEwxR6T0Nm1zw9ibBKVbum6jHudbgH5AVRaBLz7iaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1424&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-dynamic-material=&quot;t&quot; data-mpa-template=&quot;t&quot; data-mpa-dynamic-material-category=&quot;envelope&quot; data-mpa-category=&quot;动态&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-click-envelope-show-text-id=&quot;envelopePreviewContent&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;用户发送 开始消费 请求时：开启多个协程开始消费消息队列某个topic的信息；&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;用户发送 结束消费 请求时：把消费中的topic相关的协程关闭掉，结束消费；&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;svg mpa-from-tpl=&quot;t&quot; opacity=&quot;1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;set attributename=&quot;visibility&quot; from=&quot;visible&quot; to=&quot;hidden&quot; begin=&quot;click+1s&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;animate attributename=&quot;opacity&quot; fill=&quot;freeze&quot; dur=&quot;1s&quot; begin=&quot;click&quot; from=&quot;1&quot; to=&quot;0&quot; restart=&quot;never&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/svg&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4707865168539326&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHWaqBVz3tjicrVa2BNXqjesO0qQHf3pCxrgB50LKjV2GCKraiaUd565yA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1780&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4240422721268164&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHjh35bQ7aF27TbErqQA23ONEicakhBpEYwEgL2FEFHTUP3YR8Mib38ZIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1514&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3895538628944505&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHnfJEjPMNbg4Hic7S6IFC9icnNTyc6MhiaGuBDQR438oym08Qic6iavKur9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1838&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4697173620457604&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHH23DFRa2A3QZAicrWz7M1laYxfWrxJCTtdgEJLCPbXjBa4fdf8o3I63g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1486&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3727175080558539&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHH3yVzhraze2tv7O8rvMzvoEdSXCwBjlCicX9RhhmbvLzKaz1tuKYHejg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1862&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49539170506912444&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHCeqoJndDQicv1Fypicf2T4gBx3qTEQjEEicwOFk0iaYgm50Tz0YBnFGCtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1736&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;跨服务传递信息&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.0740740740740742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/65kKfpfiaHYJb5Dich6GdMtnZre8jhjTibGVwwOgApImzZWplXUib7CrRLG0ZlcicwWM9spLF5qwfdicWeLtwabw5VWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;54&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在具备一定规模的互联网公司都用微服务形式让各系统组合起来为用户提供服务，一个简单的业务在流程上可能需要十几个甚至几十个系统间互相调用。由于每个系统内部的正确性无法保证，若出现了case，比如用户反馈积分少发了，就需要排查这十几个系统的日志信息，看问题出在哪里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此处需要一个ID凭证，ID是请求级别的，在各个系统中记录着与此请求相关的日志信息，我们把它叫做trace ID。把日志采集并落盘到ES这样的存储中，有case时只需要拿到请求的trace ID就可以把全流程的关键信息还原出来。如图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3906926406926407&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHpJq6JytUxPZlibsf8UjiaXrHfQfyNyVHd3OoufN9xfNfTiaQO0vov7u8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1848&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Golang web服务中，每个请求都是开一个协程去处理的。系统间传递信息时，若通信协议用HTTP，那trace ID等信息可放在HTTP Header中，在web框架的middle层把这些信息存入Context。demo如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 检测上游服务是否传递traceID信息，若传递了直接使用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; v, ok := req.Header[&lt;span&gt;&quot;my-awesome-trace-ID&quot;&lt;/span&gt;]; ok {&lt;br/&gt;   traceID = v[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 若没传则用公共库生成一个全局唯一的traceID信息&lt;/span&gt;&lt;br/&gt;  traceID = GenTraceID()&lt;br/&gt;  req.Header[&lt;span&gt;&quot;my-awesome-trace-ID&quot;&lt;/span&gt;] = []&lt;span&gt;string&lt;/span&gt;{traceID}&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 处理完各种请求上下文信息后，把这些信息统一存储到ctx中，传递给业务层的对应Handler&lt;/span&gt;&lt;br/&gt;ctx = context.WithValue(ctx, ContentKey, record)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Context处理请求上下文这块主要用到了&lt;code&gt;WithValue&lt;/code&gt;，这个函数接收一个ctx和一对k-v。把k-v对存起来后返回一个子ctx，这次我们先简单介绍其使用场景，下篇文章会从源码层面理解这个函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ctx的生命周期是 伴随请求开始而诞生、请求结束而终止的。在请求中ctx会跨越多个函数多个协程，在打日志时，第一个参数预留给ctx是因为日志库需要从Context中抽取trace ID等信息，从而记录下完整的日志。获取信息时只需要调用context的Value方法，demo如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 从Context中获取traceID, 打到日志里&lt;/span&gt;&lt;br/&gt;v := ctx.Value(&lt;span&gt;&quot;my-awesome-trace-ID&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里画个图帮助理解：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.43552036199095023&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHEnFichB7RxwYkETiaHRdWy88HkUw8klFdSFic02Tm5UQ4brFBemvCjYzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1768&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若我们的系统也需要请求第三方服务，同样应把trace ID等信息放入HTTP Header后发送请求，其他服务按照同样的流程接收到trace ID后开始内部逻辑处理。这样一个请求在多个系统中就通过trace ID串联起了整个流程。除trace ID外，Context还可以传递 URL Path、请求时间、Caller等信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.42328042328042326&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHpXHrMeDIhrT7z1gIn3xoJPtmdaguoOXhHYv8OewSMWeMjrVcgDO5Hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1890&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.30777903043968435&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHGhmkOujuicvfxKqvXtht4pVBvSAhJPg6tW0P9z0wqNIaXPvMTsArBVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1774&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4363395225464191&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHjkeiagIjB95m10DnHYulh8YibD4QWic5ls1zniaqEEfX85hstAgibrBNIcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1508&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.39473684210526316&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHGLlQAeBuxls5VI3oURVkTYNWqictPrzsIK8aapxOGia2R698tsE3ibOHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1444&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多协程消费demo：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 此协程负责监听错误信息，开启消费&lt;/span&gt;&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// code&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 此协程负责监听re-balance信息，开启消费&lt;/span&gt;&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// code&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }()&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4838709677419355&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHlIt3T8ibKuibNNptm5zkfVn0eBufC7KoiaY2h9Y668QREVJPnvaI1Zyyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1612&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ctx, cancel := context.WithCancel(context.Background())&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 此协程负责监听错误信息，开启消费&lt;/span&gt;&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;退出监听错误协程&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;逻辑处理中...&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 此协程负责监听re-balance信息，开启消费&lt;/span&gt;&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;退出监听re-balance协程&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;逻辑处理中...&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 调用cancelFunc, 结束消费&lt;/span&gt;&lt;br/&gt; cancel()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.6842105263157895&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DicaSkNicmQsrib4XcyjpcIKAyg82NvjCzUjwaxrzV4avLjslQjgTQcG96mOIpkB3y4bWnc4eQqYvOXxtb68ksVag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;76&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;控制协程关闭&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面代码用到了&lt;code&gt;WithCancel&lt;/code&gt;方法，调用它会返回一个可被取消的ctx和CancelFunc，需要取消ctx时，调用cancel函数即可。context有个Done方法，这个方法返回一个channel，当Context被取消时，这个channel会被关闭。消费中的协程通过select监听这个channel，收到关闭信号后一个return就能结束消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;CancelFunc&lt;/code&gt;可以预防系统做不必要的工作&lt;/strong&gt;。比如用户请求A接口时，A接口内部需要请求A database、B cache 、C System获取各种数据，把这些数据经过计算后组装到一起返回给调用方。这是正常情况的时序图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9095541401273886&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHG7p7ttMxmUO6nqy3L0LB8VzSMSuZgvTsAicCNKvqS2xEvgw6xiaRm3fQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1570&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果用户在访问网站时觉得没意思，去其他网站了。此时若你的服务收到用户请求后继续去访问其他C system、B database就是浪费资源。比较符合直觉的做法是：当业务请求取消时，你的系统也应该停止请求下游系统。前面我们介绍过context在系统中贯穿请求周期，那么当用户取消访问时，只要context监听取消事件并在用户取消时发送取消事件，就可以取消请求了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9263456090651558&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHC0OpCcL5LaY5ThzV0MqA9oVxEfprnERajeIGic9Z0rCdm6XR7EhqavQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1412&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有份demo代码，项目启动后，可以用&lt;code&gt;curl localhost:8888&lt;/code&gt;访问这个接口，若1s内取消请求，服务端会打印出&lt;code&gt;request canceleld&lt;/code&gt;，正常情况下，服务会返回&lt;code&gt;process finished&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; http.ListenAndServe(&lt;span&gt;&quot;:8888&quot;&lt;/span&gt;, http.HandlerFunc(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  ctx := r.Context()&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;get request&quot;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &amp;lt;-time.After(&lt;span&gt;1&lt;/span&gt; * time.Second):&lt;br/&gt;   w.Write([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;process finished&quot;&lt;/span&gt;))&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;request canceleld&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt; }))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了用户中途取消请求的情况，还有一种情况也可以用到cancelFunc：服务A的返回数据依赖服务B和服务C的相关接口，若服务B或者服务C挂了，此次请求就算失败了，没必要再访问另一个服务，此时也可以用&lt;code&gt;CancelFunc&lt;/code&gt;。Demo如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;getUserInfoBySystemA&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; time.Sleep(&lt;span&gt;100&lt;/span&gt; * time.Millisecond)&lt;br/&gt; &lt;span&gt;// 模拟请求出错的情况&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; errors.New(&lt;span&gt;&quot;failed&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;getOrderInfoBySystemB&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-time.After(&lt;span&gt;500&lt;/span&gt; * time.Millisecond):&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;process finished&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;process cancelled&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ctx, cancel := context.WithCancel(context.Background())&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//并发从两个服务中获取相关数据&lt;/span&gt;&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  err := getUserInfoBySystemA(ctx)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// 发生错误，调用cancelFunc&lt;/span&gt;&lt;br/&gt;   cancel()&lt;br/&gt;  }&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt; getOrderInfoBySystemB(ctx)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40224159402241594&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHtdhf9svksbicWXPycNams9ETpcZGXESyiaeptHfZkVkib2doo1iabyrwxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1606&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3991537376586742&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHBrTg9q80IsyMPicQicRsYQVCqawYXU36rCFY3iaYktFB6MXwcE8MojjRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1418&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.45229681978798586&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHK9NNYLiaQPbTpEl2hRl1xoqBibfBDzqpzq31iawDdyueWgcUHaz07bvEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1698&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.47470817120622566&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHvic5ibTEF0rXvnwDtDpxo1o4a6DS4rAmESEiadrYblD5eUSshckyaKY9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1542&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.6296296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wibLMEtPxf6EkD9f6Evlem2Z3Kwx8Wsf3ibbJxgNhMufMWibuhVC8fraoR28ibQBwCWXQhOkZMM2ezUHCoHQLjxNYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;54&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;控制超时取消&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的服务对外承诺的SLA是100ms，但系统依赖的服务B的HTTP接口有点不稳定，有时50ms就能返回结果，有时100ms才能返回结果，为了保证你服务的SLA，可以用Context的&lt;code&gt;WithTimeout&lt;/code&gt;方法设置一个超时时间，demo如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 设置超时时间100ms&lt;/span&gt;&lt;br/&gt; ctx, _ := context.WithTimeout(context.Background(), &lt;span&gt;100&lt;/span&gt;*time.Millisecond)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 构建一个HTTP请求&lt;/span&gt;&lt;br/&gt; req, _ := http.NewRequest(http.MethodGet, &lt;span&gt;&quot;https://www.baidu.com/&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;// 把ctx信息传进去&lt;/span&gt;&lt;br/&gt; req = req.WithContext(ctx)&lt;br/&gt;&lt;br/&gt; client := &amp;amp;http.Client{}&lt;br/&gt; &lt;span&gt;// 向百度发送请求&lt;/span&gt;&lt;br/&gt; res, err := client.Do(req)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;Request failed:&quot;&lt;/span&gt;, err)&lt;br/&gt;  return }&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;Response received, status code:&quot;&lt;/span&gt;, res.StatusCode)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下，会得到这样的输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Response received, status code: 200&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们请求百度超时了，会得到这样的输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Request failed: Get https://www.baidu.com/: context deadline exceeded&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.37142857142857144&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHqrZ5seWxTzmfrrNwWPg6KhAVIgIrTOyyF48VX8eZcvz2Niam9pfDTjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1890&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4818713450292398&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9Kb1sYaOnX3ia9FHohDZ7wHHq63Lf8HyMastUYAmyO2MMiccg8BBzsdCIevUU0zVdNGK4hmDSrWibWSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，给自己打个广告&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎加入 &lt;strong&gt;随波逐流的薯条&lt;/strong&gt; 微信群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;薯条目前有草帽群、木叶群、琦玉群，群交流内容不限于技术、投资、趣闻分享等话题。欢迎感兴趣的同学入群交流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入群请加薯条的个人微信：709834997。并备注：加入薯条微信群。&lt;/p&gt;&lt;p&gt;欢迎关注我的公众号~&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIxODcxMTIzNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9J9Zggib9T7Iibq78c1TUWq8JjURtqFSKYxps1Qur347zl04U3ERmjBgv9B7MUC4fzNyjorW2y0SsvA/0?wx_fmt=png&quot; data-nickname=&quot;薯条的编程修养&quot; data-alias=&quot;yigfuutc&quot; data-signature=&quot;互联网公司一线开发，日常扯扯淡，分享 Golang、数据库、经验总结、系统设计等方面的技术文章&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>917627a7448b3c67f1451ac9e0a54513</guid>
<title>全链路压测（二）：方案调研和项目立项</title>
<link>https://toutiao.io/k/cnf8e8a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;全链路压测从零开始系列的第一篇文章介绍了全链路压测的背景、定义、和传统压测的差异以及如何解决差异带来的不稳定性，落地要面临的挑战和完整的压测实践流程以及长期的能力建设演变，算是对全链路压测有了一个比较系统和全面的介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本篇是系列的第二篇，从这篇文章开始，我会基于自己的个人落地实践经验，给大家分享从零开始落地全链路压测，要做哪些事情，以及这个过程中遇到的挑战、踩过的坑以及该如何解决这些问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;申报立项&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;一般来说，像生产全链路压测这种复杂的需要多个技术团队参与的复杂技术项目，在企业内部都会有一个项目申报和评估立项的过程。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;项目申报&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;下面是一个项目申报的模板，大家可以参考下：&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;为什么要做这件事？（线上故障频发，性能问题凸显，云资源成本太高）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;为了解决什么问题？（降低线上故障率和损失，降低硬件成本）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;具体的解决方案是什么？（生产环境全链路压测）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;价值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;做这件事带来的价值是什么？（提高用户体验，团队练兵，保障业务价值的实现）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;资源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;做这件事需要什么资源？（研发、运维、DBA、测试等）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;时间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;什么时候开始，什么时候上线？&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;评估立项&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;项目申报后，就是多方评估是否立项的环节，在这个环节，主要有如下几件事：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;目前存在的问题是否真的有这么严重？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这些问题如果不解决是否会对业务造成影响？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;做这件事，能否解决目前存在的问题？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;做这件事，要投入的时间资源和对业务及团队的价值，有多大？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;5&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这件事的优先级有多高？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;调研评估&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在项目正式启动前会有个调研环节。这里的调研主要指的是基于自身当前所处阶段及面临的问题和实现生产全链路压测之间的差异，以及如何解决差异的解决方案。我个人总结下来，方案调研可以分为如下四个阶段：&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;看：大厂都是怎么做的？&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;全链路压测是个技术复杂度比较高的跨团队的技术项目，最初是大厂的自留地。在调研方案时候，有必要看看大厂都是如何做的，避免走太多弯路。前面提到了落地生产全链路压测的几个挑战，下面我从这几个挑战点来做个梳理对比，帮大家快速的了解，大厂是如何做的。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;挑战点/大厂&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;阿里&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;美团&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;京东&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;滴滴&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;饿了么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;核心链路梳理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;鹰眼系统&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;Mtrace系统&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;trace系统&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据安全隔离&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;流量/线程染色透传&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;影子库表&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;流量/线程染色透传&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;影子库表&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;流量/线程染色透传&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;影子库表+特殊标记&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;流量/线程染色透传&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;影子库表&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;流量/线程染色透传&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;特殊标记(逻辑隔离)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;避免业务侵入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;性能定位分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;服务安全保护&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;/&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;PS&lt;/strong&gt;：针对上表的一些术语和“/”内容，这里做个说明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、链路梳理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在大多数企业都是采用微服务架构来设计系统，且业务场景多样化，导致了系统架构异常复杂。要覆盖所有压测范围内的场景，就需要对涉及的所有应用及其调用关系进行梳理，手工来梳理，耗时且费力。上面提到的几家大厂的鹰眼啊Mtrace系统之类的，实际上都是基于分布式链路追踪工具自研或二次开发的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式链路追踪工具，推荐开源的Jaeger，Jaeger是Uber推出的一款开源分布式追踪系统，兼容OpenTracing API。分布式追踪系统用于记录请求范围内的信息，例如，一次远程方法调用的执行过程和耗时。是&lt;strong&gt;排查系统问题和系统性能的利器，同时在链路梳理方面，能提高很多效率&lt;/strong&gt;。Jaeger的UI相较于Zipkin更加直观和丰富，还有则是sdk比较丰富，go语言编写，上传采用的是udp传输，效率高速度快。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6965098634294385&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ftksfIbzTWjiaymbZOKZUvvdXpyjk85YWtzT0VibPGMKq4Aq8oFNXarj5geTMN1clcEJIiay6JzdcdvBfnOYsAsrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1318&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、数据隔离&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;流量染色&lt;/span&gt;&lt;/strong&gt;：&lt;span&gt;对于单服务来说，识别压测流量只要在请求头中加特殊压测标识即可，HTTP和RPC服务是一样的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线程染色&lt;/span&gt;&lt;/strong&gt;：对于多线程调用服务来说，要保证测试标识在跨线程的情况下不丢失。以 Java 应用为例，主线程根据压测请求，将测试标识写入当前线程的 ThreadLocal 对象中（ThreadLocal 会为每个线程创建一个副本，用来保存线程自身的副本变量），利用 InheritableThreadLocal 的特性，对于父线程 ThreadLocal 中的变量会传递给子线程，保证了压测标识的传递。而对于采用线程池的情况，同样对线程池进行了封装，在往线程池中添加线程任务时，额外保存了 ThreadLocal 中的变量，执行任务时再进行替换 ThreadLocal 中的变量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.69377990430622&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ftksfIbzTWjiaymbZOKZUvvdXpyjk85YWHb9ibRKNLKdAwHkrLPb595AaRdzs8yluWuj44UkIQkWggiaZXM9w4Xicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;418&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、避免业务侵入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果要通过修改业务应用或者采用数据库表数据标记的方式来实现，势必会对生产业务造成一定影响（要改造需要大量资源和时间）。&lt;span&gt;对于跨服务的调用，一般都是对所有涉及到的中间件进行了改造。利用trace系统的服务间传递上下文特性，在原有传输上下文的基础上，添加测试标识的属性，以保证传输中始终带着测试标识。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;拿java举例，可以通过字节码增强，在无业务侵入情况下，实现压测流量的识别透传。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、性能定位分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全链路压测的初衷还是为了发现并解决系统在峰值流量冲击下的稳定性问题，因此性能定位分析的工具和完善的监控体系是必备的。&lt;span&gt;一般在企业级技术监控领域，大体分为五种类型的监控：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;基础监控&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：包括带宽、CDN、CPU、Memory、DiskIO、Network、Load5等指标；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;指标监控&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：服务接口维度，QPS、TPS、SLB、RT、99RT、timeout、activethreads等；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;业务监控&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：拿电商来说，有同比下单量、支付量、履约率、DAU、GMV等多重指标；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;链路追踪&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：如上面提到的Jaeger，是&lt;/span&gt;排查系统问题和系统性能的利器，同时在链路梳理方面，能提高很多效率&lt;span&gt;；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;舆情监控&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要指对外部的一些讯息的监控，比如某APP突然挂了、下不了单、有BUG可以刷单、客诉等一些列对企业或者品牌不利的因素，便于快速处理甚至公关；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、服务安全保护&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全链路压测是在生产环境进行，压测过程中，要考虑不对生产服务造成影响。因此需要一套完整的机制来保证，压测在正常实施的同时，不对生产服务应用造成影响。一般都会通过&lt;strong&gt;&lt;span&gt;熔断和流量干预的机制&lt;/span&gt;&lt;/strong&gt;来保证。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据业务自定义的熔断阙值，监控系统实时分析监控数据，当达到熔断阙值时，任务调度器会向压测引擎发送降低 QPS 或者直接中断压测的指令，防止系统被压挂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;听：SaaS服务商怎么说？&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;国内全链路压测的SaaS服务商，目前只有2家：数列科技和perfma。这里以我比较熟悉的数列的SaaS产品举例子，他们的全链路压测产品主要优势有如下几点：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;业务代码0侵入&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在接入、采集和实现逻辑控制时，不需要修改任何业务代码；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;链路自动梳理&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;仅需部署客户端，无需对应用进行任何改造，就可以看到所有的服务调用关系，快速理解系统架构，并且通过链路架构图可以详细了解链路经过的应用、缓存、中间件、DB，甚至第三方的API，每条链路的所有走向都一目了然；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据安全隔离&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在不污染生产环境业务数据情况下进行全链路压测，可以对写类型接口进行直接的性能测试；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;安全性能压测&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在生产环境进行性能压测，对业务不会造成影响；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;5&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;性能瓶颈快速定位&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：性能测试结果直接展现业务链路中性能瓶颈的节点；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.566468253968254&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ftksfIbzTWjiaymbZOKZUvvdXpyjk85YWiam4icAZ3hNENniaW2WAUP36wUK6AoxRHMPWtjnq5QiaeJWPAUibia94DlHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而且今年他们已经将自己的全链路压测产品开源了，并且支持多环境压测，下面是他们的压测多环境支持流程图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4187568157033806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ftksfIbzTWjiaymbZOKZUvvdXpyjk85YWRPUmwlgydWibiaY5tuEicIibJIvXeOyVCSpsqj35moFWnP1rI9eCOF1GVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;917&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Github地址：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;https://github.com/shulieTech/Takin&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;做：小范围接入改造看效果&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;看完大厂是怎么做的，以及SaaS服务商的产品，接下来就是要进行小范围验证了。一般进行小范围接入改造，主要有如下几点需要注意：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;环境&lt;/span&gt;&lt;/strong&gt;：如果有多套测试环境，可以选择一套使用率较低的，否则建议临时单独搭建一套缩容的环境进行改造接入以及测试验证；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;业务&lt;/span&gt;&lt;/strong&gt;：前期在调研验证阶段，建议选择核心业务对应的应用服务来进行验证，这样更方面了解具体的效果是否达到预期（当然，在落地阶段，刚开始建议选择非核心业务）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;资源&lt;/span&gt;&lt;/strong&gt;：这里主要指人力资源，在项目立项后，建议有专门的人手资源来做这件事，否则项目很容易延期甚至无疾而终，在工作产出考核上，也不太好；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;评：自研或SaaS产品的ROI&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;经过上述三个阶段的调研和验证，这里需要对项目最终的整套解决方案做一个选型确定：是选择自研还是SaaS服务商的全链路压测产品。从我个人的落地实践经验和了解来说，无论是自研，还是选择SaaS服务商，需要考量的因素主要有如下几点：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;研发能力&lt;/span&gt;&lt;/strong&gt;：一般来说，大厂或者中大型独角兽公司，研发能力和资源相对会比较强，且出于造轮子和KPI的目的，选择自研是相对来说比较好的方案。当然对于中小型企业来说，研发能力和资源会弱一些，这种情况我建议还是选择三方服务商的SaaS服务或者开源产品，性价比会更高一些；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;业务接受能力&lt;/span&gt;&lt;/strong&gt;：如果是自研，特别是选择改造业务代码的方案时，一定要考虑到业务的接受能力。因为每次变更都会对线上带来新的不稳定因素，且改造占用的时间和资源会和业务需求迭代有所冲突。如果是中间件层面改造或者采用的是无侵入的SaaS产品及开源产品，那么相对来说这个矛盾就仅限于技术团队内部；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;项目预算投入&lt;/span&gt;&lt;/strong&gt;：这里的预算包括时间、风险、需要投入的人力物力等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;ROI(投入产出比)&lt;/span&gt;&lt;/strong&gt;：实际上一个项目到了最后，要不要做的最终考虑因素就是投入产出比，以更低的风险和成本解决更大范围的严重问题，永远是优先级最高的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;本篇主要对全链路压测的项目立项和调研环节要考量的点以及业内的一些方案&amp;amp;SaaS及开源产品做了介绍，下一篇开始，会介绍落地实践过程中具体要做的一些事情，包括工具选型、流量评估等，会结合具体的业务场景来为大家分享如何从零开始的落地全链路压测。建个一个学习群，关注回复全链路压测进群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NDAwMjM1NQ==&amp;amp;mid=2247483966&amp;amp;idx=1&amp;amp;sn=48b4cb850c14599505897e2e600bd841&amp;amp;chksm=ce714a62f906c37454a2e388b29dd7f44440a2680653ca02dfeb6c2bb8fc201461bc8e173dcb&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;生产全链路压测实践之道&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NDAwMjM1NQ==&amp;amp;mid=2247484133&amp;amp;idx=1&amp;amp;sn=c706d08f7935a81be90ca07d467d034b&amp;amp;chksm=ce714ab9f906c3af35b36a9e706562c644cf71c29228dc053f75061096cbab77ba748a38ea73&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;全链路压测落地和演进之路&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NDAwMjM1NQ==&amp;amp;mid=2247484504&amp;amp;idx=1&amp;amp;sn=56a21aa7dc5aad958dbe6f759946d0a0&amp;amp;chksm=ce714c04f906c512c8b080de09e6acfd4f82c2782823f5ed442e2cae2247c4da637bb50886d6&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;全链路压测(1)：认识全链路压测&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NDAwMjM1NQ==&amp;amp;mid=2247484459&amp;amp;idx=1&amp;amp;sn=561b3ea760bf41675d66c361dbe9ff6c&amp;amp;chksm=ce714c77f906c561fde4663cf994ab766b06cef94192db024e5a04f23f805b75a3c1e3b18ab2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;聊聊传统压测和全链路压测的区别&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>00d2c944af282b4dd3accc655ab53dda</guid>
<title>计算机架构的机器学习</title>
<link>https://toutiao.io/k/zsus9yc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;最近机器学习 (ML) 进步的关键贡献者之一是定制加速器的开发，例如Google TPU和Edge TPU，它们显着提高了可用计算能力，从而解锁了各种功能，例如AlphaGo、RankBrain、WaveNets和对话代理。这种增加可以提高神经网络训练和推理的性能，为视觉、语言、理解和自动驾驶汽车等广泛的应用提供新的可能性。&lt;/p&gt;&lt;p&gt;为了保持这些进步，硬件加速器生态系统必须继续在架构设计方面进行创新，并适应快速发展的 ML 模型和应用程序。这需要对许多不同的加速器设计点进行评估，每个点不仅可以提高计算能力，还可以揭示新的能力。这些设计点通常由各种硬件和软件因素（例如，内存容量、不同级别的计算单元数量、并行性、互连网络、流水线、软件映射等）参数化。这是一项艰巨的优化任务，因为搜索空间呈指数级大1 而目标函数（例如，更低的延迟和/或更高的能源效率）通过模拟或综合进行评估在计算上是昂贵的，这使得确定可行的加速器配置具有挑战性。&lt;/p&gt;&lt;p&gt;在“ Apollo: Transferable Architecture Exploration ”中，我们介绍了我们在定制加速器的 ML 驱动设计方面的研究进展。虽然最近的 工作已经证明了利用 ML 来改进低级布局规划过程（其中硬件组件在空间上布局并在硅中连接）方面的有希望的结果，但在这项工作中，我们专注于将 ML 混合到高级系统规范和架构设计阶段，这是影响芯片整体性能的关键因素，其中建立了控制高级功能的设计元素。我们的研究展示了 ML 算法如何促进架构探索并建议跨一系列深度神经网络的高性能架构，其领域涵盖图像分类、对象检测、OCR和语义分割。&lt;/p&gt;&lt;h2&gt;&lt;em&gt;架构搜索空间和工作负载&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;架构探索的目标是为一组工作负载发现一组可行的加速器参数，以便在一组可选的用户定义下最小化所需的目标函数（例如，运行时的加权平均值）约束。然而，体系结构搜索的流形通常包含许多点，从软件到硬件没有可行的映射。其中一些设计点是先验已知的，可以通过用户将它们制定为优化约束来绕过（例如，在面积预算2约束，总内存大小不得超过预定义的限制）。然而，由于体系结构和编译器的相互作用以及搜索空间的复杂性，一些约束可能无法正确地表述到优化中，因此编译器可能无法为目标硬件找到可行的软件映射。这些不可行点在优化问题中不容易表述，并且在整个编译器通过之前通常是未知的。因此，架构探索的主要挑战之一是有效地避开不可行的点，以最少数量的周期精确架构模拟来有效探索搜索空间。&lt;/p&gt;&lt;p&gt;下图显示了目标 ML 加速器的整体架构搜索空间。加速器包含处理元件 (PE) 的二维阵列，每个处理元件以单指令多数据(SIMD) 方式执行一组算术计算。每个 PE 的主要架构组件是处理核心，包括用于 SIMD 操作的多个计算通道。每个 PE在其所有计算核心之间具有共享内存 ( PE Memory )，主要用于存储模型激活、部分结果和输出，而单个核心具有主要用于存储模型参数的内存。每个内核有多个计算通道，具有多路乘法累加(MAC) 单位。每个周期的模型计算结果要么存储在 PE 内存中以供进一步计算，要么卸载回 DRAM。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img data-ratio=&quot;0.3828125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eG1jA7faiceFtMU8TaZZ77zicmEbWVBbMpgXFiaEk5Rb0JJT5AcArTHsLvCfEnhibqZSbvry0iaT2X3cRUx1E2hgxGA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;em&gt;优化策略&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;在本研究中，我们在架构探索的背景下探索了四种优化策略：&lt;/p&gt;&lt;p&gt;1.随机：随机均匀地对架构搜索空间进行采样。&lt;/p&gt;&lt;p&gt;2.Vizier：使用贝叶斯优化在搜索空间中进行探索，其中目标函数的评估成本很高（例如硬件模拟，可能需要数小时才能完成）。使用来自搜索空间的一组采样点，贝叶斯优化形成一个代理函数，通常用高斯过程表示，它近似于搜索空间的流形。在代理函数值的指导下，贝叶斯优化算法在探索和开发的权衡中决定是从流形中的有希望的区域中采样更多（开发），还是从搜索空间中不可见的区域中采样更多（勘探）。然后，优化算法使用这些新采样点并进一步更新代理函数以更好地对目标搜索空间进行建模。Vizier 将预期改进作为其核心获取功能。在这里，我们使用Vizier (safe)，这是一种约束优化的变体，它指导优化过程避免建议不满足给定约束的试验。&lt;/p&gt;&lt;p&gt;3.Evolutionary：使用k 个个体的种群 执行进化搜索，其中每个个体的基因组对应于一系列离散化的加速器配置。通过使用锦标赛选择从种群中为每个个体选择两个父母，以某种交叉率重组他们的基因组，并以某种概率突变重组的基因组，从而产生新个体。&lt;/p&gt;&lt;p&gt;4.基于种群的黑盒优化(P3BO)：使用一组优化方法，包括进化和基于模型，已被证明可以提高样本效率和稳健性。采样数据在集成中的优化方法之间交换，优化器根据其性能历史进行加权以生成新的配置。在我们的研究中，我们使用 P3BO 的变体，其中优化器的超参数使用进化搜索动态更新。&lt;/p&gt;&lt;h2&gt;&lt;em&gt;加速器搜索空间嵌入&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;为了更好地可视化每个优化策略在加速器搜索空间导航中的有效性，我们使用t 分布随机邻居嵌入 (t-SNE) 将探索的配置映射到优化范围内的二维空间。所有实验的目标（奖励）定义为每个加速器区域的吞吐量（推理/秒）。在下图中，x轴和y轴表示嵌入空间的 t-SNE 组件（嵌入 1 和嵌入 2）。星形和圆形标记分别显示不可行（零奖励）和可行设计点，可行点的大小与其奖励相对应。&lt;/p&gt;&lt;p&gt;正如预期的那样，随机策略以均匀分布的方式搜索空间，最终在设计空间中找到很少的可行点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6447574334898278&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eG1jA7faiceFtMU8TaZZ77zicmEbWVBbMppenbrIIOe36BYI6aZIp7Y6RZ99X0Ejn7MhWk5dcEooTAchfibgNGpEg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;639&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;与随机抽样方法相比，Vizier默认优化策略在探索搜索空间和找到具有更高奖励的设计点（1.14 对 0.96）之间取得了很好的平衡。然而，这种方法往往会陷入不可行的区域，虽然它确实找到了一些具有最大回报的点（由红十字标记表示），但它在最后一次探索迭代中几乎找不到可行的点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.64375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eG1jA7faiceFtMU8TaZZ77zicmEbWVBbMpagGyLtR9eDDsRiaib3ibuO2n72lTp6ff2ibYyQAPjZFDkW68FCZic8nTb7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另一方面，进化优化策略在优化的早期找到可行的解决方案，并在它们周围组装可行点的集群。因此，这种方法主要导航可行区域（绿色圆圈）并有效地避开不可行点。此外，进化搜索能够找到更多具有最大奖励（红色十字）的设计选项。具有高回报的解决方案的这种多样性为设计师探索具有不同设计权衡的各种架构提供了灵活性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eG1jA7faiceFtMU8TaZZ77zicmEbWVBbMpc8uvIJFrAS6YPRONfA1MGDXdaspibngpDqiaje30bJKLmrQhP9NSwRWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后，基于群体的优化方法 (P3BO) 以更有针对性的方式（具有高奖励点的区域）探索设计空间，以找到最佳解决方案。P3BO 策略在具有更严格约束（例如，大量不可行点）的搜索空间中找到具有最高奖励的设计点，显示其在具有大量不可行点的搜索空间中导航的有效性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.646875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eG1jA7faiceFtMU8TaZZ77zicmEbWVBbMp4qZpbVl5u9lbKgKwloxRqpWMbAALxFWxM9u0RFpSq8JQEjprg97Qcg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;em&gt;不同设计约束下的架构探索&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;我们还研究了每种优化策略在不同面积预算约束（6.8 mm 2、5.8 mm 2和4.8 mm 2 ）下的优势。以下小提琴图显示了优化结束时（每次运行 4K 次运行 10 次后）在所研究的优化策略中最大可实现奖励的完整分布。较宽的部分代表在特定给定奖励下观察可行架构配置的可能性更高。这意味着我们倾向于在具有更高奖励（更高性能）的点上产生增加宽度的优化算法。&lt;/p&gt;&lt;p&gt;架构探索的两个表现最佳的优化策略是进化和 P3BO，两者都提供具有高回报和跨多次运行稳健性的解决方案。查看不同的设计约束，我们观察到随着面积预算约束的收紧，P3BO 优化策略会产生更高性能的解决方案。例如，当面积预算约束设置为 5.8 mm 2 时，P3BO 发现奖励（吞吐量/加速器面积）为 1.25 的设计点优于所有其他优化策略。当面积预算约束设置为 4.8 mm 2 时，观察到相同的趋势，在多次运行中发现具有更高稳健性（更少可变性）的稍微更好的奖励。&lt;/p&gt;&lt;p&gt;小提琴图显示了在 6.8 mm 2的面积预算下经过 4K 试验评估后，在 10 个优化策略中运行的最大可实现奖励的完整分布。P3BO 和 Evolutionary 算法产生了更多的高性能设计（更宽的部分）。x 轴和 y 轴分别表示研究的优化算法和基准加速器上加速（奖励）的几何平均值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6807017543859649&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eG1jA7faiceFtMU8TaZZ77zicmEbWVBbMpnz1jo31k6Szx4BoCDvIgm9gVosQiaWeiclJLH69sZ8B4ribEiavkxP8HzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;570&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6807017543859649&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eG1jA7faiceFtMU8TaZZ77zicmEbWVBbMp3q6D55hALn2tLmJibK8CyVaK1CBlv3DqTfO60pBwK0A4JMYvDeib1tiaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;570&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;em&gt;结论&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;虽然Apollo为更好地理解加速器设计空间和构建更高效的硬件迈出了第一步，但发明具有新功能的加速器仍然是一个未知领域和新领域。我们相信，这项研究是一条令人兴奋的前进道路，可以进一步探索用于跨计算堆栈的架构设计和协同优化（例如编译器、映射和调度）的 ML 驱动技术，从而为下一代开发具有新功能的高效加速器。应用程序。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>20f04774d014f90efa8ffddb695ec2a8</guid>
<title>移动平台 GPU 硬件学习与理解</title>
<link>https://toutiao.io/k/0drtqbq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;h3&gt;前言&lt;/h3&gt;&lt;p&gt;在当今移动平台下，芯片总的架构大体相似，若是哪一家出了新特性，其它家不久就会换个名字抄过去。在2020移动端性能白皮书中，安卓阵营Qualcomm Snapdragon Soc占有率超过49%，而我手头上也正好有高通的测试机，因此这篇文章主要是讲高通的GPU。因此本文初衷是试着尽可能以单家厂商为基础的硬件学习，并融入自己的理解。&lt;/p&gt;&lt;p&gt;2020年年末苹果M1  Soc正式发布，桌面电脑开始转向 ARM 架构，跟手机使用同一个架构，App 将可以通用。可以预见，以后移动平台性能越来越接近PC，而PC也向移动平台靠拢，由于性能接近，手游和端游的界限也将会越来越模糊。在B站极客湾的M1测试视频中提到，M1的GPU性能远超移动端GPU，两者不在一个量级，甚至接近桌面GPU RX560，功耗也相当优秀。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c001a06f7425c7bb860a87c8134cfac1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;555&quot; data-rawheight=&quot;331&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-c001a06f7425c7bb860a87c8134cfac1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;555&quot; data-rawheight=&quot;331&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-c001a06f7425c7bb860a87c8134cfac1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c001a06f7425c7bb860a87c8134cfac1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;1. Adreno的发展历史&lt;/h3&gt;&lt;p&gt;Qualcomm收购AMD的移动平台图形技术后，发展成为Adreno——也就是Qualcomm Soc中GPU部分的品牌。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2006 - Adreno 1xx series&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;OpenGL ES 1.1&lt;/li&gt;&lt;li&gt;固定功能管线（fixed function pipeline）&lt;/li&gt;&lt;li&gt;能完成简单的3D游戏&lt;/li&gt;&lt;li&gt;2008年公布采用Soc芯片，CPU和GPU统一在一个芯片中&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;2009 - Adreno 2xx series - yamato&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;OpenGL ES 2.0&lt;/li&gt;&lt;li&gt;统一着色器架构（Unified shader architecture）&lt;/li&gt;&lt;li&gt;可编程渲染管线&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;2012 - Adreno 3xx series - oxili&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;OpenGL ES 3.0，feature level 9_3&lt;/li&gt;&lt;li&gt;FlexRender渲染架构：可在IMR和TBR之间自动切换（有人说这个TBR与PowerVR的TBDR基本一致，不是的，官方没说过，人家原词是binning or deferred rendering，根本没提到TBDR）。为什么移动端Soc会需要IMR？猜测是当渲染目标分辨率过小，小于一个Tile时，这时候省去Binning使用IMR效率会更高。&lt;/li&gt;&lt;li&gt;Early Z Rejection&lt;/li&gt;&lt;li&gt;RenderScript：Google为安卓平台开发的一种数据并行计算框架&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;2014 - Adreno 4xx series - krait&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;OpenGL ES 3.1，Vulkan 1.0，feature level 11_1&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;2015 - Adreno 5xx series - kryo&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;OpenGL ES 3.2/3.1+AEP，Vulkan 1.0&lt;/li&gt;&lt;li&gt;Shared Virtual Memory (SVM)共享虚拟内存&lt;/li&gt;&lt;li&gt;常见于骁龙625-660、骁龙820-835&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;2018 - Adreno 6xx series&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;OpenGL ES 3.2，Vulkan 1.1，feature level 12_1&lt;/li&gt;&lt;li&gt;常见于骁龙845-888&lt;/li&gt;&lt;li&gt;true HDR&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;2. 名词解释&lt;/h3&gt;&lt;p&gt;在开始介绍前，让我们先把名词统一，作为我们的共识。&lt;/p&gt;&lt;p&gt;&lt;b&gt;System on Chip（Soc）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Soc是把CPU、GPU、内存、通信基带、GPS模块等等整合在一起的芯片的称呼。常见有A系Soc（苹果），骁龙Soc（高通），麒麟Soc（华为），联发科Soc，猎户座Soc（三星），去年苹果推出的M系Soc，暂用于Mac，但这说明手机、笔记本和PC的通用芯片已经出现了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-478c1d8898aaa7c2cd1013b4c4cf5553_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;392&quot; data-rawheight=&quot;440&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;392&quot; data-rawheight=&quot;440&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-478c1d8898aaa7c2cd1013b4c4cf5553_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a67cb6014a57c78b665f828fb3221607_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;630&quot; data-rawheight=&quot;476&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-a67cb6014a57c78b665f828fb3221607_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;630&quot; data-rawheight=&quot;476&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-a67cb6014a57c78b665f828fb3221607_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-a67cb6014a57c78b665f828fb3221607_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;物理内存&lt;/b&gt;&lt;br/&gt;内存大致分为两类，DRAM和SRAM。&lt;br/&gt;SRAM：（Static Random Access Memory，静态随机存取内存）具有静止存取数据的作用，但是断电后数据还是会消失，速度较DRAM快，不需要刷新电路就能够保存数据。&lt;b&gt;一般用作片内缓存（On-chip Cache），例如L1Cache、L2Cache。&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;DRAM：（Dynamic Random Access Memory，动态随机存取内存）需要不停地刷新电路，否则内部的数据将会消失，因此被称为“动态”存储器，常用于内存，一般容量较SRAM大。&lt;b&gt;一般用作系统内存（System Memory）。&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;SDRAM（Synchronous Dynamic Random Access Memory，同步动态随机存取内存），是指有同步接口的DRAM。&lt;/li&gt;&lt;li&gt;DDR SDRAM，简称DDR（Double Data Rate），指具有双倍数据传输率的SDRAM，其数据传输速度为系统时钟频率的两倍，由于速度增加，其传输性能优于传统的SDRAM。&lt;/li&gt;&lt;li&gt;LPDDR SDRAM，简称LPDDR（Low Power Double Data Rate）是移动设备常用的一种低功耗SDRAM，以低功耗和小体积著称，专用于移动电子产品，又名mDDR。&lt;b&gt;我们最常操作的FrameBuffer便是存放于此。&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Soc中GPU和CPU共用一块片内LPDDR物理内存，就是我们常说的手机内存，也叫System Memory，大概几个G。此外CPU和GPU还分别有自己的高速SRAM的Cache缓存，也叫On-chip Memory，一般几百K~几M。不同距离的内存访问存在不同的时间消耗，距离越近消耗越低，读取System Memory的时间消耗大概是On-chip Memory的几倍到几十倍。&lt;/p&gt;&lt;p&gt;&lt;b&gt;On-Chip Buffer&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在TB(D)R架构下会存储Tile的颜色、深度和模板缓冲，读写修改都非常快。如果Load/Store指令中缓冲需要被Preserve，将会被写入一份到System Memory中。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Early Depth Test(EarlyDT)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;由于技术专利或实现有细小差异，Mobile GPU厂商对Early Depth Test有不同的称呼，PowerVR为&lt;b&gt;HSR&lt;/b&gt;（Hidden Surface Removal），Adreno为&lt;b&gt;Early Z Rejection&lt;/b&gt;，Mali为&lt;b&gt;FPK&lt;/b&gt;(Forward Pixel Killing)，为了方便后续统称为EarlyDT。&lt;/p&gt;&lt;p&gt;&lt;b&gt;overdraw&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在一帧内，对同一个像素绘制超过一次。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Bandwidth&lt;/b&gt;&lt;/p&gt;&lt;p&gt;带宽指的是一定时间内传输的数据量。使用的带宽越大意味着单位时间内传输数据越多，因此手机就越容易发烫。由于Soc中CPU和GPU共用系统内存，带宽的消耗主要发生在片内不同级别内存之间，例如从System Memory到GPU中的Cache、GPU Cache到GPU Core Cache的过程（GPU有许多Core，每个Core又有自己单独的Cache）。例如骁龙835的最大带宽是29.8 Gbit/s，假设帧率为60，那理论上每帧可传输约0.497GB数据，当然现实中因为各种原因只可能比这个数值小。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Fillrate&lt;/b&gt;&lt;/p&gt;&lt;p&gt;像素填充率指的是GPU渲染像素的速度，当然这个像素指的是通过各种测试后的实际绘制片段，填充率越高说明设备可处理的片段数量越多，例如一台移动设备的最大填充率为4.8十亿像素/秒（GPixel/s），假设帧率为60，那每帧可处理4 800 000 000/60=80 000 000个 像素，以2340*1080的分辨率来说，理论上每帧可以绘制整个场景31次（假设每像素只绘制一遍）。不过事实上几乎达不到理论效果，一方面是有其它的消耗（例如后处理），另一方面是每个像素我们很可能不止绘制一次，这也便是各种优化文章中说要少用后处理、减少overdraw的缘由。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Stall&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当一个GPU核心的两次计算结果之间有依赖关系而必须串行时，等待的过程便是Stall。&lt;/p&gt;&lt;p&gt;&lt;b&gt;SIMD Processing Unit&lt;/b&gt;&lt;/p&gt;&lt;p&gt;SIMD（Single Instruction Multiple Data）指单指令多数据指令集。GPU为了更高效的并行计算，每一个图形处理单元都以SIMD处理单元的形式在多线程上并发的执行任务。&lt;/p&gt;&lt;p&gt;&lt;b&gt;统一着色器架构和非统一着色器架构&lt;/b&gt;&lt;/p&gt;&lt;p&gt;非统一架构中，vertex和frag都有专门的处理模块，由于任务量差异较大，这会导致Stall，而在统一架构中，vert和frag使用相同的处理模块，这在性能上会有相对较大的优势，现今绝大多数GPU都采用统一架构。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2659518b5dd71b811d3bc26d6439ee0f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;961&quot; data-rawheight=&quot;352&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-2659518b5dd71b811d3bc26d6439ee0f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;961&quot; data-rawheight=&quot;352&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-2659518b5dd71b811d3bc26d6439ee0f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-2659518b5dd71b811d3bc26d6439ee0f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;br/&gt;&lt;b&gt;Tile Accelerator(TA)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;PowerVR硬件单元，用来决定每个Tile包含哪些图元。&lt;/p&gt;&lt;p&gt;这些信息被称为per-tile list，这个list以及geometry数据都被存放在一个名为Parameter Buffer（PB）的缓存中，这个缓存在System Memory中。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Image Signal Processor (ISP)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;PowerVR的图形处理单元，用来处理一个Tile的EarlyDT、光栅化以及深度模板测试。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Texture and Shading Processor (TSP)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;负责处理片段着色器的硬件单元，这个过程也是逐Tile的，当一个Tile渲染完成时，颜色数据就会被写入System Memory。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Universal Scalable Shader Engine(USSE)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;USSE是一个通用多线程处理单元，能够处理顶点shader、片段shader和通用图形核心指令。在顶点和片段处理任务之间会尽可能优化，使得任务之间的执行尽可能并行化，即减少stall。&lt;/p&gt;&lt;p&gt;&lt;b&gt;General-purpose computing on graphics processing units（GPGPU）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;GPGPU指的是能够并行计算CPU中通用计算任务的GPU，而GPGPU计算指的是GPU在通用并行计算中的应用，这主要是源于GPU的计算核心拥有大量SIMD单元，基本上现代GPU都可以被看作是GPGPU。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Compute Unified Device Architecture（CUDA）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;是由Nvidia开发的一个并行计算平台，配备完整的工具包，旨在充分发挥GPU的并行计算能力。在CUDA出现之前，GPU非常难编程，而CUDA的出现使得开发变得非常方便，不过它只能针对Nvidia自家GPU。一般CUDA核心数量越多，则表示它并行计算能力越强。&lt;/p&gt;&lt;p&gt;相对的RenderScript是Google转为安卓开发的并行架构，OpenCL则是一种与并行计算相关的跨平台API。&lt;/p&gt;&lt;h3&gt;3. TBR与TBDR&lt;/h3&gt;&lt;h3&gt;3.1 TBR是什么？移动端为什么要用TBR？&lt;/h3&gt;&lt;p&gt;Tile Base Rendering是一种渲染架构，旨在满足低功耗且有内存带宽限制特点的移动端。&lt;/p&gt;&lt;p&gt;这种架构会将FrameBuffer划分为多个方形的Tile块，渲染Tile时先将绘制结果存放在容量小但速度快的On-chip Memory（或称Graphics Memory,GMEM）中，Tile绘制完毕后再拷贝至FrameBuffer。由于将拷贝过程分为了多次，&lt;b&gt;虽然牺牲了部分效率，但是大幅降低了带宽，解决了最麻烦的带宽和功耗问题&lt;/b&gt;，因为访问DRAM内存是一种非常昂贵的带宽消耗。&lt;/p&gt;&lt;p&gt;如下图分了12个Tile渲染。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-da03ab9bb7e3b8eb4edbc91721c5df88_b.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;256&quot; data-rawheight=&quot;259&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-da03ab9bb7e3b8eb4edbc91721c5df88_b.jpg&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;256&quot; data-rawheight=&quot;259&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-da03ab9bb7e3b8eb4edbc91721c5df88_b.jpg&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-da03ab9bb7e3b8eb4edbc91721c5df88_b.gif&quot;/&gt;&lt;/figure&gt;&lt;p&gt;而下图，IMR则是直接与FrameBuffer交互，也就用不着Tile这类麻烦的步骤。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-28f60eb6ee193b8a96ce2760ff5f6b5e_b.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;192&quot; data-thumbnail=&quot;https://pic3.zhimg.com/v2-28f60eb6ee193b8a96ce2760ff5f6b5e_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-28f60eb6ee193b8a96ce2760ff5f6b5e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;192&quot; data-thumbnail=&quot;https://pic3.zhimg.com/v2-28f60eb6ee193b8a96ce2760ff5f6b5e_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-28f60eb6ee193b8a96ce2760ff5f6b5e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-28f60eb6ee193b8a96ce2760ff5f6b5e_b.gif&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;3.2 TBR的具体是什么过程？&lt;/h3&gt;&lt;p&gt;只有PowerVR自称TBDR，其它厂家都是TBR。&lt;/p&gt;&lt;p&gt;先说TBR，TBR比IMR多一个Binning的过程（PowerVR里叫Tiling）。&lt;/p&gt;&lt;p&gt;TBR的渲染过程可以拆分为BinningPass和RenderingPass两步，对应下图。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-73a2abda9ef575cf5abfea10f123a953_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;567&quot; data-rawheight=&quot;843&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-73a2abda9ef575cf5abfea10f123a953_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;567&quot; data-rawheight=&quot;843&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-73a2abda9ef575cf5abfea10f123a953_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-73a2abda9ef575cf5abfea10f123a953_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e4f5af08aebcd926c7f5fa6b21b31cd6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;863&quot; data-rawheight=&quot;586&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-e4f5af08aebcd926c7f5fa6b21b31cd6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;863&quot; data-rawheight=&quot;586&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-e4f5af08aebcd926c7f5fa6b21b31cd6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e4f5af08aebcd926c7f5fa6b21b31cd6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Binning位于Vertex Process和Raster之间，它的目的是标记每个图元会出现在哪些Tile里，每一个图元会分配一个Bin Buffer，例如上图中Bin#1、Bin#2，这一份临时的Visiblity Stream数据会被保存至System Memory中。&lt;/p&gt;&lt;p&gt;之后真正执行RenderingPass时，再从System Memory中读取Visiblity Stream，逐Bin进行渲染，当一个Tile中的图元都被渲染完成后，会将输出的颜色从Tile写入（对应上图resolve pass，因为可能开了msaa）到FrameBuffer，然后再继续画下一个Tile，直到所有Tile绘制完毕。当最后一个Tile拷贝完毕后，再交换前后缓冲，准备绘制下一帧。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-13baef348b3c788a703888b4792131bc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;668&quot; data-rawheight=&quot;510&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-13baef348b3c788a703888b4792131bc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;668&quot; data-rawheight=&quot;510&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-13baef348b3c788a703888b4792131bc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-13baef348b3c788a703888b4792131bc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;下图是BinningPass的可视化过程，上方每个红框表示一个Tile，下方表示当前提交的三角形。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3d216b61bca3530a107f74ebc114a0e8_b.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;480&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-3d216b61bca3530a107f74ebc114a0e8_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-3d216b61bca3530a107f74ebc114a0e8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;480&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-3d216b61bca3530a107f74ebc114a0e8_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-3d216b61bca3530a107f74ebc114a0e8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-3d216b61bca3530a107f74ebc114a0e8_b.gif&quot;/&gt;&lt;/figure&gt;&lt;p&gt;因此Binning仅仅是对所有几何体进行Vertex Process确定Tile内可见的图元，并&lt;b&gt;将几何体的Raster延迟&lt;/b&gt;，这个延迟过程在TBR/TBDR都有。&lt;/p&gt;&lt;h3&gt;3.3 那么TBDR的“D”指的是什么？&lt;/h3&gt;&lt;p&gt;PowerVR的TBDR中，&lt;b&gt;D就是在TBR的基础上还把Frag Process推迟了，&lt;/b&gt;在中间插入了一个HSR（Hidden Surface Removal）的过程。如图，HSR发生在Raster和Frag Process之间。&lt;/p&gt;&lt;p&gt;对比可以发现TBR虽然也有对应的EarlyDT过程，但没有TagBuffer来保存延迟的数据。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c34b214c1d829a8d6e66339a5e25cd89_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;729&quot; data-rawheight=&quot;196&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-c34b214c1d829a8d6e66339a5e25cd89_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;729&quot; data-rawheight=&quot;196&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-c34b214c1d829a8d6e66339a5e25cd89_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c34b214c1d829a8d6e66339a5e25cd89_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;3.4 HSR具体做了什么？&lt;/h3&gt;&lt;p&gt;先说结论，HSR的目的是筛选出Tile里所有片段中最终实际渲染的那一部分，这个过程本质上来说就是&lt;b&gt;改进版Early Depth Test&lt;/b&gt;，用处也是用来减少overdraw。&lt;/p&gt;&lt;h3&gt;3.4.1 EarlyDT&lt;/h3&gt;&lt;p&gt;在说HSR前，必须先说说传统的EarlyDT，或者大家叫的EarlyZ。这是一个GPU硬件功能，指的是在执行片段着色器前会先与深度缓存中对应的片段进行深度测试，测试失败的片段将会被抛弃掉，以此达到减少OverDraw的目的。这个过程发生在光栅化和片段着色器之间。&lt;/p&gt;&lt;p&gt;例如下图原本缓冲中存在部分z值为1的像素，当有新的z值为2的像素被渲染时，重叠的部分中为2像素将被抛弃，不会进行片段着色计算。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-227e7d8c59c7ae4dda38e89985b9cc96_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;803&quot; data-rawheight=&quot;302&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-227e7d8c59c7ae4dda38e89985b9cc96_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;803&quot; data-rawheight=&quot;302&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-227e7d8c59c7ae4dda38e89985b9cc96_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-227e7d8c59c7ae4dda38e89985b9cc96_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;EarlyDT依赖于深度缓冲，因此要EarlyZ生效有两种方式：&lt;br/&gt;第一种是PreDepth Pass，也就是在渲染场景前额外用depth only pass渲染场景，这个pass渲染所有的不透明物体，禁写颜色只输出深度，它的顶点着色器只需要做顶点变换，片段着色器都可以省略。等正常渲染场景时，再关闭深度写入，那么Early Z会由drive生效丢弃看不见的片段。这种方式优势在于&lt;b&gt;粒度很细，可以达到像素级别的reject，但是缺陷在于额外一个Pass绘制全场景的消耗，多了一倍的顶点、光栅化和深度测试&lt;/b&gt;，在前向渲染这些缺陷足够超过了它的优势（延迟渲染不是），这也是大家都不用predepth的原因，在Unity中只可能在开了msaa且需要深度的后处理用上它（原因请参考URP中ForwardRenderer.cs中CanCopyDepth函数）。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;第二种则是使用front to back的渲染顺序，即对不透明物体按离相机的距离从前至后排序，按照这种顺序可以根据每个物体写入的深度缓冲，来提早将远处的片段剔除。但它也存在对应的问题，主要方面是&lt;b&gt;它的粒度是较为粗糙的几何体级别，无法解决由物体相交导致的overdraw&lt;/b&gt;，次要方面是它需要时刻由CPU计算物体排序，这存在消耗并且可能会打乱减少drawcall的排序（打断渲染状态合批），不过它的消耗相对较小，大家一般都会选择这种。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;不管哪种方式，都存在相同的限制：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在片段着色器中不能有深度值的写入、修改，否则Early Z失效（不过一般也用不着改深度）。&lt;/li&gt;&lt;li&gt;不能使用alpha test或texkill，即便有if判断条件，也会使Early Z失效。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;理由很简单，DT实际包含读和写两个操作，&lt;b&gt;硬件无法提前得知这个像素是否会被AlphaTest抛弃，如果EarlyZ通过了但是AlphaTest失败了，那EarlyZ就写入了错误的深度值，frag process中修改深度同理。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;不过从OpenGL 4.2/sm5后，可以对片段着色器使用&lt;b&gt;Depth Condition&lt;/b&gt;声明，用户在保证修改深度值大于或小于插值深度值这一约束下，drive也会尝试执行EarlyDT，只不过会把z值的写入推迟到片段着色器之后，也就是LateDT时。 &lt;/p&gt;&lt;p&gt;一般各厂家在说EarlyDT时默认都是在说不透明物体，半透明物体由于混合需要采用back to front的顺序，场景全是半透将无法从EarlyZ获得收益，但若是在不透与半透混搭的情况下倒是可以利用已有的深度缓冲做EarlyDT。 &lt;/p&gt;&lt;p&gt;还有一种&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/17898738/early-z-test-depth-test-in-directx-11&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;说法&lt;/a&gt;是如果&lt;b&gt;AlphaTest物体不写深度，那EarlyZ就有可能生效&lt;/b&gt;。我想了想似乎能说通，一个像素如果EarlyZ没过，那自然被抛弃，无影响；如果EarlyZ和AlphaTest都通过了，不写深度，也就frag写入颜色，没毛病；重点是如果EarlyZ过了但是AlphaTest没过，那这个像素不会对FrameBuffer产生任何影响（前提是Early Depth/Stencil Test过程不写模板），所以也没毛病，合理。就是不知道具体测试效果怎样。（Arm官方人员也提到AlphaTest不写深度会有性能优势，不知道是不是说的这个）&lt;/p&gt;&lt;p&gt;恩，由于EarlyDT是硬件功能，我们没办法知道是否生效，唯有实际测试通过性能分析得知。&lt;/p&gt;&lt;h3&gt;3.4.2 HSR&lt;/h3&gt;&lt;p&gt;接下来再说PowerVR的HSR。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8172c89c469c19cce67c7672072775d9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1023&quot; data-rawheight=&quot;282&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-8172c89c469c19cce67c7672072775d9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1023&quot; data-rawheight=&quot;282&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-8172c89c469c19cce67c7672072775d9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-8172c89c469c19cce67c7672072775d9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;首先HSR功能在ISP硬件单元内，如下图。&lt;/p&gt;&lt;p&gt;根据官方文档所说，在开启深度测试后，ISP会从SystemMemory的PB中读取Display List（就是Binning时存的图元数据，下图中Primitive List），&lt;b&gt;硬件驱动会根据这个数据对Tile内每个可见图元投影射线，来准确计算出图元中每个像素的深度，将其与深度缓冲中对应像素的深度进行比较来决定是否抛弃这个像素&lt;/b&gt;，Tag Buffer记录了HSR过程后所有的可见像素及其所属图元，之后才由TSP来读取并处理Tag Buffer，整个数据交互如下图所示。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e7c8e32fcccafacf710815eb0f3ad975_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;633&quot; data-rawheight=&quot;330&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-e7c8e32fcccafacf710815eb0f3ad975_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;633&quot; data-rawheight=&quot;330&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-e7c8e32fcccafacf710815eb0f3ad975_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e7c8e32fcccafacf710815eb0f3ad975_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;因此我们可以总结，HSR是在Tile内给每个图元的每个像素做了一遍像素级别的EarlyDT。&lt;/p&gt;&lt;p&gt;一般EarlyDT如果没有PreDepth的情况下，依旧只能按提交的front to back顺序来实现较为粗糙的EarlyDT。而HSR是对Tile内所有图元用射线求出像素的最小深度，一块做深度测试，官方夸耀的不需要进行front to back的排序就是因为这一点。&lt;/p&gt;&lt;p&gt;虽说HSR的效果与有PreDepth的EarlyDT一样都能达到像素级的粒度——没有overdraw，但HSR由于利用了Binning中的图元数据，不再需要额外的一遍Depth绘制，更节省性能。&lt;/p&gt;&lt;p&gt;&lt;b&gt;HSR是如何优化AlphaTest的呢？&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c1d4db716415a222aa2d663323b55aeb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;820&quot; data-rawheight=&quot;126&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-c1d4db716415a222aa2d663323b55aeb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;820&quot; data-rawheight=&quot;126&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-c1d4db716415a222aa2d663323b55aeb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-c1d4db716415a222aa2d663323b55aeb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上面说过传统EarlyDT是直接关了，而HSR并没有关掉，首先ISP会假定所有片段都是不透明的，然后将它们提交给TSP，TSP再提交给USSE进行Frag Process，如果发现片段被丢弃，USSE再将片段可见性数据发送回ISP以更新Tile里的深度和模板缓冲区。&lt;/p&gt;&lt;p&gt;这里其实说得不是很细，提交给TSP前的HSR是完整的&quot;读和写&quot;还是只有&quot;读取并测试&quot;的过程？我不是很确定，按照语义&quot;can be updated&quot;猜测应该是有写入过程的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-94c9d8687b77d983f190550a6cd80c21_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;656&quot; data-rawheight=&quot;191&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-94c9d8687b77d983f190550a6cd80c21_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;656&quot; data-rawheight=&quot;191&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-94c9d8687b77d983f190550a6cd80c21_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-94c9d8687b77d983f190550a6cd80c21_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果这个猜测成立，那AlphaTest的片段相当于把EarlyDT和LateDT的读和写都做了一遍，为了强行给AlphaTest用EarlyDT，带来了很麻烦的步骤。&lt;/p&gt;&lt;p&gt;下面回头的箭头指的大概就是这个过程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2579f33736ed3606f0765a611751de9b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;459&quot; data-rawheight=&quot;83&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-2579f33736ed3606f0765a611751de9b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;459&quot; data-rawheight=&quot;83&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-2579f33736ed3606f0765a611751de9b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-2579f33736ed3606f0765a611751de9b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;HSR这么好的东西为什么其它厂家没抄过去，是否因为HSR本身有一些局限性？&lt;/b&gt;&lt;br/&gt;并不是完全没抄。Mali的FPK使用了FPK logic和FPK buffer实现了Forward Pixel Kill，与HSR效果一致同样有Defer过程，但实现方式略有差别。这说明这个功能是大家认可的，但还没看见Adreno版本的，如果有人了解相关信息还请告知下。&lt;/p&gt;&lt;p&gt;（Mali的FPK都实装Defer了，PVR的文档还在硬吹独家TBDR...）&lt;/p&gt;&lt;h3&gt;3.5 TBDR的“D”与软件层的Deferred有什么区别?&lt;/h3&gt;&lt;p&gt;软件层的Deferred Render是将渲染改为绘制两遍，第一次是光栅化用于记录法线等基本信息存入GBuffer，第二次再遍历像素并读取GBuffer中的基本信息来进行计算，不过延迟渲染主要是用于处理场景多光照问题，就不细说了。&lt;/p&gt;&lt;p&gt;从原理思想上来说两者是相似的，但TBDR的Deffer是硬件层面的，两者没有什么直接关联。&lt;/p&gt;&lt;h3&gt;3.6 TB(D)R的MSAA&lt;/h3&gt;&lt;p&gt;在TB(D)R架构上，Tile天然适合MSAA，使用MSAA不会有额外的内存和带宽的消耗。&lt;/p&gt;&lt;p&gt;首先Tile本身带有固定大小Cache，一般几百K-几M，当采样点变多后会使得Tile所需要的内存变多，由于Tile总容量不变，drive会通过减小Tile的尺寸并增加Tile数量来应对。例如原本将FrameBuffer分12个Tile，每个为32x32像素。使用MSAA后会分为24个Tile，每个16x16像素。&lt;/p&gt;&lt;p&gt;由于Tile在将颜色写入FrameBuffer前便进行了resolved pass，也就是说写入FrameBuffer的数据不带多采样点，传输到FrameBuffer的总数据量不变，只不过传输次数变多了而已。因此2xMSAA在TB(D)R下几乎是毫无消耗，&lt;b&gt;为什么说是&quot;几乎&quot;呢？因为随着Tile数量的增加，Binning阶段中记录Tile的数据量也增加了，从而增加了顶点阶段的消耗。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;看起来是白送，然而这些要实际生效&lt;b&gt;条件苛刻&lt;/b&gt;：&lt;/p&gt;&lt;p&gt;1. StoreAction必然不能为Store，Store选项会写入带MSAA的数据，按理来说应该得选Resolve，但是深度缓冲非线性并不能Resolve，这意味着游戏只要要深度这个白送就拿不到；&lt;/p&gt;&lt;p&gt;2. 随着Tile尺寸减小，Tile数量会暴增，顶点数据也会暴增，所以只适合顶点数量较少的游戏（例如lowpoly风格）或者是UI，不过UI大多是半透明quad要MSAA有何用？所以适用性极其有限。&lt;/p&gt;&lt;h3&gt;3.7 TB(D)R的Load/Store Action&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-75f8381b9c6a69afcb6f587f9c20e2b7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1537&quot; data-rawheight=&quot;480&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-75f8381b9c6a69afcb6f587f9c20e2b7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1537&quot; data-rawheight=&quot;480&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-75f8381b9c6a69afcb6f587f9c20e2b7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-75f8381b9c6a69afcb6f587f9c20e2b7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Unity的LoadAction提到过在TBR下Load操作非常耗，我们先明白它发生的时机，它表示当渲染目标切换时，是否需要从System Memory中加载上一次在这个目标中保存的内容。&lt;/p&gt;&lt;p&gt;举个例子，先往RT A绘制了一个天空盒背景（假设StoreAction为Store），然后切换渲染目标B，往RT B中随便绘制个什么，然后切回RT A继续渲染，LoadAction发生在这时候是否需要从System Memory中读取上一次给RT A绘制的天空盒。&lt;/p&gt;&lt;p&gt;耗的原因在于每个Tile绘制前都需要从System Memory读对应Tile数据，这个读取操作多用了一倍的带宽，而且读取的时间消耗也很大。&lt;/p&gt;&lt;p&gt;它的使用一般有三种情况：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;假设我要对A Buffer所有像素进行绘制，那就选DontCare，省事&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;2. 假设我只对A Buffer中部分像素进行绘制，其余的部分我不希望有上次A Buffer的内容，就选Clear&lt;/p&gt;&lt;p&gt;3. 假设我只对A Buffer中部分像素进行绘制，其余的部分必须是上次A Buffer的内容，就选Load&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bdd15bbb6555a6c4485f926a3e6211aa_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1519&quot; data-rawheight=&quot;483&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-bdd15bbb6555a6c4485f926a3e6211aa_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1519&quot; data-rawheight=&quot;483&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-bdd15bbb6555a6c4485f926a3e6211aa_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-bdd15bbb6555a6c4485f926a3e6211aa_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;StoreAction发生在Tile渲染工作完成后（此时还在On-chip memory上），如何处理这部分渲染内容。&lt;/p&gt;&lt;p&gt;Store表示要存进System Memory，DontCare表示直接扔掉，中间的选项区别在于存时如何处理MSAA。&lt;/p&gt;&lt;p&gt;正常渲染颜色缓冲肯定得存，深度缓冲由于要深度测试一般也得存。不过由于深度缓冲非线性并不能Resolve所以第二、三个也得排除，那URP中StoreAction写死为Store也就能理解了。&lt;/p&gt;&lt;h3&gt;结语&lt;/h3&gt;&lt;p&gt;理清各种概念关系之后能发现虽然名词满天飞，但大家基本是在相互抄作业，也不难看出各家厂商针对TBR架构做了许多优化，目前大多数官方文档还停留在15-18年左右，也许当下不少新机已经包含了更强的feature，不过本文旨在理解这些基本概念，作为学习性能优化的第一步。&lt;/p&gt;&lt;h3&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Adreno&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Adreno Wiki&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pcper.com/2015/06/qualcomm-history-and-its-gpu-revolution/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;qualcomm-history-and-its-gpu-revolution&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.qualcomm.com/software/adreno-gpu-sdk/tools&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Adreno OpenGL ES Developer Guide&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.youtube.com/embed/SeySx0TkluE%3Frel%3D0%26width%3D560%26height%3D315%26wmode%3Dtransparent%26iframe%3Dtrue%26autoplay%3D1&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Adreno Hardware Tutorial 3: Tile Based Rendering&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pcper.com/2015/08/qualcomm-introduces-adreno-5xx-architecture-for-snapdragon-820/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;QUALCOMM INTRODUCES ADRENO 5XX ARCHITECTURE FOR SNAPDRAGON 820&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//users.nik.uni-obuda.hu/sima/letoltes/Processor_families_Knowledge_Base_2019/Qualcomm%2527s_processor_lines_2018_12_30.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Qualcomm&#x27;s_processor_lines_2018_12_30&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//nanoreview.net/en/soc/qualcomm-snapdragon-835&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Qualcomm Snapdragon 835&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.samsung.com/galaxy-gamedev/resources/articles/gpu-framebuffer.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;GPU Framebuffer Memory: Understanding Tiling&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.arm.com/documentation/dui0555/a/the-optimization-process/locating-bottlenecks-with-other-tools&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mali GPU Application Optimization Guide&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//community.arm.com/developer/tools-software/graphics/b/blog/posts/the-mali-gpu-an-abstract-machine-part-2---tile-based-rendering&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The Mali GPU: An Abstract Machine, Part 2 - Tile-based Rendering&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//community.arm.com/developer/tools-software/graphics/b/blog/posts/the-mali-gpu-an-abstract-machine-part-3---the-midgard-shader-core&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;The Mali GPU: An Abstract Machine, Part 3 - The Midgard Shader Core&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.arm.com/-/media/Arm%2520Developer%2520Community/PDF/Mali%2520GPU%2520datasheet/Arm%2520Mali%2520GPU%2520Datasheet%25202020.pdf%3Frevision%3D82e2cd30-98cd-4a10-bbe9-70ab4ce1e7d3%26la%3Den%26hash%3D3318C5F17395BF2E7BBD24EDA642A374876115C6&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Arm Mali GPU Datasheet 2020&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cdn.imgtec.com/sdk-documentation/PowerVR%2BHardware.Architecture%2BOverview%2Bfor%2BDevelopers.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PowerVR Hardware Architecture Overview for Developers&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cdn.imgtec.com/sdk-documentation/PowerVR%2BSeries5.Architecture%2BGuide%2Bfor%2BDevelopers.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PowerVR Series5.Architecture Guide for Developers&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cdn.imgtec.com/sdk-documentation/PowerVR_Performance_Recommendations.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PowerVR Performance Recommendations&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.imgtec.com/blog/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;A look at the PowerVR graphics architecture: Tile-based rendering&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//docs.imgtec.com/Rogue_Architecture_for_Developers/topics/_Ref389654760.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Image Synthesis Processor (ISP)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cdn.imgtec.com/sdk-documentation/Introduction_to_PowerVR_for_Developers.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Introduction to PowerVR for Developers&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//metalkit.org/2020/07/03/wwdc20-whats-new-in-metal.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;WWDC20 - What&#x27;s new in Metal and the Apple GPU&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/112120206&quot; class=&quot;internal&quot;&gt;移动设备GPU架构知识汇总&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gameinstitute.qq.com/community/detail/123220&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;针对移动端TBDR架构GPU特性的渲染优化&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cnblogs.com/timlly/p/11471507.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;深入GPU硬件架构及运行机制&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33127345&quot; class=&quot;internal&quot;&gt;再议移动平台的AlphaTest效率问题&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/425740956&quot; class=&quot;internal&quot;&gt;EarlyZ和TBDR中的HSR有什么本质区别么？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1Mo4y1Z7jb%3Ffrom%3Dsearch%26seid%3D2674235316352916331&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;吹牛还是真牛？苹果M1全网最硬核评测（上）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//open.library.ubc.ca/cIRcle/collections/ubctheses/24/items/1.0394065&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Models and techniques for designing mobile system-on-chip devices&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//haifux.org/lectures/267/Introduction-to-GPUs.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Introduction to GPU Architecture&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//upcommons.upc.edu/bitstream/handle/2117/122559/TPDS2018.pdf%3Bjsessionid%3DEF7147384A093AEAE9BE92DC8ECA26F9%3Fsequence%3D5&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Visibility Rendering Order: Improving Energy Efficiency on Mobile GPUs through Frame Coherence&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/17898738/early-z-test-depth-test-in-directx-11&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Early Z-test / depth-test in DirectX 11&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>