<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c96f48a26c0ae90d4b8066f3c7b8fb85</guid>
<title>从 Linux 源码看 socket 的 close</title>
<link>https://toutiao.io/k/fg9y3td</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;从linux源码看socket的close&lt;/h1&gt;&lt;p&gt;笔者一直觉得如果能知道从应用到框架再到操作系统的每一处代码，是一件Exciting的事情。上篇博客讲了socket的阻塞和非阻塞，这篇就开始谈一谈socket的close(以tcp为例且基于linux-2.6.24内核版本)&lt;/p&gt;&lt;h2&gt;TCP关闭状态转移图:&lt;/h2&gt;&lt;p&gt;众所周知，TCP的close过程是四次挥手，状态机的变迁也逃不出TCP状态转移图，如下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.5576923076923077&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEf38roxic4q4LUGmqgHqRFDpfqsfkoBQ8MiawgwibgibTYoS0bg0ic1rdL4qA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1456&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;tcp的关闭主要分主动关闭、被动关闭以及同时关闭(特殊情况,不做描述)&lt;/p&gt;&lt;h2&gt;主动关闭&lt;/h2&gt;&lt;h3&gt;close(fd)的过程&lt;/h3&gt;&lt;p&gt;以C语言为例，在我们关闭socket的时候，会使用close(fd)函数:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int    socket_fd;&lt;br/&gt;socket_fd = socket(AF_INET, SOCK_STREAM, 0);&lt;br/&gt;...&lt;br/&gt;// 此处通过文件描述符关闭对应的socket&lt;br/&gt;close(socket_fd)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而close(int fd)又是通过系统调用sys_close来执行的:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;asmlinkage long sys_close(unsigned int fd)&lt;br/&gt;{&lt;br/&gt;    // 清除(close_on_exec即退出进程时）的位图标记&lt;br/&gt;    FD_CLR(fd, fdt-&amp;gt;close_on_exec);&lt;br/&gt;    // 释放文件描述符&lt;br/&gt;    // 将fdt-&amp;gt;open_fds即打开的fd位图中对应的位清除&lt;br/&gt;    // 再将fd挂入下一个可使用的fd以便复用&lt;br/&gt;    __put_unused_fd(files, fd);&lt;br/&gt;    // 调用file_pointer的close方法真正清除&lt;br/&gt;    retval = filp_close(filp, files);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们看到最终是调用的filp_close方法:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int filp_close(struct file *filp, fl_owner_t id)&lt;br/&gt;{&lt;br/&gt;    // 如果存在flush方法则flush&lt;br/&gt;    if (filp-&amp;gt;f_op &amp;amp;&amp;amp; filp-&amp;gt;f_op-&amp;gt;flush)&lt;br/&gt;        filp-&amp;gt;f_op-&amp;gt;flush(filp, id);&lt;br/&gt;    // 调用fput&lt;br/&gt;    fput(filp);&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;紧接着我们进入fput:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void fastcall fput(struct file *file)&lt;br/&gt;{&lt;br/&gt;    // 对应file-&amp;gt;count--,同时检查是否还有关于此file的引用&lt;br/&gt;    // 如果没有，则调用_fput进行释放&lt;br/&gt;    if (atomic_dec_and_test(&amp;amp;file-&amp;gt;f_count))&lt;br/&gt;        __fput(file);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同一个file(socket)有多个引用的情况很常见，例如下面的例子:&lt;br/&gt;&lt;img data-ratio=&quot;0.2859848484848485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfNlgbk14xTlScDs1chVClPnoRVASuvq2nKVEIlVRiaPfS0eABvlLkC2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;所以在多进程的socket服务器编写过程中，父进程也需要close(fd)一次，以免socket无法最终关闭&lt;/p&gt;&lt;p&gt;然后就是_fput函数了:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void fastcall __fput(struct file *file)&lt;br/&gt;{&lt;br/&gt;    // 从eventpoll中释放file&lt;br/&gt;    eventpoll_release(file);&lt;br/&gt;    // 如果是release方法，则调用release&lt;br/&gt;    if (file-&amp;gt;f_op &amp;amp;&amp;amp; file-&amp;gt;f_op-&amp;gt;release)&lt;br/&gt;        file-&amp;gt;f_op-&amp;gt;release(inode, file);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于我们讨论的是socket的close,所以，我们现在探查下file-&amp;gt;f_op-&amp;gt;release在socket情况下的实现:&lt;/p&gt;&lt;h3&gt;f_op-&amp;gt;release的赋值&lt;/h3&gt;&lt;p&gt;我们跟踪创建socket的代码，即&lt;/p&gt;&lt;pre&gt;&lt;code&gt;socket(AF_INET, SOCK_STREAM, 0);&lt;br/&gt;    |-sock_create  // 创建sock&lt;br/&gt;    |-sock_map_fd  // 将sock和fd关联&lt;br/&gt;            |-sock_attach_fd&lt;br/&gt;                    |-init_file(file,...,&amp;amp;socket_file_ops);&lt;br/&gt;                            |-file-&amp;gt;f_op = fop; //fop赋值为socket_file_ops&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;socket_file_ops的实现为:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;static const struct file_operations socket_file_ops = {&lt;br/&gt;    .owner =    THIS_MODULE,&lt;br/&gt;    ......&lt;br/&gt;    // 我们在这里只考虑sock_close&lt;br/&gt;    .release =    sock_close,&lt;br/&gt;    ......&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;继续跟踪:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;sock_close&lt;br/&gt;    |-sock_release&lt;br/&gt;        |-sock-&amp;gt;ops-&amp;gt;release(sock);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上一篇博客中，我们知道sock-&amp;gt;ops为下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.4434931506849315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfIAxSDlBZzLm9WhVU9IibD6Hhaibj5e7qpiaOCbKC8e6e5ic559GZA2K2Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;即(在这里我们仅考虑tcp,即sk_prot=tcp_prot):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;inet_stream_ops-&amp;gt;release&lt;br/&gt;    |-inet_release&lt;br/&gt;            |-sk-&amp;gt;sk_prot-&amp;gt;close(sk, timeout);&lt;br/&gt;                |-tcp_prot-&amp;gt;close(sk, timeout);&lt;br/&gt;                    |-&amp;gt;tcp_prot.tcp_close&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于fd与socket的关系如下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.5472972972972973&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfibO2MeA7USX6zwdZJSQ3ficvIN7jzVwn29sgR2AfqkVkaFyibf2GqGnTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1480&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;上图中红色线标注的是close(fd)的调用链&lt;/p&gt;&lt;h3&gt;tcp_close&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;void tcp_close(struct sock *sk, long timeout)&lt;br/&gt;{&lt;br/&gt;    if (sk-&amp;gt;sk_state == TCP_LISTEN) {&lt;br/&gt;        // 如果是listen状态，则直接设为close状态&lt;br/&gt;        tcp_set_state(sk, TCP_CLOSE);&lt;br/&gt;    }&lt;br/&gt;    // 清空掉recv.buffer&lt;br/&gt;    ......&lt;br/&gt;    // SOCK_LINGER选项的处理&lt;br/&gt;    ......&lt;br/&gt;    else if (tcp_close_state(sk)){&lt;br/&gt;        // tcp_close_state会将sk从established状态变为fin_wait1&lt;br/&gt;        // 发送fin包&lt;br/&gt;        tcp_send_fin(sk);&lt;br/&gt;    }&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;四次挥手&lt;/h3&gt;&lt;p&gt;现在就是我们的四次挥手环节了，其中上半段的两次挥手下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.6488222698072805&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfHSiaNibRU3eVGNTm5WYkWKUyZIicSkUbicnvpSve9KvrZEul1V5du3hCPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;首先，在tcp_close_state(sk)中已经将状态设置为fin_wait1,并调用tcp_send_fin&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void tcp_send_fin(struct sock *sk)&lt;br/&gt;{&lt;br/&gt;    ......&lt;br/&gt;    // 这边设置flags为ack和fin&lt;br/&gt;    TCP_SKB_CB(skb)-&amp;gt;flags = (TCPCB_FLAG_ACK | TCPCB_FLAG_FIN);&lt;br/&gt;    ......&lt;br/&gt;    // 发送fin包，同时关闭nagle&lt;br/&gt;    __tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_OFF);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上图Step1所示。&lt;br/&gt;接着，主动关闭的这一端等待对端的ACK，如果ACK回来了，就设置TCP状态为FIN_WAIT2,如上图Step2所示,具体代码如下:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tcp_v4_do_rcv&lt;br/&gt;    |-tcp_rcv_state_process&lt;br/&gt;int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb, struct tcphdr *th, unsigned len)&lt;br/&gt;{&lt;br/&gt;    ......&lt;br/&gt;    /* step 5: check the ACK field */&lt;br/&gt;    if (th-&amp;gt;ack) {&lt;br/&gt;        ...&lt;br/&gt;        case TCP_FIN_WAIT1:&lt;br/&gt;            // 这处判断是确认此ack是发送Fin包对应的那个ack&lt;br/&gt;            if (tp-&amp;gt;snd_una == tp-&amp;gt;write_seq) {&lt;br/&gt;                // 设置为FIN_WAIT2状态&lt;br/&gt;                tcp_set_state(sk, TCP_FIN_WAIT2);&lt;br/&gt;                ......&lt;br/&gt;                // 设定TCP_FIN_WAIT2定时器，将在tmo时间到期后将状态变迁为TIME_WAIT&lt;br/&gt;                // 不过是这时候改的已经是inet_timewait_sock了&lt;br/&gt;                tcp_time_wait(sk, TCP_FIN_WAIT2, tmo);&lt;br/&gt;                ......&lt;br/&gt;            }&lt;br/&gt;    }&lt;br/&gt;    /* step 7: process the segment text */&lt;br/&gt;    switch(sk-&amp;gt;sk_state) {&lt;br/&gt;    case TCP_FIN_WAIT1:&lt;br/&gt;    case TCP_FIN_WAIT2:&lt;br/&gt;        ......&lt;br/&gt;    case TCP_ESTABLISHED:&lt;br/&gt;        tcp_data_queue(sk, skb);&lt;br/&gt;        queued = 1;&lt;br/&gt;        break;&lt;br/&gt;    }&lt;br/&gt;    .....&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值的注意的是，从TCP_FIN_WAIT1变迁到TCP_FIN_WAIT2之后，还调用tcp_time_wait设置一个TCP_FIN_WAIT2定时器，在tmo+(2MSL或者基于RTO计算超时)超时后会直接变迁到closed状态(不过此时已经是inet_timewait_sock了）。这个超时时间可以配置,如果是ipv4的话,则可以按照下列配置:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_fin_timeout&lt;br/&gt;/sbin/sysctl -w net.ipv4.tcp_fin_timeout=30&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.4943181818181818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEficnFqTTeicEs5X7hK6agGk8Ik3lvmA1TG1cWgNOSylqDboibhOE2b5ubg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;有这样一步的原因是防止对端由于种种原因始终没有发送fin,防止一直处于FIN_WAIT2状态。&lt;/p&gt;&lt;p&gt;接着在FIN_WAIT2状态等待对端的FIN，完成后面两次挥手:&lt;br/&gt;&lt;img data-ratio=&quot;0.488929889298893&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfrzpEa8Lvv5YnmG02iazlQY2ibsb6Wng2hib49KIocbibAmLibWhutvvhDew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1084&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;由Step1和Step2将状态置为了FIN_WAIT_2，然后接收到对端发送的FIN之后,将会将状态设置为time_wait,如下代码所示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tcp_v4_do_rcv&lt;br/&gt;    |-tcp_rcv_state_process&lt;br/&gt;        |-tcp_data_queue&lt;br/&gt;                |-tcp_fin&lt;br/&gt;static void tcp_fin(struct sk_buff *skb, struct sock *sk, struct tcphdr *th)&lt;br/&gt;{&lt;br/&gt;    switch (sk-&amp;gt;sk_state) {&lt;br/&gt;        ......&lt;br/&gt;        case TCP_FIN_WAIT1:&lt;br/&gt;            // 这边是处理同时关闭的情况&lt;br/&gt;            tcp_send_ack(sk);&lt;br/&gt;            tcp_set_state(sk, TCP_CLOSING);&lt;br/&gt;            break;&lt;br/&gt;        case TCP_FIN_WAIT2:&lt;br/&gt;            /* Received a FIN -- send ACK and enter TIME_WAIT. */&lt;br/&gt;            // 收到FIN之后，发送ACK同时将状态进入TIME_WAIT&lt;br/&gt;            tcp_send_ack(sk);&lt;br/&gt;            tcp_time_wait(sk, TCP_TIME_WAIT, 0);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;time_wait状态时，原socket会被destroy,然后新创建一个inet_timewait_sock,这样就能及时的将原socket使用的资源回收。而inet_timewait_sock被挂入一个bucket中，由&lt;br/&gt;inet_twdr_twcal_tick定时从bucket中将超过(2MSL或者基于RTO计算的时间)的time_wait的实例删除。&lt;br/&gt;我们来看下tcp_time_wait函数&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void tcp_time_wait(struct sock *sk, int state, int timeo)&lt;br/&gt;{&lt;br/&gt;    // 建立inet_timewait_sock&lt;br/&gt;    tw = inet_twsk_alloc(sk, state);&lt;br/&gt;    // 放到bucket的具体位置等待定时器删除&lt;br/&gt;    inet_twsk_schedule(tw, &amp;amp;tcp_death_row, time,TCP_TIMEWAIT_LEN);&lt;br/&gt;    // 设置sk状态为TCP_CLOSE,然后回收sk资源&lt;br/&gt;    tcp_done(sk);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体的定时器操作函数为inet_twdr_twcal_tick,这边就不做描述了&lt;/p&gt;&lt;h2&gt;被动关闭&lt;/h2&gt;&lt;h3&gt;close_wait&lt;/h3&gt;&lt;p&gt;在tcp的socket时候，如果是established状态，接收到了对端的FIN,则是被动关闭状态,会进入close_wait状态,如下图Step1所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.5347985347985348&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfibK2MZUAB9E9wym3O6mX0HE5lLvhGYBJyCW6CBjjCyVOHCghJuUFibbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1092&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;具体代码如下所示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tcp_rcv_state_process&lt;br/&gt;    |-tcp_data_queue&lt;br/&gt;static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)&lt;br/&gt;{&lt;br/&gt;    ...&lt;br/&gt;    if (th-&amp;gt;fin)&lt;br/&gt;        tcp_fin(skb, sk, th);&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们再看下tcp_fin&lt;/p&gt;&lt;pre&gt;&lt;code&gt;static void tcp_fin(struct sk_buff *skb, struct sock *sk, struct tcphdr *th)&lt;br/&gt;{&lt;br/&gt;    ......&lt;br/&gt;    // 这一句表明当前socket有ack需要发送&lt;br/&gt;    inet_csk_schedule_ack(sk);&lt;br/&gt;    ......&lt;br/&gt;    switch (sk-&amp;gt;sk_state) {&lt;br/&gt;            case TCP_SYN_RECV:&lt;br/&gt;            case TCP_ESTABLISHED:&lt;br/&gt;                /* Move to CLOSE_WAIT */&lt;br/&gt;                // 状态设置程close_wait状态&lt;br/&gt;                tcp_set_state(sk, TCP_CLOSE_WAIT);&lt;br/&gt;                // 这一句表明，当前fin可以延迟发送&lt;br/&gt;                // 即和后面的数据一起发送或者定时器到时后发送&lt;br/&gt;                inet_csk(sk)-&amp;gt;icsk_ack.pingpong = 1;&lt;br/&gt;                break;&lt;br/&gt;    }&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这边有意思的点是，收到对端的fin之后并不会立即发送ack告知对端收到了，而是等有数据携带一块发送,或者等携带重传定时器到期后发送ack。&lt;/p&gt;&lt;p&gt;如果对端关闭了，应用端在read的时候得到的返回值是0,此时就应该手动调用close去关闭连接&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if(recv(sockfd, buf, MAXLINE,0) == 0){&lt;br/&gt;    close(sockfd)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们看下recv是怎么处理fin包，从而返回0的,上一篇博客可知，recv最后调用tcp_rcvmsg,由于比较复杂，我们分两段来看:&lt;br/&gt;tcp_recvmsg第一段&lt;/p&gt;&lt;pre&gt;&lt;code&gt;        ......&lt;br/&gt;        // 从接收队列里面获取一个sk_buffer&lt;br/&gt;        skb = skb_peek(&amp;amp;sk-&amp;gt;sk_receive_queue);&lt;br/&gt;        do {&lt;br/&gt;            // 如果已经没有数据，直接跳出读取循环，返回0&lt;br/&gt;            if (!skb)&lt;br/&gt;                break;&lt;br/&gt;            ......&lt;br/&gt;            // *seq表示已经读到多少seq&lt;br/&gt;            // TCP_SKB_CB(skb)-&amp;gt;seq表示当前sk_buffer的起始seq&lt;br/&gt;            // offset即是在当前sk_buffer中已经读取的长度&lt;br/&gt;            offset = *seq - TCP_SKB_CB(skb)-&amp;gt;seq;&lt;br/&gt;            // syn处理&lt;br/&gt;            if (tcp_hdr(skb)-&amp;gt;syn)&lt;br/&gt;                offset--;&lt;br/&gt;            // 此处判断表示，当前skb还有数据可读，跳转found_ok_skb&lt;br/&gt;            if (offset &amp;lt; skb-&amp;gt;len)&lt;br/&gt;                goto found_ok_skb;&lt;br/&gt;            // 处理fin包的情况&lt;br/&gt;            // offset == skb-&amp;gt;len,跳转到found_fin_ok然后跳出外面的大循环&lt;br/&gt;            // 并返回0&lt;br/&gt;            if (tcp_hdr(skb)-&amp;gt;fin)&lt;br/&gt;                goto found_fin_ok;&lt;br/&gt;            BUG_TRAP(flags &amp;amp; MSG_PEEK);&lt;br/&gt;            skb = skb-&amp;gt;next;&lt;br/&gt;        } while (skb != (struct sk_buff *)&amp;amp;sk-&amp;gt;sk_receive_queue);&lt;br/&gt;        ......&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码的处理过程如下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.3670520231213873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfiaIciaAO0InTM3sX28K5yEf7gKwrcoeYeSHt6BgpicJFgwzQYTkbMHqdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;我们看下tcp_recmsg的第二段:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;found_ok_skb:&lt;br/&gt;        // tcp已读seq更新&lt;br/&gt;        *seq += used;&lt;br/&gt;        // 这次读取的数量更新&lt;br/&gt;        copied += used;&lt;br/&gt;        // 如果还没有读到当前sk_buffer的尽头，则不检测fin标识&lt;br/&gt;        if (used + offset &amp;lt; skb-&amp;gt;len)&lt;br/&gt;            continue;&lt;br/&gt;        // 如果发现当前skb有fin标识，去found_fin_ok&lt;br/&gt;        if (tcp_hdr(skb)-&amp;gt;fin)&lt;br/&gt;            goto found_fin_ok;&lt;br/&gt;        ......&lt;br/&gt;found_fin_ok:&lt;br/&gt;        /* Process the FIN. */&lt;br/&gt;        // tcp已读seq++&lt;br/&gt;        ++*seq;&lt;br/&gt;        ...&lt;br/&gt;        break;&lt;br/&gt;} while(len &amp;gt; 0);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由上面代码可知，一旦当前skb读完了而且携带有fin标识，则不管有没有读到用户期望的字节数量都会返回已读到的字节数。下一次再读取的时候则在刚才描述的tcp_rcvmsg上半段直接不读取任何数据再跳转到found_fin_ok并返回0。这样应用就能感知到对端已经关闭了。&lt;br/&gt;如下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.3844049247606019&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfy4tyfG7oONGGLhJyJ7JIag8qb8SgUzh4vAz2UdHOibQR7nhic3Ev7ubA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;h3&gt;last_ack&lt;/h3&gt;&lt;p&gt;应用层在发现对端关闭之后已经是close_wait状态，这时候再调用close的话，会将状态改为last_ack状态，并发送本端的fin,如下代码所示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void tcp_close(struct sock *sk, long timeout)&lt;br/&gt;{&lt;br/&gt;    ......&lt;br/&gt;    else if (tcp_close_state(sk)){&lt;br/&gt;        // tcp_close_state会将sk从close_wait状态变为last_ack&lt;br/&gt;        // 发送fin包&lt;br/&gt;        tcp_send_fin(sk);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在接收到主动关闭端的last_ack之后，则调用tcp_done(sk)设置sk为tcp_closed状态，并回收sk的资源,如下代码所示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tcp_v4_do_rcv&lt;br/&gt;    |-tcp_rcv_state_process&lt;br/&gt;int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb, struct tcphdr *th, unsigned len)&lt;br/&gt;{&lt;br/&gt;    ......&lt;br/&gt;    /* step 5: check the ACK field */&lt;br/&gt;    if (th-&amp;gt;ack) {&lt;br/&gt;        ...&lt;br/&gt;        case TCP_LAST_ACK:&lt;br/&gt;            // 这处判断是确认此ack是发送Fin包对应的那个ack&lt;br/&gt;            if (tp-&amp;gt;snd_una == tp-&amp;gt;write_seq) {&lt;br/&gt;                    tcp_update_metrics(sk);&lt;br/&gt;                    // 设置socket为closed，并回收socket的资源&lt;br/&gt;                    tcp_done(sk);&lt;br/&gt;                    goto discard;&lt;br/&gt;            }&lt;br/&gt;        ...&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码就是被动关闭端的后两次挥手了,如下图所示:&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5622641509433962&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfJqDFrzadZcH74R2rISk8D8ZfXHokc2DAXqKgQOIVPPTicxLR5mnMyDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;h3&gt;出现大量close_wait的情况&lt;/h3&gt;&lt;p&gt;linux中出现大量close_wait的情况一般是应用在检测到对端fin时没有及时close当前连接。有一种可能如下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.5744360902255639&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfogLryVmOkria1Paxsp8qEYEZBIf7KNeZ94cOp6ACQcNmx8eTsGhIrtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;当出现这种情况，通常是minIdle之类参数的配置不对(如果连接池有定时收缩连接功能的话)。给连接池加上心跳也可以解决这种问题。&lt;br/&gt;如果应用close的时间过晚，对端已经将连接给销毁。则应用发送给fin给对端，对端会由于找不到对应的连接而发送一个RST(Reset)报文。&lt;/p&gt;&lt;h3&gt;操作系统何时回收close_wait&lt;/h3&gt;&lt;p&gt;如果应用迟迟没有调用close_wait,那么操作系统有没有一个回收机制呢，答案是有的。&lt;br/&gt;tcp本身有一个包活(keep alive)定时器，在(keep alive)定时器超时之后，会强行将此连接关闭。可以设置tcp keep alive的时间&lt;/p&gt;&lt;pre&gt;&lt;code&gt;/etc/sysctl.conf&lt;br/&gt;net.ipv4.tcp_keepalive_intvl = 75&lt;br/&gt;net.ipv4.tcp_keepalive_probes = 9&lt;br/&gt;net.ipv4.tcp_keepalive_time = 7200&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;默认值如上面所示，设置的很大，7200s后超时，如果想快速回收close_wait可以设置小一点。但最终解决方案还是得从应用程序着手。&lt;br/&gt;关于tcp keepalive包活定时器可见笔者另一篇博客:&lt;br/&gt;https://my.oschina.net/alchemystar/blog/833981&lt;/p&gt;&lt;h2&gt;进程关闭时清理socket资源&lt;/h2&gt;&lt;p&gt;进程在退出时候(无论kill,kill -9 或是正常退出)都会关闭当前进程中所有的fd(文件描述符)&lt;/p&gt;&lt;pre&gt;&lt;code&gt;do_exit&lt;br/&gt;    |-exit_files&lt;br/&gt;        |-__exit_files&lt;br/&gt;            |-close_files&lt;br/&gt;                    |-filp_close&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样我们又回到了博客伊始的filp_close函数，对每一个是socket的fd发送send_fin&lt;/p&gt;&lt;h2&gt;Java GC时清理socket资源&lt;/h2&gt;&lt;p&gt;Java的socket最终关联到AbstractPlainSocketImpl,且其重写了object的finalize方法&lt;/p&gt;&lt;pre&gt;&lt;code&gt;abstract class AbstractPlainSocketImpl extends SocketImpl&lt;br/&gt;{&lt;br/&gt;    ......&lt;br/&gt;    /**&lt;br/&gt;     * Cleans up if the user forgets to close it.&lt;br/&gt;     */&lt;br/&gt;    protected void finalize() throws IOException {&lt;br/&gt;        close()&lt;br/&gt;    }&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以Java会在GC时刻会关闭没有被引用的socket,但是切记不要寄希望于Java的GC,因为GC时刻并不是以未引用的socket数量来判断的，所以有可能泄露了一堆socket,但仍旧没有触发GC。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;linux内核源代码博大精深，阅读其代码很费周折。之前读\&amp;lt;\&lt;tcp&gt;&amp;gt;的时候由于有先辈引导和梳理，所以看书中所使用的BSD源码并不觉得十分费劲。直到现在自己带着问题独立看linux源码的时候，尽管有之前的基础，仍旧被其中的各种细节所迷惑。希望笔者这篇文章能帮助到阅读linux网络协议栈代码的人。&lt;/tcp&gt;&lt;/p&gt;&lt;h2&gt;原文链接&lt;/h2&gt;&lt;p&gt;https://my.oschina.net/alchemystar/blog/1821680&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a89b61acb27efb92954c85fd93960f46</guid>
<title>资料 | 《设计数据密集型应用》中文翻译</title>
<link>https://toutiao.io/k/vnf7h38</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ccf07025dbda6d08f65e7362641e76d9</guid>
<title>[译] Kubernetes 必备工具：2021</title>
<link>https://toutiao.io/k/xbnvrk9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;figure&gt;&lt;img data-ratio=&quot;0.42&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tMghG0NOfxfs06TibdK4akquB994libe3LLAehQbmkr9UDlhvl5ul4fYT8zKVYv99tc4Rnyavg5RJIlRxvZy6Vicw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;tools&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;有别于前些天的文章 - &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5OTg2MTM0MQ==&amp;amp;mid=2247484352&amp;amp;idx=1&amp;amp;sn=352f0683e6c2f61e7336eaf5363ab011&amp;amp;scene=21#wechat_redirect&quot; title=&quot;常用的几款工具让 Kubernetes 集群上的工作更容易&quot; data-linktype=&quot;2&quot;&gt;常用的几款工具让 Kubernetes 集群上的工作更容易&lt;/a&gt; 偏重于工具类来提升工作效率，今天这篇文章更加适合用来做选型时的参考。&lt;/p&gt;&lt;p&gt;文档翻译自 &lt;span&gt;Kubernetes Essential Tools: 2021&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;，篇幅较长，做了部分增删。&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;介绍&lt;/h2&gt;&lt;p&gt;在本文中，我将尝试总结我最喜欢的 &lt;span&gt;Kubernetes&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt; 工具，并特别强调最新的和鲜为人知但我认为会非常流行的工具。&lt;/p&gt;&lt;p&gt;这只是我根据我的经验得出的个人清单，但为了避免偏见，我还将尝试提及每种工具的替代方案，以便你可以根据自己的需要进行比较和决定。我将尽可能缩短这篇文章并提供链接，以便你可以自行探索更多内容。我的目标是回答这个问题：“我如何在 Kubernetes 中做 X？” 通过描述不同软件开发任务的工具。&lt;/p&gt;&lt;h2&gt;K3D&lt;/h2&gt;&lt;p&gt;&lt;span&gt;K3D&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt; 是我最喜欢的在笔记本电脑上运行 Kubernetes (K8s) 集群的方式。它非常&lt;strong&gt;轻巧且&lt;/strong&gt;速度非常快。它是使用 &lt;strong&gt;Docker&lt;/strong&gt; 围绕 &lt;span&gt;K3S&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt; 的包装器。所以，你只需要 Docker 来运行它并且资源使用率非常低。唯一的问题是&lt;strong&gt;它不完全符合 K8s 标准&lt;/strong&gt;，但这不应该是本地开发的问题。对于测试环境，你可以使用其他解决方案。K3D 比 Kind 快，但 Kind 完全兼容。&lt;/p&gt;&lt;h3&gt;备选&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;&lt;strong&gt;K3S&lt;/strong&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/span&gt; 物联网或者边缘计算&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Kind&lt;/strong&gt;&lt;sup&gt;[6]&lt;/sup&gt;&lt;/span&gt; 完全兼容 Kubernetes 的备选&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;&lt;strong&gt;MicroK8s&lt;/strong&gt;&lt;sup&gt;[7]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;&lt;strong&gt;MiniKube&lt;/strong&gt;&lt;sup&gt;[8]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Krew&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Krew&lt;sup&gt;[9]&lt;/sup&gt;&lt;/span&gt; 是管理的必备工具 &lt;strong&gt;Kubectl 插件&lt;/strong&gt;，这是一个必须有任何 K8S 用户。我不会详细介绍超过 145 个可用&lt;span&gt;插件&lt;sup&gt;[10]&lt;/sup&gt;&lt;/span&gt;，但至少安装 &lt;span&gt;&lt;strong&gt;kubens&lt;/strong&gt;&lt;sup&gt;[11]&lt;/sup&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;strong&gt;kubectx&lt;/strong&gt;&lt;sup&gt;[12]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;h2&gt;Lens&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Lens&lt;sup&gt;[13]&lt;/sup&gt;&lt;/span&gt; 是适用于 SRE、Ops 和开发人员的 K8s &lt;strong&gt;IDE&lt;/strong&gt;。它适用于任何 Kubernetes 发行版：本地或云端。它快速、易于使用并提供实时可观察性。使用 Lens 可以非常轻松地管理多个集群。如果你是集群操作员，这是必须的。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tMghG0NOfxfs06TibdK4akquB994libe3LWqEERe7TcSUc9TAxGap9w0ane3kWTej7bwLjsADPkZZcHVGrtzwSUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;备选&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;对于那些喜欢轻量级终端替代品的人来说，&lt;span&gt;K9s&lt;sup&gt;[14]&lt;/sup&gt;&lt;/span&gt; 是一个很好的选择。K9s 会持续观察 Kubernetes 的变化，并提供后续命令来与你观察到的资源进行交互。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Helm&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Helm&lt;sup&gt;[15]&lt;/sup&gt;&lt;/span&gt; 不需要介绍，它是 Kubernetes 最著名的包管理器。你应该在 K8s 中使用包管理器，就像在编程语言中使用它一样。Helm 允许你将应用程序打包到 &lt;span&gt;Charts&lt;sup&gt;[16]&lt;/sup&gt;&lt;/span&gt; 中，将复杂的应用程序抽象为易于定义、安装和更新的可重用简单组件。&lt;/p&gt;&lt;p&gt;它还提供了强大的模板引擎。Helm 很成熟，有很多预定义的 charts，很好的支持，而且很容易使用。&lt;/p&gt;&lt;h3&gt;备选&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Kustomize&lt;/strong&gt;&lt;sup&gt;[17]&lt;/sup&gt;&lt;/span&gt; 是 helm 的一个更新和伟大的替代品，它不使用模板引擎，而是一个覆盖引擎，在其中你有基本的定义和覆盖在它们之上。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;ArgoCD&lt;/h2&gt;&lt;p&gt;我相信 &lt;span&gt;GitOps&lt;sup&gt;[18]&lt;/sup&gt;&lt;/span&gt; 是过去十年中最好的想法之一。在软件开发中，我们应该使用单一的事实来源来跟踪构建软件所需的所有移动部分，而 &lt;strong&gt;Git&lt;/strong&gt; 是做到这一点的完美工具。我们的想法是拥有一个 Git 存储库，其中包含应用程序代码以及表示所需生产环境状态的基础设施 (&lt;span&gt;IaC&lt;sup&gt;[19]&lt;/sup&gt;&lt;/span&gt;) 的声明性描述；以及使所需环境与存储库中描述的状态相匹配的自动化过程。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;GitOps: versioned CI/CD on top of declarative infrastructure. Stop scripting and start shipping.&lt;/p&gt;&lt;p&gt;— Kelsey Hightower&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;尽管使用 &lt;span&gt;Terraform&lt;sup&gt;[20]&lt;/sup&gt;&lt;/span&gt; 或类似工具，你可以实现基础设施即代码（&lt;span&gt;IaC&lt;sup&gt;[21]&lt;/sup&gt;&lt;/span&gt;），但这还不足以将你在 Git 中的所需状态与生产同步。我们需要一种方法来持续监控环境并确保没有配置漂移。使用 Terraform，你将不得不编写脚本来运行&lt;code&gt;terraform apply&lt;/code&gt;并检查状态是否与 Terraform 状态匹配，但这既乏味又难以维护。&lt;/p&gt;&lt;p&gt;Kubernetes 从头开始构建控制循环的思想，这意味着 Kubernetes 一直在监视集群的状态以确保它与所需的状态匹配，例如，运行的副本数量与所需的数量相匹配复制品。GitOps 的想法是将其扩展到应用程序，因此你可以将你的服务定义为代码，例如，通过定义 Helm Charts，并使用利用 K8s 功能的工具来监控你的应用程序的状态并相应地调整集群。也就是说，如果更新你的代码存储库或Helm Chart，生产集群也会更新。这是真正的&lt;span&gt;持续部署&lt;sup&gt;[22]&lt;/sup&gt;&lt;/span&gt;。核心原则是应用程序部署和生命周期管理应该自动化、可审计且易于理解。&lt;/p&gt;&lt;p&gt;对我来说，这个想法是革命性的，如果做得好，将使组织能够更多地关注功能，而不是编写自动化脚本。这个概念可以扩展到软件开发的其他领域，例如，你可以将文档存储在代码中以跟踪更改的历史并确保文档是最新的；或使用&lt;span&gt;ADR&lt;sup&gt;[23]&lt;/sup&gt;&lt;/span&gt;跟踪架构决策。&lt;/p&gt;&lt;p&gt;在我看来，在最好的 GitOps 工具 &lt;strong&gt;Kubernetes&lt;/strong&gt; 是 &lt;span&gt;ArgoCD&lt;sup&gt;[24]&lt;/sup&gt;&lt;/span&gt;。你可以在&lt;span&gt;此处&lt;sup&gt;[25]&lt;/sup&gt;&lt;/span&gt;阅读更多信息。ArgoCD 是 &lt;strong&gt;Argo&lt;/strong&gt; 生态系统的一部分，其中包括一些其他很棒的工具，其中一些我们将在稍后讨论。&lt;/p&gt;&lt;p&gt;使用 &lt;strong&gt;ArgoCD&lt;/strong&gt;，你可以在代码存储库中拥有每个环境，你可以在其中定义该环境的所有配置。Argo CD 在指定的目标环境中自动部署所需的应用程序状态。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9528936742934051&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tMghG0NOfxfs06TibdK4akquB994libe3LiccIibSNQicNBBUOqQjfvyIlPpKqAS07kar89lTeGqMJmrDlVVGtAsSxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;743&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;ArgoCD 被实现为一个 kubernetes 控制器，它持续监控正在运行的应用程序并将当前的实时状态与所需的目标状态（如 Git 存储库中指定的）进行比较。ArgoCD 报告并可视化差异，并且可以自动或手动将实时状态同步回所需的目标状态。&lt;/p&gt;&lt;h3&gt;备选&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Flux&lt;sup&gt;[26]&lt;/sup&gt;&lt;/span&gt; 刚刚发布了一个具有许多改进的新版本。它提供了非常相似的功能。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Argo 工作流（Workflows）和 Argo 事件（Events）&lt;/h2&gt;&lt;p&gt;在 Kubernetes 中，你可能还需要运行批处理作业或复杂的工作流。这可能是你的数据管道、异步流程甚至 CI/CD 的一部分。最重要的是，你甚至可能需要运行对某些事件做出反应的驱动微服务，例如文件上传或消息发送到队列。对于所有这些，我们有 &lt;span&gt;Argo Workflows&lt;sup&gt;[27]&lt;/sup&gt;&lt;/span&gt; 和 &lt;span&gt;Argo Events&lt;sup&gt;[28]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;尽管它们是独立的项目，但它们往往会被部署在一起。&lt;/p&gt;&lt;p&gt;Argo Workflows 是一个类似于 &lt;span&gt;Apache Airflow&lt;sup&gt;[29]&lt;/sup&gt;&lt;/span&gt; 的编排引擎，但它是 Kubernetes 原生的。它使用自定义 CRD 来定义复杂的工作流程，使用 YAML 的步骤或 &lt;strong&gt;DAG&lt;/strong&gt;，这在 K8s 中感觉更自然。它有一个漂亮的 UI、重试机制、基于 cron 的作业、输入和输出跟踪等等。你可以使用它来编排数据管道、批处理作业等等。&lt;/p&gt;&lt;p&gt;有时，你可能希望将管道与异步服务（如 &lt;strong&gt;Kafka&lt;/strong&gt; 等流引擎、队列、webhooks 或深度存储服务）集成。例如，你可能想要对上传到 S3 的文件等事件做出反应。为此，你将使用 &lt;span&gt;Argo 事件（Event）&lt;sup&gt;[30]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.666130329847144&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tMghG0NOfxfs06TibdK4akquB994libe3LlibxJYaELkic1bGRZyntsmUZ7sK3Oho8nhGMjzbv4icpics6HibJF138lUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1243&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这两个工具组合为你的所有管道需求提供了一个简单而强大的解决方案，包括 CI/CD 管道，它允许你在 Kubernetes 中本地运行 CI/CD 管道。&lt;/p&gt;&lt;h3&gt;备选&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;对于 ML 管道，你可以使用 &lt;span&gt;Kubeflow&lt;sup&gt;[31]&lt;/sup&gt;&lt;/span&gt;。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;对于 CI/CD 管道，你可以使用 &lt;span&gt;Tekton&lt;sup&gt;[32]&lt;/sup&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Kaniko&lt;/h2&gt;&lt;p&gt;我们刚刚看到了如何使用 Argo Workflows 运行 Kubernetes 原生 &lt;strong&gt;CI/CD&lt;/strong&gt; 管道。一个常见的任务是构建 &lt;strong&gt;Docker 镜像&lt;/strong&gt;，这在 Kubernetes 中通常是乏味的，因为构建过程实际上是在容器本身上运行的，你需要使用变通方法来使用主机的 Docker 引擎。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.32082551594746717&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tMghG0NOfxfs06TibdK4akquB994libe3LPJgaaG8hkBLoIQFrKVcGNd4ibtRr261d4ice4IrH0qsRKYYYDfdSiaFTg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1066&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;底线是你不应该使用 &lt;strong&gt;Docker&lt;/strong&gt; 来构建你的镜像：改用 &lt;span&gt;&lt;strong&gt;Kanico&lt;/strong&gt;&lt;sup&gt;[33]&lt;/sup&gt;&lt;/span&gt;。Kaniko 不依赖于 Docker 守护进程，而是完全在用户空间中执行 Dockerfile 中的每个命令。这使得在无法轻松或安全地运行 Docker 守护程序的环境中构建容器镜像成为可能，例如标准的 Kubernetes 集群。这消除了在 K8s 集群中构建镜像的所有问题。&lt;/p&gt;&lt;h2&gt;Istio&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Istio&lt;sup&gt;[34]&lt;/sup&gt;&lt;/span&gt; 是市场上最著名的&lt;span&gt;服务网格&lt;sup&gt;[35]&lt;/sup&gt;&lt;/span&gt;，它是开源的并且非常受欢迎。我不会详细介绍什么是服务网格，因为它是一个巨大的话题，但是如果你正在构建&lt;span&gt;微服务&lt;sup&gt;[36]&lt;/sup&gt;&lt;/span&gt;，并且可能应该这样做，那么你将需要一个服务网格来管理通信、可观察性、错误处理、安全性。与其用重复的逻辑污染每个微服务的代码（译者：SDK 侵入），不如利用服务网格为你做这件事。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9354497354497354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tMghG0NOfxfs06TibdK4akquB994libe3L3zdAnuh0b5QfzXPHDesPZOZ0R1CDRKWEe6EyhoqzBVz4fM6LKokRtg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;945&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;简而言之，服务网格是一个专用的基础设施层，你可以将其添加到你的应用程序中。它允许你透明地添加可观察性、流量管理和安全性等功能，而无需将它们添加到你自己的代码中。&lt;/p&gt;&lt;p&gt;如果 &lt;strong&gt;Istio&lt;/strong&gt; 用于运行微服务，尽管你可以在任何地方运行 Istio 并使用微服务，但 Kubernetes 已被一次又一次地证明是运行它们的最佳平台。&lt;strong&gt;Istio&lt;/strong&gt; 还可以将你的 K8s 集群扩展到其他服务，例如 VM，允许你拥有在迁移到 Kubernetes 时非常有用的混合环境。&lt;/p&gt;&lt;h3&gt;备选&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Linkerd&lt;/strong&gt;&lt;sup&gt;[37]&lt;/sup&gt;&lt;/span&gt; 是一种更轻巧且可能更快的服务网格。Linkerd 从头开始为安全性而构建，包括&lt;span&gt;默认 mTLS&lt;sup&gt;[38]&lt;/sup&gt;&lt;/span&gt;、&lt;span&gt;使用 Rust 构建的数据平面&lt;sup&gt;[39]&lt;/sup&gt;&lt;/span&gt;、&lt;span&gt;内存安全语言&lt;sup&gt;[40]&lt;/sup&gt;&lt;/span&gt;和&lt;span&gt;定期安全审计&lt;sup&gt;[41]&lt;/sup&gt;&lt;/span&gt;等功能&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Consul&lt;/strong&gt;&lt;sup&gt;[42]&lt;/sup&gt;&lt;/span&gt; 是为任何运行时和云提供商构建的服务网格，因此它非常适合跨 K8s 和云提供商的混合部署。如果不是所有的工作负载都在 Kubernetes 上运行，这是一个不错的选择。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Argo Rollouts&lt;/h2&gt;&lt;p&gt;我们已经提到，你可以使用 Kubernetes 使用 Argo Workflows 或使用 Kanico 构建图像的类似工具来运行 CI/CD 管道。下一个合乎逻辑的步骤是继续并进行持续部署。由于涉及高风险，这在真实场景中是极具挑战性的，这就是为什么大多数公司只做持续交付，这意味着他们已经实现了自动化，但他们仍然需要手动批准和验证，这个手动步骤是这是因为团队&lt;strong&gt;不能完全信任他们的自动化&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;那么，你如何建立这种信任以摆脱所有脚本并完全自动化从源代码到生产的所有内容？答案是：可观察性。你需要将资源更多地集中在指标上，并收集准确表示应用程序状态所需的所有数据。目标是使用一组指标来建立这种信任。如果你在 &lt;span&gt;Prometheus&lt;sup&gt;[43]&lt;/sup&gt;&lt;/span&gt; 中拥有所有数据，那么你可以自动部署，因为你可以根据这些指标自动逐步推出应用程序。&lt;/p&gt;&lt;p&gt;简而言之，你需要比 K8s 开箱即用的&lt;span&gt;&lt;strong&gt;滚动更新&lt;/strong&gt;&lt;sup&gt;[44]&lt;/sup&gt;&lt;/span&gt;更高级的部署技术。我们需要使用&lt;span&gt;金丝雀部署&lt;sup&gt;[45]&lt;/sup&gt;&lt;/span&gt;进行渐进式交付。目标是逐步将流量路由到应用程序的新版本，等待收集指标，分析它们并将它们与预定义的规则进行匹配。如果一切正常，我们增加流量；如果有任何问题，我们会回滚部署。要在 Kubernetes 中执行此操作，你可以使用提供 Canary 发布等的 Argo Rollouts 。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;Argo Rollouts&lt;sup&gt;[46]&lt;/sup&gt;&lt;/span&gt; 是一个 &lt;span&gt;Kubernetes 控制器&lt;sup&gt;[47]&lt;/sup&gt;&lt;/span&gt;和一组 &lt;span&gt;CRD&lt;sup&gt;[48]&lt;/sup&gt;&lt;/span&gt;，可提供高级部署功能，例如蓝绿、金丝雀、金丝雀分析、实验和向 Kubernetes 的渐进式交付功能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;尽管像 &lt;span&gt;Istio&lt;sup&gt;[49]&lt;/sup&gt;&lt;/span&gt; 这样的服务网格提供 Canary 发布，但 Argo Rollouts 使这个过程变得更加容易并且以开发人员为中心，因为它是专门为此目的而构建的。除此之外，Argo Rollouts 可以与任何服务网格集成。&lt;/p&gt;&lt;p&gt;Argo Rollouts 功能：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;蓝绿更新策略&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;金丝雀更新策略&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;细粒度、加权的流量转移&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;自动回滚和促销或人工判断&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;可定制的指标查询和业务 KPI 分析&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;入口控制器集成：NGINX、ALB&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;服务网格集成：Istio、Linkerd、SMI&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;指标提供者集成：Prometheus、Wavefront、Kayenta、Web、Kubernetes Jobs&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;备选&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Istio&lt;sup&gt;[50]&lt;/sup&gt;&lt;/span&gt; 作为 Canary 版本的服务网格。Istio 不仅仅是一个渐进式交付工具，它还是一个完整的服务网格。Istio 不会自动部署，Argo Rollouts 可以与 Istio 集成来实现这一点。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Flagger&lt;sup&gt;[51]&lt;/sup&gt;&lt;/span&gt; 与 Argo Rollouts 非常相似，并且与 &lt;span&gt;Flux&lt;sup&gt;[52]&lt;/sup&gt;&lt;/span&gt; 很好地集成在一起，因此如果你使用 Flux，请考虑使用 Flagger。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Spinnaker&lt;sup&gt;[53]&lt;/sup&gt;&lt;/span&gt; 是 Kubernetes 的第一个持续交付工具，它具有许多功能，但使用和设置起来有点复杂。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Crossplane&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Crossplane&lt;/strong&gt;&lt;sup&gt;[54]&lt;/sup&gt;&lt;/span&gt; 是我最喜欢的 K8s 工具，我对这个项目感到非常兴奋，因为它给 Kubernetes 带来了一个关键的缺失部分：像管理 K8s 资源一样管理第三方服务。这意味着，你可以使用 &lt;strong&gt;YAML&lt;/strong&gt; 中定义的 K8s 资源来配置云提供商数据库，例如 &lt;span&gt;&lt;strong&gt;AWS RDS&lt;/strong&gt;&lt;sup&gt;[55]&lt;/sup&gt;&lt;/span&gt; 或 &lt;strong&gt;GCP Cloud SQL&lt;/strong&gt;，就像你在 K8s 中配置数据库一样。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8817204301075269&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tMghG0NOfxfs06TibdK4akquB994libe3L84c8toWsUy205tnVYwb8wSCmdGqTyatVpg1jiciaAlTIk9rDTw7mMO2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;651&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;使用 Crossplane，无需使用不同的工具和方法分离基础设施和代码。&lt;strong&gt;你可以使用 K8s 资源定义一切&lt;/strong&gt;。这样，你就无需学习 &lt;span&gt;Terraform&lt;sup&gt;[56]&lt;/sup&gt;&lt;/span&gt; 等新工具并将它们分开保存。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Crossplane 是一个开源 Kubernetes 附加组件，它使平台团队能够组装来自多个供应商的基础设施，并公开更高级别的自助 API 供应用程序团队使用，而无需编写任何代码。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Crossplane&lt;/strong&gt; 扩展了你的 Kubernetes 集群，为你提供适用于任何基础架构或托管云服务的 &lt;strong&gt;CRD&lt;/strong&gt;。此外，它允许你完全实现持续部署，因为与 Terraform 等其他工具相反，Crossplane 使用现有的 K8s 功能（例如控制循环）来持续观察你的集群并自动检测任何对其起作用的配置漂移。例如，如果你定义了一个托管数据库实例并且有人手动更改它，Crossplane 将自动检测问题并将其设置回以前的值。这将实施基础设施即代码和 GitOps 原则。Crossplane 与 ArgoCD 配合使用效果很好，它可以查看源代码并确保你的代码存储库是唯一的真实来源，并且代码中的任何更改都会传播到集群以及外部云服务。如果没有 Crossplane，你只能在 K8s 服务中实现 GitOps，而不能在不使用单独进程的情况下在云服务中实现，现在你可以做到这一点，这太棒了。&lt;/p&gt;&lt;h3&gt;备选&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Terraform&lt;sup&gt;[57]&lt;/sup&gt;&lt;/span&gt; 是最著名的 IaC 工具，但它不是 K8s 原生的，需要新技能并且不会自动监视配置漂移。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Pulumi&lt;sup&gt;[58]&lt;/sup&gt;&lt;/span&gt; 是一种 Terraform 替代品，它使用开发人员可以测试和理解的编程语言工作。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Knative&lt;/h2&gt;&lt;p&gt;如果你在云中开发应用程序，你可能已经使用了一些无服务器技术，例如 &lt;span&gt;AWS Lambda &lt;sup&gt;[59]&lt;/sup&gt;&lt;/span&gt;，它是一种称为 &lt;span&gt;FaaS&lt;sup&gt;[60]&lt;/sup&gt;&lt;/span&gt; 的事件驱动范例。&lt;/p&gt;&lt;p&gt;我过去已经讨论过 &lt;span&gt;Serverless&lt;sup&gt;[61]&lt;/sup&gt;&lt;/span&gt;，因此请查看我&lt;span&gt;之前的文章&lt;sup&gt;[62]&lt;/sup&gt;&lt;/span&gt;以了解更多信息。Serverless 的问题在于它与云提供商紧密耦合，因为提供商可以为事件驱动的应用程序创建一个很好的生态系统。&lt;/p&gt;&lt;p&gt;对于 Kubernetes，如果你希望将函数作为代码运行并使用事件驱动架构，那么你最好的选择是 &lt;span&gt;Knative&lt;sup&gt;[63]&lt;/sup&gt;&lt;/span&gt;。Knative 旨在在 Kubernetes 上运行函数，在 Pod 之上创建一个抽象。&lt;/p&gt;&lt;p&gt;特点：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;针对常见应用程序用例的具有更高级别抽象的重点 API。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;在几秒钟内建立一个可扩展、安全、无状态的服务。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;松散耦合的功能让你可以使用所需的部分。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;可插拔组件让你可以使用自己的日志记录和监控、网络和服务网格。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Knative 是可移植的：在 Kubernetes 运行的任何地方运行它，不用担心供应商锁定。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;惯用的开发者体验，支持 GitOps、DockerOps、ManualOps 等常用模式。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Knative 可以与常见的工具和框架一起使用，例如 Django、Ruby on Rails、Spring 等等。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;备选&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Argo Events&lt;sup&gt;[64]&lt;/sup&gt;&lt;/span&gt; 为 Kubernetes 提供了一个事件驱动的工作流引擎，可以与 AWS Lambda 等云引擎集成。它不是 FaaS，而是为 Kubernetes 提供了一个事件驱动的架构。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;OpenFaas&lt;sup&gt;[65]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Kyverno&lt;/h2&gt;&lt;p&gt;Kubernetes 提供了极大的灵活性，以赋予敏捷的自治团队权力，但能力越大，责任越大。必须有一组&lt;strong&gt;最佳实践和规则&lt;/strong&gt;，以确保以一致且有凝聚力的方式来部署和管理符合公司政策和安全要求的工作负载。&lt;/p&gt;&lt;p&gt;有几种工具可以实现这一点，但没有一个是 Kubernetes 原生的…… 直到现在。&lt;span&gt;Kyverno&lt;sup&gt;[66]&lt;/sup&gt;&lt;/span&gt; 是为 Kubernetes 设计的策略引擎，策略作为 Kubernetes 资源进行管理，并且不需要新的语言来编写策略。Kyverno 策略可以验证、改变和生成 Kubernetes 资源。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6285714285714286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tMghG0NOfxfs06TibdK4akquB994libe3LUH27iaJj1PiaPlTwbiaOvvd7HZvGwKIK97XSg1qETYX83JhDXMjYqTDag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;你可以应用有关最佳实践、网络或安全性的任何类型的策略。例如，你可以强制所有服务都有标签或所有容器都以非 root 身份运行。你可以在&lt;span&gt;此处&lt;sup&gt;[67]&lt;/sup&gt;&lt;/span&gt;查看一些政策示例。策略可以应用于整个集群或给定的命名空间。你还可以选择是只想审核策略还是强制执行它们以阻止用户部署资源。&lt;/p&gt;&lt;h3&gt;备选&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Open Policy Agent&lt;sup&gt;[68]&lt;/sup&gt;&lt;/span&gt; 是著名的云原生基于策略的控制引擎。它使用自己的声明性语言，并且可以在许多环境中运行，而不仅仅是在 Kubernetes 上。它比 &lt;span&gt;Kyverno&lt;sup&gt;[69]&lt;/sup&gt;&lt;/span&gt; 更难管理，但更强大。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Kubevela&lt;/h2&gt;&lt;p&gt;Kubernetes 的一个问题是开发人员需要非常了解和理解平台和集群配置。许多人会争辩说 &lt;strong&gt;K8s 的抽象级别太低&lt;/strong&gt;，这会给只想专注于编写和交付应用程序的开发人员带来很多摩擦。&lt;/p&gt;&lt;p&gt;在开放式应用程序模型（&lt;span&gt;OAM&lt;sup&gt;[70]&lt;/sup&gt;&lt;/span&gt;）的设立是为了克服这个问题。这个想法是围绕应用程序创建更高级别的抽象，它独立于底层运行时。你可以在此处阅读规范。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;专注于应用程序而不是容器或协调器，开放应用程序模型 [OAM] 带来了模块化、可扩展和可移植的设计，用于使用更高级别但一致的 API 对应用程序部署进行建模。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;Kubevela&lt;sup&gt;[71]&lt;/sup&gt;&lt;/span&gt; 是 OAM 模型的一个实现。KubeVela 与运行时无关，可本地扩展，但最重要的是，以应用程序为中心 。在 Kubevela 中，应用程序是作为 Kubernetes 资源实现的一等公民。&lt;strong&gt;集群运营商（Platform Team）和开发者（Application Team）&lt;/strong&gt;是有区别的。集群操作员通过定义组件（组成应用程序的可部署/可配置实体，如 Helm Chart）和特征来管理集群和不同的环境。开发人员通过组装组件和特征来定义应用程序。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tMghG0NOfxfs06TibdK4akquB994libe3LzBLa1Ye07xgPctuGCMJe5v8QQQia3esWYVu7Nia7cShtWKbibDibtFGc0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;KubeVela 是一个&lt;span&gt;云原生计算基金会&lt;sup&gt;[72]&lt;/sup&gt;&lt;/span&gt;沙箱项目，虽然它仍处于起步阶段，但它可以在不久的将来改变我们使用 Kubernetes 的方式，让开发人员无需成为 Kubernetes 专家即可专注于应用程序。但是，我确实对 &lt;strong&gt;OAM&lt;/strong&gt; 在现实世界中的适用性有一些担忧，因为系统应用程序、ML 或大数据过程等一些服务在很大程度上依赖于低级细节，这些细节可能很难融入 OAM 模型中。&lt;/p&gt;&lt;h3&gt;备选&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Shipa&lt;sup&gt;[73]&lt;/sup&gt;&lt;/span&gt; 遵循类似的方法，使平台和开发团队能够协同工作，轻松将应用程序部署到 Kubernetes。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Snyk&lt;/h2&gt;&lt;p&gt;任何开发过程中一个非常重要的方面是安全性，这一直是 Kubernetes 的一个问题，因为想要迁移到 Kubernetes 的公司无法轻松实现其当前的安全原则。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Snyk&lt;sup&gt;[74]&lt;/sup&gt;&lt;/span&gt; 试图通过提供一个可以轻松与 Kubernetes 集成的安全框架来缓解这种情况。它可以检测容器映像、你的代码、开源项目等中的漏洞。&lt;/p&gt;&lt;h3&gt;备选&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Falco&lt;sup&gt;[75]&lt;/sup&gt;&lt;/span&gt; 是 Kubernetes 的运行时安全线程检测工具。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Velero&lt;/h2&gt;&lt;p&gt;如果你在 Kubernetes 中运行工作负载并使用卷来存储数据，则需要创建和管理备份。&lt;span&gt;Velero&lt;sup&gt;[76]&lt;/sup&gt;&lt;/span&gt; 提供简单的备份/恢复过程、灾难恢复机制和数据迁移。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.328110599078341&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tMghG0NOfxfs06TibdK4akquB994libe3LmPzFicpyHoTAaBE8CZ41gYIG1OyxS4lIGbC4DNPfFGooQPzORsXJ3CA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1085&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;与其他直接访问 Kubernetes etcd 数据库执行备份和恢复的工具不同，Velero 使用 Kubernetes API 来捕获集群资源的状态并在必要时恢复它们。此外，Velero 使你能够在配置的同时备份和恢复你的应用程序持久数据。&lt;/p&gt;&lt;h2&gt;Schema Hero&lt;/h2&gt;&lt;p&gt;软件开发中的另一个常见过程是在使用关系数据库时管理&lt;strong&gt;模式演变&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;span&gt;SchemaHero&lt;sup&gt;[77]&lt;/sup&gt;&lt;/span&gt; 是一种开源数据库架构迁移工具，可将架构定义转换为可应用于任何环境的迁移脚本。它使用 Kubernetes 声明性来管理数据库模式迁移。你只需指定所需的状态，然后 &lt;strong&gt;SchemaHero&lt;/strong&gt; 管理其余的。&lt;/p&gt;&lt;h3&gt;备选&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;LiquidBase&lt;sup&gt;[78]&lt;/sup&gt;&lt;/span&gt; 是最著名的替代品。它更难使用，且不是 Kubernetes 原生的，但它具有更多功能。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Bitnami Sealed Secrets&lt;/h2&gt;&lt;p&gt;我们已经介绍了许多 &lt;strong&gt;GitOps&lt;/strong&gt; 工具，例如 &lt;span&gt;ArgoCD&lt;sup&gt;[79]&lt;/sup&gt;&lt;/span&gt;。我们的目标是将所有内容保留在 Git 中，并使用 Kubernetes 声明性来保持环境同步。我们刚刚看到我们如何（并且应该）在 Git 中保留真实来源，并让自动化流程处理配置更改。&lt;/p&gt;&lt;p&gt;在 Git 中通常很难保留的一件事是诸如数据库密码或 API 密钥之类的秘密，这是因为你永远不应该在代码存储库中存储秘密。一种常见的解决方案是使用外部保管库（例如 &lt;span&gt;AWS Secret Manager&lt;sup&gt;[80]&lt;/sup&gt;&lt;/span&gt; 或 &lt;span&gt;HashiCorp Vault&lt;sup&gt;[81]&lt;/sup&gt;&lt;/span&gt;）来存储机密，但这会产生很多摩擦，因为你需要有一个单独的流程来处理机密。理想情况下，我们希望有一种方法可以像任何其他资源一样安全地在 Git 中存储机密。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Sealed Secrets&lt;/strong&gt;&lt;sup&gt;[82]&lt;/sup&gt;&lt;/span&gt; 旨在克服这个问题，允许你使用强加密将敏感数据存储在 Git 中。Bitnami &lt;strong&gt;Sealed Secrets&lt;/strong&gt; 本地集成在 Kubernetes 中，允许你仅通过在 Kubernetes 中运行的 Kubernetes 控制器而不是其他任何人来解密密钥。控制器将解密数据并创建安全存储的原生 K8s 机密。这使我们能够将所有内容作为代码存储在我们的 repo 中，从而允许我们安全地执行持续部署，而无需任何外部依赖。&lt;/p&gt;&lt;p&gt;Sealed Secrets 由两部分组成：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;集群端控制器&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;客户端实用程序：&lt;code&gt;kubeseal&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;该 &lt;code&gt;kubeseal&lt;/code&gt; 实用程序使用非对称加密来加密只有控制器才能解密的机密。这些加密的秘密被编码在一个 &lt;code&gt;SealedSecret&lt;/code&gt; K8s 资源中，你可以将其存储在 Git 中。&lt;/p&gt;&lt;h3&gt;备选&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;AWS Secret Manager&lt;sup&gt;[83]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;HashiCorp Vault&lt;sup&gt;[84]&lt;/sup&gt;&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Capsule&lt;/h2&gt;&lt;p&gt;许多公司使用&lt;strong&gt;多租户&lt;/strong&gt;来管理不同的客户。这在软件开发中很常见，但在 Kubernetes 中很难实现。&lt;strong&gt;命名空间&lt;/strong&gt;是将集群的逻辑分区创建为隔离切片的好方法，但这不足以安全地隔离客户，我们需要强制执行网络策略、配额等。你可以为每个名称空间创建网络策略和规则，但这是一个难以扩展的乏味过程。此外，租户将不能使用多个命名空间，这是一个很大的限制。&lt;/p&gt;&lt;p&gt;创建&lt;strong&gt;分层命名空间&lt;/strong&gt;是为了克服其中一些问题。这个想法是为每个租户拥有一个父命名空间，为租户提供公共网络策略和配额，并允许创建子命名空间。这是一个很大的改进，但它在安全和治理方面没有对租户的本地支持。此外，它还没有达到生产状态，但 1.0 版预计将在未来几个月内发布。&lt;/p&gt;&lt;p&gt;当前解决此问题的常用方法是为每个客户创建一个集群，这是安全的并提供租户所需的一切，但这很难管理且非常昂贵。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Capsule&lt;/strong&gt;&lt;sup&gt;[85]&lt;/sup&gt;&lt;/span&gt; 是一种为单个集群中的多个租户提供原生 Kubernetes 支持的工具。使用 Capsule，你可以为所有租户拥有一个集群。Capsule 将为租户提供 “几乎” 原生体验（有一些小限制），他们将能够创建多个命名空间并使用集群，因为它们完全可用，隐藏了集群实际上是共享的事实。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5364500792393027&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tMghG0NOfxfs06TibdK4akquB994libe3LvHrLsW9iaRicqdrNHdpSyvUVMMr3S3X6YfWIGuXrQMuYrQLxJr1ILhNA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1262&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;Capsule 架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在单个集群中，Capsule Controller 在称为 &lt;strong&gt;Tenant&lt;/strong&gt; 的轻量级 Kubernetes 抽象中聚合多个命名空间，这是一组 Kubernetes 命名空间。在每个租户内，用户可以自由创建他们的命名空间并共享所有分配的资源，而策略引擎则使不同的租户彼此隔离。&lt;/p&gt;&lt;p&gt;租户级别定义的网络和安全策略、资源配额、限制范围、RBAC 和其他策略由租户中的所有命名空间自动继承，类似于分层命名空间。然后用户可以自由地自治操作他们的租户，而无需集群管理员的干预。Capsule 是 GitOps 就绪的，因为它是声明性的，并且所有配置都可以存储在 Git 中。&lt;/p&gt;&lt;h2&gt;vCluster&lt;/h2&gt;&lt;p&gt;&lt;span&gt;vCluster&lt;sup&gt;[86]&lt;/sup&gt;&lt;/span&gt; 在多租户方面更进了一步，它在 Kubernetes 集群内提供了虚拟集群。每个集群都在一个常规命名空间上运行，并且是完全隔离的。虚拟集群有自己的 API 服务器和独立的数据存储，所以你在 vCluster 中创建的每个 Kubernetes 对象都只存在于 vcluster 内部。此外，您可以将 kube 上下文与虚拟集群一起使用，以像使用常规集群一样使用它们。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4987572493786247&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tMghG0NOfxfs06TibdK4akquB994libe3LLwaIVM7Ymuiahia1XckiaicNLT6Fs0dqAgibiavLtvnabMmc2xcqn5F85fxA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1207&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;只要您可以在单个命名空间内创建部署，您就可以创建虚拟集群并成为该虚拟集群的管理员，租户可以创建命名空间、安装 CRD、配置权限等等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;vCluster&lt;/strong&gt; 使用 &lt;span&gt;&lt;strong&gt;k3s&lt;/strong&gt;&lt;sup&gt;[87]&lt;/sup&gt;&lt;/span&gt; 作为其 API 服务器，使虚拟集群超轻量级且经济高效；由于 k3s 集群 100% 合规，虚拟集群也 100% 合规。&lt;strong&gt;vClusters&lt;/strong&gt; 是超轻量级的（1 个 pod），消耗很少的资源并且可以在任何 Kubernetes 集群上运行，而无需对底层集群进行特权访问。与 &lt;strong&gt;Capsule&lt;/strong&gt; 相比，它确实使用了更多的资源，但它提供了更多的灵活性，因为多租户只是用例之一。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.22486569455103608&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tMghG0NOfxfs06TibdK4akquB994libe3LRrhUPLcQ8OzUgalicUJyAUvpRaxiaicER1Q1jrW1PhQicyblrTOzic6yKYQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1303&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;其他工具&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;kube-burner&lt;sup&gt;[88]&lt;/sup&gt;&lt;/span&gt; 用于&lt;strong&gt;压力测试&lt;/strong&gt;。它提供指标和警报。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;混沌工程的 &lt;span&gt;Litmus&lt;sup&gt;[89]&lt;/sup&gt;&lt;/span&gt;。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;kubewatch&lt;sup&gt;[90]&lt;/sup&gt;&lt;/span&gt; 用于监控，但主要关注基于 Kubernetes 事件（如资源创建或删除）的推送通知。它可以与 Slack 等许多工具集成。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;BotKube&lt;sup&gt;[91]&lt;/sup&gt;&lt;/span&gt; 是一个消息机器人，用于监控和调试 Kubernetes 集群。与 kubewatch 类似，但更新并具有更多功能。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Mizu&lt;sup&gt;[92]&lt;/sup&gt;&lt;/span&gt; 是一个 API 流量查看器和调试器。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;kube-fledged&lt;sup&gt;[93]&lt;/sup&gt;&lt;/span&gt; 是一个 Kubernetes 插件，用于直接在 Kubernetes 集群的工作节点上创建和管理容器镜像的缓存。因此，&lt;strong&gt;应用程序 pod 几乎立即启动&lt;/strong&gt;，因为不需要从注册表中提取图像。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;结论&lt;/h2&gt;&lt;p&gt;在本文中，我们回顾了我最喜欢的 Kubernetes 工具。我专注于可以合并到任何 Kubernetes 发行版中的开源项目。我没有涵盖诸如 &lt;span&gt;OpenShift&lt;sup&gt;[94]&lt;/sup&gt;&lt;/span&gt; 或 Cloud Providers Add-Ons 之类的商业解决方案，因为我想让它保持通用性，但我鼓励您探索如果您在云上运行 Kubernetes 或使用商业工具，您的云提供商可以为您提供什么。&lt;/p&gt;&lt;p&gt;我的目标是向您展示您可以在 &lt;strong&gt;Kubernetes&lt;/strong&gt; 中完成您在本地所做的一切。我还更多地关注鲜为人知的工具，我认为这些工具可能具有很大的潜力，例如 &lt;span&gt;Crossplane&lt;sup&gt;[95]&lt;/sup&gt;&lt;/span&gt;、&lt;span&gt;Argo Rollouts&lt;sup&gt;[96]&lt;/sup&gt;&lt;/span&gt;或 &lt;span&gt;Kubevela&lt;sup&gt;[97]&lt;/sup&gt;&lt;/span&gt;。我更感兴趣的工具是 &lt;span&gt;vCluster&lt;sup&gt;[98]&lt;/sup&gt;&lt;/span&gt;、&lt;span&gt;Crossplane&lt;sup&gt;[99]&lt;/sup&gt;&lt;/span&gt; 和 ArgoCD/Workflows。&lt;/p&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; Kubernetes Essential Tools: 2021: &lt;em&gt;https://itnext.io/kubernetes-essential-tools-2021-def12e84c572&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; Kubernetes: &lt;em&gt;https://kubernetes.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; K3D: &lt;em&gt;https://k3d.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; K3S: &lt;em&gt;https://k3s.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[5]&lt;/code&gt; &lt;strong&gt;K3S&lt;/strong&gt;: &lt;em&gt;https://k3s.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[6]&lt;/code&gt; &lt;strong&gt;Kind&lt;/strong&gt;: &lt;em&gt;https://kind.sigs.k8s.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[7]&lt;/code&gt; &lt;strong&gt;MicroK8s&lt;/strong&gt;: &lt;em&gt;https://microk8s.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[8]&lt;/code&gt; &lt;strong&gt;MiniKube&lt;/strong&gt;: &lt;em&gt;https://minikube.sigs.k8s.io/docs/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[9]&lt;/code&gt; Krew: &lt;em&gt;https://krew.sigs.k8s.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[10]&lt;/code&gt; 插件: &lt;em&gt;https://krew.sigs.k8s.io/plugins/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[11]&lt;/code&gt; &lt;strong&gt;kubens&lt;/strong&gt;: &lt;em&gt;https://github.com/ahmetb/kubectx&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[12]&lt;/code&gt; &lt;strong&gt;kubectx&lt;/strong&gt;: &lt;em&gt;https://github.com/ahmetb/kubectx&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[13]&lt;/code&gt; Lens: &lt;em&gt;https://k8slens.dev/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[14]&lt;/code&gt; K9s: &lt;em&gt;https://k9scli.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[15]&lt;/code&gt; Helm: &lt;em&gt;https://helm.sh/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[16]&lt;/code&gt; Charts: &lt;em&gt;https://artifacthub.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[17]&lt;/code&gt; &lt;strong&gt;Kustomize&lt;/strong&gt;: &lt;em&gt;https://kustomize.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[18]&lt;/code&gt; GitOps: &lt;em&gt;https://www.gitops.tech/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[19]&lt;/code&gt; IaC: &lt;em&gt;https://en.wikipedia.org/wiki/Infrastructure_as_Code&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[20]&lt;/code&gt; Terraform: &lt;em&gt;https://www.terraform.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[21]&lt;/code&gt; IaC: &lt;em&gt;https://en.wikipedia.org/wiki/Infrastructure_as_code&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[22]&lt;/code&gt; 持续部署: &lt;em&gt;https://en.wikipedia.org/wiki/Continuous_deployment&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[23]&lt;/code&gt; ADR: &lt;em&gt;https://github.com/jamesmh/architecture_decision_record&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[24]&lt;/code&gt; ArgoCD: &lt;em&gt;https://argoproj.github.io/argo-cd/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[25]&lt;/code&gt; 此处: &lt;em&gt;https://argoproj.github.io/argo-cd/core_concepts/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[26]&lt;/code&gt; Flux: &lt;em&gt;https://fluxcd.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[27]&lt;/code&gt; Argo Workflows: &lt;em&gt;https://argoproj.github.io/argo-workflows/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[28]&lt;/code&gt; Argo Events: &lt;em&gt;https://argoproj.github.io/argo-events/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[29]&lt;/code&gt; Apache Airflow: &lt;em&gt;https://airflow.apache.org/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[30]&lt;/code&gt; Argo 事件（Event）: &lt;em&gt;https://argoproj.github.io/argo-events/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[31]&lt;/code&gt; Kubeflow: &lt;em&gt;https://www.kubeflow.org/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[32]&lt;/code&gt; Tekton: &lt;em&gt;https://tekton.dev/docs/pipelines/pipelines/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[33]&lt;/code&gt; &lt;strong&gt;Kanico&lt;/strong&gt;: &lt;em&gt;https://github.com/GoogleContainerTools/kaniko&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[34]&lt;/code&gt; Istio: &lt;em&gt;https://istio.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[35]&lt;/code&gt; 服务网格: &lt;em&gt;https://en.wikipedia.org/wiki/Service_mesh&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[36]&lt;/code&gt; 微服务: &lt;em&gt;https://microservices.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[37]&lt;/code&gt; &lt;strong&gt;Linkerd&lt;/strong&gt;: &lt;em&gt;https://linkerd.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[38]&lt;/code&gt; 默认 mTLS: &lt;em&gt;https://linkerd.io/2.10/features/automatic-mtls/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[39]&lt;/code&gt; 使用 Rust 构建的数据平面: &lt;em&gt;https://github.com/linkerd/linkerd2-proxy&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[40]&lt;/code&gt; 内存安全语言: &lt;em&gt;https://github.com/linkerd/linkerd2-proxy&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[41]&lt;/code&gt; 定期安全审计: &lt;em&gt;https://github.com/linkerd/linkerd2/blob/main/SECURITY_AUDIT.pdf&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[42]&lt;/code&gt; &lt;strong&gt;Consul&lt;/strong&gt;: &lt;em&gt;https://www.consul.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[43]&lt;/code&gt; Prometheus: &lt;em&gt;https://prometheus.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[44]&lt;/code&gt; &lt;strong&gt;滚动更新&lt;/strong&gt;: &lt;em&gt;https://www.educative.io/blog/kubernetes-deployments-strategies&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[45]&lt;/code&gt; 金丝雀部署: &lt;em&gt;https://semaphoreci.com/blog/what-is-canary-deployment&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[46]&lt;/code&gt; Argo Rollouts: &lt;em&gt;https://kubernetes.io/docs/concepts/architecture/controller/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[47]&lt;/code&gt; Kubernetes 控制器: &lt;em&gt;https://kubernetes.io/docs/concepts/architecture/controller/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[48]&lt;/code&gt; CRD: &lt;em&gt;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[49]&lt;/code&gt; Istio: &lt;em&gt;https://istio.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[50]&lt;/code&gt; Istio: &lt;em&gt;https://istio.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[51]&lt;/code&gt; Flagger: &lt;em&gt;https://flagger.app/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[52]&lt;/code&gt; Flux: &lt;em&gt;https://fluxcd.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[53]&lt;/code&gt; Spinnaker: &lt;em&gt;https://spinnaker.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[54]&lt;/code&gt; &lt;strong&gt;Crossplane&lt;/strong&gt;: &lt;em&gt;https://crossplane.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[55]&lt;/code&gt; &lt;strong&gt;AWS RDS&lt;/strong&gt;: &lt;em&gt;https://aws.amazon.com/rds/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[56]&lt;/code&gt; Terraform: &lt;em&gt;https://www.terraform.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[57]&lt;/code&gt; Terraform: &lt;em&gt;https://www.terraform.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[58]&lt;/code&gt; Pulumi: &lt;em&gt;https://www.pulumi.com/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[59]&lt;/code&gt; AWS Lambda : &lt;em&gt;https://aws.amazon.com/lambda/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[60]&lt;/code&gt; FaaS: &lt;em&gt;https://en.wikipedia.org/wiki/Function_as_a_service&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[61]&lt;/code&gt; Serverless: &lt;em&gt;https://en.wikipedia.org/wiki/Serverless_computing&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[62]&lt;/code&gt; 之前的文章: &lt;em&gt;https://itnext.io/scaling-my-app-serverless-vs-kubernetes-cdb8adf446e1&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[63]&lt;/code&gt; Knative: &lt;em&gt;https://itnext.io/scaling-my-app-serverless-vs-kubernetes-cdb8adf446e1&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[64]&lt;/code&gt; Argo Events: &lt;em&gt;https://argoproj.github.io/argo-events/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[65]&lt;/code&gt; OpenFaas: &lt;em&gt;https://www.openfaas.com/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[66]&lt;/code&gt; Kyverno: &lt;em&gt;https://kyverno.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[67]&lt;/code&gt; 此处: &lt;em&gt;https://github.com/kyverno/policies/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[68]&lt;/code&gt; Open Policy Agent: &lt;em&gt;https://www.openpolicyagent.org/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[69]&lt;/code&gt; Kyverno: &lt;em&gt;https://kyverno.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[70]&lt;/code&gt; OAM: &lt;em&gt;https://oam.dev/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[71]&lt;/code&gt; Kubevela: &lt;em&gt;https://kubevela.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[72]&lt;/code&gt; 云原生计算基金会: &lt;em&gt;https://cncf.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[73]&lt;/code&gt; Shipa: &lt;em&gt;https://www.shipa.io/getting-started/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[74]&lt;/code&gt; Snyk: &lt;em&gt;https://snyk.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[75]&lt;/code&gt; Falco: &lt;em&gt;https://falco.org/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[76]&lt;/code&gt; Velero: &lt;em&gt;https://velero.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[77]&lt;/code&gt; SchemaHero: &lt;em&gt;https://schemahero.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[78]&lt;/code&gt; LiquidBase: &lt;em&gt;https://www.liquibase.org/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[79]&lt;/code&gt; ArgoCD: &lt;em&gt;https://argoproj.github.io/argo-cd/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[80]&lt;/code&gt; AWS Secret Manager: &lt;em&gt;https://aws.amazon.com/secrets-manager/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[81]&lt;/code&gt; HashiCorp Vault: &lt;em&gt;https://www.vaultproject.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[82]&lt;/code&gt; &lt;strong&gt;Sealed Secrets&lt;/strong&gt;: &lt;em&gt;https://github.com/bitnami-labs/sealed-secrets&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[83]&lt;/code&gt; AWS Secret Manager: &lt;em&gt;https://aws.amazon.com/secrets-manager/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[84]&lt;/code&gt; HashiCorp Vault: &lt;em&gt;https://www.vaultproject.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[85]&lt;/code&gt; &lt;strong&gt;Capsule&lt;/strong&gt;: &lt;em&gt;https://github.com/clastix/capsule&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[86]&lt;/code&gt; vCluster: &lt;em&gt;https://www.vcluster.com/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[87]&lt;/code&gt; &lt;strong&gt;k3s&lt;/strong&gt;: &lt;em&gt;https://k3s.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[88]&lt;/code&gt; kube-burner: &lt;em&gt;https://github.com/cloud-bulldozer/kube-burner&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[89]&lt;/code&gt; Litmus: &lt;em&gt;https://github.com/litmuschaos/litmus&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[90]&lt;/code&gt; kubewatch: &lt;em&gt;https://github.com/bitnami-labs/kubewatch&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[91]&lt;/code&gt; BotKube: &lt;em&gt;https://www.botkube.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[92]&lt;/code&gt; Mizu: &lt;em&gt;https://getmizu.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[93]&lt;/code&gt; kube-fledged: &lt;em&gt;https://github.com/senthilrch/kube-fledged&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[94]&lt;/code&gt; OpenShift: &lt;em&gt;https://www.openshift.com/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[95]&lt;/code&gt; Crossplane: &lt;em&gt;https://crossplane.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[96]&lt;/code&gt; Argo Rollouts: &lt;em&gt;https://kubevela.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[97]&lt;/code&gt; Kubevela: &lt;em&gt;https://kubevela.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[98]&lt;/code&gt; vCluster: &lt;em&gt;https://www.vcluster.com/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[99]&lt;/code&gt; Crossplane: &lt;em&gt;https://crossplane.io/&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c0bb86e4c77ddfc3c5e658996778a1bc</guid>
<title>本地生活综合性需求图谱的构建及应用</title>
<link>https://toutiao.io/k/mz1bk58</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一、背景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;二、解决方案&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;三、实现方法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.1 行业体系层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.2 需求对象层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.3 具象需求层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.4 场景要素层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.5 场景需求层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;四、应用实践&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;五、总结展望&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、背景&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1 业务现状&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以“帮大家吃得更好，生活更好”为使命，美团覆盖了外卖、餐饮、酒店、民宿、旅游、门票、电影/演出、休闲/玩乐、丽人、医疗、亲子、教育、结婚、生活服务等数百个行业，满足数以亿计用户的多样化生活服务需求。为了持续增加平台价值，除了推动用户和商户在数量和质量上的不断提升之外，更高效地匹配用户需求和商户供给也是重要抓手之一。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了提升匹配的效率，我们需要更充分、深入地理解用户需求和商户供给，并且尝试从用户视角出发来组织和管理供给。当前，“行业-类目-商户-商品”是一种较为常见的供给组织和管理方式，然而随着业务和行业的快速发展，这种组织方式带来的痛点日渐突显，举例来说：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;部分指向性不明确的用户需求，较难得到适合的匹配结果。例如“周末陪宝宝去哪儿玩？”由于平台的匹配结果不理想，用户往往只能在线下完成类目决策，决定带宝宝去农家乐烧烤，再到平台上搜索相应的农家乐团购。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;部分需求跨多个类目，匹配过程不够流畅。例如“周末和朋友去哪里放松一下？”用户在线下完成类目决策后，可选类目包括KTV、酒吧、密室、桌游等，但各类目的承载页面相互独立，用户需要在承载页面间来回切换。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在部分指向明确的类目中，用户仍然难以找到满足自己需求的供给。例如在医美类目下，因为缺乏相关知识，用户往往并不了解商户提供的形形色色的服务项目分别具有什么功效，适合什么部位，应该使用什么材料，无法高效地找到适合自己的服务供给。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上述问题的本质原因在于供给的组织方式主要是从行业视角出发，没有充分考虑到用户视角。在当前以满足用户需求为首要目标的市场环境下，我们需要迭代完善现有的供给组织方式。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2 问题解析&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决上述问题，我们尝试从一个外部视角，结合第一性原理去进行剖析。在整个人类社会中，按照马斯洛需求层次&lt;sup&gt;[1]&lt;/sup&gt;的理论，人的需求是可以被归纳及分层的。如果将人类社会看作一个系统，人类在其中一个称为“市场”的子系统中，通过交易来满足自己的需求。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;人类从需求层次出发，在市场中完成交易，最终需求得以满足，那么在市场中交易的过程可以被拆解为“起心动念-&amp;gt;考虑-&amp;gt;选择评估-&amp;gt;交易购买-&amp;gt;履约/服务”。并且，经由前三个阶段，用户的需求逐渐从粗粒度演变为细粒度，从抽象过渡到具象。下面将结合具体的例子来进行解读：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;需求层次&lt;/strong&gt;：在马斯洛需求层次中有一个情感层次，对应了人类丰富多样的情感需求，包含亲情、友情、爱情等等。作为一个母亲，与自己的宝宝之间往往存在一种强烈的母子情，并且希望不断去强化这种情感。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;起心动念&lt;/strong&gt;：为此，母亲往往都会尽力花较多的时间去陪伴宝宝。通过增加陪伴方式的维度，变为“陪宝宝玩”；通过增加时间、空间等维度，变为“周末陪宝宝去哪儿玩？”&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;考虑&lt;/strong&gt;：对于上述问题，母亲会找出很多种方案，比如户外烧烤、农家采摘、主题公园等等。当她决定选用户外烧烤这一方案时，便会转化为具体的商品需求，如购买烤架。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;评估选择&lt;/strong&gt;：母亲于是在可触达的供给范围中进行选择。正如人们常说的货比三家，选择的依据会各不相同，如价格、质量、口碑等等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;交易购买&lt;/strong&gt;：当完成选择之后，母亲便会进行交易，以换取商品或服务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;履约服务&lt;/strong&gt;：即商品到货、完成服务等等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;市场是人类社会的一个子系统，电商平台则是市场中的一个子系统。同时，电商平台是一种线上化的子系统，它提供了搜索、推荐等形式的供给检索能力。当前的一个现状是：用户往往在线下完成了“起心动念”到“考虑”的过程，转化为具体的商品/服务需求，随后进入电商平台完成“选择评估”到“履约服务”的后续过程（&lt;/span&gt;&lt;span&gt;如下图1所示&lt;/span&gt;&lt;span&gt;）。而电商平台往往聚焦于后三个阶段的能力提升，容易忽略前两个阶段。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6717948717948717&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAicjVCdAOubRspdQo5MZJNU4hygD0hw6QNEu3fUOpHDe6SBU5D04o3ibMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 1&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，用户较难形成在平台上完成“起心动念”和“考虑”的心智，而大部分电商平台按“行业-类目-商户-商品”的方式对供给进行组织和管理。最终，用户和电商平台之间形成了一种相互掣肘的关系。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;事实上，相对于“烤架”这种明确的商品需求，用户还有很多抽象的、模糊的、不明确的需求，依然停留在前两个阶段。例如，周末陪宝宝去哪儿玩？周末和朋友去哪里放松一下？结婚前怎样才能让自己变得更美？暑假如何培养孩子的动手能力？同时，这样的需求往往跨越多个类目，或者在同类目下存在多种选择。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;电商平台只有打破既有的掣肘关系，向用户提供前两个阶段（&lt;/span&gt;&lt;span&gt;起心动念、考虑&lt;/span&gt;&lt;span&gt;）的能力，才能进一步满足用户的需求。用户的决策成本进一步降低，决策过程更加连贯，用户体验也能得到相应的提升，同时用户在市场中的交易过程也能够进一步实现线上化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以“行业-类目-商户-商品”作为参考，&lt;strong&gt;如果电商平台能够识别出用户在前两个阶段的需求，并且在其和供给之间建立新的关联关系，辅以搜索、推荐等检索能力，用户便有可能在线上完成前两个阶段&lt;/strong&gt;。而知识图谱作为一种揭示实体之间关系的语义网络，用以解决上述问题显得尤为合适。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、解决方案&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 解决思路&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;延续1.2中的例子，这位母亲将“周末陪宝宝去哪儿玩？”的需求转化为具体的“户外烧烤”需求，延伸至更为具体的“烤架”和“农家乐团购”需求。此时，母亲便会分别前往各类实物电商平台以及以美团为代表的生活服务电商平台进行“选择评估”。两种电商平台分别在实物供给池或服务供给池中采用搜索、推荐之类的召排技术定位到具体的商品/服务，并反馈给这位母亲。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于1.2中的所述，技术团队期望达成的目的，目前比较有代表性的参考案例是阿里巴巴电商认知图谱AliCoCo&lt;sup&gt;[2]&lt;/sup&gt;。它基本构建思路是从用户视角出发，先进行各种类型的原子词挖掘，再进一步对原子词进行组合和挖掘出相关候选短语，再从中识别出真实的用户需求，最后关联至相应的供给。它的层次结构如图2所示：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;分类层&lt;/strong&gt;：构建完备的分类体系，包含了的大千世界的各种分类，既有通用的空间、时间等类别，也有电商中涉及的颜色、功能以及最为重要的品类等类别。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;原子概念层&lt;/strong&gt;：在分类层诸多类别的基础上进行扩展，包含了各种类别下的原子概念（&lt;/span&gt;&lt;span&gt;例如空间-&amp;gt;户外、事件-&amp;gt;烧烤、时间-&amp;gt;圣诞节、颜色-&amp;gt;红色、功能-&amp;gt;保暖、品类-&amp;gt;连衣裙&lt;/span&gt;&lt;span&gt;）及原子概念之间的关系。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;电商概念层&lt;/strong&gt;：在原子概念层之上，包含了由原子概念组成或直接挖掘的短语粒度的用户购物需求，即电商概念（&lt;/span&gt;&lt;span&gt;例如户外烧烤&lt;/span&gt;&lt;span&gt;），从而将用户购物需求显式地用一个符合自然语言的短语表示。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;商品层&lt;/strong&gt;：包含了商品与各种原子概念、电商概念之间的关联关系（&lt;/span&gt;&lt;span&gt;例如户外烧烤-&amp;gt;烤架、黄油、锡纸&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.525035765379113&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAicO1Fqs1zUNqx7N2N7hEw7MbTjNT4uG8Z7JETKusibVmANiaVF8Tu9NLbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1398&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 2&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于上述图谱，这位母亲可以直接在天猫上表达“户外烧烤”的需求，而非更具体的“烤架”；天猫也会将烤架以外其他和户外烧烤相关的重要商品反馈给这位母亲。从对应关系来看，AliCoCo的电商概念层对应至“考虑”阶段，商品层对应至“选择评估”阶段。显然，由于AliCoCo的存在，天猫能够从“考虑”阶段开始介入用户的交易过程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由此推论，我们应该可以将图谱构建得更为完整，以覆盖“起心动念”阶段。在此阶段，人类的需求，按马斯洛需求层次，通过增加一个或多个维度约束，而被逐渐具象化。对于这样的维度约束，我们统称为“场景约束”。因此，我们将“考虑”阶段对应的需求称为“具象需求”；将“起心动念”阶段对应的需求称为“场景需求”。为此，我们希望构建一个&lt;strong&gt;本地生活综合性需求图谱（GENE：&lt;strong&gt;lifestyle &lt;strong&gt;GE&lt;/strong&gt;neral &lt;strong&gt;NE&lt;/strong&gt;eds net&lt;/strong&gt;）&lt;/strong&gt;，如下图3所示。对于本地生活场景下所涉及的数百个综合性行业，我们认为新的供给组织方式更能贴近用户需求，也是从用户视角去解决供需匹配的问题。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48046230049532196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAicw3Sv8cQcDPfwpnUxOzMUeYsMnzAVSWHgjj6ecSq5EzD85TMsSZ6DeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1817&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 3&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2 具体方案&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;延续2.1中的构建思路，我们尝试构建一套多层次的图谱结构，并将“具象需求”和“场景需求”拆分为独立的层次，既避免了两种类型的需求合在同一层级中而引起混淆，又能对用户场景化的需求进行更详尽的拆解、更丰富的刻画。本地生活综合性需求图谱（&lt;/span&gt;&lt;span&gt;GENE&lt;/span&gt;&lt;span&gt;），主要由六部分构成，包含场景需求层、场景要素层、具象需求层、需求对象层、行业体系层和供给层，如下图4所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;286&quot; data-ratio=&quot;0.53604568165596&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVr2YQEnJOlA9vRMeZPsShNZ98grQJCGHdZUmxHlVcTNC386hk7Brq5VS8bG7Ednb5ic4OWzqQsIeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2802&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 4&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在场景需求层，我们用Human-Readable的短句来表征场景化的用户需求，如“国庆节陪3岁宝宝去哪玩”、“结婚前让自己变得更美”、“小学生提升思维能力”等。一个场景需求的表述中，通常会包含人物、目的、时间、空间、方式等要素，以“国庆节陪3岁宝宝去哪玩”为例，“3岁宝宝”是人物，“陪宝宝玩”是目的，“国庆节”是时间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在场景要素层，为了更好地表达场景需求，我们将这些短句进行拆解，细化成多个细粒度的词汇，用这些词汇对场景需求中的人物、目的、时间、空间、方式等要素进行完整的覆盖和系统的组织，我们将其称为“场景要素”。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在具象需求层，由于场景需求的表述往往并不显式地指向某个具体的服务/供给，而是隐含了一批潜在的适合这一场景的服务/供给。例如，在“国庆节陪3岁宝宝去哪玩”这个例子中，户外烧烤、喂羊驼、玩滑梯、骑小马等都是适合这一场景需求的具体服务。所以我们需要将所有这些具体的服务通过短语的形式显式的展现出来，这些短语直接反应了用户具体的服务需求，被称之为“具象需求”。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在需求对象层，为了进一步的理解具象需求，我们将具象需求分为具体的服务需求所对应的对象，我们称之为“需求对象”，以及该服务中用户和对象之间的交互行为。例如，对于具象需求喂羊驼，可以分为羊驼（&lt;/span&gt;&lt;span&gt;需求对象&lt;/span&gt;&lt;span&gt;）和喂（&lt;/span&gt;&lt;span&gt;服务交互&lt;/span&gt;&lt;span&gt;），由于本地生活服务的多样性，围绕羊驼这一需求对象，除了喂羊驼外，还可以产生触摸羊驼、骑羊驼和看羊驼表演等多种具象需求。这一层除了包含需求对象节点外，也会涵盖需求对象的属性信息，以对需求对象进行更详尽地描述。例如对于具象需求户外烧烤，可分为烧烤（&lt;/span&gt;&lt;span&gt;需求对象&lt;/span&gt;&lt;span&gt;）、户外（&lt;/span&gt;&lt;span&gt;需求对象属性&lt;/span&gt;&lt;span&gt;）和体验（&lt;/span&gt;&lt;span&gt;隐含的服务交互&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在行业体系层，由于用户的场景需求和具象需求往往会跨越多个传统的服务类目，为了给用户需求确定一个具体的业务范围，我们还需要构建出各行业涉及的类目体系，作为上述各层构建的业务基础。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在供给层，包含内容这类虚拟供给和商户与商品这类实体供给，这些供给将会和具象需求和场景需求等节点进行关联，从而为用户需求提供相对应的供给支撑。例如，一个提供户外烧烤的供给将会关联上具象需求“户外烧烤”，并进一步关联上场景需求“国庆节陪3岁宝宝去哪玩”。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;综上所述，在本地生活综合性需求图谱中，用户场景化的需求和具体的服务需求被分别表达成短句级别的场景需求和短语级别的具象需求。这两种需求分别通过场景要素和需求对象进行表达。最后，不同类型的供给都会和场景需求和具象需求相关联，从而以用户需求为纽带，提升供给和用户的匹配效率。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、实现方法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当前，本地生活综合性需求图谱已经初步涵盖了用户在玩乐、医美和教育三个本地生活相关行业中的多元化需求。我们在图谱的构建过程中，自底向上按照行业体系层、需求对象层、具象需求层、场景要素层、场景需求层的顺序逐层进行构建，并将各层的节点与各种类型的供给建立关联关系。下文将以玩乐行业为例，对图谱每一层的构建细节以及涉及的算法进行介绍。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 行业体系层&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.1 行业类目树的构建&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在玩乐行业中，行业体系层包含了能够提供玩乐服务的类目，类目信息通过一个树形结构来表征。由于玩乐行业体系的构建，对专家知识的要求非常高，并且这部分的设计对后续各层的知识挖掘至关重要，因此我们没有直接进行人工定义，而是以当前我们成熟的行业类目树为基础，通过对其进行剪枝和分裂来构建。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先在类目树中筛选出和玩乐相关的一级类目节点，包括“休闲娱乐”、“亲子”、“旅游”、“餐饮”等。对于每个一级类目，我们进一步筛选其和玩乐相关的下一级类目直至叶子类目，并剪去与玩乐无关的类目。此外，我们还对剪枝后的类目树中可以细分的玩乐相关的叶子类目进行分裂，例如将“洗浴”细分为“私汤”、“洗浴中心”等，最终得到完整的玩乐行业类目树。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.2 类目的供给关联&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;确定了类目树后，我们还需要获取实体供给（&lt;/span&gt;&lt;span&gt;商户和商品&lt;/span&gt;&lt;span&gt;）和虚拟供给（&lt;/span&gt;&lt;span&gt;内容，例如UGC&lt;/span&gt;&lt;span&gt;）与类目的从属关系，从而为后续的一系列挖掘提供数据支持。由于商品和内容均可链接到商户，所以我们只需要获取商户与类目的从属关系即可。玩乐类目树是对我们已有的类目进行剪枝和分裂得到的，除了分裂出的新类目外，其余类目和商户的关系均可直接继承原有的结果。对于新分裂的类目，我们则需要重新构建商户和其之间的从属关系。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要判断一个商户属于哪个类目，最直观的依据就是商户名、商品名及商品详情，然而很多商户的商户名和商品包含的信息往往较少，增加了类目判别的难度。为了确保商户类目判别的准确性，我们引入更多的商户信息，包括商户UGC和商户画像，设计了一个多源异构数据融合判别模型，整体模型结构如下图5所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4819855884707766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAich2Ht7UbL3RPZ6dHhKvJDcL6rgKiabzegpUOjHVyHnxftWKlHVpkZFfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2498&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 5&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中，不同来源数据的特征提取和处理方式如下：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;商户名、商品名及商品详情：均为文本数据，直接通过BERT&lt;sup&gt;[3]&lt;/sup&gt;提取文本特征后输出。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;商户UGC：由于商户的UGC往往数量非常多，为了对其信息进行有效利用，首先通过Doc2Vec&lt;sup&gt;[4]&lt;/sup&gt;的方式进行Encode得到UGC的特征后，再通过一个Self-Attention&lt;sup&gt;[5]&lt;/sup&gt;模块进行特征处理后输出。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;商户画像：转成One-Hot特征后，通过全连接层进行非线性映射后输出。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上述三种特征相连接后进行融合，通过全连接层和softmax层实现最终的类目判别。基于多源数据的融合建模，商户信息得到了充分利用。以洗浴细分类目为例，仅利用商户名、商品名及商品详情数据，基于BERT判别，准确率为92%，而基于多源融合模型判别后，准确率提升到98%。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 需求对象层&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在需求对象层，我们希望能够挖掘出玩乐行业体系中各类目涉及的玩乐对象词作为该层的节点，这些词能够描述出用户在实际玩乐过程中的交互对象，这是用于组成具象玩乐需求的基础。为了确保玩乐对象挖掘的全面性，我们采用多源多方法的形式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在数据上，我们采用来自商户和用户的相关文本作为挖掘语料。在方法上，我们采用两种方式来挖掘玩乐对象词：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一种是无监督的扩充，在开始挖掘前运营会首先根据经验，提供一些玩乐对象词作为种子输入，我们提前利用语料构建无监督的Skip-Gram结构的Word2Vec模型，对业务输入的种子词提取词向量，并结合余弦相似度，快速扩充相关的对象词。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二种是有监督的标注，我们将其定义序列标注问题，采用基于BERT+CRF的模型，在语料中自动识别出新的对象词。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在实践过程中，为了更高效的挖掘，我们将无监督环节扩充和质检后的对象词在语料中进行文本匹配，并将匹配结果转化为有监督标注环节的训练样本；同时对于有监督标注的结果，经过运营质检后，也会将其作为无监督扩充的输入，通过两个环节相结合，我们完成玩乐对象的挖掘，完整流程如下图6所示。此外，在运营人工审核玩乐对象词的过程中，对于一些业务已知的核心玩乐对象，也会直接输入业务侧已经沉淀的相关特征作为其属性，进一步完善玩乐对象的信息，例如对于“剧本杀”这一玩乐对象，增加相应的“实景”和“桌面”等类型属性。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5195266272189349&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAicTUaZgFoJ9Ty6jYapKR7gx5gIwul7s6lO1Nca99X2ksjjXe7kL84qog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1690&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 6&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在获取对象词后，我们还需要知道对象词属于哪个类目，以便下一步的具象需求挖掘及供给关联，为此我们构建对象词和类目之间的关系。通过各类目下的语料文本中提及对象词的次数来衡量两者关系，是最直观且准确率最高的方法。因此，我们直接使用对象词在每个类目下的语料中进行文本匹配，通过词频高低来确定关系。同时，我们进一步构建对象词之间的上下位和同义关系，当前常见的有通过投影和分类（&lt;/span&gt;&lt;span&gt;如BERT句间关系模型&lt;/span&gt;&lt;span&gt;）等方法来进行关系判别等有监督方法。在实际过程中，我们采用规则辅助人工的方式，基于对象词的统计特征及Pattern共现的结果指导人工快速完成构建。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 具象需求层&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.1 具象需求挖掘&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;具象需求层可以看成是用户在玩乐行业中的具体服务需求的集合，每个具象玩乐需求是该层的一个节点，由玩乐对象叠加用户与对象之间的多元化的交互行为及对象描述信息得到，它通过短语的形式表达出用户对于玩乐服务供给的本质诉求。具体玩乐需求挖掘的流程流程可以分为两个步骤：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;候选短语生成&lt;/strong&gt;：围绕玩乐对象词，生成大量包含玩乐对象的短语，作为具象玩乐需求候选集。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;短语质量判别&lt;/strong&gt;：建立一个语义判别模型从候选集中提取真实的具象玩乐需求。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;候选短语生成&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在步骤1中，首先我们以需求对象词为核心，采用与玩乐对象挖掘相同的语料，进行候选短语的生成。常用的短语挖掘算法如AutoPhrase&lt;sup&gt;[6]&lt;/sup&gt;，是以Ngram来进行短语组合，而这种形式对于有需求对象的短语显得过于冗余，所以我们考虑基于句法结构来进行短语挖掘。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了使生成短语符合句法的要求，我们以预设的句法关系为模板进行挖掘。在大规模语料中为了更高效地挖掘句法关系，我们基于更轻便的ELECTRA&lt;sup&gt;[7]&lt;/sup&gt;预训练模型获取句子各成分的Embedding后，再利用BiAffine&lt;sup&gt;[8]&lt;/sup&gt;预测其句法关系。通过依存句法分析，我们在各个类目的语料中挖掘出包含相应的玩乐对象且符合句法关系的短语。此外，需求对象层中对象的属性也会被用作对象描述进行短语生成。最终所有挖掘的短语，经过词频等统计特征粗筛后将作为具象玩乐需求的候选集，挖掘示例如图7(a)所示。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34945054945054943&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAicdPssqe4FmGh98AuxF0t2P54Sicey9kjJuK04pcAysJWOAaXycpGdgvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1820&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 7&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;短语质量判别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在步骤2中，经过步骤1获取的候选集短语虽然符合预设的句法关系，但是从语义上仍然存在大量与用户实际需求不符的表述，通过抽检分析我们发现符合要求的短语不足10%。如何从海量的候选短语中挑选出反映真实的用户具象玩乐需求的短语成为亟需解决的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AutoPhrase通过基于短语统计特征的判别模型进行短语打分，然而仅通过统计特征难以识别语义质量低的短语，为此我们进一步基于统计和语义特征联合建模，构建一个Wide&amp;amp;Deep&lt;sup&gt;[9]&lt;/sup&gt;结构的判别模型，对候选集合中的短语是否为具象玩乐需求进行判别，我们希望判别模型能过滤掉大量的低质短语，从而为运营节省大量的人力成本。判别模型的整体结构如图7(b)所示，其中：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Wide部分，提取候选短语的全局和上下文的统计特征，通过全连接层进行非线性映射后输出。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Deep部分，提取候选短语的深度语义特征，通过BERT完成相应特征的提取后输出。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上述Wide和Deep部分输出的特征相连接后进行融合，优势互补，经过全连接层和softmax层来实现最终的短语判别。在实践过程中，除了直接使用已经积累的短语标签作为正样本外，我们还通过预设一些常识性的Pattern从候选集中构造正样本，例如观赏[植物]、触摸[动物]，并对候选集采样构造负样本，完成初版模型的训练，之后结合主动学习，经过多轮迭代，模型最终达到92%的召回率和85%的准确率。通过质量判别后保留的短语则会交由运营人工审核提炼后成为最终的具象玩乐需求。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.2 具象需求的供给关联&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在具象需求层中，由于具象玩乐需求是由玩乐对象得到的，所以两者之间天然地建立了对应关系。而对于具象玩乐需求之间的上下位和同义关系，则可以基于其对象之间的关系及其句法关系，在人工审核的环节来辅助人工完成构建。除此之外，更重要的是需要将具象玩乐需求与实体供给（&lt;/span&gt;&lt;span&gt;商户和商品&lt;/span&gt;&lt;span&gt;）及虚拟供给（&lt;/span&gt;&lt;span&gt;内容，例如UGC&lt;/span&gt;&lt;span&gt;）进行关联。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们将这个问题抽象为一个语义匹配的问题，通过具象玩乐需求与其对应的类目的供给的文本信息进行匹配来实现，其中，商户使用商户名文本信息，商品使用商品名和商品详情文本信息，UGC使用其自身文本信息。由于UGC和商品属于商户的一部分，所以具象玩乐需求与UGC/商品的关系也会加入其与商户关系的构建中。整体匹配流程如下图8所示，我们首先进行具象玩乐需求与UGC/商品的匹配，在此基础上再结合商户名文本的匹配结果，一起通过规则聚合后关联到商户。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34247967479674796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAic7CIMeH3UJibFzSqNXZKgUcDy67Fa47OCqLPC7SOEqS6FriaLIy3TlqKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1968&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 8&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于具象玩乐需求数量众多，同时供给的文本信息通常包含多个子句，出于效率和效果的平衡考虑，我们将匹配过程分为了召回和排序两个阶段。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在召回阶段，我们粗筛出和具象玩乐需求可能有潜在关联的子句。对于具象玩乐需求，我们基于构建的同义关系，扩展具象需求的同义标签，并将其与子句文本进行粗粒度Pattern匹配，对于匹配中的子句则将进入到排序阶段进行精细化的关联关系计算。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在排序阶段，我们构建基于BERT句间关系分类的语义匹配模型，通过在BERT后增加全连接层和softmax层来实现分类。模型通过对召回阶段得到的粗筛样本进行预测，识别两者在语义上的匹配关系（&lt;/span&gt;&lt;span&gt;关联/不关联&lt;/span&gt;&lt;span&gt;）。最终供给关联关系的平均召回率和准确率分别达到90%和95%。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4 场景要素层&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.1 场景要素拆解&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;场景要素层包含了组成用户场景化需求的场景要素。如文初提及，要描述一个场景，需要交代特定的人物、时间、空间、目的等要素。例如，对于“国庆节陪3岁宝宝去哪儿玩？”这个场景化需求，我们可做如下拆解：时间-国庆节，人物-3岁宝宝，目的-亲情陪伴（&lt;/span&gt;&lt;span&gt;陪宝宝玩&lt;/span&gt;&lt;span&gt;）。所以我们按照上述方式，对场景要素进行拆解，以期对场景要素的挖掘和梳理尽可能的全面与系统。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.2 场景要素挖掘&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;完成了场景要素拆解后，下一步就是要分别在每个拆解的类别中进行场景要素的挖掘。场景要素作为具象需求的场景化的信息，往往来自于用户的直观感受，所以挖掘的语料我们选择与具象玩乐需求关联的UGC的上下文语料。与需求对象挖掘的方法类似，我们将每个类别的已提炼总结的场景要素作为种子词，通过相关要素扩充和序列标注的方式完成场景要素的挖掘。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;确定场景要素后，接下来的关键是完成场景要素与具象玩乐需求的关系构建，即对于每个场景要素，找出其适合的具象玩乐需求，如春季适合观赏樱花、孩子适合亲近动物。我们通过对UGC文本分析后发现，UGC中用户说到某一具象玩乐需求的同时，往往也会交代一些相关的场景要素信息，所以我们继续选择与具象玩乐需求关联的UGC的上下文语料，作为关系构建的数据来源。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最初我们采用基于Pattern的方法，通过归纳可用于判断场景要素和具象玩乐需求关系的Pattern，从语料中直接抽取包含两者的文本。但由于用户表达的多样性，不仅准确率无法保证，同时有限的Pattern也影响了召回，因此我们进一步尝试使用基于模型判别的方法提升泛化性，完善关系的构建。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4351145038167939&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAicYLlugKSWhj6wnIN3gQ7DntJDnChVxLEngaoJp3SdwHgIlPI8MYf0Zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2358&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 9&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于我们使用的语料中的具象玩乐需求是已知的，如果将场景要素看成是具象玩乐需求的属性，那么问题就可以看成是一个属性级（&lt;/span&gt;&lt;span&gt;Aspect-Based&lt;/span&gt;&lt;span&gt;）的分类问题。参考属性级情感分类的做法&lt;sup&gt;[10]&lt;/sup&gt;，我们通过预设句子模板的方式，结合场景要素和具象玩乐需求构造出辅助句子，将属性级分类转换为一个类QA的句对分类问题。例如，对于已经关联了“喂羊驼”这一具象玩乐需求的某个语料：“这个周六我们到农家乐喂了羊驼”，其中一个辅助句子为“周末适合喂羊驼”。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们采用BERT句间关系分类模型来实现句对分类，如图9所示。辅助句子与语料文本通过[SEP]相连后输入模型进行判别，模型输出判别结果（&lt;/span&gt;&lt;span&gt;适合/不适合&lt;/span&gt;&lt;span&gt;）。最后我们根据在所有语料上的关系提取结果，对每个场景要素和具象需求之间的关系进行投票计算评分后来确定两者的关系。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.5 场景需求层&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.5.1 场景需求组装&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在场景需求层，我们会将场景要素层和具象需求层的信息进行组装，从而生成大量的场景需求。组装出的场景需求，既可能仅含场景要素，如“国庆节陪3岁宝宝去哪儿玩？”不含任何具象需求，又可以同时包含场景要素和具象需求，如“周末去郊外摘草莓”中，周末、郊外是场景要素，摘草莓是具象需求。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.5.2 场景需求判别&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于组装得到的场景需求，最重要的是保证其合理性，例如“周末”和“亲子”就是合理的玩乐场景，而“闺蜜”和“亲子”则是矛盾的玩乐场景。为此，我们首先需要计算场景要素之间的关系评分，从而指导场景需求的组装。场景要素只有依托具象需求，搭配上适合的玩法，参与组装的场景需求才有意义。因此，对于场景要素之间的合理关系构建，我们尝试以场景要素和具象需求的关系得分作为依据，通过关系传递评估两个场景要素之间的相关性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在3.4.2节中，我们已经量化了场景要素和具象需求之间的关系评分，一个最直观的想法是通过场景要素-具象需求-场景要素的关系传递来进行计算场景要素之间关系的计算。如图10(a)所示，以具象需求“喂羊驼”为纽带，可以获取“亲子”和“闺蜜”两个场景要素的关系得分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们首先构建场景要素和具象需求的关系评分矩阵，考虑到玩法数量满足长尾分布的情况，对矩阵进行具象需求维度的列归一化处理，同时为了保证场景要素-场景要素矩阵的自相关系数为1，对归一化后的场景要素-具象需求矩阵进行L2行范数归一化处理，因此该归一化矩阵与自身转置的矩阵乘得到的新矩阵即可作为场景要素-场景要素的关系评分矩阵。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33192567567567566&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAicUCWDbroibaY08HMIo6kbtiaO5nicOW0acFlh9PdEicAmzlU3FiawhZKJg2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2368&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 10&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过上述方法可以很快得到场景要素之间的关系评分，然而该方法仅以场景要素-具象需求-场景要素的关系传递模式，计算场景要素在具象需求上的直接共指强弱，导致场景要素关系的覆盖不足。为此，我们扩展为更长的节点关系链传递模式，这种节点之间的传递关系是服从马尔可夫性质的，如图10(b)所示。但是随着传递路径的增长，计算成本会呈指数级增长。所以我们采用强化学习&lt;sup&gt;[11]&lt;/sup&gt;中的One-Step时序差分方法进行求解，以“累计回报的期望最大化”的概念作为节点的价值，以场景要素节点集合作为强化学习概念中的状态空间，具象需求节点集合作为动作空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如当我们处在“亲子”场景要素这个状态下，可以通过选择“喂羊驼”或者“角色扮演”来跳转到下一个状态“闺蜜”或“户外”。该状态跳转过程的决策函数，根据当前场景要素状态关联的所有具象需求中随机抽取一个具象需求节点作为决策行为，抽取概率与得分正相关；状态转移概率则为在该具象需求节点决策下，随机跳转到与之相关联的场景要素，跳转概率与得分正相关。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同时，对于特定的互斥关系，我们根据实际的业务应用需求制定奖励矩阵实现多样化的场景要素关系评分模型。这样我们将节点关系传递模型转化为了马尔可夫决策模型，结合贝尔曼最优原理推导出的价值迭代表达式和节点对关系得分预测公式，如图10(c)所示。根据图示的公式，在保持策略不变的前提下采用自举迭代的思想计算节点的价值，并进一步计算场景要素之间的关系评分，既能够保证更充分的利用已有的关系网络信息，提高关系覆盖，又能通过奖励矩阵的约束关系降低互斥关系的影响，灵活适应不同业务的需求。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后基于场景要素之间的关系评分，我们从组装的场景需求集合中选择评分高的场景需求，并根据预设的模板生成最终的场景需求表达，例如“周末和朋友放松”、“和闺蜜一起玩”、“国庆节带孩子户外烧烤好去处”。这些场景需求通过其包含的场景要素/具象玩乐需求，可以链接到相应的具象玩乐需求，进而关联相关的供给，从而给用户提供场景化玩乐的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四、应用实践&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本地生活综合性需求图谱，涵盖了用户的场景需求和具象需求，一方面更前置地参与用户决策，在“起心动念”、“考虑”、“选择评估”等多个阶段影响用户，降低其决策成本，另一方面，提供更多样化的供给选择，高效地进行供需匹配。应用方式上，应用于搜索、推荐等各类业务形态。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;经过近一年的建设，当前综合性需求图谱包含数十万核心具象需求和场景需求节点，以及数千万的关系，并在美团的亲子、休闲娱乐、医美、教育培训等多个业务进行了初步的应用实践，下面举例介绍具体的应用方式和应用效果。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 亲子&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;亲子原频道页用户需求和供给之间匹配效率低下，其中ICON按照亲子传统类目划分，无法满足用户不同类型的需求（&lt;/span&gt;&lt;span&gt;图11(a)左&lt;/span&gt;&lt;span&gt;），而底部猜喜的供给形态单一，且体现用户需求的优质供给不足，决策信息不足（&lt;/span&gt;&lt;span&gt;图11(b)左&lt;/span&gt;&lt;span&gt;），因此对亲子频道页进行改版。为了贴合亲子的业务特色，我们将亲子玩乐相关的需求节点和关系，应用于频道改版后的多个流量位，为其提供标签和供给数据的支撑。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;224&quot; data-ratio=&quot;1.1496746203904555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVsG7TewiaUngCltfx0tabDkCbdqLMr9C0nk0LMHON14iaMMVbWAsdhCjfYFrqUDeQ9LPZKvmRIt2Kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 11&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中，对于ICON，基于高频的场景和具象需求，跨类目生成需求ICON，如“亲近动物”、“带娃泡汤”等（&lt;/span&gt;&lt;span&gt;图11(a)中&lt;/span&gt;&lt;span&gt;）及相应二级页（&lt;/span&gt;&lt;span&gt;图11(a)右&lt;/span&gt;&lt;span&gt;），这些ICON包含了原本多个类目中的相似需求，在用户“考虑”阶段为其提供决策信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于底部推荐，我们围绕亲子玩乐的具象需求进行供给优化，将其关联的内容作为优质供给进行推荐，并为每个供给提取包含相应具象需求的文本，作为推荐理由外露，这些句子从用户实际需求的角度展示信息，极大地吸引了用户（&lt;/span&gt;&lt;span&gt;图11(b)右&lt;/span&gt;&lt;span&gt;）。此外，还进一步根据浏览和交易行为，以供给为媒介建立具象需求与用户的关联关系，应用于个性化推荐的召回和排序的优化。改版后的亲子频道页，满足了用户多样化的推荐需求，极大地改善了用户体验。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 休闲娱乐&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在休闲娱乐频道页，我们围绕场景需求和具象需求进行了一系列应用。一方面，基于玩乐的场景需求组织新的场景ICON，如满足用户户外游玩的“踏青赏花”、满足用户在室内潮流玩乐的“室内潮玩”、满足喜欢晚上玩乐用户的“夜生活”、满足和朋友同事聚会玩乐的“团建聚会”，这些ICON从用户场景化的玩乐出发，打破了传统类目的限制，让用户和供给的匹配更加流畅，每个ICON的二级页面则会展示每个场景的具象玩法需求及关联的商户和内容。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;另一方面，在频道页场景导航模块中，尝试利用场景需求来进一步展示场景化的玩乐信息，包括“一人乐”、“家庭暖”、“过生日”等十多个玩乐场景主题，并针对这些场景的具象需求关联的商户进行推荐。这些场景化的应用（&lt;/span&gt;&lt;span&gt;图12(a)&lt;/span&gt;&lt;span&gt;），在“起心动念”阶段即作用于用户，提升了用户的决策效率。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;187&quot; data-ratio=&quot;1.1717391304347826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVsG7TewiaUngCltfx0tabDk7SbFwm4C5vn2sc2e6oUMtVMsl5fL2p5I6mibGqt9EAHHdl0aBfP4EJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 12&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，部分具象需求经过改写可以直接用于相应类目的列表页商户的快筛，例如实景剧本杀/桌面剧本杀，换装/汉服体验/撸宠必去/飞行模拟等（&lt;/span&gt;&lt;span&gt;图12(b)左和中&lt;/span&gt;&lt;span&gt;），而我们在行业体系层中类目的细分结果，亦可以成为商户的快筛，例如洗浴类目的细分（&lt;/span&gt;&lt;span&gt;图12(b)右&lt;/span&gt;&lt;span&gt;），这些快筛的应用，更加方便了用户选店。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;五、总结展望&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在本地生活服务中，如何不断提高供给和用户之间的匹配效率，是摆在我们面前的一道难题。我们尝试以用户关注对象为切入点，通过深挖用户需求并以其为纽带来关联供给和用户。为了全方位挖掘和理解用户需求，我们努力探索并尝试构建本地生活综合性需求图谱，以行业体系层、需求对象层、具象需求层、场景要素层、场景需求层的顺序逐层构建，并为各种类型的供给建立关联关系。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前，综合性需求图谱的结果可应用于搜索、推荐等各类业务形态，并已在美团多个业务场景中取得实践成果。不过，我们还处在探索的初级阶段，接下来还有很长的迭代之路要走，在此我们提出一些后续的思考和展望：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;更广的行业覆盖&lt;/strong&gt;：一方面加深对已有的玩乐、医美和教育行业的建设，挖掘更多的节点和关系，更好的理解用户需求；一方面向丽人、结婚等更多的行业进行横向覆盖；此外还将进一步扩展到用户决策的全链路，构建服务体验图谱，覆盖履约服务环节，分析其中的用户需求和反馈，更好地赋能商家提升用户体验。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;更多的数据引入&lt;/strong&gt;：当前图谱的构建主要是以平台的用户和商户的文本语料为主，下一步将利用图像等更多模态的数据，并尝试引入外部的知识，对当前的节点和关系进行完善和补充。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;更深的图谱应用&lt;/strong&gt;：现阶段图谱在搜索和推荐上的实践主要集中在标签及其关联供给的直接应用，后续考虑进一步深化图谱的应用，充分利用场景需求和场景要素的信息，为推荐侧更准的用户意图识别提供支撑，从而提升供给和用户的匹配效率，发挥出知识图谱更大的价值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;[1] Maslow A H. A theory of human motivation[J]. Psychological review, 1943, 50(4): 370.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[2] Luo X, Liu L, Yang Y, et al. AliCoCo: Alibaba e-commerce cognitive concept net[C]. Proceedings of the 2020 ACM SIGMOD International Conference on Management of Data. 2020: 313-327.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[3] Devlin J, Chang M W, Lee K, et al. Bert: Pre-training of deep bidirectional transformers for language understanding[J]. arXiv preprint arXiv:1810.04805, 2018.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[4] Le Q, Mikolov T. Distributed representations of sentences and documents[C]. International conference on machine learning. PMLR, 2014: 1188-1196.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[5] Vaswani A, Shazeer N, Parmar N, et al. Attention is all you need[J]. arXiv preprint arXiv:1706.03762, 2017.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[6] Shang J, Liu J, Jiang M, et al. Automated phrase mining from massive text corpora[J]. IEEE Transactions on Knowledge and Data Engineering, 2018, 30(10): 1825-1837.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[7] Clark K, Luong M T, Le Q V, et al. Electra: Pre-training text encoders as discriminators rather than generators[J]. arXiv preprint arXiv:2003.10555, 2020.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[8] Dozat T, Manning C D. Deep biaffine attention for neural dependency parsing[J]. arXiv preprint arXiv:1611.01734, 2016.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[9] Cheng H T, Koc L, Harmsen J, et al. Wide &amp;amp; deep learning for recommender systems[C]. Proceedings of the 1st workshop on deep learning for recommender systems. 2016: 7-10.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[10] Sun C, Huang L, Qiu X. Utilizing BERT for aspect-based sentiment analysis via constructing auxiliary sentence[J]. arXiv preprint arXiv:1903.09588, 2019.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[11] Sutton R S, Barto A G. Reinforcement learning: An introduction[J]. 2011.&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;李翔、陈焕、志伟、晓阳、艳婷、旭乐、曹臻等，均来自美团到店平台技术部到综业务数据团队。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3cce115194fc0c78f4c95caf11dc2b69</guid>
<title>Chrome 的下一代 Web 渲染架构：RenderingNG</title>
<link>https://toutiao.io/k/6f2vuza</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;近日，&lt;code&gt;Chris Harrelson&lt;/code&gt;（Blink 渲染引擎负责人）在 &lt;code&gt;Chrome&lt;/code&gt; 官方博客介绍了 &lt;code&gt;Chrome&lt;/code&gt; 下一代渲染架构：RenderingNG。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2021 年， &lt;code&gt;RenderingNG&lt;/code&gt; 的架构的设计、构建和交付过程即将完成，它是真正的下一代渲染架构，大大超越了之前的架构。&lt;code&gt;RenderingNG&lt;/code&gt; 已经开发了至少八年，它为下一代快速、流畅、可靠、响应迅速和交互式的 Web 带来了无限潜力。它为开发人员可以依赖的所有 Web 渲染引擎定义了一个新的最低标准。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9202200825309491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aDoYvepE5x33xcewvt7mNFzlkmbIU8unlowyHhr56bicd7QPJeYbEAKjxtdPIJ5IP5s0fPG3Icia4rCh0n4dTqgg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1454&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;核心特点&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;具有跨平台、设备、操作系统的核心功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;具有可预测和可靠的性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最大化使用硬件功能（CPU，GPU，屏幕分辨率，刷新率，低级栅格化 API）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只执行显示可见内容所需的工作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内置对通用视觉设计、动画和交互设计模式的支持。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为开发者提供 API 轻松管理渲染开销。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为开发者插件提供渲染管线扩展点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他优化项：HTML，CSS，2D Canvas，3D canvas，images，video 和 fonts。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Gecko&lt;/code&gt; 和 &lt;code&gt;Webkit&lt;/code&gt; 也实现了这些博客文章中描述的大部分架构特性，某些甚至在 &lt;code&gt;Chromium&lt;/code&gt; 之前就已经实现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这很棒！虽然任何一个浏览器变得更快、更可靠都值得庆祝，但我们的最终目标是提高所有浏览器的基线，让开发人员可以依赖它，这是之前任何一个渲染引擎没有想过的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;理念&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;RenderingNG&lt;/code&gt; 的理念是首先实现可靠性的结果，然后是可扩展的性能，最后是可扩展性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.456875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aDoYvepE5x33xcewvt7mNFzlkmbIU8unoYZD4w90oRuATTpxv1SrXZNVOCFibl7xodCLwicYak8Bn7MArxuHNO1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;稳定性&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5336134453781513&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aDoYvepE5x33xcewvt7mNFzlkmbIU8unc0nvVp18pESicSmQeId4YnHpZ3Rqyas5ic93N2AoW14nUib0svXYdFMHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1428&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;满足丰富复杂的用户体验的前提就是提供一个坚如磐石的平台。所有的核心功能和基础都必须正常工作，并且能在长时间的情况下稳定运行。同样重要的是，这些功能组合得很好并且没有奇怪的边界错误（这里有内涵到😅）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6064441887226697&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aDoYvepE5x33xcewvt7mNFzlkmbIU8unrjQtDZWmtOicPFQDhtwI4O1Ro2mdIpnIX0jSn04zWVenCgBspicic594g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1738&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，稳定性是 RenderingNG 最重要的部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了说明稳定性的重要性，&lt;code&gt;Chromium&lt;/code&gt; 团队花了过去八年的大部分时间来解决这个问题。首先，他们建立了对系统的深入了解 —— 从漏洞报告中学习并修复这些弱点，进行综合测试，了解站点的性能需求和 &lt;code&gt;Chromium&lt;/code&gt; 性能局限性。然后他们仔细地设计并推出了关键的设计模式和数据结构。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40425531914893614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aDoYvepE5x33xcewvt7mNFzlkmbIU8unUbekWibA1YpiaPXwk8CyMHckf8bP44G1rdDJvzkSOppVIvvtJzmjx7oA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1504&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;测试和指标&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在过去的 8 年中，&lt;code&gt;Chromium&lt;/code&gt; 团队添加了数以万计的单元、性能和集成测试。此外，他们还开发了全面的指标来衡量 Chromium 渲染在本地测试、性能基准测试以及在真实网站上使用真实用户和设备的许多方面的表现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是无论 &lt;code&gt;RenderingNG&lt;/code&gt;（或其他浏览器的渲染引擎，就此而言）有多么出色，如果浏览器之间存在大量错误或行为差异，那么我们做 Web 开发的仍然不容易。为了解决这个问题，他们还最大限度地使用了 Web 平台测试。这些测试中的每一个都验证了所有浏览器都应该通过的网络平台的使用模式。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.518125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aDoYvepE5x33xcewvt7mNFzlkmbIU8unv8aYNQicZseicj5P0SqIjvIfyqObwuibkCrw7k0rYvrHY7QHNlLIibLKRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可扩展的性能&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在速度、内存和功耗方面实现出色的性能是 &lt;code&gt;RenderingNG&lt;/code&gt; 的下一个最重要的方面。我们希望与所有网站的交互顺畅且响应迅速，同时又不牺牲设备的稳定性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 &lt;code&gt;RenderingNG&lt;/code&gt; 不只是想要性能，更想要可扩展的性能 — 一种在低端和高端机器上以及跨操作系统平台上都可靠地运行良好的架构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这称之为向上扩展 — 利用硬件设备可以实现的所有功能，然后向下扩展 — 在需要时最大限度地提高效率并减少对系统的需求。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6410998552821997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aDoYvepE5x33xcewvt7mNFzlkmbIU8unqQBNSt5x1JSrlIM03VwQEKiae9nCKhJIlLWDr5k2x1AvTIcKfqcmsfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1382&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为此， &lt;code&gt;RenderingNG&lt;/code&gt; 需要最大限度地利用缓存、性能隔离和 GPU 硬件加速。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在动态、交互式 UI 平台（如 Web）中，缓存是显着提高性能的唯一最重要的方式。浏览器中最著名的缓存类型是 HTTP 缓存，但渲染也有很多缓存。滚动最重要的缓存是缓存的 GPU 纹理和显示列表，它允许非常快的滚动，同时最大限度地减少电池消耗并在各种设备上运行良好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存有助于滚动的电池寿命和动画帧率，但更重要的是它可以解除与主线程的性能隔离。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;性能隔离&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在现代计算机上，你永远不必担心后台应用程序会减慢你正在使用的程序的速度。这是因为抢占式多任务处理，这反过来又是一种性能隔离形式：确保独立任务不会相互减慢速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Web 上，性能隔离的最佳示例就是滚动。即使在具有大量慢速的 &lt;code&gt;JavaScript&lt;/code&gt; 的网站上，滚动也可以非常流畅，因为它运行在不同的线程上，而不必依赖于 &lt;code&gt;JavaScript&lt;/code&gt; 和渲染线程。 &lt;code&gt;RenderingNG&lt;/code&gt; 会确保每一个可能的滚动都是线程化的，通过缓存，远远超出显示列表到更复杂的情况。示例包括表示固定和粘性定位元素的代码、被动事件监听器和高质量的文本渲染。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5634218289085545&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aDoYvepE5x33xcewvt7mNFzlkmbIU8un89mzjE0QQ4a7mjgmicFnGbx8V6RalibxbnGgamTldiasYQA06HFuz6MeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1356&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;GPU加速&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GPU 显着加快了生成像素和绘制到屏幕的速度 — 在很多情况下，每个像素都可以与其他每个像素并行绘制，从而大大提高了速度。&lt;code&gt;RenderingNG&lt;/code&gt; 的一个关键组件是 &lt;code&gt;GPU&lt;/code&gt; 光栅和随处绘制。这在所有平台和所有设备上使用 &lt;code&gt;GPU&lt;/code&gt; 来超加速 &lt;code&gt;Web&lt;/code&gt; 内容的渲染和动画。这在低端设备或非常高端的设备上非常重要，这些设备通常比设备的其他部分具有更强大的 GPU。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6294027565084227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aDoYvepE5x33xcewvt7mNFzlkmbIU8unPkSk2qbYwrINWhqIrCVOzPOPakGpvDW0QibwpMuMIeZXyaQqaZvICpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1306&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可扩展性&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;RenderingNG&lt;/code&gt; 已经有了非常好的稳定性和可扩展的性能，另外它还对开发非常友好，它可以很好的帮助我们扩展 &lt;code&gt;HTML&lt;/code&gt;、&lt;code&gt;CSS&lt;/code&gt; 和 &lt;code&gt;Canvas&lt;/code&gt; 的内置部分，并且不会牺牲任何性能和稳定性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这包括用于响应式设计、渐进式渲染、平滑度和响应性以及线程渲染的的高级用例的内置 &lt;code&gt;API&lt;/code&gt; 和暴露于 &lt;code&gt;JavaScript&lt;/code&gt; 的 &lt;code&gt;API&lt;/code&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;content-visibility&lt;/code&gt;: 允许站点轻松避免屏幕外内容的渲染，并为当前未显示的单页应用提供视图缓存渲染。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7005141388174807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aDoYvepE5x33xcewvt7mNFzlkmbIU8unjdibezSumJvfiacVCJ6icM6Ye4LuicDaOLEJc39QgEomSnCRAwXliaa5fcg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1556&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;OffscreenCanvas&lt;/code&gt;: 允许画布渲染（2D 画布 API 和 WebGL）在其自己的线程上运行，大大提升性能。这个项目也是 Web 的另一个重要里程碑 — 它是第一个允许 &lt;code&gt;JavaScript&lt;/code&gt;（或 &lt;code&gt;WebAssembly&lt;/code&gt;）从多个线程渲染单个网页文档的 Web API。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Container queries&lt;/code&gt;: 新的响应式布局架构&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6596794081381011&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aDoYvepE5x33xcewvt7mNFzlkmbIU8uneia5qtjW2B1ZB6Ec18xYHBibLpwyib8icaxbJhIo3iaYyFVVYLibZ0LXd7qA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1622&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Origin isolation&lt;/code&gt;: 允许站点在 iframe 之间选择更多的性能隔离。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Off-main-thread paint worklets&lt;/code&gt;: 通过在合成器线程上运行的代码，为开发人员提供了一种扩展元素绘制方式的方法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.678125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aDoYvepE5x33xcewvt7mNFzlkmbIU8un0bt2lB3yjUtibu6ic5IqJTYJQwnibSFHM1Fx8ZUup5G61yuGLnOHW2Pog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;除了显式的 &lt;code&gt;Web API&lt;/code&gt; 之外，&lt;code&gt;RenderingNG&lt;/code&gt; 还为我们提供了几个非常重要的自动功能，这对所有站点是默认生效的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;站点隔离：将跨域 iframe 放在不同的 CPU 进程中，以获得更好的安全性和性能隔离。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Vulkan、D3D12 和 Metal：利用比 OpenGL 更有效地使用 GPU 的低级 API。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更多合成动画：SVG，背景颜色。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;参考：&lt;span&gt;https://developer.chrome.com/blog/renderingng&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NDAzMjE5NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/aDoYvepE5x2LRUFlGccgWM7pibyfHFibKOp7r5ecialTR0hwcUdfXhYAPibUbYJ0VibnZS27BolMNukPspZx3ibUDiblg/0?wx_fmt=png&quot; data-nickname=&quot;code秘密花园&quot; data-alias=&quot;code_mmhy&quot; data-signature=&quot;一个优质的前端号，基础、框架、算法、项目、面试...   总有你想要的。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;抖音前端正急缺人才，如果你想加入我们，欢迎加我微信和我联系。另外如果你想加入前端、面试、理财等交流群，或者你有任何其他事情想和我交流也可以添加我的个人微信 ConardLi 。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;文中如有错误，欢迎在后台和我留言，如果这篇文章帮助到了你，欢迎点赞、在看和关注。你的点赞、在看和关注是对我最大的支持！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点赞、在看支持作者⬇️&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>