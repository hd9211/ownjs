<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9e68f96d6f43288819b895750e32705a</guid>
<title>面试官：为什么 Go 的负载因子是 6.5？</title>
<link>https://toutiao.io/k/mwuuo10</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近我有一个朋友，在网上看到一个有趣的&lt;strong&gt;段子&lt;/strong&gt;，引发了我一些兴趣。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5602536997885835&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaLMulj7LUetkJFyS01S7TqI4Ne3zaLaoDN0EibvVh1mqvRt01VmA5LNjnEp0maDgwmC8Rrib5Mfe4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;946&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听说是在最后的闲聊、吹水、聊人生、乱扯环节了，不是在技术环节了，所以大家也不用太在意什么技术评估法则（别杠）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;煎鱼作为一名技术号主，&lt;strong&gt;看到这里的 6.5，就想给大家挖一挖&lt;/strong&gt;，这到底是何物，和大家一同学习和增长知识！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.5 是什么&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上在 Go 语言中，就存在 6.5 这一概念，与 map 存在直接关系，因此我们需要先了解 map 的基本数据结构，再介绍 6.5 的背景和由来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始学习 6.5 的前世今生吧！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;了解 map 底层&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我以前在写《深入理解 Go map：初始化和访问元素》时有介绍过 map 的基础数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本结构如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.086&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaLMulj7LUetkJFyS01S7TqUsKoqG4C5WKHu5Dms3ibLvkbXP3DsOibFjlTFsVlH0QUcIpW2pjUTHOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;map 基本数据结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中重要的一个基本单位是 hmap：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; hmap &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; count     &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; flags     &lt;span&gt;uint8&lt;/span&gt;&lt;br/&gt; B         &lt;span&gt;uint8&lt;/span&gt;&lt;br/&gt; noverflow &lt;span&gt;uint16&lt;/span&gt;&lt;br/&gt; hash0     &lt;span&gt;uint32&lt;/span&gt;&lt;br/&gt; buckets    unsafe.Pointer&lt;br/&gt; oldbuckets unsafe.Pointer&lt;br/&gt; nevacuate  &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt; extra *mapextra&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; mapextra &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; overflow    *[]*bmap&lt;br/&gt; oldoverflow *[]*bmap&lt;br/&gt; nextOverflow *bmap&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;count：map 的大小，也就是 len() 的值，代指 map 中的键值对个数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;flags：状态标识，主要是 goroutine 写入和扩容机制的相关状态控制。并发读写的判断条件之一就是该值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B：&lt;strong&gt;桶，最大可容纳的元素数量，值为 负载因子（默认 6.5） * 2 ^ B，是 2 的指数&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;noverflow：溢出桶的数量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hash0：哈希因子。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;buckets：保存当前桶数据的指针地址（指向一段连续的内存地址，主要存储键值对数据）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;oldbuckets，保存旧桶的指针地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;nevacuate：迁移进度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;extra：原有 buckets 满载后，会发生扩容动作，在 Go 的机制中使用了增量扩容，如下为细项：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;overflow 为 hmap.buckets （当前）溢出桶的指针地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;oldoverflow 为 hmap.oldbuckets （旧）溢出桶的指针地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;nextOverflow 为空闲溢出桶的指针地址。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们关注到 hmap 的 B 字段，其值就是 6.5，他就是我们在苦苦寻找的 6.5，但他又是什么呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是负载因子&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;B 值，这里就涉及到一个概念：&lt;strong&gt;负载因子（load factor），用于衡量当前哈希表中空间占用率的核心指标&lt;/strong&gt;，也就是每个 bucket 桶存储的平均元素个数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外负载因子&lt;strong&gt;与扩容、迁移&lt;/strong&gt;等重新散列（rehash）行为有直接关系：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在程序运行时，会不断地进行插入、删除等，会导致 bucket 不均，内存利用率低，需要迁移。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在程序运行时，出现负载因子过大，需要做扩容，解决 bucket 过大的问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;负载因子是哈希表中的一个重要指标，在各种版本的哈希表实现中都有类似的东西，主要目的是&lt;strong&gt;为了平衡 buckets 的存储空间大小和查找元素时的性能高低&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在接触各种哈希表时都可以关注一下，做不同的对比，看看各家的考量。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么是 6.5&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解是什么后，我们进一步深挖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么 Go 语言中哈希表的负载因子是 6.5，为什么不是 8 ，也不是 1。这里面有可靠的数据支撑吗？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试报告&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上这是 Go 官方的经过认真的测试得出的数字，一起来看看官方的这份测试报告。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;报告中共包含 4 个关键指标，如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;loadFactor&lt;/th&gt;&lt;th&gt;%overflow&lt;/th&gt;&lt;th&gt;bytes/entry&lt;/th&gt;&lt;th&gt;hitprobe&lt;/th&gt;&lt;th&gt;missprobe&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;4.00&lt;/td&gt;&lt;td&gt;2.13&lt;/td&gt;&lt;td&gt;20.77&lt;/td&gt;&lt;td&gt;3.00&lt;/td&gt;&lt;td&gt;4.00&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4.50&lt;/td&gt;&lt;td&gt;4.05&lt;/td&gt;&lt;td&gt;17.30&lt;/td&gt;&lt;td&gt;3.25&lt;/td&gt;&lt;td&gt;4.50&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5.00&lt;/td&gt;&lt;td&gt;6.85&lt;/td&gt;&lt;td&gt;14.77&lt;/td&gt;&lt;td&gt;3.50&lt;/td&gt;&lt;td&gt;5.00&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5.50&lt;/td&gt;&lt;td&gt;10.55&lt;/td&gt;&lt;td&gt;12.94&lt;/td&gt;&lt;td&gt;3.75&lt;/td&gt;&lt;td&gt;5.50&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6.00&lt;/td&gt;&lt;td&gt;15.27&lt;/td&gt;&lt;td&gt;11.67&lt;/td&gt;&lt;td&gt;4.00&lt;/td&gt;&lt;td&gt;6.00&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6.50&lt;/td&gt;&lt;td&gt;20.90&lt;/td&gt;&lt;td&gt;10.79&lt;/td&gt;&lt;td&gt;4.25&lt;/td&gt;&lt;td&gt;6.50&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;7.00&lt;/td&gt;&lt;td&gt;27.14&lt;/td&gt;&lt;td&gt;10.15&lt;/td&gt;&lt;td&gt;4.50&lt;/td&gt;&lt;td&gt;7.00&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;7.50&lt;/td&gt;&lt;td&gt;34.03&lt;/td&gt;&lt;td&gt;9.73&lt;/td&gt;&lt;td&gt;4.75&lt;/td&gt;&lt;td&gt;7.50&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;8.00&lt;/td&gt;&lt;td&gt;41.10&lt;/td&gt;&lt;td&gt;9.40&lt;/td&gt;&lt;td&gt;5.00&lt;/td&gt;&lt;td&gt;8.00&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;loadFactor：负载因子，也有叫装载因子。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;%overflow：溢出率，有溢出 bukcet 的百分比。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bytes/entry：每对 key/elem 的开销字节数.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hitprobe：查找一个存在的 key 时，要查找的平均个数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;missprobe：查找一个不存在的 key 时，要查找的平均个数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;选择数值&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合测试报告一看，好家伙，不测不知道，一测吓一跳，有依据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 官方发现：&lt;strong&gt;负载因子太大了，会有很多溢出的桶。太小了，就会浪费很多空间&lt;/strong&gt;（too large and we have lots of overflow buckets, too small and we waste a lot of space）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5058236272878536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaLMulj7LUetkJFyS01S7TqwghNxRjViasYFrSkb45trFv1z3Z0BJT1yso6D59TnCqy1dojHScwtgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;figcaption&gt;来自 Go 官方源码说明&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据这份测试结果和讨论，Go 官方把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这意味着在 Go 语言中，&lt;strong&gt;当 B（bucket）平均每个存储的元素大于或等于 6.5 时，就会触发扩容行为&lt;/strong&gt;，这是作为我们用户对这个数值最近的接触。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在今天这篇文章中，我们先快速了解了 Go 语言中 map 的基本数据结构和设计，这和我们要解释的问题紧密相关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧接着针对开头所提出的 6.5，进行了介绍和说明，这其实是 map 中的负载因子。其数值的确定来源于 Go 官方的测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么是 6.5，你懂了吗？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;src/runtime/map.go&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;深度解析golang map&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang中map底层B值的计算逻辑&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxMDI4MDc1NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iac2xQZIq5icSiaTepuae8zLIUMiaxibbUM8ic735ewo6e89GRtjGbUBlgNYibwCjAicglQcvz6dCQ6yTKOw/0?wx_fmt=png&quot; data-nickname=&quot;脑子进煎鱼了&quot; data-alias=&quot;eddycjy&quot; data-signature=&quot;分享计算机基础、Go 语言、微服务架构和系统设计；著有图书《Go 语言编程之旅》。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;关注煎鱼，吸取他的知识 👆&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.07106598984771574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/486RHs1WbcgGib6o96dHbvGUGGwPicd8wusUGH1cXR29tM4bO0lNzialzkQhvU6m5ZUdaKibmcF2OQayjMe9Bia6iaXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是煎鱼。高一折腾过前端，参加过国赛拿了奖，大学搞过 PHP。现在整 Go，在公司负责微服务架构等相关工作推进和研发。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;从大学开始靠自己赚生活费和学费，到出版 Go 畅销书《Go 语言编程之旅》，再到获得 GOP（Go 领域最有观点专家）荣誉，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247483854&amp;amp;idx=1&amp;amp;sn=ec422fbf4d846975f2930ddeb5e81373&amp;amp;chksm=f9041493ce739d85a4b987eece14da627206cdad798f645cc770868312e4a22b6df24804f186&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点击蓝字查看我的出书之路&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;点击蓝字查看我的出书之路&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日常分享高质量文章，输出 Go 面试、工作经验、架构设计，&lt;span&gt;加微信拉读者交流群，记得点赞！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;&gt;来一个反馈！&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8566a8fc21ff96055394150425955a68</guid>
<title>如何优雅地记录操作日志？</title>
<link>https://toutiao.io/k/l5h2n30</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;48&quot; data-ratio=&quot;0.10078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUrXicw2VXTQTVVN5yxXWEacdY1ZdxTH195Pgibtib8EENJRMia3tzEnyVfgyfAgRibMssKqwlE186TLSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总第471&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2021年 第041篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img border=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;93&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;93&quot; data-ratio=&quot;0.9966329966329966&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVLR21NicmyQxcmiaqQ2KOJJj2JLwgJL4KSbo7CcuMF1hLf4xFjGQiaDRhSPyERxWGChWYP47Oc4sKGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot; data-width=&quot;100%&quot; opacity=&quot;&quot; title=&quot;undefined&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; data-style=&quot;text-align: left; font-size: 14px; color: inherit;&quot;&gt;&lt;section&gt;&lt;span&gt;操作日志几乎存在于每个系统中，而这些系统都有记录操作日志的一套 API。操作日志和系统日志不一样，操作日志必须要做到简单易懂。所以如何让操作日志不跟业务逻辑耦合，如何让操作日志的内容易于理解，如何让操作日志的接入更加简单？上面这些都是本文要回答的问题。我们主要围绕着如何“优雅”地记录操作日志展开描述，希望对从事相关工作的同学能够有所帮助或者启发。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1. 操作日志的使用场景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2. 实现方式&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.1 使用 Canal 监听数据库记录操作日志&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.2 通过日志文件的方式记录&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.3 通过 LogUtil 的方式记录日志&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.4 方法注解实现操作日志&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3. 优雅地支持 AOP 生成动态的操作日志&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4. 代码实现解析&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5. 总结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 操作日志的使用场景&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;103&quot; data-ratio=&quot;0.18588399720475193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxyp4WDCzpf9V5MbCTCN0czdptehicA5TUy0TCKoQoOfqzHUH7AtcDXdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1431&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;例子&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;系统日志和操作日志的区别&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;系统日志&lt;/strong&gt;：系统日志主要是为开发排查问题提供依据，一般打印在日志文件中；系统日志的可读性要求没那么高，日志中会包含代码的信息，比如在某个类的某一行打印了一个日志。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;操作日志&lt;/strong&gt;：主要是对某个对象进行新增操作或者修改操作后记录下这个新增或者修改，操作日志要求可读性比较强，因为它主要是给用户看的，比如订单的物流信息，用户需要知道在什么时间发生了什么事情。再比如，客服对工单的处理记录信息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;操作日志的记录格式大概分为下面几种：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;单纯的文字记录，比如：2021-09-16 10:00 订单创建。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;简单的动态的文本记录，比如：2021-09-16 10:00 订单创建，订单号：NO.11089999，其中涉及变量订单号“NO.11089999”。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;修改类型的文本，包含修改前和修改后的值，比如：2021-09-16 10:00 用户小明修改了订单的配送地址：从“金灿灿小区”修改到“银盏盏小区” ，其中涉及变量配送的原地址“金灿灿小区”和新地址“银盏盏小区”。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;修改表单，一次会修改多个字段。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 实现方式&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 使用 Canal 监听数据库记录操作日志&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://github.com/alibaba/canal&quot; textvalue=&quot;Canal&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Canal&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 是一款基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费的开源组件，通过采用监听数据库 Binlog 的方式，这样可以从底层知道是哪些数据做了修改，然后根据更改的数据记录操作日志。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种方式的优点是和业务逻辑完全分离。缺点也很明显，局限性太高，只能针对数据库的更改做操作日志记录，如果修改涉及到其他团队的 RPC 的调用，就没办法监听数据库了。举个例子：给用户发送通知，通知服务一般都是公司内部的公共组件，这时候只能在调用 RPC 的时候手工记录发送通知的操作日志了。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2 通过日志文件的方式记录&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;log.info(&lt;span&gt;&quot;订单创建&quot;&lt;/span&gt;)&lt;br/&gt;log.info(&lt;span&gt;&quot;订单已经创建，订单编号:{}&quot;&lt;/span&gt;, orderNo)&lt;br/&gt;log.info(&lt;span&gt;&quot;修改了订单的配送地址：从“{}”修改到“{}”， &quot;&lt;/span&gt;金灿灿小区&lt;span&gt;&quot;, &quot;&lt;/span&gt;银盏盏小区&lt;span&gt;&quot;)&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这种方式的操作记录需要解决三个问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;问题一：操作人如何记录&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;借助 SLF4J 中的 MDC 工具类，把操作人放在日志中，然后在日志中统一打印出来。首先在用户的拦截器中把用户的标识 Put 到 MDC 中。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserInterceptor&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;HandlerInterceptorAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;preHandle&lt;/span&gt;&lt;span&gt;(HttpServletRequest request, HttpServletResponse response, Object handler)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//获取到用户标识&lt;/span&gt;&lt;br/&gt;    String userNo = getUserNo(request);&lt;br/&gt;    &lt;span&gt;//把用户 ID 放到 MDC 上下文中&lt;/span&gt;&lt;br/&gt;    MDC.put(&lt;span&gt;&quot;userId&quot;&lt;/span&gt;, userNo);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.preHandle(request, response, handler);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;getUserNo&lt;/span&gt;&lt;span&gt;(HttpServletRequest request)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 通过 SSO 或者Cookie 或者 Auth信息获取到 当前登陆的用户信息&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;其次，把 userId 格式化到日志中，使用 %X{userId} 可以取到 MDC 中用户标识。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&amp;lt;pattern&amp;gt;&lt;span&gt;&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} %t %-5level %X{userId} %logger{30}.%method:%L - %msg%n&quot;&lt;/span&gt;&amp;lt;/pattern&amp;gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;问题二：操作日志如何和系统日志区分开&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过配置 Log 的配置文件，把有关操作日志的 Log 单独放到一日志文件中。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;//不同业务日志记录到不同的文件&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;appender&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;businessLogAppender&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;File&lt;/span&gt;&amp;gt;&lt;/span&gt;logs/business.log&lt;span&gt;&amp;lt;/&lt;span&gt;File&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;append&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;span&gt;append&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;filter&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;level&lt;/span&gt;&amp;gt;&lt;/span&gt;INFO&lt;span&gt;&amp;lt;/&lt;span&gt;level&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;onMatch&lt;/span&gt;&amp;gt;&lt;/span&gt;ACCEPT&lt;span&gt;&amp;lt;/&lt;span&gt;onMatch&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;onMismatch&lt;/span&gt;&amp;gt;&lt;/span&gt;DENY&lt;span&gt;&amp;lt;/&lt;span&gt;onMismatch&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;filter&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;rollingPolicy&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;fileNamePattern&lt;/span&gt;&amp;gt;&lt;/span&gt;logs/业务A.%d.%i.log&lt;span&gt;&amp;lt;/&lt;span&gt;fileNamePattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;maxHistory&lt;/span&gt;&amp;gt;&lt;/span&gt;90&lt;span&gt;&amp;lt;/&lt;span&gt;maxHistory&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;maxFileSize&lt;/span&gt;&amp;gt;&lt;/span&gt;10MB&lt;span&gt;&amp;lt;/&lt;span&gt;maxFileSize&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;rollingPolicy&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;encoder&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} %t %-5level %X{userId} %logger{30}.%method:%L - %msg%n&quot;&lt;span&gt;&amp;lt;/&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;charset&lt;/span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;span&gt;charset&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;encoder&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;appender&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;logger&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;businessLog&quot;&lt;/span&gt; &lt;span&gt;additivity&lt;/span&gt;=&lt;span&gt;&quot;false&quot;&lt;/span&gt; &lt;span&gt;level&lt;/span&gt;=&lt;span&gt;&quot;INFO&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;appender-ref&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;businessLogAppender&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;logger&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;然后在 Java 代码中单独的记录业务日志。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;//记录特定日志的声明&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger businessLog = LoggerFactory.getLogger(&lt;span&gt;&quot;businessLog&quot;&lt;/span&gt;);&lt;br/&gt; &lt;br/&gt;&lt;span&gt;//日志存储&lt;/span&gt;&lt;br/&gt;businessLog.info(&lt;span&gt;&quot;修改了配送地址&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;问题三：如何生成可读懂的日志文案&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以采用 LogUtil 的方式，也可以采用切面的方式生成日志模板，后续内容将会进行介绍。这样就可以把日志单独保存在一个文件中，然后通过日志收集可以把日志保存在 Elasticsearch 或者数据库中，接下来我们看下如何生成可读的操作日志。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3 通过 LogUtil 的方式记录日志&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;  LogUtil.log(orderNo, &lt;span&gt;&quot;订单创建&quot;&lt;/span&gt;, &lt;span&gt;&quot;小明&quot;&lt;/span&gt;)&lt;br/&gt;  LogUtil.log(orderNo, &lt;span&gt;&quot;订单创建，订单号&quot;&lt;/span&gt;+&lt;span&gt;&quot;NO.11089999&quot;&lt;/span&gt;,  &lt;span&gt;&quot;小明&quot;&lt;/span&gt;)&lt;br/&gt;  String template = &lt;span&gt;&quot;用户%s修改了订单的配送地址：从“%s”修改到“%s”&quot;&lt;/span&gt;&lt;br/&gt;  LogUtil.log(orderNo, String.format(tempalte, &lt;span&gt;&quot;小明&quot;&lt;/span&gt;, &lt;span&gt;&quot;金灿灿小区&quot;&lt;/span&gt;, &lt;span&gt;&quot;银盏盏小区&quot;&lt;/span&gt;),  &lt;span&gt;&quot;小明&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;这里解释下为什么记录操作日志的时候都绑定了一个 OrderNo，因为操作日志记录的是：某一个“时间”“谁”对“什么”做了什么“事情”。当查询业务的操作日志的时候，会查询针对这个订单的的所有操作，所以代码中加上了 OrderNo，记录操作日志的时候需要记录下操作人，所以传了操作人“小明”进来。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;上面看起来问题并不大，在修改地址的业务逻辑方法中使用一行代码记录了操作日志，接下来再看一个更复杂的例子：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; OnesIssueDO &lt;span&gt;updateAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    DeliveryOrder deliveryOrder = deliveryQueryService.queryOldAddress(request.getDeliveryOrderNo());&lt;br/&gt;    &lt;span&gt;// 更新派送信息，电话，收件人，地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;    String logContent = getLogContent(request, deliveryOrder);&lt;br/&gt;    LogUtils.logRecord(request.getOrderNo(), logContent, request.getOperator);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; onesIssueDO;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;getLogContent&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request, DeliveryOrder deliveryOrder)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String template = &lt;span&gt;&quot;用户%s修改了订单的配送地址：从“%s”修改到“%s”&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; String.format(tempalte, request.getUserName(), deliveryOrder.getAddress(), request.getAddress);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;可以看到上面的例子使用了两个方法代码，外加一个 getLogContent 的函数实现了操作日志的记录。当业务变得复杂后，记录操作日志放在业务代码中会导致业务的逻辑比较繁杂，最后导致 LogUtils.logRecord() 方法的调用存在于很多业务的代码中，而且类似 getLogContent() 这样的方法也散落在各个业务类中，对于代码的可读性和可维护性来说是一个灾难。下面介绍下如何避免这个灾难。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.4 方法注解实现操作日志&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;为了解决上面问题，一般采用 AOP 的方式记录日志，让操作日志和业务逻辑解耦，接下来看一个简单的 AOP 日志的例子。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content=&lt;span&gt;&quot;修改了配送地址&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;我们可以在注解的操作日志上记录固定文案，这样业务逻辑和业务代码可以做到解耦，让我们的业务代码变得纯净起来。可能有同学注意到，上面的方式虽然解耦了操作日志的代码，但是记录的文案并不符合我们的预期，文案是静态的，没有包含动态的文案，因为我们需要记录的操作日志是：用户%s修改了订单的配送地址，从“%s”修改到“%s”。接下来，我们介绍一下如何优雅地使用 AOP 生成动态的操作日志。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 优雅地支持 AOP 生成动态的操作日志&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 动态模板&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;一提到动态模板，就会涉及到让变量通过占位符的方式解析模板，从而达到通过注解记录操作日志的目的。模板解析的方式有很多种，这里使用了 SpEL（&lt;/span&gt;&lt;span&gt;Spring Expression Language，Spring表达式语言&lt;/span&gt;&lt;span&gt;）来实现。我们可以先写下期望的记录日志的方式，然后再看看能否实现这样的功能。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送地址：从“#oldAddress”, 修改到“#request.address”&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request, String oldAddress)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;通过 SpEL 表达式引用方法上的参数，可以让变量填充到模板中达到动态的操作日志文本内容。但是现在还有几个问题需要解决：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;操作日志需要知道是哪个操作人修改的订单配送地址。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;修改订单配送地址的操作日志需要绑定在配送的订单上，从而可以根据配送订单号查询出对这个配送订单的所有操作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;为了在注解上记录之前的配送地址是什么，在方法签名上添加了一个和业务无关的 oldAddress 的变量，这样就不优雅了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;为了解决前两个问题，我们需要把期望的操作日志使用形式改成下面的方式：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(&lt;br/&gt;     content = &lt;span&gt;&quot;修改了订单的配送地址：从“#oldAddress”, 修改到“#request.address”&quot;&lt;/span&gt;,&lt;br/&gt;     operator = &lt;span&gt;&quot;#request.userName&quot;&lt;/span&gt;, bizNo=&lt;span&gt;&quot;#request.deliveryOrderNo&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request, String oldAddress)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;修改后的代码在注解上添加两个参数，一个是操作人，一个是操作日志需要绑定的对象。但是，在普通的 Web 应用中用户信息都是保存在一个线程上下文的静态方法中，所以 operator 一般是这样的写法（&lt;/span&gt;&lt;span&gt;假定获取当前登陆用户的方式是 UserContext.getCurrentUser()&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;operator = &lt;span&gt;&quot;#{T(com.meituan.user.UserContext).getCurrentUser()}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这样的话，每个 @LogRecord 的注解上的操作人都是这么长一串。为了避免过多的重复代码，我们可以把注解上的 operator 参数设置为非必填，这样用户可以填写操作人。但是，如果用户不填写我们就取 UserContext 的 user（&lt;/span&gt;&lt;span&gt;下文会介绍如何取 user&lt;/span&gt;&lt;span&gt;）。最后，最简单的日志变成了下面的形式：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送地址：从“#oldAddress”, 修改到“#request.address”&quot;&lt;/span&gt;, &lt;br/&gt;           bizNo=&lt;span&gt;&quot;#request.deliveryOrderNo&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request, String oldAddress)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;接下来，我们需要解决第三个问题：为了记录业务操作记录添加了一个 oldAddress 变量，不管怎么样这都不是一个好的实现方式，所以接下来，我们需要把 oldAddress 变量从修改地址的方法签名上去掉。但是操作日志确实需要 oldAddress 变量，怎么办呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要么和产品经理 PK 一下，让产品经理把文案从“修改了订单的配送地址：从 xx 修改到 yy” 改为 “修改了订单的配送地址为：yy”。但是从用户体验上来看，第一种文案更人性化一些，显然我们不会 PK 成功的。那么我们就必须要把这个 oldAddress 查询出来然后供操作日志使用了。还有一种解决办法是：把这个参数放到操作日志的线程上下文中，供注解上的模板使用。我们按照这个思路再改下操作日志的实现代码。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送地址：从“#oldAddress”, 修改到“#request.address”&quot;&lt;/span&gt;,&lt;br/&gt;        bizNo=&lt;span&gt;&quot;#request.deliveryOrderNo&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 查询出原来的地址是什么&lt;/span&gt;&lt;br/&gt;    LogRecordContext.putVariable(&lt;span&gt;&quot;oldAddress&quot;&lt;/span&gt;, DeliveryService.queryOldAddress(request.getDeliveryOrderNo()));&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这时候可以看到，LogRecordContext 解决了操作日志模板上使用方法参数以外变量的问题，同时避免了为了记录操作日志修改方法签名的设计。虽然已经比之前的代码好了些，但是依然需要在业务代码里面加了一行业务逻辑无关的代码，如果有“强迫症”的同学还可以继续往下看，接下来我们会讲解自定义函数的解决方案。下面再看另一个例子：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送员：从“#oldDeliveryUserId”, 修改到“#request.userId”&quot;&lt;/span&gt;,&lt;br/&gt;        bizNo=&lt;span&gt;&quot;#request.deliveryOrderNo&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 查询出原来的地址是什么&lt;/span&gt;&lt;br/&gt;    LogRecordContext.putVariable(&lt;span&gt;&quot;oldDeliveryUserId&quot;&lt;/span&gt;, DeliveryService.queryOldDeliveryUserId(request.getDeliveryOrderNo()));&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这个操作日志的模板最后记录的内容是这样的格式：修改了订单的配送员：从 “10090”，修改到 “10099”，显然用户看到这样的操作日志是不明白的。用户对于用户 ID 是 10090 还是 10099 并不了解，用户期望看到的是：修改了订单的配送员：从“张三（&lt;/span&gt;&lt;span&gt;18910008888&lt;/span&gt;&lt;span&gt;）”，修改到“小明（&lt;/span&gt;&lt;span&gt;13910006666&lt;/span&gt;&lt;span&gt;）”。用户关心的是配送员的姓名和电话。但是我们方法中传递的参数只有配送员的 ID，没有配送员的姓名可电话。我们可以通过上面的方法，把用户的姓名和电话查询出来，然后通过 LogRecordContext 实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，“强迫症”是不期望操作日志的代码嵌入在业务逻辑中的。接下来，我们考虑另一种实现方式：自定义函数。如果我们可以通过自定义函数把用户 ID 转换为用户姓名和电话，那么就能解决这一问题，按照这个思路，我们把模板修改为下面的形式：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送员：从“{deliveryUser{#oldDeliveryUserId}}”, 修改到“{deveryUser{#request.userId}}”&quot;&lt;/span&gt;,&lt;br/&gt;        bizNo=&lt;span&gt;&quot;#request.deliveryOrderNo&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 查询出原来的地址是什么&lt;/span&gt;&lt;br/&gt;    LogRecordContext.putVariable(&lt;span&gt;&quot;oldDeliveryUserId&quot;&lt;/span&gt;, DeliveryService.queryOldDeliveryUserId(request.getDeliveryOrderNo()));&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;其中 deliveryUser 是自定义函数，使用大括号把 Spring 的 SpEL 表达式包裹起来，这样做的好处：一是把 Spring EL 表达式和自定义函数区分开便于解析；二是如果模板中不需要 SpEL 表达式解析可以容易的识别出来，减少 SpEL 的解析提高性能。这时候我们发现上面代码还可以优化成下面的形式：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送员：从“{queryOldUser{#request.deliveryOrderNo()}}”, 修改到“{deveryUser{#request.userId}}”&quot;&lt;/span&gt;,&lt;br/&gt;        bizNo=&lt;span&gt;&quot;#request.deliveryOrderNo&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这样就不需要在 modifyAddress 方法中通过 LogRecordContext.putVariable() 设置老的快递员了，通过直接新加一个自定义函数 queryOldUser() 参数把派送订单传递进去，就能查到之前的配送人了，只需要让方法的解析在 modifyAddress() 方法执行之前运行。这样的话，我们让业务代码又变得纯净了起来，同时也让“强迫症”不再感到难受了。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 代码实现解析&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 代码结构&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;1&quot; data-cropselx2=&quot;381&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;280&quot; data-ratio=&quot;0.7357142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxxB1clIphWXBh14KpvDXYacpJ8stVhwiaa8gMySwDH6ofDJSBeINeatg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上面的操作日志主要是通过一个 AOP 拦截器实现的，整体主要分为 AOP 模块、日志解析模块、日志保存模块、Starter 模块；组件提供了4个扩展点，分别是：自定义函数、默认处理人、业务保存和查询；业务可以根据自己的业务特性定制符合自己业务的逻辑。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 模块介绍&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;有了上面的分析，已经得出一种我们期望的操作日志记录的方式，接下来我们看下如何实现上面的逻辑。实现主要分为下面几个步骤：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;AOP 拦截逻辑&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;解析逻辑&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;模板解析&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LogContext 逻辑&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;默认的 operator 逻辑&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;自定义函数逻辑&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;默认的日志持久化逻辑&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Starter 封装逻辑&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.1 AOP 拦截逻辑&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;这块逻辑主要是一个拦截器，针对 @LogRecord 注解分析出需要记录的操作日志，然后把操作日志持久化，这里把注解命名为 @LogRecordAnnotation。接下来，我们看下注解的定义：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@Target&lt;/span&gt;({ElementType.METHOD})&lt;br/&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span&gt;@Inherited&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; LogRecordAnnotation {&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;success&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;fail&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;operator&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;bizNo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;category&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;detail&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;condition&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;注解中除了上面提到参数外，还增加了 fail、category、detail、condition 等参数，这几个参数是为了满足特定的场景，后面还会给出具体的例子。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6634844868735084&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESx9u9lj0hx2aROhb7VqiajrQBqLqVoOUGqYOwRsJF1hCXvauatHM1d1Iw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;为了保持简单，组件的必填参数就两个。业务中的 AOP 逻辑大部分是使用 @Aspect 注解实现的，但是基于注解的 AOP 在 Spring boot 1.5 中兼容性是有问题的，组件为了兼容 Spring boot1.5 的版本我们手工实现 Spring 的 AOP 逻辑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;550&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;382&quot; data-ratio=&quot;0.6945454545454546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxguasPnQdjmQ7GEI5micOBcxrnPXo82a5D3gZMBvxw8UE8nib3TpGwPwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;切面选择 &lt;/span&gt;&lt;code&gt;&lt;span&gt;AbstractBeanFactoryPointcutAdvisor&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 实现，切点是通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;StaticMethodMatcherPointcut&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 匹配包含 &lt;/span&gt;&lt;code&gt;&lt;span&gt;LogRecordAnnotation&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 注解的方法。通过实现 &lt;/span&gt;&lt;code&gt;&lt;span&gt;MethodInterceptor&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 接口实现操作日志的增强逻辑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面是拦截器的切点逻辑：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogRecordPointcut&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;StaticMethodMatcherPointcut&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Serializable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// LogRecord的解析类&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; LogRecordOperationSource logRecordOperationSource;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;matches&lt;/span&gt;&lt;span&gt;(@NonNull Method method, @NonNull Class&amp;lt;?&amp;gt; targetClass)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;          &lt;span&gt;// 解析 这个 method 上有没有 @LogRecordAnnotation 注解，有的话会解析出来注解上的各个参数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; !CollectionUtils.isEmpty(logRecordOperationSource.computeLogRecordOperations(method, targetClass));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setLogRecordOperationSource&lt;/span&gt;&lt;span&gt;(LogRecordOperationSource logRecordOperationSource)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.logRecordOperationSource = logRecordOperationSource;&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;切面的增强逻辑主要代码如下：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;invoke&lt;/span&gt;&lt;span&gt;(MethodInvocation invocation)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;    Method method = invocation.getMethod();&lt;br/&gt;    &lt;span&gt;// 记录日志&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; execute(invocation, invocation.getThis(), method, invocation.getArguments());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Object &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(MethodInvocation invoker, Object target, Method method, Object[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;    Class&amp;lt;?&amp;gt; targetClass = getTargetClass(target);&lt;br/&gt;    Object ret = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    MethodExecuteResult methodExecuteResult = &lt;span&gt;new&lt;/span&gt; MethodExecuteResult(&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;    LogRecordContext.putEmptySpan();&lt;br/&gt;    Collection&amp;lt;LogRecordOps&amp;gt; operations = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    Map&amp;lt;String, String&amp;gt; functionNameAndReturnMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        operations = logRecordOperationSource.computeLogRecordOperations(method, targetClass);&lt;br/&gt;        List&amp;lt;String&amp;gt; spElTemplates = getBeforeExecuteFunctionTemplate(operations);&lt;br/&gt;        &lt;span&gt;//业务逻辑执行前的自定义函数解析&lt;/span&gt;&lt;br/&gt;        functionNameAndReturnMap = processBeforeExecuteFunctionTemplate(spElTemplates, targetClass, method, args);&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        log.error(&lt;span&gt;&quot;log record parse before function exception&quot;&lt;/span&gt;, e);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        ret = invoker.proceed();&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        methodExecuteResult = &lt;span&gt;new&lt;/span&gt; MethodExecuteResult(&lt;span&gt;false&lt;/span&gt;, e, e.getMessage());&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!CollectionUtils.isEmpty(operations)) {&lt;br/&gt;            recordExecute(ret, method, args, operations, targetClass,&lt;br/&gt;                    methodExecuteResult.isSuccess(), methodExecuteResult.getErrorMsg(), functionNameAndReturnMap);&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception t) {&lt;br/&gt;        &lt;span&gt;//记录日志错误不要影响业务&lt;/span&gt;&lt;br/&gt;        log.error(&lt;span&gt;&quot;log record parse exception&quot;&lt;/span&gt;, t);&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        LogRecordContext.clear();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (methodExecuteResult.throwable != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; methodExecuteResult.throwable;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ret;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;拦截逻辑的流程：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.4030710172744723&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxz4XX5lXISsv5uiag5X5eM9PIMD9ktEv8HgKwV8U5dDibx6IWJE7fzibCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;521&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;可以看到，操作日志的记录持久化是在方法执行完之后执行的，当方法抛出异常之后会先捕获异常，等操作日志持久化完成后再抛出异常。在业务的方法执行之前，会对提前解析的自定义函数求值，解决了前面提到的需要查询修改之前的内容。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.2 解析逻辑&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;模板解析&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Spring 3 中提供了一个非常强大的功能：SpEL，SpEL 在 Spring 产品中是作为表达式求值的核心基础模块，它本身是可以脱离 Spring 独立使用的。举个例子：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SpelExpressionParser parser = &lt;span&gt;new&lt;/span&gt; SpelExpressionParser();&lt;br/&gt;        Expression expression = parser.parseExpression(&lt;span&gt;&quot;#root.purchaseName&quot;&lt;/span&gt;);&lt;br/&gt;        Order order = &lt;span&gt;new&lt;/span&gt; Order();&lt;br/&gt;        order.setPurchaseName(&lt;span&gt;&quot;张三&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(expression.getValue(order));&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这个方法将打印 “张三”。LogRecord 解析的类图如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6542893725992317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxGO8zJZoibAzrYg9Amez2aJ9vChyiaMG3txfbSicg8qboxfzdw0PQBRPpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;781&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;解析核心类&lt;/strong&gt;：&lt;/span&gt;&lt;code&gt;&lt;span&gt;LogRecordValueParser&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 里面封装了自定义函数和 SpEL 解析类 &lt;/span&gt;&lt;code&gt;&lt;span&gt;LogRecordExpressionEvaluator&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogRecordExpressionEvaluator&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;CachedExpressionEvaluator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;ExpressionKey, Expression&amp;gt; expressionCache = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;(&lt;span&gt;64&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;AnnotatedElementKey, Method&amp;gt; targetMethodCache = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;(&lt;span&gt;64&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;parseExpression&lt;/span&gt;&lt;span&gt;(String conditionExpression, AnnotatedElementKey methodKey, EvaluationContext evalContext)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; getExpression(&lt;span&gt;this&lt;/span&gt;.expressionCache, methodKey, conditionExpression).getValue(evalContext, String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;LogRecordExpressionEvaluator&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 继承自 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CachedExpressionEvaluator&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 类，这个类里面有两个 Map，一个是 expressionCache 一个是 targetMethodCache。在上面的例子中可以看到，SpEL 会解析成一个 Expression 表达式，然后根据传入的 Object 获取到对应的值，所以 expressionCache 是为了缓存方法、表达式和 SpEL 的 Expression 的对应关系，让方法注解上添加的 SpEL 表达式只解析一次。下面的 targetMethodCache 是为了缓存传入到 Expression 表达式的 Object。核心的解析逻辑是上面最后一行代码。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;getExpression(&lt;span&gt;this&lt;/span&gt;.expressionCache, methodKey, conditionExpression).getValue(evalContext, String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;getExpression&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法会从 expressionCache 中获取到 @LogRecordAnnotation 注解上的表达式的解析 Expression 的实例，然后调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，&lt;/span&gt;&lt;code&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 传入一个 evalContext 就是类似上面例子中的 order 对象。其中 Context 的实现将会在下文介绍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;日志上下文实现&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面的例子把变量放到了 LogRecordContext 中，然后 SpEL 表达式就可以顺利的解析方法上不存在的参数了，通过上面的 SpEL 的例子可以看出，要把方法的参数和 LogRecordContext 中的变量都放到 SpEL 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法的 Object 中才可以顺利的解析表达式的值。下面看看如何实现：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送员：从“{deveryUser{#oldDeliveryUserId}}”, 修改到“{deveryUser{#request.getUserId()}}”&quot;&lt;/span&gt;,&lt;br/&gt;            bizNo=&lt;span&gt;&quot;#request.getDeliveryOrderNo()&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 查询出原来的地址是什么&lt;/span&gt;&lt;br/&gt;    LogRecordContext.putVariable(&lt;span&gt;&quot;oldDeliveryUserId&quot;&lt;/span&gt;, DeliveryService.queryOldDeliveryUserId(request.getDeliveryOrderNo()));&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;在 LogRecordValueParser 中创建了一个 EvaluationContext，用来给 SpEL 解析方法参数和 Context 中的变量。相关代码如下：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;EvaluationContext evaluationContext = expressionEvaluator.createEvaluationContext(method, args, targetClass, ret, errorMsg, beanFactory);&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;在解析的时候调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法传入的参数 evalContext，就是上面这个 EvaluationContext 对象。下面是 LogRecordEvaluationContext 对象的继承体系：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;440&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;457&quot; data-ratio=&quot;1.0386363636363636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxPy2ibjbGKbEyEbaSibS2slBW1Whcg3ibJyLWL0zx8FUGEQTq0xCgH3RbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;440&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;LogRecordEvaluationContext 做了三个事情：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;把方法的参数都放到 SpEL 解析的 RootObject 中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;把 LogRecordContext 中的变量都放到 RootObject 中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;把方法的返回值和 ErrorMsg 都放到 RootObject 中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;LogRecordEvaluationContext 的代码如下：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogRecordEvaluationContext&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;MethodBasedEvaluationContext&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LogRecordEvaluationContext&lt;/span&gt;&lt;span&gt;(Object rootObject, Method method, Object[] arguments,&lt;br/&gt;                                      ParameterNameDiscoverer parameterNameDiscoverer, Object ret, String errorMsg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       &lt;span&gt;//把方法的参数都放到 SpEL 解析的 RootObject 中&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;super&lt;/span&gt;(rootObject, method, arguments, parameterNameDiscoverer);&lt;br/&gt;       &lt;span&gt;//把 LogRecordContext 中的变量都放到 RootObject 中&lt;/span&gt;&lt;br/&gt;        Map&amp;lt;String, Object&amp;gt; variables = LogRecordContext.getVariables();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (variables != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; variables.size() &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, Object&amp;gt; entry : variables.entrySet()) {&lt;br/&gt;                setVariable(entry.getKey(), entry.getValue());&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//把方法的返回值和 ErrorMsg 都放到 RootObject 中&lt;/span&gt;&lt;br/&gt;        setVariable(&lt;span&gt;&quot;_ret&quot;&lt;/span&gt;, ret);&lt;br/&gt;        setVariable(&lt;span&gt;&quot;_errorMsg&quot;&lt;/span&gt;, errorMsg);&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;下面是 LogRecordContext 的实现，这个类里面通过一个 ThreadLocal 变量保持了一个栈，栈里面是个 Map，Map 对应了变量的名称和变量的值。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogRecordContext&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; InheritableThreadLocal&amp;lt;Stack&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;&amp;gt; variableMapStack = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;   &lt;span&gt;//其他省略....&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;上面使用了 InheritableThreadLocal，所以在线程池的场景下使用 LogRecordContext 会出现问题，如果支持线程池可以使用阿里巴巴开源的 TTL 框架。那这里为什么不直接设置一个 ThreadLocal&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; 对象，而是要设置一个 Stack 结构呢？我们看一下这么做的原因是什么。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@LogRecord&lt;/span&gt;(content = &lt;span&gt;&quot;修改了订单的配送员：从“{deveryUser{#oldDeliveryUserId}}”, 修改到“{deveryUser{#request.getUserId()}}”&quot;&lt;/span&gt;,&lt;br/&gt;        bizNo=&lt;span&gt;&quot;#request.getDeliveryOrderNo()&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;modifyAddress&lt;/span&gt;&lt;span&gt;(updateDeliveryRequest request)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 查询出原来的地址是什么&lt;/span&gt;&lt;br/&gt;    LogRecordContext.putVariable(&lt;span&gt;&quot;oldDeliveryUserId&quot;&lt;/span&gt;, DeliveryService.queryOldDeliveryUserId(request.getDeliveryOrderNo()));&lt;br/&gt;    &lt;span&gt;// 更新派送信息 电话，收件人、地址&lt;/span&gt;&lt;br/&gt;    doUpdate(request);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;上面代码的执行流程如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.837620578778135&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxLcgBXtru4cjE68q2vHorVRhyXziaAV8V2G2icZg7BUIExGO8Td0QfUlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1244&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;看起来没有什么问题，但是使用 LogRecordAnnotation 的方法里面嵌套了另一个使用 LogRecordAnnotation 方法的时候，流程就变成下面的形式：&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8894230769230769&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxqGNT1JtY0uhKbK9CdeocO9X0UEficFLyn6xMGV0S1ZYlrMEG2OQkcZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1248&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;可以看到，当方法二执行了释放变量后，继续执行方法一的 logRecord 逻辑，此时解析的时候 ThreadLocal&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;的 Map 已经被释放掉，所以方法一就获取不到对应的变量了。方法一和方法二共用一个变量 Map 还有个问题是：如果方法二设置了和方法一相同的变量两个方法的变量就会被相互覆盖。所以最终 LogRecordContext 的变量的生命周期需要是下面的形式：&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxnf8JSC6vgFAUkGq7C4jlvPMPbBUotl6WnXtp79rL3C0vlfX6Ke2xXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;371&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;LogRecordContext 每执行一个方法都会压栈一个 Map，方法执行完之后会 Pop 掉这个 Map，从而避免变量共享和覆盖问题。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;默认操作人逻辑&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 LogRecordInterceptor 中 IOperatorGetService 接口，这个接口可以获取到当前的用户。下面是接口的定义：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IOperatorGetService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 可以在里面外部的获取当前登陆的用户，比如 UserContext.getCurrentUser()&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; 转换成Operator返回&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;Operator &lt;span&gt;getUser&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;下面给出了从用户上下文中获取用户的例子：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefaultOperatorGetServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IOperatorGetService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Operator &lt;span&gt;getUser&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//UserUtils 是获取用户上下文的方法&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; Optional.ofNullable(UserUtils.getUser())&lt;br/&gt;                        .map(a -&amp;gt; &lt;span&gt;new&lt;/span&gt; Operator(a.getName(), a.getLogin()))&lt;br/&gt;                        .orElseThrow(()-&amp;gt;&lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;user is null&quot;&lt;/span&gt;));&lt;br/&gt;        &lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;组件在解析 operator 的时候，就判断注解上的 operator 是否是空，如果注解上没有指定，我们就从 IOperatorGetService 的 getUser 方法获取了。如果都获取不到，就会报错。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;String realOperatorId = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (StringUtils.isEmpty(operatorId)) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (operatorGetService.getUser() == &lt;span&gt;null&lt;/span&gt; || StringUtils.isEmpty(operatorGetService.getUser().getOperatorId())) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;user is null&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    realOperatorId = operatorGetService.getUser().getOperatorId();&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    spElTemplates = Lists.newArrayList(bizKey, bizNo, action, operatorId, detail);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;自定义函数逻辑&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;自定义函数的类图如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.30807248764415157&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXehNsNY76lXs1L1HwaLESxKrpOdFKJX6OIg0AqeCc5luGlJxkdgRUgYyNOHSCcWKVVZIRE0l0EIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1214&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;下面是 IParseFunction 的接口定义：&lt;/span&gt;&lt;code&gt;&lt;span&gt;executeBefore&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数代表了自定义函数是否在业务代码执行之前解析，上面提到的查询修改之前的内容。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IParseFunction&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;executeBefore&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;String &lt;span&gt;functionName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;String &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(String value)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;ParseFunctionFactory 的代码比较简单，它的功能是把所有的 IParseFunction 注入到函数工厂中。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ParseFunctionFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, IParseFunction&amp;gt; allFunctionMap;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ParseFunctionFactory&lt;/span&gt;&lt;span&gt;(List&amp;lt;IParseFunction&amp;gt; parseFunctions)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (CollectionUtils.isEmpty(parseFunctions)) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    allFunctionMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (IParseFunction parseFunction : parseFunctions) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (StringUtils.isEmpty(parseFunction.functionName())) {&lt;br/&gt;        &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;      allFunctionMap.put(parseFunction.functionName(), parseFunction);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; IParseFunction &lt;span&gt;getFunction&lt;/span&gt;&lt;span&gt;(String functionName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; allFunctionMap.get(functionName);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isBeforeFunction&lt;/span&gt;&lt;span&gt;(String functionName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; allFunctionMap.get(functionName) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; allFunctionMap.get(functionName).executeBefore();&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;DefaultFunctionServiceImpl 的逻辑就是根据传入的函数名称 functionName 找到对应的 IParseFunction，然后把参数传入到 IParseFunction 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;apply&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法上最后返回函数的值。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefaultFunctionServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IFunctionService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ParseFunctionFactory parseFunctionFactory;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;DefaultFunctionServiceImpl&lt;/span&gt;&lt;span&gt;(ParseFunctionFactory parseFunctionFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.parseFunctionFactory = parseFunctionFactory;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(String functionName, String value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    IParseFunction function = parseFunctionFactory.getFunction(functionName);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (function == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; function.apply(value);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;beforeFunction&lt;/span&gt;&lt;span&gt;(String functionName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; parseFunctionFactory.isBeforeFunction(functionName);&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.3 日志持久化逻辑&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;同样在 LogRecordInterceptor 的代码中引用了 ILogRecordService，这个 Service 主要包含了日志记录的接口。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ILogRecordService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 保存 log&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; logRecord 日志实体&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;record&lt;/span&gt;&lt;span&gt;(LogRecord logRecord)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;业务可以实现这个保存接口，然后把日志保存在任何存储介质上。这里给了一个 2.2 节介绍的通过 log.info 保存在日志文件中的例子，业务可以把保存设置成异步或者同步，可以和业务放在一个事务中保证操作日志和业务的一致性，也可以新开辟一个事务，保证日志的错误不影响业务的事务。业务可以保存在 Elasticsearch、数据库或者文件中，用户可以根据日志结构和日志的存储实现相应的查询逻辑。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefaultLogRecordServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ILogRecordService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    @Transactional(propagation = Propagation.REQUIRES_NEW)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;record&lt;/span&gt;&lt;span&gt;(LogRecord logRecord)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;【logRecord】log={}&quot;&lt;/span&gt;, logRecord);&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.4 Starter 逻辑封装&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;上面逻辑代码已经介绍完毕，那么接下来需要把这些组件组装起来，然后让用户去使用。在使用这个组件的时候只需要在 Springboot 的入口上添加一个注解 @EnableLogRecord(tenant = &quot;com.mzt.test&quot;)。其中 tenant 代表租户，是为了多租户使用的。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;(exclude = DataSourceAutoConfiguration&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;EnableTransactionManagement&lt;/span&gt;&lt;br/&gt;@&lt;span&gt;EnableLogRecord&lt;/span&gt;(&lt;span&gt;tenant&lt;/span&gt; &lt;/span&gt;= &lt;span&gt;&quot;com.mzt.test&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SpringApplication.run(Main&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;args&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;我们再看下 EnableLogRecord 的代码，代码中 Import 了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;LogRecordConfigureSelector.class&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;LogRecordConfigureSelector&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 类中暴露了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;LogRecordProxyAutoConfiguration&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 类。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@Target&lt;/span&gt;(ElementType.TYPE)&lt;br/&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;(LogRecordConfigureSelector&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;EnableLogRecord&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;tenant&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;AdviceMode &lt;span&gt;mode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; AdviceMode.PROXY&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;LogRecordProxyAutoConfiguration&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 就是装配上面组件的核心类了，代码如下：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogRecordProxyAutoConfiguration&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ImportAware&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; AnnotationAttributes enableLogRecord;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@Role&lt;/span&gt;(BeanDefinition.ROLE_INFRASTRUCTURE)&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; LogRecordOperationSource &lt;span&gt;logRecordOperationSource&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LogRecordOperationSource();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@ConditionalOnMissingBean&lt;/span&gt;(IFunctionService&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;IFunctionService&lt;/span&gt; &lt;span&gt;functionService&lt;/span&gt;(&lt;span&gt;ParseFunctionFactory&lt;/span&gt; &lt;span&gt;parseFunctionFactory&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DefaultFunctionServiceImpl(parseFunctionFactory);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ParseFunctionFactory &lt;span&gt;parseFunctionFactory&lt;/span&gt;&lt;span&gt;(@Autowired List&amp;lt;IParseFunction&amp;gt; parseFunctions)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ParseFunctionFactory(parseFunctions);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@ConditionalOnMissingBean&lt;/span&gt;(IParseFunction&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;DefaultParseFunction&lt;/span&gt; &lt;span&gt;parseFunction&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DefaultParseFunction();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@Role&lt;/span&gt;(BeanDefinition.ROLE_INFRASTRUCTURE)&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; BeanFactoryLogRecordAdvisor &lt;span&gt;logRecordAdvisor&lt;/span&gt;&lt;span&gt;(IFunctionService functionService)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    BeanFactoryLogRecordAdvisor advisor =&lt;br/&gt;            &lt;span&gt;new&lt;/span&gt; BeanFactoryLogRecordAdvisor();&lt;br/&gt;    advisor.setLogRecordOperationSource(logRecordOperationSource());&lt;br/&gt;    advisor.setAdvice(logRecordInterceptor(functionService));&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; advisor;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@Role&lt;/span&gt;(BeanDefinition.ROLE_INFRASTRUCTURE)&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; LogRecordInterceptor &lt;span&gt;logRecordInterceptor&lt;/span&gt;&lt;span&gt;(IFunctionService functionService)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    LogRecordInterceptor interceptor = &lt;span&gt;new&lt;/span&gt; LogRecordInterceptor();&lt;br/&gt;    interceptor.setLogRecordOperationSource(logRecordOperationSource());&lt;br/&gt;    interceptor.setTenant(enableLogRecord.getString(&lt;span&gt;&quot;tenant&quot;&lt;/span&gt;));&lt;br/&gt;    interceptor.setFunctionService(functionService);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; interceptor;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@ConditionalOnMissingBean&lt;/span&gt;(IOperatorGetService&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;  @&lt;span&gt;Role&lt;/span&gt;(&lt;span&gt;BeanDefinition&lt;/span&gt;.&lt;span&gt;ROLE_APPLICATION&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;IOperatorGetService&lt;/span&gt; &lt;span&gt;operatorGetService&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DefaultOperatorGetServiceImpl();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@ConditionalOnMissingBean&lt;/span&gt;(ILogRecordService&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;  @&lt;span&gt;Role&lt;/span&gt;(&lt;span&gt;BeanDefinition&lt;/span&gt;.&lt;span&gt;ROLE_APPLICATION&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ILogRecordService&lt;/span&gt; &lt;span&gt;recordService&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DefaultLogRecordServiceImpl();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setImportMetadata&lt;/span&gt;&lt;span&gt;(AnnotationMetadata importMetadata)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.enableLogRecord = AnnotationAttributes.fromMap(&lt;br/&gt;            importMetadata.getAnnotationAttributes(EnableLogRecord&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getName&lt;/span&gt;(), &lt;span&gt;false&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.enableLogRecord == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      log.info(&lt;span&gt;&quot;@EnableCaching is not present on importing class&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这个类继承 ImportAware 是为了拿到 EnableLogRecord 上的租户属性，这个类使用变量 logRecordAdvisor 和 logRecordInterceptor 装配了 AOP，同时把自定义函数注入到了 logRecordAdvisor 中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;对外扩展类&lt;/strong&gt;：分别是&lt;/span&gt;&lt;code&gt;&lt;span&gt;IOperatorGetService&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;ILogRecordService&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;IParseFunction&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。业务可以自己实现相应的接口，因为配置了 @ConditionalOnMissingBean，所以用户的实现类会覆盖组件内的默认实现。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 总结&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;这篇文章介绍了操作日志的常见写法，以及如何让操作日志的实现更加简单、易懂，通过组件的四个模块，介绍了组件的具体实现。对于上面的组件介绍，大家如果有疑问，也欢迎在文末留言，我们会进行答疑。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6. 作者简介&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;站通，2020年加入美团，基础研发平台/研发质量及效率部工程师。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7. 参考资料&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;----------  END  ----------&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;招聘信息&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-source=&quot;bj.96weixin.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;美团研发质量及效率部 ，致力于建设业界一流的持续交付平台，现招聘基础组件方向相关的工程师，坐标北京/上海。欢迎感兴趣的同学加入，大家可投递简历至：&lt;/span&gt;&lt;span&gt;chao.yu@meituan.com&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;邮件主题请注明：美团研发质量及效率部&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;也许你还想看&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  | &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651751273&amp;amp;idx=1&amp;amp;sn=388f666fd1bce3413d8564662b120b71&amp;amp;chksm=bd125a248a65d332417c729d9e434157236a41c380fb5ca5b2b3efa7bf6e980273cc544757a9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651751273&amp;amp;idx=1&amp;amp;sn=388f666fd1bce3413d8564662b120b71&amp;amp;chksm=bd125a248a65d332417c729d9e434157236a41c380fb5ca5b2b3efa7bf6e980273cc544757a9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Logan Web：前端日志在Web端的实现&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt;&lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651748960&amp;amp;idx=1&amp;amp;sn=2bd11c883ecc787e634bc3c29dfbbe50&amp;amp;chksm=bd12a32d8a652a3b25f26de739555341937697e02f2f01017129514624cdb0dd2e2bdd844acb&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Logan：美团开源移动端基础日志库&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651747596&amp;amp;idx=2&amp;amp;sn=6e08a25d203c3e05461b3c1c5f238e82&amp;amp;chksm=bd12ac418a65255743ac6e7758b65f8d5369fde0bb902cee62bbe627f6a4bb307edf76287477&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Android动态日志系统Holmes&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;---&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7r&quot; textvalue=&quot;前端&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;前端&lt;/a&gt;&lt;strong&gt;&lt;span&gt; |&lt;/span&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt; &lt;/strong&gt; &lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jsdG&quot; textvalue=&quot;算法&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;算法&lt;/a&gt;&lt;strong&gt; |&lt;/strong&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jsWK&quot; textvalue=&quot;后端&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;后端&lt;/a&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt; | &lt;/span&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jqRZ&quot; textvalue=&quot;数据&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;数据&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;安全&lt;/a&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jui4&quot; textvalue=&quot;Android&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Android&lt;/a&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jtXE&quot; textvalue=&quot;iOS&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;iOS&lt;/a&gt; &lt;strong&gt; |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7K&quot; textvalue=&quot;运维&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;运维&lt;/a&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jtsX&quot; textvalue=&quot;测试&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;测试&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NjQ5MTI5OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVGibnsaEib3aNlqF0tOrA2RGEmNSbia2nnohE4Tpf95UyTiaSjDVbHRfY8WNBeTuLLTaVdSckkNyEx1Q/0?wx_fmt=png&quot; data-nickname=&quot;美团技术团队&quot; data-alias=&quot;meituantech&quot; data-signature=&quot;10000+工程师，如何支撑中国领先的生活服务电子商务平台？数亿消费者、数百万商户、2000多个行业、几千亿交易额背后是哪些技术在支撑？这里是美团、大众点评、美团外卖、美团配送、美团优选等技术团队的对外窗口。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ee6d035c98915430fd1d24d20bab616f</guid>
<title>设计模式系列：工厂模式</title>
<link>https://toutiao.io/k/glcmo5r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;工厂模式属于创建型设计模式。是日常使用比较多的一种设计模式。比如&lt;code&gt;Logback&lt;/code&gt;，&lt;code&gt;Spring&lt;/code&gt;等框架中都大量使用该设计模式。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484174&amp;amp;idx=1&amp;amp;sn=5c382541660563b718ffde9470605110&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;上篇文章&lt;/a&gt;提到的&lt;strong&gt;简单工厂模式&lt;/strong&gt;虽然在简单系统可以用一用，但是因为工厂类本身包含太多业务逻辑，而且如果想增加新的图表类型，需要修改工厂类等缺点。所以我们真正生产系统更多的使用工厂模式。&lt;/p&gt;&lt;p&gt;工厂模式为每一个类都定义一个单独的工厂类，该工厂类只负责创建单一的产品。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;举个例子&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;通过工厂模式实现日志的创建，为不同种类的&lt;code&gt;Logger&lt;/code&gt;分别创建不同类型的工厂。&lt;/p&gt;&lt;p&gt;来看一下UML图:&lt;/p&gt;&lt;figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6126482213438735&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/jmjNkE9L9QjriahfkJibne3GYBranOyKaGz3EiavYQwW0bfgdiacUO8Dlo99O6ZGVchClDibpvwq85RpocI4bGhqCog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;759&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;来看一下代码如何实现&lt;/p&gt;&lt;p&gt;先来定义一个&lt;code&gt;Logger&lt;/code&gt;接口，以及&lt;code&gt;LoggerFactory&lt;/code&gt;接口&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Logger&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;writeLogger&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;LoggerFactory&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;Logger &lt;span&gt;createLogger&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;分别定义&lt;code&gt;FileLogger&lt;/code&gt;和&lt;code&gt;FileLoggerFactory&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FileLogger&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Logger&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;writeLogger&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;File logger&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FileLoggerFactory&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LoggerFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Logger &lt;span&gt;createLogger&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//不同Logger的个性初始化工作&lt;/span&gt;&lt;br/&gt;        Logger logger =  &lt;span&gt;new&lt;/span&gt; FileLogger();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; logger;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果想增加新的&lt;code&gt;Logger&lt;/code&gt;直接实现&lt;code&gt;Logger&lt;/code&gt;和&lt;code&gt;LoggerFactory&lt;/code&gt;就好了，看一下客户端如何使用&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Client&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        Logger logger;&lt;br/&gt;        LoggerFactory loggerFactory;&lt;br/&gt;&lt;br/&gt;        loggerFactory = &lt;span&gt;new&lt;/span&gt; FileLoggerFactory();&lt;br/&gt;        logger = loggerFactory.createLogger();&lt;br/&gt;        logger.writeLogger();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;工厂模式是创建型模式之一，日常使用比较多，每类产品都有对应的一个工厂类。工厂模式把简单工厂的内部逻辑迁移到了客户端，当需要对功能扩展时，只需要修改客户端就OK了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484022&amp;amp;idx=1&amp;amp;sn=d3176ea73e48360b64c3f50e8fd622bf&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;1. Java并发编程那些事儿(十)——最后的总结&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484130&amp;amp;idx=1&amp;amp;sn=eb09dd99d1a8e892a3de73d898c04b0c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;2. 程序员应该掌握的常用网络问题定位工具&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483893&amp;amp;idx=1&amp;amp;sn=85f6a2063048cc244aedde3172444e32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;3. Awk这件上古神兵你会用了吗&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483852&amp;amp;idx=1&amp;amp;sn=6efb0db3d5dff639fae2aaec978c2160&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;4. 手把手教你搭建一套ELK日志搜索运维平台&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c915cda33454c2e2db11ecfd2ae11ee5</guid>
<title>流式计算框架 MegFlow 开源，帮助铲屎官实现花样宠溺</title>
<link>https://toutiao.io/k/gll08ju</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p&gt;关于程序员为什么喜欢养猫的回答，网友们给出了很多答案，比如一边吸猫一边写代码，效率更高；养猫不容易脱发；更容易交到女朋友……&lt;/p&gt;&lt;p&gt;当然，除了喜欢养猫，程序员也喜欢开脑洞，发挥自己的专长，给“猫主子们”安排上各种高科技——自动投喂机、自动饮食机、自动按摩仪……甚至在训模型的时候用猫来做测试，识别猫咪的情绪、听懂猫咪语言。&lt;/p&gt;&lt;p&gt;现在就有一款 AI 应用，研发初衷只是铲屎官程序员想要为“主子”实现猫咪围栏识别，开箱即用背后的能力正是来自 MegFlow 流式计算框架。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2e5486cadac557160bb941d71842d304_b.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;1080&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-2e5486cadac557160bb941d71842d304_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-2e5486cadac557160bb941d71842d304_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;1080&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-2e5486cadac557160bb941d71842d304_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-2e5486cadac557160bb941d71842d304_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2e5486cadac557160bb941d71842d304_b.gif&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a443300aac19e1b65e9d741bb47147f1_b.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;744&quot; data-rawheight=&quot;1080&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-a443300aac19e1b65e9d741bb47147f1_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-a443300aac19e1b65e9d741bb47147f1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;744&quot; data-rawheight=&quot;1080&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-a443300aac19e1b65e9d741bb47147f1_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-a443300aac19e1b65e9d741bb47147f1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a443300aac19e1b65e9d741bb47147f1_b.gif&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;近日，旷视开源深度学习框架 MegEngine 开源了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/MegEngine/MegFlow&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MegFlow&lt;/a&gt; 流式计算框架，助力 AI 算法开发者快速完成 AI 模型的落地应用。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;MegFlow 是面向计算机视觉应用的流式计算框架，提供了一套可快速完成 AI 应用部署的视觉解析服务方案。AI 应用开发者可以基于 MegFlow 提供的图像和视频解析服务，最快 15 分钟即可完成客制化所需功能，例如发票扫描、明火检测等。&lt;/p&gt;&lt;p&gt;常规的 AI 算法交付流程一般分为模型训练、SDK 封装、业务集成和交付验收四个步骤，冗长繁杂。&lt;b&gt;而 MegFlow 提供了一种更为简洁的视觉应用落地流程，用户可以直接用 Python 搭建计算图，不必关心 C++、图优化相关问题，省去了 SDK 封装流程，可快速实现算法交付。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;MegFlow 针对 AI 算法工程落地中的频发问题，诸如性能调优、安全性、模型加密等，都能提供行之有效的解决方案并有效提升了工程效率。MegFlow 拥有安全可靠、简单易用、语义支持丰富等特性，可以帮助 AI 应用快速落地。&lt;/p&gt;&lt;p&gt;&lt;b&gt;安全可靠&lt;/b&gt;&lt;/p&gt;&lt;p&gt;技术选型上， MegFlow 的研发团队调研了多种技术方案，最终选择了安全且零额外开销的 Rust 异步生态，从基础上保证了 MegFlow 的安全性与性能。&lt;/p&gt;&lt;p&gt;&lt;b&gt;简单易用&lt;/b&gt;&lt;/p&gt;&lt;p&gt;MegFlow 支持 Python 插件，且仅需要开发者编写同步的 Python 程序，即可实现可以被MegFlow 异步调度的 Python 插件。同时 MegFlow 提供了一套基于 Web UI的可视化调试工具，可有效提升模型部署的工作效率。&lt;/p&gt;&lt;p&gt;&lt;b&gt;语义支持丰富&lt;/b&gt;&lt;/p&gt;&lt;p&gt;表达能力上，MegFlow 支持静态图、动态图和共享图，辅以 demux、reorder、transform等函数式语义的通用插件，为搭建多样化的 AI 服务提供了丰富的语义支持。&lt;/p&gt;&lt;p&gt;MegFlow 使用相关，欢迎参考社区开发者的实践文章：&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://zhuanlan.zhihu.com/p/408791160&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-text=&quot;SunnyCase：AI 应用落地利器 - MegFlow 尝鲜&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://zhuanlan.zhihu.com/p/409279000&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-text=&quot;BBuf：MegFlow尝鲜测试&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p&gt;目前，MegFlow 已内置了开箱即用的 AI 应用，如电瓶车检测和宠物围栏检测：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;电瓶车检测应用则为物业管理者提供了智能化管理工具，如摄像头检测到电瓶车进入电梯，系统会发出通知，提醒管理人员，有效排除起火安全隐患。&lt;/li&gt;&lt;li&gt;宠物围栏检测目前支持猫咪检测，注册过的猫咪离开围栏会发出告警。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2b6896ca06d6f5393b7db7d34e0192ba_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1020&quot; data-rawheight=&quot;1020&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-2b6896ca06d6f5393b7db7d34e0192ba_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1020&quot; data-rawheight=&quot;1020&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-2b6896ca06d6f5393b7db7d34e0192ba_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2b6896ca06d6f5393b7db7d34e0192ba_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;附：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/MegEngine&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/MegEngine&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/MegEngine/megflow&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/MegEngine/me&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;gflow&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;官网：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//megengine.org.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MegEngine-深度学习，简单开发&lt;/a&gt;&lt;/p&gt;&lt;p&gt;欢迎加入 MegEngine 技术交流 QQ 群：1029741705&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>be1b7a38998da92e9df65abfd9496470</guid>
<title>2021 年预训练语言模型及微调的最新进展</title>
<link>https://toutiao.io/k/x3l6hpe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;    尽管这在NLP中效果不佳（Howard＆Ruder，2018：https://www.aclweb.org/anthology/P18-1031/），但还有其他一些参数子集可以更有效地进行微调。例如，Ben-Zaken（2020年：https://nlp.biu.ac.il/~yogo/bitfit.pdf）仅通过微调模型的偏执参数即可获得非常好的效果。&lt;/p&gt;&lt;p&gt;    另一系列工作是在微调期间修剪预训练模型的参数。此类方法使用不同的标准来修剪权重，例如基于关于权重重要性的零级或一阶信息（Sanh等人，2020年：https://papers.nips.cc/paper/2020/file/eae15aabaa768ae4a5993a8a4f4fa6e4-Paper.pdf）。由于当前硬件对稀疏架构的支持有限，因此目前最好采用结构稀疏的方法，即，将更新集中在一组有限的层，矩阵或向量中。例如，预训练模型的最后几层已表明在微调过程中用途有限，可以随机重新初始化（Tamkin等，2020：https://www.aclweb.org/anthology/2020.findings-emnlp.125/；Zhang等，2021：https://openreview.net/forum?id=cO1IH43yUF），甚至完全删除（Chung等，2021：https://openreview.net/forum?id=xpFFI_NtgpW）。&lt;/p&gt;&lt;p&gt;    修剪方法着重于减少特定于任务的模型的参数总数，而其他大多数方法着重于减少可训练参数的数量，同时保留一个副本。θ（pre-trained）。后一种方法中的最新方法通常与完全微调的性能相当，同时只训练每个任务模型参数的约0.5％（Pfeiffer等，2020：https://www.aclweb.org/anthology/2020.emnlp-main.617/ ;）。&lt;/p&gt;&lt;p&gt;    越来越多的证据表明，大型的预训练语言模型可以很好地压缩NLP任务（Li等人，2018年:https://openreview.net/forum?id=ryup8-WCW; Gordon等人，2020年:https://www.aclweb.org/anthology/2020.repl4nlp-1.18/）。这些实践证据以及它们的便利性，可用性（Pfeiffer等人，2020年：https://www.aclweb.org/anthology/2020.emnlp-demos.7/）以及最近的经验成功使这些方法在进行实验以及在实际环境中都有收益。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;文本到文本的微调&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    迁移学习的另一个发展是从诸如BERT（Devlin等，2019：https://www.aclweb.org/anthology/N19-1423/）和RoBERTa（Liu等，2019）的掩蔽语言模型向诸如T5（Raffel等，2019）的语言的自回归模型的转变。GPT-3（Brown等人，2020年）。虽然这两种方法都可以用于为文本分配似然度分数（Salazar等，2020），但自回归LM模型更容易从中进行采样。相比之下，被masked的LM通常仅限于填空场景，例如（Petroni等，2019）。&lt;/p&gt;&lt;p&gt;    使用masked LM进行微调的标准方法是用针对目标任务学习的随机初始化的特定于任务的head替换用于MLM的输出层（Devlin等人，2019年：https://www.aclweb.org/anthology/N19-1423/）。或者，可以通过以克隆的方式将任务重铸为MLM，来重新使用经过预训练的模型的输出层（Talmor等人，2020：https://www.aclweb.org/anthology/2020.tacl-1.48/；Schick和Schütze，2021：https://arxiv.org/abs/2001.07676）。类似地，自回归LM通常以文本到文本格式投射目标任务（McCann等，2018 ：https://arxiv.org/abs/1806.08730; Raffel等，2020：https://jmlr.org/papers/v21/20-074.html ; Paolini等，2021：https://openreview.net/forum?id=US-TP-xnXI）。在这两种场景中，这些模型能够从其所有预先训练的知识中受益，并且无需从头开始学习任何新参数，从而提高了样本效率。&lt;/p&gt;&lt;p&gt;    在极端情况下，如果不对参数进行微调，则根据预训练目标来构架目标任务，可以使用特定于任务的提示和少量任务样本来实现零镜头或少镜头学习（Brown等人，2020：https://papers.nips.cc/paper/2020/file/1457c0d6bfcb4967418bfb8ac142f64a-Paper.pdf）。但是，尽管可以进行这样的少量学习，但这并不是使用这种模型的最有效方法（Schick和Schütze，2020年：https://arxiv.org/abs/2009.07118；有关简要概述，请参阅此文章）。没有更新的学习需要一个巨大的模型，因为该模型需要完全依靠其现有知识。该模型可用的信息量也受到其上下文窗口的限制，并且显示模型的提示需要仔细设计。&lt;/p&gt;&lt;p&gt;    检索增强（有关概述，请参阅本文：https://ruder.io/research-highlights-2020/#2-retrieval-augmentation）可用于减轻外部知识的存储负担，而符号方法可用于教授类似于任务特定的模型规则（Awasthi等人，2020年：https://openreview.net/forum?id=SkeuexBtDr）。预先训练的模型也将变得更大，更强大，并且可能会进行行为上的微调，以使其在零样本场景下表现出色。但是，如果不进行微调，模型最终适应新任务的能力将受到限制。&lt;/p&gt;&lt;p&gt;    因此，对于大多数实际场景而言，最好的前进路径无疑是使用前面各节中描述的方法对模型参数的全部或子集进行微调。 此外，我们将越来越多地看到预训练模型的生成能力。虽然当前的方法通常集中于修改模型的自然语言输入，例如通过自动提示设计（Schick和Schütze，2020：https://arxiv.org/abs/2009.07118），但这是调节此类自然输出的最有效方法。模型可能会直接作用于其隐藏的表示上（Dathathri等人，2020：https://openreview.net/forum?id=H1edEyBKDS；请参阅Lillian Weng的文章 以了解可控文本生成方法的概述：https://lilianweng.github.io/lil-log/2021/01/02/controllable-neural-text-generation.html）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;减轻微调的不稳定性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    微调预训练模型的一个实际问题是，不同训练之间的性能可能会发生巨大变化，尤其是在小型数据集上（Phang等人，2018：https://arxiv.org/abs/1811.01088）。Dodge等人（2020年：https://arxiv.org/abs/2002.06305）发现，输出层的权重初始化和训练数据的顺序都会导致性能变化。由于不稳定通常在训练的早期就很明显，因此他们建议在训练20-30％之后尽早停止最没有希望的训练。Mosbach等（2021：https://openreview.net/forum?id=nzpLWnVAyah）另外建议在调整BERT时使用较小的学习率并增加epoch数。&lt;/p&gt;&lt;p&gt;    最近的许多方法试图通过依靠基于对抗或信任区域的方法来减轻微调过程中的不稳定性（Zhu等人，2019：https://openreview.net/forum?id=BygzbyHFvB；Jiang等人，2020：https://www.aclweb.org/anthology/2020.acl-main.197/；Aghajanyan等人，2021：https://openreview.net/forum?id=OQ08SN70M1V）。此类方法通常使用限制更新步骤之间差异的正则化项来增加微调损耗。&lt;/p&gt;&lt;p&gt;    根据上一节的内容，我们可以提出另一种建议以最小化微调过程中的不稳定性：通过将目标任务以LM的形式进行框架或使用行为微调，避免在小型数据集的目标任务上使用随机初始化的输出层在特定于任务的微调之前对输出层进行微调。因此，文本到文本模型对于在小型数据集上进行微调更为健壮，但它们在“少样本”场景中会遇到不稳定性，并且对即时和少样本很敏感（Zhao等人，2021年：https://arxiv.org/abs/2102.09690）。&lt;/p&gt;&lt;p&gt;    总体而言，随着模型越来越多地用于具有较少样本的具有挑战性的任务，因此开发对可能的变化具有鲁棒性并且可以可靠地进行微调的方法至关重要。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>