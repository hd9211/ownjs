<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b4af861e9a9388e6603464938387cf84</guid>
<title>Java中不容拒绝的一种优雅的写法</title>
<link>https://toutiao.io/k/un3ejpz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;74&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;期末考试成绩公布了，一学生气愤地找老师评理。学生：“老师，我认为这门课我不应该得零分。”老师：“是啊，我也这么认为，可学校规定，最低只能打零分。”&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;做CodeReview的时候，评价一段代码的好坏通常是仁者见仁。还好有一种无法拒绝的理由叫做【规定】。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlibpMFn6yJ42PkM6FDR6NNvsYdq0VpeJliadzl4DDkA3kKOqg2b7BNK20waUBwmgRPDnayftSISCxiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面讲一种通过规定以理服人的例子：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;观点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;不要用xx != null &amp;amp;&amp;amp; xx.length()&amp;gt;0 来判空，可以使用apache的commons包。例如使用：&lt;/p&gt;&lt;p&gt;StringUtils.isNotEmpty&lt;/p&gt;&lt;p&gt;CollectionUtils.isEmpty&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;不容拒绝理由&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;使用xx != null &amp;amp;&amp;amp; xx.length()&amp;gt;0 来判空，公司里的静态代码检查会检查让你覆盖这两个条件，你需要写两个单测来完成任务。而使用apache的commons只需要写一个单测。你的条件覆盖率达标了吗？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;深层原因&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;【编程一生】的文章怎么可能只给一个不容拒绝的理由这么浅。建议这样使用毕竟有背后深层的优势，拿StringUtils.isNotEmpty举例看看apache的代码优雅在哪里。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;StringUtils类的源码：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public static boolean &lt;/span&gt;isNotEmpty(String str) {&lt;br/&gt;    &lt;span&gt;return &lt;/span&gt;!isEmpty(str)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span&gt;public static boolean &lt;/span&gt;isEmpty(String str) {&lt;br/&gt;    &lt;span&gt;return &lt;/span&gt;str == &lt;span&gt;null &lt;/span&gt;|| str.length() == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;咦，好像和自己实现的差不多嘛！str == null || str.length() == 0 取个反，还多个一个反运算。效率一点也不高嘛！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;请注意这两个方法是静态的！静态方法&lt;span&gt;在类加载时候初始化，常驻在内存中只存一份。而自己写的判断语句，只能这个方法使用，其他方法同样的语句要复制一份。静态方法更加方便快捷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，apache的commons最根本的优势是语义更加清晰，更易读。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;往期推荐&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>90bc984a00d6789de7bffbbf6aa0f0b9</guid>
<title>优质网站同好者周刊（第 43 期）- 倾城之链 - 悠然宜想亭</title>
<link>https://toutiao.io/k/x0lt9mu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Post-body&quot;&gt;
                    &lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot; rel=&quot; nofollow ugc&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot; rel=&quot; nofollow ugc&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot; rel=&quot; nofollow ugc&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot; rel=&quot; nofollow ugc&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot; rel=&quot; nofollow ugc&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%9B%BE%E7%89%87&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;图片&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B7%A5%E5%85%B7&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;工具&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E4%B8%8B%E8%BD%BD&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;下载&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：extract images online, image extractor, download images, view images, extract images from website, download images from website, image bulk downloader, find images on website&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;A free tool to extract, view and download images from any website by using a virtual browser.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/extract.pics.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Image Extractor&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://extract.pics/&quot; rel=&quot; nofollow ugc&quot;&gt;Extract.pics&lt;/a&gt; 是一个易于使用的工具，允许您从任何公共网站提取、查看和下载图像。只需将网站的 URL 粘贴到输入字段中，然后单击“提取”即可开始该过程。完全免费使用！&lt;/p&gt;

&lt;p&gt;提取过程将需要几秒钟，以确保它找到尽可能多的图像。完成后，您将在有组织的网格中看到所有图像。您现在可以通过按大小、宽度、高度或找到它们的顺序对找到的图像进行&lt;strong&gt;排序&lt;/strong&gt;来探索找到的图像。此外，您可以按名称、大小或类型/文件格式&lt;strong&gt;搜索&lt;/strong&gt;图像。这使得准确地找到您需要的图像变得非常容易。&lt;/p&gt;

&lt;p&gt;您现在可以使用&lt;strong&gt;缩放工具在&lt;/strong&gt;浅色或深色背景下&lt;strong&gt;检查&lt;/strong&gt;图像、&lt;strong&gt;下载&lt;/strong&gt;单个图像并&lt;strong&gt;复制&lt;/strong&gt;图像&lt;strong&gt;的 URL&lt;/strong&gt;。如果您想一次&lt;strong&gt;下载多个&lt;/strong&gt;图像，您可以选择所有需要的图像，然后将它们全部下载到&lt;strong&gt;ZIP 存档中&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;同类型的网站，还有 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://imagecyborg.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Image Cyborg&lt;/a&gt;&lt;br/&gt;
、&lt;a href=&quot;https://nicelinks.site/redirect?url=https://imgdownloader.com/&quot; rel=&quot; nofollow ugc&quot;&gt;ImgDownloader - Bulk Download Image from Website and URL&lt;/a&gt;，有初步做了比较：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://imagecyborg.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Image Cyborg&lt;/a&gt; 批量下载网页上的所有图像。只需粘贴 URL 或链接即可获取图像。（评价：下载的图片，很全面；但，您需要创建一个免费帐户或登录才能使用此应用程序，这一点不是很方便）；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://imgdownloader.com/&quot; rel=&quot; nofollow ugc&quot;&gt;ImgDownloader - Bulk Download Image from Website and URL&lt;/a&gt; 强大的图像下载工具，可让您&lt;strong&gt;从任何网站下载所有图像，谷歌图像&lt;/strong&gt;。&lt;strong&gt;从 Pinterest 和 Instagram 下载所有图片和视频&lt;/strong&gt;！只需复制并粘贴 URL，即可立即获取所有图像、图片或视频，mp4。（评价：下载的图片，很全面；而且可以处理来自网站以外的图片）；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://extract.pics/&quot; rel=&quot; nofollow ugc&quot;&gt;Extract.pics&lt;/a&gt; 是一个易于使用的工具，允许您从任何公共网站提取、查看和下载图像。只需将网站的 URL 粘贴到输入字段中，然后单击“提取”即可开始该过程。（评价：下载的图片，似乎不够全面；但提供了更加强大的能力，使得您可以更快找到您需要的图像）；&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;如果您从公共网站提取、查看和下载图像的诉求，您可按需使用相关工具；目前而言（2021 年 12 月），更推荐使用 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://imgdownloader.com/&quot; rel=&quot; nofollow ugc&quot;&gt;ImgDownloader&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/61b2002a48f785032a2400b0&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Image Extractor&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%9C%A8%E7%BA%BF&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;在线&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/IDE&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;IDE&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BC%96%E8%BE%91%E5%99%A8&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;编辑器&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Replit is a simple yet powerful online IDE, Editor, Compiler, Interpreter, and REPL. Code, compile, run, and host in 50+ programming languages.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/replit.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - The collaborative browser based IDE&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://replit.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Replit&lt;/a&gt; 是一个简单而强大的在线 IDE、编辑器、编译器、解释器和 REPL。使用 50 多种编程语言进行编码、编译、运行和托管。它具有以下功能特征：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;浏览器内IDE&lt;/strong&gt;：在任何平台、操作系统和设备上使用您喜欢的语言开始编码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时协作&lt;/strong&gt;：使用诸如编辑之类的 Google 文档邀请您的朋友、队友和同事直接进入您的代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GitHub 集成&lt;/strong&gt;：通过 0 次手动设置导入、运行和协作处理数百万个 GitHub 存储库。-&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;50 多种语言&lt;/strong&gt;：从 Python 到 C++，再到 HTML 和 CSS，留在一个平台上，用您想要的任何语言学习和编码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;托管和部署&lt;/strong&gt;：当你创建一个新的 repl 时，它会立即生效并与世界共享。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;学习资源&lt;/strong&gt;：从超过 300 万热情的程序员、技术专家、创意人员和各种学习者那里学习如何编码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;团队计划&lt;/strong&gt;：通过交互式文档、实时协作和零麻烦的远程面试提高您的团队的工作效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;API 和插件&lt;/strong&gt;：以编程方式创建应用程序、启动机器人并使用插件自定义 IDE 以满足您的需求。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;因为 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://replit.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Replit&lt;/a&gt; 直接在浏览器中编码，且支持多人协作（享受类似于 Google 文档的编辑体验，您可以在其中看到协作者的光标），因为用它来做代码相关交流、学习，看起来挺有价值。在其官方网站写道：“是为了让编程更容易上手。我们为教育者、学习者和开发者构建强大而简单的工具和平台“。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/61b1f5ff48f785032a2400ae&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - The collaborative browser based IDE&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%B9%B3%E5%8F%B0&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;平台&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%9C%8D%E5%8A%A1&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;服务&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B7%A5%E5%85%B7&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;工具&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;兔小巢是腾讯推出的一款轻量、免费的用户意见反馈服务平台，旨在方便地嵌入APP/微信公众号/QQ公众号，为中小企业或团队快速搭建用户反馈通道，帮助产品提升服务水平和效率&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/txc.qq.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - 腾讯兔小巢-免费便捷的用户意见反馈服务平台&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://txc.qq.com/&quot; rel=&quot; nofollow ugc&quot;&gt;兔小巢&lt;/a&gt;是腾讯推出的一款轻量、&lt;code&gt;免费&lt;/code&gt;的用户意见反馈服务平台。几行代码 拥有和腾讯网一样的互动社区，让反馈变得便捷，轻巧；对运营人员（不再疲于运营）、程序员（不必自建反馈）、产品经理（微信推送回复）都能产生作用：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;运营人员：无需登录后台即可简单管理，你与客户的沟通平台永远简洁有序；&lt;/li&gt;
&lt;li&gt;程序员：几行代码将兔小巢放入在任何地方，包括公众号、APP、H5、网站等；&lt;/li&gt;
&lt;li&gt;产品经理：用户通过微信收到你的回复，你与用户沟通更加高效；&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://txc.qq.com/&quot; rel=&quot; nofollow ugc&quot;&gt;兔小巢&lt;/a&gt;可轻松定制属于自己的反馈平台，一站式满足管理、技术、客服、运营等多角色使用需求，同时享用安全稳定、高性能、高延展的底层设施。看似复杂的系统，从此触手可及。您可以从以下几个功能特征，更加全面了解&lt;a href=&quot;https://nicelinks.site/redirect?url=https://txc.qq.com/&quot; rel=&quot; nofollow ugc&quot;&gt;兔小巢&lt;/a&gt;：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;数据一键导出&lt;/strong&gt;：方便导出所有数据，方便数据的其他使用；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不介入数据&lt;/strong&gt;：只负责技术支撑，不介入任何产品数据；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;稳定可靠&lt;/strong&gt;：腾讯门神等多个安全系统为反馈数据保驾护航；&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;其他如&lt;a href=&quot;https://nicelinks.site/post/5b40437e615bf842b6091043&quot; rel=&quot; nofollow ugc&quot;&gt;语雀&lt;/a&gt;也具有类似的功能，虽然功能后续更强大，只可惜不是所有用户都具有其账号；先前做的几款 Web（如&lt;a href=&quot;https://nicelinks.site/redirect?url=https://support.qq.com/products/368784&quot; rel=&quot; nofollow ugc&quot;&gt;曼妙句子&lt;/a&gt;） 也是采用&lt;a href=&quot;https://nicelinks.site/redirect?url=https://txc.qq.com/&quot; rel=&quot; nofollow ugc&quot;&gt;兔小巢&lt;/a&gt;作为反馈平台，省却很多麻烦；与用户沟通，相对要高效很多。对此感兴趣的朋友，可以查看&lt;a href=&quot;https://nicelinks.site/redirect?url=https://txc.qq.com/helper/fiveFaq&quot; rel=&quot; nofollow ugc&quot;&gt;兔小巢接入文档&lt;/a&gt;，从而了解更多。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/61ae1bfd9b06756d7dc1a3fb&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - 腾讯兔小巢-免费便捷的用户意见反馈服务平台&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%99%A8&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;网站生成器&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B7%A5%E5%85%B7&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;工具&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%97%A0%E4%BB%A3%E7%A0%81&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;无代码&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：Low code platform,Custom software,Web application builder,internal tools,internal tool builder&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Budibase is a modern, open source low-code platform for building modern internal applications in minutes.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/budibase.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Budibase | Create modern business apps in minutes&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://budibase.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Budibase&lt;/a&gt;，是一个&lt;strong&gt;开源&lt;/strong&gt;的低代码平台，是一种构建业务应用程序的更快方法，可以为团队赋能并提高生产力。&lt;a href=&quot;https://nicelinks.site/redirect?url=https://budibase.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Budibase&lt;/a&gt; 汇集了构建业务应用程序所需的一切，并将最佳的开发人员体验与对速度、性能和用户体验的执着关注相结合。您可以从以下几个功能特征，来了解 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://budibase.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Budibase&lt;/a&gt; 的强大：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;内部工具&lt;/strong&gt;：创建可简化操作并无缝融入您的工作流程的内部工具。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;形式&lt;/strong&gt;：使用 Budibase 一流的表单生成器公开、私下或同时收集数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;管理面板&lt;/strong&gt;：连接到您的数据库并在几分钟内构建一个具有相关权限的管理面板。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传送门&lt;/strong&gt;：为您的客户、合作伙伴、供应商和员工创建安全且引人入胜的门户。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开源和免费&lt;/strong&gt;：Budibase 是开源的，您可以在自己的基础架构上自托管 Budibase 应用程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内部数据库&lt;/strong&gt;：Budibase 有一个内部数据库，可让您在几分钟内构建业务应用程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;公共和私人应用&lt;/strong&gt;：使用 Budibase，您可以轻松快速地构建公共和私有应用程序，或两者兼而有之。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;除上述提及的，&lt;a href=&quot;https://nicelinks.site/redirect?url=https://budibase.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Budibase&lt;/a&gt; 在&lt;strong&gt;数据&lt;/strong&gt;（连接到外部数据库、从 Rest API 提取数据、导入 CSV 或从头开始使用 Budibase 的内置数据库）、&lt;strong&gt;设计&lt;/strong&gt;（设计适用于所有设备的精美商务应用）、&lt;strong&gt;自动化&lt;/strong&gt;（只需单击几下即可自动执行手动流程）、部署（借助 Budibase 的开源平台，应用程序数据永远不必离开您的基础架构。通过 Kubernetes、Docker、Digital Ocean 进行部署。或者选择 Budibase Cloud，让 Budibase 为您管理一切。）等方面，也是做了出色的设定。&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://budibase.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Budibase&lt;/a&gt; 关于页面写到： Budibase 是一个专为提高速度和生产力而设计的开发平台。使用 Budibase，开发人员不再经历重复、长开发周期和挫折。相反，开发人员的工作效率更高、更快乐，并且可以在几分钟内交付他们引以为豪的应用程序。其使命是：打造全球领先的商业应用生态系统。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/61ab30102afff60541cdbaa8&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Budibase | Create modern business apps in minutes&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Markdown&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;Markdown&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B7%A5%E5%85%B7&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;工具&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BC%96%E8%BE%91%E5%99%A8&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;编辑器&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Simple and Elegant Markdown Editor Focused on speed and usability. Available for macOS, Windows and Linux.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/marktext.app.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Mark Text&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://marktext.app/&quot; rel=&quot; nofollow ugc&quot;&gt;Mark Text&lt;/a&gt;，一个简单而优雅的开源 Markdown 编辑器，专注于速度和可用性。适用于 Linux、macOS 和 Windows。Mark Text 是一个 MIT 许可的开源项目，最新版本将始终可以从 GitHub 发布页面免费下载。Mark Text 还在发展中，您可以从以下特征，来了解它的强大：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;实时预览 (WYSIWYG) 和干净简单的界面，以获得无干扰的写作体验。&lt;/li&gt;
&lt;li&gt;支持 CommonMark Spec、GitHub Flavored Markdown Spec 和选择性支持 Pandoc markdown。&lt;/li&gt;
&lt;li&gt;Markdown 扩展，例如数学表达式 (KaTeX)、前端和表情符号。&lt;/li&gt;
&lt;li&gt;支持段落和内联样式快捷方式，以提高您的写作效率。&lt;/li&gt;
&lt;li&gt;输出 &lt;strong&gt;HTML&lt;/strong&gt; 和 &lt;strong&gt;PDF&lt;/strong&gt; 文件。&lt;/li&gt;
&lt;li&gt;各种主题：&lt;strong&gt;Cadmium Light&lt;/strong&gt;、&lt;strong&gt;Material Dark&lt;/strong&gt; 等。&lt;/li&gt;
&lt;li&gt;多种编辑模式：&lt;strong&gt;源代码模式&lt;/strong&gt;、&lt;strong&gt;打字机模式&lt;/strong&gt;、&lt;strong&gt;焦点模式&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;直接从剪贴板粘贴图像&lt;/strong&gt;。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;为什么要写另一个编辑器？作者给出了说明：&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;我喜欢写作。我用了很多 markdown 编辑器，但仍然没有一个编辑器可以完全满足我的需求。当我写一些难以忍受的错误时，我不喜欢被打扰。Mark Text 使用虚拟 DOM 来呈现页面，这具有高效和开源的额外好处。这样任何喜欢 Markdown 和写作的人都可以使用 Mark Text。&lt;/li&gt;
&lt;li&gt;如上所述，Mark Text 是完全免费和开源的，并将永远开源。我们希望所有 Markdown 爱好者都能贡献自己的代码，帮助将 Mark Text 开发成流行的 Markdown 编辑器。&lt;/li&gt;
&lt;li&gt;有很多 Markdown 编辑器，它们都有自己的优点，有些具有其他人没有的功能。很难满足每个 Markdown 用户的需求，但我们希望 Mark Text 能够尽可能满足每个 markdown 用户。尽管最新的 Mark Text 仍然不完美，但我们会尽力做到最好。&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;个人也喜欢写作，而且喜欢 &lt;a href=&quot;https://nicelinks.site/tags/Markdown&quot; rel=&quot; nofollow ugc&quot;&gt;Markdown 编辑器&lt;/a&gt;来书写✍️；已尝试过很多相关产品，但 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://marktext.app/&quot; rel=&quot; nofollow ugc&quot;&gt;Mark Text&lt;/a&gt; 还是给我留下很深的印象，尤其是支持&lt;strong&gt;直接从剪贴板粘贴图像&lt;/strong&gt;这一功能；对 Markdown 编辑器感兴趣的朋友，不妨尝试下。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/61ab2c6f2afff60541cdbaa6&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Mark Text&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; title=&quot;&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;本期文末寄语&lt;/h2&gt;

&lt;p&gt;人的一生要经历太多的生离死别，那些突如其来的离别往往将人伤得措手不及。&lt;strong&gt;人生何处不相逢，但有些转身，真的就是一生，从此后会无期，永不相见&lt;/strong&gt;。 用力爱过的人，讲再见那一刻格外艰难。 世界上最遥远的距离不是生离死别，而是对方已经云淡风轻，你却念念不忘。── 白落梅《你若安好便是晴天 - 林徽因传》&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/300/h/300/interlace/1/ignore-error/1&quot; title=&quot;&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;您可能感兴趣的文章&lt;/h3&gt;


                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>423f12830f553c1add3fa7a7971396a0</guid>
<title>精妙绝伦的并发艺术品 — ConcurrentHashMap是如何保证线程安全的</title>
<link>https://toutiao.io/k/6ypqn5r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;| 前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阅读此篇文章，你需要有以下知识基础&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Java内存模型，可见性问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CAS&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HashMap底层原理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，在日常开发中使用的HashMap是线程不安全的，而线程安全类HashTable只是简单的在方法上加锁实现线程安全，效率低下，所以在线程安全的环境下我们通常会使用ConcurrentHashMap，但是又为何需要学习ConcurrentHashMap？用不就完事了？我认为学习其源码有两个好处：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;更灵活的运用ConcurrentHashMap&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;欣赏并发编程大师Doug Lea的作品，源码中有很多值得我们学习的并发思想，要意识到，线程安全不仅仅只是加锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我抛出以下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ConcurrentHashMap是怎么做到线程安全的？&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;get方法如何线程安全地获取key、value？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;put方法如何线程安全地设置key、value？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;size方法如果线程安全地获取容器容量？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;底层数据结构扩容时如果保证线程安全？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初始化数据结构时如果保证线程安全？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;ConcurrentHashMap并发效率是如何提高的？&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;和加锁相比较，为什么它比HashTable效率高？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，带着问题来继续看下去，欣赏并发大师精妙绝伦的并发艺术作品（以下讨论基于JDK1.8）&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;| 相关概念&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Amdahl定律&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此节定律描述均来自《Java并发编程实战》一书&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设F是必须被串行执行的部分，N代表处理器数量，Speedup代表加速比，可以简单理解为CPU使用率&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3149171270718232&quot; data-type=&quot;png&quot; data-w=&quot;181&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLbWbNNO4NVOIPxKPMic7zKg4u7CnQHhALBA7VkpZfHCWiauFFHkFeYU679DzdTQLHiazNbIibkRnkoVgg/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此公式告诉我们，当N趋近无限大，加速比最大趋近于1/F，假设我们的程序有50%的部分需要串行执行，就算处理器数量无限多，最高的加速比只能是2（20%的使用率），如果程序中仅有10%的部分需要串行执行，最高的加速比可以达到9.2（92%的使用率），但我们的程序或多或少都一定会有串行执行的部分，所以F不可能为0，所以，就算有无限多的CPU，加速比也不可能达到10（100%的使用率），下面给一张图来表示串行执行部分占比不同对利用率的影响：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7764530551415797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbue50Evic8ia9ibIeD4eBicfrLnbLfL8608CZWTv8ypibUevPPVZv83icOmdYMtQhldfMZfhJOzCpg2wRsicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1342&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此我们可以看出，程序中的可伸缩性（提升外部资源即可提升并发性能的比率）是由程序中串行执行部分所影响的，而常见的串行执行有锁竞争（上下文切换消耗、等待、串行）等等，这给了我们一个启发，可以通过减少锁竞争来优化并发性能，而ConcurrentHashMap则使用了锁分段（减小锁范围）、CAS（乐观锁，减小上下文切换开销，无阻塞）等等技术，下面来具体看看吧&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;| 初始化数据结构时的线程安全&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashMap的底层数据结构这里简单带过一下，不做过多赘述：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46598639455782315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbue50Evic8ia9ibIeD4eBicfrLnbB9gEab68FCD4j9Ixyxw4rkibJpEQYs2mYKlMaMlek26eiaKe73oep4kQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1764&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致是以一个Node对象数组来存放数据，Hash冲突时会形成Node链表，在链表长度超过8，Node数组超过64时会将链表结构转换为红黑树，Node对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&amp;lt;&lt;span&gt;K&lt;/span&gt;,&lt;span&gt;V&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Map&lt;/span&gt;.&lt;span&gt;Entry&lt;/span&gt;&amp;lt;&lt;span&gt;K&lt;/span&gt;,&lt;span&gt;V&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hash;&lt;br/&gt;  &lt;span&gt;final&lt;/span&gt; K key;&lt;br/&gt;  &lt;span&gt;volatile&lt;/span&gt; V val;&lt;br/&gt;  &lt;span&gt;volatile&lt;/span&gt; Node&amp;lt;K,V&amp;gt; next;&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，value和next指针使用了volatile来保证其可见性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JDK1.8中，初始化ConcurrentHashMap的时候这个&lt;code&gt;Node[]&lt;/code&gt;数组是还未初始化的，会等到第一次put方法调用时才初始化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; V &lt;span&gt;putVal&lt;/span&gt;&lt;span&gt;(K key, V value, &lt;span&gt;boolean&lt;/span&gt; onlyIfAbsent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt; || value == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; hash = spread(key.hashCode());&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; binCount = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt;[] tab = table;;) {&lt;br/&gt;            Node&amp;lt;K,V&amp;gt; f; &lt;span&gt;int&lt;/span&gt; n, i, fh;&lt;br/&gt;            &lt;span&gt;//判断Node数组为空&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (tab == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;//初始化Node数组&lt;/span&gt;&lt;br/&gt;                tab = initTable();&lt;br/&gt;          ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时是会有并发问题的，如果多个线程同时调用initTable初始化Node数组怎么办？看看大师是如何处理的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] initTable() {&lt;br/&gt;  Node&amp;lt;K,V&amp;gt;[] tab; &lt;span&gt;int&lt;/span&gt; sc;&lt;br/&gt;  &lt;span&gt;//每次循环都获取最新的Node数组引用&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || tab.length == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;//sizeCtl是一个标记位，若为-1也就是小于0，代表有线程在进行初始化工作了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((sc = sizeCtl) &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;//让出CPU时间片&lt;/span&gt;&lt;br/&gt;      Thread.yield(); &lt;span&gt;// lost initialization race; just spin&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//CAS操作，将本实例的sizeCtl变量设置为-1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, SIZECTL, sc, -&lt;span&gt;1&lt;/span&gt;)) {&lt;br/&gt;      &lt;span&gt;//如果CAS操作成功了，代表本线程将负责初始化工作&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;//再检查一遍数组是否为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || tab.length == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;          &lt;span&gt;//在初始化Map时，sizeCtl代表数组大小，默认16&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;//所以此时n默认为16&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;int&lt;/span&gt; n = (sc &amp;gt; &lt;span&gt;0&lt;/span&gt;) ? sc : DEFAULT_CAPACITY;&lt;br/&gt;          &lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;br/&gt;          &lt;span&gt;//Node数组&lt;/span&gt;&lt;br/&gt;          Node&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt; Node&amp;lt;?,?&amp;gt;[n];&lt;br/&gt;          &lt;span&gt;//将其赋值给table变量&lt;/span&gt;&lt;br/&gt;          table = tab = nt;&lt;br/&gt;          &lt;span&gt;//通过位运算，n减去n二进制右移2位，相当于乘以0.75&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;//例如16经过运算为12，与乘0.75一样，只不过位运算更快&lt;/span&gt;&lt;br/&gt;          sc = n - (n &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;      } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;//将计算后的sc（12）直接赋值给sizeCtl，表示达到12长度就扩容&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//由于这里只会有一个线程在执行，直接赋值即可，没有线程安全问题&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//只需要保证可见性&lt;/span&gt;&lt;br/&gt;        sizeCtl = sc;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; tab;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;table变量使用了volatile来保证每次获取到的都是最新写入的值:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] table;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就算有多个线程同时进行put操作，在初始化数组时使用了乐观锁CAS操作来决定到底是哪个线程有资格进行初始化，其他线程均只能等待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用到的并发技巧：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;volatile变量（sizeCtl）：它是一个标记位，用来告诉其他线程这个坑位有没有人在，其线程间的可见性由volatile保证。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CAS操作：CAS操作保证了设置sizeCtl标记位的原子性，保证了只有一个线程能设置成功&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;| put操作的线程安全&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接看代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; V &lt;span&gt;putVal&lt;/span&gt;&lt;span&gt;(K key, V value, &lt;span&gt;boolean&lt;/span&gt; onlyIfAbsent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt; || value == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException();&lt;br/&gt;  &lt;span&gt;//对key的hashCode进行散列&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; hash = spread(key.hashCode());&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; binCount = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;//一个无限循环，直到put操作完成后退出循环&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt;[] tab = table;;) {&lt;br/&gt;    Node&amp;lt;K,V&amp;gt; f; &lt;span&gt;int&lt;/span&gt; n, i, fh;&lt;br/&gt;    &lt;span&gt;//当Node数组为空时进行初始化&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (tab == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;      tab = initTable();&lt;br/&gt;    &lt;span&gt;//Unsafe类volatile的方式取出hashCode散列后通过与运算得出的Node数组下标值对应的Node对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//此时的Node对象若为空，则代表还未有线程对此Node进行插入操作&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((f = tabAt(tab, i = (n - &lt;span&gt;1&lt;/span&gt;) &amp;amp; hash)) == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;//直接CAS方式插入数据&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (casTabAt(tab, i, &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;                   &lt;span&gt;new&lt;/span&gt; Node&amp;lt;K,V&amp;gt;(hash, key, value, &lt;span&gt;null&lt;/span&gt;)))&lt;br/&gt;        &lt;span&gt;//插入成功，退出循环&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;                   &lt;span&gt;// no lock when adding to empty bin&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//查看是否在扩容，先不看，扩容再介绍&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((fh = f.hash) == MOVED)&lt;br/&gt;      &lt;span&gt;//帮助扩容&lt;/span&gt;&lt;br/&gt;      tab = helpTransfer(tab, f);&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      V oldVal = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;//对Node对象进行加锁&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;synchronized&lt;/span&gt; (f) {&lt;br/&gt;        &lt;span&gt;//二次确认此Node对象还是原来的那一个&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (tabAt(tab, i) == f) {&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (fh &amp;gt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            binCount = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;//无限循环，直到完成put&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt; e = f;; ++binCount) {&lt;br/&gt;              K ek;&lt;br/&gt;              &lt;span&gt;//和HashMap一样，先比较hash，再比较equals&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;br/&gt;                  ((ek = e.key) == key ||&lt;br/&gt;                   (ek != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.equals(ek)))) {&lt;br/&gt;                oldVal = e.val;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!onlyIfAbsent)&lt;br/&gt;                  e.val = value;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;              }&lt;br/&gt;              Node&amp;lt;K,V&amp;gt; pred = e;&lt;br/&gt;              &lt;span&gt;if&lt;/span&gt; ((e = e.next) == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;//和链表头Node节点不冲突，就将其初始化为新Node作为上一个Node节点的next&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;//形成链表结构&lt;/span&gt;&lt;br/&gt;                pred.next = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;K,V&amp;gt;(hash, key,&lt;br/&gt;                                          value, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;              }&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;          ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得关注的是tabAt(tab, i)方法，其使用Unsafe类volatile的操作volatile式地查看值，保证每次获取到的值都是最新的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &amp;lt;K,V&amp;gt; &lt;span&gt;Node&amp;lt;K,V&amp;gt; &lt;span&gt;tabAt&lt;/span&gt;&lt;span&gt;(Node&amp;lt;K,V&amp;gt;[] tab, &lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (Node&amp;lt;K,V&amp;gt;)U.getObjectVolatile(tab, ((&lt;span&gt;long&lt;/span&gt;)i &amp;lt;&amp;lt; ASHIFT) + ABASE);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然上面的table变量加了volatile，但也只能保证其引用的可见性，并不能确保其数组中的对象是否是最新的，所以需要Unsafe类volatile式地拿到最新的Node。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.509927797833935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbue50Evic8ia9ibIeD4eBicfrLnb3hWQbLNFbHUywheI04vvCNI2cEkEh9ictQfrtNIKZJx3LCb9yu3eeRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2216&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于其减小了锁的粒度，若Hash完美不冲突的情况下，可同时支持n个线程同时put操作，n为Node数组大小，在默认大小16下，可以支持最大同时16个线程无竞争同时操作且线程安全。当hash冲突严重时，Node链表越来越长，将导致严重的锁竞争，此时会进行扩容，将Node进行再散列，下面会介绍扩容的线程安全性。总结一下用到的并发技巧：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;减小锁粒度：将Node链表的头节点作为锁，若在默认大小16情况下，将有16把锁，大大减小了锁竞争（上下文切换），就像开头所说，将串行的部分最大化缩小，在理想情况下线程的put操作都为并行操作。同时直接锁住头节点，保证了线程安全&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Unsafe的getObjectVolatile方法：此方法确保获取到的值为最新。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;|扩容操作的线程安全&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在扩容时，ConcurrentHashMap支持多线程&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTI4MjI0MQ==&amp;amp;mid=2247488999&amp;amp;idx=3&amp;amp;sn=11f79881bf2e8130bbe7970b075aa349&amp;amp;chksm=fc7a7849cb0df15f34ea31df979bc24928072dfc4b986cfdccd68c589a733061e6fe832a21e4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;并发扩容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;并发扩容&lt;/a&gt;，在扩容过程中同时支持get查数据，若有线程put数据，还会帮助一起扩容，这种无阻塞算法，将并行最大化的设计，堪称一绝。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;先来看看扩容代码实现：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;transfer&lt;/span&gt;&lt;span&gt;(Node&amp;lt;K,V&amp;gt;[] tab, Node&amp;lt;K,V&amp;gt;[] nextTab)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; n = tab.length, stride;&lt;br/&gt;  &lt;span&gt;//根据机器CPU核心数来计算，一条线程负责Node数组中多长的迁移量&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ((stride = (NCPU &amp;gt; &lt;span&gt;1&lt;/span&gt;) ? (n &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;3&lt;/span&gt;) / NCPU : n) &amp;lt; MIN_TRANSFER_STRIDE)&lt;br/&gt;    &lt;span&gt;//本线程分到的迁移量&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//假设为16（默认也为16）&lt;/span&gt;&lt;br/&gt;    stride = MIN_TRANSFER_STRIDE; &lt;span&gt;// subdivide range&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//nextTab若为空代表线程是第一个进行迁移的&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//初始化迁移后的新Node数组&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (nextTab == &lt;span&gt;null&lt;/span&gt;) {            &lt;span&gt;// initiating&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;//这里n为旧数组长度，左移一位相当于乘以2&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;//例如原数组长度16，新数组长度则为32&lt;/span&gt;&lt;br/&gt;      Node&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt; Node&amp;lt;?,?&amp;gt;[n &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;      nextTab = nt;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Throwable ex) {      &lt;span&gt;// try to cope with OOME&lt;/span&gt;&lt;br/&gt;      sizeCtl = Integer.MAX_VALUE;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//设置nextTable变量为新数组&lt;/span&gt;&lt;br/&gt;    nextTable = nextTab;&lt;br/&gt;    &lt;span&gt;//假设为16&lt;/span&gt;&lt;br/&gt;    transferIndex = n;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;//假设为32&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; nextn = nextTab.length;&lt;br/&gt;  &lt;span&gt;//标示Node对象，此对象的hash变量为-1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//在get或者put时若遇到此Node，则可以知道当前Node正在迁移&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//传入nextTab对象&lt;/span&gt;&lt;br/&gt;  ForwardingNode&amp;lt;K,V&amp;gt; fwd = &lt;span&gt;new&lt;/span&gt; ForwardingNode&amp;lt;K,V&amp;gt;(nextTab);&lt;br/&gt;  &lt;span&gt;boolean&lt;/span&gt; advance = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;boolean&lt;/span&gt; finishing = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;// to ensure sweep before committing nextTab&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, bound = &lt;span&gt;0&lt;/span&gt;;;) {&lt;br/&gt;    Node&amp;lt;K,V&amp;gt; f; &lt;span&gt;int&lt;/span&gt; fh;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (advance) {&lt;br/&gt;      &lt;span&gt;int&lt;/span&gt; nextIndex, nextBound;&lt;br/&gt;      &lt;span&gt;//i为当前正在处理的Node数组下标，每次处理一个Node节点就会自减1&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (--i &amp;gt;= bound || finishing)&lt;br/&gt;        advance = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;//假设nextIndex=16&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((nextIndex = transferIndex) &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        i = -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        advance = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;//由以上假设，nextBound就为0&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;//且将nextIndex设置为0&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapInt&lt;br/&gt;               (&lt;span&gt;this&lt;/span&gt;, TRANSFERINDEX, nextIndex,&lt;br/&gt;                nextBound = (nextIndex &amp;gt; stride ?&lt;br/&gt;                             nextIndex - stride : &lt;span&gt;0&lt;/span&gt;))) {&lt;br/&gt;        &lt;span&gt;//bound=0&lt;/span&gt;&lt;br/&gt;        bound = nextBound;&lt;br/&gt;        &lt;span&gt;//i=16-1=15&lt;/span&gt;&lt;br/&gt;        i = nextIndex - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        advance = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (i &amp;lt; &lt;span&gt;0&lt;/span&gt; || i &amp;gt;= n || i + n &amp;gt;= nextn) {&lt;br/&gt;      &lt;span&gt;int&lt;/span&gt; sc;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (finishing) {&lt;br/&gt;        nextTable = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        table = nextTab;&lt;br/&gt;        sizeCtl = (n &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;) - (n &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, SIZECTL, sc = sizeCtl, sc - &lt;span&gt;1&lt;/span&gt;)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((sc - &lt;span&gt;2&lt;/span&gt;) != resizeStamp(n) &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT)&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        finishing = advance = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        i = n; &lt;span&gt;// recheck before commit&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//此时i=15，取出Node数组下标为15的那个Node，若为空则不需要迁移&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//直接设置占位标示，代表此Node已处理完成&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((f = tabAt(tab, i)) == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;      advance = casTabAt(tab, i, &lt;span&gt;null&lt;/span&gt;, fwd);&lt;br/&gt;    &lt;span&gt;//检测此Node的hash是否为MOVED，MOVED是一个常量-1，也就是上面说的占位Node的hash&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//如果是占位Node，证明此节点已经处理过了，跳过i=15的处理，继续循环&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((fh = f.hash) == MOVED)&lt;br/&gt;      advance = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;// already processed&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;//锁住这个Node&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;synchronized&lt;/span&gt; (f) {&lt;br/&gt;        &lt;span&gt;//确认Node是原先的Node&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (tabAt(tab, i) == f) {&lt;br/&gt;          &lt;span&gt;//ln为lowNode，低位Node，hn为highNode，高位Node&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;//这两个概念下面以图来说明&lt;/span&gt;&lt;br/&gt;          Node&amp;lt;K,V&amp;gt; ln, hn;&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (fh &amp;gt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//此时fh与原来Node数组长度进行与运算&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//如果高X位为0，此时runBit=0&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//如果高X位为1，此时runBit=1&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; runBit = fh &amp;amp; n;&lt;br/&gt;            Node&amp;lt;K,V&amp;gt; lastRun = f;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt; p = f.next; p != &lt;span&gt;null&lt;/span&gt;; p = p.next) {&lt;br/&gt;              &lt;span&gt;//这里的Node，都是同一Node链表中的Node对象&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;int&lt;/span&gt; b = p.hash &amp;amp; n;&lt;br/&gt;              &lt;span&gt;if&lt;/span&gt; (b != runBit) {&lt;br/&gt;                runBit = b;&lt;br/&gt;                lastRun = p;&lt;br/&gt;              }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//正如上面所说，runBit=0，表示此Node为低位Node&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (runBit == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;              ln = lastRun;&lt;br/&gt;              hn = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;              &lt;span&gt;//Node为高位Node&lt;/span&gt;&lt;br/&gt;              hn = lastRun;&lt;br/&gt;              ln = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt; p = f; p != lastRun; p = p.next) {&lt;br/&gt;              &lt;span&gt;int&lt;/span&gt; ph = p.hash; K pk = p.key; V pv = p.val;&lt;br/&gt;              &lt;span&gt;//若hash和n与运算为0，证明为低位Node，原理同上&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;if&lt;/span&gt; ((ph &amp;amp; n) == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                ln = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;K,V&amp;gt;(ph, pk, pv, ln);&lt;br/&gt;              &lt;span&gt;//这里将高位Node与地位Node都各自组成了两个链表&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;                hn = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;K,V&amp;gt;(ph, pk, pv, hn);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//将低位Node设置到新Node数组中，下标为原来的位置&lt;/span&gt;&lt;br/&gt;            setTabAt(nextTab, i, ln);&lt;br/&gt;            &lt;span&gt;//将高位Node设置到新Node数组中，下标为原来的位置加上原Node数组长度&lt;/span&gt;&lt;br/&gt;            setTabAt(nextTab, i + n, hn);&lt;br/&gt;            &lt;span&gt;//将此Node设置为占位Node，代表处理完成&lt;/span&gt;&lt;br/&gt;            setTabAt(tab, i, fwd);&lt;br/&gt;            &lt;span&gt;//继续循环&lt;/span&gt;&lt;br/&gt;            advance = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;          }&lt;br/&gt;          ....&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里说一下迁移时为什么要分一个ln（低位Node）、hn（高位Node），首先说一个现象：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，在put值的时候，首先会计算hash值，再散列到指定的Node数组下标中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//根据key的hashCode再散列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; hash = spread(key.hashCode());&lt;br/&gt;&lt;span&gt;//使用(n - 1) &amp;amp; hash 运算，定位Node数组中下标值&lt;/span&gt;&lt;br/&gt;(f = tabAt(tab, i = (n - &lt;span&gt;1&lt;/span&gt;) &amp;amp; hash);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中n为Node数组长度，这里假设为16。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有一个key进来，它的散列之后的hash=9，那么它的下标值是多少呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;（16 - 1）和 9 进行与运算 -&amp;gt; 0000 1111 和 0000 1001 结果还是 0000 1001 = 9&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设Node数组需要扩容，我们知道，扩容是将数组长度增加两倍，也就是32，那么下标值会是多少呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;（32 - 1）和 9 进行与运算 -&amp;gt; 0001 1111 和 0000 1001 结果还是9&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，我们把散列之后的hash换成20，那么会有怎样的变化呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;（16 - 1）和 20 进行与运算 -&amp;gt; 0000 1111 和 0001 0100 结果是 0000 0100 = 4&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（32 - 1）和 20 进行与运算 -&amp;gt; 0001 1111 和 0001 0100 结果是 0001 0100 = 20&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时细心的读者应该可以发现，如果hash在高X位为1，（X为数组长度的二进制-1的最高位），则扩容时是需要变换在Node数组中的索引值的，不然就hash不到，丢失数据，所以这里在迁移的时候将高X位为1的Node分类为hn，将高X位为0的Node分类为ln。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到代码中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt; p = f; p != lastRun; p = p.next) {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; ph = p.hash; &lt;br/&gt;  K pk = p.key; &lt;br/&gt;  V pv = p.val;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ((ph &amp;amp; n) == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    ln = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;K,V&amp;gt;(ph, pk, pv, ln);&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    hn = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;K,V&amp;gt;(ph, pk, pv, hn);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个操作将高低位组成了两条链表结构，由下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7515151515151515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbue50Evic8ia9ibIeD4eBicfrLnbA2Sbcbecicic3GobF1o7AYwk4E1q2BKiaiaBZzTDvXMhgeHDAZSoo5l06Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1650&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后将其CAS操作放入新的Node数组中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;setTabAt(nextTab, i, ln);&lt;br/&gt;setTabAt(nextTab, i + n, hn);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，低位链表放入原下标处，而高位链表则需要加上原Node数组长度，其中为什么不多赘述，上面已经举例说明了，这样就可以保证高位Node在迁移到新Node数组中依然可以使用hash算法散列到对应下标的数组中去了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后将原Node数组中对应下标Node对象设置为fwd标记Node，表示该节点迁移完成，到这里，一个节点的迁移就完成了，将进行下一个节点的迁移，也就是i-1=14下标的Node节点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;扩容时的get操作：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设Node下标为16的Node节点正在迁移，突然有一个线程进来调用get方法，正好key又散列到下标为16的节点，此时怎么办？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; V &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(Object key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; e, p; &lt;span&gt;int&lt;/span&gt; n, eh; K ek;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; h = spread(key.hashCode());&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ((tab = table) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.length) &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;      (e = tabAt(tab, (n - &lt;span&gt;1&lt;/span&gt;) &amp;amp; h)) != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((eh = e.hash) == h) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; ((ek = e.key) == key || (ek != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.equals(ek)))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; e.val;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//假如Node节点的hash值小于0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//则有可能是fwd节点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (eh &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;//调用节点对象的find方法查找值&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; (p = e.find(h, key)) != &lt;span&gt;null&lt;/span&gt; ? p.val : &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; ((e = e.next) != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (e.hash == h &amp;amp;&amp;amp;&lt;br/&gt;          ((ek = e.key) == key || (ek != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.equals(ek))))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; e.val;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点看有注释的那两行，在get操作的源码中，会判断Node中的hash是否小于0，是否还记得我们的占位Node，其hash为MOVED，为常量值-1，所以此时判断线程正在迁移，委托给fwd占位Node去查找值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//内部类 ForwardingNode中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Node&amp;lt;K,V&amp;gt; &lt;span&gt;find&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; h, Object k)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// loop to avoid arbitrarily deep recursion on forwarding nodes&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 这里的查找，是去新Node数组中查找的&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 下面的查找过程与HashMap查找无异，不多赘述&lt;/span&gt;&lt;br/&gt;  outer: &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt;[] tab = nextTable;;) {&lt;br/&gt;    Node&amp;lt;K,V&amp;gt; e; &lt;span&gt;int&lt;/span&gt; n;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt; || tab == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == &lt;span&gt;0&lt;/span&gt; ||&lt;br/&gt;        (e = tabAt(tab, (n - &lt;span&gt;1&lt;/span&gt;) &amp;amp; h)) == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;      &lt;span&gt;int&lt;/span&gt; eh; K ek;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; ((eh = e.hash) == h &amp;amp;&amp;amp;&lt;br/&gt;          ((ek = e.key) == k || (ek != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; k.equals(ek))))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; e;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (eh &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; ForwardingNode) {&lt;br/&gt;          tab = ((ForwardingNode&amp;lt;K,V&amp;gt;)e).nextTable;&lt;br/&gt;          &lt;span&gt;continue&lt;/span&gt; outer;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; e.find(h, k);&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; ((e = e.next) == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里应该可以恍然大悟了，之所以占位Node需要保存新Node数组的引用也是因为这个，它可以支持在迁移的过程中照样不阻塞地查找值，可谓是精妙绝伦的设计。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;多线程协助扩容&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在put操作时，假设正在迁移，正好有一个线程进来，想要put值到迁移的Node上，怎么办？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; V &lt;span&gt;putVal&lt;/span&gt;&lt;span&gt;(K key, V value, &lt;span&gt;boolean&lt;/span&gt; onlyIfAbsent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt; || value == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException();&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; hash = spread(key.hashCode());&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; binCount = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt;[] tab = table;;) {&lt;br/&gt;    Node&amp;lt;K,V&amp;gt; f; &lt;span&gt;int&lt;/span&gt; n, i, fh;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (tab == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;      tab = initTable();&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((f = tabAt(tab, i = (n - &lt;span&gt;1&lt;/span&gt;) &amp;amp; hash)) == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (casTabAt(tab, i, &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;                   &lt;span&gt;new&lt;/span&gt; Node&amp;lt;K,V&amp;gt;(hash, key, value, &lt;span&gt;null&lt;/span&gt;)))&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;                   &lt;span&gt;// no lock when adding to empty bin&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//若此时发现了占位Node，证明此时HashMap正在迁移&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((fh = f.hash) == MOVED)&lt;br/&gt;      &lt;span&gt;//进行协助迁移&lt;/span&gt;&lt;br/&gt;      tab = helpTransfer(tab, f);&lt;br/&gt;     ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] helpTransfer(Node&amp;lt;K,V&amp;gt;[] tab, Node&amp;lt;K,V&amp;gt; f) {&lt;br/&gt;  Node&amp;lt;K,V&amp;gt;[] nextTab; &lt;span&gt;int&lt;/span&gt; sc;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (tab != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (f &lt;span&gt;instanceof&lt;/span&gt; ForwardingNode) &amp;amp;&amp;amp;&lt;br/&gt;      (nextTab = ((ForwardingNode&amp;lt;K,V&amp;gt;)f).nextTable) != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; rs = resizeStamp(tab.length);&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (nextTab == nextTable &amp;amp;&amp;amp; table == tab &amp;amp;&amp;amp;&lt;br/&gt;           (sc = sizeCtl) &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; ((sc &amp;gt;&amp;gt;&amp;gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + &lt;span&gt;1&lt;/span&gt; ||&lt;br/&gt;          sc == rs + MAX_RESIZERS || transferIndex &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;//sizeCtl加一，标示多一个线程进来协助扩容&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, SIZECTL, sc, sc + &lt;span&gt;1&lt;/span&gt;)) {&lt;br/&gt;        &lt;span&gt;//扩容&lt;/span&gt;&lt;br/&gt;        transfer(tab, nextTab);&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; nextTab;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; table;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此方法涉及大量复杂的位运算，这里不多赘述，只是简单的说几句，此时sizeCtl变量用来标示HashMap正在扩容，当其准备扩容时，会将sizeCtl设置为一个负数，（例如数组长度为16时）其二进制表示为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;1000&lt;/span&gt; &lt;span&gt;0000&lt;/span&gt; &lt;span&gt;0001&lt;/span&gt; &lt;span&gt;1011&lt;/span&gt; &lt;span&gt;0000&lt;/span&gt; &lt;span&gt;0000&lt;/span&gt; &lt;span&gt;0000&lt;/span&gt; &lt;span&gt;0010&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无符号位为1，表示负数。其中高16位代表数组长度的一个位算法标示（有点像epoch的作用，表示当前迁移朝代为数组长度X），低16位表示有几个线程正在做迁移，刚开始为2，接下来自增1，线程迁移完会进行减1操作，也就是如果低十六位为2，代表有一个线程正在迁移，如果为3，代表2个线程正在迁移以此类推…&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要数组长度足够长，就可以同时容纳足够多的线程来一起扩容，最大化并行任务，提高性能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;在什么情况下会进行扩容操作？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在put值时，发现Node为占位Node（fwd）时，会协助扩容。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在新增节点后，检测到链表长度大于8时。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; V &lt;span&gt;putVal&lt;/span&gt;&lt;span&gt;(K key, V value, &lt;span&gt;boolean&lt;/span&gt; onlyIfAbsent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (binCount != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;//TREEIFY_THRESHOLD=8，当链表长度大于8时&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD)&lt;br/&gt;      &lt;span&gt;//调用treeifyBin方法&lt;/span&gt;&lt;br/&gt;     treeifyBin(tab, i);&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (oldVal != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; oldVal;&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;treeifyBin方法会将链表转换为红黑树，增加查找效率，但在这之前，会检查数组长度，若小于64，则会优先做扩容操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;treeifyBin&lt;/span&gt;&lt;span&gt;(Node&amp;lt;K,V&amp;gt;[] tab, &lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Node&amp;lt;K,V&amp;gt; b; &lt;span&gt;int&lt;/span&gt; n, sc;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (tab != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;//MIN_TREEIFY_CAPACITY=64&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//若数组长度小于64，则先扩容&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((n = tab.length) &amp;lt; MIN_TREEIFY_CAPACITY)&lt;br/&gt;      &lt;span&gt;//扩容&lt;/span&gt;&lt;br/&gt;      tryPresize(n &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((b = tabAt(tab, index)) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; b.hash &amp;gt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;synchronized&lt;/span&gt; (b) {&lt;br/&gt;        &lt;span&gt;//...转换为红黑树的操作&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在每次新增节点之后，都会调用addCount方法，检测Node数组大小是否达到阈值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; V &lt;span&gt;putVal&lt;/span&gt;&lt;span&gt;(K key, V value, &lt;span&gt;boolean&lt;/span&gt; onlyIfAbsent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;    &lt;span&gt;//在下面一节会讲到，此方法统计容器元素数量&lt;/span&gt;&lt;br/&gt;    addCount(&lt;span&gt;1L&lt;/span&gt;, binCount);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addCount&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; check)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  CounterCell[] as; &lt;span&gt;long&lt;/span&gt; b, s;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ((as = counterCells) != &lt;span&gt;null&lt;/span&gt; ||&lt;br/&gt;      !U.compareAndSwapLong(&lt;span&gt;this&lt;/span&gt;, BASECOUNT, b = baseCount, s = b + x)) {&lt;br/&gt;    &lt;span&gt;//统计元素个数的操作...&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (check &amp;gt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    Node&amp;lt;K,V&amp;gt;[] tab, nt; &lt;span&gt;int&lt;/span&gt; n, sc;&lt;br/&gt;    &lt;span&gt;//元素个数达到阈值，进行扩容&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (s &amp;gt;= (&lt;span&gt;long&lt;/span&gt;)(sc = sizeCtl) &amp;amp;&amp;amp; (tab = table) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;           (n = tab.length) &amp;lt; MAXIMUM_CAPACITY) {&lt;br/&gt;      &lt;span&gt;int&lt;/span&gt; rs = resizeStamp(n);&lt;br/&gt;      &lt;span&gt;//发现sizeCtl为负数，证明有线程正在迁移&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (sc &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((sc &amp;gt;&amp;gt;&amp;gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + &lt;span&gt;1&lt;/span&gt; ||&lt;br/&gt;            sc == rs + MAX_RESIZERS || (nt = nextTable) == &lt;span&gt;null&lt;/span&gt; ||&lt;br/&gt;            transferIndex &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;          &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, SIZECTL, sc, sc + &lt;span&gt;1&lt;/span&gt;))&lt;br/&gt;          transfer(tab, nt);&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;//不为负数，则为第一个迁移的线程&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, SIZECTL, sc,&lt;br/&gt;                                   (rs &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT) + &lt;span&gt;2&lt;/span&gt;))&lt;br/&gt;        transfer(tab, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;      s = sumCount();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Concu&lt;span&gt;rrentHashMap运用各类CAS操作，将扩容操作的并发性能实现最大化，在扩容过程中，就算有线程调用get查询方法，也可以安全的查询数据，若有线程进行put操作，还会协助扩容，利用sizeCtl标记位和各种volatile变量进行CAS操作达到多线程之间的通信、协助，在迁移过程中只锁一个Node节点，即保证了线程安全，又提高了并发性能。&lt;/span&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;| 统计容器大小的线程安全&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConcurrentHashMap在每次put操作之后都会调用addCount方法，此方法用于统计容器大小且检测容器大小是否达到阈值，若达到阈值需要进行扩容操作，这在上面也是有提到的。这一节重点讨论容器大小的统计是如何做到线程安全且并发性能不低的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分的单机数据查询优化方案都会降低并发性能，就像缓存的存储，在多线程环境下将有并发问题，所以会产生并行或者一系列并发冲突锁竞争的问题，降低了并发性能。类似的，热点数据也有这样的问题，在多线程并发的过程中，热点数据（频繁被访问的变量）是在每一个线程中几乎或多或少都会访问到的数据，这将增加程序中的串行部分，回忆一下开头所描述的，程序中的串行部分将影响并发的可伸缩性，使并发性能下降，这通常会成为并发程序性能的瓶颈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在ConcurrentHashMap中，如何快速的统计容器大小更是一个很重要的议题，因为容器内部需要依靠容器大小来考虑是否需要扩容，而在客户端而言需要调用此方法来知道容器有多少个元素，如果处理不好这种热点数据，并发性能将因为这个短板整体性能下降。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;试想一下，如果是你，你会如何设计这种热点数据？是加锁，还是进行CAS操作？进入ConcurrentHashMap中，看看大师是如何巧妙的运用了并发技巧，提高热点数据的并发性能。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先用图的方式来看看大致的实现思路：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47896039603960394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbue50Evic8ia9ibIeD4eBicfrLnbDAs9JMMs4muhvxSVuxvVG7VJib9xHjUqHCPvnPrSKqV25QQCald0cYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1616&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@sun&lt;/span&gt;.misc.Contended &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CounterCell&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; value;&lt;br/&gt;  CounterCell(&lt;span&gt;long&lt;/span&gt; x) { value = x; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个粗略的实现，在设计中，使用了分而治之的思想，将每一个计数都分散到各个countCell对象里面（下面称之为桶），使竞争最小化，又使用了CAS操作，就算有竞争，也可以对失败了的线程进行其他的处理。乐观锁的实现方式与悲观锁不同之处就在于乐观锁可以对竞争失败了的线程进行其他策略的处理，而悲观锁只能等待锁释放，所以这里使用CAS操作对竞争失败的线程做了其他处理，很巧妙的运用了CAS乐观锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看看具体的代码实现吧：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//计数，并检查长度是否达到阈值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addCount&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; check)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//计数桶&lt;/span&gt;&lt;br/&gt;  CounterCell[] as; &lt;span&gt;long&lt;/span&gt; b, s;&lt;br/&gt;  &lt;span&gt;//如果counterCells不为null，则代表已经初始化了，直接进入if语句块&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//若竞争不严重，counterCells有可能还未初始化，为null，先尝试CAS操作递增baseCount值&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ((as = counterCells) != &lt;span&gt;null&lt;/span&gt; ||&lt;br/&gt;      !U.compareAndSwapLong(&lt;span&gt;this&lt;/span&gt;, BASECOUNT, b = baseCount, s = b + x)) {&lt;br/&gt;    &lt;span&gt;//进入此语句块有两种可能&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//1.counterCells被初始化完成了，不为null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//2.CAS操作递增baseCount值失败了，说明有竞争&lt;/span&gt;&lt;br/&gt;    CounterCell a; &lt;span&gt;long&lt;/span&gt; v; &lt;span&gt;int&lt;/span&gt; m;&lt;br/&gt;    &lt;span&gt;//标志是否存在竞争&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; uncontended = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//1.先判断计数桶是否还没初始化，则as=null，进入语句块&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//2.判断计数桶长度是否为空或，若是进入语句块&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//3.这里做了一个线程变量随机数，与上桶大小-1，若桶的这个位置为空，进入语句块&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//4.到这里说明桶已经初始化了，且随机的这个位置不为空，尝试CAS操作使桶加1，失败进入语句块&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (as == &lt;span&gt;null&lt;/span&gt; || (m = as.length - &lt;span&gt;1&lt;/span&gt;) &amp;lt; &lt;span&gt;0&lt;/span&gt; ||&lt;br/&gt;        (a = as[ThreadLocalRandom.getProbe() &amp;amp; m]) == &lt;span&gt;null&lt;/span&gt; ||&lt;br/&gt;        !(uncontended =&lt;br/&gt;          U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {&lt;br/&gt;      fullAddCount(x, uncontended);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (check &amp;lt;= &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//统计容器大小&lt;/span&gt;&lt;br/&gt;    s = sumCount();&lt;br/&gt;  }&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;假设当前线程为第一个put的线程&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;先假&lt;span&gt;设当&lt;/span&gt;&lt;span&gt;前Map还未被put数据，则addCount一定没有被调用过，当前线程第一个调用addCount方法，则此时countCell一定没有被初始化，为null，则进行如下判断：&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; ((as = counterCells) != &lt;span&gt;null&lt;/span&gt; ||&lt;br/&gt;      !U.compareAndSwapLong(&lt;span&gt;this&lt;/span&gt;, BASECOUNT, b = baseCount, s = b + x)) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的if判断一定会走第二个判断，先CAS增加变量baseCount的值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; baseCount;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个值有什么用呢？我们看看统计容器大小的方法sumCount：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;sumCount&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//获取计数桶&lt;/span&gt;&lt;br/&gt;  CounterCell[] as = counterCells; CounterCell a;&lt;br/&gt;  &lt;span&gt;//获取baseCount，赋值给sum总数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;long&lt;/span&gt; sum = baseCount;&lt;br/&gt;  &lt;span&gt;//若计数桶不为空，统计计数桶内的值&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (as != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; as.length; ++i) {&lt;br/&gt;      &lt;span&gt;//遍历计数桶，将value值相加&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; ((a = as[i]) != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        sum += a.value;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; sum;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法的大体思路与我们开头那张图差不多，容器的大小其实是分为两部分，开头只说了计数桶的那部分，其实还有一个baseCount，在线程没有竞争的情况下的统计值，换句话说，在增加容量的时候其实是先去做CAS递增baseCount的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，统计容器大小其实是用了两种思路：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CAS方式直接递增：在线程竞争不大的时候，直接使用CAS操作递增baseCount值即可，这里说的竞争不大指的是CAS操作不会失败的情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分而治之桶计数：若出现了CAS操作失败的情况，则证明此时有线程竞争了，计数方式从CAS方式转变为分而治之的桶计数方式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;出现了线程竞争导致CAS失败&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;此时出现了&lt;span&gt;竞争，则不会再用CAS方式来计数了，直接使用桶方式，从上面的addCount方法可以看出来，此时的countCell是为空的，最终一定会进入fullAddCount方法来进行初始化桶：&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fullAddCount&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; x, &lt;span&gt;boolean&lt;/span&gt; wasUncontended)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; h;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((h = ThreadLocalRandom.getProbe()) == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            ThreadLocalRandom.localInit();      &lt;span&gt;// force initialization&lt;/span&gt;&lt;br/&gt;            h = ThreadLocalRandom.getProbe();&lt;br/&gt;            wasUncontended = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; collide = &lt;span&gt;false&lt;/span&gt;;                &lt;span&gt;// True if last slot nonempty&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            CounterCell[] as; CounterCell a; &lt;span&gt;int&lt;/span&gt; n; &lt;span&gt;long&lt;/span&gt; v;&lt;br/&gt;            ...&lt;br/&gt;            &lt;span&gt;//如果计数桶!=null，证明已经初始化，此时不走此语句块&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((as = counterCells) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = as.length) &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;              ...&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//进入此语句块进行计数桶的初始化&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//CAS设置cellsBusy=1，表示现在计数桶Busy中...&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cellsBusy == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; counterCells == as &amp;amp;&amp;amp;&lt;br/&gt;                     U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, CELLSBUSY, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;)) {&lt;br/&gt;                &lt;span&gt;//若有线程同时初始化计数桶，由于CAS操作只有一个线程进入这里&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;boolean&lt;/span&gt; init = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {                           &lt;span&gt;// Initialize table&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//再次确认计数桶为空&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (counterCells == as) {&lt;br/&gt;                        &lt;span&gt;//初始化一个长度为2的计数桶&lt;/span&gt;&lt;br/&gt;                        CounterCell[] rs = &lt;span&gt;new&lt;/span&gt; CounterCell[&lt;span&gt;2&lt;/span&gt;];&lt;br/&gt;                        &lt;span&gt;//h为一个随机数，与上1则代表结果为0、1中随机的一个&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;//也就是在0、1下标中随便选一个计数桶，x=1，放入1的值代表增加1个容量&lt;/span&gt;&lt;br/&gt;                        rs[h &amp;amp; &lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt; CounterCell(x);&lt;br/&gt;                        &lt;span&gt;//将初始化好的计数桶赋值给ConcurrentHashMap&lt;/span&gt;&lt;br/&gt;                        counterCells = rs;&lt;br/&gt;                        init = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;//最后将busy标识设置为0，表示不busy了&lt;/span&gt;&lt;br/&gt;                    cellsBusy = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (init)&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//若有线程同时来初始化计数桶，则没有抢到busy资格的线程就先来CAS递增baseCount&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapLong(&lt;span&gt;this&lt;/span&gt;, BASECOUNT, v = baseCount, v + x))&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;                          &lt;span&gt;// Fall back on using base&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里就完成了计数桶的初始化工作，在之后的计数都将会使用计数桶方式来统计总数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;计数桶扩容&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;从上面的分析中我们知道，计数桶初始化之后长度为2，在竞争大的时候肯定是不够用的，所以一定有计数桶的扩容操作，所以现在就有两个问题了：&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;什么条件下会进行计数桶的扩容？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩容操作是怎么样的？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设此时是用计数桶方式进行计数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addCount&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; check)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  CounterCell[] as; &lt;span&gt;long&lt;/span&gt; b, s;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ((as = counterCells) != &lt;span&gt;null&lt;/span&gt; ||&lt;br/&gt;      !U.compareAndSwapLong(&lt;span&gt;this&lt;/span&gt;, BASECOUNT, b = baseCount, s = b + x)) {&lt;br/&gt;    CounterCell a; &lt;span&gt;long&lt;/span&gt; v; &lt;span&gt;int&lt;/span&gt; m;&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; uncontended = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//此时显然会在计数桶数组中随机选一个计数桶&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//然后使用CAS操作将此计数桶中的value+1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (as == &lt;span&gt;null&lt;/span&gt; || (m = as.length - &lt;span&gt;1&lt;/span&gt;) &amp;lt; &lt;span&gt;0&lt;/span&gt; ||&lt;br/&gt;        (a = as[ThreadLocalRandom.getProbe() &amp;amp; m]) == &lt;span&gt;null&lt;/span&gt; ||&lt;br/&gt;        !(uncontended =&lt;br/&gt;          U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {&lt;br/&gt;      &lt;span&gt;//若CAS操作失败，证明有竞争，进入fullAddCount方法&lt;/span&gt;&lt;br/&gt;      fullAddCount(x, uncontended);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (check &amp;lt;= &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    s = sumCount();&lt;br/&gt;  }&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入fullAddCount方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fullAddCount&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; x, &lt;span&gt;boolean&lt;/span&gt; wasUncontended)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; h;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ((h = ThreadLocalRandom.getProbe()) == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    ThreadLocalRandom.localInit();      &lt;span&gt;// force initialization&lt;/span&gt;&lt;br/&gt;    h = ThreadLocalRandom.getProbe();&lt;br/&gt;    wasUncontended = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;boolean&lt;/span&gt; collide = &lt;span&gt;false&lt;/span&gt;;                &lt;span&gt;// True if last slot nonempty&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;    CounterCell[] as; CounterCell a; &lt;span&gt;int&lt;/span&gt; n; &lt;span&gt;long&lt;/span&gt; v;&lt;br/&gt;    &lt;span&gt;//计数桶初始化好了，一定是走这个if语句块&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((as = counterCells) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = as.length) &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;//从计数桶数组随机选一个计数桶，若为null表示该桶位还没线程递增过&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; ((a = as[(n - &lt;span&gt;1&lt;/span&gt;) &amp;amp; h]) == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;//查看计数桶busy状态是否被标识&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (cellsBusy == &lt;span&gt;0&lt;/span&gt;) {            &lt;span&gt;// Try to attach new Cell&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;//若不busy，直接new一个计数桶&lt;/span&gt;&lt;br/&gt;          CounterCell r = &lt;span&gt;new&lt;/span&gt; CounterCell(x); &lt;span&gt;// Optimistic create&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;//CAS操作，标示计数桶busy中&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (cellsBusy == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;              U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, CELLSBUSY, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;)) {&lt;br/&gt;            &lt;span&gt;boolean&lt;/span&gt; created = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {               &lt;span&gt;// Recheck under lock&lt;/span&gt;&lt;br/&gt;              CounterCell[] rs; &lt;span&gt;int&lt;/span&gt; m, j;&lt;br/&gt;              &lt;span&gt;//在锁下再检查一次计数桶为null&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;if&lt;/span&gt; ((rs = counterCells) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;                  (m = rs.length) &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;                  rs[j = (m - &lt;span&gt;1&lt;/span&gt;) &amp;amp; h] == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;//将刚刚创建的计数桶赋值给对应位置&lt;/span&gt;&lt;br/&gt;                rs[j] = r;&lt;br/&gt;                created = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;              }&lt;br/&gt;            } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;              &lt;span&gt;//标示不busy了&lt;/span&gt;&lt;br/&gt;              cellsBusy = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (created)&lt;br/&gt;              &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;;           &lt;span&gt;// Slot is now non-empty&lt;/span&gt;&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;        collide = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!wasUncontended)       &lt;span&gt;// CAS already known to fail&lt;/span&gt;&lt;br/&gt;        wasUncontended = &lt;span&gt;true&lt;/span&gt;;      &lt;span&gt;// Continue after rehash&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;//走到这里代表计数桶不为null，尝试递增计数桶&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (counterCells != as || n &amp;gt;= NCPU)&lt;br/&gt;        collide = &lt;span&gt;false&lt;/span&gt;;            &lt;span&gt;// At max size or stale&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;//若CAS操作失败了，到了这里，会先进入一次，然后再走一次刚刚的for循环&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;//若是第二次for循环，collide=true，则不会走进去&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!collide)&lt;br/&gt;        collide = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;//计数桶扩容，一个线程若走了两次for循环，也就是进行了多次CAS操作递增计数桶失败了&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;//则进行计数桶扩容，CAS标示计数桶busy中&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cellsBusy == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;               U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, CELLSBUSY, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;)) {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;//确认计数桶还是同一个&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (counterCells == as) {&lt;span&gt;// Expand table unless stale&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//将长度扩大到2倍&lt;/span&gt;&lt;br/&gt;            CounterCell[] rs = &lt;span&gt;new&lt;/span&gt; CounterCell[n &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;            &lt;span&gt;//遍历旧计数桶，将引用直接搬过来&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; ++i)&lt;br/&gt;              rs[i] = as[i];&lt;br/&gt;            &lt;span&gt;//赋值&lt;/span&gt;&lt;br/&gt;            counterCells = rs;&lt;br/&gt;          }&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;//取消busy状态&lt;/span&gt;&lt;br/&gt;          cellsBusy = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        collide = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;continue&lt;/span&gt;;                   &lt;span&gt;// Retry with expanded table&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;      h = ThreadLocalRandom.advanceProbe(h);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cellsBusy == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; counterCells == as &amp;amp;&amp;amp;&lt;br/&gt;             U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, CELLSBUSY, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;)) {&lt;br/&gt;      &lt;span&gt;//初始化计数桶...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapLong(&lt;span&gt;this&lt;/span&gt;, BASECOUNT, v = baseCount, v + x))&lt;br/&gt;      &lt;span&gt;break&lt;/span&gt;;                          &lt;span&gt;// Fall back on using base&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，想必已经可以解决上面两个问题了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么条件下会进行计数桶的扩容？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：在CAS操作递增计数桶失败了3次之后，会进行扩容计数桶操作，注意此时同时进行了两次随机定位计数桶来进行CAS递增的，所以此时可以保证大概率是因为计数桶不够用了，才会进行计数桶扩容&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;扩容操作是怎么样的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：计数桶长度增加到两倍长度，数据直接遍历迁移过来，由于计数桶不像HashMap数据结构那么复杂，有hash算法的影响，加上计数桶只是存放一个long类型的计数值而已，所以直接赋值引用即可。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;个人感觉，统计容器大小的线程安全与扩容ConcurrentHashMap这两个算得上ConcurrentHashMap中最聪明的两个并发设计了，阅读此源码的我看到这两个操作的设计，都忍不住拍手叫绝，我想，这或许也是一个看源码的乐趣吧，站在巨人的肩膀看巨人的思想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总结一下计数中用到的并发技巧：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;利用CAS递增baseCount值来感知是否存在线程竞争，若竞争不大直接CAS递增baseCount值即可，性能与直接baseCount++差别不大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若存在线程竞争，则初始化计数桶，若此时初始化计数桶的过程中也存在竞争，多个线程同时初始化计数桶，则没有抢到初始化资格的线程直接尝试CAS递增baseCount值的方式完成计数，最大化利用了线程的并行。此时使用计数桶计数，分而治之的方式来计数，此时两个计数桶最大可提供两个线程同时计数，同时使用CAS操作来感知线程竞争，若两个桶情况下CAS操作还是频繁失败（失败3次），则直接扩容计数桶，变为4个计数桶，支持最大同时4个线程并发计数，以此类推…同时使用位运算和随机数的方式&quot;负载均衡&quot;一样的将线程计数请求接近均匀的落在各个计数桶中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;| get操作的线程安全&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于get操作，其实没有线程安全的问题，只有可见性的问题，只需要确保get的数据是线程之间可见的即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; V &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(Object key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; e, p; &lt;span&gt;int&lt;/span&gt; n, eh; K ek;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; h = spread(key.hashCode());&lt;br/&gt;  &lt;span&gt;//此过程与HashMap的get操作无异，不多赘述&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ((tab = table) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.length) &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;      (e = tabAt(tab, (n - &lt;span&gt;1&lt;/span&gt;) &amp;amp; h)) != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((eh = e.hash) == h) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; ((ek = e.key) == key || (ek != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.equals(ek)))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; e.val;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//当hash&amp;lt;0,有可能是在迁移,使用fwd占位Node去查找新table中的数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (eh &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; (p = e.find(h, key)) != &lt;span&gt;null&lt;/span&gt; ? p.val : &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; ((e = e.next) != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (e.hash == h &amp;amp;&amp;amp;&lt;br/&gt;          ((ek = e.key) == key || (ek != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.equals(ek))))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; e.val;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在get操作中除了增加了迁移的判断以外，基本与HashMap的get操作无异，这里不多赘述，值得一提的是这里使用了tabAt方法Unsafe类volatile的方式去获取Node数组中的Node，保证获得到的Node是最新的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &amp;lt;K,V&amp;gt; &lt;span&gt;Node&amp;lt;K,V&amp;gt; &lt;span&gt;tabAt&lt;/span&gt;&lt;span&gt;(Node&amp;lt;K,V&amp;gt;[] tab, &lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (Node&amp;lt;K,V&amp;gt;)U.getObjectVolatile(tab, ((&lt;span&gt;long&lt;/span&gt;)i &amp;lt;&amp;lt; ASHIFT) + ABASE);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;| JDK1.7与1.8的不同实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK1.7的ConcurrentHashMap底层数据结构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4710017574692443&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbue50Evic8ia9ibIeD4eBicfrLnbZAKzgy0lNib5APggvBg0DmFBFBKic1839nWUAo8Peib2mByDoFENyry6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2276&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中1.7的实现也同样采用了分段锁的技术，只不过多个一个segment，一个segment里对应一个小HashMap，其中segment继承了ReentrantLock，充当了锁的角色，一把锁锁一个小HashMap（相当于多个Node），从1.8的实现来看， 锁的粒度从多个Node级别又减小到一个Node级别，再度减小锁竞争，减小程序同步的部分。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;| 总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;不得不说，大师将CAS操作运用的淋漓尽致，相信理解了以上源码的读者也可以学习到大师所运用的并发技巧，不仅仅是在ConcurrentHashMap中，其实在大部分JUC的源码中很多并发思想很值得我们去阅读、学习。&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;68&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;转自：Static_lin&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：&lt;/span&gt;&lt;span&gt;blog.csdn.net/qq_41737716/article/details/90549847&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651503297&amp;amp;idx=2&amp;amp;sn=5f19e03d6b86789b3b28af5cee97d1e9&amp;amp;chksm=bd25d6be8a525fa8b8d16745d3454ddc4aa562571964d88eb9fd4e2cb274f8a9ae806bf0b3d5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一个 HashMap 跟面试官扯了半个小时&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;一个 HashMap 跟面试官扯了半个小时&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651499697&amp;amp;idx=1&amp;amp;sn=d8f1e641d62e87009cfe0dfd88d45a6b&amp;amp;chksm=bd25c0ce8a5249d89dd61078d67722178c3ddc16c6bb531040ca5f5108ffb344d1067db39804&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;多线程环境下，HashMap为什么会出现死循环？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;多线程环境下，HashMap为什么会出现死循环？&lt;/a&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0dc3ebf38ba4e8326ebb9df6a7a9af5d</guid>
<title>一篇文章梳理清楚 Python 多线程与多进程</title>
<link>https://toutiao.io/k/w99c5yy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在学习Python的过程中，有接触到多线程编程相关的知识点，先前一直都没有彻底的搞明白。今天准备花一些时间，把里面的细节尽可能的梳理清楚。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;线程与进程的区别&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。关于多进程和多线程，教科书上最经典的一句话是“&lt;strong&gt;进程是资源分配的最小单位，线程是CPU调度的最小单位&lt;/strong&gt;”。线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;505096844&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TrMS1mPJIK4ia993XvTmTMY9XtH72pDgVAUeHBencejF7t9hRCXfbZGSBEljszuZVb3vs5mezEYUgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;进程和线程区别&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中。以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。寄存器可被用来存储线程内的局部变量，但不能存储其他线程的相关变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度，从而显著提高系统资源的利用率和吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因而近年来推出的通用操作系统都引入了线程，以便进一步提高系统的并发性，并把它视为现代操作系统的一个重要指标。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;505096841&quot; data-ratio=&quot;0.5491573033707865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TrMS1mPJIK4ia993XvTmTMY97Fguv1J3EVOhfVe6g93kkaOFMG8gFBSTtESBRKJnrJTnLEibMvvS9BA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程与进程的区别可以归纳为以下4点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;调度和切换：线程上下文切换比进程上下文切换要快得多。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在多线程OS中，进程不是一个可执行的实体。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;多进程和多线程的比较&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;对比维度&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;多进程&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;多线程&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;数据共享、同步&lt;/td&gt;&lt;td&gt;数据共享复杂，同步简单&lt;/td&gt;&lt;td&gt;数据共享简单，同步复杂&lt;/td&gt;&lt;td&gt;各有优劣&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;内存、CPU&lt;/td&gt;&lt;td&gt;占用内存多，切换复杂，CPU利用率低&lt;/td&gt;&lt;td&gt;占用内存少，切换简单，CPU利用率高&lt;/td&gt;&lt;td&gt;线程占优&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;创建、销毁、切换&lt;/td&gt;&lt;td&gt;复杂，速度慢&lt;/td&gt;&lt;td&gt;简单，速度快&lt;/td&gt;&lt;td&gt;线程占优&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;编程、调试&lt;/td&gt;&lt;td&gt;编程简单，调试简单&lt;/td&gt;&lt;td&gt;编程复杂，调试复杂&lt;/td&gt;&lt;td&gt;进程占优&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;可靠性&lt;/td&gt;&lt;td&gt;进程间不会互相影响&lt;/td&gt;&lt;td&gt;一个线程挂掉将导致整个进程挂掉&lt;/td&gt;&lt;td&gt;进程占优&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;分布式&lt;/td&gt;&lt;td&gt;适用于多核、多机，扩展到多台机器简单&lt;/td&gt;&lt;td&gt;适合于多核&lt;/td&gt;&lt;td&gt;进程占优&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结，进程和线程还可以类比为火车和车厢：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程在进程下行进（单纯的车厢无法运行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个进程可以包含多个线程（一辆火车可以有多个车厢）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到该趟火车的所有车厢）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁（mutex）”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量（semaphore）”&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Python全局解释器锁GIL&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全局解释器锁（英语：Global Interpreter Lock，缩写GIL），并不是Python的特性，它是在实现Python解析器（CPython）时所引入的一个概念。由于CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把GIL归结为Python语言的缺陷。那么CPython实现中的GIL又是什么呢？来看看官方的解释：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;The mechanism used by the CPython interpreter to assure that only one thread executes Python bytecode at a time. This simplifies the CPython implementation by making the object model (including critical built-in types such as dict) implicitly safe against concurrent access. Locking the entire interpreter makes it easier for the interpreter to be multi-threaded, at the expense of much of the parallelism afforded by multi-processor machines.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。对Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;505096845&quot; data-ratio=&quot;0.7057142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TrMS1mPJIK4ia993XvTmTMY9QfiaKYiasPzLWmOW61lDjzQia1SQibY9ZPhtucdmCwGaWCdovpkou0MuMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GIL 有什么好处？简单来说，它在单线程的情况更快，并且在和 C 库结合时更方便，而且不用考虑线程安全问题，这也是早期 Python 最常见的应用场景和优势。另外，GIL的设计简化了CPython的实现，使得对象模型，包括关键的内建类型如字典，都是隐含可以并发访问的。锁住全局解释器使得比较容易的实现对多线程的支持，但也损失了多处理器主机的并行计算能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在多线程环境中，Python 虚拟机按以下方式执行：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;设置GIL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;切换到一个线程去运行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行直至指定数量的字节码指令，或者线程主动让出控制（可以调用sleep(0)）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把线程设置为睡眠状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解锁GIL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;再次重复以上所有步骤&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;505096843&quot; data-ratio=&quot;0.5616438356164384&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TrMS1mPJIK4ia993XvTmTMY92OJSwaFFUiaPvzjxebr1yEic2PpkjVIvibDfhpv2Bwo8z8hHEgOG3iasZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python3.2前，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100（ticks可以看作是python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整），进行释放。因为计算密集型线程在释放GIL之后又会立即去申请GIL，并且通常在其它线程还没有调度完之前它就已经重新获取到了GIL，就会导致一旦计算密集型线程获得了GIL，那么它在很长一段时间内都将占据GIL，甚至一直到该线程执行结束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python 3.2开始使用新的GIL。新的GIL实现中用一个固定的超时时间来指示当前的线程放弃全局锁。在当前线程保持这个锁，且其他线程请求这个锁时，当前线程就会在5毫秒后被强制释放该锁。该改进在单核的情况下，对于单个线程长期占用GIL的情况有所好转。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单核CPU上，数百次的间隔检查才会导致一次线程切换。在多核CPU上，存在严重的线程颠簸（thrashing）。而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，从上面的实现机制可以推导出，Python的多线程对IO密集型代码要比CPU密集型代码更加友好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对GIL的应对措施：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用更高版本Python（对GIL机制进行了优化）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用多进程替换多线程（多进程之间没有GIL，但是进程本身的资源消耗较多）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指定cpu运行线程（使用affinity模块）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用Jython、IronPython等无GIL解释器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全IO密集型任务时才使用多线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用协程（高效的单线程模式，也称微线程；通常与多进程配合使用）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将关键组件用C/C++编写为Python扩展，通过ctypes使Python程序直接调用C语言编译的动态链接库的导出函数。（with nogil调出GIL限制）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Python的多进程包multiprocessing&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python的threading包主要运用多线程的开发，但由于GIL的存在，Python中的多线程其实并不是真正的多线程，如果想要充分地使用多核CPU的资源，大部分情况需要使用多进程。在Python 2.6版本的时候引入了multiprocessing包，它完整的复制了一套threading所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;借助这个multiprocessing，你可以轻松完成从单进程到并发执行的转换。multiprocessing支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Multiprocessing产生的背景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了应对Python的GIL以外，产生multiprocessing的另外一个原因时Windows操作系统与Linux/Unix系统的不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（父进程）复制了一份（子进程），然后，分别在父进程和子进程内返回。子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getpid()就可以拿到父进程的ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import os&lt;br/&gt;&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;Process (%s) start...&#x27;&lt;/span&gt; % os.getpid())&lt;br/&gt;&lt;br/&gt;\&lt;span&gt;# Only works on Unix/Linux/Mac:&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;pid = os.fork()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; pid == 0:&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;I am child process (%s) and my parent is %s.&#x27;&lt;/span&gt; % (os.getpid(), os.getppid()))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;I (%s) just created a child process (%s).&#x27;&lt;/span&gt; % (os.getpid(), pid))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述代码在Linux、Unix和Mac上的执行结果为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Process (876) start...&lt;br/&gt;&lt;br/&gt;I (876) just created a child process (877).&lt;br/&gt;&lt;br/&gt;I am child process (877) and my parent is 876.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于Windows没有fork调用，上面的代码在Windows上无法运行。由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。multiprocessing模块就是跨平台版本的多进程模块。multiprocessing模块封装了fork()调用，使我们不需要关注fork()的细节。由于Windows没有fork调用，因此，multiprocessing需要“模拟”出fork的效果。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;multiprocessing常用组件及功能&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;505096842&quot; data-ratio=&quot;0.5694444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fhujzoQe7TrMS1mPJIK4ia993XvTmTMY9ggRRIicXPVeEQhq5vF4ibLEcO9SMqYSbdU0Fsiamv2jbQHZuibSFianOic8w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;864&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建管理进程模块：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Process（用于创建进程）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Pool（用于创建管理进程池）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Queue（用于进程通信，资源共享）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Value，Array（用于进程通信，资源共享）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Pipe（用于管道通信）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Manager（用于资源共享）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步子进程模块：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Condition（条件变量）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Event（事件）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Lock（互斥锁）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RLock（可重入的互斥锁(同一个进程可以多次获得它，同时不会造成阻塞)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Semaphore（信号量）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来就一起来学习下每个组件及功能的具体使用方法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Process（用于创建进程）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;multiprocessing模块提供了一个Process类来代表一个进程对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在multiprocessing中，每一个进程都用一个Process类来表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法：Process([group [, target [, name [, args [, kwargs]]]]])&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;group：分组，实际上不使用，值始终为None&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;target：表示调用对象，即子进程要执行的任务，你可以传入方法名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;name：为子进程设定名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;args：要传给target函数的位置参数，以元组方式进行传入。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;kwargs：要传给target函数的字典参数，以字典方式进行传入。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;start()：启动进程，并调用该子进程中的p.run()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;run()：进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;terminate()：强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;is_alive()：返回进程是否在运行。如果p仍然运行，返回True&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;join([timeout])：进程同步，主进程等待子进程完成后再执行后面的代码。线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间（超过这个时间，父线程不再等待子线程，继续往下执行），需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;属性介绍：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;daemon：默认值为False，如果设为True，代表p为后台运行的守护进程；当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程；必须在p.start()之前设置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;name：进程的名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pid：进程的pid&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;exitcode：进程在运行时为None、如果为–N，表示被信号N结束(了解即可)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;authkey：进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用示例：（注意：在windows中Process()必须放到if &lt;strong&gt;name&lt;/strong&gt; == ‘&lt;strong&gt;main&lt;/strong&gt;’:下）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;from multiprocessing import Process&lt;br/&gt;&lt;br/&gt;import os&lt;br/&gt;&lt;br/&gt;def run_proc(name):&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;Run child process %s (%s)...&#x27;&lt;/span&gt; % (name, os.getpid()))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__==&lt;span&gt;&#x27;__main__&#x27;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;Parent process %s.&#x27;&lt;/span&gt; % os.getpid())&lt;br/&gt;&lt;br/&gt;    p = Process(target=run_proc, args=(&lt;span&gt;&#x27;test&#x27;&lt;/span&gt;,))&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;Child process will start.&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    p.start()&lt;br/&gt;&lt;br/&gt;    p.join()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;Child process end.&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Pool（用于创建管理进程池）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;505096850&quot; data-ratio=&quot;0.4605714285714286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TrMS1mPJIK4ia993XvTmTMY9P1U35Clr8lUV1dCibv1GEZcD2NomziccxkEdduGCx81GWy1EKcUSgvLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;875&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pool类用于需要执行的目标很多，而手动限制进程数量又太繁琐时，如果目标少且不用控制进程数量则可以用Process类。Pool可以提供指定数量的进程，供用户调用，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，就重用进程池中的进程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法：Pool([processes[, initializer[, initargs[, maxtasksperchild[, context]]]]])&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;processes ：要创建的进程数，如果省略，将默认使用cpu_count()返回的数量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;initializer：每个工作进程启动时要执行的可调用对象，默认为None。如果initializer是None，那么每一个工作进程在开始的时候会调用initializer(*initargs)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;initargs：是要传给initializer的参数组。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;maxtasksperchild：工作进程退出之前可以完成的任务数，完成后用一个新的工作进程来替代原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要Pool存在工作进程就会一直存活。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;context: 用在制定工作进程启动时的上下文，一般使用Pool() 或者一个context对象的Pool()方法来创建一个池，两种方法都适当的设置了context。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;apply(func[, args[, kwargs]])：在一个池工作进程中执行func(args,*kwargs),然后返回结果。需要强调的是：此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用p.apply()函数或者使用p.apply_async()。它是阻塞的。apply很少使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;apply_async(func[, arg[, kwds={}[, callback=None]]])：在一个池工作进程中执行func(args,*kwargs),然后返回结果。此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。它是非阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;map(func, iterable[, chunksize=None])：Pool类中的map方法，与内置的map函数用法行为基本一致，它会使进程阻塞直到返回结果。注意，虽然第二个参数是一个迭代器，但在实际使用中，必须在整个队列都就绪后，程序才会运行子进程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;map_async(func, iterable[, chunksize=None])：map_async与map的关系同apply与apply_async&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;imap()：imap 与 map的区别是，map是当所有的进程都已经执行完了，并将结果返回了，imap()则是立即返回一个iterable可迭代对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;imap_unordered()：不保证返回的结果顺序与进程添加的顺序一致。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;close()：关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;join()：等待所有工作进程退出。此方法只能在close()或teminate()之后调用，让其不再接受新的Process。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;terminate()：结束工作进程，不再处理未处理的任务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法apply_async()和map_async()的返回值是AsyncResul的实例obj。实例具有以下方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;get()：返回结果，如果有必要则等待结果到达。timeout是可选的。如果在指定时间内还没有到达，将引发异常。如果远程操作中引发了异常，它将在调用此方法时再次被引发。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ready()：如果调用完成，返回True&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;successful()：如果调用完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;wait([timeout])：等待结果变为可用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;terminate()：立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;\&lt;span&gt;# -*- coding:utf-8 -*-&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;\&lt;span&gt;# Pool+map&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;from multiprocessing import Pool&lt;br/&gt;&lt;br/&gt;def &lt;span&gt;test&lt;/span&gt;(i):&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(i)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&quot;__main__&quot;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;    lists = range(100)&lt;br/&gt;&lt;br/&gt;    pool = Pool(8)&lt;br/&gt;&lt;br/&gt;    pool.map(&lt;span&gt;test&lt;/span&gt;, lists)&lt;br/&gt;&lt;br/&gt;    pool.close()&lt;br/&gt;&lt;br/&gt;    pool.join()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;\&lt;span&gt;# -*- coding:utf-8 -*-&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;\&lt;span&gt;# 异步进程池（非阻塞）&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;from multiprocessing import Pool&lt;br/&gt;&lt;br/&gt;def &lt;span&gt;test&lt;/span&gt;(i):&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(i)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&quot;__main__&quot;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;    pool = Pool(8)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100):&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;span&gt;&#x27;&lt;br/&gt;&lt;br/&gt;        For循环中执行步骤：&lt;br/&gt;&lt;br/&gt;        （1）循环遍历，将100个子进程添加到进程池（相对父进程会阻塞）&lt;br/&gt;&lt;br/&gt;        （2）每次执行8个子进程，等一个子进程执行完后，立马启动新的子进程。（相对父进程不阻塞）&lt;br/&gt;&lt;br/&gt;        apply_async为异步进程池写法。异步指的是启动子进程的过程，与父进程本身的执行（print）是异步的，而For循环中往进程池添加子进程的过程，与父进程本身的执行却是同步的。&lt;br/&gt;&lt;br/&gt;        &#x27;&lt;/span&gt;&lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        pool.apply_async(&lt;span&gt;test&lt;/span&gt;, args=(i,))  &lt;span&gt;# 维持执行的进程总数为8，当一个进程执行完后启动一个新进程.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;test&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    pool.close()&lt;br/&gt;&lt;br/&gt;    pool.join()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;\&lt;span&gt;# -*- coding:utf-8 -*-&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;\&lt;span&gt;# 异步进程池（非阻塞）&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;from multiprocessing import Pool&lt;br/&gt;&lt;br/&gt;def &lt;span&gt;test&lt;/span&gt;(i):&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(i)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&quot;__main__&quot;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;    pool = Pool(8)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100):&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;span&gt;&#x27;&lt;br/&gt;&lt;br/&gt;            实际测试发现，for循环内部执行步骤：&lt;br/&gt;&lt;br/&gt;            （1）遍历100个可迭代对象，往进程池放一个子进程&lt;br/&gt;&lt;br/&gt;            （2）执行这个子进程，等子进程执行完毕，再往进程池放一个子进程，再执行。（同时只执行一个子进程）&lt;br/&gt;&lt;br/&gt;            for循环执行完毕，再执行print函数。&lt;br/&gt;&lt;br/&gt;        &#x27;&lt;/span&gt;&lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        pool.apply(&lt;span&gt;test&lt;/span&gt;, args=(i,))  &lt;span&gt;# 维持执行的进程总数为8，当一个进程执行完后启动一个新进程.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;test&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    pool.close()&lt;br/&gt;&lt;br/&gt;    pool.join()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Queue（用于进程通信，资源共享）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用多进程的过程中，最好不要使用共享资源。普通的全局变量是不能被子进程所共享的，只有通过Multiprocessing组件构造的数据结构可以被共享。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Queue&lt;/strong&gt;是用来创建进程间资源共享的队列的类，使用Queue可以达到多进程间数据传递的功能（缺点：只适用Process类，不能在Pool进程池中使用）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法：Queue([maxsize])&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;maxsize是队列中允许最大项数，省略则无大小限制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;put()：用以插入数据到队列。put方法还有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;get()：可以从队列读取并且删除一个元素。get方法有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常。若不希望在empty的时候抛出异常，令blocked为True或者参数全部置空即可。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;get_nowait()：同q.get(False)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;put_nowait()：同q.put(False)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;empty()：调用此方法时q为空则返回True，该结果不可靠，比如在返回True的过程中，如果队列中又加入了项目。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;full()：调用此方法时q已满则返回True，该结果不可靠，比如在返回True的过程中，如果队列中的项目被取走。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;qsize()：返回队列中目前项目的正确数量，结果也不可靠，理由同q.empty()和q.full()一样&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;from multiprocessing import Process, Queue&lt;br/&gt;&lt;br/&gt;import os, time, random&lt;br/&gt;&lt;br/&gt;def write(q):&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;Process to write: %s&#x27;&lt;/span&gt; % os.getpid())&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt; [&lt;span&gt;&#x27;A&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;B&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;C&#x27;&lt;/span&gt;]:&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;Put %s to queue...&#x27;&lt;/span&gt; % value)&lt;br/&gt;&lt;br/&gt;        q.put(value)&lt;br/&gt;&lt;br/&gt;        time.sleep(random.random())&lt;br/&gt;&lt;br/&gt;def &lt;span&gt;read&lt;/span&gt;(q):&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;Process to read: %s&#x27;&lt;/span&gt; % os.getpid())&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; True:&lt;br/&gt;&lt;br/&gt;        value = q.get(True)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;Get %s from queue.&#x27;&lt;/span&gt; % value)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&quot;__main__&quot;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;    q = Queue()&lt;br/&gt;&lt;br/&gt;    pw = Process(target=write, args=(q,))&lt;br/&gt;&lt;br/&gt;    pr = Process(target=&lt;span&gt;read&lt;/span&gt;, args=(q,))&lt;br/&gt;&lt;br/&gt;    pw.start()&lt;br/&gt;&lt;br/&gt;    pr.start()&lt;br/&gt;&lt;br/&gt;    pw.join()  &lt;span&gt;# 等待pw结束&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    pr.terminate()  &lt;span&gt;# pr进程里是死循环，无法等待其结束，只能强行终止&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JoinableQueue&lt;/strong&gt;就像是一个Queue对象，但队列允许项目的使用者通知生成者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法：JoinableQueue([maxsize])&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;maxsize：队列中允许最大项数，省略则无大小限制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JoinableQueue的实例p除了与Queue对象相同的方法之外还具有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;task_done()：使用者使用此方法发出信号，表示q.get()的返回项目已经被处理。如果调用此方法的次数大于从队列中删除项目的数量，将引发ValueError异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;join():生产者调用此方法进行阻塞，直到队列中所有的项目均被处理。阻塞将持续到队列中的每个项目均调用q.task_done（）方法为止&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;\&lt;span&gt;# -*- coding:utf-8 -*-&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;from multiprocessing import Process, JoinableQueue&lt;br/&gt;&lt;br/&gt;import time, random&lt;br/&gt;&lt;br/&gt;def consumer(q):&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; True:&lt;br/&gt;&lt;br/&gt;        res = q.get()&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;消费者拿到了 %s&#x27;&lt;/span&gt; % res)&lt;br/&gt;&lt;br/&gt;        q.task_done()&lt;br/&gt;&lt;br/&gt;def producer(seq, q):&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; seq:&lt;br/&gt;&lt;br/&gt;        time.sleep(random.randrange(1,2))&lt;br/&gt;&lt;br/&gt;        q.put(item)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;生产者做好了 %s&#x27;&lt;/span&gt; % item)&lt;br/&gt;&lt;br/&gt;    q.join()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&quot;__main__&quot;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;    q = JoinableQueue()&lt;br/&gt;&lt;br/&gt;    seq = (&lt;span&gt;&#x27;产品%s&#x27;&lt;/span&gt; % i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5))&lt;br/&gt;&lt;br/&gt;    p = Process(target=consumer, args=(q,))&lt;br/&gt;&lt;br/&gt;    p.daemon = True  &lt;span&gt;# 设置为守护进程，在主线程停止时p也停止，但是不用担心，producer内调用q.join保证了consumer已经处理完队列中的所有元素&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    p.start()&lt;br/&gt;&lt;br/&gt;    producer(seq, q)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;主线程&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Value，Array（用于进程通信，资源共享）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;multiprocessing 中Value和Array的实现原理都是在共享内存中创建ctypes()对象来达到共享数据的目的，两者实现方法大同小异，只是选用不同的ctypes数据类型而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Value&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法：Value((typecode_or_type, args[, lock])&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;typecode_or_type：定义ctypes()对象的类型，可以传Type code或 C Type，具体对照表见下文。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;args：传递给typecode_or_type构造函数的参数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lock：默认为True，创建一个互斥锁来限制对Value对象的访问，如果传入一个锁，如Lock或RLock的实例，将用于同步。如果传入False，Value的实例就不会被锁保护，它将不是进程安全的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;typecode_or_type支持的类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;| Type code | C Type             | Python Type       | Minimum size &lt;span&gt;in&lt;/span&gt; bytes |&lt;br/&gt;&lt;br/&gt;| --------- | ------------------ | ----------------- | --------------------- |&lt;br/&gt;&lt;br/&gt;| `&lt;span&gt;&#x27;b&#x27;&lt;/span&gt;`     | signed char        | int               | 1                     |&lt;br/&gt;&lt;br/&gt;| `&lt;span&gt;&#x27;B&#x27;&lt;/span&gt;`     | unsigned char      | int               | 1                     |&lt;br/&gt;&lt;br/&gt;| `&lt;span&gt;&#x27;u&#x27;&lt;/span&gt;`     | Py_UNICODE         | Unicode character | 2                     |&lt;br/&gt;&lt;br/&gt;| `&lt;span&gt;&#x27;h&#x27;&lt;/span&gt;`     | signed short       | int               | 2                     |&lt;br/&gt;&lt;br/&gt;| `&lt;span&gt;&#x27;H&#x27;&lt;/span&gt;`     | unsigned short     | int               | 2                     |&lt;br/&gt;&lt;br/&gt;| `&lt;span&gt;&#x27;i&#x27;&lt;/span&gt;`     | signed int         | int               | 2                     |&lt;br/&gt;&lt;br/&gt;| `&lt;span&gt;&#x27;I&#x27;&lt;/span&gt;`     | unsigned int       | int               | 2                     |&lt;br/&gt;&lt;br/&gt;| `&lt;span&gt;&#x27;l&#x27;&lt;/span&gt;`     | signed long        | int               | 4                     |&lt;br/&gt;&lt;br/&gt;| `&lt;span&gt;&#x27;L&#x27;&lt;/span&gt;`     | unsigned long      | int               | 4                     |&lt;br/&gt;&lt;br/&gt;| `&lt;span&gt;&#x27;q&#x27;&lt;/span&gt;`     | signed long long   | int               | 8                     |&lt;br/&gt;&lt;br/&gt;| `&lt;span&gt;&#x27;Q&#x27;&lt;/span&gt;`     | unsigned long long | int               | 8                     |&lt;br/&gt;&lt;br/&gt;| `&lt;span&gt;&#x27;f&#x27;&lt;/span&gt;`     | &lt;span&gt;float&lt;/span&gt;              | &lt;span&gt;float&lt;/span&gt;             | 4                     |&lt;br/&gt;&lt;br/&gt;| `&lt;span&gt;&#x27;d&#x27;&lt;/span&gt;`     | double             | &lt;span&gt;float&lt;/span&gt;             | 8                     |&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考地址：https://docs.python.org/3/library/array.html&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Array&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法：Array(typecode_or_type, size_or_initializer, **kwds[, lock])&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;typecode_or_type：同上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;size_or_initializer：如果它是一个整数，那么它确定数组的长度，并且数组将被初始化为零。否则，size_or_initializer是用于初始化数组的序列，其长度决定数组的长度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;kwds：传递给typecode_or_type构造函数的参数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lock：同上&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import multiprocessing&lt;br/&gt;&lt;br/&gt;def f(n, a):&lt;br/&gt;&lt;br/&gt;    n.value = 3.14&lt;br/&gt;&lt;br/&gt;    a[0] = 5&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&#x27;__main__&#x27;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;    num = multiprocessing.Value(&lt;span&gt;&#x27;d&#x27;&lt;/span&gt;, 0.0)&lt;br/&gt;&lt;br/&gt;    arr = multiprocessing.Array(&lt;span&gt;&#x27;i&#x27;&lt;/span&gt;, range(10))&lt;br/&gt;&lt;br/&gt;    p = multiprocessing.Process(target=f, args=(num, arr))&lt;br/&gt;&lt;br/&gt;    p.start()&lt;br/&gt;&lt;br/&gt;    p.join()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(num.value)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(arr[:])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：Value和Array只适用于Process类。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Pipe（用于管道通信）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多进程还有一种数据传递方式叫管道原理和 Queue相同。Pipe可以在进程之间创建一条管道，并返回元组（conn1,conn2）,其中conn1，conn2表示管道两端的连接对象，强调一点：必须在产生Process对象之前产生管道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法：Pipe([duplex])&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;dumplex:默认管道是全双工的，如果将duplex射成False，conn1只能用于接收，conn2只能用于发送。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;send(obj)：通过连接发送对象。obj是与序列化兼容的任意对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;recv()：接收conn2.send(obj)发送的对象。如果没有消息可接收，recv方法会一直阻塞。如果连接的另外一端已经关闭，那么recv方法会抛出EOFError。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;close():关闭连接。如果conn1被垃圾回收，将自动调用此方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;fileno():返回连接使用的整数文件描述符&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;poll([timeout]):如果连接上的数据可用，返回True。timeout指定等待的最长时限。如果省略此参数，方法将立即返回结果。如果将timeout射成None，操作将无限期地等待数据到达。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;recv_bytes([maxlength]):接收c.send_bytes()方法发送的一条完整的字节消息。maxlength指定要接收的最大字节数。如果进入的消息，超过了这个最大值，将引发IOError异常，并且在连接上无法进行进一步读取。如果连接的另外一端已经关闭，再也不存在任何数据，将引发EOFError异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;send_bytes(buffer [, offset [, size]])：通过连接发送字节数据缓冲区，buffer是支持缓冲区接口的任意对象，offset是缓冲区中的字节偏移量，而size是要发送字节数。结果数据以单条消息的形式发出，然后调用c.recv_bytes()函数进行接收&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;recv_bytes_into(buffer [, offset]):接收一条完整的字节消息，并把它保存在buffer对象中，该对象支持可写入的缓冲区接口（即bytearray对象或类似的对象）。offset指定缓冲区中放置消息处的字节位移。返回值是收到的字节数。如果消息长度大于可用的缓冲区空间，将引发BufferTooShort异常。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;from multiprocessing import Process, Pipe&lt;br/&gt;&lt;br/&gt;import time&lt;br/&gt;&lt;br/&gt;\&lt;span&gt;# 子进程执行方法&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;def f(Subconn):&lt;br/&gt;&lt;br/&gt;    time.sleep(1)&lt;br/&gt;&lt;br/&gt;    Subconn.send(&lt;span&gt;&quot;吃了吗&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;来自父亲的问候:&quot;&lt;/span&gt;, Subconn.recv())&lt;br/&gt;&lt;br/&gt;    Subconn.close()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&quot;__main__&quot;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;    parent_conn, child_conn = Pipe()  &lt;span&gt;# 创建管道两端&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    p = Process(target=f, args=(child_conn,))  &lt;span&gt;# 创建子进程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    p.start()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;来自儿子的问候:&quot;&lt;/span&gt;, parent_conn.recv())&lt;br/&gt;&lt;br/&gt;    parent_conn.send(&lt;span&gt;&quot;嗯&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Manager（用于资源共享）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Manager()返回的manager对象控制了一个server进程，此进程包含的python对象可以被其他的进程通过proxies来访问。从而达到多进程间数据通信且安全。Manager模块常与Pool模块一起使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Manager支持的类型有list,dict,Namespace,Lock,RLock,Semaphore,BoundedSemaphore,Condition,Event,Queue,Value和Array。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;管理器是独立运行的子进程，其中存在真实的对象，并以服务器的形式运行，其他进程通过使用代理访问共享对象，这些代理作为客户端运行。Manager()是BaseManager的子类，返回一个启动的SyncManager()实例，可用于创建共享对象并返回访问这些共享对象的代理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;BaseManager&lt;/strong&gt;，创建管理器服务器的基类&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法：BaseManager([address[, authkey]])&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;address：(hostname,port),指定服务器的网址地址，默认为简单分配一个空闲的端口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;authkey：连接到服务器的客户端的身份验证，默认为current_process().authkey的值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;start([initializer[, initargs]])：启动一个单独的子进程，并在该子进程中启动管理器服务器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;get_server()：获取服务器对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;connect()：连接管理器对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;shutdown()：关闭管理器对象，只能在调用了start()方法之后调用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例属性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;address：只读属性，管理器服务器正在使用的地址&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SyncManager&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;以下类型均不是进程安全的，需要加锁..&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Array(self,*args,**kwds)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BoundedSemaphore(self,*args,**kwds)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Condition(self,*args,**kwds)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Event(self,*args,**kwds)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JoinableQueue(self,*args,**kwds)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Lock(self,*args,**kwds)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Namespace(self,*args,**kwds)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Pool(self,*args,**kwds)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Queue(self,*args,**kwds)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RLock(self,*args,**kwds)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Semaphore(self,*args,**kwds)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Value(self,*args,**kwds)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dict(self,*args,**kwds)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;list(self,*args,**kwds)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import multiprocessing&lt;br/&gt;&lt;br/&gt;def f(x, arr, l, d, n):&lt;br/&gt;&lt;br/&gt;    x.value = 3.14&lt;br/&gt;&lt;br/&gt;    arr[0] = 5&lt;br/&gt;&lt;br/&gt;    l.append(&lt;span&gt;&#x27;Hello&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    d[1] = 2&lt;br/&gt;&lt;br/&gt;    n.a = 10&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&#x27;__main__&#x27;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;    server = multiprocessing.Manager()&lt;br/&gt;&lt;br/&gt;    x = server.Value(&lt;span&gt;&#x27;d&#x27;&lt;/span&gt;, 0.0)&lt;br/&gt;&lt;br/&gt;    arr = server.Array(&lt;span&gt;&#x27;i&#x27;&lt;/span&gt;, range(10))&lt;br/&gt;&lt;br/&gt;    l = server.list()&lt;br/&gt;&lt;br/&gt;    d = server.dict()&lt;br/&gt;&lt;br/&gt;    n = server.Namespace()&lt;br/&gt;&lt;br/&gt;    proc = multiprocessing.Process(target=f, args=(x, arr, l, d, n))&lt;br/&gt;&lt;br/&gt;    proc.start()&lt;br/&gt;&lt;br/&gt;    proc.join()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(x.value)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(arr)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(l)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(d)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(n)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;同步子进程模块&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Lock（互斥锁）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lock锁的作用是当多个进程需要访问共享资源的时候，避免访问的冲突。加锁保证了多个进程修改同一块数据时，同一时间只能有一个修改，即串行的修改，牺牲了速度但保证了数据安全。Lock包含两种状态——锁定和非锁定，以及两个基本的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法：Lock()&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;acquire([timeout]): 使线程进入同步阻塞状态，尝试获得锁定。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;release(): 释放锁。使用前线程必须已获得锁定，否则将抛出异常。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;from multiprocessing import Process, Lock&lt;br/&gt;&lt;br/&gt;def l(lock, num):&lt;br/&gt;&lt;br/&gt;    lock.acquire()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;Hello Num: %s&quot;&lt;/span&gt; % (num))&lt;br/&gt;&lt;br/&gt;    lock.release()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&#x27;__main__&#x27;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;    lock = Lock()  &lt;span&gt;# 这个一定要定义为全局&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; num &lt;span&gt;in&lt;/span&gt; range(20):&lt;br/&gt;&lt;br/&gt;        Process(target=l, args=(lock, num)).start()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RLock（可重入的互斥锁(同一个进程可以多次获得它，同时不会造成阻塞)&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RLock（可重入锁）是一个可以被同一个线程请求多次的同步指令。RLock使用了“拥有的线程”和“递归等级”的概念，处于锁定状态时，RLock被某个线程拥有。拥有RLock的线程可以再次调用acquire()，释放锁时需要调用release()相同次数。可以认为RLock包含一个锁定池和一个初始值为0的计数器，每次成功调用 acquire()/release()，计数器将+1/-1，为0时锁处于未锁定状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法：RLock()&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;acquire([timeout])：同Lock&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;release(): 同Lock&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Semaphore（信号量）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;信号量是一个更高级的锁机制。信号量内部有一个计数器而不像锁对象内部有锁标识，而且只有当占用信号量的线程数超过信号量时线程才阻塞。这允许了多个线程可以同时访问相同的代码区。比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去，如果指定信号量为3，那么来一个人获得一把锁，计数加1，当计数等于3时，后面的人均需要等待。一旦释放，就有人可以获得一把锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法：Semaphore([value])&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;acquire([timeout])：同Lock&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;release(): 同Lock&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;from multiprocessing import Process, Semaphore&lt;br/&gt;&lt;br/&gt;import time, random&lt;br/&gt;&lt;br/&gt;def go_wc(sem, user):&lt;br/&gt;&lt;br/&gt;    sem.acquire()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;%s 占到一个茅坑&#x27;&lt;/span&gt; % user)&lt;br/&gt;&lt;br/&gt;    time.sleep(random.randint(0, 3))&lt;br/&gt;&lt;br/&gt;    sem.release()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(user, &lt;span&gt;&#x27;OK&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&#x27;__main__&#x27;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;    sem = Semaphore(2)&lt;br/&gt;&lt;br/&gt;    p_l = []&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5):&lt;br/&gt;&lt;br/&gt;        p = Process(target=go_wc, args=(sem, &lt;span&gt;&#x27;user%s&#x27;&lt;/span&gt; % i,))&lt;br/&gt;&lt;br/&gt;        p.start()&lt;br/&gt;&lt;br/&gt;        p_l.append(p)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; p_l:&lt;br/&gt;&lt;br/&gt;        i.join()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Condition（条件变量）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以把Condition理解为一把高级的锁，它提供了比Lock, RLock更高级的功能，允许我们能够控制复杂的线程同步问题。Condition在内部维护一个锁对象（默认是RLock），可以在创建Condigtion对象的时候把琐对象作为参数传入。Condition也提供了acquire, release方法，其含义与锁的acquire, release方法一致，其实它只是简单的调用内部锁对象的对应的方法而已。Condition还提供了其他的一些方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法：Condition([lock/rlock])&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以传递一个Lock/RLock实例给构造方法，否则它将自己生成一个RLock实例。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;acquire([timeout])：首先进行acquire，然后判断一些条件。如果条件不满足则wait&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;release()：释放 Lock&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;wait([timeout]): 调用这个方法将使线程进入Condition的等待池等待通知，并释放锁。使用前线程必须已获得锁定，否则将抛出异常。处于wait状态的线程接到通知后会重新判断条件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;notify(): 调用这个方法将从等待池挑选一个线程并通知，收到通知的线程将自动调用acquire()尝试获得锁定（进入锁定池）；其他线程仍然在等待池中。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;notifyAll(): 调用这个方法将通知等待池中所有的线程，这些线程都将进入锁定池尝试获得锁定。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import multiprocessing&lt;br/&gt;&lt;br/&gt;import time&lt;br/&gt;&lt;br/&gt;def stage_1(cond):&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;perform first stage of work,&lt;br/&gt;&lt;br/&gt;    then notify stage_2 to continue&lt;br/&gt;&lt;br/&gt;    &quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    name = multiprocessing.current_process().name&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;Starting&#x27;&lt;/span&gt;, name)&lt;br/&gt;&lt;br/&gt;    with cond:&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;{} done and ready for stage 2&#x27;&lt;/span&gt;.format(name))&lt;br/&gt;&lt;br/&gt;        cond.notify_all()&lt;br/&gt;&lt;br/&gt;def stage_2(cond):&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;wait for the condition telling us stage_1 is done&quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    name = multiprocessing.current_process().name&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;Starting&#x27;&lt;/span&gt;, name)&lt;br/&gt;&lt;br/&gt;    with cond:&lt;br/&gt;&lt;br/&gt;        cond.wait()&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;{} running&#x27;&lt;/span&gt;.format(name))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&#x27;__main__&#x27;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;    condition = multiprocessing.Condition()&lt;br/&gt;&lt;br/&gt;    s1 = multiprocessing.Process(name=&lt;span&gt;&#x27;s1&#x27;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;                                 target=stage_1,&lt;br/&gt;&lt;br/&gt;                                 args=(condition,))&lt;br/&gt;&lt;br/&gt;    s2_clients = [&lt;br/&gt;&lt;br/&gt;        multiprocessing.Process(&lt;br/&gt;&lt;br/&gt;            name=&lt;span&gt;&#x27;stage_2[{}]&#x27;&lt;/span&gt;.format(i),&lt;br/&gt;&lt;br/&gt;            target=stage_2,&lt;br/&gt;&lt;br/&gt;            args=(condition,),&lt;br/&gt;&lt;br/&gt;        )&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1, 3)&lt;br/&gt;&lt;br/&gt;    ]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; c &lt;span&gt;in&lt;/span&gt; s2_clients:&lt;br/&gt;&lt;br/&gt;        c.start()&lt;br/&gt;&lt;br/&gt;        time.sleep(1)&lt;br/&gt;&lt;br/&gt;    s1.start()&lt;br/&gt;&lt;br/&gt;    s1.join()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; c &lt;span&gt;in&lt;/span&gt; s2_clients:&lt;br/&gt;&lt;br/&gt;        c.join()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Event（事件）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Event内部包含了一个标志位，初始的时候为false。可以使用set()来将其设置为true；或者使用clear()将其从新设置为false；可以使用is_set()来检查标志位的状态；另一个最重要的函数就是wait(timeout=None)，用来阻塞当前线程，直到event的内部标志位被设置为true或者timeout超时。如果内部标志位为true则wait()函数理解返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import multiprocessing&lt;br/&gt;&lt;br/&gt;import time&lt;br/&gt;&lt;br/&gt;def wait_for_event(e):&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;Wait for the event to be set before doing anything&quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;wait_for_event: starting&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    e.wait()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;wait_for_event: e.is_set()-&amp;gt;&#x27;&lt;/span&gt;, e.is_set())&lt;br/&gt;&lt;br/&gt;def wait_for_event_timeout(e, t):&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;Wait t seconds and then timeout&quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;wait_for_event_timeout: starting&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    e.wait(t)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;wait_for_event_timeout: e.is_set()-&amp;gt;&#x27;&lt;/span&gt;, e.is_set())&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&#x27;__main__&#x27;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;    e = multiprocessing.Event()&lt;br/&gt;&lt;br/&gt;    w1 = multiprocessing.Process(&lt;br/&gt;&lt;br/&gt;        name=&lt;span&gt;&#x27;block&#x27;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;        target=wait_for_event,&lt;br/&gt;&lt;br/&gt;        args=(e,),&lt;br/&gt;&lt;br/&gt;    )&lt;br/&gt;&lt;br/&gt;    w1.start()&lt;br/&gt;&lt;br/&gt;    w2 = multiprocessing.Process(&lt;br/&gt;&lt;br/&gt;        name=&lt;span&gt;&#x27;nonblock&#x27;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;        target=wait_for_event_timeout,&lt;br/&gt;&lt;br/&gt;        args=(e, 2),&lt;br/&gt;&lt;br/&gt;    )&lt;br/&gt;&lt;br/&gt;    w2.start()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;main: waiting before calling Event.set()&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    time.sleep(3)&lt;br/&gt;&lt;br/&gt;    e.set()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&#x27;main: event is set&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他内容&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;multiprocessing.dummy 模块与 multiprocessing 模块的区别：dummy 模块是多线程，而 multiprocessing 是多进程， api 都是通用的。所有可以很方便将代码在多线程和多进程之间切换。multiprocessing.dummy通常在IO场景可以尝试使用，比如使用如下方式引入线程池。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;from multiprocessing.dummy import Pool as ThreadPool&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;multiprocessing.dummy与早期的threading，不同的点好像是在多多核CPU下，只绑定了一个核心（具体未考证）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考文档：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://docs.python.org/3/library/multiprocessing.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://www.rddoc.com/doc/Python/3.6.0/zh/library/multiprocessing/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Python并发之concurrent.futures&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python标准库为我们提供了threading和multiprocessing模块编写相应的多线程/多进程代码。从Python3.2开始，标准库为我们提供了concurrent.futures模块，它提供了ThreadPoolExecutor和ProcessPoolExecutor两个类，实现了对threading和multiprocessing的更高级的抽象，对编写线程池/进程池提供了直接的支持。concurrent.futures基础模块是executor和future。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Executor&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Executor是一个抽象类，它不能被直接使用。它为具体的异步执行定义了一些基本的方法。ThreadPoolExecutor和ProcessPoolExecutor继承了Executor，分别被用来创建线程池和进程池的代码。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ThreadPoolExecutor对象&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadPoolExecutor类是Executor子类，使用线程池执行异步调用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;class concurrent.futures.ThreadPoolExecutor(max_workers)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用max_workers数目的线程池执行异步调用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ProcessPoolExecutor对象&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadPoolExecutor类是Executor子类，使用进程池执行异步调用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;class concurrent.futures.ProcessPoolExecutor(max_workers=None)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用max_workers数目的进程池执行异步调用，如果max_workers为None则使用机器的处理器数目（如4核机器max_worker配置为None时，则使用4个进程进行异步并发）。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;submit()方法&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Executor中定义了submit()方法，这个方法的作用是提交一个可执行的回调task，并返回一个future实例。future对象代表的就是给定的调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Executor.submit(fn, *args, **kwargs)&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;fn：需要异步执行的函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;*args, **kwargs：fn参数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;from concurrent import futures&lt;br/&gt;&lt;br/&gt;def &lt;span&gt;test&lt;/span&gt;(num):&lt;br/&gt;&lt;br/&gt;    import time&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; time.ctime(), num&lt;br/&gt;&lt;br/&gt;with futures.ThreadPoolExecutor(max_workers=1) as executor:&lt;br/&gt;&lt;br/&gt;    future = executor.submit(&lt;span&gt;test&lt;/span&gt;, 1)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(future.result())&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;map()方法&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了submit，Exectuor还为我们提供了map方法，这个方法返回一个map(func, *iterables)迭代器，迭代器中的回调执行返回的结果有序的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Executor.map(func, *iterables, timeout=None)&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;func：需要异步执行的函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;*iterables：可迭代对象，如列表等。每一次func执行，都会从iterables中取参数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;timeout：设置每次异步操作的超时时间，timeout的值可以是int或float，如果操作超时，会返回raisesTimeoutError；如果不指定timeout参数，则不设置超时间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;from concurrent import futures&lt;br/&gt;&lt;br/&gt;def &lt;span&gt;test&lt;/span&gt;(num):&lt;br/&gt;&lt;br/&gt;    import time&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; time.ctime(), num&lt;br/&gt;&lt;br/&gt;data = [1, 2, 3]&lt;br/&gt;&lt;br/&gt;with futures.ThreadPoolExecutor(max_workers=1) as executor:&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; future &lt;span&gt;in&lt;/span&gt; executor.map(&lt;span&gt;test&lt;/span&gt;, data):&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;print&lt;/span&gt;(future)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;shutdown()方法&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放系统资源,在Executor.submit()或 Executor.map()等异步操作后调用。使用with语句可以避免显式调用此方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Executor.shutdown(wait=True)&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Future&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Future可以理解为一个在未来完成的操作，这是异步编程的基础。通常情况下，我们执行io操作，访问url时（如下）在等待结果返回之前会产生阻塞，cpu不能做其他事情，而Future的引入帮助我们在等待的这段时间可以完成其他的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Future类封装了可调用的异步执行。Future 实例通过 Executor.submit()方法创建。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;cancel()：试图取消调用。如果调用当前正在执行，并且不能被取消，那么该方法将返回False，否则调用将被取消，方法将返回True。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cancelled()：如果成功取消调用，返回True。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;running()：如果调用当前正在执行并且不能被取消，返回True。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;done()：如果调用成功地取消或结束了，返回True。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;result(timeout=None)：返回调用返回的值。如果调用还没有完成，那么这个方法将等待超时秒。如果调用在超时秒内没有完成，那么就会有一个Futures.TimeoutError将报出。timeout可以是一个整形或者浮点型数值，如果timeout不指定或者为None,等待时间无限。如果futures在完成之前被取消了，那么 CancelledError 将会报出。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;exception(timeout=None)：返回调用抛出的异常，如果调用还未完成，该方法会等待timeout指定的时长，如果该时长后调用还未完成，就会报出超时错误futures.TimeoutError。timeout可以是一个整形或者浮点型数值，如果timeout不指定或者为None,等待时间无限。如果futures在完成之前被取消了，那么 CancelledError 将会报出。如果调用完成并且无异常报出，返回None.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;add_done_callback(fn)：将可调用fn捆绑到future上，当Future被取消或者结束运行，fn作为future的唯一参数将会被调用。如果future已经运行完成或者取消，fn将会被立即调用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;wait(fs, timeout=None, return_when=ALL_COMPLETED)&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;等待fs提供的 Future 实例(possibly created by different Executor instances) 运行结束。返回一个命名的2元集合，分表代表已完成的和未完成的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;return_when 表明什么时候函数应该返回。它的值必须是一下值之一：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;FIRST_COMPLETED :函数在任何future结束或者取消的时候返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FIRST_EXCEPTION ：函数在任何future因为异常结束的时候返回，如果没有future报错，效果等于&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ALL_COMPLETED :函数在所有future结束后才会返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;as_completed(fs, timeout=None)：参数是一个 Future 实例列表，返回值是一个迭代器，在运行结束后产出 Future实例 。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;from concurrent.futures import ThreadPoolExecutor, &lt;span&gt;wait&lt;/span&gt;, as_completed&lt;br/&gt;&lt;br/&gt;from time import sleep&lt;br/&gt;&lt;br/&gt;from random import randint&lt;br/&gt;&lt;br/&gt;def return_after_5_secs(num):&lt;br/&gt;&lt;br/&gt;    sleep(randint(1, 5))&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Return of {}&quot;&lt;/span&gt;.format(num)&lt;br/&gt;&lt;br/&gt;pool = ThreadPoolExecutor(5)&lt;br/&gt;&lt;br/&gt;futures = []&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(5):&lt;br/&gt;&lt;br/&gt;    futures.append(pool.submit(return_after_5_secs, x))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(1)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; as_completed(futures):&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;(x.result())&lt;br/&gt;&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(2)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考链接：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://pythonhosted.org/futures&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>24c605af89f3d4dc990c84869d92b166</guid>
<title>云原生DevOps，研发一体化的践行利器</title>
<link>https://toutiao.io/k/wcnoqnd</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;
  &lt;noscript&gt;您需要允许该网站执行 JavaScript&lt;/noscript&gt;
  
  
  
  
  
&lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
</channel></rss>