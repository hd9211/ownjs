<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>fae532b3c3603114df73d958063ce428</guid>
<title>2021 年马上就要结束了！抓紧啦！</title>
<link>https://toutiao.io/k/rf8ezjy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b56596d46553bef1132d3efe24d274e9</guid>
<title>爬虫管理平台 Crawlab 新版本的正确打开姿势（一）</title>
<link>https://toutiao.io/k/rz78afm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Crawlab&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 是开源分布式爬虫管理平台，近期发布了 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxOTMxMjA1NQ==&amp;amp;mid=2247483981&amp;amp;idx=1&amp;amp;sn=073668649bb9977cd70a7c1f09d5011e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;v0.6 beta 版本&lt;/a&gt;，在性能、稳定性、易用性等方面做了大量的优化。它相对于之前的 v0.5 版本有什么区别？其中主要优化的部分主要是什么？作为 Crawlab 用户我是否应该迁移到新版本上？本篇文章将从新版本的新特性出发，介绍新老版本的主要区别，以及如何安装使用新版本，让对 Crawlab v0.6 新版本感兴趣的小伙伴更容易上手。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;新特性介绍&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，v0.6 新版本做了大量的底层优化，不过作者不打算介绍底层原理，我们将在之后的文章中详细介绍。这个小节将从使用方面主要介绍新版本的主要新功能和特性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;文件上传优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Crawlab v0.6 版本之前，上传爬虫文件有 2 种方式：ZIP 打包或者使用 CLI 工具。ZIP 打包上传被证明是一种落后的方式，特别是遇到 Scrapy 项目，必须要求在 &lt;code&gt;scrapy.cfg&lt;/code&gt; 所在目录（根目录）进行打包，否则 Crawlab 内置的 Scrapy 辅助工具将识别不出来，或者运行时因为目录层级结构不一致导致错误；此外，即使使用 CLI 上传，也会出现类似的目录层级结构问题。在新版本中，我们保留了 CLI 上传的方式，移除了 ZIP 上传方式，另外添加了拖拽、选择目录、选择文件等非 ZIP 打包上传文件的方式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;拖拽上传&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拖拽上传非常简单，就跟在 IDE 里操作一样，将文件从操作系统目录中拖拽到文件编辑器导航栏其中一个目录上，即可上传。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6108333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sczKD2TyOPhfyuuKZwdX83rhD83DWlqkpxLWKTglDcZ2Mf00A9bJdz61THLSamu2yn2HOtrvHDgjx1FCOGyltQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;crawlab-drag-drop-upload&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;选择目录上传&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您想上传整个爬虫目录，同样可以在 Crawlab 新版本中操作。操作方式非常简单，点击文件上传按钮，点选目录，再点击上传按钮并选择待上传目录，就可以将整个爬虫项目上传到 Crawlab 了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.611157368859284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sczKD2TyOPhfyuuKZwdX83rhD83DWlqkzqiaMAbtYFKl7TmNiaAmZUqBuThyLhsibl6lSJl68hLYjLKt3ymz5AtRw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1201&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;crawlab-select-folder-upload&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;选择文件上传&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了拖拽上传和选择目录上传，Crawlab 也允许单独选择文件上传。操作方式跟选择目录上传类似。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6108333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sczKD2TyOPhfyuuKZwdX83rhD83DWlqkgKoicmcRsodWdnbiaoHmp0F3goYv8rxVN1c3InCESzkcQciakAcSzfibvw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;crawlab-select-file-upload&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文件编辑器优化&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老版本 (v0.5) 的文件编辑器虽然可以做一些基础的文件编辑功能，但它似乎还不够像主流文件编辑器软件这样完善，说白了就是用得不爽。Crawlab 新版本在文件编辑器方面做了大量的优化，几乎是推倒重做。目的就是为了让用户在界面上操作文件更舒服，而不用勉强采用 “本地编辑再上传运行” 的蹩脚方式。很多时候，爬虫工程师需要及时调试代码，而 Crawlab 新版本希望通过这次优化让用户尽可能方便的在界面上操作文件，从而摆脱对本地编辑的依赖。除了之前提到的优化后的文件目录上传方式以外，Crawlab 文件编辑器还支持更多现代化代码编辑器功能，包括文件标签、右键菜单操作、拖拽移动、智能图标等功能。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;文件标签&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候编辑代码时需要多个文件同时操作，这在主流代码编辑器中都有实现，而 Crawlab 新版本也同样支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以双击文件打开多个标签。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6108333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sczKD2TyOPhfyuuKZwdX83rhD83DWlqkWdutbYuR7rKYAuOcdpOsokFu42G1cQF9iagE1zibwYeboANQdeuZ2oAw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;crawlab-file-editor-open-tabs&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以点击文件标签来回切换。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6108333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sczKD2TyOPhfyuuKZwdX83rhD83DWlqkwnAL1g07l2EaRf5b7uiapDHDD39s61UyDAP2KCicyXnibkmEIy4HekxBQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;crawlab-file-editor-switch-tabs&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有更多复杂操作，例如拖拽和右键菜单操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6108333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sczKD2TyOPhfyuuKZwdX83rhD83DWlqkFOFY2InOJmuAdB0tu7nIBfg97cwIliciaYBGgnLoeAs1sUGPjN3VET3A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;crawlab-filer-editor-drag-tabs&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;右键菜单操作&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Crawlab 文件编辑器可以右键点击左侧的文件或目录进行更多的操作，新建文件、新建目录、重命名、复制、删除，应有尽有。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6108333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sczKD2TyOPhfyuuKZwdX83rhD83DWlqkHeXoCqo6LprcMkyTXxo3ibrtqHnaDejD2dUpNErmsRuEOq4IibesE8Ag/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;crawlab-file-editor-context-menu&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;拖拽移动&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Crawlab 文件编辑器还可以像主流 IDE 那样拖拽移动文件或目录。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6108333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sczKD2TyOPhfyuuKZwdX83rhD83DWlqksNMEEgT0KKfG4pIYBnVvY0JSpwYic7oyXQEhX8FXysfs7FjZry4Rnjg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;crawlab-file-editor-drag-drop&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;智能图标&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人可能比较习惯 JebBrains IDEA 或 VS Code 等 IDE 中各种类别文件目录的自动指定图标，而 Crawlab 文件编辑器中也支持这个功能，让开发者可以一目了然的了解各个文件或目录是用做什么功能的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5584415584415585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sczKD2TyOPhfyuuKZwdX83rhD83DWlqk0HjFicQ9KSlkA9iaib7c8xD6WgdvVq8iaqzL8VaialVnZQJs1JFedq4ZJGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;308&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;crawlab-file-editor-icons&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Crawlab 文件编辑器的智能图标是基于 &lt;span&gt;atom-material-icons&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 实现的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;表格功能优化&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Crawlab 新版本中加强了表格的优化。表格是展现列表的有效方式，例如爬虫列表、任务列表等都是以表格形式展现的。Crawlab 在新版本中允许用户进行一些高级操作，例如搜索、筛选、自定义列等功能。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;搜索&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Crawlab 表格可以点击表头的筛选按钮搜索获取相关项。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6108333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sczKD2TyOPhfyuuKZwdX83rhD83DWlqkaxB6qr2YkTUYvoRNvnYGmdvCuibgiaIMxGHZxiamo3kicLC6FOuJbpX7lw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;crawlab-table-search&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;筛选&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户也可以在 Crawlab 表格中进行筛选操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6108333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sczKD2TyOPhfyuuKZwdX83rhD83DWlqkA4XVuGaUNXFmTbhqb1Bs0NjZqhUXicGNnmamwxOJm1mtyVSap0pwjDQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;crawlab-table-filter&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;自定义列&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户可以在 Crawlab 表格中自定义想要展现或隐藏的列，还可以进行排序。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6108333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sczKD2TyOPhfyuuKZwdX83rhD83DWlqkYS0k9RbW9b1LmW5C5j5n7hX9eiaicneeepPe3Iw8OuKn2QZmckLYJeLw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;crawlab-table-customize-columns&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何安装&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了上面一些新功能介绍，一些读者可能会迫不及待想要开始使用了。虽然 v0.6 还未发布正式版本，但想要尝鲜体验最新的 beta 版本还是很简单的，跟之前版本的 Docker 部署方式是类似的。这里介绍一下本地伪多节点部署（MND），只是做 Demo 用。其他部署方式包括生成环境部署请参考 &lt;span&gt;官方文档&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;。同时，你也可以参考官方文档中的 &lt;span&gt;快速开始&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪多节点部署步骤如下。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;安装 &lt;span&gt;Docker&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 和 &lt;span&gt;Docker-Compose&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建 &lt;code&gt;docker-compose.yml&lt;/code&gt; 并进行配置，内容如下:&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;version:&lt;/span&gt; &lt;span&gt;&#x27;3.3&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;services:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;master:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;crawlabteam/crawlab:latest&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;environment:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;CRAWLAB_NODE_MASTER:&lt;/span&gt; &lt;span&gt;&quot;Y&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;CRAWLAB_NODE_NAME:&lt;/span&gt; &lt;span&gt;&quot;Master Node&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;CRAWLAB_MONGO_HOST:&lt;/span&gt; &lt;span&gt;&quot;mongo&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;GOPROXY:&lt;/span&gt; &lt;span&gt;https://goproxy.cn,direct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;8080:8080&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;depends_on:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;mongo&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;worker01:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;crawlabteam/crawlab:latest&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;environment:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;CRAWLAB_NODE_MASTER:&lt;/span&gt; &lt;span&gt;&quot;N&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;CRAWLAB_NODE_NAME:&lt;/span&gt; &lt;span&gt;&quot;Worker Node 01&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;CRAWLAB_GRPC_ADDRESS:&lt;/span&gt; &lt;span&gt;&quot;master&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;CRAWLAB_FS_FILER_URL:&lt;/span&gt; &lt;span&gt;&quot;http://master:8080/api/filer&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;GOPROXY:&lt;/span&gt; &lt;span&gt;https://goproxy.cn,direct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;depends_on:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;master&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;worker02:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;crawlabteam/crawlab:latest&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;environment:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;CRAWLAB_NODE_MASTER:&lt;/span&gt; &lt;span&gt;&quot;N&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;CRAWLAB_NODE_NAME:&lt;/span&gt; &lt;span&gt;&quot;Worker Node 02&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;CRAWLAB_GRPC_ADDRESS:&lt;/span&gt; &lt;span&gt;&quot;master&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;CRAWLAB_FS_FILER_URL:&lt;/span&gt; &lt;span&gt;&quot;http://master:8080/api/filer&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;GOPROXY:&lt;/span&gt; &lt;span&gt;https://goproxy.cn,direct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;depends_on:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;master&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;mongo:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;mongo:4&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;restart:&lt;/span&gt; &lt;span&gt;always&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;执行 &lt;code&gt;docker-compose pull&lt;/code&gt; 拉取 Docker 镜像&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;执行 &lt;code&gt;docker-compose up -d&lt;/code&gt; 启动 Docker 容器&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动完毕之后，就可以在浏览器中打开 http://localhost:8080 访问 Crawlab 主界面。默认登陆用户名密码为 &lt;code&gt;admin/admin&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文简单介绍了一下 Crawlab v0.6 beta 新版本中的部分新功能和特性。其中，本文图文并茂的介绍了文件上传、文件编辑器、表格高级功能几个非常实用的易用性方面的优化。当然，Crawlab 新版本中的优化和新特性还远不限于&lt;strong&gt;「易用性」&lt;/strong&gt;，在后面的相关文章中，将介绍更多的新特性和功能，包括&lt;strong&gt;「健壮性」&lt;/strong&gt;、&lt;strong&gt;「可扩展性」&lt;/strong&gt;、&lt;strong&gt;「可维护性」&lt;/strong&gt;方面的优化，例如插件框架等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;社区&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您认为 Crawlab 对您的工作或学习有帮助，可以加作者微信 tikazyq1，在技术讨论群与 Crawlab 使用者和开发者进行交流和学习。同时，如果您认为 Crawlab 好用，请您分享给可能会需要爬虫管理平台的朋友，您的分享可能对别人产生重要的价值。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Crawlab: &lt;span&gt;https://github.com/crawlab-team/crawlab&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;atom-material-icons: &lt;span&gt;https://github.com/tikazyq/atom-material-icons&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;官方文档: &lt;span&gt;https://docs-next.crawlab.cn/zh/guide/installation/docker.html&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;快速开始: &lt;span&gt;https://docs-next.crawlab.cn/zh/guide/quick-start.html&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Docker: &lt;span&gt;https://www.docker.com/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;Docker-Compose: &lt;span&gt;https://docs.docker.com/compose/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2e423425712ce5aae243c0843a7bf342</guid>
<title>彻底理解Golang Slice</title>
<link>https://toutiao.io/k/ifttln2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.327445652173913&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/zG4cYveMXGSFibF7EIQ1C91s62r2GC5pUQKsmCgrerzQ95q8aUqtZTGIRkN5vHCg87sJA7xFfzzaprPHUAStUjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;736&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;看完这篇文章，下面这些高频面试题你都会答了吧&lt;/p&gt;&lt;/blockquote&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Go slice的底层实现原理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go array和slice的区别&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go slice深拷贝和浅拷贝&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go slice扩容机制是怎样的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么Go slice是非线程安全的？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;slice是无固定长度的数组，底层结构是一个结构体，包含如下3个属性&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个 &lt;code&gt;slice&lt;/code&gt; 在 golang 中占用 24 个 bytes&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; slice struct {&lt;br/&gt; array unsafe.Pointer &lt;br/&gt; len   int &lt;br/&gt; &lt;span&gt;cap&lt;/span&gt;   int &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;array : 包含了一个指向一个数组的指针，数据实际上存储在这个指针指向的数组上，占用 8 bytes&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;len:  当前 slice 使用到的长度，占用8 bytes&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cap :  当前 slice 的容量，同时也是底层数组 array 的长度， 8 bytes&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4594594594594595&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eTBFF2uBxbBp7gOCYs62ic0KM3RCDE1p6v6sj2OrWBxrfjkfpaDWVLtjR3rVdq38eAXHXwOFLWrs8ibaUpofYp6kvOMOR9YUvx/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;481&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;slice并不是真正意义上的动态数组，而是一个引用类型。slice总是指向一个底层array，slice的声明也可以像 array一样，只是长度可变。&lt;strong&gt;「golang中通过语法糖，使得我们可以像声明array一样，自动创建slice结构体」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;根据&lt;/span&gt;索引位置取切片&lt;span&gt;slice&lt;/span&gt; 元素值时，默认取值范围是（0～&lt;span&gt;len&lt;/span&gt;(&lt;span&gt;slice&lt;/span&gt;)-1），一般输出slice时，通常是指 slice[0:len(slice)-1]，根据下标就可以输出所指向底层数组中的值&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;主要特性&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;引用类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang 有三个常用的高级类型&lt;span&gt;slice&lt;/span&gt;、map、channel, 它们都是&lt;span&gt;引用类型&lt;/span&gt;，当引用类型作为函数参数时，可能会修改原内容数据。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func sliceModify(s []int) {&lt;br/&gt; s[0] = 100&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func sliceAppend(s []int) []int {&lt;br/&gt; s = append(s, 100)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; s&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func sliceAppendPtr(s *[]int) {&lt;br/&gt; *s = append(*s, 100)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 注意：Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。&lt;br/&gt;// 拷贝的内容是非引用类型（int、string、struct等这些），在函数中就无法修改原内容数据；&lt;br/&gt;// 拷贝的内容是引用类型（interface、指针、map、slice、chan等这些），这样就可以修改原内容数据。&lt;br/&gt;func TestSliceFn(t *testing.T) {&lt;br/&gt; // 参数为引用类型slice：外层slice的len/&lt;span&gt;cap&lt;/span&gt;不会改变，指向的底层数组会改变&lt;br/&gt; s := []int{1, 1, 1}&lt;br/&gt; newS := sliceAppend(s)&lt;br/&gt; // 函数内发生了扩容&lt;br/&gt; t.Log(s, len(s), &lt;span&gt;cap&lt;/span&gt;(s))&lt;br/&gt; // [1 1 1] 3 3&lt;br/&gt; t.Log(newS, len(newS), &lt;span&gt;cap&lt;/span&gt;(newS)) &lt;br/&gt; // [1 1 1 100] 4 6&lt;br/&gt;&lt;br/&gt; s2 := make([]int, 0, 5)&lt;br/&gt; newS = sliceAppend(s2)&lt;br/&gt; // 函数内未发生扩容&lt;br/&gt; t.Log(s2, s2[0:5], len(s2), &lt;span&gt;cap&lt;/span&gt;(s2)) &lt;br/&gt; // [] [100 0 0 0 0] 0 5&lt;br/&gt; t.Log(newS, newS[0:5], len(newS), &lt;span&gt;cap&lt;/span&gt;(newS))&lt;br/&gt; // [100] [100 0 0 0 0] 1 5&lt;br/&gt;&lt;br/&gt; // 参数为引用类型slice的指针：外层slice的len/&lt;span&gt;cap&lt;/span&gt;会改变，指向的底层数组会改变&lt;br/&gt; sliceAppendPtr(&amp;amp;s)&lt;br/&gt; t.Log(s, len(s), &lt;span&gt;cap&lt;/span&gt;(s)) &lt;br/&gt;  // [1 1 1 100] 4 6&lt;br/&gt; sliceModify(s)&lt;br/&gt; t.Log(s, len(s), &lt;span&gt;cap&lt;/span&gt;(s)) &lt;br/&gt;  // [100 1 1 100] 4 6&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公众号后台caspar回复【代码】获取本文所有示例代码&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;切片状态&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;切片有3种特殊的状态，分为「零切片」、「空切片」和「nil 切片」&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func TestSliceEmptyOrNil(t *testing.T) {&lt;br/&gt; var slice1 []int           &lt;br/&gt;  // slice1 is nil slice&lt;br/&gt; slice2 := make([]int, 0)    &lt;br/&gt; // slcie2 is empty slice&lt;br/&gt; var slice3 = make([]int, 2) &lt;br/&gt; // slice3 is zero slice&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; slice1 == nil {&lt;br/&gt;  t.Log(&lt;span&gt;&quot;slice1 is nil.&quot;&lt;/span&gt;) &lt;br/&gt;  // 会输出这行&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; slice2 == nil {&lt;br/&gt;  t.Log(&lt;span&gt;&quot;slice2 is nil.&quot;&lt;/span&gt;) &lt;br/&gt;  // 不会输出这行&lt;br/&gt; }&lt;br/&gt; t.Log(slice3) // [0 0]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;非线程安全&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;slice不支持并发读写，所以并不是线程安全的，使用多个 goroutine 对类型为 slice 的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致;  slice在并发执行中不会报错，但是数据会丢失&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt;* 切片非并发安全&lt;br/&gt;* 多次执行，每次得到的结果都不一样&lt;br/&gt;* 可以考虑使用 channel 本身的特性 (阻塞) 来实现安全的并发读写&lt;br/&gt; */&lt;br/&gt;func TestSliceConcurrencySafe(t *testing.T) {&lt;br/&gt; a := make([]int, 0)&lt;br/&gt; var wg sync.WaitGroup&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; 10000; i++ {&lt;br/&gt;  wg.Add(1)&lt;br/&gt;  go func(i int) {&lt;br/&gt;   a = append(a, i)&lt;br/&gt;   wg.Done()&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt; t.Log(len(a)) &lt;br/&gt; // not equal 10000&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想实现slice线程安全，有两种方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方式一：通过加锁实现slice线程安全，适合对性能要求不高的场景。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func TestSliceConcurrencySafeByMutex(t *testing.T) {&lt;br/&gt; var lock sync.Mutex //互斥锁&lt;br/&gt; a := make([]int, 0)&lt;br/&gt; var wg sync.WaitGroup&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; 10000; i++ {&lt;br/&gt;  wg.Add(1)&lt;br/&gt;  go func(i int) {&lt;br/&gt;   defer wg.Done()&lt;br/&gt;   lock.Lock()&lt;br/&gt;   defer lock.Unlock()&lt;br/&gt;   a = append(a, i)&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt; t.Log(len(a)) &lt;br/&gt; // equal 10000&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方式二：通过channel实现slice线程安全，适合对性能要求高的场景。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func TestSliceConcurrencySafeByChanel(t *testing.T) {&lt;br/&gt; buffer := make(chan int)&lt;br/&gt; a := make([]int, 0)&lt;br/&gt; // 消费者&lt;br/&gt; go &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; v := range buffer {&lt;br/&gt;   a = append(a, v)&lt;br/&gt;  }&lt;br/&gt; }()&lt;br/&gt; // 生产者&lt;br/&gt; var wg sync.WaitGroup&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; 10000; i++ {&lt;br/&gt;  wg.Add(1)&lt;br/&gt;  go func(i int) {&lt;br/&gt;   defer wg.Done()&lt;br/&gt;   buffer &amp;lt;- i&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt; t.Log(len(a)) &lt;br/&gt; // equal 10000&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;共享存储空间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多个切片如果共享同一个底层数组，这种情况下，对其中一个切片或者底层数组的更改，会影响到其他切片&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt;* 切片共享存储空间&lt;br/&gt; */&lt;br/&gt;func TestSliceShareMemory(t *testing.T) {&lt;br/&gt; slice1 := []string{&lt;span&gt;&quot;1&quot;&lt;/span&gt;, &lt;span&gt;&quot;2&quot;&lt;/span&gt;, &lt;span&gt;&quot;3&quot;&lt;/span&gt;, &lt;span&gt;&quot;4&quot;&lt;/span&gt;, &lt;span&gt;&quot;5&quot;&lt;/span&gt;, &lt;span&gt;&quot;6&quot;&lt;/span&gt;, &lt;span&gt;&quot;7&quot;&lt;/span&gt;, &lt;span&gt;&quot;8&quot;&lt;/span&gt;, &lt;span&gt;&quot;9&quot;&lt;/span&gt;, &lt;span&gt;&quot;10&quot;&lt;/span&gt;, &lt;span&gt;&quot;11&quot;&lt;/span&gt;, &lt;span&gt;&quot;12&quot;&lt;/span&gt;}&lt;br/&gt; Q2 := slice1[3:6]&lt;br/&gt; t.Log(Q2, len(Q2), &lt;span&gt;cap&lt;/span&gt;(Q2)) &lt;br/&gt; // [4 5 6] 3 9&lt;br/&gt; Q3 := slice1[5:8]&lt;br/&gt; t.Log(Q3, len(Q3), &lt;span&gt;cap&lt;/span&gt;(Q3)) &lt;br/&gt; // [6 7 8] 3 7&lt;br/&gt; Q3[0] = &lt;span&gt;&quot;Unkown&quot;&lt;/span&gt;&lt;br/&gt; t.Log(Q2, Q3) &lt;br/&gt; // [4 5 Unkown] [Unkown 7 8]&lt;br/&gt;&lt;br/&gt; a := []int{1, 2, 3, 4, 5}&lt;br/&gt; shadow := a[1:3]&lt;br/&gt; t.Log(shadow, a)             &lt;br/&gt; // [2 3] [1 2 3 4 5]&lt;br/&gt; shadow = append(shadow, 100) &lt;br/&gt; // 会修改指向数组的所有切片&lt;br/&gt; t.Log(shadow, a)            &lt;br/&gt;  // [2 3 100] [1 2 3 100 5]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常用操作&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;slice 的创建有4种方式，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func TestSliceInit(t *testing.T) {&lt;br/&gt; // 初始化方式1：直接声明&lt;br/&gt; var slice1 []int&lt;br/&gt; t.Log(len(slice1), &lt;span&gt;cap&lt;/span&gt;(slice1)) &lt;br/&gt; // 0, 0&lt;br/&gt; slice1 = append(slice1, 1)&lt;br/&gt; t.Log(len(slice1), &lt;span&gt;cap&lt;/span&gt;(slice1)) &lt;br/&gt; // 1, 1, 24&lt;br/&gt;&lt;br/&gt; // 初始化方式2：使用字面量&lt;br/&gt; slice2 := []int{1, 2, 3, 4}&lt;br/&gt; t.Log(len(slice2), &lt;span&gt;cap&lt;/span&gt;(slice2)) &lt;br/&gt; // 4, 4, 24&lt;br/&gt;&lt;br/&gt; // 初始化方式3：使用make创建slice&lt;br/&gt; slice3 := make([]int, 3, 5)           &lt;br/&gt;  // make([]T, len, &lt;span&gt;cap&lt;/span&gt;) &lt;span&gt;cap&lt;/span&gt;不传则和len一样&lt;br/&gt; t.Log(len(slice3), &lt;span&gt;cap&lt;/span&gt;(slice3))       &lt;br/&gt;  // 3, 5&lt;br/&gt; t.Log(slice3[0], slice3[1], slice3[2]) &lt;br/&gt; // 0, 0, 0&lt;br/&gt; // t.Log(slice3[3], slice3[4]) &lt;br/&gt; // panic: runtime error: index out of range [3] with length 3&lt;br/&gt; slice3 = append(slice3, 1)&lt;br/&gt; t.Log(len(slice3), &lt;span&gt;cap&lt;/span&gt;(slice3)) &lt;br/&gt; // 4, 5, 24&lt;br/&gt;&lt;br/&gt; // 初始化方式4: 从切片或数组“截取”&lt;br/&gt; arr := [100]int{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := range arr {&lt;br/&gt;  arr[i] = i&lt;br/&gt; }&lt;br/&gt; slcie4 := arr[1:3]&lt;br/&gt; slice5 := make([]int, len(slcie4))&lt;br/&gt; copy(slice5, slcie4)&lt;br/&gt; t.Log(len(slcie4), &lt;span&gt;cap&lt;/span&gt;(slcie4), unsafe.Sizeof(slcie4)) &lt;br/&gt; // 2，99，24&lt;br/&gt; t.Log(len(slice5), &lt;span&gt;cap&lt;/span&gt;(slice5), unsafe.Sizeof(slice5)) &lt;br/&gt; // 2，2，24&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;增加&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func TestSliceGrowing(t *testing.T) {&lt;br/&gt; slice1 := []int{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; 10; i++ {&lt;br/&gt;  slice1 = append(slice1, i)&lt;br/&gt;  t.Log(len(slice1), &lt;span&gt;cap&lt;/span&gt;(slice1))&lt;br/&gt; }&lt;br/&gt; // 1 1&lt;br/&gt; // 2 2&lt;br/&gt; // 3 4&lt;br/&gt; // 4 4&lt;br/&gt; // 5 8&lt;br/&gt; // 6 8&lt;br/&gt; // 7 8&lt;br/&gt; // 8 8&lt;br/&gt; // 9 16&lt;br/&gt; // 10 16&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;删除&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func TestSliceDelete(t *testing.T) {&lt;br/&gt; slice1 := []int{1, 2, 3, 4, 5}&lt;br/&gt; var x int&lt;br/&gt; // 删除最后一个元素&lt;br/&gt; x, slice1 = slice1[len(slice1)-1], slice1[:len(slice1)-1] &lt;br/&gt; t.Log(x, slice1, len(slice1), &lt;span&gt;cap&lt;/span&gt;(slice1)) &lt;br/&gt; // 5 [1 2 3 4] 4 5&lt;br/&gt;&lt;br/&gt; // 删除第2个元素 &lt;br/&gt; slice1 = append(slice1[:2], slice1[3:]...) &lt;br/&gt; t.Log(slice1, len(slice1), &lt;span&gt;cap&lt;/span&gt;(slice1))    &lt;br/&gt; // [1 2 4] 3 5&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;查找&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;v := s[i] // 下标访问&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;修改&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;s[i] = 5 // 下标修改&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;截取&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt;* 切片截取&lt;br/&gt; */&lt;br/&gt;func TestSliceSubstr(t *testing.T) {&lt;br/&gt; slice1 := []int{1, 2, 3, 4, 5}&lt;br/&gt; slice2 := slice1[:]&lt;br/&gt; // 截取 slice[left:right:max]&lt;br/&gt; // left：省略默认0&lt;br/&gt; // right：省略默认len(slice1)&lt;br/&gt; // max: 省略默认len(slice1)&lt;br/&gt; // len = right-left+1&lt;br/&gt; // &lt;span&gt;cap&lt;/span&gt; = max-left&lt;br/&gt; t.Log(slice2, len(slice2), &lt;span&gt;cap&lt;/span&gt;(slice2)) &lt;br/&gt; // 1 2 3 4 5] 5 5&lt;br/&gt; slice3 := slice1[1:]&lt;br/&gt; t.Log(slice3, len(slice3), &lt;span&gt;cap&lt;/span&gt;(slice3)) &lt;br/&gt; // [2 3 4 5] 4 4&lt;br/&gt; slice4 := slice1[:2]&lt;br/&gt; t.Log(slice4, len(slice4), &lt;span&gt;cap&lt;/span&gt;(slice4)) &lt;br/&gt; // [1 2] 2 5&lt;br/&gt; slice5 := slice1[1:2]&lt;br/&gt; t.Log(slice5, len(slice5), &lt;span&gt;cap&lt;/span&gt;(slice5)) &lt;br/&gt; // [2] 1 4&lt;br/&gt; slice6 := slice1[:2:5]&lt;br/&gt; t.Log(slice6, len(slice6), &lt;span&gt;cap&lt;/span&gt;(slice6)) &lt;br/&gt; // [1 2] 2 5&lt;br/&gt; slice7 := slice1[1:2:2]&lt;br/&gt; t.Log(slice7, len(slice7), &lt;span&gt;cap&lt;/span&gt;(slice7)) &lt;br/&gt; // [2] 1 1&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;遍历&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;切片有3种遍历方式&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt;* 切片遍历&lt;br/&gt; */&lt;br/&gt;func TestSliceTravel(t *testing.T) {&lt;br/&gt; slice1 := []int{1, 2, 3, 4}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; len(slice1); i++ {&lt;br/&gt;  t.Log(slice1[i])&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; idx, e := range slice1 {&lt;br/&gt;  t.Log(idx, e)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, e := range slice1 {&lt;br/&gt;  t.Log(e)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反转&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func TestSliceReverse(t *testing.T) {&lt;br/&gt; a := []int{1, 2, 3, 4, 5}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; left, right := 0, len(a)-1; left &amp;lt; right; left, right = left+1, right-1 {&lt;br/&gt;  a[left], a[right] = a[right], a[left]&lt;br/&gt; }&lt;br/&gt; t.Log(a, len(a), &lt;span&gt;cap&lt;/span&gt;(a)) &lt;br/&gt; // [5 4 3 2 1] 5 5&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;拷贝&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发中会经常的把一个变量复制给另一个变量，那么这个过程，可能是深浅拷贝，那么今天帮大家区分一下这两个拷贝的区别和具体的区别&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;深拷贝&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拷贝的是数据本身，创造一个样的新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值。既然内存地址不同，释放内存地址时，可分别释放&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值类型的数据，默认赋值操作都是深拷贝，Array、Int、String、Struct、Float，Bool。引用类型的数据如果想实现深拷贝，需要通过辅助函数完成&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如golang深拷贝copy 方法会把源切片值(即 from Slice )中的元素复制到目标切片(即 to Slice )中，并返回被复制的元素个数，copy 的两个类型必须一致。copy 方法最终的&lt;strong&gt;「复制结果取决于较短的那个切片」&lt;/strong&gt;，当较短的切片复制完成，整个复制过程就全部完成了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt;* 深拷贝&lt;br/&gt; */&lt;br/&gt;func TestSliceDeepCopy(t *testing.T) {&lt;br/&gt; slice1 := []int{1, 2, 3, 4, 5}&lt;br/&gt; slice2 := make([]int, 5, 5)&lt;br/&gt; // 深拷贝&lt;br/&gt; copy(slice2, slice1)                   &lt;br/&gt; t.Log(slice1, len(slice1), &lt;span&gt;cap&lt;/span&gt;(slice1)) &lt;br/&gt; // [1 2 3 4 5] 5 5&lt;br/&gt; t.Log(slice2, len(slice2), &lt;span&gt;cap&lt;/span&gt;(slice2)) &lt;br/&gt; // [1 2 3 4 5] 5 5&lt;br/&gt; slice1[1] = 100                        &lt;br/&gt; t.Log(slice1, len(slice1), &lt;span&gt;cap&lt;/span&gt;(slice1)) &lt;br/&gt; // [1 100 3 4 5] 5 5&lt;br/&gt; t.Log(slice2, len(slice2), &lt;span&gt;cap&lt;/span&gt;(slice2)) &lt;br/&gt; // [1 2 3 4 5] 5 5&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;浅拷贝&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化。释放内存地址时，同时释放内存地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用类型的数据，默认全部都是浅拷贝，Slice、Map等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目的切片和源切片指向同一个底层数组，任何一个数组元素改变，都会同时影响两个数组。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt;* 浅拷贝&lt;br/&gt; */&lt;br/&gt;func TestSliceShadowCopy(t *testing.T) {&lt;br/&gt; slice1 := []int{1, 2, 3, 4, 5}&lt;br/&gt; // 浅拷贝（注意 := 对于引用类型是浅拷贝，对于值类型是深拷贝）&lt;br/&gt; slice2 := slice1     &lt;br/&gt; t.Logf(&lt;span&gt;&quot;%p&quot;&lt;/span&gt;, slice1) // 0xc00001c120&lt;br/&gt; t.Logf(&lt;span&gt;&quot;%p&quot;&lt;/span&gt;, slice2) // 0xc00001c120&lt;br/&gt; // 同时改变两个数组，这时就是浅拷贝，未扩容时，修改 slice1 的元素之后，slice2 的元素也会跟着修改&lt;br/&gt; slice1[0] = 10&lt;br/&gt; t.Log(slice1, len(slice1), &lt;span&gt;cap&lt;/span&gt;(slice1)) &lt;br/&gt; // [10 2 3 4 5] 5 5&lt;br/&gt; t.Log(slice2, len(slice2), &lt;span&gt;cap&lt;/span&gt;(slice2)) &lt;br/&gt; // [10 2 3 4 5] 5 5&lt;br/&gt; // 注意下：扩容后，slice1和slice2不再指向同一个数组，修改 slice1 的元素之后，slice2 的元素不会被修改了&lt;br/&gt; slice1 = append(slice1, 5, 6, 7, 8)&lt;br/&gt; slice1[0] = 11   &lt;br/&gt;  // 这里可以发现，slice1[0] 被修改为了 11, slice1[0] 还是10&lt;br/&gt; t.Log(slice1, len(slice1), &lt;span&gt;cap&lt;/span&gt;(slice1)) &lt;br/&gt; // [11 2 3 4 5 5 6 7 8] 9 10&lt;br/&gt; t.Log(slice2, len(slice2), &lt;span&gt;cap&lt;/span&gt;(slice2))&lt;br/&gt;  // [10 2 3 4 5] 5 5&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「在复制 slice 的时候，slice 中数组的指针也被复制了，在触发扩容逻辑之前，两个 slice 指向的是相同的数组，触发扩容逻辑之后指向的就是不同的数组了」&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;扩容&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩容会发生在slice append的时候，当slice的cap不足以容纳新元素，就会进行扩容&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码：https://github.com/golang/go/blob/master/src/runtime/slice.go&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func growslice(et *_type, old slice, &lt;span&gt;cap&lt;/span&gt; int) slice {&lt;br/&gt;   // 省略一些判断...&lt;br/&gt;    newcap := old.cap&lt;br/&gt;    doublecap := newcap + newcap&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;cap&lt;/span&gt; &amp;gt; doublecap {&lt;br/&gt;        newcap = &lt;span&gt;cap&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; old.len &amp;lt; 1024 {&lt;br/&gt;            newcap = doublecap&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            // Check 0 &amp;lt; newcap to detect overflow&lt;br/&gt;            // and prevent an infinite loop.&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; 0 &amp;lt; newcap &amp;amp;&amp;amp; newcap &amp;lt; &lt;span&gt;cap&lt;/span&gt; {&lt;br/&gt;                newcap += newcap / 4&lt;br/&gt;            }&lt;br/&gt;            // Set newcap to the requested &lt;span&gt;cap&lt;/span&gt; when&lt;br/&gt;            // the newcap calculation overflowed.&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; newcap &amp;lt;= 0 {&lt;br/&gt;                newcap = &lt;span&gt;cap&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    // 省略一些后续...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果新申请容量比两倍原有容量大，那么扩容后容量大小 等于 新申请容量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果原有 slice 长度小于 1024， 那么每次就扩容为原来的 2 倍&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果原 slice 大于等于 1024， 那么每次扩容就扩为原来的 1.25 倍&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内存泄露&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于slice的底层是数组，很可能数组很大，但slice所取的元素数量却很小，这就导致数组占用的绝大多数空间是被浪费的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Case1:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如下面的代码，如果传入的&lt;code&gt;slice b&lt;/code&gt;是很大的，然后引用很小部分给全局量&lt;code&gt;a&lt;/code&gt;，那么&lt;code&gt;b&lt;/code&gt;未被引用的部分（下标1之后的数据）就不会被释放，造成了所谓的内存泄漏。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var a []int&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;test&lt;/span&gt;(b []int) {&lt;br/&gt; a = b[:1] // 和b共用一个底层数组&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么只要全局量&lt;code&gt;a&lt;/code&gt;在，&lt;code&gt;b&lt;/code&gt;就不会被回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何避免？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这样的场景下注意：如果我们只用到一个slice的一小部分，那么底层的整个数组也将继续保存在内存当中。当这个底层数组很大，或者这样的场景很多时，可能会造成内存急剧增加，造成崩溃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在这样的场景下，我们可以将需要的分片复制到一个新的slice中去，减少内存的占用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var a []int&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;test&lt;/span&gt;(b []int) {&lt;br/&gt; a = make([]int, 1)&lt;br/&gt; copy(a, b[:0])&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Case2:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如下面的代码，返回的slice是很小一部分，这样该函数退出后，原来那个体积较大的底层数组也无法被回收&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func test2() []int{&lt;br/&gt; s = make([]int, 0, 10000)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; 10000; i++ {&lt;br/&gt;  s = append(s, p)&lt;br/&gt; }&lt;br/&gt; s2 := s[100:102]&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; s2&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何避免？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将需要的分片复制到一个新的slice中去，减少内存的占用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func test2() []int{&lt;br/&gt; s = make([]int, 0, 10000)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; 10000; i++ {&lt;br/&gt;   // 一些计算...&lt;br/&gt;  s = append(s, p)&lt;br/&gt; }&lt;br/&gt; s2 := make([]int, 2)&lt;br/&gt; copy(s2, s[100:102])&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; s2&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;切片与数组对比&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组是一个固定长度的，初始化时候必须要指定长度，不指定长度的话就是切片了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组是值类型，将一个数组赋值给另一个数组时，传递的是一份深拷贝，赋值和函数传参操作都会复制整个数组数据，会占用额外的内存；切片是引用类型，将一个切片赋值给另一个切片时，传递的是一份浅拷贝，赋值和函数传参操作只会复制len和cap，但底层共用同一个数组，不会占用额外的内存。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//a是一个数组，注意数组是一个固定长度的，初始化时候必须要指定长度，不指定长度的话就是切片了&lt;br/&gt;a := [3]int{1, 2, 3}&lt;br/&gt;//b是数组，是a的一份深拷贝&lt;br/&gt;b := a&lt;br/&gt;//c是切片，是引用类型，底层数组是a&lt;br/&gt;c := a[:]&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; len(a); i++ {&lt;br/&gt; a[i] = a[i] + 1&lt;br/&gt;}&lt;br/&gt;//改变a的值后，b是a的拷贝，b不变，c是引用，c的值改变&lt;br/&gt;fmt.Println(a) &lt;br/&gt;//[2,3,4]&lt;br/&gt;fmt.Println(b) &lt;br/&gt;//[1 2 3]&lt;br/&gt;fmt.Println(c) &lt;br/&gt;//[2,3,4]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//a是一个切片，不指定长度的话就是切片了&lt;br/&gt;a := []int{1, 2, 3}&lt;br/&gt;//b是切片，是a的一份拷贝&lt;br/&gt;b := a&lt;br/&gt;//c是切片，是引用类型&lt;br/&gt;c := a[:]&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; len(a); i++ {&lt;br/&gt; a[i] = a[i] + 1&lt;br/&gt;}&lt;br/&gt;//改变a的值后，b是a的浅拷贝，b的值改派，c是引用，c的值改变&lt;br/&gt;fmt.Println(a) &lt;br/&gt;//[2,3,4]&lt;br/&gt;fmt.Println(b) &lt;br/&gt;//[2,3,4]&lt;br/&gt;fmt.Println(c) &lt;br/&gt;//[2,3,4]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建切片时可根据实际需要预分配容量，尽量避免追加过程中进行扩容操作，有利于提升性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 append() 向切片追加元素时有可能触发扩容，扩容后将会生成新的切片&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 len()、cap()计算切片长度、容量时，时间复杂度均为 O(1)，不需要遍历切片&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;切片是非线程安全的，如果要实现线程安全，可以加锁或者使用Channel&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大数组作为函数参数时，会复制整个数组数据，消耗过多内存，建议使用切片或者指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;切片作为函数参数时，可以改变切片指向的数组，不能改变切片本身len和cap；想要改变切片本身，可以将改变后的切片返回 或者 将&lt;strong&gt;「切片指针」&lt;/strong&gt;作为函数参数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果只用到大slice的一小部分，建议将需要的分片复制到一个新的slice中去，减少内存的占用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f925071ad192a45d3fe61d66352f1452</guid>
<title>124 python|第二部分：面向对象（ 1 ）类和对象</title>
<link>https://toutiao.io/k/4ct7cgk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言：第一部分「python核心」告一段落，接下来将花三篇文章对「&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;面向对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;」进行梳理。今天的内容主要内容有：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01 面向过程&amp;amp;面向&lt;strong&gt;&lt;span&gt;对象&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    1.1 概述&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    1.2 类和对象&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02 类和对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    2.1 语法&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    2.2 实例变量&amp;amp;实例方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    2.3 跨类调用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    2.4 类变量&amp;amp;类方法  （明天继续）&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    2.5 静态方法&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03 内存分配&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;                        &lt;br mpa-from-tpl=&quot;t&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;30&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZcWNHRSIjJGs9bvuzwV9GxaCvA4ic5qN3EhBUUSmSLdmc9YTk9M815IRRFboPVT3Klpyd0bCVEdIsgn7p6ue1Zg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;01 面向过程和面向对象&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.1 概述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.027777777777777776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uyZsSl2gvXUO54LuJbh78tMMYyiav6tM98N9ouoQQTft4O3IWh4GbXmy4DLUYM3ECeaqyg9U36gDRH7rNrjqlvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;把大象关冰箱需要几步？以下是两种不同的思路。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;面向过程（手动挡）：&lt;/strong&gt;打开冰箱门→把大象装进去→关上冰箱门&lt;/p&gt;&lt;p&gt;&lt;strong&gt;面向对象（自动挡）：&lt;/strong&gt;滴！门开了&lt;span&gt;→&lt;/span&gt;滴！&lt;span&gt;大象进去&lt;/span&gt;了&lt;span&gt;→&lt;/span&gt;滴！门关了&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果让你选择其中一种方式，你会选择第几种呢？看起来自动挡很智能哈，其实活也没少干，前期少不了花时间花功夫研究怎么实现&lt;span&gt;这些功能&lt;/span&gt;。但是我们宁可前期多投入点，以方便后期的随时调用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.16634429400386846&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uyZsSl2gvXWMq8icxDAoG8Vm4w2QXB1YianHleE1ft447YicBd6xXWVtUh3KZprLNy97B3Suu7GSW0M1ATKm9hJjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1034&quot;/&gt;&lt;/p&gt;&lt;p&gt;    &lt;strong&gt; 图源：彪彪_&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面向过程&lt;/span&gt; Procedure Oriented Programming （&lt;span&gt;POP&lt;/span&gt;）&lt;span&gt;是一种&lt;strong&gt;以&lt;/strong&gt;&lt;strong&gt;过程和任务为中心&lt;/strong&gt;的编程思想&lt;/span&gt;。通过一系列具体的步骤操作相关的数据，实现软件功能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面向对象&lt;/span&gt; Object Oriented Programming（&lt;span&gt;OOP&lt;/span&gt;）&lt;span&gt;是一种&lt;strong&gt;以对象为基础&lt;/strong&gt;的编程思想&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;把数据和操作封装到对象中，通过对象一系列的交互，实现软件功能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）举例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;出去旅游，分别以两种方式来示范：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;面向过程&lt;/span&gt;&lt;/strong&gt;：做旅游规划—订景点门票—订车票—订酒店&lt;/p&gt;&lt;p&gt;（分析出解决问题的步骤，然后逐步实现）&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;面向对象&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;找旅行社做这些事  （找出解决问题的人，来分配这些事）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）优缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;table interlaced=&quot;enabled&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;strong&gt;优点&lt;br/&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;strong&gt;缺点&lt;br/&gt;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;面向过程&lt;br/&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;p&gt;所有环节自己掌控&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;工作量大&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;面向对象&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;（1）思想层面&lt;/p&gt;&lt;p&gt;可以模拟现实场景，更接近人类思维；有利于梳理归纳，分析解决问题&lt;/p&gt;&lt;p&gt;（2）技术层面&lt;/p&gt;&lt;p&gt;高复用：对代码封装，提高开发效率&lt;/p&gt;&lt;p&gt;高扩展：增加新的功能，不修改原来的代码&lt;/p&gt;&lt;p&gt;高维护：代码的可读性好，逻辑清晰，结构规整&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;有点难？&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.2 类和对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.027777777777777776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uyZsSl2gvXUO54LuJbh78tMMYyiav6tM9jn6yFFic11B0vQhibEicFyiariaZf5bK51KJpPAgasmPLgL01e3Ulr4ibTzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;（1）&lt;strong&gt;类&lt;/strong&gt;：一个抽象的概念，即生活中的类别。（比如狗类，狗是模糊或者抽象的一个类别，我们无法说出狗是什么颜色，大小如何）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（2）&lt;strong&gt;对象&lt;/strong&gt;：类的具体实例，即归属于某个类别的个体。（比如哈士奇是狗的一个品种，我们就把狗给具体化了）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（3）&lt;strong&gt;类是创建对象的模板&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3950892857142857&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uyZsSl2gvXWMq8icxDAoG8Vm4w2QXB1YiataEzpqztEdHTXYibXlUMoIptFNLqnQ6W5XkQoiahFUXia60HbfBd28ZbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;448&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）语法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（1）定义类&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; 类名:  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot; 文档说明&quot;&lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;: &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;self&lt;/span&gt;.实例变量 = 参数 &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    方法成员 &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;a.命名规则&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;类名：&lt;/strong&gt;大驼峰命名法，即每个单词的首字母都大写，如MyDog；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;方法名，变量名，参数，文件名：&lt;/strong&gt;单词全小写，并且多个单词用下划线连接，如my_dog。(文件名单词之间的下划线可以省略，如mydog)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;b._&lt;/span&gt;&lt;span class=&quot;code-snippet__title&quot;&gt;_init__(self)&lt;/span&gt; 是构造方法（&lt;span&gt;构造函数&lt;/span&gt;），可以省略&lt;/p&gt;&lt;p&gt;在创建对象时会自动调用，self会自动生成&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;c.self&lt;/span&gt;绑定的是当前对象的实例，也可以换成其他名称。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2）实例化对象（创建对象）&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;变量 = 类名（参数）&lt;strong/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;a.&lt;/span&gt;&lt;span&gt;变量存储的是实例对象的内存地址&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7046843177189409&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uyZsSl2gvXVSJVMUN9UleteYx6ayxPE5wrPIZKUicSwyfBdvpONkqRPU6ePGRqTb9Hos7jOMRZXZn36AKNmkcZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;982&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;创建类和对象举例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6852731591448931&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uyZsSl2gvXVSJVMUN9UleteYx6ayxPE5mEYGcXOuccwDLPDzof3gvVkLwia1JSIZvgdVZUC6squZ7llFaC7fCOA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;842&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;类和对象内存图示例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（3）面向过程和面向对象的写法示例&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Pig&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self, pid, birth, name, height)&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.pid = pid &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.birth = birth &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.name = name &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.height = height &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dict_pig = {&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;pid&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;104&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;birth&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1994&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;麦兜&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;height&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;0.5&lt;/span&gt;} &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(dict_pig[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;name&quot;&lt;/span&gt;]) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(dict_pig) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pig = Pig(&lt;span class=&quot;code-snippet__number&quot;&gt;104&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;1994&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;麦兜&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0.5&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(pig.name) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(pig) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(pig.__dict__) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）实例变量&amp;amp;实例方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（1）实例变量和实例方法的作用及调用方法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5548037889039242&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uyZsSl2gvXVSJVMUN9UleteYx6ayxPE52B2dRNpGOkb97KafKhEUFM8lzDiciadSO1OXPnj5iaxq6OQLese9CIGmg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;739&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Dog&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&quot;狗类&quot;&quot;&quot;&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self,name,height,weight)&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.name = name  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.height =height &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.weight = weight &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;eat&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.weight +=&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        print(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;饿了&#x27;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;husky = Dog(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;二哈&#x27;&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;0.8&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;60&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;husky.name = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;小哈&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(husky.weight)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;husky.eat() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(husky.weight)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(husky.__dict__) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）跨类调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;在python中想要实现在A类中调用B类方法称为跨类调用。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;以下通过三种语法，表达了不同场景下对象的不同操作方式：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&quot;  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;放牛娃放牛,牛跑了（3种不同语义下的用法）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&quot;&quot;&quot;&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;People&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self,name)&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.name = name &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;herd&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        print(self.name, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;放牧&#x27;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        cow = Animal() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        cow.run() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Animal&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        print(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;牛跑了&#x27;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cowboy = People(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;放牛娃&#x27;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cowboy.herd() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;xm = People(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;小明&#x27;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;xm.herd() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;People&lt;/span&gt;:&lt;/span&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self,name)&lt;/span&gt;:&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.name = name  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.cow = Animal()  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;herd&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self,place)&lt;/span&gt;:&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        print(self.name,place, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;放牧&#x27;&lt;/span&gt;)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.cow.run()   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Animal&lt;/span&gt;:&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        print(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;牛跑了&#x27;&lt;/span&gt;)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cowboy = People(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;放牛娃&#x27;&lt;/span&gt;)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cowboy.herd(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;在山上&#x27;&lt;/span&gt;)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;People&lt;/span&gt;:&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self,name)&lt;/span&gt;:&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.name = name  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;herd&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self,place,object)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        print(self.name,place, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;放牧&#x27;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        object.run() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Animal&lt;/span&gt;:&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        print(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;牛跑了&#x27;&lt;/span&gt;)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cowboy = People(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;放牛娃&#x27;&lt;/span&gt;)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;a = Animal() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cowboy.herd(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;在草地上&#x27;&lt;/span&gt;,a) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;                                                                                                      &lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U9kKudHzsK3W5c0NRAdWnuRVSW6XQyGvg6OGgAx0tyceatfwtlSTTwQN8GvP155mZttbHucmWyonfEPlOiamy9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;350&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0859375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JrRY60XUiczCB0aAKusfQXhclcbPLWbWc64icUBDfxMM47JVqSw3IOFHpry1wBXo1ryBDcXMIAWicGppjb6JJ3RCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;256&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;span&gt;面向对象编程（Python版详解）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://blog.csdn.net/weixin_45393094/article/details/105273070&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2] python面向对象详细介绍(带图)—详细得让你惊叹&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://blog.csdn.net/cuichongxin/article/details/106920686&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[3] &lt;/span&gt;用简单的例子解释什么是面向对象&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://blog.csdn.net/qq_41885871/article/details/86610301&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[4] &lt;/span&gt;彻底搞懂Python数据成员和成员方法&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://blog.csdn.net/edward_zcl/article/details/105661470&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;花样早餐展位&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uyZsSl2gvXVSJVMUN9UleteYx6ayxPE5utPdEnSsTicYuES0z4y3IRqgE3Cmf0PUicTbgcFJbrxDTMmBjdvcrib8Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fb590f864f38901698af64ff8a26c9b0</guid>
<title>Go 泛型简明入门教程</title>
<link>https://toutiao.io/k/nvynuss</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 polarisxu。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有泛型的 Go 版本 1.18 已经发布了 Beta1 版本，之前陆陆续续介绍了泛型，但可能有些人还是对 Go 泛型没有完整的了解，因此有这份入门教程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;01 准备工作&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始学习泛型之前，你应该安装 Go1.18 Beta1 或之后发布的版本，建议&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxNzY0NDE3NA==&amp;amp;mid=2247485026&amp;amp;idx=1&amp;amp;sn=dcc047b6afe0e4e4daf37f8c9e499fce&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;使用 goup 等版本管理工具&lt;/a&gt;，当然也可以直接通过 playground 来验证：https://go.dev/play/?v=gotip。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，本教程基于本地安装 Go1.18 Beta1 为例进行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ goup install 1.18beta1&lt;br/&gt;Downloaded   0.0% (    16384 / 143162528 bytes) ...&lt;br/&gt;Downloaded   5.9% (  8404928 / 143162528 bytes) ...&lt;br/&gt;Downloaded  14.1% ( 20234096 / 143162528 bytes) ...&lt;br/&gt;Downloaded  22.3% ( 31981328 / 143162528 bytes) ...&lt;br/&gt;Downloaded  30.5% ( 43695808 / 143162528 bytes) ...&lt;br/&gt;Downloaded  38.7% ( 55443040 / 143162528 bytes) ...&lt;br/&gt;Downloaded  45.7% ( 65486352 / 143162528 bytes) ...&lt;br/&gt;Downloaded  53.9% ( 77200832 / 143162528 bytes) ...&lt;br/&gt;Downloaded  62.1% ( 88866144 / 143162528 bytes) ...&lt;br/&gt;Downloaded  70.3% (100580624 / 143162528 bytes) ...&lt;br/&gt;Downloaded  78.4% (112295088 / 143162528 bytes) ...&lt;br/&gt;Downloaded  85.5% (122371168 / 143162528 bytes) ...&lt;br/&gt;Downloaded  93.7% (134102032 / 143162528 bytes) ...&lt;br/&gt;Downloaded 100.0% (143162528 / 143162528 bytes)&lt;br/&gt;INFO[0013] Unpacking /Users/xuxinhua/.go/go1.18beta1/go1.18beta1.darwin-amd64.tar.gz ...&lt;br/&gt;INFO[0020] Success: go1.18beta1 downloaded &lt;span&gt;in&lt;/span&gt; /Users/xuxinhua/.go/go1.18beta1&lt;br/&gt;INFO[0020] Default Go is &lt;span&gt;set&lt;/span&gt; to &lt;span&gt;&#x27;go1.18beta1&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证是否安装成功：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ go version&lt;br/&gt;go version go1.18beta1 darwin/amd64&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;02 创建项目&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;切换到 &lt;code&gt;$HOME&lt;/code&gt; 目录，Linux/Mac 执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ &lt;span&gt;cd&lt;/span&gt; ~&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Windows 下执行（在 C 盘，基于 cmd 或 PowerShell）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;C:\&amp;gt; &lt;span&gt;cd&lt;/span&gt; %HOMEPATH%&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后创建目录并初始化模块：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ mkdir generics&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; generics&lt;br/&gt;$ go mod init github.com/polaris1119/generics&lt;br/&gt;go: creating new go.mod: module github.com/polaris1119/generics&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;其中的模块前缀可以替换为你喜欢的名字。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;03 添加非泛型函数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面以 map 为例，先看非泛型如何处理，泛型又是如何处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如有两个 map，分别是 map[string]int 和 map[string]float64，编写函数将 map 中的 value 值相加，返回结果。因为有两个类型，因此编写两个函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;SumInts&lt;/span&gt;&lt;span&gt;(m &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; s &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, v := &lt;span&gt;range&lt;/span&gt; m {&lt;br/&gt;        s += v&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; s&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;SumFloats&lt;/span&gt;&lt;span&gt;(m &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;float64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;float64&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; s &lt;span&gt;float64&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, v := &lt;span&gt;range&lt;/span&gt; m {&lt;br/&gt;        s += v&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; s&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 main 函数中初始化两个 map 并调用上面的函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    ints := &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;&quot;first&quot;&lt;/span&gt;:  &lt;span&gt;34&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;second&quot;&lt;/span&gt;: &lt;span&gt;12&lt;/span&gt;,&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    floats := &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;float64&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;&quot;first&quot;&lt;/span&gt;:  &lt;span&gt;35.98&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;second&quot;&lt;/span&gt;: &lt;span&gt;26.99&lt;/span&gt;,&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;非泛型计算结果，SumInts: %v, SumFloats: %v\n&quot;&lt;/span&gt;, SumInts(ints), SumFloats(floats))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行后，输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ go run main.go&lt;br/&gt;非泛型计算结果，SumInts: 46, SumFloats: 62.97&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然得到了想要的结果，但 SumInts 和 SumFloats 的逻辑差不多。如果将来有其他类型，我们必须增加额外的函数，代码逻辑也类似。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了泛型，只需要一个函数就可以实现以上两个函数的功能，而且可以方便扩展为支持其他相关类型，比如 map[iint]float64 等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;03 泛型处理多类型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要支持任一类型的值，该函数将需要一种方法来声明它支持的类型。同时，调用者需要一种方法来指定它是使用整数 map 还是浮点数 map 进行调用，即调用时指定实际参数的类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了支持这一点，需要编写一个函数，除了它的普通函数参数外，还需要声明类型参数。这些类型参数使函数具有通用性，使其能够处理不同类型的参数。这样，你可以使用类型参数和普通函数参数调用该通用函数，即泛型函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个类型参数都有一个类型约束，作为类型参数的一种元类型。每个类型约束指定调用代码可以用于相应类型参数的允许类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然类型参数的约束通常表示一组类型，但在编译时类型参数代表单个类型——调用代码作为类型参数提供的类型。如果类型参数的约束不允许该调用者指定的类型，则代码将无法编译。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请记住，类型参数必须支持泛型代码对其执行的所有操作。例如，函数对参数执行加减运算，而 string 是不支持的，因此约束中不能包含 string 类型，否则代码将无法编译。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没看懂，就看具体代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;SumIntsOrFloats&lt;/span&gt;[&lt;span&gt;K&lt;/span&gt; &lt;span&gt;comparable&lt;/span&gt;, &lt;span&gt;V&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; | &lt;span&gt;float64&lt;/span&gt;]&lt;span&gt;(m &lt;span&gt;map&lt;/span&gt;[K]V)&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; s V&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, v := &lt;span&gt;range&lt;/span&gt; m {&lt;br/&gt;        s += v&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; s&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数 SumIntsOrFloats 声明了两种参数：类型参数和普通函数参数。其中类型参数放在 &lt;code&gt;[]&lt;/code&gt; 中，普通参数依然放在 &lt;code&gt;()&lt;/code&gt; 中。（别问类型参数为什么不用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;，官方给了解释：https://groups.google.com/g/golang-nuts/c/7t-Q2vt60J8/m/65D5xBDvBgAJ）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该函数的类型参数是：&lt;code&gt;K comparable, V int | float64&lt;/code&gt;，其中 K、V 的名字不重要，分别表示某种类型，comparable 和 &lt;code&gt;int | float64&lt;/code&gt; 是 K、V 类型的约束，即调用该方法时，K、V 允许的类型。comparable 是语言预定义的约束，官方的解释如下：https://pkg.go.dev/builtin@master#comparable&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;comparable is an interface that is implemented by all comparable types (booleans, numbers, strings, pointers, channels, interfaces, arrays of comparable types, structs whose fields are all comparable types). The comparable interface may only be used as a type parameter constraint, not as the type of a variable.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即表示所有可比较类型，也就是说，K 可以是任意可比较类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 V 的类型约束 &lt;code&gt;int | float64&lt;/code&gt; 表示只允许是 int 或 float64，其他类型编译会报错。关于类型约束更多内容，可以参考我之前写的文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxNzY0NDE3NA==&amp;amp;mid=2247488768&amp;amp;idx=1&amp;amp;sn=fff49e608b40b25493543e08034aca63&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Go1.18 类型约束那些事&lt;/a&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再看该函数的普通参数：m map[K]V，这表明，m 是一个 map，它的 key 类型是 K，value 类型是 V。很显然，这两个是该函数「类型参数」定义的类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型函数有了，该如何调用呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 main 中增加如下调用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fmt.Printf(&lt;span&gt;&quot;泛型计算结果，Ints 结果: Floats 结果: %v\n&quot;&lt;/span&gt;, SumIntsOrFloats[&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;](ints), SumIntsOrFloats[&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;float64&lt;/span&gt;](floats))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同一个函数，支持 map[string]int 和 map[string]float64。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，我们在调用函数和声明函数类型，用 &lt;code&gt;[]&lt;/code&gt; 指定了具体的类型，比如 &lt;code&gt;SumIntsOrFloats[string, int](ints)&lt;/code&gt;，即调用时普通参数是什么类型通过 &lt;code&gt;[]&lt;/code&gt; 指定。很显然，这很繁琐，实际上 Go 会进行类型推断，即编译器会通过普通参数的类型推导出「类型参数」。不过，跟 Go 中其他类型自动推导类似，有些情况是无法自动推导的，这时候必须手动指定实际的类型参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，上面的调用代码也可以简写为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fmt.Printf(&lt;span&gt;&quot;泛型计算结果，Ints 结果: Floats 结果: %v\n&quot;&lt;/span&gt;, SumIntsOrFloats(ints), SumIntsOrFloats(floats))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行后，得到如下结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ go run main.go&lt;br/&gt;非泛型计算结果，SumInts: 46, SumFloats: 62.97&lt;br/&gt;泛型计算结果，Ints 结果: 46, Floats 结果: 62.97&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;04 声明类型约束&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文已经大概解释了类型约束，针对本文例子，解释下类型约束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面没有将 &lt;code&gt;int | float64&lt;/code&gt; 定义为一个命名约束，相当于约束字面量（或联合类型）。一般有两种场景会单独声明类型约束：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;约束太长，比如有很多类型，直接写在函数中，会严重影响可读性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方便类型约束重用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将上面 V 的约束定义为单独的类型约束：（实际是接口，但不能作为单独类型使用）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Number &lt;span&gt;interface&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; | &lt;span&gt;float64&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于此定义另外一个函数 SumNumbers：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;SumNumbers&lt;/span&gt;[&lt;span&gt;K&lt;/span&gt; &lt;span&gt;comparable&lt;/span&gt;, &lt;span&gt;V&lt;/span&gt; &lt;span&gt;Number&lt;/span&gt;]&lt;span&gt;(m &lt;span&gt;map&lt;/span&gt;[K]V)&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; s V&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, v := &lt;span&gt;range&lt;/span&gt; m {&lt;br/&gt;        s += v&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; s&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似的，可以这样调用（省略了「类型参数」）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fmt.Printf(&lt;span&gt;&quot;泛型计算结果（带 Constraint），Ints 结果: %v, Floats 结果: %v\n&quot;&lt;/span&gt;,&lt;br/&gt;    SumNumbers(ints),&lt;br/&gt;    SumNumbers(floats))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;05 总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型的内容远不止这些，但本文作为入门教程，旨在介绍基础内容，让大家对泛型使用有一个基本了解。本文的示例参照官方泛型教程：https://go.dev/doc/tutorial/generics。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文完整代码见 playground：https://go.dev/play/p/TwS6wda3nbv?v=gotip。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>