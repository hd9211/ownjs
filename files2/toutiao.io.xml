<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>56bfb8b40a0a108fbd63229c9d6073fc</guid>
<title>听叔一句劝，消息队列的水太深，你把握不住</title>
<link>https://toutiao.io/k/obo72ks</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;这是Jam的第 &lt;/span&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;156 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;篇原创分享&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.05&quot; data-type=&quot;png&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6rXsLrncBqzrqzaZMY3L9QQQLr2beXVha4MicumtStMbcghJUPIVwPlHALTGTkkmpGicPYQbQObXGWIZr9NvjAtw/640?wx_fmt=png&quot;/&gt;   很多人在做架构设计时往往会“过度设计”,简单问题复杂化，上来就引一堆中间件，我想大概原因主要有下面两点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;为了秀（学）技术而架构&lt;br/&gt;我们常说技术是为业务服务的，不能为了技术而技术，为了秀技术引入一堆复杂架构这是要不得的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;考虑问题不全面，或者说广度不够，不知道如何简单化&lt;br/&gt;举个栗子，假设有一个高并发的用户平台需要处理注册（写）及登录查询（读）功能，在数据库层做了主从同步。&lt;br/&gt;&lt;br/&gt;有人为了解决主从同步延时问题引入了一个Redis，想实现写主库的时候同时写Redis，然后读的时候直接读Redis，用以避免了主从延时同步问题，这就是典型的考虑问题不全面，这虽然可以解决主从延时问题，但是又会导致双写一致性事务问题的产生，那不如直接把主从同步的方式改成强同步复制直接从数据库层面保证了一致性。&lt;br/&gt;&lt;br/&gt;那你可能会说改成强同步复制不是会增加响应时间进而影响系统吞吐量吗，那咱还可以对用户做个分库，多做几个主从同步出来不就可以了吗？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;诶诶诶，跑题了，今天咱不是说消息队列吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哦，言归正传。今天我们说说消息队列的问题，希望看完本文大家在引入消息队列的时候先想一想，是不是一定要引入？引入消息队列后产生的问题能不能解决？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列的作用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务开发中我们经常会引入消息中间件实现业务解耦，执行异步操作， 现在让我们来看看使用消息中间件的好处和弊端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先需要肯定是使用消息组件有很多好处，其中最核心的三个是：解耦、异步、削峰。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;解耦&lt;/strong&gt;：客户端只要讲请求发送给特定的通道即可，不需要感知接收请求实例的情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;异步&lt;/strong&gt;：将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;削峰&lt;/strong&gt;：消息中间件在消息被消费之前一直缓存消息，消息处理端可以按照自己处理的并发量从消息队列中慢慢处理消息，不会一瞬间压垮业务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然消息中间件并不是银弹，引入消息机制后也会有如下一些弊端：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;潜在的性能瓶颈&lt;/strong&gt;：消息代理可能会存在性能瓶颈。幸运的是目前主流的消息中间件都支持高度的横向扩展。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;潜在的单点故障&lt;/strong&gt;：消息代理的高可用性至关重要，否则系统整体的可靠性将受到影响，幸运的是大多数消息中间件都是高可用的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;额外的操作复杂性&lt;/strong&gt;：消息系统是一个必须独立安装、配置和运维的系统组件，增加了运维的复杂度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些弊端我们借助消息中间件本身提供的扩展、高可用能力可以解决，但是要真正用好消息中间件我们还需要关注可能会遇到的一些设计难题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列的设计难题&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;处理并发和顺序消息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在生产环境中为了提高消息处理的能力以及应用程序的吞吐量，一般会将消费者部署多个实例节点。那么带来的挑战就是 &lt;strong&gt;如何确保每个消息只被处理一次，并且是按照他们的发送顺序来处理的。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：假设有3个相同的接收方实例从同一个点对点通道读取消息，发送方按顺序发布了 &lt;code&gt;Order Created&lt;/code&gt;、&lt;code&gt;Order Updated&lt;/code&gt; 和 &lt;code&gt;Order Cancelled&lt;/code&gt; 这3个事件消息。简单的消息实现可能就会同事讲每个消息给不同的接收方。若由于网络问题导致延迟，消息可能没有按照他们发出时的顺序被处理，这将导致奇怪的行为，服务实例可能在另一个服务器处理 &lt;code&gt;Order Created&lt;/code&gt; 消息之前处理 &lt;code&gt;Order Cancelled&lt;/code&gt;消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 使用的解决方案是使用分片（分区）通道。整体解决方案分为三个部分：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个主题通道由多个分片组成，每个分片的行为类似一个通道。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送方在消息头部指定分片键如orderId，Kafka使用分片键将消息分配给特定的分片。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将接收方的多个实例组合在一起，并将他们视为相同的逻辑接收方（消费者组）。kafka将每个分片分配给单个接收器，它在接收方启动和关闭时重新分配分片。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iayMvgxttQ19lYM82uMqboNc828uf261U6CXqoUVMlQt1Oxz0HcIltRvHl6shqR3yCsncgOw1ica4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;如上图所示，每个Order事件消息都将orderId作为其分片键。特定订单的每个事件都发布到同一个分片。而且该分片中的消息始终由同一个接收方实例读取，因此这样就能够保证按顺序处理这些消息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;处理重复消息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入消息架构必须要解决的另一个挑战是处理重复消息。在理想情况下，消息代理应该只传递一次消息，但保证消息有且仅有一次的消息传递的成本通常很高。相反，很多消息组件承诺至少保证成功传递一次消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在正常情况下，消息组件只会传递一次消息。但是当客户端、网络或消息组件故障可能导致消息被多次传递。假设客户端在处理消息后发送确认消息前，他的数据库崩溃了，这时消息组件将再次发送未确认的消息，在数据库重新启动时向该客户端发送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;处理重复消息有以下两种不同的方法：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;编写幂等消息处理器&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果应用程序处理消息的逻辑是满足幂等的，那么重复消息就是无害的。程序的幂等性是指，即使这个应用被相同输入参数多次重复调用时，也不会产生额外的效果。例如：取消一个已经取消的订单，就是一个幂等性操作。同样，创建一个已经存在的订单操作也必是这样。满足幂等的消息处理程序可以被放心的执行多次，只要消息组件在传递消息时保持相同的消息顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是不幸的是，应用程序通常不是幂等的。或者你现在正在使用的消息组件在重新传递消息时不会保留排序。重复或无序消息可能会导致错误。在这种情况下，你需要编写跟踪消息并丢弃重复消息的消息处理程序。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;跟踪消息并丢弃重复消息&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑一个授权消费者信用卡的消息处理程序。它必须为每个订单仅执行一次信用卡授权操作。这段应用程序每次调用时都会产生不同的效果。如果重复消息导致消息处理程序多次执行该逻辑，则应用程序的行为将不正确。执行此类应用程序逻辑的消息处理程序必须通过检测和丢弃重复消息而让它成为幂等的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个简单的解决方案是消息接收方使用 message id 跟踪他已处理的消息并丢弃任何重复项。例如，在数据库表中存储它消费的每条消息的 message id。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4696969696969697&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iayMvgxttQ19lYM82uMqboNpJox7MnVRhzCk2DicL2Ak5ljIp4GCtESv4PTHqzGjm91xF152sFn29Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;792&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;当接收方处理消息时，它将消息的 message id 作为创建和变更业务实体的事务的一部分记录在数据表里。如上图所示，接收方将包含message id 的行插入 PROCESSED_MESSAGE表。如果消息是重复的，则INSERT将失败，接收方可以选择丢弃该消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个解决方案是消息处理程序在应用程序表，而不是专门表中记录 message id。当时用具有受限事务模型的NoSQL数据库时，此方法特别有用，因为 NoSQL数据库通常不支持将针对两个表的更新作为数据库事务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;处理事务性消息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务通常需要在更新数据库的事务中发布消息，数据库更新和消息发送都必须在事务中进行，否则服务可能会更新数据库然后在发送消息之前崩溃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务不以原子方式执行者两个操作，则类似的故障可能使系统处于不一致状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们看一下常用的保证事务消息的两种解决方案，最后再看看现代消息组件RocketMQ的事务性消息解决方案。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;使用数据库表作为消息队列&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的应用程序正在使用关系型数据库，要保证数据的更新和消息发送之间的事务可以直接使用 &lt;strong&gt;事务性发件箱模式，Transactional Outbox&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5447530864197531&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iayMvgxttQ19lYM82uMqboNUn8CpCOO9P5PqUp4JMuTwYPlKShzlP5BRUHcib6o4YOo0GnlaLWcLUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;648&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;此模式使用数据库表作为临时消息队列。如上图所示，发送消息的服务有个OUTBOX数据表，在进行INSERT、UPDATE、DELETE 业务操作时也会给OUTBOX数据表INSERT一条消息记录，这样可以保证原子性，因为这是基于本地的ACID事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OUTBOX表充当临时消息队列，然后我们在引入一个消息中继（MessageRelay）的服务，由他从OUTBOX表中读取数据并发布消息到消息组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息中继的实现可以很简单，只需要通过定时任务定期从OUTBOX表中拉取最新未发布的数据，获取到数据后将数据发送给消息组件，最后将完成发送的消息从OUTBOX表中删除即可。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;使用事务日志发布事件&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一种保证事务性消息的方式是基于数据库的事务日志，也就是所谓的数据变更捕获，Change Data Capture，简称CDC。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般数据库在数据发生变更的时候都会记录事务日志（Transaction Log），比如MySQL的binlog。事务日志可以简单的理解成数据库本地的一个文件队列，它主要记录按时间顺序发生的数据库表变更记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们利用alibaba开源的组件canal结合MySQL来说明下这种模式的工作原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多操作说明可以参考官方文档：https://github.com/alibaba/canal&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;canal工作原理&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;canal 模拟 MySQL slave 的交互协议，把自己伪装成一个MySQL的 slave节点 ，向 MySQL master 发送dump 协议；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;canal 解析 binary log 对象(原始为 byte 流)，然后可以将解析后的数据直接发送给消息组件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;RocketMQ事务消息解决方案&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apache RocketMQ在4.3.0版中已经支持分布式事务消息，RocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4503464203233256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4iayMvgxttQ19lYM82uMqboNJI9MzqA4yvCR4mVs8XK1iaDb3Suu7dYSSZ3YiaeWumtauAjRXTQIbN7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;866&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;RocketMQ实现事务消息主要分为两个阶段：正常事务的发送及提交、事务信息的补偿流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体流程为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;正常事务发送与提交阶段&lt;br/&gt;1、生产者发送一个半消息给MQServer（半消息是指消费者暂时不能消费的消息）&lt;br/&gt;2、服务端响应消息写入结果，半消息发送成功&lt;br/&gt;3、开始执行本地事务&lt;br/&gt;4、根据本地事务的执行状态执行Commit或者Rollback操作&lt;br/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务信息的补偿流程&lt;br/&gt;1、如果MQServer长时间没收到本地事务的执行状态会向生产者发起一个确认回查的操作请求&lt;br/&gt;2、生产者收到确认回查请求后，检查本地事务的执行状态&lt;br/&gt;3、根据检查后的结果执行Commit或者Rollback操作
补偿阶段主要是用于解决生产者在发送Commit或者Rollback操作时发生超时或失败的情况。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在生产者使用RocketMQ发送事务消息的时候我们也会借鉴第一种方案即自建一张事务日志表，然后在执行本地事务的时候同时生成一条事务日志记录，让本地事务与日志事务在同一个方法中，同时添加 &lt;code&gt;@Transactional&lt;/code&gt; 注解，保证两个操作事务是一个原子操作。&lt;strong&gt;这样如果事务日志表中有这个本地事务的信息，那就代表本地事务执行成功，需要Commit，相反如果没有对应的事务日志，则表示没执行成功，需要Rollback。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b5cf4a3d57d8002a83f6982985193714</guid>
<title>Kafka 为什么要抛弃 ZooKeeper？</title>
<link>https://toutiao.io/k/bbulcom</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是 yes。（先说下哈，今天文末送三本硬核的书！&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上个月 30 号， confluent 发布了一篇文章，文章上说在 Kafka 2.8 版本上将支持内部的 quorum 服务来替换 ZooKeeper 的工作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3561320754716981&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nHQJOTMnuMpLPx77KCicwSYCs7kBPMYcm38xMC3e1qtKMeFoLAL7ab1ZLNzRDZTwBe5O7LibbAdLaZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;848&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实去年我写的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247485752&amp;amp;idx=1&amp;amp;sn=53ae862abc0eddaf21a3e628706e0a67&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Kafka控制器事件处理全流程&lt;/a&gt;这篇文章已经提到这一点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3298662704309064&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nHQJOTMnuMpLPx77KCicwSYCjWtLiaoxXdBo70B8TfSJO7C28dwtmkgOJjfs8w3icGyh3NTABsr2Qqmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;673&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天再稍微展开来说说。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ZooKeeper 的作用&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZooKeeper 是一个开源的分布式协调服务框架，你也可以认为它是一个可以保证一致性的分布式(小量)存储系统。特别适合存储一些公共的配置信息、集群的一些元数据等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它有持久节点和临时节点，而临时节点这个玩意再配合 Watcher 机制就很有用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当创建临时节点的客户端与 ZooKeeper 断连之后，这个临时节点就会消失，并且订阅了节点状态变更的客户端会收到这个节点状态变更的通知。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6635416666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nHQJOTMnuMpLPx77KCicwSYCC5a3JaxhWJZ5sOcjd2JiaZtuZzBvzpXkBC7jBkFyLPSTTPxVFwtEDGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以集群中某一服务上线或者下线，都可以被检测到。因此可以用来实现服务发现，也可以实现故障转移的监听机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 就是强依赖于 ZooKeeper，没有 ZooKeeper 的话 Kafka 都无法运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZooKeeper 为 Kafka 提供了元数据的管理，例如一些 Broker 的信息、主题数据、分区数据等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在每个 Broker 启动的时候，都会和 ZooKeeper 进行交互，这样 ZooKeeper 就存储了集群中所有的主题、配置、副本等信息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.58397365532382&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nHQJOTMnuMpLPx77KCicwSYCFwfPMXfqe0u0K8NdTDK8e78XHcSWwxR6H8hQBgDicLleNDmoUAuwLaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一些选举、扩容等机制也都依赖 ZooKeeper 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如控制器的选举：每个 Broker 启动都会尝试在 ZooKeeper 注册&lt;code&gt;/controller&lt;/code&gt;临时节点来竞选控制器，第一个创建&lt;code&gt;/controller&lt;/code&gt;节点的 Broker 会被指定为控制器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;竞争失败的节点也会依赖 watcher 机制，监听这个节点，如果控制器宕机了，那么其它 Broker 会继续来争抢，实现控制器的 failover。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面就可以得知 ZooKeeper 对 Kafka 来说，&lt;span&gt;很重要&lt;/span&gt;。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;那为什么要抛弃 ZooKeeper&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件架构都是演进的，之所以要变更那肯定是因为出现了瓶颈。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;先来看看运维的层面的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先身为一个中间件，需要依赖另一个中间件，这就感觉有点奇怪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你要说依赖 Netty 这种，那肯定是没问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 Kafka 的运行需要提供 ZooKeeper 集群，这其实有点怪怪的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就等于如果你公司要上 Kafka 就得跟着上 ZooKeeper ，被动了增加了运维的复杂度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好比你去商场买衣服，要买个上衣，服务员说不单卖，要买就得买一套，这钱是不是多花了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以运维人员不仅得照顾 Kafka 集群，还得照顾 ZooKeeper 集群。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;再看性能层面的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZooKeeper 有个特点，&lt;span&gt;强一致性&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 ZooKeeper 集群的某个节点的数据发生变更，则会通知其它 ZooKeeper 节点同时执行更新，就得等着大家(超过半数)都写完了才行，这写入的性能就比较差了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43358395989974935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nHQJOTMnuMpLPx77KCicwSYCcJiaTXWI5FAv27Y4ybEP92Hl5pIKPMRojObf7uicxbwb0WcBQpDjiaWvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;798&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后看到上面我说的&lt;span&gt;小量&lt;/span&gt;存储系统了吧，一般而言，ZooKeeper 只适用于存储一些简单的配置或者是集群的元数据，不是真正意义上的存储系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果写入的数据量过大，ZooKeeper 的性能和稳定性就会下降，可能导致 Watch 的延时或丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在 Kafka 集群比较大，分区数很多的时候，ZooKeeper 存储的元数据就会很多，性能就差了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有，ZooKeeper 也是分布式的，也需要选举，它的选举也不快，而且发生选举的那段时候是不提供服务的！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 ZooKeeper 的性能问题 Kafka 之前就做了一些升级。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如以前 Consumer 的位移数据是保存在 ZooKeeper 上的，所以当提交位移或者获取位移的时候都需要访问 ZooKeeper ，这量一大 ZooKeeper 就顶不住。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以后面引入了位移主题(Topic是__consumer_offsets)，将位移的提交和获取当做消息一样来处理，存储在日志中，避免了频繁访问 ZooKeeper 性能差的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有像一些大公司，可能要支持百万分区级别，这目前的 Kafka 单集群架构下是无法支持稳定运行的，也就是目前单集群可以承载的分区数有限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 Kafka 需要去 ZooKeeper 。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;所以没了 Zookeeper 之后的 Kafka 的怎样的？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没了 Zookeeper 的 Kafka &lt;span&gt;就&lt;/span&gt;把元数据存储到自己内部了，利用之前的 Log 存储机制来保存元数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就和上面说到的位移主题一样，会有一个元数据主题，元数据会像普通消息一样保存在 Log 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以元数据和之前的位移一样，利用现有的消息存储机制稍加改造来实现了功能，完美！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后还搞了个 KRaft 来实现 Controller Quorum。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4740740740740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nHQJOTMnuMpLPx77KCicwSYCRnHmuO1ia5O5QWaPzvfIk41j4gAaA0AazMGicyJJqLzq3CXhHvJCZ4UQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;675&quot;/&gt;&lt;figcaption&gt;图来自 confluent&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个协议是基于 Raft 的，协议具体就不展开了，就理解为它能解决 Controller  Leader 的选举，并且让所有节点达成共识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前基于 Zookeeper 实现的&lt;span&gt;单个&lt;/span&gt; Controller 在分区数太大的时候还有个问题，故障转移太慢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Controller 变更的时候，需要重新加载所有的元数据到新的 Controller 身上，并且需要把这些元数据同步给集群内的所有 Broker。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 Controller Quorum 中的 Leader 选举切换则很快，因为元数据都已经在 quorum 中同步了，也就是 quorum 的 Broker 都已经有全部了元数据，所以不需要重新加载元数据！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且其它 Broker 已经基于 Log 存储了一些元数据，所以只需要增量更新即可，不需要全量了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这波改造下来就解决了之前元数据过多的问题，可以支持更多的分区！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能看到这里有人会说，那为何一开始不这么实现？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 ZooKeeper 是一个功能强大且经过验证的工具，在早期利用它来实现一些功能，多简单哟，都不需要自己实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要不是 ZooKeeper 的机制导致了这个瓶颈，也不可能会有这个改造的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件就是这样，没必要重复造轮子，合适就好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考资料：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;https://www.confluent.io/blog/kafka-without-zookeeper-a-sneakpeek/&lt;/em&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;https://time.geekbang.org/column/article/253202&lt;/em&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;https://www.infoq.cn/article/PHF3gFjUTDhWmctg6kXe&lt;/em&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，今天送的书是《深入解析Java虚拟机HotSpot》，看名字是不是就很硬核？&lt;/p&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1618841465330_0.05325699300929054&quot; data-uid=&quot;1618841465328&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;29177012&quot; data-categoryid=&quot;3&quot; data-appuin=&quot;3084391334&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该书以源码分析为基础，从运行时、垃圾回收器、即时编译三个维度全面解析 &lt;span&gt;HotSpot&lt;/span&gt; VM 的底层实现和工作机制~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我和华章合作，送&lt;span&gt;三本&lt;/span&gt;哟！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;留言点赞最高的前两名&lt;/span&gt;各得一本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;朋友圈到时候抽一本&lt;/span&gt;，加我微信好友即可：yes_oba&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4月22号晚上20点整截止&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对了想要买书的话记得用我推文的当当优惠码，见推文次条。&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是 yes，从一点点到亿点点，我们下篇见。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>20433318b4e1792954ef3d88004ff997</guid>
<title>字节跳动异构场景下的高可用建设实践</title>
<link>https://toutiao.io/k/jwzcso7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-template=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;点击上方👆&lt;span data-mid=&quot;&quot;&gt;蓝字&lt;/span&gt;关注我们！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;161&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/fgbJnuXT4EpMWYL57q1A4NBibz06jylFkOZkW3LWp3dIYj2dPb4WE5IYibpPqOkicloJw4ro84599blfDbiaaSYkUg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;648&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section label=&quot;powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;字节跳动有众多的 APP 和服务，如何用混沌工程的方式保证这些系统和服务的高可用？本文详细介绍了字节跳动混沌工程技术的演进和系统高可用建设实践。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;作者｜邵育亮，基础架构团队系统治理方向负责人&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文主要为大家介绍字节跳动在高可用建设上的一些思考和落地经验。先给大家简单介绍一下系统治理团队是做什么的。系统治理团队在基础架构团队内部，主要负责字节跳动&lt;strong&gt;研发的闭环生态&lt;/strong&gt;：从服务开发，到大规模微服务架构下的联调、开发以及对应的发布，再到上线以后的微服务治理、对应的流量调度、容量分析，以及到最后通过混沌工程的建设帮助业务提升高可用能力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来就进入正题。首先介绍一下字节跳动混沌工程建设的背景。大家知道字节跳动有很多 APP，我们有非常多的服务，这些服务大致可以分成三个类型：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;在线服务&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：大家可以理解成支持抖音、西瓜视频等的后端服务。这些服务的特点是它们跑在我们自建的大规模 K8s 上的 PaaS 集群上，这是一套非常大的微服务架构。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;离线服务&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：包括一些推荐模型的 training，大数据的 report 计算等等，都属于离线服务。它们依赖大规模的存储和计算的能力。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;基础架构&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：承载了字节中国的所有业务线，向上提供一套 PaaS 化的能力，包括计算和存储等，支撑各种业务不同的使用场景。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;不同的服务体系对高可用的关注度并不一样。我们简单做一下分析：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;在线服务&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;strong&gt;本身是无状态服务&lt;/strong&gt;，运行在 K8s 容器上，其存储都在外部的 MySQL、Redis。这些无状态服务很方便做扩容，在发生故障时能尽可能容错，当然也可能会做一些降级。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;离线服务&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;strong&gt;有状态服务，很关注计算的状态&lt;/strong&gt;。大数据的计算服务特点是运行时间很长，Training、model 的时间都特别长。它能容忍一些错误（如果某次 job 挂了，可以进行 retry），其更多状态的一致性、数据的完整性是依赖底层存储系统的支持。所以我们在离线服务的高可用建设，很大规模依赖于整个基础架构提供的高可用能力。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;基础架构&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;strong&gt;基础架构本身是有状态的&lt;/strong&gt;，它是进行大规模存储、计算的平台，可能会遇到一些网络故障、磁盘故障等灰天鹅事件，这其中我们关注较多的是数据一致性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;应对不同的服务类型，系统治理团队负责高可用的同学提出了不同的解决方案。在这里先给大家介绍我们应对在线服务（无状态服务）时混沌工程的演进。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;在线服务的混沌工程演进&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;混沌工程平台 1.0 架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们认为我们的混沌工程平台 1.0 版本还不是一个混沌工程系统，更多的是一个&lt;strong&gt;故障注入系统&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;332&quot; data-backw=&quot;503&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6600397614314115&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fgbJnuXT4EoRMvCiaz1pkUia2jDRI4LobqYTsTO9y3wFgoKZ7rcxAEROYsc6ZXguNd7m83nSwRmPDY6tl7HacoIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;503&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;上图是我们这个平台 1.0 版本的架构。这个平台面向用户提供可视化界面，可进行故障注入和一些简单的配置。在底层物理机上我们装了 Agent。Agent 运行在宿主机上，可实现容器间网络相关的故障注入。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于服务稳态，我们在做混沌演练的时候，在平台上可以注入一些 metrics，用户可以写一个 bosun 语句去查询 metrics，我们提供一个阈值，系统就会轮询这个 metrics 来判定服务是否达到稳定的状态。如果超出边界，我们就进行故障恢复。如果没有超出边界，就继续演练，看是否能达到预期。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为什么这个系统不能称之为一个混沌工程的系统？Netflix 的 Principle of Chaos 对混沌工程的定义（&lt;/span&gt;&lt;span&gt;http://principlesofchaos.org/&lt;/span&gt;&lt;span&gt;） 有五大原则：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;建立一个围绕稳定状态行为的假说&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;多样化真实世界的事件&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在生产环境中运行实验&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;持续自动化运行实验&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;最小化爆炸半径控制&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;对比以上五个原则，我们来看一下为什么说这个平台只是个故障注入系统。&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;首先整体的稳态还相对比较简陋。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;实际的微服务架构中会存在各种故障，这个平台中只做到了比较简单的故障注入，如故障延迟、断网等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在生产环境进行演练是当时能做到的事情。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;因为稳态比较简陋，所以很难真正评估这个系统是不是稳定，系统也无法自动化运行实验。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;整个系统声明 scale 的 scope 做的不是特别好。另外当时技术实现的结构是在物理机的宿主机上做故障注入，本身有一定的隐患，爆炸半径控制做得也不是特别好。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;混沌工程平台 2.0 架构&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在 2019 年的时候，我们开始想把混沌工程平台 1.0 版本演进到下一代，希望能够做一个真正符合混沌工程标准的系统，因此有了平台的 2.0 版本，我们认为它是字节跳动真正意义上的第一个混沌工程系统。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;543&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9740034662045061&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fgbJnuXT4EoRMvCiaz1pkUia2jDRI4Lobq3iaH5IfGlSThZR1VdtLbNsQ5LOwzsG6B9Mia0tU1XJZgMib3GfJbWNmCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;577&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;混沌工程平台 2.0 版本的一些升级：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;架构升级&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：引入了一个&lt;strong&gt;故障中心层&lt;/strong&gt;，解耦了业务逻辑和底层故障注入。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;故障注入&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：随着 &lt;strong&gt;Service Mesh &lt;/strong&gt;更大规模的应用，网络调用相关的故障更多基于 sidecar 实现。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;稳定性模型&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：这个阶段我们也构建了一个&lt;strong&gt;稳态系统&lt;/strong&gt;，基于服务的关键指标和机器学习等算法实现稳态计算。我们非常关注稳态系统，认为&lt;strong&gt;真正的自动化演练是不需要人工干预的&lt;/strong&gt;，所以需要一个系统来识别被演练的系统是否稳定。如果系统只看到一堆 metrics，它很难直接去认知系统的稳定性。我们希望通过一些特定算法将这些 metrics 聚合成一个百分位指标，假设这个指标达到 90 分，我们就认为它是稳定的。后文还会再介绍我们怎么在这个稳态系统里面做算法的投入。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;故障中心架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们的故障中心借鉴了 K8s 的架构。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;207&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3707865168539326&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fgbJnuXT4EoRMvCiaz1pkUia2jDRI4LobqZ1BHBQa8HwFP8hDZ4ibM3mzD8cR3a0oSibUicicxrjMurz25Gt2mItLvmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;混沌工程平台 1.0 系统有一个问题：假设通过 Agent 在 K8s 里成功注入了一个延迟故障。但 K8s 本身有弹性调度能力，如果很不幸在演练过程中这个服务 crash 了，K8s 会自动在另外一个机器上把这个 Pod 启起来。这种情况下，你以为故障演练是成功的，但其实没有成功，而是重新起了新的服务。故障中心可以在容器发生漂移的时候继续注入故障。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以我们是&lt;strong&gt;一套声明式的 API，声明的不是要注入什么故障，而是描述服务器的一种状态&lt;/strong&gt;，例如 A 跟 B 之间的网络是断开的，那么在任何状态下故障中心要保证 A 和 B 是断开状态。其次，整个系统借鉴 K8s 的架构，有丰富的 controller 支持底层不同的故障注入能力。在对业务的快速需求的支持过程中，我们在 controller 里能很快接入 Chaos Mesh、Chaos Blade 等开源项目。我们自己也原生做了一些 controller，比如 service mesh controller，agent controller，服务发现的 controller 等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;爆炸半径控制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前面提到故障中心是通过声明式 API 注入故障，我们就需要定义故障注入 model。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;241&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4322429906542056&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fgbJnuXT4EoRMvCiaz1pkUia2jDRI4LobqYHxafzDsr1hfkYJY1w4NrammzynAibZMSPVibcXuzpwj8K4ibMhjmQlWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;856&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;271&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.48503937007874015&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fgbJnuXT4EoRMvCiaz1pkUia2jDRI4LobqXdcFQMZ5z1on5I1PuBfnjDtuX44gZrjjuSy3M1D4jaJMpThSgH5C3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如上图所示：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Target&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：表示要注入故障的目标服务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Scope Filter&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：对于爆炸半径控制，很重要的一点是我们希望能够让业务去帮助声明希望演练的 scope，我们称为 Scope Filter。通过 Scope Filter 能定义故障注入的目标，可以是一个机房，一个集群，一个可用区，甚至精确到实例级别乃至流量级别。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Dependency&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：它是所有可能影响服务本身的异常来源，包括中间件，某下游服务，也包括所依赖的 CPU、磁盘、网络等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Action&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：故障事件，即发生了何种故障，比如下游服务返回拒绝、发生丢包；又比如磁盘写异常、CPU 被抢占等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;所以在故障中心声明故障时，需要描述上述内容，表明业务希望系统中是怎样的故障状态。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;稳态系统&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;稳态系统会涉及一些算法的工作，这里主要介绍三个算法的场景：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;时序序列的动态分析&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：我们叫稳态算法，可以尝试分析服务是否稳定。其中使用了阈值检测、3 Sigma 原则、稀疏规则等算法。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;AB 对比稳态分析&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：借鉴了 Netflix 在用的曼-惠特尼 U 检验，大家可以看一些相关 paper 和文章介绍。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;检测机制&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：使用指标波动一致性检测算法，用来分析强弱依赖。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;通过以上这些算法（还有其他算法），稳态系统能够去很好地刻画系统稳定性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;自动化演练&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们将自动化演练定义为完全不需要人工干预，由系统进行故障注入，在注入过程、演变过程中分析服务的稳定性，随时止损或拿到结果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们现在进行自动化演练有这样一些前提：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;能够明确演练的实际场景的目标；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过稳态系统，对稳态假设具备自动化判断能力；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;能够通过声明式 API、Scope Filter 控制混沌演练的影响范围，实验过程生产损失极小。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;自动化演练目前主要的应用场景是强弱依赖分析，包括：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;强弱依赖现状与业务标注是否一致；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;弱依赖超时是否会拖垮整体链路。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在我们再来回顾一下，为什么我们认为混沌工程平台 2.0 版本是一个混沌工程系统。还是对比前文提到的五个原则：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;建立一个围绕稳定状态的假说：通过稳态系统已经开启了稳态假说的演进。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;多样化真实世界的事件：现在故障分层上更加合理，补充了大量中间件故障和底层故障。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在生产环境中运行试验：这一点在 1.0 时期就实现了，2.0 中进行了扩展，可支持生产环境、预发环境、本地测试环境的各种故障演习。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;持续自动化运行试验：提供 csv、sdk、api 等能力，让业务线在自己希望的服务发布流程中持续跟功能做整合。我们也提供了 API 能力，帮助业务线在需要的环境做故障注入。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;最小化爆炸半径：提供声明式 API 的能力，其中一个原因就是为了控制爆炸半径。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;支撑底层系统演练的基础设施混沌平台&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;前面提到了离线服务很大程度上依赖底层状态的一致性，所以如果把基础架构中存储、计算做好，就能够很好地支撑业务。我们用一个新的基础设施混沌平台来做一些内部的实验性尝试。对于基础架构的混沌工程，我们要打破一下混沌工程的一些标准原则。&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;首先针对基础架构的混沌工程不太适合在生产环境演练，因为它依赖于底层的故障注入，影响面非常大，爆炸半径不好控制。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在自动化演练上，业务方需要更加灵活的能力，进一步跟他们的 CI/CD 打通，也需要更加复杂的编排需求。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于稳态模型，&lt;strong&gt;除了稳定性之外，我们更关注一致性&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;要支持离线环境的混沌工程，该基础设施混沌平台给了我们一个安全的环境，让我们能够在里面展开手脚做更多的故障注入，比如 CPU、Memory、File system 等系统资源故障；拒绝、丢包等网络故障；以及包括时钟跳变、进程被杀、代码级异常、文件系统级方法 error hook 在内的其他故障。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于自动化演练的自动化编排，我们希望通过这个平台给用户更加灵活的编排能力，例如：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;串并行任务执行&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;随时暂停 &amp;amp; 断点恢复&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基础设施主从节点识别&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;我们也提供了一些&lt;strong&gt;插件能力&lt;/strong&gt;，让一些组件团队能够更灵活地注入故障。有的业务团队可能在自己的系统里已经埋点了一些 hook，他们希望这个系统能够更直接地帮助注入故障，同时也希望复用我们的编排体系和平台体系。我们通过 hook 的方式，业务团队只需实现对应的 hook，就能够注入特定的故障，然后继续使用我们的整套编排体系和平台。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;331&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5927672955974843&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fgbJnuXT4EoRMvCiaz1pkUia2jDRI4LobqIrk8FwpibQvBNiaDRrLibLfauvOOu8EOibA6TNynqPU7aO1jLTFO9FCBtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1272&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;从混沌工程到系统高可用建设&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们最开始做 Chaos Engineering 的时候，对团队的使命定位是在字节跳动落地混沌工程。但是当我们做出一些能力找业务线使用的时候，会发现业务线对此并没有什么需求。后来我们努力思考之后调整了团队的使命：&lt;strong&gt;通过混沌工程或者其他一些手段帮助业务推进高可用建设&lt;/strong&gt;。调整之后我们就从过去研究 Chaos Engineering 的业界发展，变成了要去贴着业务理解业务的高可用。我们如何帮助业务进行高可用建设呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;什么是高可用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们用下面这个公式来进行理解高可用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;79&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.14169215086646278&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fgbJnuXT4EoRMvCiaz1pkUia2jDRI4LobqIYgRQT78NGzjRmic89UfNYu2TZp6sz4X9Wj8UmsTJqkFa3smve8AANA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;981&quot;/&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MTTR（Mean Time To Repair）：平均修复时间&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MTBF（Mean Time Between Failure）：平均失效间隔时间&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;N：事故发生次数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;S：影响范围&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;这个公式的值明显小于 1，算出来应该是所谓的三个九、五个九。要让 A 的值足够大，需要：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MTTR*N*S 的值足够小。所以需要降低 MTTR，降低事故发生次数，缩小故障范围。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MTBF 的值变大。即尽可能拉开两次故障之间的间隔。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;如何降低 MTTR、N、S 呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;降低故障影响范围（S）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当面向生产架构的故障发生的时候，要降低故障影响范围，从架构侧可以采用一些设计手段：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;单元化设计：用户请求隔离&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;多机房部署：系统资源隔离&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;核心业务独立部署：业务功能隔离&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;异步化处理&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;在这里，混沌工程可以做的事情是帮助 SRE 团队验证这些架构设计是否符合预期。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;减少故障发生次数（N） &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里要重新定义一下故障。Failure 是不可避免的，我们要尽可能在软件系统的架构层避免 Failure 转换成 Error。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如何降低从 Failure 到 Error 的转换率？最重要的是加强系统的容错性，包括：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;部署：异地多活，流量灵活调度，服务兜底，预案管理；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;服务治理：超时配置，熔断 fail fast。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;这其中混沌工程起到的作用帮助验证系统容错能力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;降低平均修复时间（MTTR）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;201&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36042692939244664&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fgbJnuXT4EoRMvCiaz1pkUia2jDRI4LobqFySaxJl9LGOoCDMHNyO0nvIF3neQOxCOgwrEQVvYplhqicAdQIIeDGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1218&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图展示了 MTTR 涉及的一些因素：Fail Notification、诊断、修复、测试、最终上线等所需的时间。要降低 MTTR 可以对每个涉及的因素加入一些设计手段：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;充分的监控告警覆盖。需要推动业务进行告警的治理。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在告警充分覆盖的同时保证告警的准确性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;高效定位，加强排障能力。目前我们跟内部的 AIOps 团队合作，做进一步的智能化障碍分析，降低诊断时间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;快速止损预案。从修复到测试再到最终上线，需要有一个预案系统，根据诊断的故障特征备有预案库，做到点击按钮即可选择准确的预案做恢复。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;这其中混沌工程可做的是进行应急响应演练。&lt;strong&gt;其实演练不只是针对系统，也是演练组织里每个人的应急能力&lt;/strong&gt;。当面临事故时，团队可以有一套标准的 workflow 去发现问题、定位问题、解决问题，这也混沌工程系统希望演练达到的效果。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;后续规划&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;最后介绍一下我们在高可用、混沌工程方面的后续规划，主要有三个方面：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;故障精细化能力建设&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;丰富混沌工程的使用场景&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;继续探索自动化场景&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;降低用户接入和使用成本，打造轻量级平台&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;扩展混沌工程内涵&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;回归可用性视角，持续探索混沌工程与高可用的关系&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;建立故障预算机制，通过量化故障损失进行预测和分析，从而协助决策在混沌工程的投入&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;关注👇👇公众号，后台回复【&lt;/span&gt;&lt;span&gt;&lt;strong&gt;高可用&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;】获取本文对应的&lt;/span&gt;&lt;strong&gt;&lt;span&gt; PPT&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwNTIwNzc3OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/fgbJnuXT4ErBsjJWvAQyvqOmbNdIicSf7GteicpXfENm6O5ZZAUqIZlMc2j7kib6A9XVvhMfEfUwvg3YFx7EiasiaPw/0?wx_fmt=png&quot; data-nickname=&quot;火山引擎开发者社区&quot; data-alias=&quot;&quot; data-signature=&quot;火山引擎是字节跳动旗下的数字服务与智能科技品牌，基于公司服务数亿用户的大数据、人工智能和基础服务等能力，为企业客户提供系统化全链路解决方案，助力企业务实地创新，实现业务持续快速的增长。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;321&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5553997194950911&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/fgbJnuXT4EoRMvCiaz1pkUia2jDRI4LobqcoY2TbkgJL0iaoFWXF2lnm29QwndK5eto1aOblStj1lkxX8UmialrO1A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;713&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;火山引擎品牌发布会&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;将于 6 月 10 日举行，为大家&lt;span&gt;揭秘字节跳动 9 年增长背后的技术原力&lt;/span&gt;！点击【&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;】立即预约，一起搭乘「增长引擎」舱～&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>375e4592e20148307cc5a8cdfc671af1</guid>
<title>面试侃集合：LinkedBlockingQueue 篇</title>
<link>https://toutiao.io/k/dlbbh09</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面试官：好了，聊完了&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;&lt;strong&gt;&lt;span&gt;，我们接着说说&lt;/span&gt;&lt;/strong&gt;&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;&lt;span&gt;&lt;strong&gt;吧&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：还真是不给人喘口气的机会，&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;是一个基于链表的阻塞队列，内部是由节点&lt;code&gt;Node&lt;/code&gt;构成，每个被加入队列的元素都会被封装成下面的&lt;code&gt;Node&lt;/code&gt;节点，并且节点中有指向下一个元素的指针：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    E item;&lt;br/&gt;    Node&amp;lt;E&amp;gt; next;&lt;br/&gt;    Node(E x) { item = x; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;中的关键属性有下面这些：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; capacity;&lt;span&gt;//队列容量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger count = &lt;span&gt;new&lt;/span&gt; AtomicInteger();&lt;span&gt;//队列中元素数量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt; head;&lt;span&gt;//头节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt; last;&lt;span&gt;//尾节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//出队锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantLock takeLock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;br/&gt;&lt;span&gt;//出队的等待条件对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Condition notEmpty = takeLock.newCondition();&lt;br/&gt;&lt;span&gt;//入队锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantLock putLock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;br/&gt;&lt;span&gt;//入队的等待条件对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Condition notFull = putLock.newCondition();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造函数分为指定队列长度和不指定队列长度两种，不指定时队列最大长度是&lt;code&gt;int&lt;/code&gt;的最大值。当然了，你要是真存这么多的元素，很有可能会引起内存溢出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LinkedBlockingQueue&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;(Integer.MAX_VALUE);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LinkedBlockingQueue&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; capacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (capacity &amp;lt;= &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.capacity = capacity;&lt;br/&gt;    last = head = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;E&amp;gt;(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有另一种在初始化时就可以将集合作为参数传入的构造方法，实现非常好理解，只是循环调用了后面会讲到的&lt;code&gt;enqueue&lt;/code&gt;入队方法，这里暂且略过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;中，队列的头结点&lt;code&gt;head&lt;/code&gt;是不存元素的，它的&lt;code&gt;item&lt;/code&gt;是&lt;code&gt;null&lt;/code&gt;，&lt;code&gt;next&lt;/code&gt;指向的元素才是真正的第一个元素，它也有两个用于阻塞等待的&lt;code&gt;Condition&lt;/code&gt;条件对象。与之前的&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;不同，这里出队和入队使用了不同的锁&lt;code&gt;takeLock&lt;/code&gt;和&lt;code&gt;putLock&lt;/code&gt;。队列的结构是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2599502487562189&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbHMNJReUCPWD7YZicg2iazjBOLtPUicUJlaPfPw4nfgpribCdM9qqY8Z0Tpib5S5VW8zjUYoBMc789Ccw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;面试官：为什么要使用两把锁，之前&lt;/span&gt;&lt;/strong&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;&lt;strong&gt;&lt;span&gt;使用一把锁，不是也可以保证线程的安全么？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：使用两把锁，可以保证元素的插入和删除并不互斥，从而能够同时进行，达到提高吞吐量的的效果&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面试官：嗯，那还是老规矩，先说插入方法是怎么实现的吧&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：这次就不提父类&lt;code&gt;AbstractQueue&lt;/code&gt;的&lt;code&gt;add&lt;/code&gt;方法了，反正它调用的也是子类的插入方法&lt;code&gt;offer&lt;/code&gt;，我们就直接来看&lt;code&gt;offer&lt;/code&gt;方法的源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;offer&lt;/span&gt;&lt;span&gt;(E e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException();&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; AtomicInteger count = &lt;span&gt;this&lt;/span&gt;.count;&lt;span&gt;//队列中元素个数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (count.get() == capacity)&lt;span&gt;//已满&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; c = -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    Node&amp;lt;E&amp;gt; node = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;E&amp;gt;(e);&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; ReentrantLock putLock = &lt;span&gt;this&lt;/span&gt;.putLock;&lt;br/&gt;    putLock.lock();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;//并发情况，再次判断队列是否已满&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (count.get() &amp;lt; capacity) {&lt;br/&gt;            enqueue(node);&lt;br/&gt;            &lt;span&gt;//注意这里获取的是未添加元素前的对列长度&lt;/span&gt;&lt;br/&gt;            c = count.getAndIncrement();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (c + &lt;span&gt;1&lt;/span&gt; &amp;lt; capacity)&lt;span&gt;//未满&lt;/span&gt;&lt;br/&gt;                notFull.signal();&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        putLock.unlock();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        signalNotEmpty();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; c &amp;gt;= &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;offer&lt;/code&gt;方法中，首先判断队列是否已满，未满情况下将元素封装成&lt;code&gt;Node&lt;/code&gt;对象，尝试获取插入锁，在获取锁后会再进行一次队列已满判断，如果已满则直接释放锁。在持有锁且队列未满的情况下，调用&lt;code&gt;enqueue&lt;/code&gt;入队方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;enqueue&lt;/code&gt;方法的实现也非常的简单，将当前尾节点的&lt;code&gt;next&lt;/code&gt;指针指向新节点，再把&lt;code&gt;last&lt;/code&gt;指向新节点：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;enqueue&lt;/span&gt;&lt;span&gt;(Node&amp;lt;E&amp;gt; node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    last = last.next = node;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;画一张图，方便你理解：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3181818181818182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicbHMNJReUCPWD7YZicg2iazjB7dVNXwG9IwKibXCkicH94Zjo2ssvxqRfuWVaPjB77JJGbf2z6pgtWTqA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;880&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在完成入队后，判断队列是否已满，如果未满则调用&lt;code&gt;notFull.signal()&lt;/code&gt;，唤醒等待将元素插入队列的线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;面试官：我记得在&lt;/span&gt;&lt;/strong&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;&lt;strong&gt;&lt;span&gt;里插入元素后，是调用的&lt;/span&gt;&lt;/strong&gt;&lt;code&gt;notEmpty.signal()&lt;/code&gt;&lt;span&gt;&lt;strong&gt;，怎么这里还不一样了？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：说到这，就不得不再提一下使用两把锁来分别控制插入和获取元素的好处了。在&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;中，使用了同一把锁对入队和出队进行控制，那么如果在插入元素后再唤醒插入线程，那么很有可能等待获取元素的线程就一直得不到唤醒，造成等待时间过长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;中，分别使用了入队锁&lt;code&gt;putLock&lt;/code&gt;和出队锁&lt;code&gt;takeLock&lt;/code&gt;，插入线程和获取线程是不会互斥的。所以插入线程可以在这里不断的唤醒其他的插入线程，而无需担心是否会使获取线程等待时间过长，从而在一定程度上提高了吞吐量。当然了，因为&lt;code&gt;offer&lt;/code&gt;方法是非阻塞的，并不会挂起阻塞线程，所以这里唤醒的是阻塞插入的&lt;code&gt;put&lt;/code&gt;方法的线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面试官：那接着往下看，为什么要在&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;c&lt;/code&gt;&lt;span&gt;&lt;strong&gt;等于0的情况下才去唤醒&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;notEmpty&lt;/code&gt;&lt;span&gt;&lt;strong&gt;中的等待获取元素的线程？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：其实获取元素的方法和上面插入元素的方法是一个模式的，只要有一个获取线程在执行方法，那么就会不断的通过&lt;code&gt;notEmpty.signal()&lt;/code&gt;唤醒其他的获取线程。只有当&lt;code&gt;c&lt;/code&gt;等于0时，才证明之前队列中已经没有元素，这时候获取线程才可能会被阻塞，在这个时候才需要被唤醒。上面的这些可以用一张图来说明：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6583850931677019&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicbHMNJReUCPWD7YZicg2iazjBjT5eUcUIAP5Tz6Lg2V8jkHJAX75s3JetJ3IrpvdMEkgKN4PEkTe2vQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;805&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们之前说过，队列中的&lt;code&gt;head&lt;/code&gt;节点可以认为是不存储数据的标志性节点，所以可以简单的认为出队时直接取出第二个节点，当然这个过程不是非常的严谨，我会在后面讲解出队的过程中再进行补充说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面试官：那么阻塞方法&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;put&lt;/code&gt;&lt;strong&gt;&lt;span&gt;和它有什么区别？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：&lt;code&gt;put&lt;/code&gt;和&lt;code&gt;offer&lt;/code&gt;方法整体思路一致，不同的是加锁是使用的是可被中断的方式，并且当队列中元素已满时，将线程加入&lt;code&gt;notFull&lt;/code&gt;等待队列中进行等待，代码中体现在：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt; (count.get() == capacity) {&lt;br/&gt;    notFull.await();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程体现在上面那张图的&lt;code&gt;notFull&lt;/code&gt;等待队列中的元素上，就不重复说明了。另外，和&lt;code&gt;put&lt;/code&gt;方法比较类似的，还有一个携带等待时间参数的&lt;code&gt;offer&lt;/code&gt;方法，可以进行有限时间内的阻塞添加，当超时后放弃插入元素，我们只看和&lt;code&gt;offer&lt;/code&gt;方法不同部分的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;offer&lt;/span&gt;&lt;span&gt;(E e, &lt;span&gt;long&lt;/span&gt; timeout, TimeUnit unit)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; nanos = unit.toNanos(timeout);&lt;span&gt;//转换为纳秒&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (count.get() == capacity) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nanos &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        nanos = notFull.awaitNanos(nanos);&lt;br/&gt;    }&lt;br/&gt;    enqueue(&lt;span&gt;new&lt;/span&gt; Node&amp;lt;E&amp;gt;(e));    &lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;awaitNanos&lt;/code&gt;方法在&lt;code&gt;await&lt;/code&gt;方法的基础上，增加了超时跳出的机制，会在循环中计算是否到达预设的超时时间。如果在到达超时时间前被唤醒，那么会返回超时时间减去已经消耗的时间。无论是被其他线程唤醒返回，还是到达指定的超时时间返回，只要方法返回值小于等于0，那么就认为它已经超时，最终直接返回&lt;code&gt;false&lt;/code&gt;结束。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.46511627906976744&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicbHMNJReUCPWD7YZicg2iazjBGFN6oNp4OvU99HoY7rIPsdmj02cgwZyofKCWUQgnzicCocgTOvxP7lg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;860&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面试官：费这么大顿功夫才把插入讲明白，我先喝口水，你接着说获取元素方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：……那先看非阻塞的&lt;code&gt;poll&lt;/code&gt;方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;poll&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; AtomicInteger count = &lt;span&gt;this&lt;/span&gt;.count;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (count.get() == &lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//队列为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    E x = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; c = -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; ReentrantLock takeLock = &lt;span&gt;this&lt;/span&gt;.takeLock;&lt;br/&gt;    takeLock.lock();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (count.get() &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;span&gt;//队列非空&lt;/span&gt;&lt;br/&gt;            x = dequeue();&lt;br/&gt;            &lt;span&gt;//出队前队列长队&lt;/span&gt;&lt;br/&gt;            c = count.getAndDecrement();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (c &amp;gt; &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;                notEmpty.signal();&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        takeLock.unlock();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (c == capacity)&lt;br/&gt;        signalNotFull();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出队的逻辑和入队的非常相似，当队列非空时就执行&lt;code&gt;dequeue&lt;/code&gt;进行出队操作，完成出队后如果队列仍然非空，那么唤醒等待队列中挂起的获取元素的线程。并且当出队前的元素数量等于队列长度时，在出队后唤醒等待队列上的添加线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出队方法&lt;code&gt;dequeue&lt;/code&gt;的源码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; E &lt;span&gt;dequeue&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Node&amp;lt;E&amp;gt; h = head;&lt;br/&gt;    Node&amp;lt;E&amp;gt; first = h.next;&lt;br/&gt;    h.next = h; &lt;span&gt;// help GC&lt;/span&gt;&lt;br/&gt;    head = first;&lt;br/&gt;    E x = first.item;&lt;br/&gt;    first.item = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前提到过，头节点&lt;code&gt;head&lt;/code&gt;并不存储数据，它的下一个节点才是真正意义上的第一个节点。在出队操作中，先得到头结点的下一个节点&lt;code&gt;first&lt;/code&gt;节点，将当前头结点的&lt;code&gt;next&lt;/code&gt;指针指向自己，代码中有一个简单的注释是&lt;code&gt;help gc&lt;/code&gt;，个人理解这里是为了降低&lt;code&gt;gc&lt;/code&gt;中的引用计数，方便它更早被回收。之后再将新的头节点指向&lt;code&gt;first&lt;/code&gt;，并返回清空为&lt;code&gt;null&lt;/code&gt;前的内容。使用图来表示是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3584905660377358&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicbHMNJReUCPWD7YZicg2iazjBI3fquOrcUnwwrZ6uRPUHVgRqWFqRfC8aWGyrIjQytfcSWzcArbewIA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;795&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;面试官：（看看手表）&lt;/span&gt;&lt;/strong&gt;&lt;code&gt;take&lt;/code&gt;&lt;span&gt;&lt;strong&gt;方法的整体逻辑也差不多，能简单概括一下吗&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：阻塞方法&lt;code&gt;take&lt;/code&gt;方法和&lt;code&gt;poll&lt;/code&gt;的思路基本一致，是一个可以被中断的阻塞获取方法，在队列为空时，会挂起当前线程，将它添加到条件对象&lt;code&gt;notEmpty&lt;/code&gt;的等待队列中，等待其他线程唤醒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;面试官：再给你一句话的时间，总结一下它和&lt;/span&gt;&lt;/strong&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;&lt;strong&gt;&lt;span&gt;的异同，我要下班回家了&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：好吧，我总结一下，有下面几点：&lt;/p&gt;&lt;section&gt;1、队列长度不同，&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;创建时需指定长度并且不可修改，而&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;可以指定也可以不指定长度&lt;/section&gt;&lt;section&gt;2、存储方式不同，&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;使用数组，而&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;使用&lt;code&gt;Node&lt;/code&gt;节点的链表&lt;/section&gt;&lt;section&gt;3、&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;使用一把锁来控制元素的插入和移除，而&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;将入队锁和出队锁分离，提高了并发性能&lt;/section&gt;&lt;section&gt;4、&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;采用数组存储元素，因此在插入和移除过程中不需要生成额外对象，&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;会生成新的&lt;code&gt;Node&lt;/code&gt;节点，对&lt;code&gt;gc&lt;/code&gt;会有影响&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面试官：明天上午9点，老地方，我们把队列问题贯彻到底&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：……&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c1bc1d74937a43c6b9fff6a91f94cc23</guid>
<title>Goroutine Local Storage 的一些实现方案和必要性讨论</title>
<link>https://toutiao.io/k/18kb0os</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Java的ThreadLocal是Java为每个线程提供的专用存储，把一些信息放在ThreadLocal上，可以用于来简化上层应用的API使用。一个显著的应用场景是，有了ThreadLocal后，就不需要在调用栈里的每个函数上都增加额外的参数来传递一些与调用链和日志链路追踪相关的上下文信息了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Go Team 针对增加LocalStorage的提案，明确说明过，他们更推荐显式地使用 Context 参数而不是使用LocalStorage来进行上下文信息的传递。社区里倒是有几个GLS（Goroutine Local Storage）的实现方案，&lt;strong&gt;我们团队也在系统里使用了GLS，应用后并没有明显的性能降低，主要还是不想在每个函数定义上都添加参数来传递用来做日志链路追踪的TraceId，但是并不建议业务逻辑依赖这些三方的GLS库&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;关于是否需要增加GLS的讨论以及GLS带来的性能和不兼容问题还是挺多的，正好看到一篇文章对 Go 语言是否该引入GLS的讨论进行了总结，在这里分享给大家。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文作者：兰陵子&lt;/p&gt;&lt;p&gt;原文链接：http://lanlingzi.cn/post/technical/2016/0813_go_gls/&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt; 背景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近在设计调用链与日志跟踪的API，发现相比于Java与C++，Go语言中没有原生的线程（协程）上下文，也不支持TLS（Thread Local Storage），更没有暴露API获取Goroutine的Id（后面简称&lt;code&gt;GoId&lt;/code&gt;）。这导致无法像Java一样，把一些信息放在TLS上，用于来简化上层应用的API使用：不需要在调用栈的函数中通过传递参数来传递调用链与日志跟踪的一些上下文信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java与C++中，TLS是一种机制，指存储在线程环境内的一个结构，用来存放该线程内独享的数据。进程内的线程不能访问不属于自己的TLS，这就保证了TLS内的数据在线程内是全局共享的，而对于线程外却是不可见的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中，JDK库提供&lt;code&gt;Thread.CurrentThread()&lt;/code&gt;来获取当前线程对象，提供&lt;code&gt;ThreadLocal&lt;/code&gt;来存储与获取线程局部变量。由于Java能通过&lt;code&gt;Thread.CurrentThread()&lt;/code&gt;获取当前线程，其实现的思路就很简单了，在ThreadLocal类中有一个Map，用于存储每一个线程的变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal的API提供了如下的4个方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public T get()&lt;br/&gt;protected  T initialValue()&lt;br/&gt;public void remove()&lt;br/&gt;public void set(T value)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;T get()&lt;/code&gt;:返回此线程局部变量的当前线程副本中的值，如果这是线程第一次调用该方法，则创建并初始化此副本。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;protected T initialValue()&lt;/code&gt;: 返回此线程局部变量的当前线程的初始值。最多在每次访问线程来获得每个线程局部变量时调用此方法一次，即线程第一次使用&lt;code&gt;get()&lt;/code&gt;方法访问变量的时候。如果线程先于&lt;code&gt;get&lt;/code&gt;方法调用&lt;code&gt;set(T)&lt;/code&gt;方法，则不会在线程中再调用&lt;code&gt;initialValue&lt;/code&gt;方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;void remove()&lt;/code&gt;: 移除此线程局部变量的值。这可能有助于减少线程局部变量的存储需求。如果再次访问此线程局部变量，那么在默认情况下它将拥有其 &lt;code&gt;initialValue&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;void set(T value)&lt;/code&gt;将此线程局部变量的当前线程副本中的值设置为指定值。许多应用程序不需要这项功能，它们只依赖于&lt;code&gt;initialValue()&lt;/code&gt;方法来设置线程局部变量的值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Go语言中，而Google提供的解决方法是采用&lt;code&gt;golang.org/x/net/context&lt;/code&gt;包来传递GoRoutine的上下文。对Go的Context的深入了解可参考我之前的分析：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247484263&amp;amp;idx=1&amp;amp;sn=9e51fea77e661353a85583137eb5dedd&amp;amp;chksm=fa80d2f0cdf75be6d6183edfdec4413ae1ecb63873063851f4e32004c50fbec7765d8aa9113e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;理解Go Context机制&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;理解Go Context机制&lt;/a&gt;。&lt;code&gt;Context&lt;/code&gt;也是能存储Goroutine一些数据达到共享，但它提供的接口是&lt;code&gt;WithValue&lt;/code&gt;函数来创建一个新的&lt;code&gt;Context&lt;/code&gt;对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func WithValue(parent Context, key interface{}, val interface{}) Context {&lt;br/&gt;return &amp;amp;valueCtx{parent, key, val}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;type valueCtx struct {&lt;br/&gt;Context&lt;br/&gt;key, val interface{}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (c *valueCtx) Value(key interface{}) interface{} {&lt;br/&gt;if c.key == key {&lt;br/&gt;return c.val&lt;br/&gt;}&lt;br/&gt;return c.Context.Value(key)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面代码中可以看出，&lt;code&gt;Context&lt;/code&gt;设置一次Value，就会产生一个&lt;code&gt;Context&lt;/code&gt;对象，获取Value是先找当前&lt;code&gt;Context&lt;/code&gt;存储的值，若没有再向父一级查找。获取&lt;code&gt;Value&lt;/code&gt;可以说是多Goroutine访问安全，因为它的接口设计上，是只一个Goroutine&lt;strong&gt;一次&lt;/strong&gt;设置&lt;code&gt;Key/Value&lt;/code&gt;，其它多Goroutine只能读取&lt;code&gt;Key&lt;/code&gt;的&lt;code&gt;Value&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么无获取GoId接口&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;This, among other reasons, to prevent programmers for simulating thread local storage using the goroutine id as a key.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方说，就为了避免采用&lt;code&gt;Goroutine Id&lt;/code&gt;当成&lt;code&gt;Thread Local Storage&lt;/code&gt;的&lt;code&gt;Key&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Please don’t use goroutine local storage. It’s highly discouraged. In fact, IIRC, we used to expose Goid, but it is hidden since we don’t want people to do this.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户经常使用GoId来实现&lt;code&gt;goroutine local storage&lt;/code&gt;，而Go语言不希望用户使用&lt;code&gt;goroutine local storage&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;when goroutine goes away, its goroutine local storage won’t be GCed. (you can get goid for the current goroutine, but you can’t get a list of all running goroutines)&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不建议使用&lt;code&gt;goroutine local storage&lt;/code&gt;的原因是由于不容易GC，虽然能获当前的GoId，但不能获取其它正在运行的Goroutine。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;what if handler spawns goroutine itself? the new goroutine suddenly loses access to your goroutine local storage. You can guarantee that your own code won’t spawn other goroutines, but in general you can’t make sure the standard library or any 3rd party code won’t do that.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个重要的原因是由于产生一个Goroutine非常地容易（而线程通用会采用线程池），新产生的Goroutine会失去访问&lt;code&gt;goroutine local storage&lt;/code&gt;。需要上层应用保证不会产生新的Goroutine，但我们很难确保标准库或第三库不会这样做。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;thread local storage is invented to help reuse bad/legacy code that assumes global state, Go doesn’t have legacy code like that, and you really should design your code so that state is passed explicitly and not as global (e.g. resort to goroutine local storage)&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TLS的应用是帮助重用现有那些不好（遗留）的采用全局状态的代码。而Go语言建议是重新设计代码，采用显示地传递状态而不是采用全局状态（例如采用&lt;code&gt;goroutine local storage&lt;/code&gt;）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其它手段获取GoId&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然Go语言有意识地隐藏GoId，但目前还是有手段来获取GoId：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;修改源代码暴露GoId，但Go语言可能随时修改源码，导致不兼容&lt;/p&gt;&lt;p&gt;在标准库的&lt;code&gt;runtime/proc.go&lt;/code&gt;（Go 1.6.3）中的&lt;code&gt;newextram&lt;/code&gt;函数，会产生个GoId：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;mp.lockedg = gp&lt;br/&gt;gp.lockedm = mp&lt;br/&gt;gp.goid = int64(atomic.Xadd64(&amp;amp;sched.goidgen, 1))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过&lt;code&gt;runtime.Stack&lt;/code&gt;来分析Stack输出信息获取GoId。&lt;/p&gt;&lt;p&gt;在标准库的&lt;code&gt;runtime/mprof.go&lt;/code&gt;（Go 1.6.3）中，&lt;code&gt;runtime.Stack&lt;/code&gt;会获取gp对象(包含GoId)并输出整个Stack信息：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;func Stack(buf []byte, all bool) int {&lt;br/&gt;    if all {&lt;br/&gt;        stopTheWorld(&quot;stack trace&quot;)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    n := 0&lt;br/&gt;    if len(buf) &amp;gt; 0 {&lt;br/&gt;        gp := getg()&lt;br/&gt;        sp := getcallersp(unsafe.Pointer(&amp;amp;buf))&lt;br/&gt;        pc := getcallerpc(unsafe.Pointer(&amp;amp;buf))&lt;br/&gt;        systemstack(func() {&lt;br/&gt;            g0 := getg()&lt;br/&gt;            g0.m.traceback = 1&lt;br/&gt;            g0.writebuf = buf[0:0:len(buf)]&lt;br/&gt;            goroutineheader(gp)&lt;br/&gt;            traceback(pc, sp, 0, gp)&lt;br/&gt;            if all {&lt;br/&gt;                tracebackothers(gp)&lt;br/&gt;            }&lt;br/&gt;            g0.m.traceback = 0&lt;br/&gt;            n = len(g0.writebuf)&lt;br/&gt;            g0.writebuf = nil&lt;br/&gt;        })&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    if all {&lt;br/&gt;        startTheWorld()&lt;br/&gt;    }&lt;br/&gt;    return n&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从文件名就可以看出，&lt;code&gt;runtime/mprof.go&lt;/code&gt;是用于做Profile分析，获取Stack肯定性能不会太好。从上面的代码来看，若第二个参数指定为true，还会STW，业务系统无论如何都无法接受。若Go语言修改了Stack的输出，分析Stack信息也会导致无法正常获取GoId。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通用&lt;code&gt;runtime.Callers&lt;/code&gt;来给调用Stack来打标签&lt;/p&gt;&lt;p&gt;代码参考：https://github.com/jtolds/gls/blob/master/stack_tags_main.go#L43&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过内联c或者内联汇编&lt;/p&gt;&lt;p&gt;go版本1.5，x86_64arc下汇编，估计也不通用&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;// func GoID() int64&lt;br/&gt;TEXT s3lib GoID(SB),NOSPLIT,$0-8&lt;br/&gt;MOVQ TLS, CX&lt;br/&gt;MOVQ 0(CX)(TLS*1), AX&lt;br/&gt;MOVQ AX, ret+0(FP)&lt;br/&gt;RET&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开源goroutine local storage实现&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要有机制获取GoId，就可以像Java一样来采用全局的map实现&lt;code&gt;goroutine local storage&lt;/code&gt;，在Github上搜索一下，发现有两个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;tylerb/gls&lt;/p&gt;&lt;p&gt;GoId是通过&lt;code&gt;runtime.Stack&lt;/code&gt;来分析Stack输出信息获取GoId。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;jtolds/gls&lt;/p&gt;&lt;p&gt;GoId是通用&lt;code&gt;runtime.Callers&lt;/code&gt;来给调用Stack来打标签&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个有人在2013年测试过性能，数据如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;BenchmarkGetValue 500000 2953 ns/op &lt;/p&gt;&lt;p&gt;BenchmarkSetValues 500000 4050 ns/op&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的测试结果看似还不错，但&lt;code&gt;goroutine local storage&lt;/code&gt;实现无外乎是&lt;code&gt;map+RWMutex&lt;/code&gt;，存在性能瓶颈：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Goroutine不像Thread，它的个数可以上十万并发，当这么多的Goroutine同时竞争同一把锁时，性能会急剧恶化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GoId是通过分析调用Stack的信息来获取，也是一个高成本的调用，一个字：慢。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管怎么样，没有官方的GLS，的确不是很方便，第三方实现又存在性能与不兼容风险。连&lt;code&gt;jtolds/gls&lt;/code&gt;作者也贴出其它人的评价：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;“Wow, that’s horrifying.”&lt;/p&gt;&lt;p&gt;“This is the most terrible thing I have seen in a very long time.”&lt;/p&gt;&lt;p&gt;“Where is it getting a context from? Is this serializing all the requests? What the heck is the client being bound to? What are these tags? Why does he need callers? Oh god no. No no no.”&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go语言官方认为TLS来存储全局状态是不好的设计，而是要显示地传递状态。Google给的解决方法是&lt;code&gt;golang.org/x/net/context&lt;/code&gt;。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzNTY5MzU2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4pGhLz2xEbRFHnAQon2QLYgbBibCJo1ibJHesLWshPJeRibateRtAqkaf6BgjlbhYiaxHLq6Zu07CRPw/0?wx_fmt=png&quot; data-nickname=&quot;网管叨bi叨&quot; data-alias=&quot;kevin_tech&quot; data-signature=&quot;每周分享技术类原创文章&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>