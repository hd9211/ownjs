<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9273932874fc786e9ac675d3ab0f6936</guid>
<title>浅谈如何搭建知识体系 | 码农周刊第 319 期</title>
<link>https://toutiao.io/k/dufazik</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;浅谈如何搭建知识体系 | 码农周刊第 319 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第319期（2020-09-23）&lt;/h2&gt;
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3190&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_316.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19803&amp;amp;url=https%3A%2F%2Fwww.sheca.com%2Fassets%2Fwwx%2Fpage1.html%3Fsite%3Dkaifazhe02&quot; target=&quot;_blank&quot;&gt;SHECA 提供 SSL 证书一站式服务，为你的网络安全保驾护航，上海 CA 权威认证&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;HDFS + Clickhouse + Spark&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;致力于提供一套简单方便、专业可靠、无限可能的 H5 落地页最佳实践。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;9NFL 是京东自研的联邦学习平台。整个平台的内核基于 TensorFlow，并根据业务进行了性能优化，调度则基于 k8s。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;ChatUI 是由达摩院阿里小蜜孵化的对话式界面组件，目前支持阿里经济体 80 多个事业部，数千个 Chatbot，承载着达摩院前沿技术，专注于智能对话领域的设计和技术研发体系，应用至消费者可体验的对话式界面。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;适合新手&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;模型性能杀器解读&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;有用&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;深入讲解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;第二弹&lt;/p&gt;
        
        &lt;p&gt;customize personal network&lt;/p&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://github.com/aweiu/scroll-switch&quot; target=&quot;_blank&quot;&gt;GitHub 地址&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;两种不错的思路&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://golang.design/history/&quot; target=&quot;_blank&quot;&gt;文档地址&lt;/a&gt;&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一枚有趣的程序员&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 436138 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;致力于为企业提供性能优化领域的全方位解决方案&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 423497 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;分享一些信息安全相关的文章&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 393298 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;编程、成长、正能量！&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 381811 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;分享Go语言相关内容&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 133906 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=319&amp;amp;aid=19892&amp;amp;url=http%3A%2F%2Fstore.dangdang.com%2Fgys_04001_3tk3&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_319.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;擦亮慧眼&lt;/p&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ea242feaff4ff5361472afa10d756a6d</guid>
<title>十佳 AI 产品工具，为生活添彩</title>
<link>https://toutiao.io/k/7j8f97c</link>
<content:encoded>&lt;div&gt;&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;/&gt;
  

    &lt;title&gt;十佳 AI 产品工具，为生活添彩 | 晚晴幽草轩&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;/&gt;
    
    &lt;meta name=&quot;author&quot; content=&quot;晚晴幽草轩轩主&quot;/&gt;
    
    &lt;meta name=&quot;theme-color&quot; content=&quot;#fffffb&quot;/&gt;
    &lt;meta name=&quot;baidu-site-verification&quot; content=&quot;PKEtLPjO56&quot;/&gt;
    

    &lt;meta name=&quot;keywords&quot; content=&quot;网站, 倾城之链, 图标, ICON, icons, 新世界, 产品, svg, icon font, png, jpg, 图标搜索引擎, Iconfont, 图标下载&quot;/&gt;
    &lt;meta name=&quot;description&quot; content=&quot;随着第四次工业革命的来临，人工智能（AI）已经从科幻逐步走入现实，成为人尽皆知的概念；智能支付、无人超市、AI 美图已然融入日常生活，更有 AI 写作，邮件智能助理等四处开花；除此之外，人工智能在 Web 应用这一块，也不遑多让：如智能网页设计排版，PPT 制作，音乐艺术，图片处理，应用配色，文字翻译等相关应用已在市场掀起波澜，层出不穷的设计让人叹为观止。这里整理了倾城之链所收录的，可为生活添彩的&quot;/&gt;
&lt;meta property=&quot;og:type&quot; content=&quot;article&quot;/&gt;
&lt;meta property=&quot;og:title&quot; content=&quot;十佳 AI 产品工具，为生活添彩&quot;/&gt;
&lt;meta property=&quot;og:url&quot; content=&quot;https://www.jeffjade.com/2020/09/23/170-list-of-top-20-ai-product-tools/index.html&quot;/&gt;
&lt;meta property=&quot;og:site_name&quot; content=&quot;晚晴幽草轩&quot;/&gt;
&lt;meta property=&quot;og:description&quot; content=&quot;随着第四次工业革命的来临，人工智能（AI）已经从科幻逐步走入现实，成为人尽皆知的概念；智能支付、无人超市、AI 美图已然融入日常生活，更有 AI 写作，邮件智能助理等四处开花；除此之外，人工智能在 Web 应用这一块，也不遑多让：如智能网页设计排版，PPT 制作，音乐艺术，图片处理，应用配色，文字翻译等相关应用已在市场掀起波澜，层出不穷的设计让人叹为观止。这里整理了倾城之链所收录的，可为生活添彩的&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.beautiful.ai.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/tara.ai.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.deepl.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.synthesia.io.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.unscreen.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.aiva.ai.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.remove.bg.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/slazzer.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/bigjpg.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.pickpik.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/khroma.co.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.myquark.cn.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/magi.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.allhistory.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/300/h/300/interlace/1/ignore-error/1&quot;/&gt;
&lt;meta property=&quot;og:updated_time&quot; content=&quot;2020-09-23T06:15:42.778Z&quot;/&gt;
&lt;meta name=&quot;twitter:card&quot; content=&quot;summary&quot;/&gt;
&lt;meta name=&quot;twitter:title&quot; content=&quot;十佳 AI 产品工具，为生活添彩&quot;/&gt;
&lt;meta name=&quot;twitter:description&quot; content=&quot;随着第四次工业革命的来临，人工智能（AI）已经从科幻逐步走入现实，成为人尽皆知的概念；智能支付、无人超市、AI 美图已然融入日常生活，更有 AI 写作，邮件智能助理等四处开花；除此之外，人工智能在 Web 应用这一块，也不遑多让：如智能网页设计排版，PPT 制作，音乐艺术，图片处理，应用配色，文字翻译等相关应用已在市场掀起波澜，层出不穷的设计让人叹为观止。这里整理了倾城之链所收录的，可为生活添彩的&quot;/&gt;
&lt;meta name=&quot;twitter:image&quot; content=&quot;https://oss.nicelinks.site/www.beautiful.ai.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta name=&quot;twitter:creator&quot; content=&quot;@nicejadeyang&quot;/&gt;

    
    
    
    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    

    
    
    
    
    
    
&lt;/head&gt;&lt;/html&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1f1efe9eef72a40ed6508fec04464031</guid>
<title>轻松玩转函数式编程</title>
<link>https://toutiao.io/k/zmm264v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近和一些同学讨论了函数式编程，很多同学总觉得听起来很高大上，但用起来却无从下手。于是我抽时间捋了捋，将平时工作中用到的函数式编程案例和思想整理了出来，相信阅读本文后，大家都能快速上手函数式编程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数式编程目前使用范围非常广，常用的框架，语言几乎都能看到它的身影。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;前端框架：react、vue 的 hooks 用法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;打包工具：webpack 的 webpack-chain 用法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;工具库：underscore、lodash、ramda。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部署方式：serverless。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后端：java、c# 中的 lamda 表达式。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将通过以下 3 个部分来深入函数式编程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;编程范式&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;编程范式&lt;/strong&gt; 指的是一种编程风格，它描述了程序员对程序执行的看法。在编程的世界中，同一个问题，可以站在多个角度去分析解决，这些不同的解决方案就对应了不同的编程风格。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的编程范式有：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;命令式编程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;命令式编程&lt;/strong&gt; 是使用最广的一种编程风格，它是站在计算机的角度去思考问题，主要思想是 &lt;strong&gt;关注计算机执行的步骤，即一步一步告诉计算机先做什么再做什么&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于存在很多需要控制的步骤，所以命令式编程普遍存在以下特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;控制语句&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;循环语句：while、for&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;条件分支语句：if else、switch&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无条件分支语句：return、break、continue&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;变量&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据这些特点，我们来分析一个命令式编程案例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 需求：筛选出数组中为奇数的子集合&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; array = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;// 步骤1：定义执行结果变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; reult = [];&lt;br/&gt;&lt;span&gt;// 步骤2：控制程序循环调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; array.length; i++) {&lt;br/&gt;  &lt;span&gt;// 步骤3：判断筛选条件&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (array[i] % &lt;span&gt;2&lt;/span&gt; !== &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// 步骤4：加入执行结果&lt;/span&gt;&lt;br/&gt;    reult.push(array[i]);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 步骤5：得到最终的结果 result&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码通过 5 个步骤，实现了数组的筛选，这并没有什么问题，但细心的同学可能会感到疑惑：这样写的代码量太长了，而且并不语义化，只有阅读完每一行的代码，才知道具体执行的是什么逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，这就是命令式编程的典型特点，除此之外，还有以下几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;命令式编程的每一个步骤都可以由程序员定义，这样可以更精细化、更严谨地控制代码，从而提高程序的性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命令式编程的每一个步骤都可以记录中间结果，方便调试代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命令式编程需要大量的流程控制语句，在处理多线程状态同步问题时，容易造成逻辑混乱，通常需要加锁来解决。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;声明式编程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;声明式编程&lt;/strong&gt; 同样是一种编程风格，它通过定义具体的规则，以便系统底层可以自动实现具体功能。主要思想是 &lt;strong&gt;告诉计算机应该做什么，但不指定具体要怎么做&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于需要定义规则来表达含义，所以声明式编程普遍存在以下特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;代码更加语义化，便于理解。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码量更少。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不需要流程控制代码，如：for、while、if 等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们将上文中的数组筛选，用声明式的方式重构一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 筛选出数组中为奇数的子集合&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; array = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; reult = array.filter(&lt;span&gt;(&lt;span&gt;item&lt;/span&gt;) =&amp;gt;&lt;/span&gt; item % &lt;span&gt;2&lt;/span&gt; !== &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，声明式编程没有冗余的操作步骤，代码量非常少，并且非常语义化，当我们读到 filter 的时候，自然而然就知道是在做筛选。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再看一个案例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 使用 sql 语句，查询 id 为 25 的学生&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; students &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;25&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述代码中，我们只是告诉计算机，我想查找 id 为 25 的同学，计算机就能给我们返回对应的数据了，至于是怎么查找出来的，我们并不需要关心，只要结果是正确的即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上述例子之外，还有很多声明式编程的案例：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;html 用来声明了网页的内容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;css 用来声明网页中元素的外观。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;正则表达式，声明匹配的规则。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了以上几个案例，我们来总结一下声明式编程的优缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;声明式编程不需要编写复杂的操作步骤，可以大大减少开发者的工作量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;声明式编程的具体操作都是底层统一管理，可以降低重复工作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;声明式编程底层实现的逻辑并不可控，不适合做更精细化的优化。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;函数式编程&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;函数式编程&lt;/strong&gt; 属于声明式编程中的一种，它的主要思想是 &lt;strong&gt;将计算机运算看作为函数的计算&lt;/strong&gt;，也就是把程序问题抽象成数学问题去解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数式编程中，我们可以充分利用数学公式来解决问题。也就是说，任何问题都可以通过函数（加减乘除）和数学定律（交换律、结合律等），一步一步计算，最终得到答案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数式编程中，所有的变量都是唯一的值，就像是数学中的代数 x、y，它们要么还未解出来，要么已经被解出为固定值，所以对于：&lt;code&gt;x=x+1&lt;/code&gt; 这样的自增是不合法的，因为修改了代数值，不符合数学逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，严格意义上的函数式编程也不包括循环、条件判断等控制语句，如果需要条件判断，可以使用三元运算符代替。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章开头我们提到了 webpack-chain，我们一起来看一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 使用 webpack-chain 来编写 webpack 配置。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; Config = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;webpack-chain&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; config = &lt;span&gt;new&lt;/span&gt; Config();&lt;br/&gt;config.&lt;br/&gt;    .entry(&lt;span&gt;&#x27;index&#x27;&lt;/span&gt;)&lt;br/&gt;        .add(&lt;span&gt;&#x27;src/index.js&#x27;&lt;/span&gt;)&lt;br/&gt;        .end()&lt;br/&gt;    .output&lt;br/&gt;         .path(&lt;span&gt;&#x27;dist&#x27;&lt;/span&gt;)&lt;br/&gt;         filename(&lt;span&gt;&#x27;my-first-webpack.bundle.js&#x27;&lt;/span&gt;);&lt;br/&gt;config.module&lt;br/&gt;    .rule(&lt;span&gt;&#x27;compile&#x27;&lt;/span&gt;)&lt;br/&gt;        .test(&lt;span&gt;/\.js$/&lt;/span&gt;)&lt;br/&gt;        .use(&lt;span&gt;&#x27;babel&#x27;&lt;/span&gt;)&lt;br/&gt;        .loader(&lt;span&gt;&#x27;babel-loader&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = config;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，webpack-chain 可以通过链式的函数 api 来创建和修改 webpack 配置，从而更方便地创建和修改 webpack 配置。试想一下，如果一份 webpack 配置需要用于多个项目，但每个项目又有一些细微的不同配置，这个应该怎么处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用 webpack-chain 去修改配置，一个函数 api 就搞定了，而使用命令式的编程，则需要去逐步遍历整个 webpack 配置文件，找出需要修改的点，才能进行修改，这无疑就大大减少了我们的工作量。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;函数式编程的特点&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据维基百科权威定义，函数式编程有以下几个特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;函数是一等公民&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;函数可以和变量一样，可以赋值给其他变量，也可以作为参数，传入一个函数，或者作为别的函数返回值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;只用表达式，不用语句：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;表达式是一段单纯的运算过程，总是有返回值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语句是执行某种操作，没有返回值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;也就是说，函数式编程中的每一步都是单纯的运算，而且都有返回值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;无副作用&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不会产生除运算以外的其他结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同一个输入永远得到同一个数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;不可变性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引用透明&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上的特点都是函数式编程的核心，基于这些特点，又衍生出了许多应用场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;纯函数：同样的输入得到同样的输出，无副作用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;函数组合：将多个依次调用的函数，组合成一个大函数，简化操作步骤。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高阶函数：可以加工函数的函数，接收一个或多个函数作为输入、输出一个函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;闭包：函数作用域嵌套，实现的不同作用域变量共享。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;柯里化：将一个多参数函数转化为多个嵌套的单参数函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;偏函数：缓存一部分参数，然后让另一些参数在使用时传入。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;惰性求值：预先定义多个操作，但不立即求值，在需要使用值时才去求值，可以避免不必要的求值，提升性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;递归：控制函数循环调用的一种方式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尾递归：避免多层级函数嵌套导致的内存溢出的优化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;链式调用：让代码更加优雅。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些应用场景都大量存在于我们的日常工作中，接下来我们通过几个案例来实战一下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;函数式编程常见案例&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于函数式编程的应用场景，我们来实现几个具体的案例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、函数组合，组合多个函数步骤。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;compose&lt;/span&gt;(&lt;span&gt;f, g&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; f.call(&lt;span&gt;this&lt;/span&gt;, g.apply(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;arguments&lt;/span&gt;));&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;toLocaleUpperCase&lt;/span&gt;(&lt;span&gt;str&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; str.toLocaleUpperCase();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;toSigh&lt;/span&gt;(&lt;span&gt;str&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; str + &lt;span&gt;&quot;!&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 将多个函数按照先后执行顺序组合成一个函数，简化多个调用步骤。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; composedFn = compose(toSigh, toLocaleUpperCase);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;函数组合：&quot;&lt;/span&gt;, composedFn(&lt;span&gt;&quot;msx&quot;&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;// 函数组合：MSX!&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、柯里化，将一个多参数函数转化为多个嵌套的单参数函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 柯里化&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;curry&lt;/span&gt;(&lt;span&gt;targetfn&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; numOfArgs = targetfn.length;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn&lt;/span&gt;(&lt;span&gt;...rest&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (rest.length &amp;lt; numOfArgs) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; fn.bind(&lt;span&gt;null&lt;/span&gt;, ...rest);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; targetfn.apply(&lt;span&gt;null&lt;/span&gt;, rest);&lt;br/&gt;    }&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 加法函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;a, b, c, d&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; a + b + c + d;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 将一个多参数函数转化为多个嵌套的单参数函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;柯里化：&quot;&lt;/span&gt;, curry(add)(&lt;span&gt;1&lt;/span&gt;)(&lt;span&gt;2&lt;/span&gt;)(&lt;span&gt;3&lt;/span&gt;)(&lt;span&gt;4&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;// 柯里化：10&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、偏函数，缓存一部分参数，然后让另一些参数在使用时传入。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 偏函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;isTypeX&lt;/span&gt;(&lt;span&gt;type&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;obj&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt;.prototype.toString.call(obj) === &lt;span&gt;`[object &lt;span&gt;${type}&lt;/span&gt;]`&lt;/span&gt;;&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 缓存一部分参数，然后让另一些参数在使用时传入。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; isObject = isTypeX(&lt;span&gt;&quot;Object&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; isNumber = isTypeX(&lt;span&gt;&quot;Number&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;偏函数测试：&quot;&lt;/span&gt;, isObject({ &lt;span&gt;a&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt; }, &lt;span&gt;123&lt;/span&gt;)); &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;偏函数测试：&quot;&lt;/span&gt;, isNumber(&lt;span&gt;1&lt;/span&gt;)); &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、惰性求值，预先定义多个操作，但不立即求值，在需要使用值时才去求值，可以避免不必要的求值，提升性能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 这里使用 C# 中的 LINQ 来演示&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 假设数据库中有这样一段数据 db.Gems [4,15,20,7,3,13,2,20];&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; q =&lt;br/&gt;    db.Gems&lt;br/&gt;    .Select(c =&amp;gt; c &amp;lt; &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;   .Take(&lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;// 只要不调用 ToList 就不会求值&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// 在具体求值的时候，会将预先定义的方法进行优化整合，以产生一个最优的解决方案，才会去求值。&lt;/span&gt;&lt;br/&gt;    .ToList();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述代码中，传统的求值会遍历 2 次，第一次遍历整个数组（8 项），筛选出小于 10 的项，输出 &lt;code&gt;[4,7,3,2]&lt;/code&gt;，第二次遍历这个数组（4 项），输出 &lt;code&gt;[4,7,3]&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用惰性求值，则会将预先定义的所有操作放在一起进行判断，所以只需要遍历 1 次就可以了。在遍历的同时判断 &lt;code&gt;是否小于 10&lt;/code&gt; 和 &lt;code&gt;小于 10 的个数是否为 3&lt;/code&gt;，当遍历到第 5 项时，就能输出 &lt;code&gt;[4,7,3]&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比传统求值遍历的 8+4=12 项，使用惰性求值则只需遍历 5 项，程序的运行效率也就自然而然地得到了提升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、高阶函数，可以加工函数的函数（接收一个或多个函数作为输入、输出一个函数）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// React 组件中，将一个组件，封装为带默认背景色的新组件。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// styled-components 就是这个原理&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;withBackgroundRedColor&lt;/span&gt; (&lt;span&gt;wrapedComponent&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Component&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    render () {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;{backgroundColor:&lt;/span&gt; &#x27;&lt;span&gt;red&lt;/span&gt;} &amp;gt;&lt;/span&gt;&lt;br/&gt;                 &lt;span&gt;&amp;lt;&lt;span&gt;wrapedComponent&lt;/span&gt; {&lt;span&gt;...this.props&lt;/span&gt;} /&amp;gt;&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、递归和尾递归。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 普通递归，控制函数循环调用的一种方式。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fibonacci&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (n === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (n === &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; fibonacci(n - &lt;span&gt;1&lt;/span&gt;) + fibonacci(n - &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;没有使用尾递归，导致栈溢出&quot;&lt;/span&gt;, fibonacci(&lt;span&gt;100&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 尾递归，避免多层级函数嵌套导致的内存溢出的优化。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fibonacci2&lt;/span&gt;(&lt;span&gt;n, result, preValue&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; fibonacci2(n - &lt;span&gt;1&lt;/span&gt;, preValue, result + preValue);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// result = 0, preValue = 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;使用了尾递归，不会栈溢出&quot;&lt;/span&gt;, fibonacci2(&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、链式调用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// lodash 中，一个方法调用完成之后，可以继续链式调用其他的方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; users = [&lt;br/&gt;  { &lt;span&gt;user&lt;/span&gt;: &lt;span&gt;&quot;barney&quot;&lt;/span&gt;, &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;36&lt;/span&gt; },&lt;br/&gt;  { &lt;span&gt;user&lt;/span&gt;: &lt;span&gt;&quot;fred&quot;&lt;/span&gt;, &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;40&lt;/span&gt; },&lt;br/&gt;  { &lt;span&gt;user&lt;/span&gt;: &lt;span&gt;&quot;pebbles&quot;&lt;/span&gt;, &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt; },&lt;br/&gt;];&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; youngest = _.chain(users)&lt;br/&gt;  .sortBy(&lt;span&gt;&quot;age&quot;&lt;/span&gt;)&lt;br/&gt;  .map(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;o&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; o.user + &lt;span&gt;&quot; is &quot;&lt;/span&gt; + o.age;&lt;br/&gt;  })&lt;br/&gt;  .head()&lt;br/&gt;  .value();&lt;br/&gt;&lt;span&gt;// =&amp;gt; &#x27;pebbles is 1&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;思考与总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从编程范式开始，分析了函数式编程的定位，进一步引申出函数式编程的概念，然后基于一些工作中的案例，实战了函数式编程的应用场景，希望大家都能轻松地认识函数式编程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，如果你对此有任何想法，欢迎留言评论！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SM05zvmibH7KVsb0AmaBOr9GiblgWGMZnRqWN8yslvcTauwHNfq6XzyicXiaLy4UHPASyyvRtvB0LyAia67mABPVm7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ac4c6eec3c88ee3ce3dfd420d2a8eb4</guid>
<title>资料 |《JavaScript 20 年》</title>
<link>https://toutiao.io/k/fgeg3yt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bf6ebce7b0ff1a30ed07fa4fa77838dc</guid>
<title>谈谈前后端分离及认证选择</title>
<link>https://toutiao.io/k/xza2iwi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-outdated&quot;&gt;
    &lt;div class=&quot;hint&quot;&gt;
      &lt;p&gt;【注意】最后更新于 &lt;span class=&quot;timeago&quot; datetime=&quot;2020-06-04T00:00:00&quot; title=&quot;June 4, 2020&quot;&gt;June 4, 2020&lt;/span&gt;，文中内容可能已过时，请谨慎使用。&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
    &lt;div class=&quot;post-content&quot;&gt;
      &lt;p&gt;前几年，web开发领域中「前后端分离」比较火，现如今已逐渐成为事实标准。但是究竟什么是前后端分离？又为什么要前后端分离呢？&lt;/p&gt;
&lt;h2 id=&quot;什么是前后端分离为什么要前后端分离&quot;&gt;什么是前后端分离？为什么要前后端分离？&lt;/h2&gt;
&lt;p&gt;前后端分离，说的更多的是一种架构上的概念。在传统的web架构中，比如经典的MVC，会分数据层、逻辑层、视图层。这个视图层即我们所说的前端了，映射到代码层面，就是html、js、css等代码文件。数据层和逻辑层更多的是后端部分，例如我们的 &lt;code&gt;.java&lt;/code&gt; 、&lt;code&gt;.go&lt;/code&gt;、&lt;code&gt;.py&lt;/code&gt;等文件。这些文件会在一个工程中，并不会单独的开发、测试、部署。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/static/imgs/jwt_cookie/mvc.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在前后端分离的架构中，前端和后端是分开的，分别在不同的工程中。前端有专门的前端开发人员来进行开发、测试，后端则有后端开发人员来进行开发、测试，他们之间通过API来交互。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/static/imgs/jwt_cookie/back_frond.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前后端分离有这么几个好处：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1/ 解耦了前后端的工作人员&lt;/strong&gt; 让前端和后端分别交给更擅长的人来做，细化了工种，可以更加的专精。前端人员来关心用户体验、UI设计、交互渲染；后端人员更关注业务逻辑、性能保障、安全等方面。在项目进度方面，前后端可以并行开发，而互不影响，加快了整体的项目进度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2/ 解耦了前后端的代码&lt;/strong&gt; 后端只需提供API服务，不再与静态文件交互。后端可以使用更复杂的分布式、微服务架构，提供更好的性能和稳定性保障。同时前端除了PC端之外，移动端也可以使用相同的一套后端服务。&lt;/p&gt;
&lt;p&gt;看到这里，前后端分离被广泛应用也可以理解了。&lt;/p&gt;
&lt;p&gt;大家需要注意，并不是所有的项目都需要前后端分离，像是大型的项目，开发人员很多，人员分工明确，这种团队配置下，使用前后端分离可增加工作效率提高系统质量。但是团队人员少，分工不那么明确的情况下，再采用前后端分离的架构，只会增加开发成本和系统复杂度。前后端分离是一个好的架构思路，但是需要看具体的业务和人员情况，切勿盲目的跟从。&lt;/p&gt;
&lt;h2 id=&quot;前后端分离常用的认证方式&quot;&gt;前后端分离常用的认证方式&lt;/h2&gt;
&lt;p&gt;前后端分离中前后端的交互是通过API进行的，那么其中的认证是少不了的。前后端分离中常用的认证方式有下面几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Session-Cookie&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Token 验证&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OAuth(开放授权)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;session-cookie-方式&quot;&gt;Session-Cookie 方式&lt;/h3&gt;
&lt;p&gt;Session-Cookie 方式是我们开发web应用时最常用的认证方式。它的认证过程一般是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/static/imgs/jwt_cookie/session_cookie.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1/ 用户浏览器向服务器发起认证请求，将用户名和密码发送给服务器。&lt;/li&gt;
&lt;li&gt;2/ 服务器认证用户名和密码，若通过则创建一个session对话，并将用户信息保存到session中。session的信息可以是保存到服务器文件、共享外部存储、数据库等存储中，等下次请求时查询验证使用。&lt;/li&gt;
&lt;li&gt;3/ 服务器会将该session的唯一标识ID，返回给用户浏览器，并保存在cookie中。&lt;/li&gt;
&lt;li&gt;4/ 用户请求其他页面时，浏览器会自动将用户的cookie携带上，并发起接口请求，服务端收到请求后，从cookie解析出sessionID， 根据这个sessionID 查询登录后并保存好的session，若有则说明用户已登录，放行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该方式是MVC架构中最常用的认证方案，在前后端分离中也是可以用的。几乎所有的Web框架都默认集成了Session-Cookie的认证方式，而且对Session-Cookie方式的安全性和稳定性方面都有很成熟的处理方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当前端代码使用后端web框架当做web容器驱动时，Session-Cookie 方案可作为首选的认证方案。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;token-方式&quot;&gt;Token 方式&lt;/h3&gt;
&lt;p&gt;Token 方式是不同系统交互、前后端架构常用的认证方式。Token 方式的认证流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/static/imgs/jwt_cookie/token.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1/ 用户使用用户名和密码登录，将用户名和密码发送给服务器。&lt;/li&gt;
&lt;li&gt;2/ 服务器验证用户名和密码，若正确，则签发token，返回给用户。&lt;/li&gt;
&lt;li&gt;3/ 用户收到token后，将其存储起来，web服务一般为localStrage 或cookie。&lt;/li&gt;
&lt;li&gt;4/ 用户请求其他资源页面时，会携带token，一般放到header 或参数中，发送给服务端。&lt;/li&gt;
&lt;li&gt;5/ 服务器收到后，验证token，判断用户的正确性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JWT(JSON Web Token)是最常用的一种Token认证方式，已成为Token认证的标准事实。JWT 方式将Token 分段，使其可以保持少量数据，还增加了签名验证，确保了token的安全性。JWT 网上介绍的资料很多，这里不再赘述。不了解的，可参考下边这些资料：&lt;/p&gt;

&lt;h3 id=&quot;oauth-方式&quot;&gt;OAuth 方式&lt;/h3&gt;
&lt;p&gt;OAuth（Open Authorization）是一个开放标准，允许用户授权第三方网站访问他们存储在服务端的用户信息。我们常见的的QQ、微信等第三方登录便是Auth认证方式。OAuth协议有1.0和2.0两个版本。相比较1.0版，2.0版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式。&lt;/p&gt;
&lt;p&gt;OAuth更像是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。&lt;/p&gt;
&lt;p&gt;在单纯的前后端分离系统中，OAuth并不是常用的方式，它更多的应用在不同系统之间的授权交互。&lt;/p&gt;
&lt;h2 id=&quot;对比思考&quot;&gt;对比思考&lt;/h2&gt;
&lt;p&gt;刨去不常用的OAuth，这里对比两种前两种常用的认证方式 JWT Auth 和 Session-Cookie Auth ，到底谁才是前后端分离认证的最佳实践呢。从下面几个方向分析比对。&lt;/p&gt;
&lt;h3 id=&quot;可扩展性&quot;&gt;可扩展性&lt;/h3&gt;
&lt;p&gt;Session-Cookie 是&lt;strong&gt;有状态&lt;/strong&gt;的服务，在服务端保存了session的信息。当服务端扩容的时候，需要考虑到session的共享问题，这个问题已有成熟的解决放方案，可使用session复制、共享、持久化等方式解决，大多数的分布式Web框架已经集成了处理方案。JWT 验证方式是&lt;strong&gt;无状态&lt;/strong&gt;的服务，服务端可随意扩缩容。&lt;/p&gt;
&lt;p&gt;Session-Cookie 方式&lt;strong&gt;基于Cookie&lt;/strong&gt;，也就是必须是浏览器或支持Cookie的浏览器封装的框架，纯移动端无法使用。JWT 不同，&lt;strong&gt;不依赖Cookie&lt;/strong&gt;, 只要在本地可存储即可。&lt;/p&gt;
&lt;h3 id=&quot;安全性&quot;&gt;安全性&lt;/h3&gt;
&lt;p&gt;Web开发中常见的两个安全问题 XSS（跨站点脚本攻击） 和 CRSF （跨站点请求伪造）。前者利用注入脚本到用户认证网站上，执行恶意脚本代码。后者则利用浏览器访问后端自动携带cookie的机制，来跨站伪造请求。XSS 只要我们对注入端，进行过滤、转义就能解决，CRSF 是我们重点关注的。&lt;/p&gt;
&lt;p&gt;在Session-Cookie认证方式中，因为把SessionID保存在了Cookie中，很容易引起CRSF攻击。在大多数的WEB框架中有集成解决方案，如Django 的csrftoken 、Beego的xsrfToken 等。在使用Session-Cookie方案时建议开启web框架的csrf功能。&lt;/p&gt;
&lt;p&gt;JWT 认证，可以把Token存放在Cookie或localstorage。建议存在localstorage，这样就彻底避免了 CRSF 攻击。&lt;/p&gt;
&lt;p&gt;另外JWT有几个安全性的问题，需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1/ &lt;strong&gt;JWT是明文编码&lt;/strong&gt; JWT 的编码是明文Base64的一个编码，是可以反编译的。在使用JWT传输信息的时候，不要放置重要敏感信息，最好使用https。&lt;/li&gt;
&lt;li&gt;2/ &lt;strong&gt;JWT 泄露问题&lt;/strong&gt; 解决JWT的泄露问题是一个平衡的问题。有三种处理方式由轻到重，看你业务重要性酌情选择：
&lt;ul&gt;
&lt;li&gt;将JWT 的过期时间设置的很短，即使泄露也无关紧要。&lt;/li&gt;
&lt;li&gt;在服务端设计JWT的黑名单机制，将泄露的Token 加黑名单即可。&lt;/li&gt;
&lt;li&gt;保存签发的JWT，当JWT泄露时，直接设置失效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;性能&quot;&gt;性能&lt;/h3&gt;
&lt;p&gt;Session-Cookie方案，因为后端服务存储了Session信息，在认证的时候需要查询，当有大量认证的时候是非常耗费资源的。JWT 可以把信息放到token中，只需要验证解码，使用签名验证token即可，相对来说效率会有提升。&lt;/p&gt;
&lt;p&gt;从上面三个方面，我们分析了Session-Cookie和JWT 方式各自的优缺点，和面对问题的一些应对方案。相信大家会有自己的心里选择。&lt;/p&gt;
&lt;p&gt;抛开业务场景谈技术都是耍流氓。不同的业务场景，不同的架构设计，适用的认证方式也是不同的。这里按我自己的经验总结了下，什么情况下该使用那种认证方式，大家可参考。&lt;/p&gt;
&lt;p&gt;适用Session-Cookie认证方案的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目只有web端的情况；&lt;/li&gt;
&lt;li&gt;项目人员配置少，且前后端开发都会参与；&lt;/li&gt;
&lt;li&gt;项目前后端分离不彻底，前端使用后端web框架作为服务容器启动；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 JWT 认证方案的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目人员配置充足，分工明确；&lt;/li&gt;
&lt;li&gt;项目除web端外还有移动端；&lt;/li&gt;
&lt;li&gt;临时的授权需求；&lt;/li&gt;
&lt;li&gt;纯后端系统之间的交互。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文围绕前后端分离这个话题总结分享了前后端分离时的认证方案。这些仅仅是通用的一般方案，在具体的业务场景中，还有很多不典型的扩展的验证方案也是极好的，欢迎大家留言讨论自己心中的最佳认证方案。&lt;/p&gt;
&lt;h2 id=&quot;参考及扩展阅读&quot;&gt;参考及扩展阅读&lt;/h2&gt;

   

    &lt;/div&gt;

    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>