<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>42ca5da9f06444b7c860707ecfd590b5</guid>
<title>纯Docker部署Https服务——以Nextcloud为例</title>
<link>https://toutiao.io/k/v7hy6ct</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;toc-content post tag-linux tag-docker tag-https no-image&quot;&gt;
      &lt;h2 id=&quot;%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/h2&gt;&lt;p&gt;近期阿里云的廉价学生机小水管到期了，打算把一些服务打包迁移到微软员工不要钱的azure云上。&lt;/p&gt;&lt;p&gt;原先各种服务的部署方式都是直接部署的，换主机需要重新搭建各种环境非常麻烦，也容易遗漏。于是就想跟随潮流把这些服务都上docker，能够做到部署一把梭。&lt;/p&gt;&lt;h2 id=&quot;%E9%9A%BE%E7%82%B9&quot;&gt;难点&lt;/h2&gt;&lt;p&gt;一般的开源组件都会有官方docker镜像，部署起来其实都很方便。大部分对着官方文档改改配置再用docker-compose组合一下参数就能跑起来。比较麻烦的点就是网站要部署成 https 的话需要 SSL 证书。对于个人使用的小网站来说，云厂商的 SSL 证书又实在是比较贵（阿里云上通配符域名大概2000¥/年，单域名也要400¥/年）。&lt;/p&gt;&lt;p&gt;比较经济实惠的做法是使用 &lt;a href=&quot;https://letsencrypt.org/&quot;&gt;Let’s Encrypt&lt;/a&gt; 的免费证书，不过代价就是他需要定时check你对这个域名的所有权。显然，我们肯定不能手动更新，那样简直要疯。一般我们会用 &lt;a href=&quot;https://certbot.eff.org/&quot;&gt;certbot&lt;/a&gt; 来定时进行站点所有权的确认。经常对接站长后台工具的人应该都知道，认证的方式一般有两种：一种是将给定的验证字符串写进 DNS 的 TXT 记录，从而确认你对这个&lt;strong&gt;域名&lt;/strong&gt;的所有权；第二种是将给定的验证字符串写在网站的给定目录下，从而确认你对这个&lt;strong&gt;网站&lt;/strong&gt;的所有权。&lt;/p&gt;&lt;p&gt;理论上最方便的做法是通过一个定时任务，定时调用 DNS 服务商的接口来改 TXT 记录。这样可以做到将 SSL 证书的校验和网站本身的部署分离开，使得校验所有权的逻辑不干扰正常的网站配置。不过尴尬的是 certbot 提供的 &lt;a href=&quot;https://eff-certbot.readthedocs.io/en/stable/using.html#dns-plugins&quot;&gt;DNS插件&lt;/a&gt; 基本都不包含国内的运营商。而考虑到域名在国内解析的性能，我还是不太想把域名切到国外的服务商去。&lt;/p&gt;&lt;p&gt;因此事实上我只能采用 webroot 的方式来认证。这个方式比较万金油，不过缺点就是不支持通配符域名，如果需要同时验证多个子域名，则需要手动添加。同时，传统的 certbot 使用方式中一定还需要在系统中配置一个 crontab 任务来做更新，而我现在则希望将这个 crontab 任务也集成在 docker 中，尽量不要对除 docker 外的逻辑做任何感知。&lt;/p&gt;&lt;h2 id=&quot;%E6%AD%A5%E9%AA%A4&quot;&gt;步骤&lt;/h2&gt;&lt;p&gt;逻辑上讲，步骤大致应当如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;去 DNS 服务商提供的配置后台，将给定域名配置好A记录指向目的主机。&lt;/li&gt;&lt;li&gt;安装 &lt;a href=&quot;https://docs.docker.com/engine/install/ubuntu/&quot;&gt;docker&lt;/a&gt;  &lt;a href=&quot;https://docs.docker.com/compose/install/&quot;&gt;docker-compose&lt;/a&gt; ，并设置好配置文件。&lt;/li&gt;&lt;li&gt;配置并启动 nginx 只开放 http 端口 ，准备 certbot 的认证环境。&lt;/li&gt;&lt;li&gt;启动 certbot 初始化，配合nginx，生成首个私钥和证书链。&lt;/li&gt;&lt;li&gt;利用 certbot 提供的私钥和证书，配置 nginx 的 https 端口。&lt;/li&gt;&lt;li&gt;配置 certbot 的自动 renew ，进行自动验证。&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;%E6%A0%B7%E4%BE%8B&quot;&gt;样例&lt;/h2&gt;&lt;p&gt;下面以在 &lt;code&gt;https://pan.mythsman.com&lt;/code&gt; 下配置 &lt;a href=&quot;https://nextcloud.com/&quot;&gt;nextcloud&lt;/a&gt; 为例。 DNS 配置、docker 和 docker-compose 安装等步骤略过。&lt;/p&gt;&lt;h3 id=&quot;%E5%88%9D%E5%A7%8B%E5%8C%96docker%E9%85%8D%E7%BD%AE&quot;&gt;初始化docker配置&lt;/h3&gt;&lt;p&gt;./docker-compose.yml&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;version: &quot;3.8&quot;
services:
    nginx:
        container_name: nginx
        image: nginx:latest
        restart: always
        volumes:
            - ./nginx/logs:/var/log/nginx
            - ./nginx/conf.d:/etc/nginx/conf.d
            - ./certbot/conf:/etc/nginx/ssl
            - ./certbot/data:/var/www/certbot
        ports:
            - &quot;80:80&quot;
            - &quot;443:443&quot;
        command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while :;do sleep 24h &amp;amp; wait $${!}; nginx -s reload; done &amp;amp; nginx -g \&quot;daemon off;\&quot;&quot;]

    certbot:
        container_name: certbot
        image: certbot/certbot:latest
        command: certonly --webroot --webroot-path=/var/www/certbot --agree-tos --email mythsman@foxmail.com -d  pan.mythsman.com
        # entrypoint: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;trap exit TERM;while :; do certbot renew --webroot -w /var/www/certbot; sleep 24h &amp;amp; wait $${!}; done;&quot;]
        volumes:
            - ./certbot/conf:/etc/letsencrypt
            - ./certbot/logs:/var/log/letsencrypt
            - ./certbot/data:/var/www/certbot&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;./certbot/conf 目录存放的即是 certbot 生成的证书等一大堆文件，因此需要挂载给 nginx 。&lt;/li&gt;&lt;li&gt;./certbot/logs 目录下存放的是证书创建相关的日志。&lt;/li&gt;&lt;li&gt;./certbot/data 目录是 certbot 用来存放校验字符串的，需要通过nginx对外网暴露，因此也需要挂在给 nginx。&lt;/li&gt;&lt;li&gt;./nginx/logs 目录存放的即是 nginx 的相关日志。&lt;/li&gt;&lt;li&gt;./nginx/conf.d 目录存放 nginx 的配置，下面会介绍。&lt;/li&gt;&lt;li&gt;nginx 的 command 指令写了一个小脚本，用来让 nginx 定时自动 reload，方便 certbot 刷新证书后 nginx 能及时更新。&lt;/li&gt;&lt;li&gt;certbot 的 command 指令中需要配置接受邮箱，用来接受一些通知消息，以及需要配置的域名 &lt;code&gt;pan.mythsman.com&lt;/code&gt; 。&lt;/li&gt;&lt;li&gt;certbot 的 entrypoint 指令是用来后续 renew 的，暂时注释掉。&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;%E5%88%9D%E5%A7%8B%E5%8C%96nginx%E9%85%8D%E7%BD%AE&quot;&gt;初始化nginx配置&lt;/h3&gt;&lt;p&gt;./nginx/conf.d/default.conf&lt;/p&gt;&lt;pre&gt;&lt;code&gt;server {
     listen [::]:80 default_server;
     listen 80 default_server;

     server_name _;

     location ~ /.well-known/acme-challenge {
         allow all;
         root /var/www/certbot;
     }

     location / {
         if ( $host = &quot;pan.mythsman.com&quot; ){
             return 301 https://pan.mythsman.com$request_uri;
         }
         return 444;
     }

}

server {
       listen 443 default_server;
       listen [::]:443 default_server;
       server_name _;
       ssl_reject_handshake on;
       ssl_session_tickets off;
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;这里最关键的是 &lt;code&gt;.well-known&lt;/code&gt; 行，用来关联 certbot 的校验文件。&lt;/li&gt;&lt;li&gt;&lt;code&gt;return 444&lt;/code&gt; 是用来拒绝掉一些未知域名的http访问。&lt;/li&gt;&lt;li&gt;&lt;code&gt;ssl_reject_handshake&lt;/code&gt; 是用来拒绝掉一些未知域名的https的访问。&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6&quot;&gt;生成证书&lt;/h3&gt;&lt;p&gt;执行 &lt;code&gt;docker-compose up -d&lt;/code&gt; ，证书生成成功后会在 &lt;code&gt;./certbot/logs/letsencrypt.log&lt;/code&gt; 打印相关日志:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;2022-03-09 03:41:39,879:DEBUG:certbot._internal.storage:Creating directory /etc/letsencrypt/archive.
2022-03-09 03:41:39,879:DEBUG:certbot._internal.storage:Creating directory /etc/letsencrypt/live.
2022-03-09 03:41:39,879:DEBUG:certbot._internal.storage:Writing README to /etc/letsencrypt/live/README.
2022-03-09 03:41:39,879:DEBUG:certbot._internal.storage:Creating directory /etc/letsencrypt/archive/pan.mythsman.com.
2022-03-09 03:41:39,879:DEBUG:certbot._internal.storage:Creating directory /etc/letsencrypt/live/pan.mythsman.com.
2022-03-09 03:41:39,880:DEBUG:certbot._internal.storage:Writing certificate to /etc/letsencrypt/live/pan.mythsman.com/cert.pem.
2022-03-09 03:41:39,880:DEBUG:certbot._internal.storage:Writing private key to /etc/letsencrypt/live/pan.mythsman.com/privkey.pem.
2022-03-09 03:41:39,880:DEBUG:certbot._internal.storage:Writing chain to /etc/letsencrypt/live/pan.mythsman.com/chain.pem.
2022-03-09 03:41:39,880:DEBUG:certbot._internal.storage:Writing full chain to /etc/letsencrypt/live/pan.mythsman.com/fullchain.pem.
2022-03-09 03:41:39,880:DEBUG:certbot._internal.storage:Writing README to /etc/letsencrypt/live/pan.mythsman.com/README.
2022-03-09 03:41:39,909:DEBUG:certbot._internal.plugins.selection:Requested authenticator webroot and installer &amp;lt;certbot._internal.cli.cli_utils._Default object at 0x7f94027a1370&amp;gt;
2022-03-09 03:41:39,909:DEBUG:certbot._internal.cli:Var authenticator=webroot (set by user).
2022-03-09 03:41:39,909:DEBUG:certbot._internal.cli:Var webroot_path=/var/www/certbot (set by user).
2022-03-09 03:41:39,909:DEBUG:certbot._internal.cli:Var webroot_path=/var/www/certbot (set by user).
2022-03-09 03:41:39,909:DEBUG:certbot._internal.cli:Var webroot_map={&#x27;webroot_path&#x27;} (set by user).
2022-03-09 03:41:39,909:DEBUG:certbot._internal.storage:Writing new config /etc/letsencrypt/renewal/pan.mythsman.com.conf.
2022-03-09 03:41:39,911:DEBUG:certbot._internal.display.obj:Notifying user:
Successfully received certificate.
Certificate is saved at: /etc/letsencrypt/live/pan.mythsman.com/fullchain.pem
Key is saved at:         /etc/letsencrypt/live/pan.mythsman.com/privkey.pem
This certificate expires on 2022-06-07.
These files will be updated when the certificate renews.
2022-03-09 03:41:39,911:DEBUG:certbot._internal.display.obj:Notifying user: NEXT STEPS:
2022-03-09 03:41:39,912:DEBUG:certbot._internal.display.obj:Notifying user: - The certificate will need to be renewed before it expires. Certbot can automatically renew the certificate in the background, but you may need to take steps to enable that functionality. See https://certbot.org/renewal-setup for instructions.
2022-03-09 03:41:39,913:DEBUG:certbot._internal.display.obj:Notifying user: If you like Certbot, please consider supporting our work by:
 * Donating to ISRG / Let&#x27;s Encrypt:   https://letsencrypt.org/donate
 * Donating to EFF:                    https://eff.org/donate-le&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以通过 nginx 的访问日志 &lt;code&gt;/nginx/logs/access.log&lt;/code&gt;  查看他在校验的过程中访问了哪些页面:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;3.120.130.29 - - [09/Mar/2022:03:41:36 +0000] &quot;GET /.well-known/acme-challenge/fNVMV-CtDCdq_eAdiaV0rF_J7I-ZW38M7Bo3UqEtOY4 HTTP/1.1&quot; 200 87 &quot;-&quot; &quot;Mozilla/5.0 (compatible; Let&#x27;s Encrypt validation server; +https://www.letsencrypt.org)&quot; &quot;-&quot;
3.19.56.43 - - [09/Mar/2022:03:41:36 +0000] &quot;GET /.well-known/acme-challenge/fNVMV-CtDCdq_eAdiaV0rF_J7I-ZW38M7Bo3UqEtOY4 HTTP/1.1&quot; 200 87 &quot;-&quot; &quot;Mozilla/5.0 (compatible; Let&#x27;s Encrypt validation server; +https://www.letsencrypt.org)&quot; &quot;-&quot;
34.221.255.206 - - [09/Mar/2022:03:41:36 +0000] &quot;GET /.well-known/acme-challenge/fNVMV-CtDCdq_eAdiaV0rF_J7I-ZW38M7Bo3UqEtOY4 HTTP/1.1&quot; 200 87 &quot;-&quot; &quot;Mozilla/5.0 (compatible; Let&#x27;s Encrypt validation server; +https://www.letsencrypt.org)&quot; &quot;-&quot;
64.78.149.164 - - [09/Mar/2022:03:41:36 +0000] &quot;GET /.well-known/acme-challenge/fNVMV-CtDCdq_eAdiaV0rF_J7I-ZW38M7Bo3UqEtOY4 HTTP/1.1&quot; 200 87 &quot;-&quot; &quot;Mozilla/5.0 (compatible; Let&#x27;s Encrypt validation server; +https://www.letsencrypt.org)&quot; &quot;-&quot;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;%E9%85%8D%E7%BD%AE%E7%AB%99%E7%82%B9%E5%AE%B9%E5%99%A8%E5%92%8C%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%96%B0&quot;&gt;配置站点容器和证书更新&lt;/h3&gt;&lt;p&gt;./docker-compose.yml&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;version: &quot;3.8&quot;
services:
    nginx:
        container_name: nginx
        image: nginx:latest
        restart: always
        volumes:
            - ./nginx/logs:/var/log/nginx
            - ./nginx/conf.d:/etc/nginx/conf.d
            - ./certbot/conf:/etc/nginx/ssl
            - ./certbot/data:/var/www/certbot
        ports:
            - &quot;80:80&quot;
            - &quot;443:443&quot;
        command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while :;do sleep 24h &amp;amp; wait $${!}; nginx -s reload; done &amp;amp; nginx -g \&quot;daemon off;\&quot;&quot;]

    certbot:
        container_name: certbot
        image: certbot/certbot:latest
        # command: certonly --webroot --webroot-path=/var/www/certbot --agree-tos --email mythsman@foxmail.com -d  pan.mythsman.com
        entrypoint: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;trap exit TERM;while :; do certbot renew --webroot -w /var/www/certbot; sleep 24h &amp;amp; wait $${!}; done;&quot;]
        volumes:
            - ./certbot/conf:/etc/letsencrypt
            - ./certbot/logs:/var/log/letsencrypt
            - ./certbot/data:/var/www/certbot
    nextcloud:
        container_name: nextcloud
        image: nextcloud:latest
        volumes:
            - ./nextcloud:/var/www/html
        ports:
            - &quot;8080:80&quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;这里将 cerbot 的 command 注释掉，更换了 entrypoint 的启动脚本，用来每天自动更新 cerbot 证书。&lt;/li&gt;&lt;li&gt;新增了 nextcloud 的镜像。&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;%E9%85%8D%E7%BD%AE%E7%AB%99%E7%82%B9%E7%9A%84nginx&quot;&gt;配置站点的Nginx&lt;/h3&gt;&lt;p&gt;./nginx/conf.d/pan.mythsman.com-ssl.conf&lt;/p&gt;&lt;pre&gt;&lt;code&gt;server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;

    server_name pan.mythsman.com;

    ssl_certificate /etc/nginx/ssl/live/pan.mythsman.com/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/live/pan.mythsman.com/privkey.pem;

    ssl_stapling on;
    ssl_stapling_verify on;

    location / {
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Host $http_host;
        proxy_pass http://172.17.0.1:8080;
    }

    client_max_body_size 10G;

}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;proxy_pass 中的 172.17.0.1 为 host 主机在 docker 中访问的 ip，8080端口暴露的即为前文设置的 nextcloud 的服务。&lt;/li&gt;&lt;li&gt;ssl_certificate 和 ssl_certificate_key 配置为前文 certbot 生成的文件。&lt;/li&gt;&lt;li&gt;&lt;code&gt;client_max_body_size 10G;&lt;/code&gt; 配置是增大上传文件的大小限制。&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2&quot;&gt;重新部署&lt;/h3&gt;&lt;p&gt;执行 &lt;code&gt;docker-compose down&lt;/code&gt; 和  &lt;code&gt;docker-compose up -d&lt;/code&gt; ，重新部署各个服务。部署完成后，可以查看 certbot 的日志：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;2022-03-09 06:27:54,847:DEBUG:certbot._internal.main:certbot version: 1.24.0
2022-03-09 06:27:54,848:DEBUG:certbot._internal.main:Location of certbot entry point: /usr/local/bin/certbot
2022-03-09 06:27:54,848:DEBUG:certbot._internal.main:Arguments: [&#x27;--webroot&#x27;, &#x27;-w&#x27;, &#x27;/var/www/certbot&#x27;]
2022-03-09 06:27:54,848:DEBUG:certbot._internal.main:Discovered plugins: PluginsRegistry(PluginEntryPoint#manual,PluginEntryPoint#null,PluginEntryPoint#standalone,PluginEntryPoint#webroot)
2022-03-09 06:27:54,863:DEBUG:certbot._internal.log:Root logging level set at 30
2022-03-09 06:27:54,865:DEBUG:certbot._internal.display.obj:Notifying user: Processing /etc/letsencrypt/renewal/pan.mythsman.com.conf
2022-03-09 06:27:54,883:DEBUG:certbot._internal.plugins.selection:Requested authenticator webroot and installer &amp;lt;certbot._internal.cli.cli_utils._Default object at 0x7f64a6694f10&amp;gt;
2022-03-09 06:27:54,883:DEBUG:certbot._internal.cli:Var authenticator=webroot (set by user).
2022-03-09 06:27:54,883:DEBUG:certbot._internal.cli:Var webroot_path=/var/www/certbot (set by user).
2022-03-09 06:27:54,883:DEBUG:certbot._internal.cli:Var webroot_map={&#x27;webroot_path&#x27;} (set by user).
2022-03-09 06:27:54,883:DEBUG:certbot._internal.cli:Var webroot_path=/var/www/certbot (set by user).
2022-03-09 06:27:54,907:DEBUG:urllib3.connectionpool:Starting new HTTP connection (1): r3.o.lencr.org:80
2022-03-09 06:27:55,136:DEBUG:urllib3.connectionpool:http://r3.o.lencr.org:80 &quot;POST / HTTP/1.1&quot; 200 503
2022-03-09 06:27:55,137:DEBUG:certbot.ocsp:OCSP response for certificate /etc/letsencrypt/archive/pan.mythsman.com/cert1.pem is signed by the certificate&#x27;s issuer.
2022-03-09 06:27:55,138:DEBUG:certbot.ocsp:OCSP certificate status for /etc/letsencrypt/archive/pan.mythsman.com/cert1.pem is: OCSPCertStatus.GOOD
2022-03-09 06:27:55,141:DEBUG:certbot._internal.display.obj:Notifying user: Certificate not yet due for renewal
2022-03-09 06:27:55,142:DEBUG:certbot._internal.plugins.selection:Requested authenticator webroot and installer None
2022-03-09 06:27:55,142:DEBUG:certbot._internal.display.obj:Notifying user:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2022-03-09 06:27:55,142:DEBUG:certbot._internal.display.obj:Notifying user: The following certificates are not due for renewal yet:
2022-03-09 06:27:55,142:DEBUG:certbot._internal.display.obj:Notifying user:   /etc/letsencrypt/live/pan.mythsman.com/fullchain.pem expires on 2022-06-07 (skipped)
2022-03-09 06:27:55,142:DEBUG:certbot._internal.display.obj:Notifying user: No renewals were attempted.
2022-03-09 06:27:55,143:DEBUG:certbot._internal.display.obj:Notifying user: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2022-03-09 06:27:55,143:DEBUG:certbot._internal.renewal:no renewal failures&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;没有报错说明流程就是通的，不过由于这个证书是刚申请的，离过期还很远，因此在renew的时候显示不需要更新。如果是想强制更新的话，可以在 certbot 的参数中加 &lt;code&gt;--renew-by-default&lt;/code&gt; 选项。如果想确认证书的过期时间，可以通过 openssl 命令查看：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ openssl x509 -in cert.pem -noout -dates
notBefore=Jan 30 03:00:32 2022 GMT
notAfter=Apr 30 03:00:31 2022 GMT&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时候访问 &lt;code&gt;pan.mythsman.com&lt;/code&gt; 即可发现 https 证书已经OK了。&lt;/p&gt;&lt;h3 id=&quot;nextcloud%E7%9A%84%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE&quot;&gt;Nextcloud的其他配置&lt;/h3&gt;&lt;p&gt;配置好 https 后，nextcloud有时还不认得自己的scheme已经是https了，这里最好需要修改一下配置。&lt;/p&gt;&lt;p&gt;&lt;code&gt;./nextcloud/config/config.php&lt;/code&gt; 新增一行：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&#x27;overwriteprotocol&#x27; =&amp;gt; &#x27;https&#x27;,&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&quot;&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.rocworks.at/wordpress/?p=950&quot;&gt;Nginx &amp;amp; Certbot (Letsencrypt) via Docker&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://eff-certbot.readthedocs.io/en/stable/using.html#webroot&quot;&gt;Certbot User Guide&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://community.letsencrypt.org/t/cant-use-webroot-authenticator-needed-for-wildcard-domain/64668&quot;&gt;Can’t use webroot authenticator needed for wildcard domain&lt;/a&gt;&lt;/p&gt;
    &lt;/section&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>87366250472891b6d4394679e08b3bfa</guid>
<title>分库分表，我为什么要用Shardingsphere呢？</title>
<link>https://toutiao.io/k/naz0qrj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1379310344827587&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XJlI2e4PlFCAo31qnIMbDbZYjZiaoMc13vKFLjK6kut61aP4k8Uxmzic3FzFMtZapG4jlyBmJMg0UOndMMRWaTLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;58&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;em data-mid=&quot;&quot;/&gt;&lt;p data-mid=&quot;&quot;&gt;可以参与抽奖&lt;/p&gt;&lt;em data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibl6u6nJ01g9icia42icDbWWvO2ObicnIUHjwQKVp30YzLS8xSInYupoEXAKjYeYDibY50CgKLz6ViaDjTjuRqUqaae0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;参与方式&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/K8beZoNWDcUm9I6ia4UU97K1XHrQx2PavruEm3xAL2W3Vd7JxrB8PLXtmT5JkwqpC9Dg9hEmtVZkY2hibnlkib0Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;关注公众号：35岁程序员那些事，后台回复关键词“参与抽奖”，获取抽奖链接，点击抽奖。 中奖之后，可以联系笔者的微信号或者公众号后台回复关键词“联系笔者”，获取联系方式。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分库分表推荐Spring Cloud Alibaba+Seata+Shardingsphere&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分库分表是高并发系统中从可扩展性全面保障业务稳定性的最佳手段之一，当然它也有很多成熟的开源解决方案，比如Apache-Shardingsphere、Mycat和Zebra等，本小节会简单的分析下分库分表相关的生态领域。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ShardingSphere&lt;/strong&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Apache-Shardingsphere框架整体发展经历了很多阶段，①当当网内部数据库中间件 ②Sharding-JDBC ③Sharding-Sphere ④Apache ShardingSphere。Apache-Shardingsphere拥抱开源社区并开放源码和持续技术建设，目前star 13.1k fork 4.4k，是一款非常优秀开源分布式数据库中间件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;第一阶段：它是当当网内部应用框架ddframe中并从关系型数据库模块dd-rdb中分离出来的数据库水平分片框架，并实现透明化数据库分库分表访问。Sharding-JDBC是继dubbox和elastic-job之后，ddframe系列开源的第3个项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;第二阶段：在众多开源的分布式数据库中间件中，当当网的开源组件Sharding-JDBC是一个非常优秀的技术解决方案，一直以来，Sharding-JDBC定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;第三阶段：当应用场景多元化之后，仅通过JDBC 层的嵌入，难于应对更加复杂的业务场景，比如：Java 之外的异构语言、数据库管理端命令行和Consul UI等等。但是基于Proxy去模拟数据库的中间代理层的方案则更加容易支撑相应的应用场景。由于Proxy版本的出现，使得Sharding-JDBC这个名字已经不再适合，但是开源社区无法放弃过去两年多Sharding-JDBC的影响力所带来的用户沉淀。因此，还是保留了“Sharding”这个关键词。而且对于分布式数据库中间件来说，无论是分库分表、柔性事务还是数据治理，“Sharding”是这一切的起源。于是官方的开源社区将原有的Sharding-JDBC与新开发的 Sharding-Proxy 以及正在孵化中的Sharding-Sidecar一起组成了一个生态圈，将其命名为Sharding-Sphere，即 Sharding 生态圈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第四阶段；2018年11月10日，开源分布式数据库中间件生态圈Sharding-Sphere正式进入Apache基金会孵化器，并再次更名为Apache ShardingSphere。2019年4月23日，发布4.0.0-RC1，它是ShardingSphere进入Apache基金会后第一个Release Version。2020年4月16日，Apache基金会董事会宣布Apache ShardingSphere成功晋升为Apache顶级项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Mycat&lt;/strong&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Mycat 是什么？从定义和分类来看，它是一个开源的分布式数据库系统，是一个实现了 MySQL 协议的Server，前端用户可以把它看作是一个数据库代理，用MySQL 客户端工具和命令行访问，而其后端可以用 MySQL 原生（Native）协议与多个 MySQL服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信， 其核心功能是分表分库，即将一个大表水平分割为 N 个小表，存储在后端 MySQL 服务器里或者其他数据库里。Mycat发展到目前的版本，已经不是一个单纯的 MySQL代理了，它的后端可以支持 MySQL、SQL Server、 Oracle、DB2、PostgreSQL等主流数据库，也支持 MongoDB这种新型 NoSQL方式的存储，未来它也还会支持更多类型的存储数据库。而在最终用户看来，无论是那种存储方式，在Mycat里，都是一个传统的数据库表，支持标准的 SQL语句进行数据的操作，这样一来，对前端业务系统来说，可以大幅降低开发难度，提升开发速度，在测试阶段，可以将一个表定义为任何一种 Mycat支持的存储方式，比如MySQL的 MyASIM表、内存表、或者MongoDB、LevelDB以及号称是世界上最快的内存数据库 MemSQL 上。试想一下，用户表存放在 MemSQL 上，大量读频率远超过写频率的数据如订单的快照数据存放于 InnoDB 中，一些日志数据存放于 MongoDB 中，而且还能把 Oracle 的表跟 MySQL 的表做关联查询，你是否有一种不能呼吸的感觉？而未来，还能通过 Mycat自动将一些计算分析后的数据植入到Hadoop中，并能用 Mycat+Storm/Spark Stream 引擎做大规模数据分析，看到这里，你大概明白了，Mycat是什么？Mycat就是 BigSQL，Big Data On SQL Database。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Mycat目前star 8.8k fork 3.8k，最新版本是1.6.7.6-release，社区活跃度非常高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt; Zebra&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zebra是一个基于JDBC API协议上开发出的高可用、高性能的数据库访问层解决方案，是美团点评内部使用的数据库访问层中间件。具有以下的功能点：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配置&lt;/span&gt;&lt;span&gt;集中管理，动态刷&lt;/span&gt;&lt;span&gt;新；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持读写分离、分库分表；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;丰富的监控信息在&lt;/span&gt;&lt;span&gt;CAT&lt;/span&gt;&lt;span&gt;上展现；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;异步化数据&lt;/span&gt;&lt;span&gt;库请求，多数据源支持。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zebra 简化了读写分离、分库分表的开发工作，使得业务方在分库分库、读写分离的情况下，依然可以像操作单个库那样去操作，屏蔽底层实现的复杂性，对业务透明。Zebra还提供了从读写分离到分库分表全生命周期的技术支持。Zebra提供的完善的监控体系帮助开发掌控数据库请求的整个链路，快速定位问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zebra 目前star1.9k fork 583，最新版本是2.9.1，当然最后一次更新是2018年12月17日，社区活跃度不是很高，所以一般从技术选型的角度，优先推荐Apache-Shardingsphere或者Mycat。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;对比以上三种分库分表解决方案&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下表，只是对比了Apache-Shardingsphere和Mycat，因为Zebra技术选型不是很多，在这里就不做横向对比。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Apache-Shardingsphere&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Mycat&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;工作层面&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;JDBC协议&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Mysql协议/JDBC协议&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;运行方式&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Jar包或者代理客户端&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;独立服务以及代理客户端独立部署&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;开发方式&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;代码/配置改动&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;连接地址（数据源）&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;运维方式&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;无&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;管理独立服务，运维成本高&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;性能&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;高并发、高性能&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;独立服务+网络开销，存在性能损耗风险。&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;功能范围&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;协议范围&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;分布式事务和数据迁移等&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;适用操作&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;OLTP&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;OLTP+OLAP&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持数据库&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;基于JDBC协议的数据库&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;Mysql和其他支持JDBC协议的数据库&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;分布式事务&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持XA和Seata AT模式&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持弱XA，支持XA分布式事务（1.6.5）&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;是否支持自定义sharding路由&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;最大支持sharding路由维度&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;2&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;1&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持语言&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;支持JDBC协议的开发语言&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;动态调整数据源&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;研发/或者第三方插件支持（Mybatis-Plus）&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;添加新组合配置并重启Mycat&lt;/span&gt;&lt;span/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span/&gt;        &lt;strong&gt;      &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;为什么选择ShardingSphere&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了上述技术优势以外，主要还是ShardingSphere偏主流，比如它支持Seata，后续还会支持Nacos等，这些都和Spring Cloud Alibaba契合度非常高的，所以在选择一个技术之前，不要只看它的技术有多牛，要看是否是主流的技术趋势。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e66c2828bc2f18c7208bdfb3c27c3b61</guid>
<title>面试官问，Redis 是单线程还是多线程?我懵了</title>
<link>https://toutiao.io/k/kd3u5dk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-pid=&quot;DOz5cV2M&quot;&gt;我们平时看到介绍 Redis 的文章，都会说 Redis 是单线程的。但是我们学习的时候，比如 Redis 的 bgsave 命令，它的作用是在后台异步保存当前数据库的数据到磁盘，那既然是异步了，肯定是由别的线程去完成的，这怎么还能说 Redis 是单线程的呢？&lt;/p&gt;&lt;p data-pid=&quot;7jL_mr2i&quot;&gt;其实通常说的 Redis 是单线程，主要是指 Redis 对外提供键值存储服务的主要流程，即网络 IO 和键值对读写是由⼀个线程来完成的。除此外 Redis 的其他功能，比如持久化、 异步删除、集群数据同步等，是由额外的线程执⾏的。在这一点上 Node 也是一样的，一般提到 Node 也是单线程的，但其实 Node 只有一个主线程是单线程，其他异步任务则由其他线程完成。这样做的原因是防止有同步代码阻塞，导致主线程被占用后影响后续的程序代码执行。&lt;/p&gt;&lt;p data-pid=&quot;H9afwmen&quot;&gt;因此，严格地说 Redis 并不是单线程。但是我们⼀般把 Redis 称为单线程高性能，这样显得 Redis 更强一些。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Redis 为什么用单线程&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;mRleqHb6&quot;&gt;Redis 为什么用单线程？在回答这个问题前，先来看大家都很熟悉的数据库 MySQL，它使用的就是多线程。MySQL 不会每有一个连接就创建一个线程，因为线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等，同时也会降低计算机的整体性能。这个正是多线程会遇到的难点。&lt;/p&gt;&lt;p data-pid=&quot;d326LPc6&quot;&gt;此外多线程系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构，当有多个进程要修改这个共享资源时，为了保证共享资源的正确性，就需要有额外的机制进行保证，而这个额外的机制，也会带来额外的开销。还是以 MySQL 举例，MySQL 引入了锁机制来解决这个问题。&lt;/p&gt;&lt;p data-pid=&quot;N1OHAy3c&quot;&gt;从上面不难看出，多线程开发中并发访问控制是⼀个难点，需要精细的设计才能处理。如果只是简单地处理，比如简单地采⽤⼀个粗粒度互斥锁，只会出现不理想的结果。即便增加了线程，系统吞吐率也不会随着线程的增加而增加，因为大部分线程还在等待获取访问共享资源的互斥锁。而且，大部分采用多线程开发引入的同步原语保护共享资源的并发访问，也会降低系统代码的易调试性和可维护性。&lt;/p&gt;&lt;p data-pid=&quot;Ao1xZBNA&quot;&gt;而正是以上这些问题，才让 Redis 采⽤了单线程模式。&lt;/p&gt;&lt;p data-pid=&quot;18UJ2Hrs&quot;&gt;看到这里大家可能有点疑惑，前面说了 Redis 不是单线程，现在我们也说了 Redis 的键值对读写操作使用采用了单线程模式，那么它的其他线程是是什么样的呢？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;主进程的其它线程&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;iWbOj44Q&quot;&gt;Redis 3.0 版本后，主进程中除了主线程处理网络 IO 和命令操作外，还有 3 个辅助 BIO 线程。这 3 个 BIO 线程分别负责处理，文件关闭、AOF 缓冲数据刷新到磁盘，以及清理对象这三个任务队列，从而避免这些任务对主 IO 线程的影响。&lt;/p&gt;&lt;p data-pid=&quot;jHiYKxeo&quot;&gt;Redis 在启动时，会同时启动这三个 BIO 线程，但是 BIO 线程只有在需要执行相关类型后台任务时才会唤醒，其他时间会休眠等待任务。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-351f345326168d65546e6c487f4836ff_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;580&quot; data-rawheight=&quot;316&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-351f345326168d65546e6c487f4836ff_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;580&quot; data-rawheight=&quot;316&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-351f345326168d65546e6c487f4836ff_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-351f345326168d65546e6c487f4836ff_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;多进程&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;B-szwmns&quot;&gt;除了主进程，在以下场景如果需要进行重负荷任务的处理，Redis 会 fork 一个子进程来处理：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;dYviL92T&quot;&gt;&lt;b&gt;收到 bgrewriteaof 命令：&lt;/b&gt;Redis fork 一个子进程，然后子进程往临时 AOF文件中写入重建数据库状态的所有命令。写入完毕后，子进程会通知父进程把新增的写操作追加到临时 AOF 文件。最后将临时文件替换旧的 AOF 文件，并重命名。&lt;/li&gt;&lt;li data-pid=&quot;rjwQWi84&quot;&gt;&lt;b&gt;收到 bgsave 命令：&lt;/b&gt;Redis 构建子进程，子进程将内存中的所有数据通过快照做一次持久化落地，写入到 RDB 中。&lt;/li&gt;&lt;li data-pid=&quot;OgO1Ffnf&quot;&gt;&lt;b&gt;当需要进行全量复制：&lt;/b&gt;master 启动一个子进程，子进程将数据库快照保存到 RDB 文件。在写完 RDB 快照文件后，master 会把 RDB 发给 slave，同时将后续新的写指令都同步给 slave。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;Redis6.0 多线程&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;XtAzZXGD&quot;&gt;多线程是 Redis6.0 推出的一个新特性。正如上面所说 Redis 是核心线程负责网络 IO ，命令处理以及写数据到缓冲，而随着网络硬件的性能提升，单个主线程处理⽹络请求的速度跟不上底层⽹络硬件的速度，导致网络 IO 的处理成为了 Redis 的性能瓶颈。&lt;/p&gt;&lt;p data-pid=&quot;3MpKb3wd&quot;&gt;而 Redis6.0 就是从单线程处理网络请求到多线程处理，通过多个 IO 线程并⾏处理网络操作提升实例的整体处理性能。需要注意的是对于读写命令，Redis 仍然使⽤单线程来处理，这是因为继续使⽤单线程执行命令操作，就不⽤为了保证 Lua 脚本、事务的原⼦性，额外开发多线程互斥机制了。&lt;/p&gt;&lt;p data-pid=&quot;sA5x_gRv&quot;&gt;需要注意的是在 Redis6.0 中，多线程机制默认是关闭的，需要在 redis.conf 中完成以下两个设置才能启用多线程。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;9V-g4QW9&quot;&gt;设置 io-thread-do-reads 配置项为 yes，表示启用多线程。&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li data-pid=&quot;z6J_1bYT&quot;&gt;设置线程个数。⼀般来说，&lt;b&gt;线程个数要小于&lt;/b&gt; &lt;b&gt;Redis&lt;/b&gt; &lt;b&gt;实例所在机器的&lt;/b&gt; &lt;b&gt;CPU&lt;/b&gt; &lt;b&gt;核数&lt;/b&gt;，例如，对于⼀个 8 核的机器来说，Redis 官⽅建议配置 6 个 IO 线程。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;多线程流程&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;F9JJ4wz-&quot;&gt;来具体看一下在 Redis6.0 中，主线程和 IO 线程是如何协作完成请求处理的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f184dac090a6f0bef7ee70f849dcb398_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;486&quot; data-rawheight=&quot;732&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-f184dac090a6f0bef7ee70f849dcb398_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;486&quot; data-rawheight=&quot;732&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-f184dac090a6f0bef7ee70f849dcb398_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f184dac090a6f0bef7ee70f849dcb398_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;6_Fge9xa&quot;&gt;全部流程分为以下 4 阶段：&lt;/p&gt;&lt;p data-pid=&quot;jeptKXXJ&quot;&gt;&lt;b&gt;阶段⼀：服务端和客⼾端建立&lt;/b&gt; &lt;b&gt;Socket&lt;/b&gt; &lt;b&gt;连接，并分配处理线程&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;1TPkUKV5&quot;&gt;当有客⼾端请求和实例建立 Socket 连接时，主线程会创建和客户端的连接，并把 Socket 放入全局等待队列中。然后主线程通过轮询方法把 Socket 连接分配给 IO 线程。&lt;/p&gt;&lt;p data-pid=&quot;V3ArTfwg&quot;&gt;&lt;b&gt;阶段⼆：IO&lt;/b&gt; &lt;b&gt;线程读取并解析请求&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;aUtuJdMH&quot;&gt;主线程把 Socket 分配给 IO 线程后，会进⼊阻塞状态等待 IO 线程完成客户端请求读取和解析。&lt;/p&gt;&lt;p data-pid=&quot;f0853DrM&quot;&gt;&lt;b&gt;阶段三：主线程执⾏请求操作&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;TBH25YZ_&quot;&gt;IO 线程解析完请求后，主线程以单线程的⽅式执⾏这些命令操作。&lt;/p&gt;&lt;p data-pid=&quot;-kzwpKka&quot;&gt;&lt;b&gt;阶段四：IO&lt;/b&gt; &lt;b&gt;线程回写&lt;/b&gt; &lt;b&gt;Socket&lt;/b&gt; &lt;b&gt;和主线程清空全局队&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;uJ0R7qAX&quot;&gt;主线程执行完请求操作后，会把需要返回的结果写入缓冲区。然后，主线程会阻塞等待 IO 线程把这些结果回写到 Socket 中，并返回给客户端。等到 IO 线程回写 Socket 完毕，主线程会清空全局队列，等待客户端的后续请求。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;X20Vou0a&quot;&gt;看完了这篇文章，相信大家对 Redis 是单线程的说法已经有了大致概念。我们说它是单线程，主要是因为在以前的版本中网络 IO 和键值对读写是由⼀个线程来完成的。而之所以说 Redis 是多线程，则是因为 Redis6.0 以后的版本里，网络 IO 的部分变为了多线程处理。而且除了主线程，还有 3 个辅助 BIO 线程，分别是 fsync 线程、close 线程、清理回收线程。当然不能忘记的是，想要体验多线程机制，就得通过修改配置文件开启多线程功能。&lt;/p&gt;&lt;p data-pid=&quot;0sC_lR2J&quot;&gt;&lt;b&gt;推荐阅读：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/683/%25E4%25BA%2591%25E5%258E%259F%25E7%2594%259F%25E7%2581%25B0%25E5%25BA%25A6%25E6%259B%25B4%25E6%2596%25B0%25E5%25AE%259E%25E8%25B7%25B5.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-8f104356f3f3ddcb0d1906098658cc1e_180x120.jpg&quot; data-image-width=&quot;1280&quot; data-image-height=&quot;503&quot; data-text=&quot;云原生灰度更新实践&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/652/MySQL%2520%25E4%25B8%25AD%25E5%25AD%2598%25E5%2582%25A8%25E6%2597%25B6%25E9%2597%25B4%25E7%259A%2584%25E6%259C%2580%25E4%25BD%25B3%25E5%25AE%259E%25E8%25B7%25B5.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-c930bdf5e4303330e0c3d9b7dfb313b8_180x120.jpg&quot; data-image-width=&quot;685&quot; data-image-height=&quot;350&quot; data-text=&quot;MySQL 中存储时间的最佳实践&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7a4cb9de69e680821655c10858b4ed84</guid>
<title>python实现B站UP主自动监控</title>
<link>https://toutiao.io/k/p8i7cpt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.确定小目标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，确定一下我们想实现的脚本的功能：&lt;/span&gt;&lt;span&gt;给&lt;/span&gt;&lt;span&gt;定一些UP主的ID，我们自动关注这些UP主，并开始监控这些UP主是否有更新视频，如果有则微信进行通知并自动下载这些视频。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span&gt;模拟登录&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然要实现自动关注功能当然还是要先实现B站的模拟登录啦，这里我们还是借助公众号之前开源的DecryptLogin包，先安装一下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;pip&lt;/span&gt; install DecryptLogin --upgrade&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;然后简单写几行代码就ok啦：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; DecryptLogin &lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; login&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;lg = login.Login()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;infos_return, session = lg.bilibili(mode=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;scanqr&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.自动关注&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;我们先来抓包看看关注UP主时需要请求的接口吧，简单调试之后发现以下这个链接不管从名字还有从需要携带的参数看都很可疑：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5041567695961995&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZTbkic2pYRqickgglaYr7Z4BX5SMYcKZAHQnzC2BiavZw4WNjsULKAgJkKrcXzp5jBEpxfPJ17pA4Wmibmdqch7Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1684&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，我们可以先写个脚本测试一下我们的想法，可以看到请求这个接口需要携带的参数如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2068230277185501&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZTbkic2pYRqickgglaYr7Z4BX5SMYcKZA3gLg4McKK6xdsoUcOVNTBFC90CuAIzx1tib6RokWLQhmczib41WC5vOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1407&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过测试，必须要携带的参数是这些：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fid: 想要关注的UP主的ID；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;act: 固定值, 为&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;re_src: 固定值, 为&lt;span class=&quot;code-snippet__number&quot;&gt;11&lt;/span&gt;；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;jsonp: 固定值, 为jsonp；&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;csrf: 从登录的cookies中可以拿到。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;代码实现如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;&#x27;&#x27;关注某个UP主&#x27;&#x27;&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;follow&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self, up_id)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    url = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;https://api.bilibili.com/x/relation/modify&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    data = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;fid&#x27;&lt;/span&gt;: up_id,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;act&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;re_src&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;11&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;jsonp&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;jsonp&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;csrf&#x27;&lt;/span&gt;: self.session.cookies.get_dict(domain=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;.bilibili.com&#x27;&lt;/span&gt;).get(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;bili_jct&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;&#x27;&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    headers = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Host&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;api.bilibili.com&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Origin&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;https://space.bilibili.com&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Referer&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;https://space.bilibili.com/&lt;span class=&quot;code-snippet__subst&quot;&gt;{up_id}&lt;/span&gt;/&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    response = self.session.post(url, data=data, headers=headers)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    response_json = response.json()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; response_json[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;code&#x27;&lt;/span&gt;], response_json.get(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;message&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;测试之后登录客户端看发现确实可以成功关注对应的UP主，于是这部分内容也顺利地完成啦~&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.实时监控&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时监控其实也很简单，只需要先把目标UP主当前首页的作品信息获取到，然后每隔一段时间对比一次，看看有没有新的作品出现就行啦。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体而言，我们需要先获取到UP主当前首页的作品信息：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;&#x27;&#x27;获得UP主首页所有视频信息&#x27;&#x27;&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getupvids&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self, up_id)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    up_vids, aids = [], []&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    headers = {&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;User-Agent&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.117 Safari/537.36&#x27;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    params = {&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;keyword&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;mid&#x27;&lt;/span&gt;: up_id, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;ps&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;tid&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;pn&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;order&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;pubdate&#x27;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    response = self.session.get(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;https://api.bilibili.com/x/space/arc/search&#x27;&lt;/span&gt;, headers=headers, params=params)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    response_json = response.json()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; response_json[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;data&#x27;&lt;/span&gt;][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;list&#x27;&lt;/span&gt;][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;vlist&#x27;&lt;/span&gt;]:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        aids.append(item[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;aid&#x27;&lt;/span&gt;])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; aid &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; aids:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        params = {&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;aid&#x27;&lt;/span&gt;: aid}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        response = self.session.get(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;https://api.bilibili.com/x/web-interface/view&#x27;&lt;/span&gt;, headers=headers, params=params)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        response_json = response.json()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        up_vids.append(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;https://www.bilibili.com/video/&#x27;&lt;/span&gt; + response_json[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;data&#x27;&lt;/span&gt;][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;bvid&#x27;&lt;/span&gt;])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; up_vids&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;然后每隔一段时间对比一下就行：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; up_id &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; self.up_ids:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    self.logging(&lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;正在检查UP主&lt;span class=&quot;code-snippet__subst&quot;&gt;{ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;username&quot;&lt;/span&gt;]}&lt;/span&gt;是否更新了视频...&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    vids = self.getupvids(up_id)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;updated_vids&#x27;&lt;/span&gt;] = []&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; vid &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; vids:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; vid &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;vids&#x27;&lt;/span&gt;]: &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;updated_vids&#x27;&lt;/span&gt;].append(vid)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;vids&#x27;&lt;/span&gt;].append(vid)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最后把对比结果打印出来，有更新则进行微信消息推送即可：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; up_id &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; self.up_ids:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; len(ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;updated_vids&#x27;&lt;/span&gt;]) &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        msg = &lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;你关注的UP主&lt;span class=&quot;code-snippet__subst&quot;&gt;{ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;username&quot;&lt;/span&gt;]}&lt;/span&gt;更新啦...&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.pushwechat(msg)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.logging(msg)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; vid &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;updated_vids&#x27;&lt;/span&gt;]:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            os.system(&lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;videodl -i &lt;span class=&quot;code-snippet__subst&quot;&gt;{vid}&lt;/span&gt; -s &lt;span class=&quot;code-snippet__subst&quot;&gt;{ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;username&quot;&lt;/span&gt;]}&lt;/span&gt;&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        msg = &lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;你关注的UP主&lt;span class=&quot;code-snippet__subst&quot;&gt;{ups_recorder[up_id][&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;username&quot;&lt;/span&gt;]}&lt;/span&gt;暂时没有更新...&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.logging(msg)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;span&gt;大功告成啦，完整源代码详见相关文件~&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f2714a6e862ac70abccad2990f481e92</guid>
<title>成为更好的开发者！行动起来！</title>
<link>https://toutiao.io/k/bcodelm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>