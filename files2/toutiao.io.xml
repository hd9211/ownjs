<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>19586f11ffd15d2738877513e94971fb</guid>
<title>一个技术团队leader的搭建私有知识库避坑经验分享</title>
<link>https://toutiao.io/k/o3dptn4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作为一名技术团队的管理者，团队整体规模达到80人，对团队人才培养与团队搭建有些所思所得，现在分享下。
1、需求的产生
开始带团队的时候，对​​知识库​​完全没有概念，公司内也没有什么分享整理的系统的解决方法，大多数都是些成word或者excel，甚至文本文档，然后在svn上的某一个文件夹一丢，就算是知识库了。但是两年过后，就发现这种杂乱无序的知识库分享方式，有很多缺点，比如快速查找、文档有错的时候不能同步更新等等。 。
基于我遇到的情况，公司内部要搭建统一管理的知识库，知识库要能够实实在在的帮助到团队的每一个需要帮助的人，而不仅仅是一个形式，马马虎虎应付了事的知识库资料是没有意义。
然后，整理了我的想法思路需求：
• 内容划分：将知识或者信息分类，形成文档集或者知识库。从知识信息的用途来分为：公司制度管理类、通用技术类、市场知识类、产品规范与案例类、入职培训类等；&lt;/p&gt;

&lt;p&gt;• 信息安全：对于公司内部信息，特别是技术、市场相关的信息，有非常机密敏感的内容，一定不能是SaaS，要支持本地化部署；一定要有权限化管理，有效的信息分级控制；&lt;/p&gt;

&lt;p&gt;• 内容形式：B/S模式，支持富文本、支持演示文稿、支持脑图、支持画图等；&lt;/p&gt;

&lt;p&gt;• 快速检索：要支持内容级的检索，不能只是搜索题目，一定要能支持内容搜索；&lt;/p&gt;

&lt;p&gt;• 形成交流：对内容可以评价与评论，这样更加容易形成团队内部交流，最好是类似于论坛的形式，相关的人都可以发表相关的意见和建议；&lt;/p&gt;

&lt;p&gt;• 易于分享：能对分享的范围进行控制，可以对分享的时间有效性、支持密码、内部账号等；&lt;/p&gt;

&lt;p&gt;• 简易操作：交付一定要简单，最好支持便捷的用户认证等；&lt;/p&gt;

&lt;p&gt;• 成本控制：因为公司人数逐步在增加，最好是成本越低越好，不能有人数与功能的限制；&lt;/p&gt;

&lt;p&gt;• 易于扩展：最好是完全开源，容易扩展，因为我们内部有个需求，是日常项目执行的过程中，能把日常项目中的某些文档形成知识积累（产品经理的​​需求分析​​，prd等），那么要在知识库上可以提供便捷的二开；&lt;/p&gt;

&lt;p&gt;2、技术选型
其实从交付上最理想的是语雀和Thoughts（teambition的内容管理），虽然也有腾讯文档与石墨文档等，其实从需求层面都可以使用，但是更多的侧重于个人使用，但是这些都是SaaS的，​​私有化​​部署贵的吓人。
然后找了支持本地化部署的MRdoc，但是这个版本是python的，我们的技术团队都是java，技术栈不对。然后也看了开源wiki，根据项目组的实际情况，修改代码，实现自己想要的效果。推荐使用dokuwiki，简洁、可自行性极高、支持权限、版本持续更新重。最大的的缺点是，编辑文档的操作性比较不友好。
最后我们选型的是 “​​无忧·企业文档​​”，对我们企业需求相当匹配。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/attachment/089f787eb4c540d19191a0423c476710/w600&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;p&gt;git开源地址：gitee.com/software-minister/jvs-knowledge-lib/tree/master&lt;/p&gt;

&lt;p&gt;PC端演示环境：
无忧·企业文档-微信扫码直接登录  knowledge.bctools.cn/#/index&lt;/p&gt;

&lt;p&gt;从开始看文档到部署完成，花了半天时间，文档支持还是比较充足。
部分图片：&lt;img src=&quot;https://img.toutiao.io/attachment/119710fff0124df1b445b8120029ce17/w600&quot; alt=&quot;file&quot;/&gt;&lt;img src=&quot;https://img.toutiao.io/attachment/ff7ab8847a8e4c5d89750f037e506cf1/w600&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、最后总结
• 团队一旦达到一定规模，内部信息流动的有效性降低，特别是在技能的传递与知识的沉淀上存在明显的问题。一定要有配套的机制进行技术内容的沉淀与知识的传递。&lt;/p&gt;

&lt;p&gt;• 一定要有所分工与负责人，内容的整理一定是要有经验，对公司的背景特点有非常深刻认识的。公司制度由人事管理、​​通用技术​​有技术部技术专家管理、市场知识类有市场总监负责、产品需求类由产品总监负责等。&lt;/p&gt;

&lt;p&gt;• 知识库的建立到一定程度之后，写的分享就会实实在在的帮助到新人或者其他成员，逐渐的，团队也就能感受到知识库的作用，但是这个过程比较漫长。个人认为分享知识，要调动所有人的积极性是不可能的事情，唯有负责人+强制+鼓励并行，才能真正的建立起知识库。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>083260150feefd9e01dfc9ef29fe082a</guid>
<title>网络字节序列-大端序和小端序</title>
<link>https://toutiao.io/k/ohy7j47</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485988&amp;amp;idx=1&amp;amp;sn=efad5a030bc0a933ac5af2ee09f3c6c4&amp;amp;chksm=fafde08acd8a699c198d0d65c413273f05f2796cfd873160c2ba81ed3f33aebfaccb62234cb7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《一个http请求进来都经过了什么(2021版)》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《一个http请求进来都经过了什么(2021版)》&lt;/a&gt;到&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486103&amp;amp;idx=1&amp;amp;sn=943c5b7f3558df78164321806f273c8f&amp;amp;chksm=fafde039cd8a692f86f0ac97b0e1e05ece075de3e4f33e6a5ec90b269c51aed1963ff3107e0e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《懂得三境界-使用dubbo时请求超过问题》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《懂得三境界-使用dubbo时请求超过问题》&lt;/a&gt;，再到&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486166&amp;amp;idx=1&amp;amp;sn=08a24c175c02a4b146dc52088d410599&amp;amp;chksm=fafde078cd8a696e616aebcb72aeef444e1e0008bf950a368933195f13c0a268face0d3ee371&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《接下来一段时间会对大家进行网络通信的魔鬼训练-理解socket》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《接下来一段时间会对大家进行网络通信的魔鬼训练-理解socket》&lt;/a&gt;和&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486186&amp;amp;idx=1&amp;amp;sn=f21e17b21beb4c99cef0e076071ac859&amp;amp;chksm=fafde044cd8a69526aa3ec9edbe71ea5aa41de2ef236494201dc2f20701ed8abc6be1a72344f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《深入理解MQ生产端的底层通信过程-理解channel》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;深入理解MQ生产端的底层通信过程-理解channel&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，我的思路是一篇篇的深入网络通信底层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到了通信底层，必须要了解的一个知识是网络字节序列。这个东东，99%以上的开发中都用不到。but:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先这个问题比较好理解；第二，要手动处理二进制流的话就不得不考虑，否则可能测试的时候完全没有发现问题，到线上出现诡异事件；第三，这个知识如此之重要，我记得大学的时候课本上也讲过。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;字节序列的历史&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;字节序列分成大端序（big endian或称大尾序）和小端序（little endian或称小尾序）。那为什么大小尾序会称为大小端序呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;术语“little endian(小端)”和“big endian(大端)”出自Swift的《格列佛游记》（Gulliver&#x27;s Trabels）一书，其中交战的两个派别无法就应该从哪一端（小端还是大端）打开一个半熟的鸡蛋达成一致。就像鸡蛋的问题一样，选择何种字节顺序没有技术上的理由。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“小”国和“大”国，这两大强国在过去三年一直在苦战。战争开始是由于：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是“小”国的祖父小时候吃鸡蛋，一次按古法打鸡蛋是碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由“大”国的人们煽动起来的。因为叛乱平息后，流亡的人总是逃到“大”国去寻救避难，“大”国的人口就增加了。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不得做官。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Swift是在讽刺英国和法国之间的持续的冲突。Danny Cohen，一位网络协议的早期开创者，第一次使用这两个术语来指代字节顺序，后来这个术语被广泛接纳了。因为产生两种序列的标准和Swift讲的故事如出一辙：几十年前，两强互相看不惯，摩托罗拉(Motorala)使用大端序，英特尔(Intel)使用小端序。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;大端序和小&lt;strong&gt;&lt;span&gt;端&lt;/span&gt;&lt;/strong&gt;序的理解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数值例如0x2266使用两个字节储存：高位字节是0x22，低位字节是0x66。&lt;/p&gt;&lt;blockquote/&gt;&lt;p&gt;0x1234567大端字节序和小端字节序的写法如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;200&quot; data-backw=&quot;400&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibpMFn6yJ42PkM6FDR6NNvsNKyHic0WYn72S9OeWvJMgrIgPvGKscDLf9tgN5lIttJt35Gp1CdsliaA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;打个比方：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlibpMFn6yJ42PkM6FDR6NNvspUShpCYV4Tp2Kmgpic2OuibiaJBicB3FicnIrZ1Wno4Z8WJeT9qwGGbkE6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;结论：网络字节序列传输采用大端序。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;标准不同引发的问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2016年我做了一款用于处理图片位置被旋转的方法和工具，并成功申请了专利。起因是这样的：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;做过一个项目，有天运营打电话过来说：“有个用户上传了头像到咱们应用上，结果头像是倒置的。”我去后台一看果然是和练倒立一样倒置着脑袋。我们自己测试的时候，从来没有发生这种问题。但是用户所有的声音都是有道理的。当时我们动员了公司所有人用我们的应用看看有没有类似的情况。终于在一个三星的手机上重现了这个问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;原来照片属性中是存储了旋转信息的，我们之所以看到照片显示的位置都很正确，其实是iphone系统，还有大部分的安卓系统发现图片被旋转了之后都有将图片旋转回来的处理。但是在部分android系统中，却没有做这种处理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32470334412081986&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibpMFn6yJ42PkM6FDR6NNvsT358Kk1c1sfxibFKicYLN1PTKBibmLqld7Gn8LAGerse0xY1ga9AzU1KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;927&quot;/&gt;&lt;/p&gt;&lt;p&gt;上面两张图片，每张图片被旋转了旋转了8个角度。这里面只有它们的EXIF信息里的orientation值不同。EXIF信息是数码相机的拍摄信息，在压缩文件的格式中只有JPEG格式的储存了这种信息。它可以有1-8的8个值。分别对应于旋转0度，水平翻转，旋转180度，垂直翻转，顺时针90度—+水平翻转，顺时针90度，顺时针90度+垂直翻转，逆时针90度。这时就会发生这种情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;经过调查发现目前并没有现成的java类库来做这件事情，基本都是从系统层面就解决了这个问题。确实有图片处理的类库，可是添加一个大jar包进来就只为获取图片的旋转信息，jar包可有将近一个MB呢。所以咱们尽量还是自己写工具类来解决问题吧。因为这种解决这种问题不涉及其他的处理，这时只用这样一个针对特定问题的工具类增加了代码的可读性，减少了服务器负担。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实现原理简单可以理解为：存储图片的旋转信息都是放在EXIF信息里。所以只要找到EXIF信息，根据EXIF信息里的旋转方向将图片旋转回来即可。当然实际上各种考虑要复杂的多。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;还记得&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485790&amp;amp;idx=1&amp;amp;sn=28d1275aec18350f7627e81bbdab4dfc&amp;amp;chksm=fafde3f0cd8a6ae60b893b6998175db1c20e96328a5721a1b00a2d7b231d141ba7e85f02c6f0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《面试中一个暴露能力等级的问题》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《面试中一个暴露能力等级的问题》&lt;/a&gt;那篇文章吗？相信只要在工作中遇到问题仔细思考，不放过，一定能说出让面试官眼前一亮的故事。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6d39e299e619d6434e0f636dcf6bbbcf</guid>
<title>干货 | 分布式数据库TiDB在携程的实践</title>
<link>https://toutiao.io/k/67t945m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MjM5MDI3MjA5MQ==&amp;amp;action=getalbum&amp;amp;album_id=2170120724240302083#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;2170120724240302083&quot; data-tag_source=&quot;3&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#数据库&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;1个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:0.title1&quot;&gt;&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Army，携程数据库专家，主要负责分布式数据库运维及研究。&lt;/p&gt;&lt;p&gt;Keira，资深数据库工程师，主要负责MySQL和TiDB运维。&lt;/p&gt;&lt;p&gt;Rongjun，携程大数据架构开发，专注离线和实时大数据产品和技术。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程自2014年左右开始全面使用MySQL数据库，随着业务增长、数据量激增，单机实例逐渐出现瓶颈，如单表行数过大导致历史数据查询耗时升高，单库容量过大导致磁盘空间不足等。为应对这些问题，我们采取了诸多措施如分库分表的水平拆分、一主多从读写分离、硬件SSD升级、增加前端Redis缓存等，但同时也使得整个业务层架构更加复杂，且无法做到透明的弹性，因此开始将目光转移到分布式数据库以解决这些痛点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近年来受到Spanner&amp;amp;F1的启发，基于CAP理论和Paxos、Raft协议作为工程实现的分布式数据库得到了蓬勃发展，从硅谷的CockroachDB到国产的TiDB都在社区产生了很强的影响力。携程也对这些产品从社区活跃度、用户规模、易用性等多个方面做了调研，最终选择了国产的TiDB。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB是一个开源的NewSQL数据库，支持混合事务和分析处理（HTAP）工作负载，兼容大部分MySQL语法，并且提供水平可扩展性、强一致性和高可用性。主要由PingCAP公司开发和支持，并在Apache 2.0下授权。2018年11月我们开始TiDB的POC以及与携程现有运维平台的整合，2019年1月第一个线上应用正式接入，最初的目标只是保证数据库的可用性以及可以存储足够多的关系型数据。随着TiDB快速迭代，越来越多的功能进入社区，如HATP特性，让我们不局限于最初的目标，开始了新的探索。本文将介绍TiDB在携程业务场景中的运维实践，希望对读者有所帮助和参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、架构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程内部历时1年，代号为“流浪地球”的机房级故障演练，验证了IDC级别故障容灾能力。我们将TiDB的三个副本分布在三个数据中心，保证在单中心故障时不影响对外服务，同时数据一致性也不受影响，并在tidb-server层实现了自动探活以及自动故障切换，让RPO等于0，RTO小于30S。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来了解一下TiDB的整体架构（如图1-1），再结合携程的场景来部署。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5244479495268138&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlVOWWWXtR6ckO6HmJBBpeTPlCmSrVx9L6icZxZsz2SsS5ujT9MXDqvvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1-1 TiDB的整体架构图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从TiDB的架构图我们可以看到，得益于组件 PD 和 TiKV 都通过 Raft 实现了数据的容灾，原生就提供了多IDC的部署能力，和 Google Spanner 采用原子钟方案不同的是，TiDB 采用了 PD 进行单点全局统一授时的 Timestamp方案。TiDB 中的每个事务都需要向 PD leader 获取 TSO，当 TiDB 与 PD leader 不在同一个数据中心时，它上面运行的事务也会因此受网络延迟影响。目前携程的跨 IDC 延迟在 0.5-2ms之间 ，属于可接受的延迟范围。配置三数据中心时，需要对相应的TiKV和PD的label配置规则，这样PD在调度re&lt;/span&gt;&lt;span&gt;gion副本时会根据标签属性在每一个机房都拥有一份全量数据。具体的一个配置示例，如图1-2：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.32636469221835074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlnicXUdMNyYRCvnRBtibsOdLrj0fcAicjCcudyzFLJ3HUcUKFCSwiadssuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1-2 TiDB在携程的部署架构和配置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种部署架构的优点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;所有数据的副本分布在三个数据中心，具备IDC级别的高可用和容灾能力&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任何一个数据中心失效后，不会产生任何数据丢失 (RPO = 0)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任何一个数据中心失效后，其他两个数据中心会自动发起 leader election，并在合理长的时间内（通常情况 20s 以内）自动恢复服务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB目前已经应用到携程的多个业务场景，包括风控、社区、营销、搜索、酒店等。这里选取两个比较典型的使用案例——国际业务CDP平台和酒店结算业务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 国际业务CDP平台&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为Trip数据来源比较广泛，既有自身数据也有外部数据；数据形式也非常多样化，既有结构化数据，也有半结构化和非结构化数据；数据加工形式既有离线数据处理，也有在线数据处理，因此国际业务构建了CDP平台以解决加工这些数据，形成业务系统、运营、市场需要并且可以理解的数据和标签，具体可以阅读往期文章：《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;amp;mid=2697271936&amp;amp;idx=2&amp;amp;sn=72d5a081eb34f37a3bd3bdc9e1758b88&amp;amp;chksm=8376e5b4b4016ca2a37435cc855ac9a119a1546821aff30ecef51631c0d14ee31e5ee6695e39&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;携程国际业务动态实时标签处理平台实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;携程国际业务动态实时标签处理平台实践&lt;/a&gt;》。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ti&lt;/span&gt;&lt;span&gt;DB在其中主要承担存储业务持久化的标签以及内部SOA调用的查询服务。查询分为UID等维度的基础信息查询、订单订阅基础信息查询的OLTP，以及EDM\Marketing等人群的OLAP查询。整个CDP平台的架构如图2-1：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.47012302284710017&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlQknvoGVddYSFXx1kxiaWEPornWQNjegMaX0P3yl3AAEc8AsicLWuiapEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1138&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-1 CDP平台架构图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体的数据处理，历史全量数据通过数据批处理引擎（如Spark）转换完成以后批量写入到数据持久化存储引擎（TiDB），增量数据业务应用以消息的形式发送到Kafka或者QMQ消息队列，通过实时DAG处理完后持久化到存储引擎（TiDB）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;持久标签访问的主要场景有两个，一种是跟现有CRM系统对接，在线根据业务的特征圈选符合条件的业务数据，这种场景的查询条件不固定，返回结果集因筛选条件而定，对于数据存储引擎的数据计算和处理能力要求比较高，即我们在数据处理领域经常提到的OLAP的场景。&lt;/span&gt;&lt;span&gt;另一种场景是线上业务根据前端传入的业务标签相关的唯一标识来查询是否满足特定业务要求，或者返回指定特征值，满足业务处理的需要，需要毫秒级响应，对应的是OLTP场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于标签的多样性，有查询记录的字段多达60个，查询条件是60个字段的随机组合，无法通过传统数据库层的Index来提高查询效率，经典的方案是OLTP和OLAP分离，但数据会存储多份，多数据源的数据一致性是一个很大的挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于这种场景，我们开启了TiDB的TiFlash，TiFlash 是 TiDB HTAP 形态的关键组件，它是 TiKV 的列存扩展，在提供了良好的隔离性的同时，也兼顾了强一致性。列存副本通过 Raft Learner 协议异步复制，但是在读取的时候通过 Raft 校对索引配合 MVCC 的方式获得 Snapshot Isolation 的一致性隔离级别。&lt;span&gt;TiFlash&lt;/span&gt; MPP模式如图2-2。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.51875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlSAMeqJap3J7C4icicsj0qZ0bWHgNeKYxeqM6E1w4NTZBKnBKrmv2icCQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-2 TiDB MPP模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种架构很好地解决了 HTAP 场景的隔离性以及列存同步的问题，开启之后几个典型查询性能提升：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;TiFlash MPP提升，20s -&amp;gt; 1s&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;Set @@session.tidb_allow_mpp=1;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;Set @@session.tidb_enforce_mpp=0;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.12812248186946013&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlaicH70pms48eA0u6kAl6avI4Bqzyq7O25jOElCp7StJ2nTUn665XUAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1241&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;TiFlash 列裁剪，16.9s -&amp;gt; 2.8s&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;Set @@session.tidb_allow_mpp=1;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;Set @@session.tidb_enforce_mpp=0;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;Set session tidb_isolation_read_engines =’tidb,tiFlash’;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.07661290322580645&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlCM8th2Kwk5ehiblHuqrvVpNG3SfNc4HM2WLwflm8icMecLVVCA51JSHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2 酒店结算业务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程酒店结算业务全库6T，单服务器存储6T全量数据有很大挑战。常规的方法是用分库分表的方式来减少实例数据量及压力，但分库分表的维度很难确定，无论从酒店维度还是供应商维度都无法避免跨片的查询，给程序的开发带来了很大的困难，并且大部分查询都是聚合运算，因此我们尝试迁移到TiDB。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前最大的表存储了28亿条数据，读写已完全切换到TiDB。具体所使用的部署模式和上节提到的国际业务CDP平台类似，同样是开启了TiDB的TiFlash来加速查询的性能，具体的性能如图2-3：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5172995780590718&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlVQiawmS0L6MbvEGbLjbTVuL7hbsEibzzqMgnbBSqTUSrOcIhdhF9ugdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1185&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-3 酒店结算性能监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、一些问题的实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1 参数不合理导致的性能问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式数据库有别于传统单机，通常MySQL遇到性能问题时可以快速定位是由于网络抖动、SQL缺失索引还是请求次数激增等原因导致的，但分布式的&lt;span&gt;Ti&lt;/span&gt;&lt;span&gt;DB&lt;/span&gt;&lt;/span&gt;&lt;span&gt;组件众多，各个组件之间的网络通信、某个组件资源不足、SQL复杂等都可能是导致出现性能问题的原因。目前官方提供了问题导图，方便根据不同的场景尽快定位原因。这里给出一个具体的案例，总结了一个典型问题的排查思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;国际业务集群使用官方默认配置的集群上线测试时，发现写入耗时高达秒级，且耗时波动较大。来自应用端的监控（纵坐标单位为毫秒）,如图3-1：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7613636363636364&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlSibFtzZUTujYhHM0LjJAuWwpQ3Rnb74hBuS6NA4fKSJRmSd2EtdtaWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;528&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3-1 IBA写入响应监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据Pingcap的导图发现scheduler command duration的时间约等于事务的prewrite时间（纵坐标单位为秒），可以看出scheduler-worker不足。如图3-2：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.40339425587467365&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlrTV5ahKCibPuUicKpC8HGWXZ4HSEKC6VZc5D1MmxrdSvibr4xGdZsJBFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;766&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3-2 scheduler command duration的时间&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以我们做了如下的调整：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;调整完成后来自应用端的监控（纵坐标单位为毫秒），如图3-3，红色箭头处是参数调整的时间点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4430379746835443&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlxhVWz64nt2icsCnOMmuibWnmVUPuT56XFTqKdOacxtZqkQqqTojgnEIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3-3 IBA写入响应监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;默认配置并非最佳配置，需要根据服务器硬件、使用场景不断调试并最终固化为每个集群甚至所有集群的最佳实践配置；根据PingCAP提供的问题导图，逐步定位具体哪个组件哪个方面存在瓶颈，我们同时也在进一步开发一键定位工具，能更快速的定位性能瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2 分布式带来的自增列问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;含自增列的表，在自增列不强制赋值的情况下，insert语句报主键冲突：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;报错SQL：INSERT INTO `xxx_table ` (`id, `name`, `tag`, `comment`, `creator`) VALUES (?, ?, ?, ?, ?)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;报错内容：com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrity&lt;/span&gt;&lt;span&gt;Constraint&lt;/span&gt;&lt;span&gt;ViolationException: Duplicate entry 175190 for key &#x27;PRIMARY&#x27;.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在PingCAP官方文档上，有以下介绍：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB 中，自增列只保证自增且唯一，并不保证连续分配。TiDB 目前采用批量分配 ID 的方式，所以如果在多台 TiDB 上同时插入数据，分配的自增 ID 会不连续。TiDB 实现自增 ID 的原理是每个 tidb-server 实例缓存一段 ID 值用于分配（目前会缓存 30000 个 ID），用完这段值再去取下一段。假设集群中有两个 tidb-server 实例 A 和 B（A 缓存 [1,30000] 的自增 ID，B 缓存 [30001,60000] 的自增 ID），依次执行如下操作：客户端向 B 插入一条将 id 设置为 1 的语句 insert into t values (1, 1)，并执行成功。客户端向 A 发送 Insert 语句 insert into t (c) (1)，这条语句中没有指定 id 的值，所以会由 A 分配，当前 A 缓存了 [1, 30000] 这段 ID，所以会分配 1 为自增 ID 的值，并把本地计数器加 1。而此时数据库中已经存在 id 为 1 的数据，最终返回 Duplicated Error 错误。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过这段介绍，我们了解到造成自增主键冲突，是因为存在自增主键显式插入导致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;结论：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;分布式数据库对于表自增列是预分配的，自增主键显式插入会导致tidb-server上的计数器混乱，引起数据写入报错。在开发规范中，我们明确要求TiDB不允许自增主键显式插入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3 修改字段是否为空导致默认值异常&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下的表，我们字段从int升级到bigint&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CREATE TABLE `test` (`id` int);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` add `col1` int(11) null default &#x27;0&#x27;;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` add `col2` int(11) null default &#x27;0&#x27;;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` change `col1` `col1` bigint(20) null default &#x27;0&#x27;;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` change `col2` `col2` bigint(20) null default &#x27;0&#x27;;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们发现默认值0不合适，因此，执行下面的语句，把默认值调整为null&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` change `col1` `col1` bigint(20) null ;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` change `col2` `col2` bigint(20) null&#x27;;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时，我们插入一条数据：insert into test(id) values(1);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;神奇的发现，col1和col2的值依旧是0. 这和我们的预期不符。经过一系列重现测试，以及社区论坛的查找，我们发现这个问题是一个已知问题。&lt;a target=&quot;_blank&quot; href=&quot;https://github.com/pingcap/tidb/pull/20491&quot; textvalue=&quot;https://github.com/pingcap/tidb/pull/20491&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;https://github.com/pingcap/tidb/pull/20491&lt;/a&gt;. 该Bug在TiDB 4.0.9及以后版本已修复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;结论：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;成熟的社区论坛是TiDB日常运维和快速排障的利器，借助社区论坛上各种技术探索和交流分享，可以汲取优质内容，收获前沿知识，快速定位和解决问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、监控与告警&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于分布式数据库运维，监控和告警是非常核心的一环，冒烟现象或者不规范现象，需要及时发现，及时解决，避免问题恶化。监控准确、告警及时可以帮助运维人员准确定位问题，快速解决故障。TiDB 使用开源时序数据库 Prometheus 作为监控和性能指标信息存储方案，使用 Grafana 作为可视化组件进行展示，我们在此基础上进一步做了整合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.1 TiDB监控大盘&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB原生提供prometheus+Grafana的性能大盘，数据非常丰富，但数据分散在单独的集群，无法提供全局视角，我们通过prometheus源生remote write到9201端口，自研了一个adaptor监听9201端口，转发性能数据到携程统一监控平台，搭建了我们自己的监控大盘。如图4-1：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.45&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlYNjibrJTuNyUbfuMBXqn3O27sghq24cIBWCMfd530hBT8gD1lSUU0xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4-1 整合后的TiDB监控大盘 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.2 三副本监控&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB使用三个以上的副本，通过raft协议来保证数据的一致性。当出现多数副本丢失或者宕机时，这部分数据处于不可用状态，是否存在副本缺失或者副本状态异常是需要特别注意的。因此我们会针对副本的数目及状态进行巡检，确保不会出现长时间内副本不足的情况，一旦发现有副本丢失，可以增加副本的调度线程，务必及时解决副本缺失问题。Region Peer的监控如图4-2：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4709090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdl5AMVht994duxmH66vOKjq80s4nltUJgRej56DwmA93Mx1zAl9n1jbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4-2 三副本监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.3 磁盘容量监控&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB存储数据量庞大，需要特别关注机器磁盘剩余可使用空间的情况，以免写满磁盘造成不必要的故障。对于磁盘的监控，我们的阈值是物理磁盘的80%，一旦磁盘使用容量超过阈值，我们需要安排加机器扩容。对比相同情况下MySQL复杂的拆分方法，TiDB的处理方法更简单高效。磁盘的监控告警如图4-3：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5444444444444444&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlem5Ao42rbS1CZickcCZfCXIjxY0zLYFT0giaYRpHzh9PWJD3FJDPzFTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;360&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4-3 TiDB磁盘监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.4 配置标准化检查&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB集群的配置文件参数、系统参数众多，不同实例的配置项各不相同，且经常会对集群扩容缩容，因此我们要求变更前后集群的配置必须严格按照标准配置进行调整。只要做到配置标准，很大程度上就会保证集群标准化运行。配置标准化的监控告警如图4-4：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.16752312435765673&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1crw9HkpWicbLUPHibZpLqibqCp7RzaX0XDWjzobFyVIpibVolrHR04ZpJNI8EjFr3EPw55WI8z3m6QZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;973&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4-4 配置标准化的监控告警&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.5 性能告警&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有时候会存在突发的流量上升，或者瞬间的性能尖峰的情况，这时候就需要关注性能告警。METRICS_SCHEMA 是基于 Prometheus 中 TiDB 监控指标的一组视图，有了基础的性能数据，我们只需要根据性能阈值，及时告警，及时分析处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、周边工具&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了监控与告警，我们也开发了一系列周边工具，对于TiDB的运维，带来了更大的便利。这些周边工具主要包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.1 和现有的数据周边工具打通&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现有的数据周边工具主要包括：数据库的发布（DDL），数据在线查询，数据在线修改，以及和现有的大数据流程打通等，这些支持MySQL的工具也一样可以支持TiDB，为MySQL迁移TiDB打解决了后顾之忧，让之前使用MySQL的开发测试人员可以方便流畅地切换到TiDB。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.2 TiDB部署工具&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB集群实例角色较多，集群部署有别于传统单机，需要单独开发一套部署工具，包括集群上线流程、集群下线流程、扩容缩容实例、集群版本升级等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.3 TiDB闪回工具&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有时候会遇到开发测试人员误操作数据的情况，可以使用数据闪回工具进行回退，我们借助TiDB binlog开发了闪回工具，对binlog的内容做反转，生成数据恢复SQL，供 TiDB数据恢复使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、未来规划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.1 故障的一键分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式数据库与单机不同， TiDB组件比较多，可供调整的参数有数百个，各个组件之间的网络通信、某个组件资源不足、SQL复杂等都可能导致出现性能问题，后续计划将TiDB诊断做成自动化和智能化，目前已经通过改造TiDB server源码，完成了TiDB的全链路SQL收集和分析，这将作为未来故障一键分析的基础。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.2 基于HDD硬盘测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB 所有的优化都是基于SSD来做的，高性能意味着高成本。我们还是会面临数据量比较大，但写入和查询都比较少，响应要求不高的场景。我们目前已经完成基于HDD硬盘的测试，选择的机器配置为12块10T HDD硬盘，单机部署12个TiKV实例，这种架构已经在小范围应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.3 同城双中心自适应同步方案DR Auto-Sync&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DR Auto-Sync 正处在高速迭代的周期中，后续版本将会有一系列高可用和容灾能力的加强。从 5.3.0 开始将支持双中心对等部署，藉此获得快速恢复多副本的能力，我们也在保持关注中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;【推荐阅读】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1crw9HkpWicbLUPHibZpLqibqCNpp1MADT0D3Tic6Aaw2wmqnpOhvqedVNzZbkqicLxbb6h9O8p1uNKI6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; “携程技术”公众号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  分享，交流，成长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bdc555394158f6d5c74e5e8e01bd45a2</guid>
<title>如何用Python爬取网易云音乐歌单</title>
<link>https://toutiao.io/k/3xwcyvs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;pre data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;点击⬆️方“&lt;/span&gt;&lt;span&gt;逆锋起笔&lt;/span&gt;&lt;span&gt;”，&lt;/span&gt;&lt;span&gt;公众号回复 &lt;/span&gt;&lt;span&gt;编程资源&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;领取大佬们推荐的学习资料&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;作者：我不是秃头哆唻咪 （侵删）&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;https://blog.csdn.net/weixin_44864260/article/details/113428996&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;此货很干,跟上脚步!!!&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Cookie&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;cookie是什么东西?&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;小饼干?能吃吗?&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;简单来说就是你第一次用账号密码访问服务器&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;服务器在你本机硬盘上设置一个身份识别的会员卡(cookie)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下次再去访问的时候只要亮一下你的卡片(cookie)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;服务器就会知道是你来了,因为你的账号密码等信息已经刻在了会员卡上&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;需求分析&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;爬虫要访问一些私人的数据就需要用cookie进行伪装&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;想要得到cookie就得先登录,爬虫可以通过表单请求将账号密码提交上去&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是在火狐的F12截取到的数据就是,&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;网易云音乐先将你的账号密码给编了码,再发post请求&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以我们在准备表单数据的时候就已经被卡住了&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这时候我们就可以使用自动化测试Selenium帮助我们去登录&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;登录好之后就获取cookie给爬虫使用&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;OK,废话也废话完了,直接开整吧!!&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先跟我创建一个爬虫项目和爬虫&lt;br/&gt;在cmd创建&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5244897959183673&quot; data-type=&quot;png&quot; data-w=&quot;980&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPmu7ickftcibgBmGJmesR4xeXdSgLPoMKC5kMUCy61wkteEmiat98tqTFw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;用Pycharm打开这个项目&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先修改配置文件setting.py&lt;br/&gt;1.关闭机器人协议&lt;br/&gt;2.取消禁用cookie的功能&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.0174520069808028&quot; data-type=&quot;png&quot; data-w=&quot;573&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPhX9rKwj6H6yOpfBDXSngAa5VrmYmGDub70ZXhrk8IRC8ooY9R7tMyQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;现在就回到爬虫文件wyySpider.py准备前期的工作&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;修改start_urls里的网址&lt;/strong&gt;和&lt;strong&gt;准备一个请求头&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;首先用火狐浏览器打开网易云音乐,登录后进入到个人主页&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.1129032258064515&quot; data-type=&quot;png&quot; data-w=&quot;372&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPrsKc6Mo5Kylq0oI28yovtlPlRYUb54WNGo87llS16Nk8vFrlXrLcyg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8128031037827352&quot; data-type=&quot;png&quot; data-w=&quot;1031&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPJL8gyhEabOuqvLzeMG355Wl7vRibSVKFr5bCfTYwhiah4jpgBupL1EDg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4991852254209669&quot; data-type=&quot;png&quot; data-w=&quot;1841&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPxyL0SzxibNP4VScLscSXK4MbSrQj2AAFYz5hqPCH5iaHiaCC2MibycXwJg/640?wx_fmt=png&quot;/&gt;&lt;img data-ratio=&quot;0.28702851885924563&quot; data-type=&quot;png&quot; data-w=&quot;1087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPbFicoyMTXxUL7sDkmg5qr6C0pZWbjuyG8LKTibxAzPH2klv08KWMW0sg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在爬虫代码那里准备一下,修改一下start_urls&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt; scrapy&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt; webdriver&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.action_chains &lt;span&gt;import&lt;/span&gt; ActionChains&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; time&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WyyspiderSpider&lt;/span&gt;&lt;span&gt;(scrapy.Spider)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    name = &lt;span&gt;&#x27;wyySpider&#x27;&lt;/span&gt;&lt;br/&gt;    allowed_domains = [&lt;span&gt;&#x27;163.com&#x27;&lt;/span&gt;]&lt;br/&gt;    start_urls = [&lt;span&gt;&#x27;https://music.163.com/playlist?id=19xxxxx7&#x27;&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;先实现一下&lt;strong&gt;自动登录功能获取cookie&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先导一下自动化测试的包(Selenium)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;没有这个包的话去控制台:pip --default-timeout=100 install selenium -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt; webdriver&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.action_chains &lt;span&gt;import&lt;/span&gt; ActionChains&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; time&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;导完包还要一个谷歌的驱动程序,先看一下自己的谷歌版本&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4195612431444241&quot; data-type=&quot;png&quot; data-w=&quot;1094&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPsNJBndJsib8iccT3fXMIGbxbA5ANKmzj92mUEHyibHsdn2dib4BXU0VfGA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;到这网站下载相同版本的驱动程序:&lt;/span&gt;&lt;span&gt;https://sites.google.com/a/chromium.org/chromedriver/home&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果版本跟我的一样可以去网盘下载:&lt;br/&gt;链接: https://pan.baidu.com/s/1M-gME2R8EEhEoFlPaDhbmA 提取码: 7iai&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;解压后记住这个驱动的位置,在爬虫文件写一个获取cookie的函数（微信搜索readdot，关注后回复 编程资源，领取各种经典学习资料）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;以下代码的坐标不一定适合各位的电脑,不过给你们安利个物理外挂(电脑微信截图Alt+A)&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;        &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;getCookie&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 获取谷歌的驱动,参数为刚刚驱动程序的位置&lt;/span&gt;&lt;br/&gt;        driver = webdriver.Chrome(&lt;span&gt;&quot;C:/Users/Administrator/AppData/Local/Programs/Python38/Lib/site-packages/selenium/webdriver/chrome/chromedriver.exe&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# -----------------selenium自动登录-----------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 打开谷歌然后访问指定的网站&lt;/span&gt;&lt;br/&gt;        driver.get(&lt;span&gt;&quot;https://music.163.com/&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 最大化,睡眠是怕网速慢没加载出来&lt;/span&gt;&lt;br/&gt;        driver.maximize_window()&lt;br/&gt;        time.sleep(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 鼠标从(0,0)向x(1435px),y(35px)移动,用左键点击一下&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;1435&lt;/span&gt;, &lt;span&gt;35&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 点击其他方式&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;-480&lt;/span&gt;, &lt;span&gt;575&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 同意条款&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;-218&lt;/span&gt;, &lt;span&gt;-10&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 手机登录&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;107&lt;/span&gt;, &lt;span&gt;-100&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 输入账号密码&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 通过css选择器获取id为&quot;p&quot;的标签,然后send_keys就是模拟输入一些信息&lt;/span&gt;&lt;br/&gt;        driver.find_element_by_css_selector(&lt;span&gt;&quot;#p&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;账号&quot;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_css_selector(&lt;span&gt;&quot;#pw&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;密码&quot;&lt;/span&gt;)&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 点击登录&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;110&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 找到头像悬浮&lt;/span&gt;&lt;br/&gt;        img = driver.find_element_by_css_selector(&lt;span&gt;&quot;div.head:nth-child(1) &amp;gt; img:nth-child(1)&quot;&lt;/span&gt;)&lt;br/&gt;        ActionChains(driver).move_to_element(img).perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.5&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 点击我的主页&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;40&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.5&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 点击喜欢的音乐&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;-870&lt;/span&gt;, &lt;span&gt;830&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# -----------------selenium自动登录-----------------------&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;登录完毕后就可以获取cookie,但看一下下面的cookie&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;[{&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;2147483647&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;WM_TID&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;UnQj6SSNqN9BEVdubmNcEjpl%2B9DA&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;2147483647&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;WM_NIKE&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;9ca17ae2e6ffcda170e2e6ee87f4508ef58483ea4a97968ea7c54e879a8eaaf445aebc83b6e933f3f1c0b4c82af0fea7c3b92af697b7a6dc7b82afc09ad98ca695bc5082ecbcb1e772b7889b3d1c15bf28da0bbfb5b95aa8795f073adbc9c98ed79a28d8aa7f450f1ae9dd9b77a85edbf9ac625f1ef84d8f970b4e7bfd8cd21b48e8c8ec17df3e7a898f74488ef9bb5c837e2a3&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;.music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;WNMCID&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;sameSite&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;Strict&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;fdygqk.1611989994304.01.0&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;.music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;WEVNSM&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;sameSite&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;Strict&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;1.0.0&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;2147483647&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;WM_NI&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;6IyEYqBqpyZMITjt9DB4tPdzuXUFC%2BNyOiu3S04CTC5Nsv2Q4gkMM0BQ2SPZxQWvItmyodTwnsbSFFqD3rS84rG3qyG%2F31L7zdp9q7N%2BpRDmBw19hwtHD1UTE%3D&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;.music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;1927349994&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;NMTID&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;00O-pWx8ZDJJQfiFkHzsgin07nYSmUAAAF3UhdN2w&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;4765589994&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;_ntes_nuid&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;738fc9cd89d6d8799fa76b3348d25d7d&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;4765589994&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;_ntes_nnid&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;738fc9cd89d6d8799fa76b3348d25d7d,1611989994150&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;.music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;1769671794&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;_iuqxldmzr_&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;32&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;.music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;1769671794&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;JSESSIONID-WYYY&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;OoCMxNwGV%5CfZD2OSzAXovf4ASVZsJ8UQ4sgg7JfH075cKTD%2FW3sMzZj%2BpayS1EnNVXzRm%2F2GxfzIoNv3FTjYxKeNFZWqf6UeiMSc1%2BG98kgsEM94juuE%5Cs18k2%2BPNPAp3hU0G%5CFDUtjkimCR5pgOIOI%3A1611991794102&#x27;&lt;/span&gt;}]&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;是列表加字典的结构,而Scrapy的cookie是字符串类型的,所以我们要做一个转型&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;# 将driver获取的字典类型的cookie提取name和value封装成字符串&lt;/span&gt;&lt;br/&gt;        temp = []&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; driver.get_cookies():&lt;br/&gt;            temp.append(i[&lt;span&gt;&#x27;name&#x27;&lt;/span&gt;] + &lt;span&gt;&quot;=&quot;&lt;/span&gt; + i[&lt;span&gt;&#x27;value&#x27;&lt;/span&gt;])&lt;br/&gt;        &lt;span&gt;# 返回字符串cookie&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;;&#x27;&lt;/span&gt;.join(temp)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;所以这个函数基本就写完了,自动登录后获取cookie是不是很爽!!!&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在重写一下def start_requests(self),这个函数是在请求发起前执行的&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;在这个函数把请求头给塞进去,因为setting那边没有定义&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;start_requests&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 定义请求头的时候调用一下getCookie获取一下cookie&lt;/span&gt;&lt;br/&gt;        headers = {&lt;br/&gt;            &lt;span&gt;&#x27;Cookie&#x27;&lt;/span&gt;: self.getCookie(),&lt;br/&gt;            &lt;span&gt;&#x27;User-Agent&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36&#x27;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;# 注意url是个列表这里拿下标[0],然后把headers请求头塞进去,交给parse函数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;yield&lt;/span&gt; scrapy.Request(url=self.start_urls[&lt;span&gt;0&lt;/span&gt;], headers=headers, callback=self.parse)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;请求前一切准备好之后,在解析函数(parse)进行保存一下数据,记得导re包&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;parse&lt;/span&gt;&lt;span&gt;(self, response)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 匹配歌曲名的正则表达式&lt;/span&gt;&lt;br/&gt;        patt = re.compile(&lt;span&gt;r&#x27;&amp;lt;a href=&quot;/song.id=.*?&quot;&amp;gt;([^&amp;lt;|{]*?)&amp;lt;/a&amp;gt;&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 找到所有歌曲名&lt;/span&gt;&lt;br/&gt;        listdata = re.findall(patt, response.text)&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;# 把数据写进txt文件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;with&lt;/span&gt; open(file=&lt;span&gt;&quot;../response.txt&quot;&lt;/span&gt;, mode=&lt;span&gt;&quot;w+&quot;&lt;/span&gt;, encoding=&lt;span&gt;&quot;utf-8&quot;&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; file:&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; listdata:&lt;br/&gt;                file.write(item+&lt;span&gt;&quot;\n&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;一句启动爬虫的命令,眨眨眼的时间 ~&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;数据就进去了哦!原来我的喜爱歌单只有不到500~&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.026098901098901&quot; data-type=&quot;png&quot; data-w=&quot;728&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPXibZJJlnu4bHSWTQG1ZBOKQjIJmPuNzbAlu5WzX0rfn0iaZy0dh00VQg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;下面就是爬虫源代码&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt; scrapy&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt; webdriver&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.action_chains &lt;span&gt;import&lt;/span&gt; ActionChains&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; time&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; re&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WyyspiderSpider&lt;/span&gt;&lt;span&gt;(scrapy.Spider)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    name = &lt;span&gt;&#x27;wyySpider&#x27;&lt;/span&gt;&lt;br/&gt;    allowed_domains = [&lt;span&gt;&#x27;163.com&#x27;&lt;/span&gt;]&lt;br/&gt;    start_urls = [&lt;span&gt;&#x27;https://music.163.com/playlist?id=19xxxxx7&#x27;&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;getCookie&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 获取谷歌的驱动,参数为刚刚驱动程序的位置&lt;/span&gt;&lt;br/&gt;        driver = webdriver.Chrome(&lt;span&gt;&quot;C:/Users/Administrator/AppData/Local/Programs/Python38/Lib/site-packages/selenium/webdriver/chrome/chromedriver.exe&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# -----------------selenium自动登录-----------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 打开谷歌然后访问指定的网站&lt;/span&gt;&lt;br/&gt;        driver.get(&lt;span&gt;&quot;https://music.163.com/&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 最大化,睡眠是怕网速慢没加载出来&lt;/span&gt;&lt;br/&gt;        driver.maximize_window()&lt;br/&gt;        time.sleep(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;# 以下坐标以自己的电脑为准&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 鼠标从(0,0)向x(1435px),y(35px)移动,用左键点击一下&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;1435&lt;/span&gt;, &lt;span&gt;35&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 点击其他方式&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;-480&lt;/span&gt;, &lt;span&gt;575&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 同意条款&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;-218&lt;/span&gt;, &lt;span&gt;-10&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 手机登录&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;107&lt;/span&gt;, &lt;span&gt;-100&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 输入账号密码&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 通过css选择器获取id为&quot;p&quot;的标签,然后send_keys就是模拟输入一些信息&lt;/span&gt;&lt;br/&gt;        driver.find_element_by_css_selector(&lt;span&gt;&quot;#p&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;账号&quot;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_css_selector(&lt;span&gt;&quot;#pw&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;密码&quot;&lt;/span&gt;)&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 点击登录&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;110&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 找到头像悬浮&lt;/span&gt;&lt;br/&gt;        img = driver.find_element_by_css_selector(&lt;span&gt;&quot;div.head:nth-child(1) &amp;gt; img:nth-child(1)&quot;&lt;/span&gt;)&lt;br/&gt;        ActionChains(driver).move_to_element(img).perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.5&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 点击我的主页&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;40&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.5&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# # 点击喜欢的音乐&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# ActionChains(driver).move_by_offset(-870, 830).click().perform()&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# time.sleep(0.3)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# -----------------selenium自动登录-----------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 将driver获取的字典类型的cookie提取name和value封装成字符串&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 临时存放每个拼接好的key=value字符串&lt;/span&gt;&lt;br/&gt;        temp = []&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 遍历driver给的cookies字典&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; driver.get_cookies():&lt;br/&gt;            temp.append(i[&lt;span&gt;&#x27;name&#x27;&lt;/span&gt;] + &lt;span&gt;&quot;=&quot;&lt;/span&gt; + i[&lt;span&gt;&#x27;value&#x27;&lt;/span&gt;])&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 返回字符串cookie&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;;&#x27;&lt;/span&gt;.join(temp)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;start_requests&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 定义请求头的时候调用一下getCookie获取一下cookie&lt;/span&gt;&lt;br/&gt;        headers = {&lt;br/&gt;            &lt;span&gt;&#x27;Cookie&#x27;&lt;/span&gt;: self.getCookie(),&lt;br/&gt;            &lt;span&gt;&#x27;User-Agent&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36&#x27;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;# 注意url是个列表这里拿下标[0],然后把headers请求头塞进去,交给parse函数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;yield&lt;/span&gt; scrapy.Request(url=self.start_urls[&lt;span&gt;0&lt;/span&gt;], headers=headers, callback=self.parse)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;parse&lt;/span&gt;&lt;span&gt;(self, response)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 匹配歌曲名的正则表达式&lt;/span&gt;&lt;br/&gt;        patt = re.compile(&lt;span&gt;r&#x27;&amp;lt;a href=&quot;/song.id=.*?&quot;&amp;gt;([^&amp;lt;|{]*?)&amp;lt;/a&amp;gt;&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 找到所有歌曲名&lt;/span&gt;&lt;br/&gt;        listdata = re.findall(patt, response.text)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 把数据写进txt文件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;with&lt;/span&gt; open(file=&lt;span&gt;&quot;response.txt&quot;&lt;/span&gt;, mode=&lt;span&gt;&quot;w+&quot;&lt;/span&gt;, encoding=&lt;span&gt;&quot;utf-8&quot;&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; file:&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; listdata:&lt;br/&gt;                file.write(item+&lt;span&gt;&quot;\n&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247492605&amp;amp;idx=1&amp;amp;sn=d4a9e41c255057e2a2e64a813f5c1ef2&amp;amp;chksm=fa3f02a6cd488bb03b519f3a16430c0ccf3725d875ba3b01225b898911882d3d5caf57119fa4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;假如程序员进军 UI 界？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247492582&amp;amp;idx=1&amp;amp;sn=7994d770fcca4e47e379db37c4c13054&amp;amp;chksm=fa3f02bdcd488bab5acddee3cb1c35e1e7e597bd65fa3c3508ce8045c6fb13615b8ffe2ec34b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2021 年软件开发趋势大预测！&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247492576&amp;amp;idx=1&amp;amp;sn=e481178446fb6b3ee0eec9d7b400277b&amp;amp;chksm=fa3f02bbcd488badceacdd16cb64c930d39f2fcf603004a0379cfacdf1098bb38e5f37b2f85a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;谷歌发布新编程语言，居然专治这个？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247492456&amp;amp;idx=1&amp;amp;sn=03b089ffe7a7986cdc6ea50bfffb11ed&amp;amp;chksm=fa3f0233cd488b250a43e7a574d1e88a0bc89fb5e3bd912c043b07ce0cd388d4bc189390df21&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;重磅：微信内置输入法来了！&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247492542&amp;amp;idx=1&amp;amp;sn=49b99b871ac5386db6b526408e92a54e&amp;amp;chksm=fa3f02e5cd488bf3211f2e0048d517cc9a104970787a2269a1d9c57b58186b533ae5c1cfea28&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;这个程序员火了，竟是因为给老板修了一 次U盘...&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.3619246861924685&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hs540iaTKoaILnb3kuPFMrsGenkU5D5P7HJTPPCzZ02JAG1SwoNypeEXhc9CmUJBNAPl1RsRGxTRtKg0wRBtWwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;956&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;添加微信codingSmart领取&lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hs540iaTKoaJzr8mCunJ8fiaLHTVy5ic53H2dSVXKlA7iaibMyl7qJNTePsPptc1CdmciaD2PmhG5J98xjRicQ3Ob0diaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span data-darkmode-bgcolor-15865441435016=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15865441435016=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15865441435016=&quot;rgb(255, 21, 21)&quot; data-darkmode-original-color-15865441435016=&quot;rgb(255, 0, 0)&quot; data-style=&quot;max-width: 100%; color: rgb(255, 0, 0); font-family: Optima-Regular, PingFangTC-light; font-weight: 700; letter-spacing: 0.544px; widows: 1; word-spacing: 2px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__37&quot; data-darkmode-bgcolor-15866879525102=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15866879525102=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15866879525102=&quot;rgb(255, 21, 21)&quot; data-darkmode-original-color-15866879525102=&quot;rgb(255, 0, 0)&quot; data-darkmode-bgcolor-158705654000210=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-158705654000210=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-158705654000210=&quot;rgb(255, 21, 21)&quot; data-darkmode-original-color-158705654000210=&quot;rgb(255, 0, 0)&quot; data-darkmode-bgcolor-15870565400370=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15870565400370=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15870565400370=&quot;rgb(255, 21, 21)&quot; data-darkmode-original-color-15870565400370=&quot;rgb(255, 0, 0)&quot;&gt;支持下 &lt;/span&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1.764&quot; data-type=&quot;gif&quot; data-w=&quot;250&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ibsfLhQMgy09JhlUaCQZm4kXHBSlPxPOOpOcfiaNmJRjoem28z1x3CbXNG2eQNK8Tic1Yyf1WqKZ3VibvSicNtwcguQ/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ceb98fa23101caa6f2dd801be4a047e9</guid>
<title>vscode-loader 解析之（node 环境） - 悠然宜想亭</title>
<link>https://toutiao.io/k/r3oixv0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Post-body&quot;&gt;
                    &lt;p&gt;前面，我们已经分析过浏览器环境的模块加载，接下来看 node 环境的模块加载。&lt;/p&gt;

&lt;h2&gt;示例&lt;/h2&gt;

&lt;p&gt;vscode-loader 在 node 环境下加载模块，和浏览器环境基本一致。不同点是，不是通过 script 标签加载 loader.js，而是通过 require 加载。&lt;/p&gt;

&lt;p&gt;具体示例如下：&lt;/p&gt;

&lt;p&gt;加载 loader.js，再调用 loader 模块的方法，加载 test 依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;loader = require(&quot;./src/loader&quot;);
// 设置缓存
loader.config({
  nodeCachedData: {
    path: &quot;./cache-data&quot;,
  },
});
loader([&quot;test&quot;], function (test) {
  console.log(test.compare(7, 5));
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义模块：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// test.js

define(&quot;test&quot;, function () {
  return {
    compare: function (a, b) {
      return a &amp;gt; b;
    },
  };
});&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;loader 加载模块&lt;/h2&gt;

&lt;p&gt;上一篇文章中，我们提到，浏览器环境通过 require 函数加载模块。而 node 环境，是通过 loader.js 的模块导出值，加载其他模块。&lt;/p&gt;

&lt;p&gt;查看入口文件中的逻辑，可以看出 loader 就是 require 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;// 初始化
export function init(): void {
...

if (env.isNode &amp;amp;&amp;amp; !env.isElectronRenderer) {
// 设置 module.expots
module.exports = RequireFunc;
require = &amp;lt;any&amp;gt;RequireFunc;
} else {
...
}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，node 环境加载模块的逻辑，和浏览器基本是一致的。不同点在于，之前提到的，不同环境下的 &lt;code&gt;scriptLoader&lt;/code&gt; (脚本加载器)。&lt;/p&gt;

&lt;h2&gt;NodeScriptLoader&lt;/h2&gt;

&lt;p&gt;下面，我们具体来看 node 的脚本加载器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;class OnlyOnceScriptLoader implements IScriptLoader {

...

public load(moduleManager: IModuleManager, scriptSrc: string, callback: () =&amp;gt; void, errorback: (err: any) =&amp;gt; void): void {
if (!this._scriptLoader) {
if (this._env.isWebWorker) {
this._scriptLoader = new WorkerScriptLoader();
} else if (this._env.isElectronRenderer) {
// electron 渲染进程，preferScriptTags 指定是否用 &amp;lt;script&amp;gt; 标签加载，默认为 false
const { preferScriptTags } = moduleManager.getConfig().getOptionsLiteral();
if (preferScriptTags) {
this._scriptLoader = new BrowserScriptLoader();
} else {
this._scriptLoader = new NodeScriptLoader(this._env);
}
} else if (this._env.isNode) {
// node 环境，新建 node 的脚本加载器
this._scriptLoader = new NodeScriptLoader(this._env);
} else {
this._scriptLoader = new BrowserScriptLoader();
}
}
...
}
}

class NodeScriptLoader implements IScriptLoader {

private static _BOM = 0xFEFF;
private static _PREFIX = &#x27;(function (require, define, __filename, __dirname) { &#x27;;
private static _SUFFIX = &#x27;\n});&#x27;;

...

public load(moduleManager: IModuleManager, scriptSrc: string, callback: () =&amp;gt; void, errorback: (err: any) =&amp;gt; void): void {
// load-1: 获取配置
const opts = moduleManager.getConfig().getOptionsLiteral();
const nodeRequire = ensureRecordedNodeRequire(moduleManager.getRecorder(), (opts.nodeRequire || global.nodeRequire)); // nodeRequire 增加事件记录
const nodeInstrumenter = (opts.nodeInstrumenter || function (c) { return c; });// 如果设置了 nodeInstrumenter，在脚本加载之前，会先对脚本执行该转换函数
// load-2: 初始化
this._init(nodeRequire);
this._initNodeRequire(nodeRequire, moduleManager);
let recorder = moduleManager.getRecorder();

// load-3: 加载模块
if (/^node\|/.test(scriptSrc)) {
// &#x27;node|&#x27; 开头的，用 nodeRequire 加载（同步加载），直接调用 callback

let pieces = scriptSrc.split(&#x27;|&#x27;);

let moduleExports = null;
try {
moduleExports = nodeRequire(pieces[1]);
} catch (err) {
errorback(err);
return;
}

moduleManager.enqueueDefineAnonymousModule([], () =&amp;gt; moduleExports);
callback();

} else {

// load-3-1: 路径处理
scriptSrc = Utilities.fileUriToFilePath(this._env.isWindows, scriptSrc);
const normalizedScriptSrc = this._path.normalize(scriptSrc);
const vmScriptPathOrUri = this._getElectronRendererScriptPathOrUri(normalizedScriptSrc);
const wantsCachedData = Boolean(opts.nodeCachedData);
const cachedDataPath = wantsCachedData ? this._getCachedDataPath(opts.nodeCachedData!, scriptSrc) : undefined;

// load-3-2: 获取模块代码和缓存，执行代码
this._readSourceAndCachedData(normalizedScriptSrc, cachedDataPath, recorder, (err: any, data: string, cachedData: Buffer, hashData: Buffer) =&amp;gt; {
if (err) {
errorback(err);
return;
}

// 处理模块代码
let scriptSource: string;
if (data.charCodeAt(0) === NodeScriptLoader._BOM) {
scriptSource = NodeScriptLoader._PREFIX + data.substring(1) + NodeScriptLoader._SUFFIX;
} else {
scriptSource = NodeScriptLoader._PREFIX + data + NodeScriptLoader._SUFFIX;
}

scriptSource = nodeInstrumenter(scriptSource, normalizedScriptSrc);

// 生成并执行脚本
const scriptOpts: INodeVMScriptOptions = { filename: vmScriptPathOrUri, cachedData };
const script = this._createAndEvalScript(moduleManager, scriptSource, scriptOpts, callback, errorback);

// 处理、验证缓存
this._handleCachedData(script, scriptSource, cachedDataPath!, wantsCachedData &amp;amp;&amp;amp; !cachedData, moduleManager);
this._verifyCachedData(script, scriptSource, cachedDataPath!, hashData, moduleManager);
});
}
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;初始化&lt;/h3&gt;

&lt;p&gt;这里，我们先看 load-2 初始化的处理：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;class NodeScriptLoader implements IScriptLoader {
private _init(nodeRequire: (nodeModule: string) =&amp;gt; any): void {
if (this._didInitialize) {
return;
}
this._didInitialize = true;

// 获取 node 原生模块
this._fs = nodeRequire(&#x27;fs&#x27;);
this._vm = nodeRequire(&#x27;vm&#x27;);
this._path = nodeRequire(&#x27;path&#x27;);
this._crypto = nodeRequire(&#x27;crypto&#x27;);
}

// 修补 nodejs 的 require 函数，以便我们可以从缓存数据手动创建脚本。这是通过覆盖 `Module._compile` 函数来完成的。
private _initNodeRequire(nodeRequire: (nodeModule: string) =&amp;gt; any, moduleManager: IModuleManager): void {
// require-1: 如果已经打过补丁，直接返回
const { nodeCachedData } = moduleManager.getConfig().getOptionsLiteral();
if (!nodeCachedData) {
return;
}
if (this._didPatchNodeRequire) {
return;
}
this._didPatchNodeRequire = true;

// require-2: 修改 Module.compile
const that = this
const Module = nodeRequire(&#x27;module&#x27;);

function makeRequireFunction(mod: any) {
...
}

Module.prototype._compile = function (content: string, filename: string) {
...
}
}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，_initNodeRequire 修改了 node 的 &lt;code&gt;require&lt;/code&gt; 函数，主要是改写了 &lt;code&gt;Module.prototype._compile&lt;/code&gt;。&lt;/p&gt;

&lt;h4&gt;node 的 _compile&lt;/h4&gt;

&lt;p&gt;我们先了解一下 node 的 &lt;code&gt;require&lt;/code&gt; 函数，及 &lt;code&gt;Module.prototype._compile&lt;/code&gt;，以便后续对比。这里的 node 代码为 &lt;a href=&quot;https://github.com/nodejs/node/blob/v14.0.0/lib/internal/modules/cjs/loader.js&quot; rel=&quot; nofollow ugc&quot;&gt;14.0.0 版本&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;先看 &lt;code&gt;require&lt;/code&gt; 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// require: 根据路径加载模块，返回模块的 exports 属性。
Module.prototype.require = function(id) {
...
// 第一步：调用 Module._load
return Module._load(id, this, /* isMain */ false);
};

// Module._load：加载模块、管理缓存
Module._load = function(request, parent, isMain) {
...

// 1. 如果缓存中已存在模块，返回模块的 exports
const cachedModule = Module._cache[filename];
    if (cachedModule !== undefined) {
        updateChildren(parent, cachedModule, true);
        if (!cachedModule.loaded)
            return getExportsForCircularRequire(cachedModule);
        return cachedModule.exports;
    }

...

// 2. 如果是原生模块，调用 `NativeModule.prototype.compileForPublicLoader()` 并返回 exports
    const mod = loadNativeModule(filename, request);
    if (mod &amp;amp;&amp;amp; mod.canBeRequiredByUsers) return mod.exports;

...

// 3. 否则，新建一个模块并保存到缓存，加载文件，返回 exports
const module = new Module(filename, parent);
...
Module._cache[filename] = module;
try {
...
// 第二步：调用 Module.prototype.load
        module.load(filename);
        ...
    } finally {
        ...
    }

    return module.exports;
}

// Module.prototype.load: 根据文件名，调用合适的扩展处理器。
Module.prototype.load = function (filename) {
    ...

// 第三步：调用对应的处理器，比如 Module._extensions[&#x27;.js&#x27;]
    Module._extensions[extension](this, filename);
    this.loaded = true;

    ...
};

Module._extensions[&#x27;.js&#x27;] = function (module, filename) {
    ...
    content = fs.readFileSync(filename, &#x27;utf8&#x27;);
// 第四步：调用 Module.prototype._compile
    module._compile(content, filename);
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面代码，可以看出 node 的 &lt;code&gt;require&lt;/code&gt; 函数，执行过程是 &lt;code&gt;require&lt;/code&gt; -&amp;gt; &lt;code&gt;Module._load&lt;/code&gt; -&amp;gt; &lt;code&gt;Module.prototype.load&lt;/code&gt; -&amp;gt; &lt;code&gt;Module._extensions[&#x27;.js&#x27;]&lt;/code&gt; -&amp;gt; &lt;code&gt;Module.prototype._compile&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;继续看 node 的 &lt;code&gt;Module.prototype._compile&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// node

// Module.prototype._compile: 在指定的上下文中，编译、运行文件内容。
Module.prototype._compile = function (content, filename) {
    ...

// node-compile-1：compiledWrapper: 将文件内容进行封装
    const compiledWrapper = wrapSafe(filename, content, this);

    ...
// node-compile-2：生成 require, exports 等参数
    const dirname = path.dirname(filename);
    const require = makeRequireFunction(this, redirects);
    let result;
    const exports = this.exports;
    const thisValue = exports;
    const module = this;
    ...
    if (inspectorWrapper) {
// 断点调试，一般不走这个逻辑
        result = inspectorWrapper(compiledWrapper, thisValue, exports,
            require, module, filename, dirname);
    } else {
// node-compile-3：调用 compiledWrapper
        result = compiledWrapper.call(thisValue, exports, require, module,
            filename, dirname);
    }
    ...
    return result;
};

// 封装文件内容
function wrapSafe(filename, content, cjsModuleInstance) {
    if (patched) {
// node-compile-1-1：Module.wrap，封装文件内容，返回 (function (exports, require, module, __filename, __dirname) { ${content} \n})
        const wrapper = Module.wrap(content);
// node-compile-1-2：vm.runInThisContext，调用虚拟机接口，编译代码，并在当前上下文执行代码
        return vm.runInThisContext(wrapper, {
            filename,
            lineOffset: 0,
            displayErrors: true,
            importModuleDynamically: async (specifier) =&amp;gt; {
                const loader = asyncESM.ESMLoader;
                return loader.import(specifier, normalizeReferrerURL(filename));
            },
        });
    }
    ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;node 的 &lt;code&gt;Module.prototype._compile&lt;/code&gt;，将文件内容进行封装（compiledWrapper），然后生成 require 等参数，再调用封装的函数（compiledWrapper）。&lt;/p&gt;

&lt;p&gt;node-compile-1-2 使用了 node 的 &lt;a href=&quot;https://nodejs.org/api/vm.html&quot; rel=&quot; nofollow ugc&quot;&gt;vm&lt;/a&gt; 模块，该模块支持编译代码、运行代码等功能。&lt;/p&gt;

&lt;h4&gt;vscode-loader 的 _compile&lt;/h4&gt;

&lt;p&gt;vscode-loader 的 &lt;code&gt;Module.prototype._compile&lt;/code&gt;，逻辑如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;class NodeScriptLoader implements IScriptLoader {
private _initNodeRequire(nodeRequire: (nodeModule: string) =&amp;gt; any, moduleManager: IModuleManager): void {

...

Module.prototype._compile = function (content: string, filename: string) {
// compile-1: 替换 shebang，包装源码
const scriptSource = Module.wrap(content.replace(/^#!.*/, &#x27;&#x27;));

// compile-2: 获取缓存数据，并记录事件
const recorder = moduleManager.getRecorder();
// 对于示例而言，缓存路径为 cache-data/test-${hash}.code
const cachedDataPath = that._getCachedDataPath(nodeCachedData, filename);
const options: INodeVMScriptOptions = { filename };
let hashData: Buffer | undefined;
try {
// 读取缓存数据
const data = that._fs.readFileSync(cachedDataPath);
hashData = data.slice(0, 16);
// 设置到 options.cachedData
options.cachedData = data.slice(16);
recorder.record(LoaderEventType.CachedDataFound, cachedDataPath);
} catch (_e) {
recorder.record(LoaderEventType.CachedDataMissed, cachedDataPath);
}
// compile-3: 新建 vm.Script，编译代码
const script = new that._vm.Script(scriptSource, options);
// compile-4: 生成 compileWrapper，用于在当前上下文运行代码
const compileWrapper = script.runInThisContext(options);

// compile-5: 生成 require 等参数
const dirname = that._path.dirname(filename);
const require = makeRequireFunction(this);
const args = [this.exports, require, this, filename, dirname, process, _commonjsGlobal, Buffer];
// compile-6: 执行 compileWrapper，传入参数
const result = compileWrapper.apply(this.exports, args);

// compile-7: 缓存数据
that._handleCachedData(script, scriptSource, cachedDataPath, !options.cachedData, moduleManager);
that._verifyCachedData(script, scriptSource, cachedDataPath!, hashData, moduleManager);

return result;
}
}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和 node 的相似之处：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;code&gt;compile-1&lt;/code&gt;，等同于 &lt;code&gt;node-compile-1-1&lt;/code&gt;，通过 &lt;code&gt;Module.wrap&lt;/code&gt; 封装文件内容。这样可以保证代码在独立上下文中运行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compile-3&lt;/code&gt;、&lt;code&gt;compile-4&lt;/code&gt;，等同于 &lt;code&gt;node-compile-1-2&lt;/code&gt;，调用虚拟机接口 &lt;code&gt;runInThisContext&lt;/code&gt;，用于在当前上下文执行代码。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compile-5&lt;/code&gt;，等同于 &lt;code&gt;node-compile-2&lt;/code&gt;，生成 require 等参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compile-6&lt;/code&gt;，等同于 &lt;code&gt;node-compile-3&lt;/code&gt;，执行封装后的代码。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;和 node 的不同之处：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;code&gt;compile-2&lt;/code&gt;，增加了获取缓存，并记录缓存事件的逻辑。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compile-3&lt;/code&gt;，编译代码时，options 中传入了缓存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compile-5&lt;/code&gt;，改写了 &lt;code&gt;makeRequireFunction&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compile-7&lt;/code&gt;，执行代码后，缓存了数据。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;可以看出，vscode-loader 的 &lt;code&gt;Module.prototype._compile&lt;/code&gt;，主要是&lt;strong&gt;增加了缓存的逻辑&lt;/strong&gt;，改写了 &lt;code&gt;makeRequireFunction&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;makeRequireFunction&lt;/code&gt; 的对比如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;// node
function makeRequireFunction(mod, redirects) {
    const Module = mod.constructor;

    let require;
    if (redirects) {
// 处理重定向
        const { resolve, reaction } = redirects;
        const id = mod.filename || mod.id;
        require = function require(path) {
// node 协议，加载原生模块，返回 exports
// 文件协议，调用 mode.require，加载文件
...
            return mod.require(path);
        };
    } else {
// 非重定向，直接调用 mod.require
        require = function require(path) {
            return mod.require(path);
        };
    }

    function resolve(request, options) {
        validateString(request, &#x27;request&#x27;);
        return Module._resolveFilename(request, mod, false, options);
    }
    require.resolve = resolve;
    function paths(request) {
        validateString(request, &#x27;request&#x27;);
        return Module._resolveLookupPaths(request, mod);
    }
    resolve.paths = paths;
    require.main = process.mainModule;
    require.extensions = Module._extensions;
    require.cache = Module._cache;
    return require;
}

// vscode-loader
function makeRequireFunction(mod: any) {
const Module = mod.constructor;
// 直接调用 mod.require
let require = &amp;lt;any&amp;gt;function require(path) {
try {
return mod.require(path);
} finally {
// nothing
}
}
require.resolve = function resolve(request, options) {
return Module._resolveFilename(request, mod, false, options);
};
require.resolve.paths = function paths(request) {
return Module._resolveLookupPaths(request, mod);
};
require.main = process.mainModule;
require.extensions = Module._extensions;
require.cache = Module._cache;
return require;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，由于 vscode-loader 的 &lt;code&gt;Module.prototype._compile&lt;/code&gt; 没有重定向的情况，所以 &lt;code&gt;makeRequireFunction&lt;/code&gt; 中的 require，删除了重定向处理。而 require 的其他属性，和 node 保持一致，没有修改。&lt;/p&gt;

&lt;h4&gt;vscode-loader 的缓存处理&lt;/h4&gt;

&lt;p&gt;vscode-loader 通过 config 来设置缓存目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;// 设置缓存
loader.config({
  nodeCachedData: {
    path: &quot;./cache-data&quot;,
  },
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;compile-2&lt;/code&gt; 通过 &lt;code&gt;_getCachedDataPath&lt;/code&gt; 获取缓存路径：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;// compile-2
const cachedDataPath = that._getCachedDataPath(nodeCachedData, filename);

// 对于示例而言，缓存路径为 cache-data/test-${hash}.code
private _getCachedDataPath(config: INodeCachedDataConfiguration, filename: string): string {
// 根据文件名、配置等生成 hash 值
const hash = this._crypto.createHash(&#x27;md5&#x27;).update(filename, &#x27;utf8&#x27;).update(config.seed!, &#x27;utf8&#x27;).update(process.arch, &#x27;&#x27;).digest(&#x27;hex&#x27;);
const basename = this._path.basename(filename).replace(/\.js$/, &#x27;&#x27;);
return this._path.join(config.path, `${basename}-${hash}.code`);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;compile-2&lt;/code&gt; 读取缓存后，并通过 options 传入 vm.script，以使用缓存数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;// compile-2
try {
const cachedDataPath = that._getCachedDataPath(nodeCachedData, filename);
// 读取缓存数据
const data = that._fs.readFileSync(cachedDataPath);
hashData = data.slice(0, 16);
// 设置到 options.cachedData
options.cachedData = data.slice(16);
...
} catch (_e) {
...
}
// options 中包含 cachedData
const script = new that._vm.Script(scriptSource, options);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行源文件的代码后，&lt;code&gt;compile-7&lt;/code&gt; 更新和校验缓存数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;// compile-7
that._handleCachedData(script, scriptSource, cachedDataPath, !options.cachedData, moduleManager);
that._verifyCachedData(script, scriptSource, cachedDataPath!, hashData, moduleManager);

// 处理缓存数据：如果缓存失败，就删除原来的缓存，重新生成缓存；如果 options 没有缓存数据，就生成缓存数据
private _handleCachedData(script: INodeVMScript, scriptSource: string, cachedDataPath: string, createCachedData: boolean, moduleManager: IModuleManager): void {
if (script.cachedDataRejected) {
// cached data got rejected -&amp;gt; delete and re-create
this._fs.unlink(cachedDataPath, err =&amp;gt; {
moduleManager.getRecorder().record(LoaderEventType.CachedDataRejected, cachedDataPath);
this._createAndWriteCachedData(script, scriptSource, cachedDataPath, moduleManager);
if (err) {
moduleManager.getConfig().onError(err)
}
});
} else if (createCachedData) {
// no cached data, but wanted
this._createAndWriteCachedData(script, scriptSource, cachedDataPath, moduleManager);
}
}

// 校验缓存数据：如果 hash 值改变，就删除缓存文件
private _verifyCachedData(script: INodeVMScript, scriptSource: string, cachedDataPath: string, hashData: Buffer | undefined, moduleManager: IModuleManager): void {
if (!hashData) {
// nothing to do
return;
}
if (script.cachedDataRejected) {
// invalid anyways
return;
}
setTimeout(() =&amp;gt; {
// check source hash - the contract is that file paths change when file content
// change (e.g use the commit or version id as cache path). this check is
// for violations of this contract.
const hashDataNow = this._crypto.createHash(&#x27;md5&#x27;).update(scriptSource, &#x27;utf8&#x27;).digest();
if (!hashData.equals(hashDataNow)) {
moduleManager.getConfig().onError(&amp;lt;any&amp;gt;new Error(`FAILED TO VERIFY CACHED DATA, deleting stale &#x27;${cachedDataPath}&#x27; now, but a RESTART IS REQUIRED`));
this._fs.unlink(cachedDataPath!, err =&amp;gt; {
if (err) {
moduleManager.getConfig().onError(err);
}
});
}

}, Math.ceil(5000 * (1 + Math.random())));
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;加载模块&lt;/h3&gt;

&lt;p&gt;初始化之后，load-3 进行模块加载，主要分为路径处理、获取模块代码并执行。&lt;/p&gt;

&lt;h4&gt;路径处理&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;class NodeScriptLoader implements IScriptLoader {
public load(moduleManager: IModuleManager, scriptSrc: string, callback: () =&amp;gt; void, errorback: (err: any) =&amp;gt; void): void {
...
// load-3-1: 路径处理
// 对于示例而言，test.js -&amp;gt; test.js
scriptSrc = Utilities.fileUriToFilePath(this._env.isWindows, scriptSrc);
const normalizedScriptSrc = this._path.normalize(scriptSrc);
const vmScriptPathOrUri = this._getElectronRendererScriptPathOrUri(normalizedScriptSrc);
// 配置是否使用缓存，示例为 true
const wantsCachedData = Boolean(opts.nodeCachedData);
// 如果使用缓存，获取缓存路径，示例为 cache-data/test-${hash}.code
const cachedDataPath = wantsCachedData ? this._getCachedDataPath(opts.nodeCachedData!, scriptSrc) : undefined;
...
}
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;获取模块代码并执行&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;class NodeScriptLoader implements IScriptLoader {

private static _BOM = 0xFEFF;
private static _PREFIX = &#x27;(function (require, define, __filename, __dirname) { &#x27;;
private static _SUFFIX = &#x27;\n});&#x27;;

public load(moduleManager: IModuleManager, scriptSrc: string, callback: () =&amp;gt; void, errorback: (err: any) =&amp;gt; void): void {
...
// load-3-2: 获取模块代码和缓存，执行代码
// 第一步: 获取模块代码和缓存，其中获取缓存同 compile-2
this._readSourceAndCachedData(normalizedScriptSrc, cachedDataPath, recorder, (err: any, data: string, cachedData: Buffer, hashData: Buffer) =&amp;gt; {
if (err) {
errorback(err);
return;
}

// 第二步: 处理模块代码，同 compile-1
// 如果有 bom 则去除，再封装文件内容，即 &#x27;(function (require, define, __filename, __dirname)&#x27; + data + &#x27;{ \n});&#x27;;
let scriptSource: string;
if (data.charCodeAt(0) === NodeScriptLoader._BOM) {
scriptSource = NodeScriptLoader._PREFIX + data.substring(1) + NodeScriptLoader._SUFFIX;
} else {
scriptSource = NodeScriptLoader._PREFIX + data + NodeScriptLoader._SUFFIX;
}
// 如果配置了转换函数，则执行转换函数：const nodeInstrumenter = (opts.nodeInstrumenter || function (c) { return c; });
scriptSource = nodeInstrumenter(scriptSource, normalizedScriptSrc);

// 第三步: 生成并执行脚本，cacheData 对应从缓存路径读取的缓存数据，同 compile-3 ~ compile-6
const scriptOpts: INodeVMScriptOptions = { filename: vmScriptPathOrUri, cachedData };
const script = this._createAndEvalScript(moduleManager, scriptSource, scriptOpts, callback, errorback);

// step-4: 更新、验证缓存，同 compile-7
this._handleCachedData(script, scriptSource, cachedDataPath!, wantsCachedData &amp;amp;&amp;amp; !cachedData, moduleManager);
this._verifyCachedData(script, scriptSource, cachedDataPath!, hashData, moduleManager);
});

// 第一步. 读取模块和缓存文件
private _readSourceAndCachedData(sourcePath: string, cachedDataPath: string | undefined, recorder: ILoaderEventRecorder, callback: (err?: any, source?: string, cachedData?: Buffer, hashData?: Buffer) =&amp;gt; any): void {

if (!cachedDataPath) {
// 不使用缓存时，直接读取模块文件
this._fs.readFile(sourcePath, { encoding: &#x27;utf8&#x27; }, callback);

} else {
// 使用缓存时，同时读取模块文件和缓存文件
let source: string | undefined = undefined;
let cachedData: Buffer | undefined = undefined;
let hashData: Buffer | undefined = undefined;
let steps = 2;

const step = (err?: any) =&amp;gt; {
if (err) {
callback(err);

} else if (--steps === 0) {
// 两个文件都读取后，steps 变为 0，再执行 callback
callback(undefined, source, cachedData, hashData);
}
}

this._fs.readFile(sourcePath, { encoding: &#x27;utf8&#x27; }, (err: any, data: string) =&amp;gt; {
source = data;
step(err);
});

this._fs.readFile(cachedDataPath, (err: any, data: Buffer) =&amp;gt; {
if (!err &amp;amp;&amp;amp; data &amp;amp;&amp;amp; data.length &amp;gt; 0) {
hashData = data.slice(0, 16);
cachedData = data.slice(16);
recorder.record(LoaderEventType.CachedDataFound, cachedDataPath);

} else {
recorder.record(LoaderEventType.CachedDataMissed, cachedDataPath);
}
step(); // ignored: cached data is optional
});
}
}

// 第三步. 生成并执行脚本
private _createAndEvalScript(moduleManager: IModuleManager, contents: string, options: INodeVMScriptOptions, callback: () =&amp;gt; void, errorback: (err: any) =&amp;gt; void): INodeVMScript {
const recorder = moduleManager.getRecorder();
recorder.record(LoaderEventType.NodeBeginEvaluatingScript, options.filename);

// 同 compile-3: 新建 vm.Script，编译代码
const script = new this._vm.Script(contents, options);
// 同 compile-4: 生成 ret，用于在当前上下文运行代码
const ret = script.runInThisContext(options);

// 获取 define 函数，对应 main.ts 中的 DefineFunc
const globalDefineFunc = moduleManager.getGlobalAMDDefineFunc();
let receivedDefineCall = false;
const localDefineFunc: IDefineFunc = &amp;lt;any&amp;gt;function () {
receivedDefineCall = true;
return globalDefineFunc.apply(null, arguments);
};
localDefineFunc.amd = globalDefineFunc.amd;

// 同 compile-6: 执行 ret
ret.call(global, moduleManager.getGlobalAMDRequireFunc(), localDefineFunc, options.filename, this._path.dirname(options.filename));

recorder.record(LoaderEventType.NodeEndEvaluatingScript, options.filename);

if (receivedDefineCall) {
callback();
} else {
errorback(new Error(`Didn&#x27;t receive define call in ${options.filename}!`));
}

return script;
}
}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，load-3 加载模块，和 &lt;code&gt;Module.prototype._compile&lt;/code&gt; 的处理逻辑基本一致，都是调用 &lt;code&gt;vm.script&lt;/code&gt;，&lt;code&gt;runInThisContext&lt;/code&gt; 编译代码、执行代码。对缓存的处理也基本一致，都是读取缓存文件内容 &lt;code&gt;cachedData&lt;/code&gt;，在 &lt;code&gt;new vm.script&lt;/code&gt; 时传入缓存；执行代码后，通过 &lt;code&gt;_handleCachedData&lt;/code&gt;、&lt;code&gt;_verifyCachedData&lt;/code&gt; 更新、验证缓存。&lt;/p&gt;

&lt;h2&gt;define 定义模块&lt;/h2&gt;

&lt;p&gt;node 环境和浏览器环境，define 定义模块的逻辑是一致的，本文不再赘述。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;本文主要介绍了 vscode-loader 在 node 环境和浏览器环境的区别，即 &lt;code&gt;scriptLoader&lt;/code&gt; 加载模块的方式不同：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;浏览器环境，生成 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签，并设置 async，异步加载模块。&lt;/li&gt;
&lt;li&gt;node 环境，读取文件内容，再调用 &lt;code&gt;vm&lt;/code&gt; 接口（&lt;code&gt;vm.script&lt;/code&gt;，&lt;code&gt;runInThisContext&lt;/code&gt;）编译代码、执行代码，且支持缓存数据。&lt;/li&gt;&lt;/ul&gt;


&lt;h2&gt;猜您可能感兴趣的文章&lt;/h2&gt;



                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>