<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>202282639fee5d94807155c0e9bf6836</guid>
<title>一个后端朋友面试一个月的经验总结</title>
<link>https://toutiao.io/k/ldwacnk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-source-line=&quot;1&quot;&gt;关于面经，小辉之前的文章可以查看《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNzgyNzAwNg==&amp;amp;mid=2247484103&amp;amp;idx=1&amp;amp;sn=3a9f1f3a19a297d60282fa8314ae661c&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;建议找工作的你看一下，无论是校招还是社招&lt;/a&gt;》&lt;/p&gt;&lt;p data-source-line=&quot;3&quot;&gt;本次分享一个后端朋友最近面试的经验总结，希望能对你有启发。&lt;/p&gt;&lt;h3 data-source-line=&quot;5&quot;&gt;面试概况&lt;/h3&gt;&lt;p data-source-line=&quot;7&quot;&gt;朋友坐标北京，裸辞在家找工作。线上面试一共58场，投递公司包含a轮-c轮、上市公司或者知名互联网公司，除了中途放弃面试或者谈薪阶段放弃之外，基本做到面试一路绿灯，最后拿到了包括阿里、字节等offer。&lt;/p&gt;&lt;h3 data-source-line=&quot;9&quot;&gt;面试过程&lt;/h3&gt;&lt;p data-source-line=&quot;11&quot;&gt;朋友赋闲在家，7月1日打开某招聘app，上传简历后开始投递简历，然后每天进行3-6场的面试，两周后面试大多结束开始进入谈薪阶段，第三周收尾一些面试和谈薪，第四周入职新公司。&lt;/p&gt;&lt;blockquote data-source-line=&quot;13&quot;&gt;&lt;p&gt;如果只面几家目标厂的话，一般一周内拿offer时间上可以实现的。有些厂可以做到一天之内面完并谈offer，效率是很高的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-source-line=&quot;15&quot;&gt;面试感悟&lt;/h2&gt;&lt;h3 data-source-line=&quot;17&quot;&gt;1. 面试邀约速度&lt;/h3&gt;&lt;p data-source-line=&quot;19&quot;&gt;如果是部门直推的话，面试邀请会非常快，最快当天就有邀约，因为业务方看到简历比较满意后会很快让HR联系候选人；如果简历是通过官网或者内推人扔到人才库的话，可能需要3,4天的时间被捞起。&lt;/p&gt;&lt;p data-source-line=&quot;21&quot;&gt;总体来说，还是业务直推比较快——无论是业务部门还是HR，其他方式就要慢一些。&lt;/p&gt;&lt;h3 data-source-line=&quot;23&quot;&gt;2. 面试结果的反馈速度可以很快&lt;/h3&gt;&lt;p data-source-line=&quot;25&quot;&gt;网上不少讨论说面试结果等了很久也没有约下一面，以我朋友的经验来看，每一场面试最快就是面试结尾的时候预约下一次的面试时间或者直接告知面试通过，面试后通知的大多不会超过2个小时，有些大厂是第二天才通知的。没有遇到过三五天都没有消息的情况。&lt;/p&gt;&lt;p data-source-line=&quot;27&quot;&gt;以小辉当时参与招聘的流程来看，面试流程确实是可以很快的，如果面试流程慢的话，建议多看看其他机会，流程慢说明你的面试结果正在compare其他人的结果，而最终是否被录取有的时候并不是因为你是否绝对优秀，会有多个维度考虑，所以为了分担找工作的风险，不要把希望都放到一个篮子里。&lt;/p&gt;&lt;p data-source-line=&quot;29&quot;&gt;此外，面试官的评语也不用太在意，朋友就遇到某二线厂和某一线厂有比较矛盾的评价——面试很看运气，例如和面试官的气场是否合得来。有时候大厂反而比小厂更容易面上，一是大厂HC更充足，部门之间独立招聘；二是小厂HC比较少，所以招人比较谨慎，有的时候角度更加刁钻。&lt;/p&gt;&lt;blockquote data-source-line=&quot;31&quot;&gt;&lt;p&gt;有些面试官并不是想考察候选人会什么，而是想考察候选人不会什么。那这样的面试就会让候选人很难受。虽然这样可以省去理解候选人表述的精力，但这样很难招到有实力的人。所以面挂的同学也不必泄气，多面几次总有机会。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-source-line=&quot;33&quot;&gt;3. 可以找猎头&lt;/h3&gt;&lt;p data-source-line=&quot;35&quot;&gt;对于信息渠道比较少的同学，选择猎头帮忙找工作也是还不错的方式，不过猎头也有不靠谱的，例如未经同意投简历导致候选人无法面目标部门的。更多时候猎头只是发个JD、推个简历、完成自己的KPI然后除了JD之外的信息都无法提供。但相对靠谱的猎头，会提供岗位面试情况、部门信息、公司信息等等，另外交个朋友时刻了解下行业信息也是不错的。猎头靠谱与否差别很大，想找靠谱猎头或者社招内推都可以找小辉。&lt;/p&gt;&lt;h3 data-source-line=&quot;37&quot;&gt;4. 合理把握面试节奏&lt;/h3&gt;&lt;p data-source-line=&quot;39&quot;&gt;无论一天中还是整个找工作的时间跨度的面试，都需要合理安排面试顺序和节奏。&lt;/p&gt;&lt;p data-source-line=&quot;41&quot;&gt;从一天的角度来说，一天面试太多场容易让人产生疲惫感，尤其是临近晚饭或者晚饭之后；从整个找工作时间跨度来说，过早投递了目标厂并且拿到offer，很容易就产生懈怠心理，不想准备后边的面试，也容易被目标厂催促入职，动摇继续面试的动力。&lt;/p&gt;&lt;h3 data-source-line=&quot;43&quot;&gt;5. 面试要保持良好的身体状态&lt;/h3&gt;&lt;p data-source-line=&quot;45&quot;&gt;对于重要的面试一定要提前问好是面试几轮、多长时间，这样对时间可以更好的把控。&lt;/p&gt;&lt;p data-source-line=&quot;47&quot;&gt;例如朋友面某厂的时候，约得下午三点，以为只有一面，面完了吃个饭，结果竟然是连续两面（一面结束后通知还有二面）。朋友在二面的时候饿得不行，手写topk堆排序的时候直接大脑短路，当时以为面试会挂掉，所以只想放弃这道算法题赶紧结束面试。&lt;/p&gt;&lt;blockquote data-source-line=&quot;49&quot;&gt;&lt;p&gt;人饿肚子的时候更愿意放弃，所以要保持良好的身体状态。当然充足的睡眠也很重要。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-source-line=&quot;51&quot;&gt;6. 面试要保持良好的精神状态&lt;/h3&gt;&lt;p data-source-line=&quot;53&quot;&gt;这里主要是希望大家面试的时候不要紧张，不要觉得面试是单方面被面试官考察，实际上面试官也只是想找个能帮他分担工作的战友。面试是双向选择的过程，你被考察的时候，你也要考察对方是不是适合跟你工作，这个部门或者业务是否适合你。紧张的根源在于对不确定性或者未知的担忧，大体可以通过下面三个方向来理性控制紧张情绪。&lt;/p&gt;&lt;ol data-source-line=&quot;55&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;调整期待&lt;br/&gt;减少对面试结果的期待，把面试当成一次技术交流或者技术分享会，看淡结果更注重过程，这样能一定程度上缓解紧张。有的时候面试没拿到offer并不是你能力是否匹配或者面评是否好，有的时候是受岗位、部门和大环境多方面影响。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提高能力&lt;br/&gt;自身能力就像武侠小说中的内功一样，当内功足够深厚的人，招式有的时候显得不那么重要。所以不负时光尽量提高自己，才能有更多的自信，面试的时候也更不容易紧张。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;充分准备&lt;br/&gt;能力是无法短时间提高的，如果已经到了要面试的时间窗口，做些面试的准备（可以理解为招式，例如一个流利的自我介绍或者逻辑严谨的项目介绍），也是很有必要的。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-source-line=&quot;62&quot;&gt;&lt;p&gt;面试官有的时候也会紧张，所以为了更有利沟通效果，保持谦虚谨慎的态度，回答问题前先思考并有条理地表达出来，将面试官当成日常工作沟通的同事，只有这样才能尽量克制自己的紧张情绪，让交谈氛围更加轻松，也能给面试官留下个比较好的印象。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-source-line=&quot;64&quot;&gt;7. 刷题有必要&lt;/h3&gt;&lt;p data-source-line=&quot;66&quot;&gt;朋友面试的整体感觉，刷题还是很有必要的。大部分公司都会问算法题，尤其是大厂，如果没有ac或者完全没写出来，对于面评结果肯定是有影响的。&lt;/p&gt;&lt;p data-source-line=&quot;68&quot;&gt;一般面试算法难度不会超过leetcode medium水平，我朋友的手写算法能力并不好，几十场面试下来有80%的题目都没有ac，但是并不耽误面试通过，所以也请候选人放宽心。&lt;/p&gt;&lt;p data-source-line=&quot;70&quot;&gt;另外堆排序、全排列、快排这种题都属于面试官对前面过程比较认可，然后放水问的算法题目，所以这种常见的题还是要准备一下，不然遇到面试官放水，结果算法环节掉链子。&lt;/p&gt;&lt;blockquote data-source-line=&quot;72&quot;&gt;&lt;p&gt;对于工作经验较长（例如5年以上）、偏技术管理的人，手写算法环节可能会弱化对编码能力、边界条件考察的要求，但还是可能会有算法题，但更偏向于代码思路和风格的查考。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-source-line=&quot;74&quot;&gt;8. 回答技术问题，不要无脑背诵&lt;/h3&gt;&lt;p data-source-line=&quot;76&quot;&gt;例如面试官问Spring Bean的生命周期，小辉曾见过候选人将整个过程倒背如流，但实际上这对于面试官的感觉就是恰巧这道题你背过，那换个思路问问，例如问问aop发生在哪个阶段？解决循环依赖在哪个阶段？如果恰巧你也背下了，那你赢了，你大脑内存足够；但如果你背不下来，那前面的就白背了，面试官觉得你是背的八股文，可能并没有看过源码。&lt;/p&gt;&lt;p data-source-line=&quot;78&quot;&gt;小辉还是建议技术基础知识要尽量关联项目来讲，即使没有在项目中直接使用到，这个知识的原理、设计方法或者理念也是可以借鉴的，也可以在讲完八股文的时候扩展讲一下。&lt;/p&gt;&lt;blockquote data-source-line=&quot;80&quot;&gt;&lt;p&gt;能说出技术的应用场景并能灵活应用可是面试加分项。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-source-line=&quot;82&quot;&gt;9. 遇到不会的问题可以说自己的理解&lt;/h3&gt;&lt;p data-source-line=&quot;84&quot;&gt;遇到面试官提出的问题是自己没有接触过的方向，没必要怕耽误面试时间，立刻说不会。对于自己能想到实现方案的问题，完全可以说如果自己去实现这个地方会怎么做。&lt;/p&gt;&lt;p data-source-line=&quot;86&quot;&gt;如果想不到实现方案，可寻找自己的知识体系中，与之最相关的一类问题，在征得面试官同意之后，讲解给面试官，避免面试官仅以一个点的不足误认为你整块技能不够。&lt;/p&gt;&lt;p data-source-line=&quot;88&quot;&gt;当时朋友遇到某大厂问Redis的跳表如何快速查询排名的，朋友并不知道所以直接说不会，但面试官很友善地说让我朋友说说如果自己去实现的话会怎么做。我朋友先问了是否还是基于跳表，当得到面试官肯定答案的时候，朋友的思考方向就不会跑偏，然后他猜对了答案。&lt;/p&gt;&lt;p data-source-line=&quot;90&quot;&gt;如果面试官提出的问题你完全不会或者一直在一个你不懂的领域周旋，你可以坦诚相告自己在这方面的能力和经验，并询问实际工作中对这块的要求程度，说明你在这块领域的学习计划，尽量消除能力差距带来的影响（有的时候可能是面试官对你简历中某个描述的误解，以为是你擅长的方向，这样的坦诚相告可以消除这种误解）。&lt;/p&gt;&lt;p data-source-line=&quot;92&quot;&gt;此外有的面试官为了真正测试出你某项技能的极限，会一直问到你回答不上来为止。所以即使有些问题你没回答上来，并不表示你不合格，这只是正常的能力测试而已。&lt;/p&gt;&lt;blockquote data-source-line=&quot;94&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;当遇到不会的问题不用感觉挫败。小辉当时作为面试官问出题目，候选人完全不会，小辉倒觉得是自己的问题没有延伸好，然后会忽略这道问题再换个问题或者方向来考察候选人。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;原则上是候选人没有明显缺点的时候，面评会多写候选人的优点，同时在候选人有明显优点的时候不过度求全。这才是一份合格的面试评价。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;h3 data-source-line=&quot;97&quot;&gt;10. 回答问题不要觉得是常识就不说&lt;/h3&gt;&lt;p data-source-line=&quot;99&quot;&gt;能说还是一定要多说，不然你以为的是常识不说，面试官可能就来了个技术深度一般的评语。面试很多时候看运气，并不客观，所以无论过没过或者哪家评语好坏不要影响心情，继续面下去。&lt;/p&gt;&lt;blockquote data-source-line=&quot;101&quot;&gt;&lt;p&gt;当然一个合格的面试官在写下“技术深度一般”之前，是应该有针对的提出若干问题，当候选人回答确实不够好的话，才可以认定候选人“技术深度一般”。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-source-line=&quot;103&quot;&gt;11. 经典的问题&lt;/h3&gt;&lt;p data-source-line=&quot;105&quot;&gt;列举一些经典的问题，HR面或者Leader面都有可能被问到的问题。回答问题的时候最好结合具体事例说，而不是简单的主观陈述，这样更有说服力。&lt;/p&gt;&lt;ol data-source-line=&quot;107&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;最大的优点是什么&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最大的缺点是什么&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为什么选择我们公司&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;什么原因会让你离开我们公司&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;之前几家工作的离职原因&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;职业规划或者未来五年计划是什么&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在之前项目中的角色是什么样的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;你的leader/同事如何评价你&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;怎么看xx业务？（就是你面试的这家的业务）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对新的工作有什么期许&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;项目中遇到的最大的挑战，举个例子&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;你觉得所在团队或项目中有什么问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;有什么兴趣爱好&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-source-line=&quot;121&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;回答过程中，尽量与面试官保持良好地互动，表现出自己积极主动和善于合作的一面，展示心理成熟、负责任、有担当的一面，也尽可能展示有管理甚至有领导力的一面（即使你连虚线管理都不是，但你同样可以有感染带动其他人一起做事的可能）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;需要注意例如“项目中遇到的最大的挑战，举个例子”的问题，对于HR和技术面试官，你讲解的侧重点需要不同。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;h3 data-source-line=&quot;124&quot;&gt;12. 面试考察的方向&lt;/h3&gt;&lt;p data-source-line=&quot;126&quot;&gt;对于技术岗位面试，扎实的技术基础知识和丰富的项目经验肯定是要重点关注的，所以普遍认为一面挂掉的概率是最高的。但除此之外，如下方面也是需要在面试中展现出来的，是面试官考察或者加分的选项。&lt;/p&gt;&lt;ol data-source-line=&quot;128&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;是否对过往项目有整体的把控或了解，无论是技术架构还是业务目标（项目介绍中体现）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;技术方案设计的过程，是否对业界技术有了解，是否有横向比较、论证的过程或能力（项目介绍中体现）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;是否具备创新的能力解决现有的业务挑战（让候选人阐述一个经历过最有挑战的问题）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;逻辑思维是否严谨，能否清晰定义问题并拆解分析（让候选人阐述一个经历过最有挑战的问题）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;是否具备不错的沟通能力（面试整体体验）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;是否乐观积极、有自驱力和抗压能力（面试整体体验）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;是否有清晰地个人目标，这样更有利于快速成长（面试整体体验）&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-source-line=&quot;136&quot;&gt;13. 面试可以对知识体系有不小的提高&lt;/h3&gt;&lt;p data-source-line=&quot;138&quot;&gt;面试中会接触到很多的大佬，能从不同角度针对你过往经历提出问题，这过程中可以学习很多，而且你也可以将一些项目中的困惑提出来，大佬提出他的看法，这也是一种启发。&lt;/p&gt;&lt;h3 data-source-line=&quot;140&quot;&gt;14. 你需要个时间管理工具&lt;/h3&gt;&lt;p data-source-line=&quot;142&quot;&gt;朋友用的是xx清单App，这样每个面试预约都可以排好时间并设置好提醒，这个很重要。&lt;/p&gt;&lt;h3 data-source-line=&quot;144&quot;&gt;15. 选择你觉得有前途的赛道&lt;/h3&gt;&lt;p data-source-line=&quot;146&quot;&gt;大型互联网公司选择并不多，核心部门的坑位更是看运气，即使入职，面对也可能是一坨屎山代码和历史包袱。所以除了大公司，也可以关注比较有前途的中小型公司。例如朋友聊过某A轮公司，最后聊到了CEO；也聊过C轮公司，CTO指点工作规划。朋友聊过之后感觉这些公司的业务方向也都很有前景，尤其是在这两年，toc开始势弱，tob更受资本青睐的环境下，很多对公众不是很知名的企业，未来可期而且招聘需求很强烈。&lt;/p&gt;&lt;blockquote data-source-line=&quot;148&quot;&gt;&lt;p&gt;对于技术人员，技术经验是基础与根本，业务成果是我们的价值体现，而一个好的赛道更能激发不断前进的动力和放大我们的价值。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-source-line=&quot;150&quot;&gt;总结&lt;/h2&gt;&lt;p data-source-line=&quot;152&quot;&gt;本文结合朋友的面试经验与小辉之前的经验做一个分享，只是希望有实力的候选人不会因为面试表现的缺失与理想offer失之交臂，这对候选人和对企业都是一种遗憾。&lt;/p&gt;&lt;p data-source-line=&quot;154&quot;&gt;正如大佬说过：“面试只是起点，能力才是终局”。面试通过实力和运气寻找新挑战的起点，然而更重要的则是在新的道路上不断地提升自己的实力，学习知识、开阔眼界。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>49d095c2ebcf26e0b8fe6b08018cf4ed</guid>
<title>万字长文说透分布式锁</title>
<link>https://toutiao.io/k/zlvt91d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-sourcepos=&quot;3:1-3:264&quot;&gt;&lt;strong data-darkmode-color-16275682949322=&quot;rgb(255, 23, 0)&quot; data-darkmode-original-color-16275682949322=&quot;#fff|rgb(52, 73, 94)|rgb(233, 0, 0)&quot; data-style=&quot;font-family: &amp;quot;Source Sans Pro&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px; text-align: start; white-space: normal; caret-color: rgb(52, 73, 94); color: rgb(233, 0, 0);&quot; class=&quot;js_darkmode__1&quot;&gt;&lt;em data-darkmode-color-16275682949322=&quot;rgb(128, 157, 185)&quot; data-darkmode-original-color-16275682949322=&quot;#fff|rgb(52, 73, 94)|rgb(233, 0, 0)|rgb(52, 73, 94)&quot; data-style=&quot;color: rgb(52, 73, 94); text-size-adjust: auto;&quot; class=&quot;js_darkmode__2&quot;&gt;&lt;em data-darkmode-color-16136621561195=&quot;rgb(128, 157, 185)&quot; data-darkmode-original-color-16136621561195=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)&quot; data-style=&quot;max-width: 100%; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); text-size-adjust: auto; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__3&quot; data-darkmode-color-16165880998151=&quot;rgb(128, 157, 185)&quot; data-darkmode-original-color-16165880998151=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)&quot; data-darkmode-bgcolor-16165880998151=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16165880998151=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16178855864317=&quot;rgb(128, 157, 185)&quot; data-darkmode-original-color-16178855864317=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)&quot; data-darkmode-bgcolor-16178855864317=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16178855864317=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16195315735269=&quot;rgb(128, 157, 185)&quot; data-darkmode-original-color-16195315735269=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)&quot; data-darkmode-bgcolor-16195315735269=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16195315735269=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16275682949322=&quot;rgb(128, 157, 185)&quot; data-darkmode-original-color-16275682949322=&quot;#fff|rgb(52, 73, 94)|rgb(233, 0, 0)|rgb(52, 73, 94)&quot; data-darkmode-bgcolor-16275682949322=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16275682949322=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;strong data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(0, 0, 0)&quot; data-style=&quot;max-width: 100%; font-size: medium; letter-spacing: 0.544px; color: rgb(0, 0, 0); font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__4&quot; data-darkmode-color-16094149065186=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(0, 0, 0)&quot; data-darkmode-color-16107273892940=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16107273892940=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-color-16121907968588=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16121907968588=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-bgcolor-16121907968588=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16121907968588=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16136621561195=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16136621561195=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-bgcolor-16136621561195=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16136621561195=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16165880998151=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16165880998151=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-bgcolor-16165880998151=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16165880998151=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16178855864317=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16178855864317=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-bgcolor-16178855864317=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16178855864317=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16195315735269=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16195315735269=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-bgcolor-16195315735269=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16195315735269=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16275682949322=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16275682949322=&quot;#fff|rgb(52, 73, 94)|rgb(233, 0, 0)|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-bgcolor-16275682949322=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16275682949322=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(136, 136, 136)&quot; data-darkmode-color-16094149065186=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(136, 136, 136)&quot; data-darkmode-color-16107273892940=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16107273892940=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)&quot; data-darkmode-color-16121907968588=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16121907968588=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16121907968588=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16121907968588=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16136621561195=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16136621561195=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16136621561195=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16136621561195=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16165880998151=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16165880998151=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16165880998151=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16165880998151=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16178855864317=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16178855864317=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16178855864317=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16178855864317=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16195315735269=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16195315735269=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16195315735269=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16195315735269=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16275682949322=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16275682949322=&quot;#fff|rgb(52, 73, 94)|rgb(233, 0, 0)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16275682949322=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16275682949322=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(217, 33, 66)&quot; data-darkmode-color-16094149065186=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(217, 33, 66)&quot; data-darkmode-color-16107273892940=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16107273892940=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(217, 33, 66)&quot; data-darkmode-color-16121907968588=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16121907968588=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(217, 33, 66)&quot; data-darkmode-bgcolor-16121907968588=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16121907968588=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16136621561195=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16136621561195=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(217, 33, 66)&quot; data-darkmode-bgcolor-16136621561195=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16136621561195=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16165880998151=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16165880998151=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(217, 33, 66)&quot; data-darkmode-bgcolor-16165880998151=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16165880998151=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16178855864317=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16178855864317=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(217, 33, 66)&quot; data-darkmode-bgcolor-16178855864317=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16178855864317=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16195315735269=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16195315735269=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(217, 33, 66)&quot; data-darkmode-bgcolor-16195315735269=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16195315735269=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16275682949322=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16275682949322=&quot;#fff|rgb(52, 73, 94)|rgb(233, 0, 0)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(217, 33, 66)&quot; data-darkmode-bgcolor-16275682949322=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16275682949322=&quot;#fff|rgb(255, 255, 255)&quot;&gt;▲ &lt;/span&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(2, 30, 170)&quot; data-style=&quot;max-width: 100%; color: rgb(2, 30, 170); text-align: center; font-size: 11px; letter-spacing: 1px; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__5&quot; data-darkmode-color-16094149065186=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(2, 30, 170)&quot; data-darkmode-color-16107273892940=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16107273892940=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(2, 30, 170)&quot; data-darkmode-color-16121907968588=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16121907968588=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(2, 30, 170)&quot; data-darkmode-bgcolor-16121907968588=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16121907968588=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16136621561195=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16136621561195=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(2, 30, 170)&quot; data-darkmode-bgcolor-16136621561195=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16136621561195=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16165880998151=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16165880998151=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(2, 30, 170)&quot; data-darkmode-bgcolor-16165880998151=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16165880998151=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16178855864317=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16178855864317=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(2, 30, 170)&quot; data-darkmode-bgcolor-16178855864317=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16178855864317=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16195315735269=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16195315735269=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(2, 30, 170)&quot; data-darkmode-bgcolor-16195315735269=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16195315735269=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16275682949322=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16275682949322=&quot;#fff|rgb(52, 73, 94)|rgb(233, 0, 0)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(2, 30, 170)&quot; data-darkmode-bgcolor-16275682949322=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16275682949322=&quot;#fff|rgb(255, 255, 255)&quot;&gt;点击上方&quot;多颗糖&quot;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;em data-darkmode-color-16136621561195=&quot;rgb(128, 157, 185)&quot; data-darkmode-original-color-16136621561195=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)&quot; data-style=&quot;max-width: 100%; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); text-size-adjust: auto; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__6&quot; data-darkmode-color-16165880998151=&quot;rgb(128, 157, 185)&quot; data-darkmode-original-color-16165880998151=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)&quot; data-darkmode-bgcolor-16165880998151=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16165880998151=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16178855864317=&quot;rgb(128, 157, 185)&quot; data-darkmode-original-color-16178855864317=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)&quot; data-darkmode-bgcolor-16178855864317=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16178855864317=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16195315735269=&quot;rgb(128, 157, 185)&quot; data-darkmode-original-color-16195315735269=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)&quot; data-darkmode-bgcolor-16195315735269=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16195315735269=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16275682949322=&quot;rgb(128, 157, 185)&quot; data-darkmode-original-color-16275682949322=&quot;#fff|rgb(52, 73, 94)|rgb(233, 0, 0)|rgb(52, 73, 94)&quot; data-darkmode-bgcolor-16275682949322=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16275682949322=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;strong data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(0, 0, 0)&quot; data-style=&quot;max-width: 100%; font-size: medium; letter-spacing: 0.544px; color: rgb(0, 0, 0); font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__7&quot; data-darkmode-color-16094149065186=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(0, 0, 0)&quot; data-darkmode-color-16107273892940=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16107273892940=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-color-16121907968588=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16121907968588=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-bgcolor-16121907968588=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16121907968588=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16136621561195=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16136621561195=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-bgcolor-16136621561195=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16136621561195=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16165880998151=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16165880998151=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-bgcolor-16165880998151=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16165880998151=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16178855864317=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16178855864317=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-bgcolor-16178855864317=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16178855864317=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16195315735269=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16195315735269=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-bgcolor-16195315735269=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16195315735269=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16275682949322=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16275682949322=&quot;#fff|rgb(52, 73, 94)|rgb(233, 0, 0)|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-bgcolor-16275682949322=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16275682949322=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(136, 136, 136)&quot; data-darkmode-color-16094149065186=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(136, 136, 136)&quot; data-darkmode-color-16107273892940=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16107273892940=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)&quot; data-darkmode-color-16121907968588=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16121907968588=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16121907968588=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16121907968588=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16136621561195=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16136621561195=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16136621561195=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16136621561195=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16165880998151=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16165880998151=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16165880998151=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16165880998151=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16178855864317=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16178855864317=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16178855864317=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16178855864317=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16195315735269=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16195315735269=&quot;#fff|rgb(52, 73, 94)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(2, 30, 170)&quot; data-darkmode-bgcolor-16195315735269=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16195315735269=&quot;#fff|rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; color: rgb(2, 30, 170); text-align: center; font-size: 11px; letter-spacing: 1px; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__8&quot; data-darkmode-color-16275682949322=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16275682949322=&quot;#fff|rgb(52, 73, 94)|rgb(233, 0, 0)|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(2, 30, 170)&quot; data-darkmode-bgcolor-16275682949322=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16275682949322=&quot;#fff|rgb(255, 255, 255)&quot;&gt;关注公众号&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;3:1-3:264&quot;&gt;“分布式锁”这个问题快被说烂了，奈何笔者实在没有找到一个满意的答案，故记录自己寻找答案、总结的过程。分布式锁的设计涉及了许多分布式系统相关的问题，许多地方值得推敲，非常有意思。&lt;/p&gt;&lt;h2 data-sourcepos=&quot;5:1-5:9&quot;&gt;TL; DR&lt;/h2&gt;&lt;p data-sourcepos=&quot;7:1-7:123&quot;&gt;太长不看？没关系，我已经做好了思维导图，点个分享再收藏，支持一下，也方便以后查阅。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5450612833453496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0kaN4nMibMuHuiatStdHWq2DscpeSO5Vt8nfQnETDvKzhydRvu6icCK2eFnOLfZwOyrN6YA4sfIS6Mg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2774&quot;/&gt;&lt;/p&gt;&lt;h2 data-sourcepos=&quot;11:1-11:39&quot;&gt;分布式锁三个属性和两大类&lt;/h2&gt;&lt;p data-sourcepos=&quot;13:1-13:261&quot;&gt;多线程编程通常使用 &lt;code&gt;mutex&lt;/code&gt; 或信号量等方式进行同步；在同一个操作系统下的多进程也能通过共享内存等方式同步；但在分布式系统多进程之间的资源争抢，例如下单抢购，就需要额外的分布式锁。&lt;/p&gt;&lt;p data-sourcepos=&quot;15:1-15:206&quot;&gt;分布式锁大多都是 Advisory lock，即在访问数据前先获取锁信息，再根据信息决定是否可以访问；相对的是 mandatory lock，未授权访问锁定的数据时会产生异常。&lt;/p&gt;&lt;p data-sourcepos=&quot;17:1-17:414&quot;&gt;分布式锁属于分布式互斥问题(distributed mutual exclusion)，实际上 Lamport 在那篇经典论文 &quot;Time, clocks, and the ordering of events in a distributed system&quot; 中早就证明了使用状态机能够去中心化解决多进程互斥问题，而共识算法就能实现这样的状态机。但大多时候我们还是会使用一个分布式锁而不是构建一个共识库，主要因为：&lt;/p&gt;&lt;ol data-sourcepos=&quot;18:1-21:0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;很多(业务)系统很难改造成使用共识算法，锁服务更易于保持已存在的程序结构和通信模式；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;基于锁的接口更为程序员所熟悉。虽然可能只是表面熟悉 :)，但肯定好过使用一个共识库；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;锁服务能减少客户端系统运行的服务器数目。一个共识算法需要 quorum 做决策，即我们常说的超过半数节点可用，每个客户端都构建成 quorum 需要大量的服务器，而一套分布式锁服务可以安全地服务多个客户端。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-sourcepos=&quot;22:1-22:123&quot;&gt;因此，相比于客户端实现一个共识库，使用分布式锁服务耦合更松、更易用、也更节省资源。&lt;/p&gt;&lt;p data-sourcepos=&quot;24:1-24:304&quot;&gt;提起分布式锁，大家可能马上会想到各种实现方式，以及一场关于基于 Redis 实现的分布式锁是否安全的论战，这些文章可能很多地方都能搜到。但在开始讨论这些东西之前，我们首先要思考，一个分布式锁到底需要具备哪些性质？&lt;/p&gt;&lt;p data-sourcepos=&quot;26:1-26:60&quot;&gt;总的来说，分布式锁服务有三个必备的性质：&lt;/p&gt;&lt;ul data-sourcepos=&quot;27:1-30:0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;互斥（Mutual Exclusion）&lt;/strong&gt;，这是锁最基本的功能，同一时刻只能有一个客户端持有锁；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;避免死锁（Dead lock free）&lt;/strong&gt;，如果某个客户端获得锁之后花了太长时间处理，或者客户端发生了故障，锁无法释放会导致整个处理流程无法进行下去，所以要避免死锁。最常见的是通过设置一个 TTL(Time To Live，存活时间) 来避免死锁。假设设置 TTL 为 3 秒，如果 3 秒过后锁还没有被释放，系统也会自动释放该锁（TTL 的设置要非常小心！这个时长取决于你的业务逻辑）。可是这也存在一个问题，假如进程1获取了锁，然后由于某些原因（下面会说到）没有来得及更新 TTL；3秒后进程2来获取锁，由于 TTL 已过，进程2可以获得锁并开始处理，此时同时有两个客户端持有锁，可能会产生意外行为。所以我们不能只有 TTL，还需要给锁附加一个唯一 ID (或 fencing token)来标识锁。上述逻辑中，当进程 1 获取到锁后记为 LOCK_1；TTL 过后进程 2 获取到的锁记为 LOCK_2。之后，我们可以在应用层面或锁服务层面检查该 id，来阻断旧的请求。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;容错（Fault tolerance）&lt;/strong&gt;，为避免单点故障，锁服务需要具有一定容错性。大体有两种容错方式，一种是锁服务本身是一个集群，能够自动故障切换(ZooKeeper、etcd)；另一种是客户端向多个独立的锁服务发起请求，其中某个锁服务故障时仍然可以从其他锁服务读取到锁信息(Redlock)，代价是一个客户端要获取多把锁，并且要求每台机器的时钟都是一样的，否则 TTL 会不一致，可能有的机器会提前释放锁，有的机器会太晚释放锁，导致出现问题。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-sourcepos=&quot;31:1-31:356&quot;&gt;&lt;p data-sourcepos=&quot;31:3-31:356&quot;&gt;值得注意的是，容错会以性能为代价，容错性取决于你的系统级别，如果你的系统可以承担分布式锁存在误差，那么单节点或者简单的主从复制也许就能满足；如果你的系统非常严格，例如金融系统或航天系统，那么就要考虑每个 corner case——本文更倾向于讨论后者。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-sourcepos=&quot;33:1-33:147&quot;&gt;我们会拿着这三个属性逐一分析各种分布式锁的实现。在此之前，先把分布式锁分为两大类：自旋类和监听类。&lt;/p&gt;&lt;blockquote data-sourcepos=&quot;37:1-37:81&quot;&gt;&lt;p data-sourcepos=&quot;37:3-37:81&quot;&gt;因此，本文默认读者大概了解 Redis、ZooKeeper 和 etcd 是什么。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-sourcepos=&quot;39:1-39:108&quot;&gt;如此，我们在头脑中已经有了一个很好的框架，现在开始往思维导图中填充知识。&lt;/p&gt;&lt;h2 data-sourcepos=&quot;41:1-41:27&quot;&gt;基于数据库的实现&lt;/h2&gt;&lt;p data-sourcepos=&quot;43:1-43:307&quot;&gt;最简单的，我们想到通过某个独立的数据库（或文件），当获取到数据时，往数据库中插入一条数据。之后的进程想要获取数据，会先检查数据库是否存在记录，就能够知道是否有别的进程持有锁，这便实现了分布式锁的&lt;strong&gt;互斥性&lt;/strong&gt;。&lt;/p&gt;&lt;p data-sourcepos=&quot;45:1-45:139&quot;&gt;数据库可以通过主从同步复制来实现&lt;strong&gt;容错&lt;/strong&gt;，虽然主从复制切换时不会非常轻松，可能需要管理员参与。&lt;/p&gt;&lt;p data-sourcepos=&quot;47:1-47:149&quot;&gt;为了&lt;strong&gt;避免死锁&lt;/strong&gt;，我们需要增加时间戳字段和自增 id 字段，同时在后台启动一个线程定时释放和清理过期的锁。&lt;/p&gt;&lt;table data-sourcepos=&quot;49:1-54:52&quot;&gt;&lt;thead&gt;&lt;tr data-sourcepos=&quot;49:1-49:19&quot;&gt;&lt;th data-sourcepos=&quot;49:2-49:9&quot;&gt;字段&lt;/th&gt;&lt;th data-sourcepos=&quot;49:11-49:18&quot;&gt;作用&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr data-sourcepos=&quot;51:1-51:36&quot;&gt;&lt;td data-sourcepos=&quot;51:2-51:5&quot;&gt;id&lt;/td&gt;&lt;td data-sourcepos=&quot;51:7-51:35&quot;&gt;自增 id，唯一标识锁&lt;/td&gt;&lt;/tr&gt;&lt;tr data-sourcepos=&quot;52:1-52:19&quot;&gt;&lt;td data-sourcepos=&quot;52:2-52:6&quot;&gt;key&lt;/td&gt;&lt;td data-sourcepos=&quot;52:8-52:18&quot;&gt;锁名称&lt;/td&gt;&lt;/tr&gt;&lt;tr data-sourcepos=&quot;53:1-53:27&quot;&gt;&lt;td data-sourcepos=&quot;53:2-53:8&quot;&gt;value&lt;/td&gt;&lt;td data-sourcepos=&quot;53:10-53:26&quot;&gt;自定义字段&lt;/td&gt;&lt;/tr&gt;&lt;tr data-sourcepos=&quot;54:1-54:52&quot;&gt;&lt;td data-sourcepos=&quot;54:2-54:6&quot;&gt;ttl&lt;/td&gt;&lt;td data-sourcepos=&quot;54:8-54:51&quot;&gt;存活时间，定时清理，避免死锁&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-sourcepos=&quot;57:1-57:154&quot;&gt;可见基于数据库的实现较为繁琐，要自己维护锁的 TTL；除非使用分布式数据库，否则主从复制的故障切换并不轻松。&lt;/p&gt;&lt;p data-sourcepos=&quot;59:1-59:234&quot;&gt;除了麻烦之外，如果经常用数据库你也知道，在高并发常见下数据库读写是非常缓慢的，会导致我们的系统性能存在瓶颈。如果采用多个独立数据库进行容错，那性能就更差了。&lt;/p&gt;&lt;p data-sourcepos=&quot;61:1-61:125&quot;&gt;于是，为了分布式锁的性能，开始转向基于 Redis 或者 memcache 等内存存储系统来实现分布式锁。&lt;/p&gt;&lt;h2 data-sourcepos=&quot;63:1-63:25&quot;&gt;基于 Redis 的实现&lt;/h2&gt;&lt;p data-sourcepos=&quot;65:1-65:98&quot;&gt;分布式锁最多的恐怕就是基于 Redis 的实现。首先我们从单节点 Redis 开始。&lt;/p&gt;&lt;h3 data-sourcepos=&quot;67:1-67:41&quot;&gt;基于单节点 Redis 的分布式锁&lt;/h3&gt;&lt;p data-sourcepos=&quot;69:1-69:145&quot;&gt;总的来说就是一条命令实现写 key + 设置过期时间，否则原子性无法保证可能出现死锁。于是就有了以下命令：&lt;/p&gt;&lt;p data-sourcepos=&quot;71:1-71:27&quot;&gt;&lt;code&gt;set key value nx px 10000&lt;/code&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;73:1-73:42&quot;&gt;&lt;code&gt;set&lt;/code&gt; 命令后的 5 个参数分别是：&lt;/p&gt;&lt;ol data-sourcepos=&quot;74:1-79:0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;第一个为 key 作为锁名；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第二个为 value，一般传入一个唯一 id，例如一个随机数或者客户端 mac 地址 + uuid；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第三个为 NX，意思是 SET IF NOT EXIST，即只有 key 不存在时才进行 &lt;code&gt;set&lt;/code&gt; 操作；若 key 已经存在(锁已被占)，则不做任何操作；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第四个为 PX，作用是给这个 key 加一个过期时间，具体时间长短由第五个参数决定；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第五个为具体的过期时间，对应第四个参数 PX 是毫秒，EX 是秒；&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-sourcepos=&quot;80:1-80:304&quot;&gt;这个方案在互斥性和避免死锁上性能良好，且非常轻量。但单节点的 Redis 存在单点故障。注意，Redis 主从复制是异步的，所以加入从节点会增加破坏互斥性的风险。为了实现容错性，就有了基于多节点 Redis 的分布式锁，即 Redlock。&lt;/p&gt;&lt;h3 data-sourcepos=&quot;82:1-82:41&quot;&gt;基于多节点 Redis 的分布式锁&lt;/h3&gt;&lt;p data-sourcepos=&quot;84:1-84:205&quot;&gt;Redlock 用到多个独立的 Redis 节点，其思想简而言之，是在多个 Redis 实际都获取锁，其中一个宕机了，只要还有超过半数节点可用，就可以继续提供锁服务。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9546485260770975&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0kaN4nMibMuHuiatStdHWq2D4vIjt8dicw1jYceicRqj25iaLNDuyTueBrwPvB3MFJpOJwyNj6et16M3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;441&quot;/&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;86:1-86:44&quot;&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;88:1-88:59&quot;&gt;如图所示，Redlock 获取锁的大致步骤如下，：&lt;/p&gt;&lt;ol data-sourcepos=&quot;89:1-94:0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;依次对多个 Redis 实例进行加锁(一般是3个或5个)，加锁命令使用单实例 Redis 的加锁命令；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为了避免在某个节点长时间获取不到锁而阻塞，每次获取锁操作也有一个超时时间，远小于 TTL，超过超时时间则认为失败，继续向下一个节点获取锁；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;计算整个获取多把锁的总消耗时间，只有在超过半数节点都成功获取锁，并且总消耗时间小于 TTL，则认为成功持有锁；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;成功获取锁后，要重新计算 TTL = TTL - 总消耗时间；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果获取锁失败，要向所有 redis 实例发送释放锁的命令。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-sourcepos=&quot;95:1-95:65&quot;&gt;释放锁操作就是向所有实例都发送删除 key 命令。&lt;/p&gt;&lt;p data-sourcepos=&quot;97:1-97:131&quot;&gt;Redlock 容错性依赖于一个时间戳的计算，这在分布式系统中并不受待见，于是有了一场著名的论战。&lt;/p&gt;&lt;h2 data-sourcepos=&quot;99:1-99:17&quot;&gt;Redlock 论战&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1580817051509769&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0kaN4nMibMuHuiatStdHWq2DIkxtOKicEvygVibHmxDtich30k5AJzXMQibYtCYkHkHsVXFD7AZ0VibBIQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;563&quot;/&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;104:1-104:251&quot;&gt;DDIA 的作者 Martin Kleppmann 大佬发表了著名的文章《How to do distributed locking》，表示 Redlock 并不可靠，该文章主要阐述了两个观点：&lt;/p&gt;&lt;ol data-sourcepos=&quot;105:1-107:0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Redis 命令避免了死锁但可能会不满足互斥性，因为没有自增 id 或 fencing token 来阻断同时获得锁的两个客户端；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Redlock 基于时间戳的合理性值得怀疑，多台服务器难以保证时间一致；&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-sourcepos=&quot;108:1-108:224&quot;&gt;第一点如下图所示，Client 1 获取锁后发生了 STW GC(或缺页等问题)，TTL 过期后 Client 2 获取了锁，此时两个客户端持有锁，违反了互斥性。后续写操作自然就可能存在问题。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36363636363636365&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0kaN4nMibMuHuiatStdHWq2Djg86vPr5DGcuKFfM0U0hKqS0Zg7sz8LAKgOxI1CL77T8480dSsggdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1100&quot;/&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;110:1-110:44&quot;&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;112:1-112:267&quot;&gt;我们在避免死锁时提到，需要另外用单调递增 id (Martin 称之为 fencing token，也叫序列号)来标识每一个锁。增加 id 后逻辑如下图所示，最后的 Client 1 的写请求因为 token 是旧的，会被存储系统拒绝。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36363636363636365&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0kaN4nMibMuHuiatStdHWq2DvVQnxsNj5pYI2N1ZEuGtGOJ8viaXmtYs9KWPMZmmMajGicsWHl6RECaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1100&quot;/&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;114:1-114:44&quot;&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;116:1-116:261&quot;&gt;第二点 Martin 认为，Redlock 的时间戳计算方式不可靠，每台服务器的走时并不绝对准确，例如 NTP 进行同步时系统会发生时钟漂移，即当前服务器的时间戳突然变大或变小，这都会影响 Redlock 的计算。&lt;/p&gt;&lt;p data-sourcepos=&quot;118:1-118:253&quot;&gt;Martin 的这篇文章引起了大家对分布式锁广泛讨论。Redis 作者 antirez 也不甘示弱，发表文章《Is Redlock safe?》进行反驳，回应了上述两个问题，我总结了 antirez 的论点：&lt;/p&gt;&lt;ol data-sourcepos=&quot;119:1-121:0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;针对第一点，虽然 Redlock 提供不了自增 id 这样的字段，但是由客户端指定的字段 value 也可以实现唯一标识，并通过 read-modify-write 原子操作来进行检查；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;时钟发送漂移肯定会影响 Redlock 安全性，可是通过恰当的运维，例如不要随意人为修改时钟、将一次大的 NTP 时钟调整转换成多次微小的调整等方式，使时钟修改不超过某个范围就不会对 Redlock 产生影响。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-sourcepos=&quot;122:1-122:298&quot;&gt;&lt;p data-sourcepos=&quot;122:3-122:298&quot;&gt;非常推荐阅读争论的两篇文章，但篇幅所限我只提取了观点。关于争论的详细内容张铁蕾老师的文章《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&amp;amp;mid=2657261521&amp;amp;idx=1&amp;amp;sn=7bbb80c8fe4f9dff7cd6a8883cc8fc0a&amp;amp;chksm=84479e08b330171e89732ec1460258a85afe73299c263fcc7df3c77cbeac0573ad7211902649&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基于Redis的分布式锁到底安全吗（下）？&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;基于Redis的分布式锁到底安全吗（下）？&lt;/a&gt;》也有着比较完整的中文回顾。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-sourcepos=&quot;124:1-124:51&quot;&gt;对于这两个问题，我想谈谈我的理解。&lt;/p&gt;&lt;p data-sourcepos=&quot;126:1-126:567&quot;&gt;对于第一个问题，文章开头“三大属性”我们就分析过，增加 TTL 来避免死锁就会对互斥性产生影响，无论基于 Redis 还是基于 Zookeeper 实现都会存在该问题。antirez 观点是 Redlock 也可以用 value 作为唯一标识来阻断操作，这确实没问题，我也挑不出毛病。但我们可以思考下，&lt;strong&gt;实际编程中读者您觉得使用一个自增 id 进行判断容易还是使用 read-modify-write 操作更容易呢？&lt;/strong&gt;（实际上，一开始我都不怎么理解什么是 read-modify-write 操作）&lt;/p&gt;&lt;p data-sourcepos=&quot;128:1-128:139&quot;&gt;我认为 fencing token 是一个更好的解决方案，一个单调自增的 id 更符合我们的直觉，同时也更好进行 debug。&lt;/p&gt;&lt;p data-sourcepos=&quot;130:1-130:329&quot;&gt;作为 fencing token 的一个实际参考，Hazelcast 的文章 &quot;Distributed Locks are Dead; Long Live Distributed Locks!&quot; 给出了一个 FencedLock 解决方案，并且通过了 Jepsen 测试。&lt;/p&gt;&lt;p data-sourcepos=&quot;132:1-132:148&quot;&gt;第二个问题，时钟漂移是否应该引起注意呢？antirez 的观点是时钟确实会影响 Redlock，但可以通过合理运维避免。&lt;/p&gt;&lt;p data-sourcepos=&quot;134:1-134:300&quot;&gt;Julia Evans(也是很出名的技术博主)也写了一篇后续文章 &quot;TIL: clock skew exists&quot;，来讨论时钟漂移的问题是否真的值得引起注意。最终得出的结论是：有界的时钟漂移不是一个安全的假设。&lt;/p&gt;&lt;p data-sourcepos=&quot;136:1-136:48&quot;&gt;事实上，时钟问题并不罕见，例如：&lt;/p&gt;&lt;ul data-sourcepos=&quot;137:1-141:0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Nelson Minar 在1999年发表了论文，通过调查发现，NTP 服务器经常提供不正确的时间；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;aphyr 的文章《The trouble with timestamps》也总结了时间戳在分布式系统中的麻烦；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Google 在 Spanner 中投入大量精力来处理时间问题，并发明了 TrueTime 这一授时系统；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;闰秒也会导致时钟漂移，不过闰秒确实非常罕见（即使是现在，闰秒依然会导致许多问题，以后我们会专门谈谈）。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-sourcepos=&quot;142:1-142:207&quot;&gt;通过上述例子，时钟问题是真实存在的，如果你的系统对分布式锁的安全性要求严格，不想造成任何系统和金钱上的损失，那么你应该考虑所有的边缘情况。&lt;/p&gt;&lt;p data-sourcepos=&quot;144:1-144:231&quot;&gt;Martin Kleppmann 没有回复任何 Hacker News 的评论，他觉得自己想要表达的都已经说完了，他不想参与争论，他认为实际上一个分布式系统到底该怎么做取决于你如何管理你的系统。&lt;/p&gt;&lt;p data-sourcepos=&quot;146:1-146:161&quot;&gt;本文想表达的也是这样的观点，软件工程没有银弹，这些 trade-off 取决于你系统的重要级别，你怎么管理你的分布式系统。&lt;/p&gt;&lt;p data-sourcepos=&quot;148:1-148:155&quot;&gt;只不过分布式系统研究人员通常会非常关注那些看似非常不可能在你的电脑上发生的事情(例如：时钟偏移)，原因是：&lt;/p&gt;&lt;ol data-sourcepos=&quot;149:1-152:0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;需要找出某个算法来解决此类问题，因此需要考虑所有 corner case；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分布式系统中会有成千上万的机器，那么不大可能发生的事情会变得极有可能；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;其中一些问题其实是很常见的（例如：网络分区）。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-sourcepos=&quot;153:1-153:26&quot;&gt;基于 ZooKeeper 实现&lt;/h2&gt;&lt;p data-sourcepos=&quot;155:1-155:74&quot;&gt;除了 Redlock，还有哪些既能容错又能避免死锁的方式呢？&lt;/p&gt;&lt;p data-sourcepos=&quot;157:1-157:336&quot;&gt;容错性当然离不开我们的老朋友共识算法，我们不再让客户端依次上多个锁，而是让锁服务器通过共识算法复制到多数派节点，然后再回复客户端。由于共识算法本身不依赖系统时间戳而是逻辑时钟（Raft 的任期或 Paxos 的 epoch），故不存在时钟漂移问题。&lt;/p&gt;&lt;p data-sourcepos=&quot;159:1-159:138&quot;&gt;其次，死锁避免问题依然需要 TTL 和自增 id 等手段，我们通过锁服务给每次加锁请求标识上单调递增 id。&lt;/p&gt;&lt;p data-sourcepos=&quot;161:1-161:216&quot;&gt;通过以上两种方法，我们可以得到一个更可靠的分布式锁。代价是，我们需要一个实现共识算法的第三方组件。下文主要介绍三个此类实现：ZooKeeper、etcd 和 Chubby。&lt;/p&gt;&lt;p data-sourcepos=&quot;163:1-163:87&quot;&gt;ZooKeeper 是一个分布式协调服务，参见：《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwODA2NjIxOA==&amp;amp;mid=2247484272&amp;amp;idx=1&amp;amp;sn=2133da6dacf2d1e153d9bbca96b16e3f&amp;amp;chksm=970980b5a07e09a382576d91ef8e532b79f07cb5c09a0a889098766933bc1e32f6faaa02d0cf&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;ZooKeeper 设计原理&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;ZooKeeper 设计原理&lt;/a&gt;》。&lt;/p&gt;&lt;p data-sourcepos=&quot;165:1-165:71&quot;&gt;基于 ZooKeeper 实现的分布式锁依赖以下两个节点属性：&lt;/p&gt;&lt;ul data-sourcepos=&quot;166:1-168:0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;sequence&lt;/code&gt;：顺序节点，ZooKeeper 会将一个10位带有0填充的序列号附加到客户端设置的 znode 路径之后。例如 &lt;code&gt;locknode/guid-lock-&lt;/code&gt; 会返回 &lt;code&gt;locknode/guid-lock-0000000001&lt;/code&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;ephemeral&lt;/code&gt;：临时节点，当客户端和 ZooKeeper 连接断开时，临时节点会被删除，能够避免死锁。但这个断开检测依然有一定心跳延迟，所以仍然需要自增 id 来避免互斥性被破坏。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-sourcepos=&quot;169:1-169:145&quot;&gt;ZooKeeper 官方文档有提供现成的分布式锁实现方法：&lt;/p&gt;&lt;ol data-sourcepos=&quot;170:1-175:0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;首先调用 &lt;code&gt;create()&lt;/code&gt;，锁路径例如 &lt;code&gt;locknode/guid-lock-&lt;/code&gt;，并设置 &lt;code&gt;sequence&lt;/code&gt; 和 &lt;code&gt;ephemeral&lt;/code&gt; 标志。&lt;code&gt;guid&lt;/code&gt; 是客户端的唯一标识，如果 &lt;code&gt;create()&lt;/code&gt; 创建失败可以通过 &lt;code&gt;guid&lt;/code&gt; 来进行检查，下面会提到；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;调用 &lt;code&gt;getChildren()&lt;/code&gt; 获取子节点列表，不要设置 watch 标志（很重要，可以避免 Herd Effect，即惊群效应）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;检查 2 中的子节点列表，如果步骤 1 中创建成功并且返回的序列号后缀是最小的，则客户端持有该分布式锁，到此结束；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果发现序列不是最小的，则从子节点列表中选择比当前序列号小一位的节点记为 p，客户端调用 &lt;code&gt;exist(p, watch=true)&lt;/code&gt;，即监听 p，当 p 被删除时收到通知（该节点只有比自己小一位的节点释放时才能获得锁）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果 &lt;code&gt;exist()&lt;/code&gt; 返回 null，即前一个分布式锁被释放了，转到步骤 2；否则需要一直等待步骤 4 中 watch 的通知。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.810126582278481&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0kaN4nMibMuHuiatStdHWq2DIibm6ia6icxHQNsxIWFX2NEicePKrFOKwLdJJQ8arL7PUWRc7MkibcsibATw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;632&quot;/&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;176:1-177:95&quot;&gt;&lt;em&gt;如上图所示，每个客户端只监听比自己小的 znode，可以避免惊群效应。&lt;/em&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;179:1-179:30&quot;&gt;获取锁的伪代码如下：&lt;/p&gt;&lt;pre data-sourcepos=&quot;180:1-186:3&quot;&gt;&lt;code&gt;n = create(l + “/guid-lock-”, EPHEMERAL|SEQUENTIAL)&lt;br/&gt;C = getChildren(l, false)&lt;br/&gt;if n is lowest znode in C, exit&lt;br/&gt;p = znode in C ordered just before n&lt;br/&gt;goto 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-sourcepos=&quot;188:1-188:88&quot;&gt;释放锁非常简单：客户端直接删除他们在步骤 1 创建的 znode 节点。&lt;/p&gt;&lt;p data-sourcepos=&quot;190:1-190:24&quot;&gt;有几点需要注意：&lt;/p&gt;&lt;p data-sourcepos=&quot;195:1-195:158&quot;&gt;当然，虽然 ZooKeeper 的实现看起来更为可靠，但根据你实现锁的方式，可能还是会有大量的锁逻辑调试、锁争抢等问题。&lt;/p&gt;&lt;p data-sourcepos=&quot;197:1-197:130&quot;&gt;基于 ZooKeeper 的分布式锁性能介于基于 Mysql 和基于 Redis 的实现之间，性能上当然不如单节点 Redis。&lt;/p&gt;&lt;p data-sourcepos=&quot;199:1-199:96&quot;&gt;ZooKeeper 的另一个缺点是需要另外维护一套 ZooKeeper 服务（已有则忽略）。&lt;/p&gt;&lt;h2 data-sourcepos=&quot;201:1-201:7&quot;&gt;etcd&lt;/h2&gt;&lt;p data-sourcepos=&quot;203:1-203:219&quot;&gt;Etcd 是著名的分布式 key-value 存储结构，因在 Kubernetes 中使用而闻名。etcd 同样可以用来实现分布式锁，官方也很贴心的提供了 &lt;code&gt;clientv3&lt;/code&gt; 包给开发者快速实现分布式锁。&lt;/p&gt;&lt;p data-sourcepos=&quot;205:1-205:72&quot;&gt;我们来看下 etcd 是如何解决分布式锁“三大问题”的：&lt;/p&gt;&lt;ul data-sourcepos=&quot;206:1-209:0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;互斥：etcd 支持事务，通过事务创建 key 和检查 key 是否存在，可以保证互斥性；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;容错：etcd 基于 Raft 共识算法，写 key 成功至少需要超过半数节点确认，这就保证了容错性；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;死锁：etcd 支持租约(Lease)机制，可以对 key 设置租约存活时间(TTL)，到期后该 key 将失效删除，避免死锁；etc 也支持租约续期，如果客户端还未处理完可以继续续约；同时 etcd 也有自增 id，在下文介绍。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-sourcepos=&quot;210:1-210:451&quot;&gt;为了帮助开发者快速实现分布式锁，etcd 给出了 &lt;code&gt;clientv3&lt;/code&gt; 包，其中分布式锁在 &lt;code&gt;concurrency&lt;/code&gt; 包中。按照官方文档给出的案例&lt;span&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/span&gt;，首先创建一个新的会话(session)并指定租约的 TTL，然后实例化一个 &lt;code&gt;NewMutex()&lt;/code&gt; 之后就可以调用 &lt;code&gt;Lock()&lt;/code&gt; 和 &lt;code&gt;Unlock()&lt;/code&gt; 进行抢锁和释放锁。代码如下：&lt;/p&gt;&lt;pre data-sourcepos=&quot;212:1-235:3&quot; tabindex=&quot;0&quot;&gt;&lt;code&gt;cli&lt;span&gt;,&lt;/span&gt; err &lt;span&gt;:=&lt;/span&gt; clientv3&lt;span&gt;.&lt;/span&gt;&lt;span&gt;New&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;clientv3&lt;span&gt;.&lt;/span&gt;Config&lt;span&gt;{&lt;/span&gt;Endpoints&lt;span&gt;:&lt;/span&gt; endpoints&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;   log&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Fatal&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; cli&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Close&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;s&lt;span&gt;,&lt;/span&gt; err &lt;span&gt;:=&lt;/span&gt; concurrency&lt;span&gt;.&lt;/span&gt;&lt;span&gt;NewSession&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;cli&lt;span&gt;,&lt;/span&gt; concurrency&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WithTTL&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;   log&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Fatal&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Close&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;m &lt;span&gt;:=&lt;/span&gt; concurrency&lt;span&gt;.&lt;/span&gt;&lt;span&gt;NewMutex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;/my-lock/&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err &lt;span&gt;:=&lt;/span&gt; m&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Lock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;context&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;   log&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Fatal&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;acquired lock for s&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err &lt;span&gt;:=&lt;/span&gt; m&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Unlock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;context&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;   log&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Fatal&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;released lock for s&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-sourcepos=&quot;237:1-237:145&quot;&gt;其中 &lt;code&gt;Lock()&lt;/code&gt; 函数的源代码很容易找到，由于篇幅我就不放出来了，但源代码中可以看到的一些其他机制包括：&lt;/p&gt;&lt;ul data-sourcepos=&quot;238:1-241:0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Revision 机制。一个全局序列号，跟 ZooKeeper 的序列号类似，可以用来避免 watch 惊群；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Prefix 机制。即上述代码中 etcd 会创建一个前缀为 &lt;code&gt;/my-lock/&lt;/code&gt; 的 key(&lt;code&gt;/my-lock/&lt;/code&gt; + LeaseID)，分布式锁由该前缀下 revision 最小(最早创建)的 key 获得；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Watch 机制。跟 ZooKeeper 一样，客户端会监听 revision 比自己小的 key，当比自己小的 key 释放锁后，尝试去获得锁。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-sourcepos=&quot;242:1-242:68&quot;&gt;本质上 etcd 和 ZooKeeper 对分布式锁的实现是类似的。&lt;/p&gt;&lt;p data-sourcepos=&quot;244:1-244:33&quot;&gt;选择 etcd 的原因可能有：&lt;/p&gt;&lt;h2 data-sourcepos=&quot;249:1-249:9&quot;&gt;Chubby&lt;/h2&gt;&lt;p data-sourcepos=&quot;252:1-252:279&quot;&gt;最后简要谈一下 Chubby。由于 Chubby 没有开源，没法直接使用，细节也难以得知，很少会有造一个 Chubby 的需求（虽然我老东家真的用 C++ 造了一个）。因此，Chubby 部分只是 Paper 读后感，不感兴趣的读者可以跳过。&lt;/p&gt;&lt;p data-sourcepos=&quot;254:1-254:158&quot;&gt;&lt;span&gt;Chubby&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;是 Google 研发的松耦合分布式锁服务，此外 GFS 和 BigTable 使用 Chubby 来存储一些元数据。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Chubby 有以下几大特点：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;260:1-260:459&quot;&gt;Chubby 依赖于 Paxos 共识算法来实现容错，数据以 UNIX 文件系统方式进行组织(称为 Node)，同样有 Ephemeral 类型的临时节点，断开连接后会被删除；支持监听某个 Node——总而言之，我们可以从 ZooKeeper 上看到许多 Chubby 的影子，ZooKeeper 和 Chubby 解决的问题是比较类似的，因此很多人认为 ZooKeeper 是 Chubby 的开源实现，不过两者的具体架构还是略有不同。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5936794582392777&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0kaN4nMibMuHuiatStdHWq2DvnUjzPTVqeRBBz3cwGCfuTc1EwtRr4CNYxBU7QFKcv6iabPmTvb1L7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;443&quot;/&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;264:1-264:267&quot;&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;264:1-264:267&quot;&gt;为了容错，一个 Chubby 集群包含 5 个节点，组成一个 Chubby cell。这 5 个节点只有一个是 master 其余都是 replicas，只有 Master 能够处理请求和读写文件，其它副本节点通过 Paxos 算法复制 Master 的行为来容错。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5692599620493358&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0kaN4nMibMuHuiatStdHWq2DnLPDxDiahN3uTpv6HmWelDlhC0pN8D2CQU63CHgyr8y0NsOVUut2GUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;527&quot;/&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;268:1-268:19&quot;&gt;Chubby 还支持：&lt;/p&gt;&lt;ul data-sourcepos=&quot;269:1-273:0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Sequencer&lt;/code&gt;：锁的序列号(更好的避免死锁和 watch)；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Session&lt;/code&gt;：客户端会话，包括租约时间；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;KeepAlive&lt;/code&gt;：在租约快要过期时可以发送 &lt;code&gt;KeepAlive&lt;/code&gt; 续约；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Cache&lt;/code&gt;：锁服务支持大量的客户端，为了减少读请求支持客户端无感知的缓存；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-sourcepos=&quot;274:1-274:209&quot;&gt;比较有意思的是 Chubby 的&lt;strong&gt;故障恢复&lt;/strong&gt;。当 Master 发生故障，其内存的 session 和锁信息会丢失，session 中最重要的租约信息，Paxos 算法会选举出新的 Master，然后：&lt;/p&gt;&lt;ol data-sourcepos=&quot;275:1-279:0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;选择新的 epoch，可以理解为 Raft 中的任期，小于 epoch 的客户端请求会被拒绝，保证了 Master 不会响应旧 Master 的请求；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;根据数据库(持久化存储)中的数据恢复出 session 和锁相关信息，并将 session 租约延长到一个可能的最大期限；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;只接受 KeepAlive 请求；下图步骤 4 中第一个 KeepAlive 请求会由于epoch错误而被 Maser 拒绝，但客户端也因此获得了最新的 epoch；步骤 6 中第二个 KeepAlive 成功，由于上一步延长的租约够长，步骤 7 的响应会延长客户端本地的租约时间；接着恢复正常的通信。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;从新请求中发现老 Master 创建的 Handle 时，新 Master 也需要重建，一段时间后(一般是一分钟)，删除没有 Handle 的临时节点&lt;/em&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-sourcepos=&quot;280:1-280:128&quot;&gt;整个过程如图所示。其中绿色都是安全时期，橙色部分是危险时期，Chubby 集群切换到新的 Master。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.31127982646420826&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0kaN4nMibMuHuiatStdHWq2D9Lx3o2vJrA2wGA01W2hyodXibTXnicicCozJ8qIX0vhtVLiaBgNQaTQv1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1844&quot;/&gt;&lt;/p&gt;&lt;p data-sourcepos=&quot;285:1-285:84&quot;&gt;Chubby 我不想太过深入，我想大家没有再造一个 Chubby 的动力了。&lt;/p&gt;&lt;h2 data-sourcepos=&quot;287:1-287:9&quot;&gt;结语&lt;/h2&gt;&lt;p data-sourcepos=&quot;289:1-289:245&quot;&gt;写这篇文章的时候内心是忐忑的，为了 ego 和不被大家骂我尽量不犯错，但错误实在难免，并且随着时间推移可能两三年后一些解决方案并不适用。这篇文章实在花了我许多时间和精力。&lt;/p&gt;&lt;p data-sourcepos=&quot;291:1-291:233&quot;&gt;想要深入分布式锁问题的同学，我推荐好好看一遍 Lamport 的 &quot;Time, clocks, and the ordering of events in a distributed system&quot;，&lt;strong&gt;当然我的新书里也有对该论文的剖析，下半年会跟大家见面&lt;/strong&gt;。&lt;/p&gt;&lt;p data-sourcepos=&quot;293:1-293:90&quot;&gt;最后，本文如有不妥之处，希望读者能够留言指出，我会积极改正。&lt;/p&gt;&lt;h2 data-sourcepos=&quot;295:1-295:12&quot;&gt;Reference&lt;/h2&gt;&lt;section&gt;&lt;p data-sourcepos=&quot;297:7-297:147&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;1. Lamport, Leslie. &quot;Time, clocks, and the ordering of events in a distributed system.&quot; Concurrency: the Works of Leslie Lamport. 2019. 179-196.&lt;/p&gt;&lt;p&gt;2. How to do distributed locking, https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html&lt;/p&gt;&lt;p&gt;3. Is Redlock safe?, http://antirez.com/news/101&lt;/p&gt;&lt;p&gt;4. Distributed Locks are Dead; Long Live Distributed Locks! https://hazelcast.com/blog/long-live-distributed-locks/&lt;/p&gt;&lt;p&gt;5. TIL: clock skew exists,http://jvns.ca/blog/2016/02/09/til-clock-skew-exists/&lt;/p&gt;&lt;p&gt;6. A Survey of the NTP Network, http://alumni.media.mit.edu/~nelson/research/ntp-survey99/&lt;/p&gt;&lt;p&gt;7. The trouble with timestamps, https://aphyr.com/posts/299-the-trouble-with-timestamps&lt;/p&gt;&lt;p&gt;8. Corbett, James C., et al. &quot;Spanner: Google’s globally distributed database.&quot; ACM Transactions on Computer Systems (TOCS) 31.3 (2013): 1-22.&lt;/p&gt;&lt;p&gt;9. Hunt, Patrick, et al. &quot;ZooKeeper: Wait-free Coordination for Internet-scale Systems.&quot; USENIX annual technical conference. Vol. 8. No. 9. 2010.&lt;/p&gt;&lt;p&gt;10. ZooKeeper 实现分布式锁官方文档, https://zookeeper.apache.org/doc/r3.7.0/recipes.html#sc_recipes_Locks&lt;/p&gt;&lt;p&gt;11. etcd 实现分布式锁官方案例，https://github.com/etcd-io/etcd/blob/main/tests/integration/clientv3/concurrency/mutex_test.go&lt;/p&gt;&lt;p&gt;12. Burrows, Mike. &quot;The Chubby lock service for loosely-coupled distributed systems.&quot; Proceedings of the 7th symposium on Operating systems design and implementation. 2006.&lt;/p&gt;&lt;p data-sourcepos=&quot;297:7-297:147&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;欢迎关注我的公众号：&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwODA2NjIxOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0g3RQ9bRYaJib92ovwsSB9pPup1lt5cB24cJVJia1dc3Nr2kFSBHsJq5HL9DcLhoAGribSBvHU7ZzjA/0?wx_fmt=png&quot; data-nickname=&quot;多颗糖&quot; data-alias=&quot;duoketang&quot; data-signature=&quot;分布式系统和个人成长。我想要说的，前人们都说过了。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3b7859d981cfc1c2633ecbd1dc24e4ff</guid>
<title>浅谈订单重构之路</title>
<link>https://toutiao.io/k/cz5lqu8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近负责了订单重构项目，从技术方案设计，到最终落地，项目圆满完成。虽然重构项目做了很多次，每次都是在挑战极限，在时间紧任务重的情况下，有条不紊的推进。最终提测质量高，平滑上线，此文章特此记录一下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;背景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原订单单库单表，数据量大，已到达性能瓶颈，且无法水平扩容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订单增长迅速，重构迫在眉睫。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;目标&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;订单分库分表，方便后期水平扩展&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订单流程改造，并且平滑过渡到新流程。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;重构方案&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注: 所谓重构方案，一定是基于特定场景的，没有统一方案，但核心思想是一样的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景: 网约车场景，下单量大，但是大部分订单会派不上司机取消。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方案: 增加派前订单表，派前订单表分库分表， 派上司机后，订单进入派后表(老表)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此方案优势: 不影响派后订单流程(例如，司机端流程，计费流程)，压力集中在派前表，同时派前表数据无需长时间保留(例如7天归档)。派前订单表数据量极小，查询写入效率高。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5605726872246696&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kulR6Bq67W9YZVwbu1HyomyUpwxnAqBQEzetEaB9Av3JVMUjLjVD8KGbJ8X56alsw1xqryeBdNicxKpV3BSKCSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;img.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分库分表方案:&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.42578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kulR6Bq67W9YZVwbu1HyomyUpwxnAqBQEYJAZUAwaSqd8ic1Vw1FJ8pWdobXicgazsT88nQU475HGRv18wRW9Ywg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;img.png&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;灰度方案&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按流量灰度，分为5个阶段，平滑过渡到新流程&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;一阶段&lt;/th&gt;&lt;th&gt;二阶段&lt;/th&gt;&lt;th&gt;三阶段&lt;/th&gt;&lt;th&gt;四阶段&lt;/th&gt;&lt;th&gt;五阶段&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;1/100000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1‰&lt;/span&gt;&lt;/td&gt;&lt;td&gt;10%&lt;/td&gt;&lt;td&gt;50%&lt;/td&gt;&lt;td&gt;100%&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;时间安排&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.24228028503562946&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kulR6Bq67W9YZVwbu1HyomyUpwxnAqBQmoMflUertfdLXFRibGoKOib3ibiaYNPR6UlapXteiajB4Kh9UvSak7sicgOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;842&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;img.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调研&amp;amp;方案设计: 4天&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发人力: 4人7个工作日&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试人力: 6人3个工作日&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;灰度时间: 2周&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注: 虽然时间紧，任务重，该有的流程不能忽视&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;重构收益&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次重构如期上线，并且测试阶段bug极少，可以说超预期。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在数据库资源不变情况下，下单接口性能提升N倍(N&amp;gt;4)。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;重构后下单接口RT&amp;lt;50ms, 基础服务(dubbo服务)下单接口 RT &amp;lt; 5ms。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;订单分库分表，分了256张表，8个库，目前在一个数据库集群，最多支持8个数据库集群水平扩展。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4）订单架构分层，分为业务层和数据层，订单内部通信改为RPC通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7c2b98365f94703e8adda1e6510dd610</guid>
<title>关于推荐系统中产品经理如何定位的问题</title>
<link>https://toutiao.io/k/sbuphpf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作者·黄崇远&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;『数据虫巢』&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全文共&lt;strong&gt;2821&lt;/strong&gt;字&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;题图ssyer.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;374&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;442&quot; data-ratio=&quot;1.65&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqsfk6bM7QwwqsV0svU56oFLsXF6Xyg85myAiaF05Zgro8V0FG6mlWQja3ZicOsL6CfD9V1MLRdBo5QQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;“&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 推荐系统看着是一个偏技术的问题，但实际上少不了产品逻辑的赋能，很多时候产品逻辑能起到的是四两拨千斤的作用。&lt;strong&gt;&lt;span&gt;”&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在很多时候，我们都是以技术的视角去观测推荐系统，从推荐的算法逻辑到推荐系统的技术架构逻辑，并且从技术视角基本上已经成为了推荐系统问题讨论和演化的一个“标准”做法了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐系统这种看似偏重于底层策略算法逻辑的产品形态，直接影响的更多是底层逻辑，甚至更透彻一点说是算法策略逻辑，但推荐这种产品形态是非常贴近于用户端的，甚至可以说很多时候研究的是一种用户心理。算法工程师从数学、从算法模型的角度去诠释这种“心理”变化，而产品则可以从心理学、产品学的逻辑去设计逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;甚至很多时候，产品的一些策略逻辑，在推荐系统的效果上往往能起到“四两拨千斤”的巧妙作用。所以，作为研究推荐以及跟推荐强相关的广告相关的从业者们，特别是技术从业者，不可忽视产品逻辑在其中的作用，并且需要理解其中的相关逻辑，以及从技术维度上与产品逻辑形成良好的协同作用，最终才能给用户呈现一个较好的推荐结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在理清楚推荐产品经理的职能之前，需要理清楚推荐产品经理与算法策略工程师的边界，即哪些逻辑由什么角色来决定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以电商领域的购物车结算场景为例，在结算列表中是否需要提供一个商品推荐列表，这个显然是由产品经理来决定，并且结合当前业务逻辑，以凑单满减等类似的形态进行包装，这显然也是产品经理的决策范围。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但具体推荐什么商品，理论上是一个算法策略问题，应该交由算法策略工程师通过推荐算法模型以及相关策略决定最终呈现的商品。但同样，这是一个有限制的算法逻辑实现，即待推荐的商品需要考虑的商业影响因素是，参与了凑单满减之后，对于平台来说需要计算一定的盈利空间，所以对于算法工程师来说，其待召回的商品列表并不是一个完全的商品集，而是在产品经理甚至是结合了运营等逻辑筛选之后的一个子候选集。并且，对于这个场景的推荐评估来说，业务评估需要结合产品经理对于满减目标达成的目的进行推荐效果进行业务评估。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从这个例子中我们可以看到，在整个推荐系统落地的过程中，与商业逻辑强相关的决策部分一定是产品经理的职责范畴，而算法工程师更多是在“框架”限制的基础上，进行目标优化，或者换种描述就是，明确输入输出的基础上进行效果最大化的模型设计以及实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，什么场景下是否进行物品的推荐是由产品经理决定的，对于商品的输出是否有大的商业逻辑限制是由产品经理决定的，具体业务的考核目标也是产品经理决定的。在这个基础上，算法以及策略工程师围绕业务目标，进行效果最大化的技术逻辑设计和实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，具体的推荐策略，例如算法模型中是偏重USER的关系进行推荐，还是偏重于用户的历史记录进行推荐，还是偏重于当前浏览的商品进行推荐，又或者说抛开这些逻辑，只要模型的评估指标好，业务指标达成较好就推荐哪个商品？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结起来就是，推荐产品经理要不要具体干涉到算法推荐的具体策略，甚至影响到推荐结果的重新排序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于很多中初级的推荐算法工程师来说可能会觉得只要目标清晰了，对于哪些商品应该排在前面，也就是预估的分值的强弱的决定权应该掌握在算法工程师的手里。但实际上，虽然对于业务指标的界定是清晰的，但是还有很多逻辑是没有办法显式的融入到单次算法逻辑的业务评估中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如，对于整体平台的中长期的发展考量，更为直接点的就是用户体验，单次的业务指标的达成，如CTR的提升，是无法看出这种逻辑修改对于中长期的用户体验影响的，以及推荐系统中一直备受“诟病”的“信息茧房”问题（即随着用户对于推荐信息的持续反馈，导致用户的兴趣越来越窄，最终看到的信息都是单点的，从而形成了茧房）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种偏重于中长期的平台考量，通过短期的推荐业务指标设置是比较难以量化的，因此必须要在推荐的逻辑中进行干预，例如推荐的召回环节进行多路的逻辑召回，又或者在精排预估之后进行一些商业策略的重排序微调等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;涉及到推荐的问题，很多读者朋友们可能听过多样性、新颖度、惊喜度等名词，其实本质上他们都是偏向于产品逻辑的一种描述。就以提升用户体验的多样性为例，大部分推荐系统在召回逻辑中大多会有意识的去构建多种逻辑的召回，比如通过ITEM相似关系做召回，通过用户的长期兴趣做召回，通过用户的短期兴趣做召回，通过用户与用户的协同关系做物品召回等。本意上就是为了从多个角度去考虑候选集的组成，从而构建推荐物品列表的多样性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，假如你认真地问产品经理，到底什么是多样性，具体怎么去精准的量化，笔者估计大部分应该是回答不上来的，甚至可以说到底做到什么程度的多样性对于用户的体验来说就是好的或者是不够的，这些都没有标准的答案，最多通过用户访谈等有限的逻辑去收集推荐列表的多样性是否得到满足。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但不管怎么看，这种多样性的考虑本身就是一种相对感性的解决逻辑，但又成为了推荐系统中“约定俗成”的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，推荐产品经理与推荐算法工程师的职责边界用另一个逻辑去解释可能更容易理解，即推荐产品经理偏重于中长期的平台逻辑，以及一些偏感性的决策逻辑，而推荐算法工程师则着重解决目标明确的优化问题，以及平台明确的短期收益优化问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;沿着这个思路，例如一个平台其基本基调是偏重于社交关系的平台，那么在产品经理的视角中，其推荐逻辑中一定会侧重关系链为核心基础的推荐策略，这就不单纯是达成业务指标的问题，更多是通过这种逻辑进一步完善整体平台的调性，这与算法工程师本身去优化业务指标并没有冲突，而是考虑点不同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更进一步的体现就是，推荐理由的设计。所谓推荐理由，通常推荐相关的栏位中，其推荐栏位都有标题，大体上会表现出推荐逻辑的偏重。例如上述说的偏重于社交关系的平台中，可能更多会给出类似“你的朋友们也都喜欢看、买”之类的理由。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先不考虑推荐列表的具体算法模型逻辑，单纯从这种推荐理由的引导角度看，这就是一种产品设计的思维，从整体平台逻辑协调的角度去设计这种引导。并且，这种引导看似只有简单的一句话，但是往往很多时候调整这种逻辑比你辛辛苦苦优化模型效果来的更加的便捷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;伴随着推荐系统的迭代，随之完善的就是在线分流实验系统，即通过实验分流，可以精准的对比在线不同策略的效果，这里所谓的策略当然也包括了类似上述这种推荐理由的策略尝试。所以，随着技术的不断发展，推荐产品经理也在不断将过去那种偏重于感性的逻辑设计，当成一种可以对比量化的策略逻辑去构建实验分流，最终通过数据的观察来决定产品策略的落地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于实验系统相关的内容，我们在后续章节中也会进一步的进行了解和讨论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回到这个小章节的话题，对于从事于推荐领域的两个不同角色，我们需要多从对方视角去理解决策落地的逻辑，从而让推荐系统变得更加的合理，这也要求推荐产品经理更加能够从算法设计的逻辑去思考问题，而推荐算法工程师也更加的关注平台的长期受益，甚至把这种思想融入到模型设计中去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;着手当下，放眼未来，这才是推荐系统能够长存的基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9465648854961832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icr5FVCSvBqvMexxWOopOqLBDkK4OcleOkgZGq1Nam2wx8KHreT6gcGaEAOHDaREvvGbFfYficNNNkpHKMxiaYRIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;131&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;文章都看完了，还不点个赞来个赏~&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-id=&quot;2255&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4NDE2Mzc5Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/L1DZlNuj2MVtThPyeNicwY65TGF50j7R2FbP6sT0utKIiak73ooPBVuARS0RkULCGjhpzicGHOSIuzmvC5tEkQBVg/0?wx_fmt=png&quot; data-nickname=&quot;夏虫悟冰&quot; data-alias=&quot;chong_talk&quot; data-signature=&quot;我希望这个号，能够帮助我在认知乃至于人生价值维度上进行升华，形成自我的良性循环，并且是无拘无束的内容表达，夏虫依然可以语冰，言冰，悟冰，不去折腾安能体会东寒之爽快。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;217&quot; data-backw=&quot;554&quot; data-before-oversubscription-url=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/icr5FVCSvBqvKestzBFLnfCjCM3dqHibqiaNpeU4tUjKw5ehb6Pdumns43uNwbr8VWHE2qJMh1WlSZtibU81nHUdXg/0?wx_fmt=jpeg&quot; data-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBqvKestzBFLnfCjCM3dqHibqiadMpRoNxpDgggQFw15AdfibagOvQNbiakdzy3icmLsyTl5G1icl3O1rB3SQ/0?wx_fmt=jpeg&quot; data-ratio=&quot;0.390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/icr5FVCSvBqvKestzBFLnfCjCM3dqHibqiaNpeU4tUjKw5ehb6Pdumns43uNwbr8VWHE2qJMh1WlSZtibU81nHUdXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e9b813f8ad69af9dd106283bb97ae26b</guid>
<title>前端性能优化：preload, prefetch, preconnect</title>
<link>https://toutiao.io/k/5kbom1j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-header&quot;&gt;&lt;h1 class=&quot;title&quot;&gt;前端性能优化-preload,prefetch,preconnect&lt;/h1&gt;&lt;p class=&quot;meta&quot;&gt;小纪同学 Posted at — Aug 10, 2021
&lt;span class=&quot;meta&quot; id=&quot;busuanzi_container_page_pv&quot;&gt;阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;markdown&quot;&gt;&lt;p&gt;提到前端性能优化，我们通常会想到启用压缩，压缩资源文件大小。或者启用浏览器缓存，可以起到较少 HTTP 请求，优化资源加载速度的效果，但这些手段主要提升重复访问相同资源时的加载速度。默认情况下，浏览器只会先加载 HTML 中声明的资源。如果没有声明，浏览器是不会提前加载资源的。那有没有什么办法能提前加载页面所需资源，优化首次的加载速度呢？&lt;/p&gt;&lt;p&gt;很幸运，随着 Web 技术的发展，现代的浏览器可以做到提前加载页面所需资源了。使用资源提示伪指令 prefetch 和 preload，可以提前告知浏览器加载资源，从而可以缩短网站的（首次）加载速度，优化页面性能。&lt;/p&gt;&lt;h2 id=&quot;preload&quot;&gt;preload&lt;/h2&gt;&lt;p&gt;一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用的时候立即执行，就无需等待网络的消耗。&lt;/p&gt;&lt;p&gt;使用方式有三种：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt; &lt;span&gt;使用&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; &lt;span&gt;标签静态标记需要预加载的资源&lt;/span&gt; --&amp;gt;
&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;preload&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;/path/to/style.css&quot;&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;=&lt;span&gt;&quot;style&quot;&lt;/span&gt;&amp;gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt; &lt;span&gt;用脚本动态创建一个&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; &lt;span&gt;标签后插入到&lt;/span&gt; &lt;span&gt;head&lt;/span&gt; &lt;span&gt;头部&lt;/span&gt; --&amp;gt;
&amp;lt;&lt;span&gt;script&lt;/span&gt;&amp;gt;
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; = &lt;span&gt;document&lt;/span&gt;.&lt;span&gt;createElement&lt;/span&gt;(&lt;span&gt;&#x27;link&#x27;&lt;/span&gt;);
&lt;span&gt;link&lt;/span&gt;.&lt;span&gt;rel&lt;/span&gt; = &lt;span&gt;&#x27;preload&#x27;&lt;/span&gt;;
&lt;span&gt;link&lt;/span&gt;.&lt;span&gt;as&lt;/span&gt; = &lt;span&gt;&#x27;style&#x27;&lt;/span&gt;;
&lt;span&gt;link&lt;/span&gt;.&lt;span&gt;href&lt;/span&gt; = &lt;span&gt;&#x27;/path/to/style.css&#x27;&lt;/span&gt;;
&lt;span&gt;document&lt;/span&gt;.&lt;span&gt;head&lt;/span&gt;.&lt;span&gt;appendChild&lt;/span&gt;(&lt;span&gt;link&lt;/span&gt;);
&amp;lt;/script&amp;gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt; &lt;span&gt;在&lt;/span&gt; &lt;span&gt;HTTP&lt;/span&gt; &lt;span&gt;响应头中加上&lt;/span&gt; &lt;span&gt;preload&lt;/span&gt; &lt;span&gt;字段&lt;/span&gt; --&amp;gt;
&lt;span&gt;Link&lt;/span&gt;: &amp;lt;&lt;span&gt;https&lt;/span&gt;:&lt;span&gt;//example.com/other/styles.css&amp;gt;; rel=preload; as=style
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;rel 属性值为 preload；as 属性用于规定资源的类型，并根据资源类型设置Accep请求头，以便能够使用正常的策略去请求对应的资源；href 为资源请求地址；onload 和onerror 则分别是资源加载成功和失败后的回调函数；&lt;/p&gt;&lt;p&gt;as 值包括：style、script、image、font、fetch、document、audio、video等。
如果请求跨域资源，需要加上crossorigin属性。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;preload&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;font.woff2&quot;&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;=&lt;span&gt;&quot;font&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;font/woff2&quot;&lt;/span&gt; &lt;span&gt;crossorigin&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;特点&quot;&gt;特点&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;preload 不会阻塞 windows 的 onload 事件，除非，preload资源的请求刚好来自于会阻塞 window 加载的资源。&lt;/li&gt;&lt;li&gt;在请求跨域资源时推荐加上crossorigin属性，否则可能会导致资源的二次加载（尤其是font资源）。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;使用场景&quot;&gt;使用场景&lt;/h3&gt;&lt;h4 id=&quot;1-提前加载字体&quot;&gt;1. 提前加载字体&lt;/h4&gt;&lt;p&gt;web 中字体属于较晚加载的一类资源，但是字体的渲染对用户体验来说至关重要。如果加载慢了会给用户造成字体抖动的现象，即字体会先显示成环境默认字体。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;preload&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;font.woff2&quot;&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;=&lt;span&gt;&quot;font&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;font/woff2&quot;&lt;/span&gt; &lt;span&gt;crossorigin&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&quot;2-加载第三方js&quot;&gt;2. 加载第三方js&lt;/h4&gt;&lt;p&gt;比如加载一段统计页面访问量的代码，但又不愿意这段代码的加载给页面渲染造成延迟从而影响用户体验，不想延迟 window 的 onload 事件。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;preload&quot;&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;=&lt;span&gt;&quot;script&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;async_script.js&quot;&lt;/span&gt;
    &lt;span&gt;onload&lt;/span&gt;=&lt;span&gt;&quot;var script = document.createElement(&#x27;script&#x27;); 
&lt;/span&gt;&lt;span&gt;    script.src = this.href; document.body.appendChild(script);&quot;&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&quot;3-响应式加载&quot;&gt;3. 响应式加载&lt;/h4&gt;&lt;p&gt;如果 web 端支持手机浏览器访问，对于 web 端和手机端加载不同资源时，可以使用 link 的 media 属性来判断。常见的做法是通过 JS 判断当前浏览器类型动态地加载资源，但这样一来，浏览器的预加载器就无法及时发现他们，可能耽误加载时机，影响用户体验。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;preload&quot;&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;=&lt;span&gt;&quot;image&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;map.png&quot;&lt;/span&gt; &lt;span&gt;media&lt;/span&gt;=&lt;span&gt;&quot;(max-width: 600px)&quot;&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;preload&quot;&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;=&lt;span&gt;&quot;script&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;map.js&quot;&lt;/span&gt; &lt;span&gt;media&lt;/span&gt;=&lt;span&gt;&quot;(min-width: 601px)&quot;&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&quot;4-预测用户行为提前加载资源&quot;&gt;4. 预测用户行为提前加载资源&lt;/h4&gt;&lt;p&gt;比如用户鼠标停留在某个 item 上，例如商品。去分析商品详情页所需要的资源并提前开启 preload 加载。&lt;/p&gt;&lt;h3 id=&quot;兼容性&quot;&gt;兼容性&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;imgs/web-preformance/image1.png&quot; alt=&quot;preload 兼容性&quot;/&gt;&lt;/p&gt;&lt;p&gt;可以通过下面方法判断是否支持 preload：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;isPreloadSupported&lt;/span&gt; = () =&amp;gt; { 
  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; = &lt;span&gt;document&lt;/span&gt;.&lt;span&gt;createElement&lt;/span&gt;(&lt;span&gt;&#x27;link&#x27;&lt;/span&gt;); 
  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;relList&lt;/span&gt; = &lt;span&gt;link&lt;/span&gt;.&lt;span&gt;relList&lt;/span&gt;; 
  &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;relList&lt;/span&gt; || !&lt;span&gt;relList&lt;/span&gt;.&lt;span&gt;supports&lt;/span&gt;) { 
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;  
  } 
  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;relList&lt;/span&gt;.&lt;span&gt;supports&lt;/span&gt;(&lt;span&gt;&#x27;preload&#x27;&lt;/span&gt;); 
};

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;preload-会使资源优先加载&quot;&gt;preload 会使资源优先加载&lt;/h3&gt;&lt;p&gt;浏览器加载资源优先级如下：
&lt;img src=&quot;imgs/web-preformance/image2.png&quot; alt=&quot;优先级&quot;/&gt;&lt;/p&gt;&lt;p&gt;preload 用 “as” 或者用 “type” 属性来表示他们请求资源的优先级（比如说 preload 使用 as=”style” 属性将获得最高的优先级）。没有 “as” 属性的将被看作异步请求，“Early”意味着在所有未被预加载的图片请求之前被请求（“late”意味着之后）。&lt;/p&gt;&lt;p&gt;可以在 chrome 查看资源优先级：
&lt;img src=&quot;imgs/web-preformance/image6.png&quot; alt=&quot;资源优先级&quot;/&gt;&lt;/p&gt;&lt;h3 id=&quot;注意&quot;&gt;注意&lt;/h3&gt;&lt;h4 id=&quot;避免滥用-preload&quot;&gt;避免滥用 preload&lt;/h4&gt;&lt;p&gt;若不确定资源是必定会加载的，则不要错误使用 preload，以免本末倒置，给页面带来更沉重的负担。当 preload 加载的资源没有使用时，浏览器会给出警告：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;imgs/web-preformance/image3.png&quot; alt=&quot;警告&quot;/&gt;&lt;/p&gt;&lt;h4 id=&quot;preload-加载跨域资源时需要添加-crossorigin-属性&quot;&gt;preload 加载跨域资源时需要添加 crossorigin 属性&lt;/h4&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;preload&quot;&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;=&lt;span&gt;&quot;font&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;https://at.alicdn.com/t/font_zck90zmlh7hf47vi.woff&quot;&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;preload&quot;&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;=&lt;span&gt;&quot;font&quot;&lt;/span&gt; &lt;span&gt;crossorigin&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;https://at.alicdn.com/t/font_zck90zmlh7hf47vi.woff&quot;&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果对跨域的文件进行 preload 的时候，没有添加 crossorigin 属性，将会请求两次。&lt;/p&gt;&lt;h2 id=&quot;prefetch&quot;&gt;prefetch&lt;/h2&gt;&lt;p&gt;prefetch 作用是告诉浏览器未来可能会使用到的某个资源，比如下一页。浏览器就会在闲时去加载对应的资源，若能预测到用户的行为，比如懒加载，点击到其它页面等则相当于提前预加载了需要的资源。它的用法跟 preload 是一样的。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt; &lt;span&gt;使用&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; &lt;span&gt;标签静态标记需要预加载的资源&lt;/span&gt; --&amp;gt;
&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;prefetch&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;/path/to/style.css&quot;&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;=&lt;span&gt;&quot;style&quot;&lt;/span&gt;&amp;gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt; &lt;span&gt;用脚本动态创建一个&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; &lt;span&gt;标签后插入到&lt;/span&gt; &lt;span&gt;head&lt;/span&gt; &lt;span&gt;头部&lt;/span&gt; --&amp;gt;
&amp;lt;&lt;span&gt;script&lt;/span&gt;&amp;gt;
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; = &lt;span&gt;document&lt;/span&gt;.&lt;span&gt;createElement&lt;/span&gt;(&lt;span&gt;&#x27;link&#x27;&lt;/span&gt;);
&lt;span&gt;link&lt;/span&gt;.&lt;span&gt;rel&lt;/span&gt; = &lt;span&gt;&#x27;prefetch&#x27;&lt;/span&gt;;
&lt;span&gt;link&lt;/span&gt;.&lt;span&gt;as&lt;/span&gt; = &lt;span&gt;&#x27;style&#x27;&lt;/span&gt;;
&lt;span&gt;link&lt;/span&gt;.&lt;span&gt;href&lt;/span&gt; = &lt;span&gt;&#x27;/path/to/style.css&#x27;&lt;/span&gt;;
&lt;span&gt;document&lt;/span&gt;.&lt;span&gt;head&lt;/span&gt;.&lt;span&gt;appendChild&lt;/span&gt;(&lt;span&gt;link&lt;/span&gt;);
&amp;lt;/script&amp;gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt; &lt;span&gt;在&lt;/span&gt; &lt;span&gt;HTTP&lt;/span&gt; &lt;span&gt;响应头中加上&lt;/span&gt; &lt;span&gt;prefetch&lt;/span&gt; &lt;span&gt;字段&lt;/span&gt; --&amp;gt;
&lt;span&gt;Link&lt;/span&gt;: &amp;lt;&lt;span&gt;https&lt;/span&gt;:&lt;span&gt;//example.com/other/styles.css&amp;gt;; rel=prefetch; as=style
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;兼容性-1&quot;&gt;兼容性&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;imgs/web-preformance/image4.png&quot; alt=&quot;prefetch 兼容性&quot;/&gt;&lt;/p&gt;&lt;h3 id=&quot;preload-和-prefetch-对比&quot;&gt;preload 和 prefetch 对比&lt;/h3&gt;&lt;p&gt;1、Chrome有四种缓存：http cache、memory cache、Service Worker cache 和 Push cache。在 preload 或 prefetch 的资源加载时，两者均存储在 http cache。当资源加载完成后，如果资源是可以被缓存的，那么其被存储在http cache中等待后续使用；如果资源不可被缓存，那么其在被使用前均存储在 memory cache。&lt;/p&gt;&lt;p&gt;2、preload 和 prefetch 都没有同域名的限制；&lt;/p&gt;&lt;p&gt;3、preload 主要用于预加载当前页面需要的资源；而prefetch主要用于加载将来页面肯能需要的资源；&lt;/p&gt;&lt;p&gt;4、不论资源是否可以缓存，prefetch 会在网络堆栈中至少缓存5分钟；&lt;/p&gt;&lt;p&gt;5、preload 需要使用 as 属性指定特定的资源类型以便浏览器为其分配一定的优先级，并能够正确加载资源。&lt;/p&gt;&lt;h3 id=&quot;避免混用-preload-和-prefetch&quot;&gt;避免混用 preload 和 prefetch&lt;/h3&gt;&lt;p&gt;preload 和 prefetch 混用的话，并不会复用资源，而是会重复加载。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;preload&quot;&lt;/span&gt;   &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;https://at.alicdn.com/t/font_zck90zmlh7hf47vi.woff&quot;&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;=&lt;span&gt;&quot;font&quot;&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;prefetch&quot;&lt;/span&gt;  &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;https://at.alicdn.com/t/font_zck90zmlh7hf47vi.woff&quot;&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;=&lt;span&gt;&quot;font&quot;&lt;/span&gt;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&quot;imgs/web-preformance/image5.png&quot; alt=&quot;资源重复加载&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;preconnect&quot;&gt;preconnect&lt;/h2&gt;&lt;p&gt;preconnect 允许浏览器在一个 HTTP 请求正式发给服务器前预先执行一些操作，这包括 DNS 解析，TLS 协商，TCP 握手，这消除了往返延迟并为用户节省了时间。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;“Preconnect 是优化的重要手段，它可以减少很多请求中的往返路径 —— 在某些情况下可以减少数百或者数千毫秒的延迟。”—— lya Grigorik（Web性能权威指南作者）&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;imgs/web-preformance/image7.png&quot; alt=&quot;preconnect&quot;/&gt;&lt;/p&gt;&lt;p&gt;它的用法跟 preload 是一样的。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt; &lt;span&gt;使用&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; &lt;span&gt;标签静态标记需要预加载的资源&lt;/span&gt; --&amp;gt;
&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;preconnect&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;https://cdn.domain.com&quot;&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;=&lt;span&gt;&quot;style&quot;&lt;/span&gt; &lt;span&gt;crossorigin&lt;/span&gt;&amp;gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt; &lt;span&gt;用脚本动态创建一个&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; &lt;span&gt;标签后插入到&lt;/span&gt; &lt;span&gt;head&lt;/span&gt; &lt;span&gt;头部&lt;/span&gt; --&amp;gt;
&amp;lt;&lt;span&gt;script&lt;/span&gt;&amp;gt;
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;link&lt;/span&gt; = &lt;span&gt;document&lt;/span&gt;.&lt;span&gt;createElement&lt;/span&gt;(&lt;span&gt;&#x27;link&#x27;&lt;/span&gt;);
&lt;span&gt;link&lt;/span&gt;.&lt;span&gt;rel&lt;/span&gt; = &lt;span&gt;&#x27;preconnect&#x27;&lt;/span&gt;;
&lt;span&gt;link&lt;/span&gt;.&lt;span&gt;as&lt;/span&gt; = &lt;span&gt;&#x27;style&#x27;&lt;/span&gt;;
&lt;span&gt;link&lt;/span&gt;.&lt;span&gt;href&lt;/span&gt; = &lt;span&gt;&#x27;https://cdn.domain.com&#x27;&lt;/span&gt;;
&lt;span&gt;document&lt;/span&gt;.&lt;span&gt;head&lt;/span&gt;.&lt;span&gt;appendChild&lt;/span&gt;(&lt;span&gt;link&lt;/span&gt;);
&amp;lt;/script&amp;gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt; &lt;span&gt;在&lt;/span&gt; &lt;span&gt;HTTP&lt;/span&gt; &lt;span&gt;响应头中加上&lt;/span&gt; &lt;span&gt;preconnect&lt;/span&gt; &lt;span&gt;字段&lt;/span&gt; --&amp;gt;
&lt;span&gt;Link&lt;/span&gt;: &amp;lt;&lt;span&gt;https&lt;/span&gt;:&lt;span&gt;//cdn.domain.com&amp;gt;; rel=preconnect; as=style
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面是为 Google Fonts 使用 preconnect 的例子，通过给 fonts.gstatic.com 加入 preconnect 提示，浏览器将立刻发起请求，和 CSS 请求并行执行。在这个场景下，preconnect 从关键路径中消除了三个 RTTs（Round-Trip Time） 并减少了超过半秒的延迟，lya Grigorik 的 &lt;a href=&quot;https://www.igvita.com/2015/08/17/eliminating-roundtrips-with-preconnect/&quot;&gt;eliminating RTTS with preconnect&lt;/a&gt; 一文中有更详细的分析。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&#x27;https://fonts.gstatic.com&#x27;&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&#x27;preconnect&#x27;&lt;/span&gt; &lt;span&gt;crossorigin&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span&gt;link&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&#x27;https://fonts.googleapis.com/css?family=Roboto+Slab:700|Open+Sans&#x27;&lt;/span&gt; &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&#x27;stylesheet&#x27;&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到第二次请求时，节约了 400ms 左右的时间：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;imgs/web-preformance/image8.png&quot; alt=&quot;preconnect 请求&quot;/&gt;&lt;/p&gt;&lt;h3 id=&quot;兼容性-2&quot;&gt;兼容性&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;imgs/web-preformance/image9.png&quot; alt=&quot;preconnect 兼容性&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;案例&quot;&gt;案例&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;Housing.com 在对他们的渐进式 Web 应用程序的脚本转用 proload 看到大约缩短了10%的可交互时间。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;imgs/web-preformance/image10.png&quot; alt=&quot;Housing.com&quot;/&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;p&gt;Shopify 在转用 preload 加载字体后在 Chrome 桌面版获得了 50%（1.2s） 的文字渲染优化，这完全解决了他们的文字闪动问题。
&lt;img src=&quot;imgs/web-preformance/image11.png&quot; alt=&quot;Shopify&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;金融时报在它们的网站使用 preload HTTP 头时，他们节约了大约 1s 的显示片头图片时间。
&lt;img src=&quot;imgs/web-preformance/image12.png&quot; alt=&quot;金融时报&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;preload，prefetch 以及 preconnect 能让浏览器提前加载需要的资源，将资源的下载和执行分离开来，运用得当的话可以对首屏渲染带来不小的提升，可以对页面交互上带来极致的体验。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>