<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>26ec005047116a0084b3beac8b638e2c</guid>
<title>闯过这 54 关，点亮你的 Git 技能树</title>
<link>https://toutiao.io/k/6kqnm2d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;card-body markdown markdown-toc&quot;&gt;
        
        &lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/36eaf186-6a61-427b-8972-04c65a57ad07.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开篇&quot;&gt;开篇&lt;/h2&gt;
&lt;p&gt;如今，Git 大行其道，颇有一统天下之势。
如果你的技能树上 Git 和 Github 的图标还没有点亮的话，你都不好意思说你是程序员。
别说互联网企业，我接触到的许多传统企业都在从 SVN，Clear Case 等迁移到 Git 上，甚至大厂还会有一个团队去定制适合自己企业的 Git 服务器。&lt;/p&gt;

&lt;p&gt;很多人简历上写的「精通 Git 与 Github」，但如果你问他熟悉到什么程度的话，回答通常是「就是会用常用的 add，commit，push 操作」。&lt;/p&gt;

&lt;p&gt;但工作中我们会遇到一些更加复杂的场景：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;忽略某些文件&lt;/li&gt;
&lt;li&gt;创建，删除分支&lt;/li&gt;
&lt;li&gt;找到最后修改某行代码的人&lt;/li&gt;
&lt;li&gt;commit 后发现里边包含一个不应该提交的文件&lt;/li&gt;
&lt;li&gt;commit 后发现少提交了一些文件&lt;/li&gt;
&lt;li&gt;一个文件中的多次有改动，怎么做到只提交其中的一部分？&lt;/li&gt;
&lt;li&gt;怎样整理提交记录使其更加整洁？&lt;/li&gt;
&lt;li&gt;快速定位是哪一次提交引入了 bug&lt;/li&gt;
&lt;li&gt;...
作为一线程序员，我们要如何快速学习 Git 以发挥其最大威力呢？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今天我就要向大家介绍一个工具，准确说应该是「游戏」，名字叫「githug」，它把平常可能遇到的一些场景都实例化，变成一个一个的关卡，一共有 55 个关卡：&lt;/p&gt;
&lt;pre class=&quot;highlight plaintext&quot;&gt;&lt;code&gt;#1: init
#2: config
#3: add
#4: commit
#5: clone
#6: clone_to_folder
#7: ignore
#8: include
#9: status
#10: number_of_files_committed
#11: rm
#12: rm_cached
#13: stash
#14: rename
#15: restructure
#16: log
#17: tag
#18: push_tags
#19: commit_amend
#20: commit_in_future
#21: reset
#22: reset_soft
#23: checkout_file
#24: remote
#25: remote_url
#26: pull
#27: remote_add
#28: push
#29: diff
#30: blame
#31: branch
#32: checkout
#33: checkout_tag
#34: checkout_tag_over_branch
#35: branch_at
#36: delete_branch
#37: push_branch
#38: merge
#39: fetch
#40: rebase
#41: repack
#42: cherry-pick
#43: grep
#44: rename_commit
#45: squash
#46: merge_squash
#47: reorder
#48: bisect
#49: stage_lines
#50: find_old_branch
#51: revert
#52: restore
#53: conflict
#54: submodule
#55: contribute
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;首先我们需要来安装这个游戏，「githug」是用 Ruby 编写的，可通过如下命令安装：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;gem install githug&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果遇到权限问题，请加上 sudo：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;sudo gem install githug&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安装成功后，在 Terminal 里进入你常用的目录，输入 githug，会提示游戏目录不存在，是否要创建一个，输入 y 然后回车：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/33bb1b0e-b9bc-4c91-9930-f89aa1432273.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;根据提示&lt;code&gt;cd git_hug&lt;/code&gt; 进入游戏目录，准备开始游戏。&lt;/p&gt;
&lt;h2 id=&quot;基本命令&quot;&gt;基本命令&lt;/h2&gt;
&lt;p&gt;在开始前我们还需要了解游戏的一些基本操作：&lt;/p&gt;

&lt;p&gt;play - 默认命令，检查是否过关
hint - 显示过关提示
reset - 重启本关，或者重启到指定的某关
levels - 显示关卡列表
来试一下，githug reset：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/05f415e3-0be9-4e00-bca0-daf954e4c5f1.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;我以第一关为例子给大家演示一下玩法。&lt;/p&gt;

&lt;p&gt;第一关的名称是：init，提示是：「一个新目录 git_hug 被创建了，请把它初始化为一个空仓库」。
假设现在我不知道该怎么过关，我可以查看过关提示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/da0dc920-1714-4909-bbdd-85446d4c4c48.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;指示是：「你可以输入 git 命令来查看 git 命令列表」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/00b90da9-0f2e-429f-83c7-499d9dee0f5c.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看最后一行，原来用 git init 就可以初始化一个空仓库，接着输入 githug 进行过关检测：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/a2d14c4f-8586-4c20-b9cf-ec948a2eb427.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;太棒了！顺利进入第二关！&lt;/p&gt;

&lt;p&gt;怎么样？明白了吗？后面的 54 关就靠你自己了哦！&lt;/p&gt;
&lt;h2 id=&quot;友情提示&quot;&gt;友情提示&lt;/h2&gt;
&lt;p&gt;在闯关过程中，尽量使用 githug hint，git help subcommand 获取帮助，也可以根据下面的教程来系统学习：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://backlog.com/git-tutorial/cn/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;&quot;&gt;猴子都能懂的 git 入门&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为保大家都能顺利通关，学到所有的知识点，接下来我会写过关攻略，详细介绍每一关的玩法。&lt;/p&gt;

&lt;p&gt;并且我不会直接给答案，而是演示整个过关的过程。&lt;/p&gt;
        &lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://codingstyle.cn&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;「软件匠艺社区」&lt;/a&gt;旨在传播匠艺精神，通过分享好的「工作方式」，让帮助程序员更加快乐高效地编程！&lt;/p&gt;&lt;/blockquote&gt;
      &lt;/div&gt;
      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1f8f0626936d4d1564dc16821f3e3a26</guid>
<title>Kubernetes 原生 CI/CD 构建框架 Argo 详解</title>
<link>https://toutiao.io/k/y0ieaw4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是流水线？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在计算机中，&lt;strong&gt;流水线是把一个重复的过程分解为若干个子过程，使每个子过程与其他子过程并行进行的技术，也叫 Pipeline&lt;/strong&gt;。由于这种 s工作方式与工厂中的生产流水线十分相似， 因此也被称为流水线技术。从本质上讲，流水线技术是一种时间并行技术。&lt;/span&gt;&lt;span&gt;以“构建镜像”过程为例：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;327&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5658914728682171&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMM9eqKTwE2s4z6umicS2icRp5DUZK4glnxT5QMsbemEv5xvUz8U3GeymWEJUusTEWtOYBGcWu2hMT4w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在每一次构建镜像中，我们都需要拉下代码仓库中的代码，进行代码编译，构建镜像，最后推往镜像仓库。在每一次代码更改过后，这一过程都是不变的。使用流水线工具可以极大的提升这一过程的效率，只需要进行简单的配置便可以轻松的完成重复性的工作。这样的过程也被称之为 CI。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上图流程中使用的是 Jenkins。Jenkins 作为老牌流水线框架被大家所熟知。在云原生时代，Jenkins 推出了 Jenkins X 作为基于 Kubernetes 的新一代流水线，另外云原生时代还&lt;/span&gt;&lt;span&gt;诞生了两大流水线框架—— Argo 和 Tekton。本文就详细介绍了 Argo 的相关内容。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3ODAzMTMyNQ==&amp;amp;mid=2247488127&amp;amp;idx=1&amp;amp;sn=c00dd13b0baa973d3c0a2cb1d27ae7cd&amp;amp;chksm=cf18aacdf86f23db7bb47ef05878b83cbcdbd938e1db5db0f165ee2a62e04b85c6b54e50b2b0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《Kubernetes 原生 CI/CD 构建框架 Tekton 详解！》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《Kubernetes 原生 CI/CD 构建框架 Tekton 详解！》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;详细介绍了 Tekton 的相关内容。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Argo&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Argo Workflows 是一个开源的容器原生的工作流引擎，可在 Kubernetes 上编排并行作业。Argo Workflows 实现为 Kubernetes CRD。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Quick Start&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Argo 基于 Kubernetes，可以直接使用 kubectl 安装，安装的组件主要包括了一些 CRD 以及对应的 controller 和一个 server。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;64&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.11015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUgZV43ymX225cm9qFslKLghVRNjmWPOB90wpqHia0GXxTrezlFkYwHxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;注意，上述安装只会执行同 namespace 内的 Workflow，cluster install 详见文档。文档地址：&lt;/span&gt;&lt;span&gt;https://github.com/argoproj/argo/blob/master/docs/installation.md&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三级定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;要了解 Argo 定义的 CRD，先从其中的三级定义入手。概念上的从大到小分别为 WorkflowTemplate、Workflow、template，这些资源的命名有些相似，要注意分辨。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Template&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从最简单的 template 说起，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一个 template 有多种类型，分别为 container、script、dag、ste&lt;/span&gt;&lt;span&gt;ps、resource 以及 suspend。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;对于 template，我们可以简单的将其理解为一个 Pod ——container/script/resource 类型的 template 都会去实际控制一个 Pod，而 dag/steps 类型的 template 则是由多个基础类型的 template （container/script/resource）组成的。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;container&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：最常见的模板类型，与 Kubernetes container spec 保持一致。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;script&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：该类型基于 Container，支持用户在 template 定义一段脚本，另有一个 Source 字段来表示脚本的运行环境。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;resource&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：该类型支持我们在 template 中对 kubernetes 的资源进行操作，有一个 action 字段可以指定操作类型，如 create, apply, delete 等，并且支持设定相关的成功与失败条件用于判断该 template 的成功与失败。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;suspend&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Suspend template 将在一段时间内或在手动恢复执行之前暂停执行。可以从 CLI （使用 argo resume）、API 或 UI 恢复执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;steps&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Steps Template 允许用户以一系列步骤定义任务。在 Steps 中，[--] 代表顺序执行，[-] 代表并行执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;dag&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：DAG template 允许用户将任务定义为带依赖的有向无环图。在 DAG 中，通过 dependencies设置在特定任务开始之前必须完成的其他任务。没有任何依赖项的任务将立即运行。有关 DAG 的详细逻辑可见源码 &lt;/span&gt;&lt;span&gt;https://github.com/argoproj/argo/blob/master/workflow/controller/dag.go#L204&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Workflow&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在一个 Workflow 中，其 spec 中有一个名为 templates 的字段，在其中至少需要一个 template 作为其组成的任务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个最简单的 hello world 例子如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;359&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6213921901528013&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqU6BDxlSO4y8M6fuiaAQO1p5qRag8WaibAsrAmnRDNud3khMaia5BHgatyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在这个例子中，该 Workflow 的 templates 字段中指定了一个类型为 container 的 template，使用了 whalesay 镜像。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面是一个稍微复杂的 workflow：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.97421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUkJiatZ1kHYzMv6DH8dZCNJMVq2p9Pw08a1oYpDlHtnTqEEDOEE4iau6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;563&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;WorkflowTemplate&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;WorkflowTemplate &lt;/span&gt;相当于 Workflow 的模板库，和 Workflow 一样，也由 template 组成。用户在创建完 WorkflowTemplate 后，可以通过直接提交它们来执行 Workflow。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8388278388278388&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUV66EdLqfJOLGKTmoMs9xRRoJsibu2v8BrRUu6oV7jpvs054DD5lJZkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1092&quot; data-backw=&quot;578&quot; data-backh=&quot;485&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Workflow Overview&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7647058823529411&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUbr2aIupELvQqZ1qibplicqxspEvZnySj3yL1thgExtIKiaJrXWrhNLS3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1020&quot; data-backw=&quot;578&quot; data-backh=&quot;442&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在了解了 Argo 的三级定义后，我们首先来深入一下 Argo 中最为关键的定义，Workflow。&lt;strong&gt;Workflow 是 Argo 中最重要的资源，有两个重要的功能：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于这些双重职责，Workflow 应该被视为一个 Active 的对象。它不仅是一个静态定义，也是上述定义的一个“实例”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Workflow Template 的定义与 Workflow 几乎一致，除了类型不同。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;正因为 Workflow 既可以是一个定义也可以是一个实例，所以才需要 WorkflowTemplate 作为 Workflow 的模板，WorkflowTemplate 在定义后可以通过提交（Submit）来创建一个 Workflow。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;而 Workflow 由一个 entrypoint 及一系列 template 组成，entrypoint 定义了这个 workflow 执行的入口，而 template 会实际去执行一个 Pod，其中，用户定义的内容会在 Pod 中以 Main Container 体现。此外，还有两个 Sidecar 来辅助运行。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Sidecar&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在 Argo 中，这些 Sidecar 的镜像都是 argoexec。Argo 通过这个 executor 来完成一些流程控制。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Init&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当用户的 template 中需要使用到 inputs 中的 artifact 或者是 script 类型时（script 类型需要注入脚本），Argo 都会为这个 pod 加上一个 Init Container —— 其镜像为 argoexec，命令是 argoexec init。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这个 Init Container 中，主要工作就是加载 artifact：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9744680851063829&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqU34T931kQS27RW9W3IdZ6v9bwVT2qJuZwV3vO7t3MSvUcXoG17h22pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot; data-backw=&quot;578&quot; data-backh=&quot;563&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Wait&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除了 Resource 类型外的 template，Argo 都会注入一个 Wait Container，用于等待 Main Container 的完成并结束所有 Sidecar。这个 Wait Container 的镜像同样为 argoexec，命令是 argoexec wait。（Resource 类型的不需要是因为 Resource 类型的 template 直接使用 argoexec 作为 Main Container 运行）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;868&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.50234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUCyRCK9vSYDT7LlfESmcedeBgUN53BJAYKibEYcXl7kRff5vAsPKWGvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Inputs and Outputs&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在运行 Workflow 时，一个常见的场景是输出产物的传递。通常，一个 Step 的输出产物可以用作后续步骤的输入产物。&lt;strong&gt;在 Argo 中，产物可以通过 Artifact 或是 Parameter 传递。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Artifact&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;要使用 Argo 的 Artifact，首先必须配置和使用 Artifact 存储仓库。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;具体的配置方式可以通过修改存有 Artifact Repository 信息的默认 Config Map 或者在 Workflow 中显示指定，详见 配置文档，在此不做赘述。下表为 Argo 支持的仓库类型。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUebOU4jGnfpBcF4AZ7t4doKNOMoNPxWftPDkrCu36ekN0ZhRMBLcwhA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;一个简单的使用了 Artifact 的例子如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.190625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqULprIzymW8BibVkGeQV8OvgZoeqDbR9B7jYCcc6nRXX7kMOicUBibjvJ2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;688&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;默认情况下，Artifact 被打包为 tar 包和 gzip 包，我们也可以使用 archive 字段指定存档策略。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在上面的例子里，名为 whalesay 的 template 使用 cowsay 命令生成一个名为 /tmp/hello-world.txt 的文件，然后将该文件作为一个名为 hello-art 的 Artifact 输出。名为 print-message 的 template 接受一个名为 message 的输入 Artifact，在 /tmp/message 的路径上解包它，然后使用 cat 命令打印 /tmp/message 的内容。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在前面 Sidecar 介绍中提到过，&lt;strong&gt;Init Container 主要用于拉取 Artifact 产物&lt;/strong&gt;。这些 Sidecar 正是产物传递的关键。下面，我们通过介绍另一种产物传递的方式来体验 Argo 中传递产物的关键。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Scripts&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;先来看一个简单的例子：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUHMHZicAEOwGVclLwVia9aroJSkyeNYIbD9g1P4LibIEGClCQIgYr8vKKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;570&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在上面的例子中，有两个类型为 script 的 template，script 允许使用 source 规范脚本主体。这将创建一个包含脚本主体的临时文件，然后将临时文件的名称作为最后一个参数传递给 command（执行脚本主体的解释器），这样便可以方便的执行不同类型的脚本（bash、python、js etc）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Script template 会将脚本的标准输出分配给一个名为 result 的特殊输出参数从而被其他 template 调用。在这里，通过 {{steps.generate.outputs.result}} 即可获取到名为 generate 的 template 的脚本输出。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;{{xxx}} 是 Argo 固定的变量替换格式：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;关于变量的格式详见文档，文档地址：&lt;/span&gt;&lt;span&gt;https://github.com/argoproj/argo/blob/master/docs/variables.md&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;关于变量替换的逻辑详见源码，源码地址：&lt;/span&gt;&lt;span&gt;https://github.com/argoproj/argo/blob/master/workflow/common/util.go#L305&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;那么，容器内部应该如何获取这个脚本输出呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们回到 Sidecar，在 Wait Container 中，有这样一段逻辑：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUxFATxLXYl77wzhvebRUTORnyxfcCksxsibKWEu2yUGs6HOkj2WJrGOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;505&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqU71Yv4U9n7L7wV9XianjnjYxK7dia7p2YUPgVaCJoK6D5A7IW9Uicm9eyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;201&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;再来看看这个 Wait Container 的 Volume Mount 情况：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUxIbWNUutHohzfXdEkdkzYkKPcFHKzWGx5r6KDFk6VeqAiaSviap5r6jQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;261&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;现在就十分明确了，&lt;strong&gt;Wait Container 通过挂载 docker.sock 以及 service account，获取到 Main Container 中的输出结果，并保存到 Workflow 中&lt;/strong&gt;。当然，因为 Workflow 中保存了大量的信息，当一个 Workflow 的 Step 过多时，整个 Workflow 的结构会过于庞大。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Parameter&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Parameter 提供了一种通用机制，可以将步骤的结果用作参数。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Parameter 的工作原理与脚本结果类似，除了输出参数的值会被设置为生成文件的内容，而不是 stdout 的内容。如：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUtaCwVj9Iwr0yG4fWOOVazfW3gIFj6ENblOhQj8D7fK3ElzU8U3hqmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;181&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Volume&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这并不是 Argo 处理产物传递的一种标准方式，但是通过共享存储，我们显然也能达到共通产物的结果。当然，如果使用 Volume，我们则无需借助 Inputs 和 Outputs。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 Workflow 的 Spec 中，我们定义一个 Volume 模板：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUEJzRK8flqgicwiaz1TKCo1xk9dibrBicWPPMKW7VZZV3OQIm5ib9nH4wYJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;210&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;并在其他的 template 中 mount 该 volume：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqU1aLGMTFNoZbAkXgIpibKz9lJ2IjibybichfwTzV9Yuj2f19KnxFZo09vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;155&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;其他流程控制功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;循环&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在编写 Workflow 时，能够循环迭代一组输入通常是非常有用的，如下例所示:&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUK7JKyraKlJe5iaVvhngK3SpiaLj2ftPgPsxURwdvfo3JSEj2TaEYYu4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;205&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在源码实现中，将会去判断 withItems，如果存在，则对其中的每个元素进行一次 step 的扩展。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.71640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUMAvK3nACFX6DLRamJwEkgoD9wPrg8LuutksAgx45qoII7tvAIxnlRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;414&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;条件判断&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过 when 关键字指定：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUNicSicUf9dPSCrm3hdVXibZSjkeqEe1I4VkPhMtrRiaNJ0Viaj119dgxbqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;243&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;错误重尝&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.28984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUFmt15mlrujmtkdJ9v5C7POlEn6vYDdibnpR1RgannjeJiazICUY5wtCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;168&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;递归&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Template 可以递归地相互调用&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，这是一个非常实用的功能。例如在机器学习场景中：可以设定准确率必须满足一个值，否则就持续进行训练。在下面这个抛硬币例子中，我们可以持续抛硬币，直到出现正面才结束整个工作流。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.92734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUONpTNq9BFicY098ziaIO7aDWQLlVsoiavgNicCpia0MKZbb9icdPVznHiapbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;536&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;以下是两次执行的结果，第一次执行直接抛到正面，结束流程；第二次重复三次后才抛到正面，结束流程。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.65703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUPpDFCliaGUoRc5icLpiavZYCBdZLdA2nbMDMCMGFxCuIamto65ialdSkYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;380&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;退出处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;退出处理是一个指定在 workflow 结束时执行的 template，无论成功或失败。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.17734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUjGfX9SBjbM9tNNV4BJKHaMpjXUAYGXEu1ibDQfPYickpCblFnUno6vMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;103&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;对比 Tekton&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;相较于 Tekton 而言，Argo 的流程控制功能更加丰富。拥有着循环、递归等功能，这对于一些机器学习的场景都是十分适用的。而 Argo 社区对自己的定位也是 MLOps、AIOps、Data/Batch Processing，这也正是 Kubeflow Pipeline 底层基于 Argo 的原因（尽管 KFP 也在做 Tekton 的 backend）。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;但是在权限控制方面，Argo 做的就不如 Tekton，我个人认为，Tekton 的结构定义更为清晰。二者各有优劣，可以根据自己的需求进行选择。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参考文档&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Argo Roadmap：&lt;/span&gt;&lt;span&gt;https://github.com/argoproj/argo/blob/master/docs/roadmap.md&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Argo Examples：&lt;/span&gt;&lt;span&gt;https://argoproj.github.io/argo/examples/#welcome&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Argo Source Code：&lt;/span&gt;&lt;span&gt;https://github.com/argoproj/argo&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fff592b3a61b7428a6f8560c679e9139</guid>
<title>超越身边 80% 的人，其实没有你想象的那么难</title>
<link>https://toutiao.io/k/ns5biqo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.33184855233853006&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRgzIV2YTLYP1C9K6m6ZesXIGMic8cBk5es1ZicMDfULrExGEw49a51icWhlYkA1pXmib62xNNUDrMgXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;898&quot;/&gt;我是架构精进之路，点击上方“关注”，坚持每天为你分享技术干货，私信我回复“01”，送你一份程序员成长进阶大礼包。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;职场工作多年来，我观察到一些有点出乎意料的现象，例如：&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;1、很多年轻时头脑灵活、拼搏奋进的人，到了35+岁似乎也没有领先别人多少，甚至有不少人还落后了。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、而年轻时能力一般、似乎安于现状的人，到了35+岁似乎也普遍在经理、总监的位置上，甚至还有人担任了更高的职位。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;有点奇怪，到底是什么造成了这种预期之外的情况呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这其中有人归因于机遇，有人归因于心态，有人归因于没有贵人相助...&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实，接触的人多了就会发现一点：“&lt;/span&gt;&lt;span&gt;出类拔萃确实很难，但领先身边80%的人却相对简单&lt;/span&gt;&lt;span&gt;”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;只要尝试做到以下四点（甚至其中的任一点），几乎都有可能成为领先他人的那前20%&lt;/span&gt;&lt;/section&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;span&gt;&lt;strong&gt;1、多一点耐心&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;在现在这个一切都讲究快节奏的社会里，有耐心的人实在太少了。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;学习某个新技能刚没几天，就觉得见效太慢了也许就要选择放弃； &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;参加工作刚刚有半年一年没晋升加薪，就觉得受委屈了，闹着要离职；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;选择创业时在产品上没耐心打磨，成天想着怎么融一大笔钱、怎么用户裂变，幻想一夜暴富财富自由。 &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;人根本不怕悟性差，就怕没耐性。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;“只要功夫深，铁杵磨成针。” 愿意花时间去琢磨，不管怎么样，都会有进步。但是，我见到很多人，非常喜欢说自己“悟性差”、是“凡人”，明明也是喝过几年墨水的人，其实不过是对自己没有耐心罢了，舍不得继续往里钻研。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，如果你能多一点耐心，比别人多坚持一会儿，很容易就能领先这些没有耐心的人。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;记得我刚刚毕业工作那会儿，也是一个极其没有耐心的人。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;记得大学刚毕业不久，我拿到了自己心仪的Offer，一开始，我对自己也的未来也是踌躇满志。但是日常工作毕竟是繁杂的，逐渐将最初的满腔热血逐渐打磨殆尽。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在公司呆了两年后，虽然拿了部门相对而言还不错的高绩效，工资也还不错，但我却依然觉得公司的平台不足以支撑我更快成长，自己会有更好的发展，因此选择跳槽了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有人可能会反驳说 “频繁跳槽挺好的，工资都是靠跳出来的”，其实这其中的熟悉环境和浪费的时间精力，一点儿也不少。获得到的可能是部分涨薪，但损失的可能是更大的机遇和成长。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经历过没耐心的苦果后，我就告诉自己一定要有耐心，坚持长期主义，在任何一家公司都至少要呆满三年。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;有个同事的话我至今印象深刻，“&lt;/span&gt;&lt;span&gt;再牛的技术成长，都不如傻瓜式的坚持&lt;/span&gt;&lt;span&gt;”。不推崇绝对信奉，但确实有一定道理。有时候你认为自己去了更好更有前途的公司平台，殊不知遇到的新挑战新问题也是非常难以解决的。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;有了这个转变，我之后的职业生涯收获了越来越来的长期主义回报。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如，带领团队做事，从一个人单打独斗到一群人为了集体利益去拼搏是完全不一样的。当你不仅为了自己的成长负责，还要为你团队中的每一个人成长负责，你就会感觉身上的担子完全不一样。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;把自己作为产品来打磨，来运营&lt;/span&gt;&lt;span&gt;，让自己多一点耐心，你会发现不经意间就领先很多身边的人了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-height=&quot;767&quot; data-ratio=&quot;0.7497556207233627&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgTGGOckX5cbdydxbLHXhBa5iammy6OdOrlurjbHgLoYOCLWia7J5mm5Az9OuRV0lHvWzXV7Z30lnFxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1023&quot; data-width=&quot;1023&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;strong&gt;&lt;span&gt;2、少一点贪心&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;前几天周末聚会，有位朋友跟我倾诉：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“我最近很焦虑，感觉前面有很多问题要解决，有很多东西要学，焦虑反过来又让我很拖延，感觉成长很慢。那&lt;/span&gt;&lt;span&gt;我应该怎么来设定我的合适的目标和成长计划？&lt;/span&gt;&lt;span&gt;” &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个问题非常具有普遍性，可能80%以上的人都有。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实，&lt;/span&gt;&lt;span&gt;这种焦虑的根本病因在于贪心&lt;/span&gt;&lt;span&gt;。总以为自己得到的太少，往往是因为我们想要的太多。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;管理学大师德鲁克在《卓有成效的管理者》中有一段讲得特别好： &lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;有些人一事无成，而实际上他们却做得很吃力&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。原因有三：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1）他们低估了完成一件任务所需的时间。他们总以为万事顺利，却总不免有出乎意料的情况发生；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2）一般的管理者（往往也是不大有效的管理者）总喜欢赶工，而赶工的结果，总不免使进度更加落后；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3）一般的管理者喜欢同时着手几件要事，结果对每一件事，他们都无法获得足够的最少整块时间。只要任何一件事情受阻，全部事情也都会跟着受阻了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;           ——引自德鲁克《卓有成效的管理者》&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;如果我们能减少自己的贪心，像德鲁克建议的这样，一段时间只聚焦一个目标、一个关键任务的话，那么我们成功完成这个目标或关键任务的概率将大大提高。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;有些同学可能会担心：目标或计划安排得太少，是不是会导致自己缺少成就感呢？ &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;假如你减少了计划中的工作量，还是未能按时完成，那么你在计划里额外加再多任务项也没意义，反正你都不会去做完。更严重的是，当你排上这些事项，只会导致原本能做完的要事因为受到干扰而可能做不完，结果就是变得更焦虑了，最后可能什么都不愿做了（心里会想反正我也做不完）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;假如真的将任务量减少，你最终做的事也不会变少，因为你肯定有多余的时间空下来，那时再加更多的事就可以了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-height=&quot;681&quot; data-ratio=&quot;0.5675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgTGGOckX5cbdydxbLHXhBa5ia3aIgXIg4ibPmNRXMV09r6AaKKb57uy19gCPiavCfq5fdTCRpu0q344w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot; data-width=&quot;1200&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;木刻，描述一个贪婪的人会吃大量的食物&lt;/span&gt;&lt;/section&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;span&gt;&lt;strong&gt;3、多一点行动&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;这个世界上，绝大部分人失败不是因为没有思考，而是因为犹豫不决，迟迟没有行动。美国总统艾森豪威尔说过：“任何语言都是苍白的，你唯一需要的就是执行力，一个行动胜过一打计划”。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你稍微用心观察下周边的朋友和同事，你会发现坐而论道、大谈理想的人很多，但是踏踏实实动手去做的人却很少。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;子曰：“君子欲讷于言而敏于行。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;意思是：君子，说话是慢的，是迟钝的，看起来还比较木讷，但是行动很迅速。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;为什么要这样呢？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为说话是容易的，而去做事，是比较难的，难在开始的行动，也难在过程的坚持。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如 我计划锻炼身体，做减肥计划。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一但让你去干，你可能说自己条件不成熟，没有健身房；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当你有了健身房的时候，你又会找其他借口说，今天就不去了吧，明天再去。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其实说话是相当容易的，执行起来就会有些难度。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;再比如，我们大家都知道早起早睡好，但总是有部分人，天天都在说：“明天我要早起早睡”，但是每天依旧玩游戏，依旧看电视剧，很晚入睡。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;人一旦养成喜欢说，说了又不执行的习惯，就很容易变得一事无成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这就是“纸上得来终觉浅，绝知此事要躬行”的最佳写照之一。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;工作中，总有同学问我：“怎么写好述职报告呢？如何写好文章，有没有什么写作方法论？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我的最大建议就是：&lt;/span&gt;&lt;span&gt;不用管什么方法论，先去试着写写，写多了你的水平自然就提升了&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为写多了，你就不得不去琢磨内容如何布局，怎样思路别人才能更易懂、如何写才更言简意赅等等，这样写作水平自然也就高了。 但如果不去试，再厉害的方法论给你也没啥用。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，少一点空想，多一点行动，你想不领先80%的人都难，因为愿意动手去做的人实在是太少了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-height=&quot;682&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgTGGOckX5cbdydxbLHXhBa55ppENhIug2hicjC2TDEbUibZ3LtT9UTQAPo88RypzO8B9Nh13icZDDtvg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1023&quot; data-width=&quot;1023&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;span&gt;&lt;strong&gt;4、少一点娱乐&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;在现在这个全球消费主义占主流的时代里，人类社会和文化有了越来越强的娱乐化倾向。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;《美丽新世界》的作者英国作家赫胥黎曾警告过：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“在一个科技发达的时代里，造成精神毁灭的敌人更可能是一个满面笑容的人，而不是那种一眼看上去就让人心生怀疑和仇恨的人。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;让你趋之如骛的手机游戏、刷了就放不下的短视频、无脑连续剧、低俗综艺节目正是这个“满面笑容的人”。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;世界著名的媒体文化研究者尼尔·波兹曼在1985年出版的《娱乐至死》中，就因为电视文化的盛行提出过一个著名预言：&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;毁掉我们的不是我们憎恨的东西，恰恰是我们热爱的东西！&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;教育、体育、商业和任何其它公众话语的内容，都日渐以娱乐的方式出现，并成为一种文化精神，而人类无声无息地成为娱乐的附庸，毫无怨言，甚至心甘情愿，其结果是我们成了一个娱乐至死的物种。 &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;拒绝X音、X手等精神鸦片，这些除了让你提高兴奋阈值没任何用。我们活在当下最好的时代，因为你拒绝这些 “奶头乐” 就能打败80%的同龄人。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当你减少一些无谓的娱乐，体验到了一种更积极的状态时，就很后悔之前荒废了很多时间在游戏、娱乐上面。因为享受到了戒除游戏带来的好处，我后来也从来不看低俗综艺节目、不追无脑连续剧，这帮我省下了大量的时间。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在此声明一下：&lt;/span&gt;&lt;span&gt;我不反对娱乐，在合理范围内娱乐，会给我们带来精神的享受和精力的恢复。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但现在的问题是，太多的人不是娱乐不足，而是沉溺在了“泛娱乐”之中。所有这些泛娱乐的东西，利用的都是人性中贪婪、懒惰、虚荣的一面，很容易就让你上瘾，你一旦上瘾绝对是百害而无一利的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，如果你能抵制住诱惑，减少一点娱乐的话，你会发现你比80%的人都多了不少可用于学习和思考的时间。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-height=&quot;800&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgTGGOckX5cbdydxbLHXhBa5zwX7XPw1crkSTJcugSUHcz64viboa3xxF8288mMyrDkTtJEMzdyIs2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot; data-width=&quot;1200&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;也许出类拔萃很难，但领先80%的人却相对简单，真的只要投入20%的努力就能做到。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;坚持做好这四点里只要你能做到其中一点，领先80%的人几乎就是顺其自然的事。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你还有所怀疑的话，那请你挑选其中一点认真去实践上三年，你敢么？&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-height=&quot;729&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgTGGOckX5cbdydxbLHXhBa5DrxibkAxQPjAqnAsVbxMVqpHalVFUiaRUNyB7t3aFgibuToPeJUtV0Uxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-width=&quot;1200&quot; data-ratio=&quot;0.6074074074074074&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-pm-slice=&quot;1 1 []&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;作者&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;架构精进之路，专注软件架构研究，技术学习与个人成长，关注并私信我回复“01”，送你一份程序员成长进阶大礼包。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;往期热文推荐：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98311&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;395&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;395&quot; data-ratio=&quot;0.36484375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgSxEpr7AzM5lGCicdEjfuE6jaiae9Rmj1CVCg85GJKaFKuico89ZlnhGicQiciciccOiaqVibE5cmKXwO1AOuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87502&quot;&gt;&lt;p&gt;&lt;span&gt;「技术架构精进」专注架构研究，技术分享&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Thanks for reading!&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bdb2a31538b8634e2476250ddf14efd3</guid>
<title>分布式唯一 ID 解决方案：雪花算法</title>
<link>https://toutiao.io/k/eyvwks8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;code&gt;阅读大概需要3分钟&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;附源码&lt;/p&gt;

&lt;p&gt;[toc]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210112221734297.png&quot; alt=&quot;封面图&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;单体架构的服务的日子已经一去不复返了。&lt;/p&gt;

&lt;p&gt;当前系统业务和数据存储的复杂度都在提升，分布式系统是目前使用非常普遍的解决方案。&lt;/p&gt;

&lt;p&gt;全局唯一 ID 几乎是所有设计系统时都会遇到的，全局唯一 ID 在存储和检索中有至关重要的作用。&lt;/p&gt;

&lt;h2&gt;ID生成器&lt;/h2&gt;

&lt;p&gt;在应用程序中，经常需要全局唯一的ID作为数据库主键。如何生成全局唯一ID？&lt;/p&gt;

&lt;p&gt;首先，需要确定全局唯一ID是整型还是字符串？如果是字符串，那么现有的UUID就完全满足需求，不需要额外的工作。缺点是字符串作为ID占用空间大，索引效率比整型低。&lt;/p&gt;

&lt;p&gt;如果采用整型作为ID，那么首先排除掉32位int类型，因为范围太小，必须使用64位long型。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;采用整型作为ID时，如何生成自增、全局唯一且不重复的ID？&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;数据库自增&lt;/h3&gt;

&lt;p&gt;数据库自增 ID 是我们在数据量较小的系统中经常使用的，利用数据库的自增ID，从1开始，基本可以做到连续递增。Oracle可以用 &lt;code&gt;SEQUENCE&lt;/code&gt;，MySQL可以用主键的 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt;，虽然不能保证全局唯一，但每个表唯一，也基本满足需求。&lt;/p&gt;

&lt;p&gt;数据库自增ID的缺点是数据在插入前，无法获得ID。数据在插入后，获取的ID虽然是唯一的，但一定要等到事务提交后，ID才算是有效的。有些双向引用的数据，不得不插入后再做一次更新，比较麻烦。&lt;/p&gt;

&lt;p&gt;在我们开发过程中，遇到一种 主主数据库同步（简单可以理解为，同样的sql再另一台数据库再执行一次）的场景，如果使用数据库自增 ID，就会出现主键不一致、或主键冲突问题。&lt;/p&gt;

&lt;h2&gt;分布式ID生成器&lt;/h2&gt;

&lt;h3&gt;方案一：UUID&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;分布式环境不推荐使用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;uuid 是我们比较先想到的方法，在 java.util;包中就有对应方法。这是一个具有rfc标准的uuid：&lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;https://www.ietf.org/rfc/rfc4122.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;uuid 有很好的性能（本地调用），没有网络消耗。&lt;/p&gt;

&lt;p&gt;但是，uuid 不易存储（生成了字符串、存储过长、很多场景不适用）；信息不安全（基于 MAC 地址生成、可能会造成泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。
）；无法保证递增（或趋势递增）；其他博主反馈，截取前20位做唯一 ID ，在大数量（大概只有220w）情况下会有重复问题。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;UUID.randomUUID().toString()&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;方案二：snowflake(雪花算法)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;这是目前使用较多分布式ID解决方案，推荐使用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;背景 Twitter 云云就不介绍了，就是前段时间封了懂王账号的 Twitter。&lt;/p&gt;

&lt;h4&gt;算法介绍&lt;/h4&gt;

&lt;p&gt;SnowFlake算法生成id的结果是一个64bit大小的整数，它的结构如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190402101612645.png&quot; alt=&quot;snowflake-64bit&quot;/&gt;&lt;/p&gt;



&lt;p&gt;由于在 Java 中 64bit 的整数是 long 类型，所以在 Java 中 SnowFlake 算法生成的 id 就是 long 来存储的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SnowFlake可以保证&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;同一台服务器所有生成的id按时间趋势递增&lt;/li&gt;
&lt;li&gt;整个分布式系统内不会产生重复id（因为有datacenterId和workerId来做区分）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;存在的问题：
1. 机器ID（5位）和数据中心ID（5位）配置没有解决，分布式部署的时候会使用相同的配置，任然有ID重复的风险。
2. 使用的时候需要实例化对象，没有形成开箱即用的工具类。
3. 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。（这点在正常情况下是不会发生的）&lt;/p&gt;

&lt;p&gt;针对上面问题，这里提供一种解决思路，workId 使用服务器 hostName 生成，dataCenterId 使用 IP 生成，这样可以最大限度防止 10 位机器码重复，但是由于两个 ID 都不能超过 32，只能取余数，还是难免产生重复，但是实际使用中，hostName 和 IP 的配置一般连续或相近，只要不是刚好相隔 32 位，就不会有问题，况且，hostName 和 IP 同时相隔 32 的情况更加是几乎不可能的事，平时做的分布式部署，一般也不会超过 10 台容器。&lt;/p&gt;

&lt;p&gt;生产上使用docker配置一般是一次编译，然后分布式部署到不同容器，不会有不同的配置。这种情况就对上面提到的出现了不确定情况，这个在评论中会再出一篇参考文章。&lt;/p&gt;

&lt;h4&gt;源码&lt;/h4&gt;

&lt;p&gt;Java 版雪花ID生成算法&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;package com.my.blog.website.utils;

import org.apache.commons.lang3.RandomUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;

import java.net.Inet4Address;
import java.net.UnknownHostException;

/**
 * Twitter_Snowflake&amp;lt;br&amp;gt;
 * SnowFlake的结构如下(每部分用-分开):&amp;lt;br&amp;gt;
 * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &amp;lt;br&amp;gt;
 * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&amp;lt;br&amp;gt;
 * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)
 * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &amp;lt;&amp;lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&amp;lt;br&amp;gt;
 * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&amp;lt;br&amp;gt;
 * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&amp;lt;br&amp;gt;
 * 加起来刚好64位，为一个Long型。&amp;lt;br&amp;gt;
 * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。
 */
public class SnowflakeIdWorker {

    // ==============================Fields===========================================
    /** 开始时间截 (2015-01-01) */
    private final long twepoch = 1489111610226L;

    /** 机器id所占的位数 */
    private final long workerIdBits = 5L;

    /** 数据标识id所占的位数 */
    private final long dataCenterIdBits = 5L;

    /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */
    private final long maxWorkerId = -1L ^ (-1L &amp;lt;&amp;lt; workerIdBits);

    /** 支持的最大数据标识id，结果是31 */
    private final long maxDataCenterId = -1L ^ (-1L &amp;lt;&amp;lt; dataCenterIdBits);

    /** 序列在id中占的位数 */
    private final long sequenceBits = 12L;

    /** 机器ID向左移12位 */
    private final long workerIdShift = sequenceBits;

    /** 数据标识id向左移17位(12+5) */
    private final long dataCenterIdShift = sequenceBits + workerIdBits;

    /** 时间截向左移22位(5+5+12) */
    private final long timestampLeftShift = sequenceBits + workerIdBits + dataCenterIdBits;

    /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */
    private final long sequenceMask = -1L ^ (-1L &amp;lt;&amp;lt; sequenceBits);

    /** 工作机器ID(0~31) */
    private long workerId;

    /** 数据中心ID(0~31) */
    private long dataCenterId;

    /** 毫秒内序列(0~4095) */
    private long sequence = 0L;

    /** 上次生成ID的时间截 */
    private long lastTimestamp = -1L;

    private static SnowflakeIdWorker idWorker;

    static {
        idWorker = new SnowflakeIdWorker(getWorkId(),getDataCenterId());
    }

    //==============================Constructors=====================================
    /**
     * 构造函数
     * @param workerId 工作ID (0~31)
     * @param dataCenterId 数据中心ID (0~31)
     */
    public SnowflakeIdWorker(long workerId, long dataCenterId) {
        if (workerId &amp;gt; maxWorkerId || workerId &amp;lt; 0) {
            throw new IllegalArgumentException(String.format(&quot;workerId can&#x27;t be greater than %d or less than 0&quot;, maxWorkerId));
        }
        if (dataCenterId &amp;gt; maxDataCenterId || dataCenterId &amp;lt; 0) {
            throw new IllegalArgumentException(String.format(&quot;dataCenterId can&#x27;t be greater than %d or less than 0&quot;, maxDataCenterId));
        }
        this.workerId = workerId;
        this.dataCenterId = dataCenterId;
    }

    // ==============================Methods==========================================
    /**
     * 获得下一个ID (该方法是线程安全的)
     * @return SnowflakeId
     */
    public synchronized long nextId() {
        long timestamp = timeGen();

        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常
        if (timestamp &amp;lt; lastTimestamp) {
            throw new RuntimeException(
                    String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));
        }

        //如果是同一时间生成的，则进行毫秒内序列
        if (lastTimestamp == timestamp) {
            sequence = (sequence + 1) &amp;amp; sequenceMask;
            //毫秒内序列溢出
            if (sequence == 0) {
                //阻塞到下一个毫秒,获得新的时间戳
                timestamp = tilNextMillis(lastTimestamp);
            }
        }
        //时间戳改变，毫秒内序列重置
        else {
            sequence = 0L;
        }

        //上次生成ID的时间截
        lastTimestamp = timestamp;

        //移位并通过或运算拼到一起组成64位的ID
        return ((timestamp - twepoch) &amp;lt;&amp;lt; timestampLeftShift)
                | (dataCenterId &amp;lt;&amp;lt; dataCenterIdShift)
                | (workerId &amp;lt;&amp;lt; workerIdShift)
                | sequence;
    }

    /**
     * 阻塞到下一个毫秒，直到获得新的时间戳
     * @param lastTimestamp 上次生成ID的时间截
     * @return 当前时间戳
     */
    protected long tilNextMillis(long lastTimestamp) {
        long timestamp = timeGen();
        while (timestamp &amp;lt;= lastTimestamp) {
            timestamp = timeGen();
        }
        return timestamp;
    }

    /**
     * 返回以毫秒为单位的当前时间
     * @return 当前时间(毫秒)
     */
    protected long timeGen() {
        return System.currentTimeMillis();
    }

    private static Long getWorkId(){
        try {
            String hostAddress = Inet4Address.getLocalHost().getHostAddress();
            int[] ints = StringUtils.toCodePoints(hostAddress);
            int sums = 0;
            for(int b : ints){
                sums += b;
            }
            return (long)(sums % 32);
        } catch (UnknownHostException e) {
            // 如果获取失败，则使用随机数备用
            return RandomUtils.nextLong(0,31);
        }
    }

    private static Long getDataCenterId(){
        int[] ints = StringUtils.toCodePoints(SystemUtils.getHostName());
        int sums = 0;
        for (int i: ints) {
            sums += i;
        }
        return (long)(sums % 32);
    }


    /**
     * 静态工具类
     *
     * @return
     */
    public static synchronized Long generateId(){
        long id = idWorker.nextId();
        return id;
    }

    //==============================Test=============================================
    /** 测试 */
    public static void main(String[] args) {
        System.out.println(System.currentTimeMillis());
        long startTime = System.nanoTime();
        for (int i = 0; i &amp;lt; 50000; i++) {
            long id = SnowflakeIdWorker.generateId();
            System.out.println(id);
        }
        System.out.println((System.nanoTime()-startTime)/1000000+&quot;ms&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考原文：&lt;a href=&quot;https://blog.csdn.net/xiaopeng9275/article/details/72123709&quot;&gt;https://blog.csdn.net/xiaopeng9275/article/details/72123709&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;分享和在看是对我最大的鼓励。我是pub哥，我们下期见!&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c2a765028f04a00b2629d05b7192d285</guid>
<title>分布式文件系统架构对比</title>
<link>https://toutiao.io/k/xcmrxkd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.15850340136054422&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1470&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/F446RY3QsZnKPwvd2FlmZQDIZ67BgWV4PVxO01CPHjJqqOlwPs1xNO9vasibyoGQcmicXibu7k5Cr9FGVMBdSbU7Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;什么是文件系统？&lt;/strong&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;文件&lt;/span&gt;&lt;span&gt;系&lt;/span&gt;&lt;span&gt;统是计算机中一个&lt;/span&gt;&lt;span&gt;非常重要的组&lt;/span&gt;&lt;span&gt;件，为存储设备提供一致的访问和管理方式。&lt;/span&gt;&lt;span&gt;在不同的操作系统中，文件系统会有一些差别，但也有一些共性几十年都没怎么变化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据是以文件的形式存在，提供 Open、Read、Write、Seek、Close 等API 进行访问；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;文件以树形目录进行组织，提供原子的重命名（Rename）操作改变文件或者目录的位置。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;文件系统提供的访问和管理方法支撑了绝大部分的计算机应用，Unix 的“万物皆文件”的理念更是凸显了它的重要地位。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;文件系统的复杂性使得它的可扩展性未能跟得上互联网的高速发展，极大简化了的对象存储及时填补了空缺得以快速发展起来。因为对象存储缺乏树状结构也不支持原子重命名操作，跟文件系统有很大的差别，本文暂不讨论。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;单机文件系统的挑战&lt;/strong&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;绝大多数文件系统都是单机的，在单机操作系统内为一个或者多个存储设备提供访问和管理。随着互联网的高速发展，单机文件系统面临很多的挑战：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;共享：无法同时为分布在多个机器中的应用提供访问，于是有了 NFS 协议，可以将单机文件系统通过网络的方式同时提供给多个机器访问。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;容量：无法提供足够空间来存储数据，数据只好分散在多个隔离的单机文件系统里。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;性能：无法满足某些应用需要非常高的读写性能要求，应用只好做逻辑拆分同时读写多个文件系统。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可靠性：受限于单个机器的可靠性，机器故障可能导致数据丢失。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可用性：受限于单个操作系统的可用性，故障或者重启等运维操作会导致不可用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;随着互联网的高速发展，这些问题变得日益突出，涌现出了一些分布式文件系统来应对这些挑战。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;下面介绍几个我了解过的分布式文件系统的基本架构，并比较不同架构的优点和局限。&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;GlusterFS&lt;/strong&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;GlusterFS 是由美国的 Gluster 公司开发的 POSIX 分布式文件系统（以 GPL 开源），2007年发布第一个公开版本，2011年被 Redhat 收购。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的基本思路就是通过一个无状态的中间件把多个单机文件系统融合成统一的名字空间（namespace）提供给用户。这个中间件是由一系列可叠加的转换器（Translator）实现，每个转换器解决一个问题，比如数据分布、复制、拆分、缓存、锁等等，用户可以根据具体的应用场景需要灵活配置。比如一个典型的分布式卷如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6060606060606061&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/F446RY3QsZlIdqnvdCASlP2Ok5OwQpsOlSR0fRnzTibibSFaxolpVDegBPNT6Tc6wibNjKAAd2GicqtOicaicL9MNzmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;660&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;图片来源：&lt;/small&gt;&lt;small&gt;https://docs.gluster.org/en/latest/Quick-Start-Guide/Architecture/&lt;/small&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Server1 和 Server2 构成有 2 副本的 Volume0，Server3 和 Server4 构成 Volume1，它们再融合成有更大空间的分布式卷。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据文件最终以相同的目录结构保存在单机文件系统上，不用担心 GlusterFS 的不可用导致数据丢失。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;没有明显的单点问题，可线性扩展。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对大量小文件的支持估计还不错。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2&gt;&lt;span&gt;挑战：&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这种结构是相对静态的，不容易调整，也要求各个存储节点有相同的配置，当数据或者访问不均衡时没法进行空间或者负载调整。故障恢复能力也比较弱，比如 Server1 故障时，Server2 上的文件就没办法在健康的 3 或者 4上增加拷贝保障数据可靠。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;因为缺乏独立的元数据服务，要求所有存储节点都会有完整的数据目录结构，遍历目录或者做目录结构调整时需要访问所有节点才能得到正确结果，导致整个系统的可扩展能力有限，扩展到几十个节点时还行，很难有效地管理上百个节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt; &lt;strong mpa-from-tpl=&quot;t&quot;&gt;CephFS&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;CephFS 始于 Sage Weil 的博士论文研究，目标是实现分布式的元数据管理以支持 EB 级别数据规模。2012年，Sage Weil 成立了 InkTank 继续支持 CephFS 的开发，于 2014年被 Redhat 收购。直到 2016 年，CephFS 才发布可用于生产环境的稳定版（CephFS 的元数据部分仍然是单机的）。现在，CephFS 的分布式元数据仍然不成熟。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ceph 是一个分层的架构，底层是一个基于 CRUSH（哈希）的分布式对象存储，上层提供对象存储（RADOSGW）、块存储（RDB）和文件系统（CephFS）三个API，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7063492063492064&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/F446RY3QsZlIdqnvdCASlP2Ok5OwQpsOzkxpXeJrmknzibGiaenxt3L8OyIwsAVAXRgamMyBccYl17qyia2PcoP9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;图片来源：&lt;/small&gt;&lt;small&gt;https://en.wikipedia.org/wiki/Ceph_(software)&lt;/small&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用一套存储系统来满足多个不同场景的存储需求（虚拟机镜像、海量小文件和通用文件存储）还是非常吸引人的，但因为系统的复杂性需要很强的运维能力才能支撑，实际上目前只有块存储还是比较成熟应用得比较多，对象存储和文件系统都不太理想，听到一些使用案例用过一段时间后就放弃了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CephFS 的架构如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/F446RY3QsZlIdqnvdCASlP2Ok5OwQpsOQmdzDmTcjAD2wPsYxEUL8ecTNOBOC0gPg14LNb3mlXSXy1iaIKjHDLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;图片来源：&lt;/small&gt;&lt;small&gt;https://en.wikipedia.org/wiki/Ceph_(software)&lt;/small&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CephFS 是由 MDS（Metadata Daemon) 实现的，它是一个或者多个无状态的元数据服务，从底层的 OSD 加载文件系统的元信息，并缓存到内存中以提高访问速度。因为 MDS 是无状态的，可以配置多个备用节点来实现 HA，相对比较容易。不过备份节点没有缓存，需要重新预热，有可能故障恢复时间会比较长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为从存储层加载或者写入数据会比较慢，MDS 必须使用多线程来提高吞吐量，各种并发的文件系统操作导致复杂度大大上升，容易发生死锁，或者因为 IO 比较慢导致的性能大幅下降。为了获得比较好的性能，MDS 往往需要有足够多的内存来缓存大部分元数据，这也限制了它实际的支撑能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当有多个活跃的 MDS 时，目录结构中的一部分（子树）可以动态的分配到某个MDS并完全由它来处理相关请求，以达到水平扩展的目的。多个活跃之前，不可避免地需要各自锁机制来协商对子树的所有权，以及通过分布式事务来实现跨子树的原子重命名，这些实现起来都是非常复杂的。目前最新的官方文档仍然不推荐使用多个 MDS（作为备份是可以的）。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;GFS&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Google 的 GFS 是分布式文件系统中的先驱和典型代表，由早期的 BigFiles 发展而来。在 2003 年发表的论文中详细阐述了它的设计理念和细节，对业界影响非常大，后来很多分布式文件系统都是参照它的设计。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;顾名思义，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;BigFiles/GFS 是为大文件优化设计的，并不适合平均文件大小在 1MB 以内的场景。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;GFS的架构入下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5933333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/F446RY3QsZlIdqnvdCASlP2Ok5OwQpsOmHaiaCdVbH2WDhOnwWQBV3YeBsXVCNZ493ec9icjqaT6zhGFaNyHiagug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;450&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;图片来源：&lt;/small&gt;&lt;small&gt;https://en.wikipedia.org/wiki/Google_File_System&lt;/small&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GFS 有一个 Master 节点来管理元数据（全部加载到内存，快照和更新日志写到磁盘），文件划分成 64MB 的 Chunk 存储到几个 ChunkServer 上（直接使用单机文件系统）。文件只能追加写，不用担心 Chunk 的版本和一致性问题（可以用长度当做版本）。这个使用完全不同的技术来解决元数据和数据的设计使得系统的复杂度大大简化，也有足够的扩展能力（如果平均文件大小大于 256MB，Master 节点每 GB 内存可以支撑约 1PB 的数据量）。放弃支持 POSIX 文件系统的部分功能（比如随机写、扩展属性、硬链接等）也进一步简化了系统复杂度，以换取更好的系统性能、鲁棒性和可扩展性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为 GFS 的成熟稳定，使得 Google 可以更容易地构建上层应用（MapReduce、BigTable等）。后来，Google 开发了拥有更强可扩展能力的下一代存储系统 Colossus，把元数据和数据存储彻底分离，实现了元数据的分布式（自动 Sharding），以及使用Reed Solomon 编码来降低存储空间占用从而降低成本。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;HDFS&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;出自 Yahoo 的 Hadoop 算是 Google 的 GFS、MapReduce 等的开源Java实现版，HDFS 也是基本照搬 GFS 的设计，这里就不再重复了，下图是HDFS的架构图：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7408854166666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/F446RY3QsZlIdqnvdCASlP2Ok5OwQpsODUvZx31FAJqkdTtNxwXC9kjT71KT5rvwJEzz7gtsuGy5wg0IqePdQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;HDFS的可靠性和可扩展能力还是非常不错的，有不少几千节点和 100PB 级别的部署，支撑大数据应用表现还是很不错的，少有听说丢数据的案例（因为没有配置回收站导致数据被误删的除外）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;HDFS 的 HA 方案是后来补上的，做得比较复杂，以至于最早做这个 HA 方案的 Facebook 在很长一段时间（至少 3 年）内都是手动做故障切换（不信任自动故障切换）。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为 NameNode 是 Java 实现的，依赖于预先分配的堆内存大小，分配不足容易触发 Full GC 而影响整个系统的性能。有一些团队尝试把它用 C++ 重写了，但还没看到有成熟的开源方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;HDFS 也缺乏成熟的非 Java 客户端，使得大数据（Hadoop等工具）以外的场景（比如深度学习等）使用起来不太方便。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;MooseFS&lt;/strong&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;MooseFS 是来自波兰的开源分布式 POSIX 文件系统，也是参照了 GFS 的架构，实现了绝大部分 POSIX 语义和 API，通过一个非常成熟的 FUSE 客户端挂载后可以像本地文件系统一样访问。MooseFS 的架构如下图所示：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7057291666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/F446RY3QsZlIdqnvdCASlP2Ok5OwQpsOKdKTDkWqokzNddV4la3mT5fCoCfLuqiaMzKnOvGaHp7JbqaGI5SdicUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MooseFS 支持快照，用它来做数据备份或者备份恢复等还是恢复方便的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MooseFS 是由 C 实现的，Master 是个异步事件驱动的单线程，类似于 Redis。不过网络部分使用的是 poll 而不是更高效的 epoll，导致并发到 1000 左右时 CPU 消耗非常厉害。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开源的社区版没有HA，是通过 metalogger 来实现异步冷备，闭源的收费版有 HA。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了支持随机写操作，MooseFS 中的 chunk 是可以修改的，通过一套版本管理机制来保证数据一致性，这个机制比较复杂容易出现诡异问题（比如集群重启后可能会有少数 chunk 实际副本数低于预期）。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;JuiceFS&lt;/strong&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上面说的 GFS、HDFS 和 MooseFS 都是针对自建机房这种软硬件环境设计的，将数据的可靠性和节点可用性合在一起用多机多副本的方式解决。但是在公有云或者私有云的虚拟机里，块设备已经是具有三副本可靠性设计的虚拟块设备，如果再通过多机多副本的方式来做，会导致数据的成本居高不下（实际上是 9 个拷贝）。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是我们针对公有云，改进 HDFS 和 MooseFS 的架构，设计了 JuiceFS，架构如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7356770833333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/F446RY3QsZlIdqnvdCASlP2Ok5OwQpsOkaic0PFzGM6W55EL30QJ0o56ZoPuIU7YyIiaYhKsFAYIJXqc3YCYMqgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JuiceFS 使用公有云中已有的对象存储来替换 DataNode 和 ChunkServer，实现一个完全弹性的 Serverless 的存储系统。公有云的对象存储已经很好地解决了大规模数据的安全高效存储，JuiceFS 只需要专注元数据的管理，也大大降低了元数据服务的复杂度（GFS 和 MooseFS 的 master 要同时解决元数据的存储和数据块的健康管理）。我们也对元数据部分做了很多改进，从一开始就实现了基于 Raft 的高可用。要真正提供一个高可用高性能的服务，元数据的管理和运维仍然是很有挑战的，元数据是以服务的形式提供给用户。因为 POSIX 文件系统 API 是应用最最广泛的 API，我们基于 FUSE 实现了高度 POSIX 兼容的客户端，用户可以通过一个命令行工具把 JuiceFS 挂载到 Linux 或者 macOS 中，像本地文件系统一样快速访问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图中右边虚线部分是负责数据存储和访问的部分，涉及用户的数据隐私，它们是完全在客户自己的账号和网络环境中，不会跟元数据服务接触。我们（Juicedata）没有任何方法接触到客户的内容（元数据除外，请不要把敏感内容放到文件名里）。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;小结&lt;/strong&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;简要介绍了下我所了解的几个分布式文件系统的架构，把他们按照出现的时间顺序放在下面的图里（箭头表示后参考了前者或者是新一代版本）：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.681592039800995&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/F446RY3QsZlIdqnvdCASlP2Ok5OwQpsO04Te7VBkHAJ62qefRJrVDsevTQlEM03ogr8lnr67aUviaP65UfUTlUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;603&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图中上部分蓝色的几个文件下主要是给大数据场景使用的，实现的是 POSIX 的子集，而下面绿色的几个是 POSIX 兼容的文件系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他们中以 GFS 为代表的元数据和数据分离的系统设计能够有效平衡系统的复杂度，有效解决大规模数据的存储问题（通常也都是大文件），有更好的可扩展性。这个架构下支持元数据的分布式存储的 Colossus 和 WarmStorage 更是具有无限的可扩展能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;JuiceFS 作为后来者，学习了 MooseFS 实现分布式 POSIX 文件系统的方式，也学习了 Facebook 的 WarmStorage 等元数据和数据彻底分开的思路，希望为公有云或者私有云等场景下提供最好的分布式存储体验。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;JuiceFS 通过将数据存储到对象存储的方式，有效避免了使用以上分布式文件系统时的双层冗余（块存储的冗余和分布式系统的多机冗余）导致的成本过高问题。JuiceFS 还支持所有的公有云，不用担心某个云服务锁定，还能平滑地在公有云或者区之间迁移数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，如果你手上有公有云账号，来 JuiceFS 注册一下，5 分钟就可以给你的虚拟机或者自己的 Mac &lt;span&gt;上&lt;/span&gt;挂载一个 PB 级容量的文件系统了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- End -&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-id=&quot;93640&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;往期阅读&lt;/span&gt;&lt;/section&gt;&lt;section data-bgless=&quot;spin&quot; data-bglessp=&quot;80&quot; data-bgopacity=&quot;50%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg5MjUyNjExMw==&amp;amp;mid=2247484563&amp;amp;idx=1&amp;amp;sn=9e295996afae83e8031bb24ffdf107f7&amp;amp;chksm=c03d8fddf74a06cb2daf308bd5a44398da65e6298da9ad3408f939d0ba9520521361a56eb9ba&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;巧用符号链接迁移 HDFS 数据，业务完全无感知！&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg5MjUyNjExMw==&amp;amp;mid=2247484530&amp;amp;idx=1&amp;amp;sn=d840512b948037bec45fd89cf8418677&amp;amp;chksm=c03d8f3cf74a062ab547f44a8a5bd26ccfebd91c5009098c0d6b9b50a5ae27442c3d8a17d55d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;跨云数据搬迁利器：Juicesync&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg5MjUyNjExMw==&amp;amp;mid=2247484486&amp;amp;idx=1&amp;amp;sn=13b65d505e1b5d4e4d385feec4212979&amp;amp;chksm=c03d8f08f74a061e7563f9a26d83e742da0cf7c2be4bdc1bb5e1c04d4f81287d2a0b7f6c731c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;如何使用 JuiceFS 在云上优化 Kylin 4.0 的存储性能？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg5MjUyNjExMw==&amp;amp;mid=2247483785&amp;amp;idx=1&amp;amp;sn=058e055ad9883cc55981ef7985595505&amp;amp;chksm=c03d8ac7f74a03d1319780d881c6e02c5ac42883f65c89ebf729529feeb5371c886ff109e4b8&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;环球易购数据平台如何做到既提速又省钱？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg5MjUyNjExMw==&amp;amp;mid=2247483786&amp;amp;idx=1&amp;amp;sn=03e93207369fdd66f426db9b6794f1fa&amp;amp;chksm=c03d8ac4f74a03d2d101af6980b7ef81894a5225476bebb255126d5ad2568bb1114daccd98e9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;如何把 MySQL 备份验证性能提升10倍&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;193&quot; data-ratio=&quot;0.3333333333333333&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/F446RY3QsZnKPwvd2FlmZQDIZ67BgWV4kIibIUPicfFjdP3XbjrvMllCvSlSic54iccpBDUIWe5aEVWibWOw7iahBoxw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/6aVaON9Kibf5ibKRPQgZ9XgbVNsIeQUnfKSiaErmr8dtdicicS3A8m6TiavR6ZB0Eah3pD0kjQg8ACyNb1x5ibdqRg2jA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;点击&lt;strong&gt;阅读原文&lt;/strong&gt;，访问官网！&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>