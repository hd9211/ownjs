<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>66d23ff5dc9c906f152d4bc2846130db</guid>
<title>[推荐] 这几款 JVM 故障诊断处理工具你还不会？</title>
<link>https://toutiao.io/k/dux0ogl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几天中午正在和同事最近聊股市较好，这几天每天都可以喝点肉汤，心里还是挺高兴的；正在这个时候收到了线上告警邮件和运维同学的消息，“你们有服务挂了！”，心里一紧，立马打开电脑看来下线上cat监控大盘，发现很多服务都在报错，根据cat上的监控日志很快发现了其中一个服务内存溢出导致其他调用服务也有问题，竟然已经定位到了出问题的服务，那就简单了，没有是重启解决不了的问题，重启之后很快服务都恢复正常了。几分钟之后又报错了，同样也是这个服务内存溢出，经过排查后发现该服务的堆内存被改小了，好家伙，运维同学不讲武德，搞偷袭，趁我没反应过来调了内存，内存调整回去之后服务就恢复了正常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事后把线上的快照文件拖了下来分析，发现本身这个项目的代码也有些问题，本文就整理了一下JVM常用的分析工具。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;命令行工具&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在安装完JDK之后在JAVA_HOME/bin目录下JDK已经提供了很多命令行的工具&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.06375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3L6TRz9Y0UdvzxE2DGJosqxbc4qu9pJCWZejq6WtqCssK83AEK3UMrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能我们最常用的就是&lt;code&gt;java&lt;/code&gt;、&lt;code&gt;javac&lt;/code&gt;这两个命令，除了这两个命令之外还有提供很多其他的实用工具，本文主要来一起学习对JVM监控诊断工具&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;虚拟机进程状况工具（jps）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该工具的功能比较单一，与linux中的ps功能类似，用来列出正在运行的虚拟机进程，并显示出运行的主类和进程号&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jps [option] [hostid]&lt;/code&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;如果需要查看远程机器的jvm进程需要填写&lt;code&gt;hostid&lt;/code&gt;，并且需要使用RMI，比如：&lt;code&gt;rmi://192.168.2.128:12345&lt;/code&gt;&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-q&lt;/code&gt; : 只显示出虚拟机的进程id（lvmid），省略主类名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-m&lt;/code&gt; : 输出启动时传递给主类的参数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-l&lt;/code&gt; : 显示出主类的全名，包括jar包路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-v&lt;/code&gt; : 输出虚拟机进程启动时的JVM参数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23290203327171904&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3zIQRpQAtZibR8uPLX3MU1OoibCvIQQZLFLia31ermSkeW8icYvYdPLLPnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;虚拟机统计信息监控工具（jstat）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于监控虚拟机运行状态信息的命令行工具，可以提供内存，垃圾收集等运行时的数据&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jstat [option vmid] [interval [s|ms] [count]]&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;interval表示间隔多久时间查询一次，count表示查询多少次，比如：每个两秒查询一次进程52412的垃圾收集情况，共查询5次&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jstat -gc 52412 2s 5&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.10375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3OObJnsw4ho5Gam75mB4vIA1kMeuFBLmdoHYajmf15ibYh1iaPz1GkZxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-class&lt;/code&gt;: 监控类装载，卸载次数和总空间以及加载类的耗时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gc&lt;/code&gt;: 监控java堆的情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gcutil&lt;/code&gt;: 主要输出各个空间使用的百分比&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gcnew&lt;/code&gt;: 主要是监控新生代的GC状况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gcold&lt;/code&gt;: 监控老年代的GC状况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-compiler&lt;/code&gt;: 输出JIT编译器编译过的方法和耗时信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看堆空间的使用百分比: &lt;code&gt;jstat -gcutil 52412 2s 5&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16973684210526316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN39ticu2fcOAGShUKaqFQzmIfZtLAgGceHoruTjg6AOZibahyoIT9bwPJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;java配置信息工具（jinfo）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过&lt;code&gt;jinfo&lt;/code&gt;实时的查看和调整虚拟机的各项参数；可以通过&lt;code&gt;jps -v&lt;/code&gt;查看虚拟机启动时候指定的参数信息，如果需要查看未显示指定的参数默认值也可以通过&lt;code&gt;jinfo -flag&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jinfo -flag CMSInitiatingOccupancyFraction 52412&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3HcQOFibOt6HbrdaIeRvEVMhicicPAfgichnqbgRCQSAjQes4J6ZtURl3Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jinfo除了可以查看参数以外，还可以在运行时修改一些允许被修改的参数&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Java内存映像工具（jmap）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jmap用于生成JVM堆的快照文件，除了使用jmap工具，我们通常也会在配置JVM的启动参数 &lt;code&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/code&gt; 让JVM在发送内存溢出之后自动生成dump文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jmap [option] vmid&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如生成java堆的快照文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jmap -dump:live,format=b,file=/Users/huaan9527/Desktop/heap.hprof 59950&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-F&lt;/code&gt;: 当虚拟机对-dump选项没有响应时可用选择使用这个参数强制生成快照&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-histo&lt;/code&gt;: 显示出堆中对象统计信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;堆栈跟踪工具（jstack）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于生成JVM当前线程的快照信息。通常用于查询什么原因导致线程长时间的停顿，比如：线程死循环，死锁，等待网络/IO&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jstack [option] vmid&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-F&lt;/code&gt;: 当请求不被响应时强制输出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-l&lt;/code&gt;: 除了显示堆栈外，还需要显示锁的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-m&lt;/code&gt;: 如果调用到本地方法，显示出C/C++的堆栈&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;VisualVM 可视化工具&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VisualVM是目前JDK自带的功能最强的运行监视和故障处理程序，在VisualVM之前，JDK也提供了一款可视化工具JConsole，由于JConsole的所有功能在VisualVM都有，所以可视化工具大家几乎都选择使用VisualVM。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VisualVM本身是基于Netbean开发的，所以具备了插件扩展功能，安装插件之后上面介绍的所有命令行的工具的功能都可以在VisualVM中使用。可以在在JAVA_HOME/bin目录下执行&lt;code&gt;jvisualvm&lt;/code&gt;启动。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;插件安装
默认情况VisualVM提供的功能很少，需要我们在菜单栏-&amp;gt;工具-&amp;gt;插件里面安装插件，我这是全部插件都安装了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.59875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3QGVcxoRL0D1EaoyiaI5tEqpBEGL0yXhmHe2NfcKJtyvic20C2RRhJP1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;功能演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46981627296587924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3UEXOHP6iauXffDAODBG85QP4PqKosiajOGz9GVXUib8x6c9HDJed2DxVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;762&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显示出当前本机所有的JVM进程，这里显示的内容和前面说的命令行&lt;code&gt;jps&lt;/code&gt;显示的内容一样&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3ZZs5Y4qialznXKtKIj1MibSTrqWycDS8UYoiaadvzqXOn2IR9DOiaWc0Ww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前虚拟机启动信息的展示，比如：JVM启动参数、系统参数&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.66&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3IuCCtJENo62LdUe0eVNAlVESYFVCQGKQjJib0TPxwcpWVLIuuCj6ia8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个页面相当于命令jstat的功能，显示出了CPU, 内存，线程，类装载当前处于什么情况&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成dump文件可以在应用程序窗口右键菜单中选择，也可以在这个页面点击右上角的&lt;code&gt;堆dump&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Visual GC
此页主要展示了GC相关的信息，这是在性能调优时常用的页面之一&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3uMn8Ciaga5rTDzRsjfjMa36O6GGgez4Cuj1EozA2VjwHnEiczK8EfxjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以写个程序来观看下这个截图各个内存区域的变化情况，为了让图的效果明显需要修改JVM的启动参数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-Xmx100m -Xms100m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/Users/huaan9527/Desktop&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) {&lt;br/&gt;    List&amp;lt;DataTest&amp;gt; datas = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    IntStream.range(0, 10000).forEach(index -&amp;gt; {&lt;br/&gt;        datas.add(new DataTest());&lt;br/&gt;&lt;br/&gt;        try {&lt;br/&gt;            Thread.sleep(50);&lt;br/&gt;        } catch (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    System.gc();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;static class DataTest {&lt;br/&gt;    byte[] bytes = new byte[1024];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5325&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3TJRzV0hnQgqJyXvS7icdAw8Rdh0wDAeaY3evvibsq9kEloJF3VNYLxOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程
本页的功能相当于命令行工具&lt;code&gt;jstack&lt;/code&gt;，主要是用于检查什么原因导致线程长时间等待，我们写程序来演示下等待外部资源、锁等待、死循环这几种请求&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「等待外部资源」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) throws IOException {&lt;br/&gt;    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));&lt;br/&gt;    System.out.println(reader.readLine());&lt;br/&gt;    try {&lt;br/&gt;        Thread.sleep(1000000);&lt;br/&gt;    } catch (InterruptedException e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选中main线程，右侧会看到当前线程运行到了readBytes，等待键盘输入&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN30YP4cEJicbw4ibpa7HpHV68d8qiaExhstP9l0eMdQmrltjZJrwS7Is9JQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在控制台输入之后再次查看main线程的状态，此时进入了TIME_WAIT状态&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3vF9IMG5fFrYAq5GkB0ta3yLZlHrm7ccRfCqU7VDHEz9hRVQJLsZKMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「锁等待」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) throws IOException, InterruptedException {&lt;br/&gt;    Thread thread = createLockThread(new Object());&lt;br/&gt;    thread.join();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public static Thread createLockThread(final Object lock) {&lt;br/&gt;    Thread lockThread = new Thread(() -&amp;gt; {&lt;br/&gt;        synchronized (lock) {&lt;br/&gt;            try {&lt;br/&gt;                lock.wait();&lt;br/&gt;            } catch (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }, &lt;span&gt;&quot;lockThread&quot;&lt;/span&gt;);&lt;br/&gt;    lockThread.start();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; lockThread;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3TktpB0w3QcrBiadrLic8Jz2wErvo24dZRtXCCNc9os2CQJJrESuofvfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lockThread线程在等待lock对象的notify方法被调用，此时处于WAITING状态，在被唤醒之前是不会再分配执行时间&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「死循环」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) throws IOException, InterruptedException {&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.25625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3LDibRDrJ6XM9pYXlHdpupiauyXORbYfdsDOsDzuACnEia4uURESibn4aWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程一直处于运行状态，从堆栈追踪里可以看出代码一直停留在了191行，在空循环上用尽分配的执行时间&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇介绍了命令行工具和可视化工具，下篇实战演示下如何通过这些工具对&lt;strong&gt;「Idea运行速度调优」&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写到最后&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中或许会存在或多或少的不足、错误之处，有建议或者意见也非常欢迎大家给我留言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，&lt;strong&gt;「白嫖不好，创作不易」&lt;/strong&gt;，希望朋友们可以&lt;strong&gt;「点赞」&lt;/strong&gt;，因为这些就是我分享的全部动力来源🙏&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>77468a6042677575b66f7843d3c67836</guid>
<title>[推荐] 21 大软件架构特点的全面解析</title>
<link>https://toutiao.io/k/2n0entj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;作者 | sergiuoltean&lt;/section&gt;&lt;section&gt;策划 | 万佳&lt;/section&gt;&lt;p&gt;众所周知，架构特点多以&quot;ility&quot;结尾（例如 scalability、deployability），也被称为 NFR（非功能需求）、质量属性。架构的特点没有固定清单，但标准是有的，就是 ISO25010：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.28203125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqVFrDFzHyB9k3US7k8UdllGNpeuibRBMD0f4C6UbOe1k2Qw9hmzNQa9Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们从业务需求（业务特征）、我们期望的系统运营方式（运营特征）中总结出这些特点，它们是隐式的、贯穿各领域，是架构师在字里行间能看出来的特点。《软件架构基础》书中的这张表是隐藏特点的一个例子。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.24406224406224405&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1221&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqiaO89N3PN3Quvvn5oz6zDXIZTD4ZhyXibWHoMibiauodxZ2yzzdVF5IiaVg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;《实践中的软件架构》一书中对架构特点解释得很清楚。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4306640625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erq6zECHjPicDPLxm41ZeTiaI08emicaFDcofcYTlNBLibMlgPflviawQ16K3g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;刺激的来源（Source of Stiumulus）可以是角色、触发事件的东西等。刺激（Stimulus）是实际产生的事件。环境（Environment）代表事件发生的系统条件。工件（Artifact）是系统中正在被刺激的部分。响应（Response）就是工件在我们应该度量（measure）的刺激下的行为方式。背景了解完毕，让我们来看具体的特点。&lt;/p&gt;&lt;section&gt;&lt;span&gt;1&lt;/span&gt;性能&lt;/section&gt;&lt;p&gt;根据 Smith 所说，“性能是指响应能力：响应特定事件所需的时间，或给定时间间隔内处理的事件数”。性能可以有以下指标：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;延迟&lt;/strong&gt; 。表示获得响应之前经过的时间，这里指的是一段时间。我们有最小延迟（开始时间）和 &lt;strong&gt;截止日期&lt;/strong&gt; （结束时间）。衡量延迟的其他因素包括 &lt;strong&gt;优先级&lt;/strong&gt;（我们在其中查看响应的顺序）和 &lt;strong&gt;抖动&lt;/strong&gt; （随时间观察到的延迟波动）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;。是指在固定时间间隔内获得的响应数。但为了提高精度，我们应该度量多个时间间隔。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可用容量&lt;/strong&gt;。以上度量的结合体。在不超出延迟要求的情况下可实现的最大吞吐量。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可调度的利用率&lt;/strong&gt;。利用率是资源繁忙时间的百分比，而可调度的利用率是满足一定时间要求的最大利用率。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;数据丢失&lt;/strong&gt;。如果使用缓存来提高性能，那么缓存未命中将成为性能指标。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt; 提高性能的技术&lt;/section&gt;&lt;p&gt;首先我们要了解影响性能的因素。&lt;/p&gt;&lt;p&gt;我们需要控制需求，为此我们可以使用队列、节流和背压机制。通过改进算法，我们可以减少资源需求。通过设置最大响应时间（超时）和某种优先级，我们可以进一步控制需求。&lt;/p&gt;&lt;p&gt;可以使用垂直缩放来获得更好的响应时间。提高性能的另一种方法是并发。还需要注意阿姆达尔定律。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7503105590062111&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;805&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqkHkGgQ2nGKvvCoiaTV5nlOb4ltrOxItm0MqrEjIVqCAwChaEtpcRV6Q/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加速效果的瓶颈是程序的串行部分。例如，如果 95％的代码可以并行化，则并行计算的理论最大加速比将是 20 倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;限制你的资源、对所有内容（线程、队列）实施固定的生产限制、规划资源使用并尽可能避免争用……这些说起来容易，做起来难。还可以充分利用缓存、水平缩放、添加多个处理单元等。&lt;/p&gt;&lt;p&gt;你应该了解你的框架和你的数据库，并优化它们。&lt;/p&gt;&lt;section&gt;&lt;span&gt;2&lt;/span&gt;可靠性&lt;/section&gt;&lt;p&gt;根据《牛津词典》，可靠意味着质量或性能始终如一，且能够被信任。可靠性可以用平均故障间隔时间（MTBF）来表示，可靠性 =exp（-t/MTBF）。&lt;/p&gt;&lt;p&gt;可靠性很难用数字度量。我们可以用一些软件指标衡量复杂度和代码覆盖率，以了解可靠性的边缘情况。适应度函数也可用于度量可靠性。未解决问题的数量、成功的构建和部署的数量也是一些可用指标。ISO-9001 是衡量可靠性的另一种方法。&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://sergiuoltean.com/2020/04/29/fitness-functions/&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 提高可靠性的技术&lt;/section&gt;&lt;p&gt;遵循最佳工程实践将产生更好的产品。使用更好的管理实践和流程，可以实现更高的可靠性。突变测试技术会让系统考虑边缘情况。混沌测试是提高可靠性的另一个重要工具。总之我们要强化系统来提高可靠性。&lt;/p&gt;&lt;section&gt;&lt;span&gt;3&lt;/span&gt;可用性&lt;/section&gt;&lt;p&gt;表示可用系统时间与总工作时间的比率。这是可靠性之上的另一层。它是系统掩盖或修复特定阈值（例如时间间隔）内故障的能力。可用性可以表示为&lt;/p&gt;&lt;p&gt;在公众号互联网架构师后台回复“2T”，获取Java面试题和答案惊喜礼包。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.30526315789473685&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;380&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqtkqWLJibqaGVWw8aKuxrCLAFYVIxu4hOw7q8wVB9dswQb54Tcq4U8aw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;MTBF= 平均无故障时间；MTTR= 平均修复时间&lt;/p&gt;&lt;p&gt;于是我们计算出下表：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2532894736842105&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1216&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erq5viaev7W7cZ6Fiaicc4OgLcfWGeVZEaKBwicZI4dXxOWvdVQdtd2HzZfaw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 提高可用性的技术&lt;/section&gt;&lt;p&gt;为了提升它，首先我们需要检测潜在的故障。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.21428571428571427&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1218&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erq6guAullicqfZVgjtTuh4SefwcHC6OIeqr9zKMbmb4mJl48OWsH2Zc5Q/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;检测到异常情况后，我们可以进行干预。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3235053235053235&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1221&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqHHiaLlc8VHJvliaNFm3hVS1icpKgiaxHKuetLkhAPqmdjly309jJz9oNyQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;4&lt;/span&gt;弹性&lt;/section&gt;&lt;p&gt;弹性指的是系统遇到问题时可以降级（而非中断服务），等待问题修复完成，表示的是系统在遇到严重故障时的持续运行能力。为实现弹性，需要提前设置防御机制（断路器模式）。弹性有时被称为&lt;strong&gt;容错性&lt;/strong&gt; 。弹性系统指的是可以适应压力并持续运行的系统。很难用数字指标来度量弹性。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 增强弹性的技术&lt;/section&gt;&lt;p&gt;首先是确定潜在风险：系统有哪些关键功能？哪些硬件至关重要？然后我们需要实施保护策略，为此需要检查哪些事件可能导致这些重要部件发生故障。找出风险因素后就需要确定容忍阈值。具体的保护策略包括对请求数和线程数施加限制、缓存相同的请求、批量发送请求等。&lt;/p&gt;&lt;section&gt;&lt;span&gt;5&lt;/span&gt;可信赖性&lt;/section&gt;&lt;p&gt;它包括&lt;strong&gt;可靠性&lt;/strong&gt; 、&lt;strong&gt;可用性&lt;/strong&gt; 、&lt;strong&gt;弹性&lt;/strong&gt; 、&lt;strong&gt;可持续性&lt;/strong&gt; （可用性 / 弹性的比值）、&lt;strong&gt;可恢复性&lt;/strong&gt; （弹性函数）和 &lt;strong&gt;稳健性&lt;/strong&gt; （可靠性函数）。我们应该始终将它们视为一个整体。&lt;/p&gt;&lt;p&gt;拿一辆汽车来说，如果它是新车并且是知名的可靠品牌（例如梅赛德斯），我们可以说它是可靠的。它有备用轮胎，所以有一些可用性。四轮驱动意味着弹性，其中两轮出故障还有两轮能工作（但性能会下降）。可持续性是可用性（备用轮胎）和弹性（四轮驱动）的综合。健壮性在这里可以指道路通过能力。如果汽车是电动的，那么充电速度就是一个可恢复性指标。&lt;/p&gt;&lt;section&gt;&lt;span&gt;6&lt;/span&gt;可伸缩性&lt;/section&gt;&lt;p&gt;它是系统在重负载下在可接受的阈值内的执行能力。它分为手动和自动可伸缩性两种，后者也叫 &lt;strong&gt;灵活性&lt;/strong&gt; 。当负载突增时，系统会做出反应并水平缩放（添加 / 删除更多实例）。我们可以查看 CPU 和内存来观察这些突发事件。这些突发操作完成后，系统将杀死不必要的实例，从而降低成本。垂直伸缩意味着我们向系统添加了更多物理资源（例如更多的内存、更好的 cpu）。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 实现可伸缩性的技术&lt;/section&gt;&lt;p&gt;这里涉及到 devops，最好使用 aws fargate 之类的云服务。&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://aws.amazon.com/fargate/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;下图中可以看到放大和缩小策略。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3251953125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqictxBRPIvNIDX5kz4Fg7qEJk6VdYhfT3DTxjlgbUx7USx7QJU3uvsibw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;7&lt;/span&gt;安全性&lt;/section&gt;&lt;p&gt;它实际上是许多特点的集合：&lt;strong&gt;机密性&lt;/strong&gt; 是指系统保护用户数据安全的能力；&lt;strong&gt;完整性&lt;/strong&gt; 是保护外部资源免遭篡改的能力；&lt;strong&gt;身份验证&lt;/strong&gt; 允许用户访问系统；&lt;strong&gt;授权&lt;/strong&gt; 则告诉用户可以访问系统的哪些部分。授权通常使用 RBAC、ACL 或 ABAC 来实现。&lt;strong&gt;不可否认性&lt;/strong&gt; 保证了消息的发送者不能否认自己发送了消息，并且接收者也不能否认自己接收了消息。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 增强安全性的技术&lt;/section&gt;&lt;p&gt;首先我们需要检测。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1722723543888433&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqnGXRrSgAyiacrwUFzmKc3p7as8nV0Dju5txibtFXWlONeP5kMFhtawMQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;针对攻击行为，我们需要制定灵活的应对策略。大多数情况下我们可以撤消访问权限，在某些极端情况下我们可以关闭系统，当然最好还是避免后一种情况出现。最好使用成熟的安全解决方案，自行实现往往不是好办法。&lt;/p&gt;&lt;section&gt;&lt;span&gt;8&lt;/span&gt;互操作性&lt;/section&gt;&lt;p&gt;它表示系统与外部系统通信的能力。合约接口是互操作性中最重要的概念，其涵盖了通信的所有方面，包括错误处理。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善互操作性的技术&lt;/section&gt;&lt;p&gt;最好的策略是使用企业集成模式。如果用到多个通信协议，这种策略就是最佳方法。&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://learning.oreilly.com/library/view/enterprise-integration-patterns/0321200683/&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;9&lt;/span&gt;可调整性&lt;/section&gt;&lt;p&gt;也称为 &lt;strong&gt;可变性&lt;/strong&gt; ，其描述了系统变化的难易程度。一般来说它是一个隐含的特征。作为架构师，你要知道系统变化的概率是未知的，但一旦出现变化，系统应该能够优雅地应对。变化是软件世界中唯一确定的事物。话虽如此，我们不能将整个系统都设计为可变组件。如果每个组件都是即插即用组件，设计就做不完了。因此我们需要找到那些变化概率很高的部分。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改进可调整性的技术&lt;/section&gt;&lt;p&gt;有两个维度。作为一名架构师，你需要确定哪些部分具有较高的变化概率；作为软件工程师，你必须确保这些部分容易改动。遵循 SOLID 原则是一个很好的开始。可以使用适应度函数度量传入和传出耦合。我们需要计算变化成本。比如要构建一个 UI 表单，它需要的位置比我们最初想像的要多，则我们可以复制粘贴代码并进行必要的调整，也可以构建一个新组件并插进来。然后我们得到了变化的成本：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;N x 编写代码的成本（复制粘贴）&amp;lt;= 编写组件 +（N x 将其插进来的成本）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;还需要考虑时间，观察较长的时间才能得到可靠的观察结果。&lt;/p&gt;&lt;section&gt;&lt;span&gt;10&lt;/span&gt;可部署性&lt;/section&gt;&lt;p&gt;所有系统都应封装在某种工件中，可以是 war、jar、ear、apk、dll、gem 等。它们被部署在能够运行它们的环境中。由于 docker 的进化，现在我们可以在一台机器上拥有多个环境。可部署性是一种将代码转换为客户可用产品的机制。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善可部署性的技术&lt;/section&gt;&lt;p&gt;最有效的是实施持续集成 / 持续部署（CI/CD）。认真的话，每次代码推送都将触发一个生产部署。为此，应通过适应度函数和自动化测试来保护你的代码。它是抗脆弱性的关键部分。我们希望能按需部署，一键完成工作。我们也会部署硬件。使用基础架构即代码之类的技术可以提高效率。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqzn6VSE0NOrhUxApjTwYtAhCpu6Okwo1AQPicVU2MFOiapYbS2KiazAAsg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;11&lt;/span&gt;可测试性&lt;/section&gt;&lt;p&gt;在所有系统中它都是一个重要特征。我们必须确保构建的系统尊重了客户的需求。复杂的系统很难测试。以微服务架构为例，我们有很多独立开发的活动部件。这个特征经常会让步给其他特征。为了使系统可测试，我们需要能控制每个组件的输入和输出。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善可测试性的技术&lt;/section&gt;&lt;p&gt;请尽量控制系统的复杂性。我们应该构建较小的组件，不要重新发明轮子；还应该编写可测试的代码，在适当的位置应用 TDD。&lt;/p&gt;&lt;section&gt;&lt;span&gt;12&lt;/span&gt;简单性&lt;/section&gt;&lt;p&gt;这条特征是很难实现的。一切都是权衡取舍，而大多数情况下这一条都会被牺牲掉。但如果我们需要在有限的时间内快速构建某些东西，那么就应该优先考虑简单性。在构建 MVP（最小可行产品）时，我们关心的只有简单性。但请注意，实现目标之后，我们不应丢掉所有东西。不要与 PoC（概念验证）或某种 R&amp;amp;D 混淆。&lt;strong&gt;可重用性&lt;/strong&gt; 在这里也很重要。在公众号互联网架构师后台回复“2T”，获取一份惊喜礼包。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善简单性的技术&lt;/section&gt;&lt;p&gt;可以构建粗粒度的组件；使用 RAD 框架，例如 ApacheIsis、Vaadin 或 JHipster；牺牲简单性之前请确保自己能承受对应的代价；遵循 KISS 原则。记住时间是关键：先跑起来，再考虑美观和性能。&lt;/p&gt;&lt;section&gt;&lt;span&gt;13&lt;/span&gt;可移植性&lt;/section&gt;&lt;p&gt;指的是系统从一个操作系统移植到另一个的能力，它会影响编程语言的选择。例如，我们知道为了运行 Java 代码需要一个 JVM，因此问题就是“JVM 是否可移植？”答案是肯定的。另一个例子是 golang：它打包为二进制文件，不需要外部依赖项，因此是可移植的。一些微软专属技术就不行，它们只能运行在微软操作系统中。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善可移植性的技术&lt;/section&gt;&lt;p&gt;一个显而易见的选项就是容器化、docker。一个 docker 引擎能够运行多个隐藏了实现细节的 docker 容器。&lt;/p&gt;&lt;section&gt;&lt;span&gt;14&lt;/span&gt;易用性&lt;/section&gt;&lt;p&gt;谈到易用性时通常会提到 &lt;strong&gt;可配置性&lt;/strong&gt; ，即用户自定义系统的能力，比如通过 UI 主题更改外观和配置系统行为（例如控制用户访问权限等）。还有 &lt;strong&gt;本地化&lt;/strong&gt;，也称为 i18n（internationalization）。它指的是系统支持多种标准的能力，一般是通过用户体验（UX）实现的。这里的标准指的是语言、货币、公制单位、字符编码等。本地化资源通常是静态的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可访问性&lt;/strong&gt; 是另一个易用性特征。世界上有些人是残疾的（失明、听力受损、色盲），我们如何确保这些人可以受益于我们的系统呢？对于色盲来说，选择颜色会花很多时间。Siri/Alexa 是盲人的好帮手。考虑可访问性时，请想到我们的祖父母是不是能方便地使用我们的系统。&lt;/p&gt;&lt;p&gt;另外还有 &lt;strong&gt;可支持性&lt;/strong&gt; ，比如说帮助页面或者 24x7 技术支持。我们应该努力让系统直观易用，这会影响可学习性，也就是用户习惯系统所需的时间。用户培训和帮助页面之类的策略很好用。&lt;/p&gt;&lt;section&gt;&lt;span&gt;15&lt;/span&gt;可扩展性&lt;/section&gt;&lt;p&gt;它是描述系统对即插即用组件需求程度的特征。对于使用内核架构的系统来说，这是很重要的特征。Eclipse Platform 和 OSGI 标准就是经典的例子。&lt;/p&gt;&lt;section&gt;&lt;span&gt;16&lt;/span&gt;抗脆弱性&lt;/section&gt;&lt;p&gt;它是系统应对压力、冲击、波动、噪声、错误、故障或攻击的能力。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8887993553585818&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqRaQgOWhjpJNO9eeIc9UNz8y2TKtUCnDexX76UqjHoSfYmBvANTGtgg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善抗脆弱性的技术&lt;/section&gt;&lt;p&gt;首先我们要敲打敲打系统。可以使用 CI/CD，它们本来就是做这种事的。每次代码更改都必须投入生产。当然，我们也要有防御机制，适应度函数就是个好方法；Simian Army 也是个不错的工具。&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://github.com/Netflix/SimianArmy&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;17&lt;/span&gt;可升级性&lt;/section&gt;&lt;p&gt;它是指系统无缝升级自身的能力。对于非 Web 产品（例如 App Store 和 Google Play），这很容易实现，因为它们的升级能力是嵌入到 OS 中的；涉及到 Web 应用时，事情就麻烦多了。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善可升级性的技术&lt;/section&gt;&lt;p&gt;首先我们需要为服务提供版本控制。下一步是使用蓝绿部署或金丝雀部署等策略进行零停机的时间部署。&lt;/p&gt;&lt;section&gt;&lt;span&gt;18&lt;/span&gt;合规性&lt;/section&gt;&lt;p&gt;不管我们需要的是哪种第三方工具和框架，都应该得到它们的合法授权。我们需要重视开源软件的合规性因素，因为它们可能会附带一些我们不想要的额外约束。没有人愿意暴露自己的源代码，因此我们应该远离 GPL 许可证。在欧盟，《GDPR》已成为强制规定，因此我们需要确保系统符合其规定。还要考虑一些 ISO 标准，公司可能需要遵循某些流程才能符合它们的要求。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfP4FIqmEzg5sEcuGxyg2erqc34toXzc9KFA2TNLzt6Tt6j9FNNDQZGbPg2ZMISO78AHNjcTeoxARA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 改善合规性的技术&lt;/section&gt;&lt;p&gt;理想情况下，每家公司都应该有一个法律部门，但现实并非如此。适应度函数（例如许可证检查）可以保护我们免受列入黑名单的许可证的影响。在设计系统时，我们必须找到一种保护用户数据隐私的方法。&lt;/p&gt;&lt;section&gt;&lt;span&gt;19&lt;/span&gt;成本&lt;/section&gt;&lt;p&gt;可能是最重要的架构特点。一切都有成本，虚拟的、还是现实的都一样。任何成本都可以换算成金钱。如果我们需要购买某些工具（IDE）、云服务（例如 AWS）、第三方框架（例如 new-relic）的许可证，则总会产生财务成本。开发团队也要发工资，学习新技术或培训团队成员需要花钱。不尊重敏捷宣言是有代价的；错误的代码要付出代价；缺少单元测试会有代价；缺少 CI/CD 会有代价；没有基础架构即代码也会有代价……这个列表是没有尽头的。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 降低成本的技术&lt;/section&gt;&lt;p&gt;帮助客户控制成本是我们的责任。我们需要区分单纯的成本和投资，并让客户相信投资是划算的。&lt;/p&gt;&lt;p&gt;以 Scrum 流程为例，我个人认为它没什么用。在一个固定的周期（通常为两周）中，我们有这么多的仪式（计划、站会、演示、回顾），然后根据（猜出来的）估计值做计算，结果 Sprint 完成度 100％只是偶然而非必然。我们需要敏捷和适应，而不是盲目地遵循流程。我们应该减少会议和仪式，这样成本就会下降。我们应该专注于完成工作的本质要素。&lt;/p&gt;&lt;p&gt;测试是必要的投资，快速前进的唯一方法就是正确前进。我们必须说服客户，从长远来看，成本是会下降的。测试会减少错误的数量，从而减少成本。&lt;/p&gt;&lt;p&gt;代码质量是另一项投资。好的代码将带来更好的测试，提高稳健性、可维护性、可调整性等。与难以维护的系统相比，我们的更改花费的时间会更少，成本会下降。&lt;/p&gt;&lt;section&gt;&lt;span&gt;20&lt;/span&gt;可存档性&lt;/section&gt;&lt;p&gt;指系统保留历史数据记录的能力。在数据是一等公民的系统中（例如财务系统），这个特征非常重要。数据绝不会删除，而只会归档，这主要是考虑到法律要求。可归档性是对可审计性的支持。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 实现可归档性的技术&lt;/section&gt;&lt;p&gt;首先是在数据上使用时间戳（例如 updatedOn、createdOn）。然后要有一个 cron 作业，将所有低于特定阈值的数据移入历史表中。另一种技术是将数据标记为软删除，但这会影响查询性能。&lt;/p&gt;&lt;section&gt;&lt;span&gt;21&lt;/span&gt;可审核性 / 可跟踪性&lt;/section&gt;&lt;p&gt;这是支持重构历史的系统特征。我们必须记录所有关键操作（尤其是在安全场景中），以便重现问题并从错误中学习经验。我们也可以将这些记录用作法律依据。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 实现可审核性的技术&lt;/section&gt;&lt;p&gt;记录每个关键操作并集中存放这些记录。可以使用 ELK，或 sleuth-zipkin 具。&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.elastic.co/what-is/elk-stack&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://sergiuoltean.com/2017/10/04/zipkin-sleuth/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://sergiuoltean.com/2020/06/26/architecture-characteristics/&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>41d356b19740a0dfcd82632bd28efceb</guid>
<title>[推荐] Redis 教程：Redis 知识体系详解</title>
<link>https://toutiao.io/k/av396i0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;theme-default-content content__default&quot;&gt;&lt;h1 id=&quot;♥redis教程---redis知识体系详解♥&quot;&gt;&lt;a href=&quot;#♥redis教程---redis知识体系详解♥&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; ♥Redis教程 - Redis知识体系详解♥&lt;/h1&gt; &lt;blockquote&gt;&lt;p&gt;本系列主要对Redis知识体系进行详解。@pdai&lt;/p&gt;&lt;/blockquote&gt;  &lt;h2 id=&quot;知识体系&quot;&gt;&lt;a href=&quot;#知识体系&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 知识体系&lt;/h2&gt; &lt;p&gt;&lt;em&gt;知识体系&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&lt;img alt=&quot;&quot; data-src=&quot;/_images/db/redis/db-redis-overview.png&quot; loading=&quot;lazy&quot; class=&quot;lazy&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;em&gt;相关文章&lt;/em&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;p&gt;首先，我们通过学习Redis的概念基础，了解它适用的场景。&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-introduce.html&quot;&gt;Redis入门 - Redis概念和基础&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;blockquote&gt;&lt;p&gt;其次，这些适用场景都是基于Redis支持的数据类型的，所以我们需要学习它支持的数据类型；同时在redis优化中还需要对底层数据结构了解，所以也需要了解一些底层数据结构的设计和实现。&lt;/p&gt;&lt;/blockquote&gt; &lt;p&gt;&lt;img alt=&quot;&quot; data-src=&quot;/_images/db/redis/db-redis-object-2-2.png&quot; loading=&quot;lazy&quot; class=&quot;lazy&quot;/&gt;&lt;/p&gt;  &lt;blockquote&gt;&lt;p&gt;再者，需要学习Redis支持的核心功能，包括持久化，消息，事务，高可用；高可用方面包括，主从，哨兵等；高可拓展方面，比如 分片机制等。&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-rdb-aof.html&quot;&gt;Redis进阶 - 持久化：RDB和AOF机制详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;为了防止数据丢失以及服务重启时能够恢复数据，Redis支持数据的持久化，主要分为两种方式，分别是RDB和AOF; 当然实际场景下还会使用这两种的混合模式。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-pub-sub.html&quot;&gt;Redis进阶 - 消息传递：发布订阅模式详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-event.html&quot;&gt;Redis进阶 - 事件：Redis事件机制详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis 采用事件驱动机制来处理大量的网络IO。它并没有使用 libevent 或者 libev 这样的成熟开源方案，而是自己实现一个非常简洁的事件驱动库 ae_event。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-trans.html&quot;&gt;Redis进阶 - 事务：Redis事务详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-copy.html&quot;&gt;Redis进阶 - 高可用：主从复制详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;我们知道要避免单点故障，即保证高可用，便需要冗余（副本）方式提供集群服务。而Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。本文主要阐述Redis的主从复制。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-sentinel.html&quot;&gt;Redis进阶 - 高可用：哨兵机制（Redis Sentinel）详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;在上文主从复制的基础上，如果注节点出现故障该怎么办呢？ 在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的问题。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-cluster.html&quot;&gt;Redis进阶 - 高可拓展：分片技术（Redis Cluster）详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;前面两篇文章，主从复制和哨兵机制保障了高可用，就读写分离而言虽然slave节点来扩展主从的读并发能力，但是写能力和存储能力是无法进行扩展的，就只能是master节点能够承载的上限。如果面对海量数据那么必然需要构建master（主节点分片)之间的集群，同时必然需要吸收高可用（主从复制和哨兵机制）能力，即每个master分片节点还需要有slave节点，这是分布式系统中典型的纵向扩展（集群的分片技术）的体现；所以在Redis 3.0版本中对应的设计就是Redis Cluster。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;blockquote&gt;&lt;p&gt;最后，就是具体的实践以及实践中遇到的问题和解决方法了：在不同版本中有不同特性，所以还需要了解版本；以及性能优化，大厂实践等。&lt;/p&gt;&lt;/blockquote&gt;  &lt;h2 id=&quot;学习资料&quot;&gt;&lt;a href=&quot;#学习资料&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 学习资料&lt;/h2&gt; &lt;ul&gt;&lt;li&gt;&lt;p&gt;Redis官网:http://redis.io/&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Redis官方文档:http://redis.io/documentation&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Redis教程:http://www.w3cschool.cn/redis/redis-intro.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Redis下载:http://redis.io/download&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis英文文档 https://redis.io/topics/data-types&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis中文文档 http://www.redis.cn/documentation.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;《redis设计与实现 3.0版本》 http://redisbook.com/index.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis菜鸟教程 https://www.runoob.com/redis/redis-tutorial.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis源码解读 3.2.8版本 https://blog.csdn.net/men_wen/article/details/75668345&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;除此之外，我还推荐你看下 极客时间 《Redis核心技术与实战》（作者：蒋德钧）的相关内容，它是我看到的为数不多的含有实战经验比较多的专栏，部分文章中图片也来源于这个系列。&lt;/p&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d7ece89b785b732ff0f9207b4be142da</guid>
<title>[推荐] 聊聊 IT 技术人的知识体系</title>
<link>https://toutiao.io/k/vmimc5g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;161&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/fCpd1cf8iacboUWicibrqngI6axlkiaEZKSOWSicUSdsk4LbBIQhzV9NJQ79BDSNLm4KRFkDFHcdb3hN0cpR9iaKwRxw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【个人成长&lt;strong&gt;&lt;span&gt;】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;| &lt;/span&gt;&lt;strong&gt;&lt;span&gt;作者&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;/Edison Zhou&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;我在我的2020年终总结中提到技术人需要建立自己的知识体系，那么怎么建立自己的知识体系呢？技术人的知识体系又是什么样的呢？今天，和你一一分享。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文视频版：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;amp;mid=2651734689&amp;amp;idx=1&amp;amp;sn=774b0c51d53c06f81fb765c7173aaaa1&amp;amp;chksm=8bc39da0bcb414b6904df41999cecd8e58908b0d30c7dc3ed5a640c5d6af05cfa9d321dec82c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;聊聊IT技术人的知识体系&quot; data-itemshowtype=&quot;5&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊聊IT技术人的知识体系&lt;/a&gt;，本文为该视频的文字稿。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1&lt;/span&gt;关于我的12字方针&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;我在我的《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;amp;mid=2651734149&amp;amp;idx=1&amp;amp;sn=75f3bfceff058042c764efd094cbf158&amp;amp;chksm=8bc39f84bcb41692500a44c5a4a69e6c867cd7c600bf4e0bfe2ece1988a3688b5b5fc3a0a73f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2020年终回顾&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2020年终回顾&lt;/a&gt;》一文中提到了一个12字方针，以应对IT技术人的中年危机，它是“&lt;strong&gt;抓主线、建体系、有侧重、多复盘&lt;/strong&gt;”。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;139&quot; data-backw=&quot;258&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;258&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;86&quot; data-ratio=&quot;0.5376827896512936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fCpd1cf8iacYVFJUtUdwrENd5no68ft7sibx9aHnOCq33ouIvY2GZ01GH2XjBAojQJRjQJBf3YWqajzofx0FJibSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;889&quot;/&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中，“建体系”三个字最为重要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，是建什么体系呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;答曰：建立我们IT技术人的知识体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，我们就来聊聊如何建立我们自己的知识体系。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;2&lt;/span&gt;刻意构筑 点-线-面&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们可以借助 &lt;strong&gt;点-线-面&lt;/strong&gt; 的方法论来构筑知识体系，即我们在工作中用到的往往是一个知识面的某条主线的某个点，只有当你用了多个点之后才会将它们升维到某条主线，最终多条主线再次升维形成一个知识面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里我们以Redis为例来说说如何构筑Redis的点-线-面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;248&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;514&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;83&quot; data-ratio=&quot;0.33407572383073497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fCpd1cf8iacaCD0zs9aP5DWSsWHia1icNSowVLb5lpVoibwYUoBDg7aFTVxPKDqA6YBtE0oZIbf9WhfUibBiaENvFoVw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;898&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis应该是我们做后端开发的技术人大概率都会用到的一个中间件，不管你用到了哪种程度，只要你是做后端开发，那么你的知识体系中必然有它的位置。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;这里我们借助某位老师总结的一个Redis的知识结构图来聊聊，如下图所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;248&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;258&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;86&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fCpd1cf8iacYVFJUtUdwrENd5no68ft7s5etIstD2micpkibmYnSLeu55scxUok6sgkia3ErpT6wkjUPOAckia3dWpw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;我们可以从上图中看到，该老师将Redis这个知识面分为了两大维度 和 三大主线，两大维度分别是 应用维度 和 系统维度，三大主线分别是 高性能主线、高可靠主线 和 高可扩展主线。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作为一个对自己有追求 又 渴望成长 的IT技术人来说，往往都是在工作中在了解和实践Redis的一个又一个零散的知识点，却很少将它们整理和归纳，使这些点能够串联起一条主线脉络在心中。比如，我们常常使用Redis做缓存，用了很多相关的get/set接口，也用了k/v、string、set等数据结构，有的还使用到了新增的SET接口实现了分布式锁去应对秒杀抢购的业务场景，但却很少将它们归纳分类提升维度，进而构筑知识体系，因此在面试中的回答往往不够完整（这也是我的经历，错失一些offer的感悟）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如果我们都能有这样的整理和归纳，对每个知识面都有像上图一样的脉络在心中，是不是也会增加我们的自信程度，减少不必要的中年焦虑？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;画外音：骚年，平日里多多归纳总结，刻意练习，必有收获。技术如此，业务知识也如此，心中有一条公司整体业务的主线 以及 自己项目团队所负责的业务线的详细脉络，就是一个合格的IT技术人，因为技术是为业务服务的，没有交付业务价值的技术也是不合格的。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;那么，跳出Redis这个知识面，我们后端技术人的知识体系的全貌又是怎么样的？这里我整理了一棵树，它列出重要的知识面 和 主线，仅供参考。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;416&quot; data-backw=&quot;451&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;451&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;254&quot; data-ratio=&quot;0.9217252396166135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fCpd1cf8iacYVFJUtUdwrENd5no68ft7setykTsvZaC36kvZC5lBHwJSs2CXhKtoxIl1wFbibukMenib3SQpKwdPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1252&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;当然，这还只是一棵较为粗糙的树，我会持续对它进行完善，因为我的技术认知和业务认知也在不断地更新，乐观接受新认知，勇于放弃旧认知，只要自己不断地在进步，就是值得高兴的事。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;此外，金三银四已经到来，Edison也在整理一棵开发面试的知识体系，目前整理到了v0.5版本，关注EdisonTalk的童鞋可以回复“面试知识树”获取。这个pdf的全貌如下图所示：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;341&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;518&quot; data-ratio=&quot;0.6055900621118012&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fCpd1cf8iacYVFJUtUdwrENd5no68ft7sdooN6VhaPuedt4zmZebArKknn8yp7fY6QHPXyZsw1kNqVB1XwVbQMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1288&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在EdisonTalk交流群里（欢迎加群交流），很多童鞋都表达了自己的焦虑，认为自己多年所学的知识可能会在今后的日子越来越得不到市场。我承认，在国内的互联网和IT大环境市场下，面向职位和工资编程，.NET在互联网大厂的平均使用份额的确不高，但是也需要承认.NET在数字化转型、工业制造、3D游戏（Unity）、BIM设计、医疗信息化等行业领域还是占有一席之地。此外，作为一个程序员，掌握两门及以上的开发语言也不是什么坏事儿，如果我们将自己的知识体系进行一个抽象和升维，你会发现.NET技术栈在你的知识体系中只是其中的一个面，其他的很多面其实都是后端开发通用的技术能力，你不必担心这些通用的技术能力在其他企业用不上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;画外音：讲到这里，细心的读者应该可以发现，抽象归纳和顶层设计的能力对于程序员来说，是个需要逐步练习的技能，可以帮助我们看到全局，而只有看到全局，你才能做到胸有全局脉络，又能聚焦局部重点。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;3&lt;/span&gt;其他想说的&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关于硬技能和软技能&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在职场中，硬技能是我们安身立命的基础，它是硬核的，即我们所掌握的开发语言、框架、中间件 和 项目经验。软技能是我们扩展边界的条件，它是加分项，可以在我们达到开发角色边界的时候帮助我们跨上一个新台阶，比如Team Leader或Project Manager等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;341&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;340&quot; data-ratio=&quot;0.3318534961154273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fCpd1cf8iacYVFJUtUdwrENd5no68ft7sE2fPPctdiaTNuIssQNPyWw6DPqP8H8Y4XKMjKxicjfxbbm26tddRZnhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;901&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;技术人职场打怪升级路线&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在职场中，我们首先是做事，通过硬核技能写好代码做好服务，等到一定时机，我们有机会管事（比如Team Leader），再管人（比如Manager），最后管心（比如Director或CIO/CTO）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;185&quot; data-backw=&quot;328&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;328&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;109&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fCpd1cf8iacZnibZG0ra87V5DHSibFtJmeeXibAcTjqPDFSveLpBl0lSfvy6u8H6xicV8icRDX1CgI44tfS8tibaznvmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么技术人越成长晋升，关注点都会慢慢聚焦到人和人心上面？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为&lt;strong&gt;人心比系统复杂&lt;/strong&gt;，架构师处理的是多个系统之间的连接关系，而管理者处理的其实是多个人心之间的连接关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我的一点成长经验&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我在职场中也没有做到什么高级管理者的位置，但我现在逐步养成了拔高自己的视角去看待一些问题，我也有了一些自己的成长经验，我觉得以下几点对初入职场和初中级开发工程师都是有用的（如果你也认可）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;185&quot; data-backw=&quot;328&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;317&quot; data-ratio=&quot;0.6188340807174888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fCpd1cf8iacYVFJUtUdwrENd5no68ft7suTqKX2yXeCXIfTc2hPvVkjiboGesTUL54erdujnTTCLLINLDp0d4OBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一点，&lt;strong&gt;积极主动做事&lt;/strong&gt;。职场中积极主动做事的人，运气都不会太差，机会一定都是会留给积极做事有准备的人。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二点，&lt;strong&gt;努力扩展边界&lt;/strong&gt;。任何成长阶段都有自己的边界，而渴望成长的人总是希望在几年或多年的时间里上一个新台阶。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三点，&lt;strong&gt;及时总结复盘&lt;/strong&gt;。当你努力踏上一个新的台阶时，你总是不习惯或者不适应的，你会踩很多很多的坑，这时你需要及时对踩过的坑进行总结复盘，避免下次再犯。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这三点其实是有一个顺序关系的，你只有积极主动做事，才会在大概率的情况下得到拓展边界（踏上新的成长台阶）的机会，而当你踏上新台阶时，一定会碰到各种各样的问题（因为要处理问题的复杂度提升了）进而踩很多坑，这时你就需要及时总结复盘，避免多次犯同样的错误。如此，这就是一轮成长的闭环，而技术人的职场进阶路线就是一个又一个这样的闭环。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;4&lt;/span&gt;小结&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本文介绍了IT技术人的知识体系的概念，如何通过 点-线-面 理论来构建自己的知识体系，最后给出了一个后端技术人知识体系的示例，你可以根据自己的需求进行完善。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，你有没有开始计划去整理你的知识体系呢？欢迎留言，一起交流！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;配套视频&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section/&gt;&lt;p&gt;&lt;span&gt;后台回复：&lt;strong&gt;面试知识树&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即可获得.NET开发面试知识体系pdf&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_gif/r0Yeg3pq20kXBcStvMoDUdhY0LlibllkRC7l9RV1ROKHxIuCfQfTy09WLHTwN8l72OX2JV3z0lQXfsdQWCZ5BiaA/640?wx_fmt=gif&quot; data-ratio=&quot;0.125&quot; data-type=&quot;gif&quot; data-w=&quot;720&quot; data-width=&quot;80%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/r0Yeg3pq20kXBcStvMoDUdhY0LlibllkRC7l9RV1ROKHxIuCfQfTy09WLHTwN8l72OX2JV3z0lQXfsdQWCZ5BiaA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;年终总结：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;amp;mid=2651734149&amp;amp;idx=1&amp;amp;sn=75f3bfceff058042c764efd094cbf158&amp;amp;chksm=8bc39f84bcb41692500a44c5a4a69e6c867cd7c600bf4e0bfe2ece1988a3688b5b5fc3a0a73f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Edison的2020年终总结&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Edison的2020年终总结&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数字化转型：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;amp;mid=2651732970&amp;amp;idx=1&amp;amp;sn=c0f217fced5d68ef81246c9b0e7528c8&amp;amp;chksm=8bc3e4ebbcb46dfd58b37b7d6d49095887e943b9eb288dc114a314d1449c4d1938e0d0ca8cc5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;我在传统企业做数字化转型&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Edison在传统企业做数字化转型&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术管理：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;amp;mid=2651733864&amp;amp;idx=1&amp;amp;sn=f06e2b737419b3e04ac313f62176c978&amp;amp;chksm=8bc3e069bcb4697f27e7f92a746780629e46ee95949f3e1dc22a141621dbb38bc22e862a5b67&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;IT技术人的技术管理学习进阶&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;IT技术人的技术管理学习进阶&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商业知识：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;amp;mid=2651734202&amp;amp;idx=1&amp;amp;sn=3bbca266c43e43a0bfe3cd98b7bf54c6&amp;amp;chksm=8bc39fbbbcb416adba16fb085660eba6ae57f7675790237fce41761ba6c928e138626b588d8a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;技术人的底层商业知识系列文章目录&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;IT技术人的底层商业知识兵器库&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;.NET大会：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NzQzNTg4Ng==&amp;amp;mid=2651734305&amp;amp;idx=1&amp;amp;sn=475e554e2da5f39d1d4ee004bc8f476b&amp;amp;chksm=8bc39e20bcb41736cd4d4b64acd7d7c2715d7c3ec52df6c5b2f4ed31bca78e65ce7ae6674773&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2020年中国.NET开发者大会PDF资料&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2020年中国.NET开发者大会PDF资料&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;👇扫码关注EdisonTalk&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4NzQzNTg4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/fCpd1cf8iacbJedmiaPXbPDa7ZPs4ianVyxeKwdNgZib1h5xktrFemhPvXA9sZ7lEn2CQesXavQzX16doZicUwfpQag/0?wx_fmt=png&quot; data-nickname=&quot;EdisonTalk&quot; data-alias=&quot;edc-talk&quot; data-signature=&quot;勤于学习 • 善于总结 • 乐于分享&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-type=&quot;gif&quot; data-ratio=&quot;0.2778649921507064&quot; data-w=&quot;637&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ANsQAmJ8oxXiac1myuYZopO7E8a8nT2Fb4QS0ZNkicxPRZfU9rMEQCySgCkZ2eXbvCCtQRLDu1NUmoMancYFxSfQ/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c7848135d6361ed5f737b8f82b2fc593</guid>
<title>[推荐] [译] 新老手必备的 34 种 JavaScript 简写优化技术</title>
<link>https://toutiao.io/k/jdslwhk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原文：https://javascript.plainenglish.io/34-javascript-optimization-techniques-to-know-in-2021-d561afdf73c3&lt;br/&gt;作者：Atit&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发者的生活总是在学习新的东西，跟上变化不应该比现在更难，我的动机是介绍所有JavaScript的最佳实践，比如简写功能，作为一个前端开发者，我们必须知道，让我们的生活在2021年变得更轻松。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能做了很长时间的JavaScript开发，但有时你可能没有更新最新的特性，这些特性可以解决你的问题，而不需要做或编写一些额外的代码。这些技术可以帮助您编写干净和优化的JavaScript代码。此外，这些主题可以帮助你为2021年的JavaScript面试做准备。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.如果有多个条件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在数组中存储多个值，并且可以使用数组 &lt;code&gt;include&lt;/code&gt; 方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (x === &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt; || x === &lt;span&gt;&#x27;def&#x27;&lt;/span&gt; || x === &lt;span&gt;&#x27;ghi&#x27;&lt;/span&gt; || x ===&lt;span&gt;&#x27;jkl&#x27;&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;//logic&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; ([&lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;def&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;ghi&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;jkl&#x27;&lt;/span&gt;].includes(x)) {&lt;br/&gt;  &lt;span&gt;//logic&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.如果为真…否则简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对于我们有 &lt;code&gt;if-else&lt;/code&gt; 条件，里面不包含更大的逻辑时，是一个较大的捷径。我们可以简单的使用三元运算符来实现这个简写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test: boolean;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (x &amp;gt; &lt;span&gt;100&lt;/span&gt;) {&lt;br/&gt;  test = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  test = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test = (x &amp;gt; &lt;span&gt;10&lt;/span&gt;) ? &lt;span&gt;true&lt;/span&gt; : &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//or we can use directly&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test = x &amp;gt; &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们有嵌套条件时，我们可以采用这种方式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x = &lt;span&gt;300&lt;/span&gt;,&lt;br/&gt;test2 = (x &amp;gt; &lt;span&gt;100&lt;/span&gt;) ? &lt;span&gt;&#x27;greater 100&#x27;&lt;/span&gt; : (x &amp;lt; &lt;span&gt;50&lt;/span&gt;) ? &lt;span&gt;&#x27;less 50&#x27;&lt;/span&gt; : &lt;span&gt;&#x27;between 50 and 100&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test2); &lt;span&gt;// &quot;greater than 100&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.声明变量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们要声明两个具有共同值或共同类型的变量时，可以使用此简写形式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1, test2 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.Null, Undefined，空检查&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们创建新的变量时，有时我们想检查我们引用的变量的值是否为空或undefined。JavaScript确实有一个非常好的简写工具来实现这些功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1 !== &lt;span&gt;null&lt;/span&gt; || test1 !== &lt;span&gt;undefined&lt;/span&gt; || test1 !== &lt;span&gt;&#x27;&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; test2 = test1;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.null值检查和分配默认值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;null check&quot;&lt;/span&gt;, test2); &lt;span&gt;// output will be &quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.undefined值检查和分配默认值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;undefined check&quot;&lt;/span&gt;, test2); &lt;span&gt;// output will be &quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常值检查&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;&#x27;test&#x27;&lt;/span&gt;,&lt;br/&gt;    test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test2); &lt;span&gt;// output: &#x27;test&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.将值分配给多个变量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们处理多个变量并希望将不同的值分配给不同的变量时，此简写技术非常有用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1, test2, test3;&lt;br/&gt;test1 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;test2 = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;test3 = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; [test1, test2, test3] = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.赋值运算符简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在编程中处理很多算术运算符，这是将运算符分配给JavaScript变量的有用技术之一。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;test1 = test1 + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;test2 = test2 - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;test3 = test3 * &lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;test1++;&lt;br/&gt;test2--;&lt;br/&gt;test3 *= &lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.如果存在简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我们大家都在使用的常用简写之一，但仍然值得一提。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1 === &lt;span&gt;true&lt;/span&gt;) or &lt;span&gt;if&lt;/span&gt; (test1 !== &lt;span&gt;&quot;&quot;&lt;/span&gt;) or &lt;span&gt;if&lt;/span&gt; (test1 !== &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand //it will check empty string,null and undefined too&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：如果test1有任何值，它将在if循环后进入逻辑，该运算符主要用于 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 的检查。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.多个条件的AND（&amp;amp;&amp;amp;）运算符&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果仅在变量为 &lt;code&gt;true&lt;/code&gt; 的情况下才调用函数，则可以使用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1) {&lt;br/&gt; callMethod(); &lt;br/&gt;} &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;test1 &amp;amp;&amp;amp; callMethod();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.foreach循环简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是迭代的常用简写技术之一。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; testData.length; i++)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; testData) or  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i &lt;span&gt;of&lt;/span&gt; testData)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个变量的数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;testData&lt;/span&gt;(&lt;span&gt;element, index, array&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;test[&#x27;&lt;/span&gt; + index + &lt;span&gt;&#x27;] = &#x27;&lt;/span&gt; + element);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;[&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;].forEach(testData);&lt;br/&gt;&lt;span&gt;// logs: test[0] = 11, test[1] = 24, test[2] = 32&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.return中比较&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以在return语句中使用比较。它将避免我们的5行代码，并将它们减少到1行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;checkReturn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!(test === &lt;span&gt;undefined&lt;/span&gt;)) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; test;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; callMe(&lt;span&gt;&#x27;test&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data = checkReturn();&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(data); &lt;span&gt;//output test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;callMe&lt;/span&gt;(&lt;span&gt;val&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(val);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;checkReturn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; test || callMe(&lt;span&gt;&#x27;test&#x27;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.箭头函数&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;a, b&lt;/span&gt;) &lt;/span&gt;{ &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; a + b; &lt;br/&gt;} &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; add = &lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a + b;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多示例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;callMe&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Hello&#x27;&lt;/span&gt;, name);&lt;br/&gt;}&lt;br/&gt;callMe = &lt;span&gt;&lt;span&gt;name&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Hello&#x27;&lt;/span&gt;, name);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.短函数调用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用三元运算符来实现这些功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;test2&#x27;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; test3 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test3 == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;  test1();&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  test2();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;(test3 === &lt;span&gt;1&lt;/span&gt;? test1:test2)();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15. Switch简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以将条件保存在键值对象中，并可以根据条件使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;switch&lt;/span&gt; (data) {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;    test1();&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;:&lt;br/&gt;    test2();&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;:&lt;br/&gt;    test();&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// And so on...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data = {&lt;br/&gt;  &lt;span&gt;1&lt;/span&gt;: test1,&lt;br/&gt;  &lt;span&gt;2&lt;/span&gt;: test2,&lt;br/&gt;  &lt;span&gt;3&lt;/span&gt;: test&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;data[something] &amp;amp;&amp;amp; data[something]();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16.隐式返回简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用箭头函数，我们可以直接返回值，而不必编写return语句。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;calculate&lt;/span&gt;(&lt;span&gt;diameter&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;.PI * diameter&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;calculate = &lt;span&gt;&lt;span&gt;diameter&lt;/span&gt; =&amp;gt;&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;Math&lt;/span&gt;.PI * diameter;&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17.小数基数指数&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++) { ... }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1e4&lt;/span&gt;; i++) {&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.默认参数值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;test1, test2&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (test1 === &lt;span&gt;undefined&lt;/span&gt;)&lt;br/&gt;    test1 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (test2 === &lt;span&gt;undefined&lt;/span&gt;)&lt;br/&gt;    test2 = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; test1 + test2;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;add = &lt;span&gt;(&lt;span&gt;test1 = &lt;span&gt;1&lt;/span&gt;, test2 = &lt;span&gt;2&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; (test1 + test2);&lt;br/&gt;add() &lt;span&gt;//output: 3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19.扩展运算符简写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// joining arrays using concat&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test = [&lt;span&gt;4&lt;/span&gt; ,&lt;span&gt;5&lt;/span&gt; , &lt;span&gt;6&lt;/span&gt;].concat(data);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// joining arrays&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test = [&lt;span&gt;4&lt;/span&gt; ,&lt;span&gt;5&lt;/span&gt; , &lt;span&gt;6&lt;/span&gt;, ...data];&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test); &lt;span&gt;// [ 4, 5, 6, 1, 2, 3]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于克隆，我们也可以使用扩展运算符。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// cloning arrays&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test1 = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = test1.slice()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// cloning arrays&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test1 = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = [...test1];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20.模板文字&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您厌倦了在单个字符串中使用 &lt;code&gt;+&lt;/code&gt; 来连接多个变量，那么这种简写可以消除您的头痛。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; welcome = &lt;span&gt;&#x27;Hi &#x27;&lt;/span&gt; + test1 + &lt;span&gt;&#x27; &#x27;&lt;/span&gt; + test2 + &lt;span&gt;&#x27;.&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; welcome = &lt;span&gt;`Hi &lt;span&gt;${test1}&lt;/span&gt; &lt;span&gt;${test2}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;21.多行字符串简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在代码中处理多行字符串时，可以使用以下功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = &lt;span&gt;&#x27;abc abc abc abc abc abc\n\t&#x27;&lt;/span&gt;&lt;br/&gt;    + &lt;span&gt;&#x27;test test,test test test test\n\t&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = &lt;span&gt;`abc abc abc abc abc abc&lt;br/&gt;         test test,test test test test`&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;22.对象属性分配&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;&#x27;a&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; obj = {&lt;span&gt;test1&lt;/span&gt;: test1, &lt;span&gt;test2&lt;/span&gt;: test2}; &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; obj = {test1, test2};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;23.将字符串转换成数字&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;parseInt&lt;/span&gt;(&lt;span&gt;&#x27;123&#x27;&lt;/span&gt;); &lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = &lt;span&gt;parseFloat&lt;/span&gt;(&lt;span&gt;&#x27;12.3&#x27;&lt;/span&gt;); &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1 = +&lt;span&gt;&#x27;123&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = +&lt;span&gt;&#x27;12.3&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;24.用解构简写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test1 = &lt;span&gt;this&lt;/span&gt;.data.test1;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = &lt;span&gt;this&lt;/span&gt;.data.test2;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = &lt;span&gt;this&lt;/span&gt;.data.test3;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { test1, test2, test3 } = &lt;span&gt;this&lt;/span&gt;.data;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;25.用Array.find简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们确实有一个对象数组并且我们想要根据对象属性查找特定对象时，find方法确实很有用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = [&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;test2&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;cde&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;fgh&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;]&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;findtest1&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; data.length; ++i) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (data[i].type === &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt; &amp;amp;&amp;amp; data[i].name === name) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; data[i];&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand&lt;/span&gt;&lt;br/&gt;filteredData = data.find(&lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; data.type === &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt; &amp;amp;&amp;amp; data.name === &lt;span&gt;&#x27;fgh&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(filteredData); &lt;span&gt;// { type: &#x27;test1&#x27;, name: &#x27;fgh&#x27; }&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;26.查找条件简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们有代码来检查类型，根据类型需要调用不同的方法，我们可以选择使用多个else ifs或者switch，但是如果我们有比这更好的简写方法呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;) {&lt;br/&gt;  test1();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test2&#x27;&lt;/span&gt;) {&lt;br/&gt;  test2();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test3&#x27;&lt;/span&gt;) {&lt;br/&gt;  test3();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test4&#x27;&lt;/span&gt;) {&lt;br/&gt;  test4();&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;Invalid value &#x27;&lt;/span&gt; + type);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; types = {&lt;br/&gt;  &lt;span&gt;test1&lt;/span&gt;: test1,&lt;br/&gt;  &lt;span&gt;test2&lt;/span&gt;: test2,&lt;br/&gt;  &lt;span&gt;test3&lt;/span&gt;: test3,&lt;br/&gt;  &lt;span&gt;test4&lt;/span&gt;: test4&lt;br/&gt;};&lt;br/&gt; &lt;br/&gt;&lt;span&gt;var&lt;/span&gt; func = types[type];&lt;br/&gt;(!func) &amp;amp;&amp;amp; &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;Invalid value &#x27;&lt;/span&gt; + type); func();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;27.按位索引简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们遍历数组以查找特定值时，我们确实使用 &lt;code&gt;indexOf()&lt;/code&gt; 方法，如果找到更好的方法该怎么办？让我们看看这个例子。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(arr.indexOf(item) &amp;gt; &lt;span&gt;-1&lt;/span&gt;) { &lt;span&gt;// item found &lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(arr.indexOf(item) === &lt;span&gt;-1&lt;/span&gt;) { &lt;span&gt;// item not found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(~arr.indexOf(item)) { &lt;span&gt;// item found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(!~arr.indexOf(item)) { &lt;span&gt;// item not found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按位（&lt;code&gt;〜&lt;/code&gt;）运算符将返回除-1以外的任何值的真实值。否定它就像做 &lt;code&gt;~~&lt;/code&gt; 一样简单。另外，我们也可以使用 &lt;code&gt;include()&lt;/code&gt; 函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (arr.includes(item)) { &lt;br/&gt;&lt;span&gt;// true if the item found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;28.Object.entries()&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此函数有助于将对象转换为对象数组。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = { &lt;span&gt;test1&lt;/span&gt;: &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;test2&lt;/span&gt;: &lt;span&gt;&#x27;cde&#x27;&lt;/span&gt;, &lt;span&gt;test3&lt;/span&gt;: &lt;span&gt;&#x27;efg&#x27;&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; arr = &lt;span&gt;Object&lt;/span&gt;.entries(data);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(arr);&lt;br/&gt;&lt;span&gt;/** Output:&lt;br/&gt;[ [ &#x27;test1&#x27;, &#x27;abc&#x27; ],&lt;br/&gt;  [ &#x27;test2&#x27;, &#x27;cde&#x27; ],&lt;br/&gt;  [ &#x27;test3&#x27;, &#x27;efg&#x27; ]&lt;br/&gt;]&lt;br/&gt;**/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;29.Object.values()&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是ES8中引入的一项新功能，该功能执行与 &lt;code&gt;Object.entries()&lt;/code&gt; 类似的功能，但没有关键部分：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = { &lt;span&gt;test1&lt;/span&gt;: &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;test2&lt;/span&gt;: &lt;span&gt;&#x27;cde&#x27;&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; arr = &lt;span&gt;Object&lt;/span&gt;.values(data);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(arr);&lt;br/&gt;&lt;span&gt;/** Output:&lt;br/&gt;[ &#x27;abc&#x27;, &#x27;cde&#x27;]&lt;br/&gt;**/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;30.双按位简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双重NOT按位运算符方法仅适用于32位整数）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;1.9&lt;/span&gt;) === &lt;span&gt;1&lt;/span&gt; &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;~~&lt;span&gt;1.9&lt;/span&gt; === &lt;span&gt;1&lt;/span&gt; &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;31.重复一个字符串多次&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要一次又一次地重复相同的字符，我们可以使用for循环并将它们添加到同一循环中，但是如果我们有一个简写方法呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i ++) { &lt;br/&gt;  test += &lt;span&gt;&#x27;test &#x27;&lt;/span&gt;; &lt;br/&gt;} &lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(str); &lt;span&gt;// test test test test test &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&#x27;test &#x27;&lt;/span&gt;.repeat(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;32.在数组中查找最大值和最小值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; arr = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]; &lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.max(…arr); &lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.min(…arr); &lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;33.从字符串中获取字符&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; str = &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;str.charAt(&lt;span&gt;2&lt;/span&gt;); &lt;span&gt;// c&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;Note: If we know the index &lt;span&gt;of&lt;/span&gt; the array then we can directly use index insted &lt;span&gt;of&lt;/span&gt; character.If we are not sure about index it can &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;undefined&lt;/span&gt;&lt;br/&gt;str[&lt;span&gt;2&lt;/span&gt;]; &lt;span&gt;// c&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;34.数学指数幂函数的简写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.pow(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;); &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;**&lt;span&gt;3&lt;/span&gt; &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>