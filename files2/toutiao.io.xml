<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6c6b5c685e9a58703762624e865fb054</guid>
<title>五一假期不想人挤人？来这里！</title>
<link>https://toutiao.io/k/ok4mp6n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;调休凑的五一小长假终于要来了！&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;抛开 “实际只放了半天” 的小情绪，好好放松一下吧！&lt;/strong&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.34841628959276016&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNaviceqLPCc4PwSgmSN5yTT69y8dECkDGSCSY210dpIOoKk2e5syPmOeu4yLlDpO4YgibWhYgbFAkHgSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;884&quot;/&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;假期去哪玩呢？小心人从众哦！&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/c2Sib3Mp7pOMic7Juicyxo7vsjvhibIibiayDib5VMxsrWKHhm3RvF4ZciambwKWKBaYwa9KRvzOnyDck4TOwLs0JcPcHg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.7556270096463023&quot; data-w=&quot;311&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;宅吗？怕无聊的话，继续往下看！五一小长假，周刊菌陪你哦！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.4517453798767967&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/AjN1jquNaviceqLPCc4PwSgmSN5yTT69yXsQGL1BvcduO2ZWcCfyE5ArUSic5pRxon4ia7M9Dn5vpRdia6573OQjhg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;487&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;322&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.318840579710145&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8pVYfXHFZnJw6GmED4PucZvQd6m3AP8fUG1IKJyBgicmJ3P5ygQjO5r6Bib2x190MFOlb6PwExNQuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4362549287d1f3ea1882e0e2a617ab14</guid>
<title>系统设计之路：如何设计一个 URL 短链服务</title>
<link>https://toutiao.io/k/6mzds1m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;368&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6371428571428571&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/la8s6uvJibdSx2r2we2pt5ZE8BsiciarpJ62wyxsSibDVicGybHVQRHxGyFH2ianynf8O8IBq1icchnYHYeYU4qArNZAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;每当我们学习一门新的编程语言，做的第一件事情，就是写一个 “&lt;/span&gt;&lt;span&gt;Hello world&lt;/span&gt;&lt;span&gt;”&lt;span&gt; &lt;/span&gt;程序，先让它能 &lt;/span&gt;&lt;span&gt;Run&lt;/span&gt;&lt;span&gt; 起来，潘多拉魔盒打开之后，再深入学习语言的其他精髓。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;同样，我们在准备系统设计相关的面试时，“设计一个 &lt;/span&gt;&lt;span&gt;URL &lt;/span&gt;&lt;span&gt;短链服务” 往往就是那个 “&lt;/span&gt;&lt;span&gt;Hello world&lt;/span&gt;&lt;span&gt;”。吃下这道开胃菜，才能有胃口品尝后续更美味的 “系统设计” 大餐，比如：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设计 &lt;/span&gt;&lt;span&gt;News Feeds&lt;/span&gt;&lt;span&gt; 系统&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设计 &lt;/span&gt;&lt;span&gt;Twitter&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设计搜索框中的下拉提示&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设计 &lt;span&gt;12306&lt;/span&gt; 订票系统&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设计一个&lt;span&gt; KV &lt;/span&gt;存储系统&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设计一个图书推荐系统&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;闲话少叙，下面我们一起先尝尝这道 “开胃菜”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 什么是 &lt;span&gt;URL&lt;/span&gt;&lt;span&gt; &lt;/span&gt;短链&lt;/span&gt;&lt;/strong&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;URL &lt;/span&gt;&lt;span&gt;短链，就是把原来较长的网址，转换成比较短的网址。我们可以在短信和微博里可以经常看到短链的身影。如下图，我随便找了某一天躺在我短信收件箱里的短信。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;257&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4439178515007899&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdTQILKc709kIeEDib7nt584rdKxRu4aictlqLJlEqap1Q02U8w22XjpRibhsyFrSAW2icoLXTwcttuSibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;633&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图所示短信中，&lt;/span&gt;&lt;span&gt;https://j.mp/38Zx5XC&lt;/span&gt;&lt;span&gt;，就是一条短链。&lt;/span&gt;&lt;span&gt;用户点击蓝色的短链，就可以在浏览器中看到它对应的原网址：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;40&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.06896551724137931&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdTQILKc709kIeEDib7nt584rbnZHoZmiaKIjFZZIWHOj52UOM27BZia0torvznSKLLx9BOJVgYAzKJvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;493&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;那么为什么要做这样的转换呢？来看看短链带来的好处：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;当然，以上好处也只是相对的，这不，随着微信扫码能力的提升，微信已经开始取消短链服务了。&lt;/span&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;276&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.47833333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdTQILKc709kIeEDib7nt584rceaagNqMNsCf6tticUwCRIocIZrHkEUe8bsyf2qOZG9MGF7MGqIBRDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 短链跳转主要原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. &lt;/span&gt;&lt;span&gt;客户端（或浏览器）请求短链：&lt;/span&gt;&lt;span&gt;https://j.mp/38Zx5XC&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. &lt;/span&gt;&lt;span&gt;短链服务器收到请求后，返回 &lt;/span&gt;&lt;span&gt;status code: 301 &lt;/span&gt;&lt;span&gt;或 &lt;/span&gt;&lt;span&gt;302&lt;/span&gt;&lt;span&gt;，说明需要跳转，同时也通过 &lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt; 字段告知客户端：你要访问的其实是下面这个长网址&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;https://activity.icoolread.com/act7/212/duanxin/index&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;3. &lt;/span&gt;&lt;span&gt;客户端收到短链服务器的应答后，再去访问长网址：&lt;span&gt;https://activity.icoolread.com/act7/212/duanxin/index&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;428&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7410358565737052&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdT8lhiaFzW8rasuWC7zxvRj95G8DRWBEuSlHquJGokjdtD7ic51NKIcZy1wJYLhWEIK7upezJjDP27g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;502&quot;/&gt;&lt;span&gt;实际浏览器中的网络请求如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;348&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6025824964131994&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdRVwqyZOLmNKiaKHh9eMg2tHJwJo803oQpic1BjAYaL2wicGfvjfkvVSSccUaSNjLC9kXB0f4CsZg8eA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;3. URL&lt;/span&gt;&lt;span&gt; &lt;/span&gt;短链设计的需求&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;功能性需求：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;非功能性需求：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;4. &lt;/span&gt;系统容量预估&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们知道，做系统架构的时候，应该要让系统能扛住两方面的 “压力”：写请求的压力和读请求的压力。写请求是指将长 &lt;/span&gt;&lt;span&gt;URL &lt;/span&gt;&lt;span&gt;转换成短 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;，并将短 &lt;/span&gt;&lt;span&gt;URL &lt;/span&gt;&lt;span&gt;存到数据库。而读请求是指用户点击短 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; ，系统接到请求，从数据库中找到对应的长&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;，返回给用户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于一个 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;，通常情况下我们把它一次性转换好后，把它存到数据库就完事了（“写”）。接下来运营就会通过诸如短信、社交媒体等渠道将含有短链的内容发送给不同的用户，然后对内容感兴趣的用户会去点击该短链，继而跳转到目标页面（“读”）。这个系统的读请求要远高于写请求，是一个 “&lt;/span&gt;&lt;span&gt;Read-Heavy&lt;/span&gt;&lt;span&gt;” 的系统。这里，我们假设读写比是 &lt;/span&gt;&lt;span&gt;100 : 1&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;假设，我们的系统 &lt;/span&gt;&lt;span&gt;1 &lt;/span&gt;&lt;span&gt;个月需要处理 &lt;/span&gt;&lt;span&gt;30 M&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;万）&lt;/span&gt;&lt;span&gt;的写请求（长链生成短链服务），那么按照 &lt;/span&gt;&lt;span&gt;100 : &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; 的读写比例，我们每个月需要处理 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 跳转的次数为：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;100 * 30 M = 3B &lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;30 &lt;/span&gt;&lt;span/&gt;&lt;/em&gt;&lt;span&gt;亿&lt;/span&gt;&lt;em&gt;&lt;span&gt;）&lt;/span&gt;&lt;/em&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进而，我们可以估算出每秒需要处理的请求数（&lt;/span&gt;&lt;span&gt;Q&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;每秒的写请求（长链生成短链）： &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;30 &lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;&lt;span&gt;/ (&lt;/span&gt;&lt;/span&gt;&lt;span&gt;30 &lt;/span&gt;&lt;span&gt;days&lt;/span&gt;&lt;span&gt;* &lt;/span&gt;&lt;span&gt;24 &lt;/span&gt;&lt;span&gt;hours&lt;/span&gt;&lt;span&gt;* &lt;/span&gt;&lt;span&gt;60 &lt;/span&gt;&lt;span&gt;min&lt;/span&gt;&lt;span&gt;* &lt;/span&gt;&lt;span&gt;60 &lt;/span&gt;&lt;span&gt;sec&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;span&gt; ≅ &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;12 requests/second&lt;/span&gt;&lt;/em&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;每秒的读请求（短链跳转长链）：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;100 * &lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;ques&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt; /&lt;/span&gt;&lt;span&gt; second&lt;/span&gt;  = 1200 &lt;span&gt;r&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;ques&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;second&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来再估算一下需多少的存储空间。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;假设我们会默认保存 &lt;/span&gt;&lt;span&gt;5 &lt;/span&gt;&lt;span&gt;年内的短链转换记录，那么 &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; 年内产生的 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 数量：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;0 M&lt;/span&gt;&lt;span&gt; * 12 * 5 = 1,800,000,000&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么短链应该设计成多长，才能表示这 &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; 年内的这 &lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt; 亿的 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 呢？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;通常短链是用 [&lt;/span&gt;&lt;span&gt;0-9&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;a-z&lt;/span&gt;&lt;span&gt;], [&lt;/span&gt;&lt;span&gt;A-Z&lt;/span&gt;&lt;span&gt;] 这 &lt;/span&gt;&lt;span&gt;62 &lt;/span&gt;&lt;span&gt;个字符的组合来表示的，那么长度是 &lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt; 的短链可以映射的 &lt;/span&gt;&lt;span&gt;URL &lt;/span&gt;&lt;span&gt;数量如下图：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;table interlaced=&quot;enabled&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;N&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;可映射的&lt;/span&gt; &lt;span&gt;URL&lt;/span&gt; &lt;span&gt;数量&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;62^1 = 62&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;62^2 = 3,884&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;62^3 = 238,328&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;62^4 = 14,776,336&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;62^5 = 916,132,832&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;62^6 = 56,800,235,584&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;62^7 = 3,521,614,606,208&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;所以，理论上我们的短链设计成 &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt; 个字符就能满足需求了。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;接下来，我们再假设数据中的一条记录的平均长度为 5&lt;/span&gt;&lt;span&gt;00 bytes&lt;/span&gt;&lt;span&gt;（每条记录包含长 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; ，短 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;，记录创建时间，过期时&lt;/span&gt;&lt;span&gt;间等信息）&lt;/span&gt;&lt;span&gt;。那么，存储空间至少需要：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;0 M&lt;/span&gt;&lt;span&gt; * 12 * 5&lt;/span&gt; * &lt;span&gt;500&lt;/span&gt; =&lt;span&gt; 0.9 T&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;再预估一下需要多大的网络带宽。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;入网带宽：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;12 * 500 &lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt;bytes = 6 KB/s = 48 Kbps&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;出网带宽：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;1200 * 500 bytes = 600 KB/s = 4.8 Mbps&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里延伸一下：通常情况下，服务器云厂商的入网带宽是不收费的，而出网带宽需要计费。出网带宽可以实时调整，我们可以读请求的根据实际情况，即时调整出网带宽。入网带宽会根据入网带宽，做动态的调整。比如阿里云的 &lt;/span&gt;&lt;span&gt;ECS&lt;/span&gt;&lt;span&gt;，如果出网带宽的峰值小于 &lt;/span&gt;&lt;span&gt;10Mbps&lt;/span&gt;&lt;span&gt;，那么入网带宽就是 &lt;/span&gt;&lt;span&gt;10Mbps&lt;/span&gt;&lt;span&gt;，当出网带宽峰值大于 &lt;/span&gt;&lt;span&gt;10Mbps&lt;/span&gt;&lt;span&gt;时，入网带宽会调成和出网峰值相等的带宽。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;另外，为了保证读请求的快速响应，我们还需要把一些经常访问的记录&lt;/span&gt;&lt;span&gt;在内存中缓存起来。根据 &lt;/span&gt;&lt;span&gt;2-8&lt;/span&gt;&lt;span&gt; 原则，我们把每天访问量前 &lt;/span&gt;&lt;span&gt;20%&lt;/span&gt;&lt;span&gt; 的记录缓存起来，那么需要的内存空间为：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;100 * 3&lt;/span&gt;&lt;span&gt;0 M / 30 * 0.2 * 500 bytes = 10 G&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;综上，我们预估的与系统容量相关的各参数罗列如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;每月长链&lt;strong&gt;生成&lt;/strong&gt;短链的请求量：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;30 million&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;每月短链跳转长链的请求量：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;3 billion&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;读写请求比：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;100:1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;每秒长链生成短链的请求量：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;12 requests/second&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;每秒&lt;strong&gt;短链跳转长链&lt;/strong&gt;的请求量：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;1.2K requests/second&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;年内生成的 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;URL&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt; 短链数：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;1.8&lt;/span&gt;&lt;span&gt; billion&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;存储长短链映射关系的一条记录所需的空间：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;0.5K bytes&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt; 年内所需的存储空间&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0.9 T bytes&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;出网带宽&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;4.8 Mbps&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;缓存空间：&lt;/span&gt;&lt;/strong&gt;&lt;em&gt;&lt;span&gt;10 G&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;5. &lt;/span&gt;“裸奔”的架构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不考虑系统优化，先画一下最基础的架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;298&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5161764705882353&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdT8lhiaFzW8rasuWC7zxvRj9PYd2cCstpOmntU4kCX27fz5SZAs1c0MRck12kDkaR7T0RFNkT4ibNZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;6. API &lt;/span&gt;设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;接口 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：根据原始 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;，生成短链&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;POST    &lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&lt;span&gt;api/v0/shorten&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;接口 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：根据短链，返回原始 &lt;span&gt;URL&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;    &lt;strong&gt;GET    &lt;/strong&gt;&lt;em&gt;&lt;span&gt;api/v0/shortUrl&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;shortUr&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;l&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;(&lt;span&gt;String&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;: &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;短链，不为&lt;/span&gt;&lt;span&gt;空。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7. &lt;/span&gt;模块详细设计&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设计短链生成算法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;设计的短链生成算法，本质上是为了寻找一种映射关系，能将原始 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 和生成的短链对应起来。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;110&quot; data-backw=&quot;540&quot; data-ratio=&quot;0.20317460317460317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdRHGSaXn1kuFcBfVltscQLch3D3LicnOibKBD9Ke5ic3SocqAarhFvFGtfAw3Mn4eegSLQJNZdRJSMVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图中的 &lt;em&gt;&lt;span&gt;f(x) &lt;/span&gt;&lt;/em&gt;表示短链生成算法，可以是具体的函数，也可以是一些规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我们来分析一下目前短链生成算法一些主流的方案。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案1：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 算法&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最容易想到的是用 &lt;/span&gt;&lt;span&gt;MD5&lt;/span&gt;&lt;span&gt; 算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;输入的长 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 经过 &lt;/span&gt;&lt;span&gt;MD5&lt;/span&gt;&lt;span&gt; 算法的处理，会输出一串长度为 &lt;/span&gt;&lt;span&gt;128 bit&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;16 B&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;的字符串。&lt;/span&gt;&lt;span&gt;128 bit&lt;/span&gt;&lt;span&gt; 的 &lt;/span&gt;&lt;span&gt;MD&lt;/span&gt;&lt;span&gt;5 &lt;/span&gt;&lt;span&gt;经过 &lt;/span&gt;&lt;span&gt;Base62&lt;/span&gt;&lt;span&gt; 转换，会生成 &lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt; 位的字符串。&lt;/span&gt;&lt;span&gt;What&#x27;s the f**k&lt;/span&gt;&lt;span&gt;？ 怎么一顿骚操作之后反而变长了？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于我们的短链长度是&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;&lt;span&gt; 位，一种方案是，我们可以从 &lt;/span&gt;&lt;span&gt;22 &lt;/span&gt;&lt;span&gt;位字符中取出前 &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt; 位即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么问题来了，这种操作引起 &lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt; 冲突的概率还是挺高的，就是说两个长 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 经过 &lt;/span&gt;&lt;span&gt;MD5&lt;/span&gt;&lt;span&gt; 后，再经过&lt;/span&gt;&lt;span&gt; Base62 &lt;/span&gt;&lt;span&gt;转换，生成串 &lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;，如果 &lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt; 的前 &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt; 位一样，即使后面的 &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt; 位有差别，那么两个原本不一样的 &lt;/span&gt;&lt;span&gt;URL &lt;/span&gt;&lt;span&gt;还是会映射到同一个短链上。这是不允许的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为解决这个问题，我们可以在检测到冲突时，在输入的原始 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 后面拼接一个特殊的标记，比如：&lt;strong&gt;[精确到毫秒的时间戳]&lt;/strong&gt; 或 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;[客户端 &lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，然后重新&lt;/span&gt;&lt;span&gt; Hash&lt;/span&gt;&lt;span&gt;，这样冲突的概率就会降低，如果碰上好运再发生冲突，那就继续用一样的方式在&lt;/span&gt; &lt;span&gt;URL &lt;/span&gt;&lt;span&gt;后再加标记。对应的，通过短链获取长链时，我们需把长链尾部这些特殊标记去掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看出来，&lt;/span&gt;&lt;span&gt;MD5&lt;/span&gt;&lt;span&gt; 这种解决方案，不太优雅，而且效率不高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一种改进的方案是采用 &lt;/span&gt;&lt;span&gt;Google&lt;/span&gt;&lt;span&gt; 的 &lt;/span&gt;&lt;span&gt;MurmurHash&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;MD5 &lt;/span&gt;&lt;span&gt;是加密型哈希函数，主要关注加解密的安全性，所以会牺牲很多性能。而 &lt;span&gt;M&lt;/span&gt;&lt;span&gt;ur&lt;/span&gt;&lt;span&gt;mur&lt;/span&gt;&lt;span&gt;Has&lt;/span&gt;&lt;span&gt;h&lt;/span&gt; &lt;/span&gt;&lt;span&gt;是一种非加密型哈希函数，适用于一般的&lt;/span&gt;&lt;span&gt;哈希&lt;/span&gt;&lt;span&gt;检索操作。与其它流行的哈希函数相比，对于长度较长的 &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;MurmurHash&lt;/span&gt;&lt;span&gt; 的随机分布特征表现更良好，发生 &lt;/span&gt;&lt;span&gt;Hash &lt;/span&gt;&lt;span&gt;碰撞的几率更低。比起 &lt;span&gt;MD5&lt;/span&gt;，它的性能至少提升了&lt;/span&gt;&lt;span&gt;一个数量级。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;MurmurHash&lt;/span&gt; 的最新版本是 &lt;span&gt;MurmurHash3&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，提供了 &lt;span&gt;32 bit, &lt;/span&gt;&lt;span&gt;128 bit &lt;/span&gt;这两种长度的哈希值。&lt;/span&gt;&lt;span&gt;URL &lt;/span&gt;&lt;span&gt;经过&lt;span&gt; MurmurHash&lt;/span&gt; 计算后会生成一个整数。&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;bit&lt;/span&gt;&lt;span&gt; 可以表示的数值范围为 &lt;/span&gt;&lt;span&gt;0 ~ 4294967295&lt;/span&gt;&lt;span&gt;, 约&lt;/span&gt; &lt;span&gt;43 &lt;/span&gt;&lt;span&gt;亿，而基于我们前面的估计，系统 &lt;/span&gt;&lt;span&gt;5 &lt;/span&gt;&lt;span&gt;年内生成的 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 数量约 &lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt; 亿，所以选择 &lt;/span&gt;&lt;span&gt;32bit&lt;/span&gt;&lt;span&gt; 的哈希值就足以满足需求了。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;接下来，我们需要把经过 &lt;span&gt;MurmurHash&lt;/span&gt; 生成的数字转化为 &lt;/span&gt;&lt;span&gt;Base62&lt;/span&gt;&lt;span&gt; 的字符。即 &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt; 进制的 &lt;/span&gt;&lt;span&gt;0~9&lt;/span&gt;&lt;span&gt; 对应 &lt;/span&gt;&lt;span&gt;62&lt;/span&gt;&lt;span&gt; 进制的 &lt;/span&gt;&lt;span&gt;0~9&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt; 进制的 &lt;/span&gt;&lt;span&gt;10~35&lt;/span&gt;&lt;span&gt; 对应 &lt;/span&gt;&lt;span&gt;62&lt;/span&gt;&lt;span&gt; 进制的 &lt;/span&gt;&lt;span&gt;a~z&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt; 进制的 &lt;/span&gt;&lt;span&gt;36~61&lt;/span&gt;&lt;span&gt; 对应 &lt;/span&gt;&lt;span&gt;62&lt;/span&gt;&lt;span&gt; 进制的 &lt;/span&gt;&lt;span&gt;A~Z&lt;/span&gt;&lt;span&gt;。假设长 &lt;/span&gt;&lt;span&gt;UR&lt;/span&gt;&lt;span/&gt;&lt;span&gt;L &lt;/span&gt;&lt;span&gt;经过 &lt;span&gt;MurmurHash&lt;/span&gt; 后生成的数字为：&lt;/span&gt;&lt;span&gt;2134576890, &lt;/span&gt;&lt;span&gt;那么&lt;/span&gt;&lt;span&gt;经过转换后生成的短链为 &lt;/span&gt;&lt;span&gt;2kssXw&lt;/span&gt;&lt;span&gt;，转换过程如下：&lt;/span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;269&quot; data-backw=&quot;540&quot; data-ratio=&quot;0.49875311720698257&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdT8lhiaFzW8rasuWC7zxvRj9Q82FITMGj9oNBHRhA3HWJvPLpspAxenXgWmvw19ryC2ElUkVckdMJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;401&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这样，基于 &lt;span&gt;MurmurHash&lt;/span&gt; 的方案已经能较好地满足需求了。在系统运行前期，由于 &lt;/span&gt;&lt;span&gt;43&lt;/span&gt;&lt;span&gt; 亿的 &lt;/span&gt;&lt;span&gt;Hash slot&lt;/span&gt;&lt;span&gt; 没有完全填满，所以一般不会出现 &lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt; 冲突，系统运行 &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;6 &lt;/span&gt;&lt;span&gt;年后，由于 &lt;/span&gt;&lt;span&gt;Hash slot&lt;/span&gt;&lt;span&gt; 不断被占用，可能会出现一些 &lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt; 冲突。这时，一方面，我们需要删除过期的短链（超过 &lt;/span&gt;&lt;span&gt;5 &lt;/span&gt;&lt;span&gt;年），释放一些 &lt;/span&gt;&lt;span&gt;Hash slot&lt;/span&gt;&lt;span&gt;，另一方面，出现冲突的时候也可以按照上述原 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 后面拼接特殊标记的方式，重新计算 &lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt; 值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案2：全局自增 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;ID&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;不同于 &lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt; 算法，全局自增&lt;/span&gt;&lt;span&gt; ID &lt;/span&gt;&lt;span&gt;的方案不需要对长 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 进行 &lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt; 转换。因为 &lt;/span&gt;&lt;span&gt;ID &lt;/span&gt;&lt;span&gt;全局自增且唯一，它天然就能确保一个 &lt;/span&gt;&lt;span&gt;ID &lt;/span&gt;&lt;span&gt;只映射一个长 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;，不存在之前 &lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt; 方案中存在的多个长 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 可能映射到同一个短链的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于全局自增 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt; 方案的整体设计思路是这样的：&lt;/span&gt;&lt;span&gt;&lt;span&gt;我们先&lt;/span&gt;&lt;/span&gt;&lt;span&gt;维护一个 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt; 自增生成器，这个自增生成器采用一定的算法来生成全局自增的 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;，比如用数据库的自增 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;，或用 &lt;/span&gt;&lt;span&gt;Zookeeper&lt;/span&gt;&lt;span&gt; 来计数，或用 &lt;/span&gt;&lt;span&gt;Redis &lt;/span&gt;&lt;span&gt;中具有原子操作&lt;/span&gt;&lt;span&gt;的 &lt;/span&gt;&lt;span&gt;incby&lt;/span&gt;&lt;span&gt;，或使用 &lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt; 中的 &lt;/span&gt;&lt;span&gt;AtomicLong&lt;/span&gt;&lt;span&gt;，或采用基于 &lt;/span&gt;&lt;span&gt;CAS&lt;/span&gt;&lt;span&gt; 的乐观锁思想自己实现一个自增计数算法，等等。&lt;/span&gt;&lt;span&gt;总之，经过 &lt;/span&gt;&lt;span&gt;&lt;span&gt;ID &lt;/span&gt;&lt;/span&gt;&lt;span&gt;生成器后&lt;/span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;它可以输出 &lt;/span&gt;&lt;span&gt;1、2、3、4…&lt;/span&gt;&lt;span&gt;这样自增的整数 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当短链服务接收到一个原始 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 转短 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 的请求后，它先从 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt; 生成器中取一个号，然后将其转化成 &lt;/span&gt;&lt;span&gt;62&lt;/span&gt;&lt;span&gt; 进制表示法，我们把它称为短链的 &lt;/span&gt;&lt;span&gt;Key (&lt;/span&gt;&lt;span&gt;比如: &lt;/span&gt;&lt;span&gt;&lt;span&gt;2kssXw&lt;/span&gt;)&lt;/span&gt;&lt;span&gt;，再把这个 &lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt; 拼接到短链服务的域名（比如新浪微博短域名 &lt;/span&gt;&lt;span&gt;http://t.cn/&lt;/span&gt;&lt;span&gt;）后面，就形成了最终的短网址，比如：&lt;span&gt;http://t.cn/&lt;span&gt;2kssXw&lt;/span&gt;&lt;/span&gt;。最后，把生成的短 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 和对应的原始 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 存到数据库中。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;基于全局自增&lt;/span&gt; &lt;span&gt;ID&lt;/span&gt;&lt;span&gt; 的方案，整体的设计思路很清晰，实现起来难度也不大，比如采用 &lt;/span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span&gt; 作为发号器，单机的 &lt;/span&gt;&lt;span&gt;QPS&lt;/span&gt;&lt;span&gt;  可以逼近 &lt;/span&gt;&lt;span&gt;10w&lt;/span&gt;&lt;span&gt;，所以性能也是很不错的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，这种方案还存在两方面的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：发号器的&lt;/span&gt; &lt;span&gt;ID &lt;/span&gt;&lt;span&gt;是在自增的，来一个 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 请求，不管 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 有没有重复，发号器每次都会发一个不一样的 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;。这样，如果相同的&lt;/span&gt; &lt;span&gt;URL &lt;/span&gt;&lt;span&gt;&lt;span&gt;多次&lt;/span&gt;&lt;span&gt;请求&lt;/span&gt;&lt;span&gt;短链服务，每次都会生成&lt;/span&gt;&lt;span&gt;不一样&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;短链&lt;/span&gt;&lt;span&gt;。如果有人搞破坏，用同一个 &lt;/span&gt;&lt;span&gt;URL &lt;/span&gt;&lt;span&gt;反复请求短链服务，就可以很轻松地把短链服务的 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt; 资源耗尽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：短链后面的 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt; 单调增长，太有规律了，可以被预测到。这样攻击者就可以很容易猜到别人的短链，进而可以发起对原网址的非正常访问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，怎么解决这两个问题呢？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于问题 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;，我们第一时间的反应，就是给数据库中的长 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 字段也加一个索引，确保重复的长 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 无法插入到数据库，保证了短 &lt;/span&gt;&lt;span&gt;U&lt;/span&gt;&lt;span&gt;RL&lt;/span&gt;&lt;span&gt; 和长 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 之间一对一的映射关系。但是，由于多加了一个长 &lt;span&gt;URL&lt;/span&gt; 字段的索引，一方面创建索引树需&lt;/span&gt;&lt;span&gt;占用更多的存储空间，另一方面，由于索引字段内容太多，导致数据库的一个 &lt;/span&gt;&lt;span&gt;Page&lt;/span&gt;&lt;span&gt; （比如 &lt;/span&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;span&gt; 的 &lt;/span&gt;&lt;span&gt;Innodb&lt;/span&gt;&lt;span&gt;，一个 &lt;/span&gt;&lt;span&gt;Page &lt;/span&gt;&lt;span&gt;默认是 &lt;/span&gt;&lt;span&gt;16K&lt;/span&gt;&lt;span&gt;）能包含的记录数减少，当有新的插入、删除操作时，就很容易产生分页，导致性能的下降。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实，我们也可以不去处理重复 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 的问题。&lt;/span&gt;&lt;span&gt;实际上，多数情况下&lt;/span&gt;&lt;span&gt;用户只关心短链能否正确地跳转到原始网址。至于短链长什么样，重不重复，&lt;/span&gt;&lt;span&gt;用户&lt;/span&gt;&lt;span&gt;其实根本就不 &lt;/span&gt;&lt;span&gt;care&lt;/span&gt;&lt;span&gt;。所以，即便是同一个原始 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;，两次生成的短链不一样，也并不会影响到用户的使用。在这个思路下，我们就可以不用去给长 &lt;/span&gt;&lt;span&gt;URL &lt;/span&gt;&lt;span&gt;字段加索引了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，长 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 字段不加索引后，我们就要做些额外的工作，来防止同一个长 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 转短链的次数太多，导致短链 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt; 资源耗尽的问题。我们可以在短链服务前加一个布隆过滤器（&lt;/span&gt;&lt;span&gt;Bloom Filter&lt;/span&gt;&lt;span&gt;）。布隆过滤器基于位操作，即省空间，操作效率也高。当长 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 转换短链的请求打过来的时候，先判断布隆过滤器里有没有这个 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;， 如果没有&lt;/span&gt;&lt;span&gt;，那么说明这个长 &lt;/span&gt;&lt;span&gt;URL &lt;/span&gt;&lt;span&gt;还没有转换过，接下来短链服务就给它生成一个对应的短链。如果布隆过滤器判断该 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 已经存在了，那么就不再给它分配新的自增 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，布隆过滤器有一个“假真”的特性：如果它判断过滤器中存在某个 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;，而事实上这个 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 却&lt;/span&gt;&lt;span&gt;可能不存在。为什么会这样？因为多个 &lt;/span&gt;&lt;span&gt;URL &lt;/span&gt;&lt;span&gt;经过散列后，某些比特位会被置为&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;，而这些是 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; 的比特位组成的散列值可能刚好和这个待判断 &lt;/span&gt;&lt;span&gt;URL &lt;/span&gt;&lt;span&gt;的散列值一样。不过呢，这个概率可以通过调整过滤器的比特位长度，变得很小很小，小到可以忽略不计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至于问题 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;，我们可以引入随机算法来解决。&lt;/span&gt;&lt;span&gt;在得到自增 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt; 对应的 &lt;/span&gt;&lt;span&gt;62 &lt;/span&gt;&lt;span&gt;进制的字符串后，再将字符串中的每个字符转换为二进制数。然后在固定位，比如第 &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; 位，第 &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt; 位，第 &lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt; 位，... 等等，插入一个随机值即可。相应的，解码的时候，需要将固定位的值去掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案3：离线生成 &lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案 &lt;/span&gt;&lt;span&gt;1 &lt;/span&gt;&lt;span&gt;和 &lt;/span&gt;&lt;span&gt;2 &lt;/span&gt;&lt;span&gt;都是基于 &lt;/span&gt;&lt;span&gt;Online&lt;/span&gt;&lt;span&gt; 的方案，即来一个请求，根据一定的算法实时生成一个短链。为了进一步提升短链 &lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt; 的生成效率，而不必非得用到的时候才去生成 &lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;，我们可以换一个思路：通过 &lt;/span&gt;&lt;span&gt;Offline&lt;/span&gt;&lt;span&gt; 的方式，预先生成一批没有冲突的短链 &lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，等长 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 转短 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 的请求打过来的时候，就从预先生成的短链 &lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt; 中，选取一个还没使用的 &lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;，把映射关系写到数据库。这样，我们就完全不用担心方案 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; 中出现的 &lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt; 冲突&lt;/span&gt;&lt;span&gt;问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们把这种通过 &lt;/span&gt;&lt;span&gt;Offline&lt;/span&gt;&lt;span&gt; 方式生成短链 &lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt; 的服务，叫做 &lt;/span&gt;&lt;span&gt;Key Generating Service&lt;/span&gt;&lt;span&gt;，简称 &lt;/span&gt;&lt;span&gt;KGS&lt;/span&gt;&lt;span&gt;。通过 &lt;/span&gt;&lt;span&gt;KGS&lt;/span&gt;&lt;span&gt; 生成的短链 &lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;，放在&lt;/span&gt;&lt;span&gt; Key DB&lt;/span&gt;&lt;span&gt; 中。整个流程如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdTptL8htnEycwibCKngjmyh4tENLmVIVZhP1s3YsYmOHYMapM3DM4KkF1DTHwIn5PI6epduojQfhog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5202821869488536&quot; data-w=&quot;567&quot; data-backw=&quot;540&quot; data-backh=&quot;281&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们知道，基于 &lt;/span&gt;&lt;span&gt;Base62&lt;/span&gt;&lt;span&gt;，总共可以产生 &lt;em&gt;&lt;span&gt;62 ^ 6 &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;种不同的 &lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;， 所以&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt; &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;KeyDB&lt;/span&gt;&lt;span&gt; 中存储所有 &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt; 位 &lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt; 所需的空间为：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;(62 ^ 6) * 6 byte &lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;≅ &lt;/span&gt;&lt;/span&gt;&lt;/em&gt; 317 G&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;另外，对比基于自增 &lt;span&gt;ID&lt;/span&gt; 的方案，增加了 &lt;span&gt;2 &lt;/span&gt;次同步的网络请求（&lt;span&gt;WebServer -&amp;gt; KGS &lt;/span&gt;和&lt;span&gt; KGS -&amp;gt; KeyDB&lt;/span&gt;）。那么，这 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; 次请求是否有办法优化？ &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以采用“预加载”的方法，让 &lt;span&gt;KGS &lt;span&gt;每次从 &lt;span&gt;KeyDB &lt;span&gt;请求 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Key &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;时，不要只拿一个，而是一次多拿一些，比如 &lt;/span&gt;&lt;span&gt;&lt;span&gt;1000 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;个，然后放进 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;KGS&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 服务器的本地内存中，数据结构可以是阻塞队列。&lt;span&gt;KeyDB &lt;span&gt;会将这 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 个 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 标记为已使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;更进一步，其实 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;WebServer&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 也可以从 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;KGS&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 中一次多拿一些未使用的 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，比如每次返回 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;20&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 个，放在 &lt;span&gt;We&lt;/span&gt;&lt;span/&gt;&lt;span&gt;bServer &lt;/span&gt;的本地内存。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;当 &lt;span&gt;We&lt;/span&gt;&lt;span/&gt;&lt;span&gt;bServer &lt;/span&gt;阻塞队列中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 快用完的时候，再向 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;K&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;GS&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 请求再拿 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 个 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。同样的，&lt;span&gt;KGS &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 快用完的时候，再向 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;KeyDB&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 请求再 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;1000 &lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;个 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;span&gt;&lt;span&gt;这样，经过“预加载”优化之后，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;2 &lt;/span&gt;&lt;span&gt;&lt;span&gt;次同步网络请求就变成 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;0 &lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;次，达到了将同步请求“异步化”的效果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;那么，“预加载”会有什么问题呢？毕竟数据是放在内存中的，如果服务器因故障重启，那么这些“预加载”的 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 就丢失了，虽然这些 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; 还没有真正被使用，但是 &lt;span&gt;Ke&lt;/span&gt;&lt;span&gt;yDB &lt;span&gt;已经将它们标记为已使用，所以这些丢失的 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Key &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;最后就被浪费掉了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那怎么应对这种意外情况呢？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一种办法是，&lt;/span&gt;&lt;span&gt;&lt;span&gt;KGS &lt;/span&gt;&lt;/span&gt;&lt;span&gt;从 &lt;/span&gt;&lt;span&gt;&lt;span&gt;KeyDB&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 批量拿 &lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 的时候，&lt;/span&gt;&lt;span&gt;&lt;span&gt;KeyDB&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 不要先将这些&lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 标记为已使用。&lt;/span&gt;&lt;span&gt;&lt;span&gt;KGS&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;span&gt;&lt;span&gt;WebServer&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 在真正使用了一个 &lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 之后，再异步地将 &lt;/span&gt;&lt;span&gt;&lt;span&gt;KeyDB&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 中的这个 &lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 标记为已使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;另一种办法是：&lt;strong&gt;不处理&lt;/strong&gt;。相对于 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;568&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; 亿的总量，偶尔浪费 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; 个 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，其实影响不大，况且服务器又不是天天宕机重启。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;所以说，架构其实是一种根据实际情况，不断权衡利弊的过程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.  数据库表设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有两个公用的数据库：&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;AppKey&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;DB&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;UrlMappingDB&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;span/&gt;&lt;span&gt;AppKey&lt;/span&gt;&lt;span&gt;DB &lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;用于管理用户的 &lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;AppKey&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，防止非法用户调用长链转短链接口。&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Url&lt;/span&gt;&lt;span&gt;Mapping&lt;/span&gt;&lt;span&gt;DB &lt;/span&gt;用于存放短链 &lt;span&gt;Key&lt;/span&gt; 和原始 &lt;span&gt;URL&lt;/span&gt; 的映射关系。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果我们采用基于 &lt;/span&gt;&lt;span&gt;&lt;span&gt;KGS&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 的方案，还需要设计一个数据库：&lt;/span&gt;&lt;span&gt;&lt;span&gt;KeyDB&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;用于存放预先生成的短链 &lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;AppKeyD&lt;/span&gt;&lt;span&gt;&lt;span&gt;B&lt;/span&gt; 中只有一张表：&lt;span&gt;t_user_appkey&lt;/span&gt;，&lt;/span&gt;&lt;span&gt;UrlMappingDB&lt;/span&gt;&lt;span&gt; 中只有一张表：&lt;/span&gt;&lt;span&gt;t_url_mapping&lt;/span&gt;&lt;span&gt;，表结构如下：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`t_user_appkey`&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;`id`&lt;/span&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; AUTO_INCREMENT &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;用户id&#x27;&lt;/span&gt; ,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;`app_key`&lt;/span&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;32&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; ,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;`status`&lt;/span&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;bit&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;账号状态：0 正常，1 异常&#x27;&lt;/span&gt; ,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;`gmt_create`&lt;/span&gt;  datetime &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;创建日期&#x27;&lt;/span&gt; ,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;PRIMARY &lt;span class=&quot;code-snippet__keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;`id`&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`t_url_mapping`&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;`key`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;code-snippet__built_in&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;SET&lt;/span&gt; utf8 &lt;span class=&quot;code-snippet__keyword&quot;&gt;COLLATE&lt;/span&gt; utf8_general_ci &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;短链key&#x27;&lt;/span&gt; ,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;`original_url`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;512&lt;/span&gt;) &lt;span class=&quot;code-snippet__built_in&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;SET&lt;/span&gt; utf8 &lt;span class=&quot;code-snippet__keyword&quot;&gt;COLLATE&lt;/span&gt; utf8_general_ci &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;原始url&#x27;&lt;/span&gt; ,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;`gmt_created`&lt;/span&gt; datetime &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;创建时间&#x27;&lt;/span&gt; ,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;`gmt_expired`&lt;/span&gt; datetime &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;key失效日期&#x27;&lt;/span&gt; ,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;PRIMARY &lt;span class=&quot;code-snippet__keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;`key`&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;ENGINE&lt;/span&gt;=&lt;span class=&quot;code-snippet__keyword&quot;&gt;InnoDB&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;SET&lt;/span&gt;=utf8 &lt;span class=&quot;code-snippet__keyword&quot;&gt;COLLATE&lt;/span&gt;=utf8_general_ci&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ROW_FORMAT=&lt;span class=&quot;code-snippet__keyword&quot;&gt;COMPACT&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;KeyDB&lt;/span&gt;&lt;span&gt;&lt;span&gt;中有两张结构一样的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;表：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;t_valid_keys &lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt; &lt;span&gt;t_unvalid&lt;/span&gt;&lt;span&gt;_keys&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;。&lt;span&gt;表结构很简单，&lt;/span&gt;&lt;span&gt;只有&lt;/span&gt;&lt;span&gt;一个字段 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;key&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;t_valid_keys &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;用于存放还没有被分配掉的短链&lt;/span&gt;&lt;span&gt; Key&lt;/span&gt;&lt;span&gt;，可以预先生成。&lt;span&gt;单机情况下，一般不会&lt;/span&gt;&lt;span&gt;一下子生成所有的&lt;/span&gt;&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt;&lt;span&gt;，而是根据规则分批去生成 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;&lt;span&gt;，比如固定某两位生成一批，这样 &lt;span&gt;t_valid_keys &lt;/span&gt;单表的记录数量最多在千万的量级。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;t_unvalid_key&lt;/span&gt;&lt;span&gt;s &lt;span&gt;用于存放已经使用的 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;KGS&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; 每次向 &lt;span&gt;t_valid_keys&lt;/span&gt; 请求没被使用的 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&lt;span&gt;，请求返回的同时将这些 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;Key &lt;/span&gt;&lt;span&gt;&lt;span&gt;写到 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;t_unvalid_keys &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;中。当 &lt;span&gt;t_unvalid_key&lt;/span&gt;&lt;span&gt;s &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;中的数据达到千万的量级后，需要分表，或者一开始就设计好分表规则。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`t_valid_keys `&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;`key`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;code-snippet__built_in&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;SET&lt;/span&gt; utf8 &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;有效的key&#x27;&lt;/span&gt; ,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;PRIMARY &lt;span class=&quot;code-snippet__keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;`key`&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`t_unvalid_keys `&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;`key`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;code-snippet__built_in&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;SET&lt;/span&gt; utf8 &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;失效的key&#x27;&lt;/span&gt; ,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;PRIMARY &lt;span class=&quot;code-snippet__keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;`key`&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;9. &lt;/span&gt;考虑系统扩展的问题&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至此，我们分析了短链服务主要模块的设计。接下来再来考虑系统的可用性和性能问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于前面的系统容量预估，我们知道 &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; 年内所需的存储空间&lt;/span&gt;&lt;span&gt;是 &lt;/span&gt;&lt;span&gt;TB&lt;/span&gt;&lt;span&gt; 级别的，其中最主要是要存储长 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 和短 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 之间的映射关系，单个 &lt;span&gt;&lt;span&gt;UrlMappingDB&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 和单张 &lt;span&gt;t_url_mapping &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;是搞不定的，这时就需要考虑分库分表的方案。而且，在短链服务这个项目背景下，一开始就需要设计分库分表的方案。&lt;/span&gt;&lt;span&gt;分库主要是为了解决数据库“写”的压力，分表是为了解决“读”的压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，需要分几个库，几个表？分库分表的策略是什么？&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;分库的策略一般是垂直分库，不同的服务对应不同的数据库。短链服务主要需要两个数据库：保存长短链关系的 &lt;span&gt;&lt;span&gt;UrlMappingDB&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;和 保存短链 &lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 使用记录的 &lt;/span&gt;&lt;span&gt;&lt;span&gt;KeyDB&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。考虑到单个 &lt;span&gt;&lt;span&gt;UrlMappingDB&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 的数据量比较大，同时分散写数据库的压力， 我们还需继续将 &lt;span&gt;UrlMappingDB &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;拆成多个库。分库的个数需结合分表的个数来考虑。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;至于分表，一个原则就是尽量让单表的记录在 &lt;/span&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 千万以下（至于深层的原理，可以结合 &lt;/span&gt;&lt;span&gt;Page&lt;/span&gt;&lt;span&gt; 大小和 &lt;/span&gt;&lt;span&gt;B+&lt;/span&gt;&lt;span&gt; 树索引机制）。短链服务中，可以分成 &lt;/span&gt;&lt;span&gt;256&lt;/span&gt;&lt;span&gt; 张表，这样每张表的记录数为：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;1.8&lt;/span&gt;&lt;span&gt; billion&lt;/span&gt; / 256 = &lt;/span&gt;&lt;span&gt;7, 031, 250&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即单表记录约为&lt;/span&gt;&lt;span&gt; 700 &lt;/span&gt;&lt;span&gt;万。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;t_url_mapping &lt;/span&gt;分表的 &lt;/span&gt;&lt;span&gt;&lt;span&gt;key &lt;/span&gt;&lt;/span&gt;&lt;span&gt;可以使用短链 &lt;/span&gt;&lt;span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 或创建时间来计算 &lt;/span&gt;&lt;span&gt;hash&lt;/span&gt;&lt;span&gt;，通过一致性 &lt;/span&gt;&lt;span&gt;Hash &lt;/span&gt;&lt;span&gt;算法把记录路由到对应的分表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样，一个分库分表的规则就是：把 &lt;span&gt;&lt;span&gt;UrlMappingDB&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; 分成 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;4 &lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;个库，即：&lt;/span&gt;&lt;span&gt;&lt;span&gt;UrlMappingDB_00&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;UrlMappingDB&lt;/span&gt;&lt;span&gt;&lt;span&gt;_&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;01&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;UrlMappingDB_02&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;U&lt;/span&gt;&lt;span&gt;rl&lt;/span&gt;&lt;span&gt;MappingDB_03。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;各个分库和分表的对应关系如下：&lt;/span&gt;&lt;/p&gt;&lt;table align=&quot;center&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;分库&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;分表&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;UrlMappingDB_00&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;t_url_mapping_000 ~ &lt;/span&gt;&lt;span&gt;t_url_mapping_063&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;UrlMappingDB_01&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;t_url_mapping_064 ~ &lt;/span&gt;&lt;span&gt;t_url_mapping_127&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;UrlMappingDB_02&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;t_url_mapping_128 ~ &lt;/span&gt;&lt;span&gt;t_url_mapping_191&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;UrlMappingDB_03&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;t_url_mapping_192 ~ &lt;/span&gt;&lt;span&gt;t_url_mapping_256&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;OK&lt;/span&gt;&lt;span&gt;， &lt;span&gt;UrlMappingDB &lt;/span&gt;&lt;/span&gt;&lt;span&gt;的分库分表已经搞定&lt;/span&gt;&lt;span&gt;。但是目前数据还存在单点故障的风险，因为我们没有做备份，如果某个分库所在的机器宕机了，那么这个分库的所有数据就丢了。所以我们还需要将分库的数据 &lt;/span&gt;&lt;span&gt;copy&lt;/span&gt;&lt;span&gt; 一份或多份，做好冗余。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据的备份可以采用常见的中心化的主从架构，也可以采用基于去中心化的 &lt;/span&gt;&lt;span&gt;NWR&lt;/span&gt;&lt;span&gt; 机制。至于主从之间怎么同步数据，用什么共识机制来选主，&lt;span&gt;NWR &lt;/span&gt;&lt;/span&gt;&lt;span&gt;机制下&lt;/span&gt;&lt;span&gt;多个节点之间怎么同步数据等问题，这里就不再展开了，后面有单独的文章来探讨这些话题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在设计短链生成算法的环节，介绍了 &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; 种短链生成算法，方案 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; 使用 &lt;/span&gt;&lt;span&gt;MurmurHash&lt;/span&gt;&lt;span&gt;，做成分布式服务相对简单，一样的服务只要多部署几台机器，前面加个 &lt;/span&gt;&lt;span&gt;Nginx &lt;/span&gt;&lt;span&gt;做负载均衡就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;372&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6427586206896552&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdSIJrqTguPZXLzZYclubctic8PTfethKcNvQKgmiaNqVZY4qibcueLS4p3CFBnDw4tzYPjZeJyJCZeMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;725&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果用自增 &lt;span&gt;ID&lt;/span&gt; 方案来做发号器，怎么做分布式高可用方案呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;我们可以做 10 个发号器，分别为 &lt;/span&gt;&lt;span&gt;Sender&lt;/span&gt;&lt;span&gt;_00 ~ &lt;/span&gt;&lt;span&gt;Sender&lt;/span&gt;&lt;span&gt;_09， &lt;/span&gt;&lt;span&gt;Sender&lt;/span&gt;&lt;span&gt;_00 负责发出尾号是 0 的 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Sender&lt;/span&gt;&lt;span&gt;_01 负责发出尾号是 1 的 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;，以此类推，&lt;/span&gt;&lt;span&gt;Sender&lt;/span&gt;&lt;span&gt;_09 负责发出尾号是 9 的 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;。每个发号器的步长是 10，就是说，如果某次 &lt;/span&gt;&lt;span&gt;Sender&lt;/span&gt;&lt;span&gt;_00 发送了 200，那么下一次它会发送 210。这样每个发号器产生的 &lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt; 互不冲突。具体的实现，可以基于本机内存（&lt;/span&gt;&lt;span&gt;AtomicLong&lt;/span&gt;&lt;span&gt;） + 记&lt;/span&gt; &lt;span&gt;L&lt;/span&gt;&lt;span&gt;og&lt;/span&gt;&lt;span&gt; 实现，也可以基于 &lt;/span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span&gt; 的累加器实现，或基于 &lt;/span&gt;&lt;span&gt;ZK&lt;/span&gt;&lt;span&gt; 计数。下图使用 &lt;/span&gt;&lt;span&gt;Redis Cluster&lt;/span&gt;&lt;span&gt; 实现。我们在 &lt;/span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span&gt; 中设置 10 个不一样的 key，每个&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt; 相当于一个发号器，步进长度为 10。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;779&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.3469721767594107&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdT8lhiaFzW8rasuWC7zxvRj9asSkqY4oU11t1guYg5U0OU0tswtzgmLHCf1PN4zelI1lHxQmoIicmOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;611&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果使用 &lt;/span&gt;&lt;span&gt;KGS&lt;/span&gt;&lt;span&gt; 方案作为发号器，考虑到 &lt;/span&gt;&lt;span&gt;KG&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt; 可以批量发号，批量拿号后完全是内存操作，少了网络 &lt;/span&gt;&lt;span&gt;IO&lt;/span&gt;&lt;span&gt; 的开销，所以 &lt;/span&gt;&lt;span&gt;KG&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt; 服务器做主备架构就可以了，如果压力上来的时候，可以做类似多个发号器的架构。架构图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;718&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.241726618705036&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdT8lhiaFzW8rasuWC7zxvRj9pHE8M2NaViaxFltWg0FavZvp3DBKZSyCV2YqHsysGa84iaoJPOfibfm9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;695&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;短链服务是一个典型的读多写少的应用，对于这种 &lt;/span&gt;&lt;span&gt;Read Heavy&lt;/span&gt;&lt;span&gt; 型的应用，显然加缓存可以大大提升读请求的性能。以下是加入缓存的架构图。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;533&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.9220085470085471&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdT8lhiaFzW8rasuWC7zxvRj9kSaX9Yz2ZUqmC30hKnMGrtqhrIVQ9ZZVwICUWSbzWBjaHFGrMLZAOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;再说说缓存失效相关的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们一开始说的需求里说短链是有过期时间的，&lt;/span&gt;&lt;span&gt;用户可以自己设置过期时间&lt;/span&gt;&lt;span&gt;，不设置的话系统会默认保留&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt; 年。&lt;/span&gt;&lt;span&gt;&lt;span&gt;短链过期&lt;/span&gt;后，我们需要从 &lt;/span&gt;&lt;span&gt;UrlMappingDB&lt;/span&gt;&lt;span&gt; 中将该短链和原始 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt; 的绑定关系解除，这样短链就可再次投入使用了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问题是：短链过期的时候，是先删缓存呢，还是先删数据库记录？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果是先删缓存再删数据库，会发生什么问题？&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如下图所示，假设短链 &lt;span&gt;2kssXw &lt;/span&gt;&lt;/span&gt;&lt;span&gt;过期需要删除，在 &lt;/span&gt;&lt;span&gt;T1&lt;/span&gt;&lt;span&gt; 时刻删除缓存成功， &lt;/span&gt;&lt;span&gt;T3&lt;/span&gt;&lt;span&gt; 时刻删除数据库记录成功。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;208&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3600713012477718&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdSme5LOFKxV4BxzFO9Csl2AJsEibpyCBHLJQhiaEjrkSNLSUlbibwOUAQ7uJDxUTcTkgBFWar3QX0xMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;561&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在高并发环境下，&lt;/span&gt;&lt;span&gt;T2&lt;/span&gt;&lt;span&gt; 时刻来了一个短链跳转的请求，需要从缓存里根据短链 &lt;span&gt;2kssXw &lt;/span&gt;去找对应的原始 &lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;，但是&lt;/span&gt;&lt;span&gt;这时缓存中&lt;/span&gt;&lt;span&gt;已经没有这个键值对了，所以又会去数据库中查找，看是否存在含有 &lt;span&gt;2kssXw &lt;/span&gt;&lt;/span&gt;&lt;span&gt;的记录，不幸的是，这时数据库中 &lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2kssXw &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;对应的记录还没有删掉，所以又被加载到了缓存中。&lt;/span&gt;&lt;span&gt;到了&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; T3 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;时刻，数据库中 &lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2kssXw &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;对应的记录才真正被删掉，但这时缓存中却存在 &lt;/span&gt;&lt;span&gt;2kssXw&lt;/span&gt;&lt;span&gt; 对应的数据。这就造成了缓存和数据库的数据不一致。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;207&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35765124555160144&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/la8s6uvJibdSme5LOFKxV4BxzFO9Csl2AqaqibAV2pW1VAIibZL9PibCnNvHPHI3FwA709qARMq1mduVvdSdrCpddA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;562&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;所以，常用的方案是先删数据库记录，再删缓存。如果需要再保险一点，再启用延时双删，或&lt;/span&gt;&lt;span&gt;者直接同步数据库的 &lt;/span&gt;&lt;span&gt;binlog&lt;/span&gt;&lt;span&gt; 来删缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了防止一些异常的流量占用系统资源，让正常的请求能够得到服务器的 “雨露均沾”，让系统运行地更健壮，所以一个系统除了正常的功能，还需要加入一些限流策略。可以基于 &lt;/span&gt;&lt;span&gt;Nginx&lt;/span&gt;&lt;span&gt; 来做限流，可以对某些 &lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt; 实现限流，比如 &lt;/span&gt;&lt;span&gt;1s&lt;/span&gt;&lt;span&gt; 内同一个&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt;&lt;span&gt; 只能请求 &lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;次；也可以限制一段时间内的连接总数，比如 1s 内，只接受 &lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt; 个&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt; 的连接；也可以实现基于黑白名单的限流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果需要更细粒度的对具体服务和接口的限流策略，可以参靠 &lt;/span&gt;&lt;span&gt;Guava&lt;/span&gt;&lt;span&gt; 的 &lt;/span&gt;&lt;span&gt;RateLimiter&lt;/span&gt;&lt;span&gt;，再定制自己的策略，在网关层实现限流。感兴趣的同学可以去了解更多的细节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上，&lt;/span&gt;&lt;span&gt;Enjoy&lt;/span&gt;&lt;span&gt; ~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎大家关注 &quot;人人都是面试官&quot;， 一起积累和成长 ~&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c2041b82092f7e6e643c5ed73004d169</guid>
<title>对象的可见性：volatile 篇</title>
<link>https://toutiao.io/k/wa4mx5o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：汤圆&lt;/p&gt;

&lt;p&gt;个人博客：&lt;a href=&quot;http://www.javalover.cc&quot;&gt;javalover.cc&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;官人们好啊，我是汤圆，今天给大家带来的是《对象的可见性 - volatile篇》，希望有所帮助，谢谢&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;文章如果有误，希望大家可以指出，真心感谢&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;简介&lt;/h2&gt;

&lt;p&gt;当一个线程修改了某个共享变量时（非局部变量，所有线程都可以访问得到），其他线程总是能立马读到最新值，这时我们就说这个变量是具有可见性的&lt;/p&gt;

&lt;p&gt;如果是单线程，那么可见性是毋庸置疑的，肯定改了就能看到（直肠子，有啥说啥，大家都能看到）&lt;/p&gt;

&lt;p&gt;但是如果是多线程，那么可见性就需要通过一些手段来维持了，比如加锁或者volatile修饰符（花花肠子，各种套路让人措手不及）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;PS：实际上，没有真正的直肠子，据科学研究表明，人的肠子长达8米左右（～身高的5倍）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;目录&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;单线程和多线程中的可见性对比&lt;/li&gt;
&lt;li&gt;volatile修饰符&lt;/li&gt;
&lt;li&gt;指令重排序&lt;/li&gt;
&lt;li&gt;volatile和加锁的区别&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;正文&lt;/h2&gt;

&lt;h3&gt;1. 单线程和多线程中的可见性对比&lt;/h3&gt;

&lt;p&gt;这里我们举两个例子来看下，来了解什么是可见性问题&lt;/p&gt;

&lt;p&gt;下面是一个单线程的例子，其中有一个共享变量&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class SignleThreadVisibilityDemo {
    // 共享变量
    private int number;
    public void setNumber(int number){
        this.number = number;
    }
    public int getNumber(){
        return this.number;
    }
    public static void main(String[] args) {
        SignleThreadVisibilityDemo demo = new SignleThreadVisibilityDemo();
        System.out.println(demo.getNumber());
        demo.setNumber(10);
        System.out.println(demo.getNumber());
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下：可以看到，第一次共享变量number为初始值0，但是调用setNumber(10)之后，再读取就变成了10&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;0
10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改了就能看到，如果多线程也有这么简单，那多好（来自菜鸟的内心独白）。&lt;/p&gt;

&lt;p&gt;下面我们看一个多线程的例子，还是那个共享变量&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;package com.jalon.concurrent.chapter3;

/**
 * &amp;lt;p&amp;gt;
 *  可见性:多线程的可见性问题
 * &amp;lt;/p&amp;gt;
 *
 * @author: JavaLover
 * @time: 2021/4/27
 */
public class MultiThreadVisibilityDemo {
    // 共享变量
    private int number;
    public static void main(String[] args) throws InterruptedException {
        MultiThreadVisibilityDemo demo = new MultiThreadVisibilityDemo();
        new Thread(()-&amp;gt;{
            // 这里我们做个假死循环，只有没给number赋值（初始化除外），就一直循环
            while (0==demo.number);
            System.out.println(demo.number);
        }).start();
        Thread.sleep(1000);
        // 168不是身高，只是个比较吉利的数字
        demo.setNumber(168);
    }

    public int getNumber() {
        return number;
    }

    public void setNumber(int number) {
        this.number = number;
    }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你没看错，就是输出为空，而且程序还在一直运行（没有试过，如果不关机，会不会有输出number的那一天）&lt;/p&gt;

&lt;p&gt;这时就出现了可见性问题，即主线程改了共享变量number，而子线程却看不到&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;原因是什么呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们用图来说话吧，会轻松点&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/29/42VT9gWia1JdCL6.png&quot; alt=&quot;可见性问题&quot;/&gt;&lt;/p&gt;

&lt;p&gt;步骤如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;子线程读取number到自己的栈中，备份&lt;/li&gt;
&lt;li&gt;主线程读取number，修改，写入，同步到内存&lt;/li&gt;
&lt;li&gt;子线程此时没有意识到number的改变，还是读自己栈中的备份ready（可能是各种性能优化的原因）&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;那要怎么解决呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;加锁或者volatile修饰符，这里我们加volatile&lt;/p&gt;

&lt;p&gt;修改后的代码如下：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class MultiThreadVisibilityDemo {
    // 共享变量，加了volatile修饰符，此时number不会备份到其他线程，只会存在共享的堆内存中
    private volatile int number;
    public static void main(String[] args) throws InterruptedException {
        MultiThreadVisibilityDemo demo = new MultiThreadVisibilityDemo();
        new Thread(()-&amp;gt;{
            while (0==demo.number);
            System.out.println(demo.number);
        }).start();
        Thread.sleep(1000);
        // 168不是身高，只是个比较吉利的数字
        demo.setNumber(168);
    }

    public int getNumber() {
        return number;
    }

    public void setNumber(int number) {
        this.number = number;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;168
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，跟我们预期的一样，子线程可以看到主线程做的修改&lt;/p&gt;

&lt;p&gt;下面就让我们一起来探索volatile的小世界吧&lt;/p&gt;

&lt;h3&gt;2. volatile修饰符&lt;/h3&gt;

&lt;p&gt;volatile是一种比加锁稍弱的同步机制，它和加锁最大的区别就是，它不能保证原子性，但是它轻量啊&lt;/p&gt;

&lt;p&gt;我们先把上面那个例子说完；&lt;/p&gt;

&lt;p&gt;我们加了volatile修饰符后，子线程就可以看到主线程做的修改，那么volatile到底做了什么呢？&lt;/p&gt;

&lt;p&gt;其实我们可以把volatile看做一个标志，如果虚拟机看到这个标志，就会认为被它修饰的变量是易变的，不稳定的，随时可能被某个线程修改；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;此时虚拟机就不会对与这个变量相关的指令进行重排序（下面会讲到），而且还会将这个变量的改变实时通知到各个线程（可见性）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用图说话的话，就是下面这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/29/A7jR2my5ikcxC9z.png&quot; alt=&quot;可见性问题-volatile&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到，线程中的number备份都不需要了，每次需要number的时候，都直接去堆内存中读取，这样就保证了数据的可见性&lt;/p&gt;

&lt;h3&gt;3. 指令重排序&lt;/h3&gt;

&lt;p&gt;指令重排序指的是，虚拟机有时候为了优化性能，会把某些指令的执行顺序进行调整，前提是指令的依赖关系不能被破坏（比如int a = 10; int b = a;此时就不会重排序）&lt;/p&gt;

&lt;p&gt;下面我们看下可能会重排序的代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class ReorderDemo {
    public static void main(String[] args) {
        int a = 1;
        int b = 2;
        int m = a + b;
        int c = 1;
        int d = 2;
        int n = c - d;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们要了解一个底层知识，就是每一条语句的执行，在底层系统都是分好几步走的（比如第一步，第二步，第三步等等，这里我们就不涉及那些汇编知识了，大家感兴趣可以参考看下《实战Java高并发》1.5.4）；&lt;/p&gt;

&lt;p&gt;现在让我们回到上面这个例子，依赖关系如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/29/8xbYSacZmfVghLw.png&quot; alt=&quot;依赖关系&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到，他们三三成堆，互不依赖，此时如果发生了重排序，那么就有可能排成下面这个样子&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/29/BxIRNMUi37k9uQ4.png&quot; alt=&quot;重排序&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（上图只是从代码层面进行的效果演示，实际上指令的重排序比这个细节很多，这里主要了解重排序的思想先）&lt;/p&gt;

&lt;p&gt;由于m=a+b需要依赖a和b的值，所以当指令执行到m=a+b的add环节时，如果b还没准备好，那么m=a+b就需要等待b，后面的指令也会等待；&lt;/p&gt;

&lt;p&gt;但是如果重排序，把m=a+b放到后面，那么就可以利用add等待的这个空档期，去准备c和d；&lt;/p&gt;

&lt;p&gt;这样就减少了等待时间，提升了性能（感觉有点像上学时候学的C，习惯性地先定义变量一大堆，然后再编写代码）&lt;/p&gt;

&lt;h3&gt;4. volatile和加锁的区别&lt;/h3&gt;

&lt;p&gt;区别如下&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th/&gt;
&lt;th&gt;加锁&lt;/th&gt;
&lt;th&gt;volatile&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;原子性&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;❎&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可见性&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;有序性&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;上面所说的有序性指的就是禁止指令的重排序，从而使得多线程中不会出现乱序的问题；&lt;/p&gt;

&lt;p&gt;我们可以看到，加锁和volatile最大的区别就是原子性；&lt;/p&gt;

&lt;p&gt;主要是因为volatile只是针对某个变量进行修饰，所以就有点像原子变量的复合操作（虽然原子变量本身是原子操作，但是多个原子变量放到一起，就无法保证了）&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;可见性在单线程中没问题，但是多线程会有问题&lt;/li&gt;
&lt;li&gt;volatile是一种比加锁轻量级的同步机制，可以保证变量的可见性和有序性（禁止重排序）&lt;/li&gt;
&lt;li&gt;指令重排序：有时虚拟机为了优化性能，会在运行时把相互没有依赖的代码顺序重新排序，以此来减少指令的等待时间，提高效率&lt;/li&gt;
&lt;li&gt;加锁和volatile的区别：加锁可以保证原子性，volatile不可以&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考内容：&lt;/p&gt;



&lt;h2&gt;后记&lt;/h2&gt;

&lt;p&gt;最后，感谢大家的观看，谢谢&lt;/p&gt;

&lt;p&gt;原创不易，期待官人们的三连哟&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f91c30446b234352b007175db2675ade</guid>
<title>如何借助 Proxy 代理，提升架构扩展性</title>
<link>https://toutiao.io/k/b6wvgvt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们都知道&lt;/span&gt;&lt;strong&gt;HTTP协议&lt;/strong&gt;&lt;span&gt;本身是无状态的，前后两次请求没有直接关联。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有些业务功能比较特殊，比如发起一次http请求创建一笔订单，前提要求用户先登录，为了解决这个问题，http协议header中引入了Cookie，存储上下文信息，传递登录状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，服务器也有状态之分，取决于服务器是否有存储数据，还是纯计算节点&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.47734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXLp4MmFegTh2ybNrg4xzDftvGPZWwzMluPvDDtFBW3gWnDcIul8G6GPmcSB2bUtUBpSfIvWTibrxqA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;场景：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在有这么一个业务场景，用户发出请求，指令随机打到了一台服务器，比如&lt;code&gt;174.56.102.101&lt;/code&gt;，但根据索引条件，数据实际存储在 &lt;code&gt;174.56.102.102&lt;/code&gt; 或者 &lt;code&gt;174.56.102.103&lt;/code&gt;，此时&lt;code&gt;174.56.102.101&lt;/code&gt; 需要将请求转发给真实的目标服务器，以便获取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然也有一定概率，&lt;code&gt;174.56.102.101&lt;/code&gt;就是真实的数据存储服务器，此时只需要调用本地方法，直接获取数据即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，一个系统会提供很多功能函数，每个函数在执行时，都要先判断数据的真实存储位置，然后再发起远程网络请求，获取数据。这样编写存在大量的代码冗余。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有一种方式，只管调用对应的&lt;code&gt;funcion函数&lt;/code&gt;，至于底层真实数据在哪里，&lt;strong&gt;由框架层来处理&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们想到了RPC框架，比如 &lt;code&gt;Dubbo&lt;/code&gt;，对于开发者而言，调用一个远程服务跟调用本地方法一样，简单方便。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9109947643979057&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXLp4MmFegTh2ybNrg4xzDftOicSLEWhku9biaJ4FXESkE9hJCicbnodoOhIpRgxHHZHsWupq1nSCBVXw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;191&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何来设计这个框架层&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从大的角色划分来看，分为服务提供方和消费方，首先我们来看看消费方如何设计？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消费方&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义注解类 &lt;code&gt;@RPCReference&lt;/code&gt;，作为&lt;code&gt;Field&lt;/code&gt;字段的属性说明，如果有此标识说明注入的是一个代理类。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Service&lt;br/&gt;@Slf4j&lt;br/&gt;public class ComputeService {&lt;br/&gt;&lt;br/&gt;    @RPCReference&lt;br/&gt;    private IResourceService iResourceService;&lt;br/&gt;    &lt;br/&gt;省略。。。。&lt;br/&gt;&lt;br/&gt; public Object method(param){&lt;br/&gt;   // 正常方法调用&lt;br/&gt;   iResourceService.m1();&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;特别说明：&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、IResourceService 需要定义为接口类型&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;2、根据Spring的IOC注入机制，&lt;code&gt;iResourceService&lt;/code&gt;指向的是一个代理类实例地址&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么这个代理类如何创建？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，定义一个增强类 &lt;code&gt;ConsumerProxyFactory&lt;/code&gt;，实现&lt;code&gt;InvocationHandler&lt;/code&gt;接口&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Slf4j&lt;br/&gt;public class ConsumerProxyFactory implements InvocationHandler {&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 复写InvocationHandler类提供的方法，业务类方法调用会触发执行invoke增强逻辑&lt;br/&gt;     */&lt;br/&gt;    @Override&lt;br/&gt;    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {&lt;br/&gt;        Class&amp;lt;?&amp;gt; clazz = proxy.getClass().getInterfaces()[0];&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (method.getName().contains(&lt;span&gt;&quot;toString&quot;&lt;/span&gt;)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;        }&lt;br/&gt;        // 根据args参数做判断&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (当前节点) {&lt;br/&gt;            // 调用本地方法&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; invodeMethod(clazz, method, args);&lt;br/&gt;        }&lt;br/&gt;        // 否则走rpc远程调用&lt;br/&gt;&lt;br/&gt;        // 构造请求体&lt;br/&gt;        RPCRequest req = buildRpcReq(clazz, method, args);&lt;br/&gt;        // 构造请求头&lt;br/&gt;        Map&amp;lt;String, String&amp;gt; headerMap = buildHeaderMap( requestString);&lt;br/&gt;&lt;br/&gt;        // 访问远程服务器的接口，查询结果&lt;br/&gt;        String responseString = HttpClientUtil.postRequest(url, req, headerMap);&lt;br/&gt;&lt;br/&gt;        // 本地ThreadLocal资源清理、释放&lt;br/&gt;&lt;br/&gt;        // 反序列化，解析出Return对象&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; JSONObject.parseObject(responseString, method.getGenericReturnType());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 执行当前节点的本地方法&lt;br/&gt;     */&lt;br/&gt;    private Object invodeMethod(Class&amp;lt;?&amp;gt; clazz, Method method, Object[] args) {&lt;br/&gt;        try {&lt;br/&gt;            // 根据Class模板查询Bean实例&lt;br/&gt;            Object bean =ProviderContext.getProviders(clazz);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (Void.TYPE.equals(method.getReturnType())) {&lt;br/&gt;                method.invoke(bean, args);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; null;&lt;br/&gt;            }&lt;br/&gt;            Object result = method.invoke(bean, args);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        } catch (Exception e) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; e.getMessage();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    // 构造请求体&lt;br/&gt;    private RPCRequest buildRpcReq(Class&amp;lt;?&amp;gt; clazz, Method method, Object[] args) {&lt;br/&gt;        Class&amp;lt;?&amp;gt;[] parameterTypes = method.getParameterTypes();&lt;br/&gt;        String[] parameterTypeNames = Arrays.stream(parameterTypes).map(Class::getName).toArray(String[]::new);&lt;br/&gt;        Type[] listParameterType = method.getGenericParameterTypes();&lt;br/&gt;        String[] listParameterTypeNames = Arrays.stream(listParameterType).map(Type::getTypeName).toArray(String[]::new);&lt;br/&gt;        RPCRequest req = new RPCRequest();&lt;br/&gt;        req.setClazz(clazz);&lt;br/&gt;        req.setMethodName(method.getName());&lt;br/&gt;        req.setParameterTypeNames(parameterTypeNames);&lt;br/&gt;        req.setListParameterTypeNames(listParameterTypeNames);&lt;br/&gt;        req.setArguments(args);&lt;br/&gt;        req.setTt(System.currentTimeMillis());&lt;br/&gt;        省略一些业务参数。。&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; req;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代理类又是如何注入的呢？&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Component&lt;br/&gt;@Slf4j&lt;br/&gt;public class RPCReferenceBeanPostProcessor implements BeanPostProcessor, ApplicationContextAware {&lt;br/&gt;    private ApplicationContext applicationContext;&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {&lt;br/&gt;        // spring容器初始化时，拦截每一个Bean创建&lt;br/&gt;        Class&amp;lt;?&amp;gt; beanClass = bean.getClass();&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;            // 获取Bean实例下的所有全局变量Field&lt;br/&gt;            Field[] fields = beanClass.getDeclaredFields();&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Field field : fields) {&lt;br/&gt;                // 判断是否有@RPCReference注解描述&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!hasAnnotation(field.getAnnotations(), RPCReference.class.getName())) {&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                // 通过反射，为field属性填充Proxy代理类实例&lt;br/&gt;                setField(bean, field);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;while&lt;/span&gt; ((beanClass = beanClass.getSuperclass()) != null);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private void setField(Object bean, Field field) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!field.isAccessible()) {&lt;br/&gt;            field.setAccessible(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        try {&lt;br/&gt;            // Field是接口类型&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (field.getType().isInterface()) {&lt;br/&gt;                Class&amp;lt;?&amp;gt; interfaceClass = field.getType();&lt;br/&gt;                // 创建代理类&lt;br/&gt;                Object object = Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class[]{interfaceClass}, new ConsumerProxyFactory());&lt;br/&gt;                // 代理类注入&lt;br/&gt;                field.set(bean, object);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                throw new RPCException(&lt;span&gt;&quot;10000&quot;&lt;/span&gt;, field.getType().getName() + &lt;span&gt;&quot;-Referenc only suiteable for interface&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        } catch (Exception e) {&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private boolean hasAnnotation(Annotation[] annotations, String annotationName) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (Annotation annotation : annotations) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (annotation.annotationType().getName().equals(annotationName)) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此处主要借助Spring提供的扩展类，&lt;code&gt;ApplicationContextAware&lt;/code&gt;、&lt;code&gt;BeanPostProcessor&lt;/code&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ApplicationContextAware，通过这个上下文环境可以查看、管理 Spring 容器中的Bean。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;BeanPostProcessor，如果我们想在Spring容器中完成bean实例化、配置以及其他初始化方法前后要添加一些自己逻辑处理。我们需要定义一个或多个BeanPostProcessor接口实现类，然后注册到Spring IoC容器中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;服务方&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义&lt;code&gt;ResourceService&lt;/code&gt;继承&lt;code&gt;IResourceService&lt;/code&gt;接口，用于处理具体的业务编码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点：类描述用&lt;code&gt;@RPCService&lt;/code&gt; 注解标记，后面&lt;code&gt;Spring&lt;/code&gt;框架要根据此标识扫描，并做统一管理&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Slf4j&lt;br/&gt;@RPCService&lt;br/&gt;@Service&lt;br/&gt;public class ResourceService implements IResourceService {&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 业务方法&lt;br/&gt;     */&lt;br/&gt;    public ResourceDTO &lt;span&gt;&lt;span&gt;query&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        // 具体业务逻辑省略&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; resourceDTO;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何扫描&lt;code&gt;@RPCService&lt;/code&gt;注解标识的服务实例呢？&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Slf4j&lt;br/&gt;@Configuration&lt;br/&gt;public class RpcServiceLoader {&lt;br/&gt;&lt;br/&gt;    private static Map&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt; providers = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    public static Object getProviders(Class&amp;lt;?&amp;gt; clazz) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; providers.get(clazz);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Bean&lt;br/&gt;    @Autowired&lt;br/&gt;    RpcServiceFactory getProviderProxyFactory(ProviderConfig providerConfig, ApplicationContext ct) {&lt;br/&gt;        RpcServiceFactory rpcServiceFactory = new RpcServiceFactory();&lt;br/&gt;        // 扫描有RPCService注解的bean实例&lt;br/&gt;        Map&amp;lt;String, Object&amp;gt; map = ct.getBeansWithAnnotation(RPCService.class);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (Object bean : map.values()) {&lt;br/&gt;            Class&amp;lt;?&amp;gt; interFaceClazz = AopUtils.getTargetClass(bean).getInterfaces()[0];&lt;br/&gt;            providers.put(interFaceClazz, bean);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; rpcServiceFactory;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务提供方所有的RPC服务实例存储在&lt;code&gt;Map&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt;&lt;/code&gt;，统一管理，后续查询服务时会用到&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最后，关键一步，当服务方收到请求，如何完成触发调用？&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;public class RpcServiceFactory {&lt;br/&gt;&lt;br/&gt;    /***&lt;br/&gt;     * 作为RPC的服务提供方&lt;br/&gt;     * 接收消费方的请求信息，参数解析，通过反射机制，完成相关方法调用&lt;br/&gt;     * 返回结果给调用者（包含异常）&lt;br/&gt;     */&lt;br/&gt;    public Object handleHttpContent(String reqStr) throws Throwable {&lt;br/&gt;        // 将消费方传递的参数反序列化，解析出对象&lt;br/&gt;        RPCRequest req = RPCSerializer.INSTANCE.requestParse(reqStr);&lt;br/&gt;&lt;br/&gt;        // 反射&lt;br/&gt;        Class&amp;lt;?&amp;gt; clazz = req.getClazz();&lt;br/&gt;        String methodName = req.getMethodName();&lt;br/&gt;        Object[] args = req.getArguments();&lt;br/&gt;        String[] parameterTypeNames = req.getParameterTypeNames();&lt;br/&gt;        String[] listParameterTypeNames = req.getListParameterTypeNames();&lt;br/&gt;        Class&amp;lt;?&amp;gt;[] parameterTypes = Arrays.stream(parameterTypeNames).map(this::classForName)&lt;br/&gt;                .toArray(Class[]::new);&lt;br/&gt;&lt;br/&gt;        Method method = clazz.getMethod(methodName, parameterTypes);&lt;br/&gt;&lt;br/&gt;        // 根据类模板查服务的Bean实例&lt;br/&gt;        Object bean = RpcServiceLoader.getProviders(clazz);&lt;br/&gt;        int argsListSize = 0;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (null != args) {&lt;br/&gt;            argsListSize = args.length;&lt;br/&gt;        }&lt;br/&gt;        // 解析出方法的入参&lt;br/&gt;        Object[] argsList = new Object[argsListSize];&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (int i = 0; i &amp;lt; argsListSize; i++) {&lt;br/&gt;            Object o;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (parameterTypeNames[i].contains(&lt;span&gt;&quot;java.util.List&quot;&lt;/span&gt;)) {&lt;br/&gt;                //参数是list&lt;br/&gt;                String clazzName = listParameterTypeNames[i].replace(&lt;span&gt;&quot;java.util.List&amp;lt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).replace(&lt;span&gt;&quot;&amp;gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;                //非list&lt;br/&gt;                Class&amp;lt;?&amp;gt; aClass = classForName(clazzName);&lt;br/&gt;                o = JSONObject.parseArray(JSONObject.toJSONString(args[i]), aClass);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                //非list&lt;br/&gt;                Class&amp;lt;?&amp;gt; aClass = classForName(parameterTypeNames[i]);&lt;br/&gt;                o = JSONObject.parseObject(JSONObject.toJSONString(args[i]), aClass);&lt;br/&gt;            }&lt;br/&gt;            argsList[i] = o;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (Void.TYPE.equals(method.getReturnType())) {&lt;br/&gt;            method.invoke(bean, argsList);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Void.TYPE.getName();&lt;br/&gt;        }&lt;br/&gt;        Object result = method.invoke(bean, argsList);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public Object getBeanByClass(Class&amp;lt;?&amp;gt; clazz) throws RPCException {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (bean != null) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public Class&amp;lt;?&amp;gt; classForName(String className) {&lt;br/&gt;        try {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Class.forName(className);&lt;br/&gt;        } catch (ClassNotFoundException e) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; null;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Redis cluster集群便是采用这个设计思路&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis cluster有固定的&lt;strong&gt;16384&lt;/strong&gt;个hash slot，对每个key计算&lt;strong&gt;CRC16&lt;/strong&gt;值，然后对16384取模，可以获取key对应的hash slot。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集群中每个master都会持有部分slot，比如有3个master，那么可能每个master持有5000多个hash slot&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如：100w条数据，5个master，每个master就负责存储20w条数据，分布式数据存储&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;此时会有同学问，如果集群扩容或缩容怎么办？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实很简单，增加一个master，就将其他master的hash slot移动部分过去。减少一个master，就将它的hash slot移动到其他master上去&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来要讲的部分跟今天的主题相关，或者说设计思路相似&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Redis cluster 如何对多master写入？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写入数据的时候，其实是你可以将请求发送到任意一个master上去执行，该master会计算这个key对应的CRC16值，然后对16384个hash slot取模，找到key对应的hash slot，然后找到真实的master节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对应的master就在自己本地的话，&lt;code&gt;如：set key1 value1&lt;/code&gt;，key1 对应的hash slot 就在自己本地，那么自己处理就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果计算出来的hash slot在其他master节点上，则返回moved给客户端，由客户端进行重定向到对应的master上执行&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好奇宝宝又要发问了？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于重定向的客户端，大部分情况下，可能都会出现一次请求重定向，才能找到正确的节点，非常消耗网络IO。有什么解决方案吗？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8986175115207373&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXLp4MmFegTh2ybNrg4xzDftRR6G2hRibAqFORhkrbmd7S1khZMd3b9UDia4b4h1tE7bYVGo5Jx0QDmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;217&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以了解下 &lt;code&gt;JedisCluster&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;JedisCluster&lt;/code&gt;是针对&lt;code&gt;Redis Cluster&lt;/code&gt;的java客户端，它封装了java访问redis集群的各种操作，包括初始化连接、请求重定向等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理细节：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在JedisCluster初始化的时候，随机选择一个node，初始化hash slot -&amp;gt; node映射表，同时为每个节点创建一个JedisPool连接池&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每次基于JedisCluster执行操作，首先JedisCluster都会在本地计算key的hash slot，然后在本地映射表找到对应的节点&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果那个node正好还是持有那个hash slot，那么就ok; 如果说进行了reshard这样的操作，可能hash slot已经不在那个node上了，就会返回moved&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果JedisCluter API发现对应的节点返回moved，那么利用该节点的元数据，更新本地的hash slot -&amp;gt; node映射表缓存&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;重复上面几个步骤，直到找到对应的节点，如果重试超过5次，那么就报错，JedisClusterMaxRedirectionException&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;jedis老版本，可能会出现在集群某个节点故障还没完成自动切换恢复时，频繁更新hash slot，频繁ping节点检查活跃，导致大量网络IO开销&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;jedis最新版本，对于这些过度的hash slot更新和ping，都进行了优化，避免了类似问题&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5bf0e3ed9ae63f6bd54cbc5ad57b13d0</guid>
<title>Java 双刃剑之 Unsafe 类详解</title>
<link>https://toutiao.io/k/z7fag7p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前一段时间在研究&lt;code&gt;juc&lt;/code&gt;源码的时候，发现在很多工具类中都调用了一个&lt;code&gt;Unsafe&lt;/code&gt;类中的方法，出于好奇就想要研究一下这个类到底有什么作用，于是先查阅了一些资料，一查不要紧，很多资料中对Unsafe的态度都是这样的画风：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6509695290858726&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicaBXVnRhkLmPqRRBCrEkM8EUJhuA9Kiap9X8Yibc8wicsexSbH6ia0kxXibIcoILTMGibxLTz9QuLwjhVgw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;722&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实看到这些说法也没什么意外，毕竟Unsafe这个词直译过来就是“不安全的”，从名字里我们也大概能看来Java的开发者们对它有些不放心。但是作为一名极客，不能你说不安全我就不去研究了，毕竟只有了解一项技术的风险点，才能更好的避免出现这些问题嘛。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们言归正传，先通过简单的介绍来对Unsafe类有一个大致的了解。Unsafe类是一个位于&lt;code&gt;sun.misc&lt;/code&gt;包下的类，它提供了一些相对底层方法，能够让我们接触到一些更接近操作系统底层的资源，如系统的内存资源、cpu指令等。而通过这些方法，我们能够完成一些普通方法无法实现的功能，例如直接使用偏移地址操作对象、数组等等。但是在使用这些方法提供的便利的同时，也存在一些潜在的安全因素，例如对内存的错误操作可能会引起内存泄漏，严重时甚至可能引起jvm崩溃。因此在使用Unsafe前，我们必须要了解它的工作原理与各方法的应用场景，并且在此基础上仍需要非常谨慎的操作，下面我们正式开始对Unsafe的学习。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Unsafe 基础&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来尝试获取一个Unsafe实例，如果按照&lt;code&gt;new&lt;/code&gt;的方式去创建对象，不好意思，编译器会报错提示你：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Unsafe() has private access in &#x27;sun.misc.Unsafe&#x27;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看Unsafe类的源码，可以看到它被&lt;code&gt;final&lt;/code&gt;修饰不允许被继承，并且构造函数为&lt;code&gt;private&lt;/code&gt;类型，即不允许我们手动调用构造方法进行实例化，只有在&lt;code&gt;static&lt;/code&gt;静态代码块中，以单例的方式初始化了一个Unsafe对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Unsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Unsafe theUnsafe;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;Unsafe&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;        theUnsafe = &lt;span&gt;new&lt;/span&gt; Unsafe();&lt;br/&gt;    }   &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Unsafe类中，提供了一个静态方法&lt;code&gt;getUnsafe&lt;/code&gt;，看上去貌似可以用它来获取Unsafe实例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@CallerSensitive&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Unsafe &lt;span&gt;getUnsafe&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Class var0 = Reflection.getCallerClass();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!VM.isSystemDomainLoader(var0.getClassLoader())) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SecurityException(&lt;span&gt;&quot;Unsafe&quot;&lt;/span&gt;);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; theUnsafe;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果我们直接调用这个静态方法，会抛出异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception in thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.lang.SecurityException: Unsafe&lt;br/&gt; at sun.misc.Unsafe.getUnsafe(Unsafe.java:&lt;span&gt;90&lt;/span&gt;)&lt;br/&gt; at com.cn.test.GetUnsafeTest.main(GetUnsafeTest.java:&lt;span&gt;12&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是因为在&lt;code&gt;getUnsafe&lt;/code&gt;方法中，会对调用者的&lt;code&gt;classLoader&lt;/code&gt;进行检查，判断当前类是否由&lt;code&gt;Bootstrap classLoader&lt;/code&gt;加载，如果不是的话那么就会抛出一个&lt;code&gt;SecurityException&lt;/code&gt;异常。也就是说，只有启动类加载器加载的类才能够调用Unsafe类中的方法，来防止这些方法在不可信的代码中被调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，为什么要对Unsafe类进行这么谨慎的使用限制呢，说到底，还是因为它实现的功能过于底层，例如直接进行内存操作、绕过jvm的安全检查创建对象等等，概括的来说，Unsafe类实现功能可以被分为下面8类：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6417657045840407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaBXVnRhkLmPqRRBCrEkM8EXBpGK0hibIQZzQAWZP9xxQWdXHN8RmaibQm6icrbd5AdsqddPicibgbvqsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;589&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;创建实例&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到上面的这些功能，你是不是已经有些迫不及待想要试一试了。那么如果我们执意想要在自己的代码中调用Unsafe类的方法，应该怎么获取一个它的实例对象呢，答案是利用反射获得Unsafe类中已经实例化完成的单例对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Unsafe &lt;span&gt;getUnsafe&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IllegalAccessException &lt;/span&gt;{&lt;br/&gt;    Field unsafeField = Unsafe&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getDeclaredField&lt;/span&gt;(&quot;&lt;span&gt;theUnsafe&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//Field unsafeField = Unsafe.class.getDeclaredFields()[0]; //也可以这样，作用相同&lt;/span&gt;&lt;br/&gt;    unsafeField.setAccessible(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    Unsafe unsafe =(Unsafe) unsafeField.get(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; unsafe;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在获取到Unsafe的实例对象后，我们就可以使用它为所欲为了，先来尝试使用它对一个对象的属性进行读写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fieldTest&lt;/span&gt;&lt;span&gt;(Unsafe unsafe)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; NoSuchFieldException &lt;/span&gt;{&lt;br/&gt;    User user=&lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; fieldOffset = unsafe.objectFieldOffset(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getDeclaredField&lt;/span&gt;(&quot;&lt;span&gt;age&lt;/span&gt;&quot;))&lt;/span&gt;;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;offset:&quot;&lt;/span&gt;+fieldOffset);&lt;br/&gt;    unsafe.putInt(user,fieldOffset,&lt;span&gt;20&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;age:&quot;&lt;/span&gt;+unsafe.getInt(user,fieldOffset));&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;age:&quot;&lt;/span&gt;+user.getAge());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行代码输出如下，可以看到通过Unsafe类的&lt;code&gt;objectFieldOffset&lt;/code&gt;方法获取了对象中字段的偏移地址，这个偏移地址不是内存中的绝对地址而是一个相对地址，之后再通过这个偏移地址对&lt;code&gt;int&lt;/code&gt;类型字段的属性值进行了读写操作，通过结果也可以看到Unsafe的方法和类中的&lt;code&gt;get&lt;/code&gt;方法获取到的值是相同的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;offset:12&lt;br/&gt;age:20&lt;br/&gt;age:20&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的例子中调用了Unsafe类的&lt;code&gt;putInt&lt;/code&gt;和&lt;code&gt;getInt&lt;/code&gt;方法，看一下源码中的方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getInt&lt;/span&gt;&lt;span&gt;(Object o, &lt;span&gt;long&lt;/span&gt; offset)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;putInt&lt;/span&gt;&lt;span&gt;(Object o, &lt;span&gt;long&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先说作用，&lt;code&gt;getInt&lt;/code&gt;用于从对象的指定偏移地址处读取一个&lt;code&gt;int&lt;/code&gt;，&lt;code&gt;putInt&lt;/code&gt;用于在对象指定偏移地址处写入一个&lt;code&gt;int&lt;/code&gt;，并且即使类中的这个属性是&lt;code&gt;private&lt;/code&gt;私有类型的，也可以对它进行读写。但是有细心的小伙伴可能发现了，这两个方法相对于我们平常写的普通方法，多了一个&lt;code&gt;native&lt;/code&gt;关键字修饰，并且没有具体的方法逻辑，那么它是怎么实现的呢？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;native方法&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java中，这类方法被称为&lt;code&gt;native&lt;/code&gt;方法（&lt;code&gt;Native Method&lt;/code&gt;），简单的说就是由java调用非java代码的接口，被调用的方法是由非java 语言实现的，例如它可以由C或C++语言来实现，并编译成DLL，然后直接供java进行调用。&lt;code&gt;native&lt;/code&gt;方法是通过JNI（&lt;code&gt;Java Native Interface&lt;/code&gt;）实现调用的，从 java1.1开始 JNI 标准就是java平台的一部分，它允许java代码和其他语言的代码进行交互。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2640625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaBXVnRhkLmPqRRBCrEkM8EZRTMLV8cOWWdGDWcwsgW85IH8gClucO2ibvJLjtrRkzElmJ3hTcBmibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Unsafe类中的很多基础方法都属于&lt;code&gt;native&lt;/code&gt;方法，那么为什么要使用&lt;code&gt;native&lt;/code&gt;方法呢？原因可以概括为以下几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要用到 java 中不具备的依赖于操作系统的特性，java在实现跨平台的同时要实现对底层的控制，需要借助其他语言发挥作用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于其他语言已经完成的一些现成功能，可以使用java直接调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序对时间敏感或对性能要求非常高时，有必要使用更加底层的语言，例如C/C++甚至是汇编&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;juc&lt;/code&gt;包的很多并发工具类在实现并发机制时，都调用了&lt;code&gt;native&lt;/code&gt;方法，通过它们打破了java运行时的界限，能够接触到操作系统底层的某些功能。对于同一个&lt;code&gt;native&lt;/code&gt;方法，不同的操作系统可能会通过不同的方式来实现，但是对于使用者来说是透明的，最终都会得到相同的结果，至于java如何实现的通过JNI调用其他语言的代码，不是本文的重点，会在后续的文章中具体学习。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Unsafe 应用&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在对Unsafe的基础有了一定了解后，我们来看一下它的基本应用。由于篇幅有限，不能对所有方法进行介绍，如果大家有学习的需要，可以下载openJDK的源码进行学习。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;1、内存操作&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你是一个写过&lt;code&gt;c&lt;/code&gt;或者&lt;code&gt;c++&lt;/code&gt;的程序员，一定对内存操作不会陌生，而在java中是不允许直接对内存进行操作的，对象内存的分配和回收都是由&lt;code&gt;jvm&lt;/code&gt;自己实现的。但是在Unsafe中，提供的下列接口可以直接进行内存操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//分配新的本地空间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;allocateMemory&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; bytes)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//重新调整内存空间的大小&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;reallocateMemory&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; address, &lt;span&gt;long&lt;/span&gt; bytes)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//将内存设置为指定值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setMemory&lt;/span&gt;&lt;span&gt;(Object o, &lt;span&gt;long&lt;/span&gt; offset, &lt;span&gt;long&lt;/span&gt; bytes, &lt;span&gt;byte&lt;/span&gt; value)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//内存拷贝&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;copyMemory&lt;/span&gt;&lt;span&gt;(Object srcBase, &lt;span&gt;long&lt;/span&gt; srcOffset,Object destBase, &lt;span&gt;long&lt;/span&gt; destOffset,&lt;span&gt;long&lt;/span&gt; bytes)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//清除内存&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;freeMemory&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; address)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用下面的代码进行测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;memoryTest&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;4&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; addr = unsafe.allocateMemory(size);&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; addr3 = unsafe.reallocateMemory(addr, size * &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;addr: &quot;&lt;/span&gt;+addr);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;addr3: &quot;&lt;/span&gt;+addr3);&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        unsafe.setMemory(&lt;span&gt;null&lt;/span&gt;,addr ,size,(&lt;span&gt;byte&lt;/span&gt;)&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;2&lt;/span&gt;; i++) {&lt;br/&gt;            unsafe.copyMemory(&lt;span&gt;null&lt;/span&gt;,addr,&lt;span&gt;null&lt;/span&gt;,addr3+size*i,&lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        System.out.println(unsafe.getInt(addr));&lt;br/&gt;        System.out.println(unsafe.getLong(addr3));&lt;br/&gt;    }&lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        unsafe.freeMemory(addr);&lt;br/&gt;        unsafe.freeMemory(addr3);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看结果输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;addr: 2433733895744&lt;br/&gt;addr3: 2433733894944&lt;br/&gt;16843009&lt;br/&gt;72340172838076673&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析一下运行结果，首先使用&lt;code&gt;allocateMemory&lt;/code&gt;方法申请4字节长度的内存空间，在循环中调用&lt;code&gt;setMemory&lt;/code&gt;方法向每个字节写入内容为&lt;code&gt;byte&lt;/code&gt;类型的1，当使用Unsafe调用&lt;code&gt;getInt&lt;/code&gt;方法时，因为一个&lt;code&gt;int&lt;/code&gt;型变量占4个字节，会一次性读取4个字节，组成一个&lt;code&gt;int&lt;/code&gt;的值，对应的十进制结果为16843009，可以通过图示理解这个过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35674157303370785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaBXVnRhkLmPqRRBCrEkM8Esdm2Nh0fYQk19Tp4cMic0h7rVrFPjtj4HQzq0ia2aiaZdczlQUKJRhrzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在代码中调用&lt;code&gt;reallocateMemory&lt;/code&gt;方法重新分配了一块8字节长度的内存空间，通过比较&lt;code&gt;addr&lt;/code&gt;和&lt;code&gt;addr3&lt;/code&gt;可以看到和之前申请的内存地址是不同的。在代码中的第二个for循环里，调用&lt;code&gt;copyMemory&lt;/code&gt;方法进行了两次内存的拷贝，每次拷贝内存地址&lt;code&gt;addr&lt;/code&gt;开始的4个字节，分别拷贝到以&lt;code&gt;addr3&lt;/code&gt;和&lt;code&gt;addr3+4&lt;/code&gt;开始的内存空间上：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.388366124893071&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaBXVnRhkLmPqRRBCrEkM8E49cx90zJjSnqkM3UvR2HicEWJtBz06YNA6EsM4EJWbXoNsH3zfWzuMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1169&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拷贝完成后，使用&lt;code&gt;getLong&lt;/code&gt;方法一次性读取8个字节，得到&lt;code&gt;long&lt;/code&gt;类型的值为72340172838076673。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意，通过这种方式分配的内存属于堆外内存，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用&lt;code&gt;freeMemory&lt;/code&gt;方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在&lt;code&gt;try&lt;/code&gt;中执行对内存的操作，最终在&lt;code&gt;finally&lt;/code&gt;块中进行内存的释放。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2、内存屏障&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍内存屏障前，需要知道编译器和CPU会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致CPU的高速缓存和内存中数据的不一致，而内存屏障（&lt;code&gt;Memory Barrier&lt;/code&gt;）就是通过组织屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在硬件层面上，内存屏障是CPU为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在java8中，引入了3个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由jvm来生成内存屏障指令，来实现内存屏障的功能。Unsafe中提供了下面三个内存屏障相关方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//禁止读操作重排序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;loadFence&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//禁止写操作重排序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;storeFence&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//禁止读、写操作重排序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fullFence&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以&lt;code&gt;loadFence&lt;/code&gt;方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这估计很多小伙伴们会想到&lt;code&gt;volatile&lt;/code&gt;关键字了，如果在字段上添加了&lt;code&gt;volatile&lt;/code&gt;关键字，就能够实现字段在多线程下的可见性。基于读内存屏障，我们也能实现相同的功能。下面定义一个线程方法，在线程中去修改&lt;code&gt;flag&lt;/code&gt;标志位，注意这里的&lt;code&gt;flag&lt;/code&gt;是没有被&lt;code&gt;volatile&lt;/code&gt;修饰的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Getter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ChangeThread&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**volatile**/&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; flag=&lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            Thread.sleep(&lt;span&gt;3000&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }        &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;subThread change flag to:&quot;&lt;/span&gt; + flag);&lt;br/&gt;        flag = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主线程的&lt;code&gt;while&lt;/code&gt;循环中，加入内存屏障，测试是否能够感知到&lt;code&gt;flag&lt;/code&gt;的修改变化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    ChangeThread changeThread = &lt;span&gt;new&lt;/span&gt; ChangeThread();&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; Thread(changeThread).start();&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; flag = changeThread.isFlag();&lt;br/&gt;        unsafe.loadFence(); &lt;span&gt;//加入读内存屏障&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (flag){&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;detected flag changed&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;main thread end&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;subThread change flag to:&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;detected flag changed&lt;br/&gt;main thread end&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而如果删掉上面代码中的&lt;code&gt;loadFence&lt;/code&gt;方法，那么主线程将无法感知到&lt;code&gt;flag&lt;/code&gt;发生的变化，会一直在&lt;code&gt;while&lt;/code&gt;中循环。可以用图来表示上面的过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6980392156862745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaBXVnRhkLmPqRRBCrEkM8EwNQ7DyBdp4Upicsy8HUEicjBkzc2h3bpHBxcW5XuLyVTgA8gAiaONDjzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;765&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解java内存模型（&lt;code&gt;JMM&lt;/code&gt;）的小伙伴们应该清楚，运行中的线程不是直接读取主内存中的变量的，只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。上面的图中的流程就是子线程借助于主内存，将修改后的结果同步给了主线程，进而修改主线程中的工作空间，跳出循环。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3、对象操作&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;a&lt;/strong&gt;、对象成员属性的内存偏移量获取，以及字段属性值的修改，在上面的例子中我们已经测试过了。除了前面的&lt;code&gt;putInt&lt;/code&gt;、&lt;code&gt;getInt&lt;/code&gt;方法外，Unsafe提供了全部8种基础数据类型以及&lt;code&gt;Object&lt;/code&gt;的&lt;code&gt;put&lt;/code&gt;和&lt;code&gt;get&lt;/code&gt;方法，并且所有的&lt;code&gt;put&lt;/code&gt;方法都可以越过访问权限，直接修改内存中的数据。阅读openJDK源码中的注释发现，基础数据类型和&lt;code&gt;Object&lt;/code&gt;的读写稍有不同，基础数据类型是直接操作的属性值（&lt;code&gt;value&lt;/code&gt;），而&lt;code&gt;Object&lt;/code&gt;的操作则是基于引用值（&lt;code&gt;reference value&lt;/code&gt;）。下面是&lt;code&gt;Object&lt;/code&gt;的读写方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//在对象的指定偏移地址获取一个对象引用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; Object &lt;span&gt;getObject&lt;/span&gt;&lt;span&gt;(Object o, &lt;span&gt;long&lt;/span&gt; offset)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//在对象指定偏移地址写入一个对象引用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;putObject&lt;/span&gt;&lt;span&gt;(Object o, &lt;span&gt;long&lt;/span&gt; offset, Object x)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了对象属性的普通读写外，Unsafe还提供了&lt;strong&gt;volatile读写&lt;/strong&gt;和&lt;strong&gt;有序写入&lt;/strong&gt;方法。&lt;code&gt;volatile&lt;/code&gt;读写方法的覆盖范围与普通读写相同，包含了全部基础数据类型和&lt;code&gt;Object&lt;/code&gt;类型，以&lt;code&gt;int&lt;/code&gt;类型为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//在对象的指定偏移地址处读取一个int值，支持volatile load语义&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getIntVolatile&lt;/span&gt;&lt;span&gt;(Object o, &lt;span&gt;long&lt;/span&gt; offset)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//在对象指定偏移地址处写入一个int，支持volatile store语义&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;putIntVolatile&lt;/span&gt;&lt;span&gt;(Object o, &lt;span&gt;long&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对于普通读写来说，&lt;code&gt;volatile&lt;/code&gt;读写具有更高的成本，因为它需要保证可见性和有序性。在执行&lt;code&gt;get&lt;/code&gt;操作时，会强制从主存中获取属性值，在使用&lt;code&gt;put&lt;/code&gt;方法设置属性值时，会强制将值更新到主存中，从而保证这些变更对其他线程是可见的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有序写入的方法有以下三个：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;putOrderedObject&lt;/span&gt;&lt;span&gt;(Object o, &lt;span&gt;long&lt;/span&gt; offset, Object x)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;putOrderedInt&lt;/span&gt;&lt;span&gt;(Object o, &lt;span&gt;long&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;putOrderedLong&lt;/span&gt;&lt;span&gt;(Object o, &lt;span&gt;long&lt;/span&gt; offset, &lt;span&gt;long&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有序写入的成本相对&lt;code&gt;volatile&lt;/code&gt;较低，因为它只保证写入时的有序性，而不保证可见性，也就是一个线程写入的值不能保证其他线程立即可见。为了解决这里的差异性，需要对内存屏障的知识点再进一步进行补充，首先需要了解两个指令的概念：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Load&lt;/code&gt;：将主内存中的数据拷贝到处理器的缓存中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Store&lt;/code&gt;：将处理器缓存的数据刷新到主内存中&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺序写入与&lt;code&gt;volatile&lt;/code&gt;写入的差别在于，在顺序写时加入的内存屏障类型为&lt;code&gt;StoreStore&lt;/code&gt;类型，而在&lt;code&gt;volatile&lt;/code&gt;写入时加入的内存屏障是&lt;code&gt;StoreLoad&lt;/code&gt;类型，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7355212355212355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaBXVnRhkLmPqRRBCrEkM8Ec9xEaHN8PswCGx9bLibe7bGbX7yjLyCiar9QqEe3Nn8HjSLMgveR3ANA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;518&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在有序写入方法中，使用的是&lt;code&gt;StoreStore&lt;/code&gt;屏障，该屏障确保&lt;code&gt;Store1&lt;/code&gt;立刻刷新数据到内存，这一操作先于&lt;code&gt;Store2&lt;/code&gt;以及后续的存储指令操作。而在&lt;code&gt;volatile&lt;/code&gt;写入中，使用的是&lt;code&gt;StoreLoad&lt;/code&gt;屏障，该屏障确保&lt;code&gt;Store1&lt;/code&gt;立刻刷新数据到内存，这一操作先于&lt;code&gt;Load2&lt;/code&gt;及后续的装载指令，并且，&lt;code&gt;StoreLoad&lt;/code&gt;屏障会使该屏障之前的所有内存访问指令，包括存储指令和访问指令全部完成之后，才执行该屏障之后的内存访问指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上所述，在上面的三类写入方法中，在写入效率方面，按照&lt;code&gt;put&lt;/code&gt;、&lt;code&gt;putOrder&lt;/code&gt;、&lt;code&gt;putVolatile&lt;/code&gt;的顺序效率逐渐降低，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;b&lt;/strong&gt;、使用Unsafe的&lt;code&gt;allocateInstance&lt;/code&gt;方法，允许我们使用非常规的方式进行对象的实例化，首先定义一个实体类，并且在构造函数中对其成员变量进行赋值操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; b;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;A&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.b =&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分别基于构造函数、反射以及Unsafe方法的不同方式创建对象进行比较：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;objTest&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception&lt;/span&gt;{&lt;br/&gt;    A a1=&lt;span&gt;new&lt;/span&gt; A();&lt;br/&gt;    System.out.println(a1.getB());&lt;br/&gt;    A a2 = A&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;newInstance&lt;/span&gt;()&lt;/span&gt;;&lt;br/&gt;    System.out.println(a2.getB());&lt;br/&gt;    A a3= (A) unsafe.allocateInstance(A&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    System.out.println(a3.getB());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印结果分别为1、1、0，说明通过&lt;code&gt;allocateInstance&lt;/code&gt;方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了&lt;code&gt;Class&lt;/code&gt;对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。在上面的例子中，如果将A类的构造函数改为&lt;code&gt;private&lt;/code&gt;类型，将无法通过构造函数和反射创建对象，但&lt;code&gt;allocateInstance&lt;/code&gt;方法仍然有效。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4、数组操作&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Unsafe中，可以使用&lt;code&gt;arrayBaseOffset&lt;/code&gt;方法可以获取数组中第一个元素的偏移地址，使用&lt;code&gt;arrayIndexScale&lt;/code&gt;方法可以获取数组中元素间的偏移地址增量。使用下面的代码进行测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;arrayTest&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String[] array=&lt;span&gt;new&lt;/span&gt; String[]{&lt;span&gt;&quot;str1str1str&quot;&lt;/span&gt;,&lt;span&gt;&quot;str2&quot;&lt;/span&gt;,&lt;span&gt;&quot;str3&quot;&lt;/span&gt;};&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; baseOffset = unsafe.arrayBaseOffset(String[]&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    System.out.println(baseOffset);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; scale = unsafe.arrayIndexScale(String[]&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    System.out.println(scale);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; array.length; i++) {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; offset=baseOffset+scale*i;&lt;br/&gt;        System.out.println(offset+&lt;span&gt;&quot; : &quot;&lt;/span&gt;+unsafe.getObject(array,offset));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面代码的输出结果为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;16&lt;br/&gt;4&lt;br/&gt;16 : str1str1str&lt;br/&gt;20 : str2&lt;br/&gt;24 : str3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过配合使用数组偏移首地址和各元素间偏移地址的增量，可以方便的定位到数组中的元素在内存中的位置，进而通过&lt;code&gt;getObject&lt;/code&gt;方法直接获取任意位置的数组元素。需要说明的是，&lt;code&gt;arrayIndexScale&lt;/code&gt;获取的并不是数组中元素占用的大小，而是地址的增量，按照openJDK中的注释，可以将它翻译为&lt;strong&gt;元素寻址的转换因子&lt;/strong&gt;（&lt;code&gt;scale factor for addressing elements&lt;/code&gt;）。在上面的例子中，第一个字符串长度为11字节，但其地址增量仍然为4字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，基于这两个值是如何实现的寻址和数组元素的访问呢，这里需要借助一点在前面的文章中讲过的Java对象内存布局的知识，先把上面例子中的String数组对象的内存布局画出来，就很方便大家理解了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5345666991236612&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaBXVnRhkLmPqRRBCrEkM8E11h8sWtib9VvZQuficUesEaRDfyK0OpqS2kL8F0NX7VAlOhhibJg5vwaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1027&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在String数组对象中，对象头包含3部分，&lt;code&gt;mark word&lt;/code&gt;标记字占用8字节，&lt;code&gt;klass point&lt;/code&gt;类型指针占用4字节，数组对象特有的数组长度部分占用4字节，总共占用了16字节。第一个String的引用类型相对于对象的首地址的偏移量是就16，之后每个元素在这个基础上加4，正好对应了我们上面代码中的寻址过程，之后再使用前面说过的&lt;code&gt;getObject&lt;/code&gt;方法，通过数组对象可以获得对象在堆中的首地址，再配合对象中变量的偏移量，就能获得每一个变量的引用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;5、CAS操作&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;juc&lt;/code&gt;包的并发工具类中大量地使用了CAS操作，像在前面介绍&lt;code&gt;synchronized&lt;/code&gt;和&lt;code&gt;AQS&lt;/code&gt;的文章中也多次提到了CAS，其作为乐观锁在并发工具类中广泛发挥了作用。在Unsafe类中，提供了&lt;code&gt;compareAndSwapObject&lt;/code&gt;、&lt;code&gt;compareAndSwapInt&lt;/code&gt;、&lt;code&gt;compareAndSwapLong&lt;/code&gt;方法来实现的对&lt;code&gt;Object&lt;/code&gt;、&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;类型的CAS操作。以&lt;code&gt;compareAndSwapInt&lt;/code&gt;方法为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;compareAndSwapInt&lt;/span&gt;&lt;span&gt;(Object o, &lt;span&gt;long&lt;/span&gt; offset,&lt;span&gt;int&lt;/span&gt; expected,&lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数中&lt;code&gt;o&lt;/code&gt;为需要更新的对象，&lt;code&gt;offset&lt;/code&gt;是对象&lt;code&gt;o&lt;/code&gt;中整形字段的偏移量，如果这个字段的值与&lt;code&gt;expected&lt;/code&gt;相同，则将字段的值设为&lt;code&gt;x&lt;/code&gt;这个新值，并且此更新是不可被中断的，也就是一个原子操作。下面是一个使用&lt;code&gt;compareAndSwapInt&lt;/code&gt;的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    CasTest casTest=&lt;span&gt;new&lt;/span&gt; CasTest();&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; Thread(()-&amp;gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++) {&lt;br/&gt;            casTest.increment(i);&lt;br/&gt;            System.out.print(casTest.a+&lt;span&gt;&quot; &quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }).start();&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; Thread(()-&amp;gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;5&lt;/span&gt; ; i &amp;lt;&lt;span&gt;10&lt;/span&gt; ; i++) {&lt;br/&gt;            casTest.increment(i);&lt;br/&gt;            System.out.print(casTest.a+&lt;span&gt;&quot; &quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }).start();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;increment&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;){&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;long&lt;/span&gt; fieldOffset = unsafe.objectFieldOffset(CasTest&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getDeclaredField&lt;/span&gt;(&quot;&lt;span&gt;a&lt;/span&gt;&quot;))&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (unsafe.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;,fieldOffset,x-&lt;span&gt;1&lt;/span&gt;,x))&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (NoSuchFieldException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行代码会依次输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1 2 3 4 5 6 7 8 9 &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的例子中，使用两个线程去修改&lt;code&gt;int&lt;/code&gt;型属性&lt;code&gt;a&lt;/code&gt;的值，并且只有在&lt;code&gt;a&lt;/code&gt;的值等于传入的参数&lt;code&gt;x&lt;/code&gt;减一时，才会将&lt;code&gt;a&lt;/code&gt;的值变为&lt;code&gt;x&lt;/code&gt;，也就是实现对&lt;code&gt;a&lt;/code&gt;的加一的操作。流程如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7611607142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaBXVnRhkLmPqRRBCrEkM8EaC5yS2Wk1qVArJicAtolTzibG5LUICItNBp1RVZiaOVGvB8JzakicIHczg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;896&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，在调用&lt;code&gt;compareAndSwapInt&lt;/code&gt;方法后，会直接返回&lt;code&gt;true&lt;/code&gt;或&lt;code&gt;false&lt;/code&gt;的修改结果，因此需要我们在代码中手动添加自旋的逻辑。在&lt;code&gt;AtomicInteger&lt;/code&gt;类的设计中，也是采用了将&lt;code&gt;compareAndSwapInt&lt;/code&gt;的结果作为循环条件，直至修改成功才退出死循环的方式来实现的原子性的自增操作。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;6、线程调度&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Unsafe类中提供了&lt;code&gt;park&lt;/code&gt;、&lt;code&gt;unpark&lt;/code&gt;、&lt;code&gt;monitorEnter&lt;/code&gt;、&lt;code&gt;monitorExit&lt;/code&gt;、&lt;code&gt;tryMonitorEnter&lt;/code&gt;方法进行线程调度，在前面介绍AQS的文章中我们提到过使用&lt;code&gt;LockSupport&lt;/code&gt;挂起或唤醒指定线程，看一下&lt;code&gt;LockSupport&lt;/code&gt;的源码，可以看到它也是调用的Unsafe类中的方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;park&lt;/span&gt;&lt;span&gt;(Object blocker)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Thread t = Thread.currentThread();&lt;br/&gt;    setBlocker(t, blocker);&lt;br/&gt;    UNSAFE.park(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;0L&lt;/span&gt;);&lt;br/&gt;    setBlocker(t, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unpark&lt;/span&gt;&lt;span&gt;(Thread thread)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (thread != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        UNSAFE.unpark(thread);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LockSupport的&lt;code&gt;park&lt;/code&gt;方法调用了Unsafe的&lt;code&gt;park&lt;/code&gt;方法来阻塞当前线程，此方法将线程阻塞后就不会继续往后执行，直到有其他线程调用&lt;code&gt;unpark&lt;/code&gt;方法唤醒当前线程。下面的例子对Unsafe的这两个方法进行测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Thread mainThread = Thread.currentThread();&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; Thread(()-&amp;gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            TimeUnit.SECONDS.sleep(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;subThread try to unpark mainThread&quot;&lt;/span&gt;);&lt;br/&gt;            unsafe.unpark(mainThread);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }).start();&lt;br/&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;park main mainThread&quot;&lt;/span&gt;);&lt;br/&gt;    unsafe.park(&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;0L&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;unpark mainThread success&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序输出为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;park main mainThread&lt;br/&gt;subThread try to unpark mainThread&lt;br/&gt;unpark mainThread success&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序运行的流程也比较容易看懂，子线程开始运行后先进行睡眠，确保主线程能够调用&lt;code&gt;park&lt;/code&gt;方法阻塞自己，子线程在睡眠5秒后，调用&lt;code&gt;unpark&lt;/code&gt;方法唤醒主线程，使主线程能继续向下执行。整个流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2319148936170212&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaBXVnRhkLmPqRRBCrEkM8E1UagxPFz0fFJqqK2ibKRqrdbtlEK7y0jch54Tof921X7eOZppDL3Ugw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;470&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，Unsafe源码中&lt;code&gt;monitor&lt;/code&gt;相关的三个方法已经被标记为&lt;code&gt;deprecated&lt;/code&gt;，不建议被使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//获得对象锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Deprecated&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;monitorEnter&lt;/span&gt;&lt;span&gt;(Object var1)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//释放对象锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Deprecated&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;monitorExit&lt;/span&gt;&lt;span&gt;(Object var1)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//尝试获得对象锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Deprecated&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryMonitorEnter&lt;/span&gt;&lt;span&gt;(Object var1)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;monitorEnter&lt;/code&gt;方法用于获得对象锁，&lt;code&gt;monitorExit&lt;/code&gt;用于释放对象锁，如果对一个没有被&lt;code&gt;monitorEnter&lt;/code&gt;加锁的对象执行此方法，会抛出&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;异常。&lt;code&gt;tryMonitorEnter&lt;/code&gt;方法尝试获取对象锁，如果成功则返回&lt;code&gt;true&lt;/code&gt;，反之返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;7、Class操作&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Unsafe对&lt;code&gt;Class&lt;/code&gt;的相关操作主要包括类加载和静态变量的操作方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;a&lt;/strong&gt;、静态属性读取相关的方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//获取静态属性的偏移量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;staticFieldOffset&lt;/span&gt;&lt;span&gt;(Field f)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//获取静态属性的对象指针&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; Object &lt;span&gt;staticFieldBase&lt;/span&gt;&lt;span&gt;(Field f)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//判断类是否需要实例化（用于获取类的静态属性前进行检测）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;shouldBeInitialized&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt; c)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个包含静态属性的类，进行测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String name=&lt;span&gt;&quot;Hydra&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;staticTest&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    User user=&lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    System.out.println(unsafe.shouldBeInitialized(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;    Field sexField = User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getDeclaredField&lt;/span&gt;(&quot;&lt;span&gt;name&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; fieldOffset = unsafe.staticFieldOffset(sexField);&lt;br/&gt;    Object fieldBase = unsafe.staticFieldBase(sexField);&lt;br/&gt;    Object object = unsafe.getObject(fieldBase, fieldOffset);&lt;br/&gt;    System.out.println(object);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;Hydra&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Unsafe的对象操作中，我们学习了通过&lt;code&gt;objectFieldOffset&lt;/code&gt;方法获取对象属性偏移量并基于它对变量的值进行存取，但是它不适用于类中的静态属性，这时候就需要使用&lt;code&gt;staticFieldOffset&lt;/code&gt;方法。在上面的代码中，只有在获取&lt;code&gt;Field&lt;/code&gt;对象的过程中依赖到了&lt;code&gt;Class&lt;/code&gt;，而获取静态变量的属性时不再依赖于&lt;code&gt;Class&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的代码中首先创建一个&lt;code&gt;User&lt;/code&gt;对象，这是因为如果一个类没有被实例化，那么它的静态属性也不会被初始化，最后获取的字段属性将是&lt;code&gt;null&lt;/code&gt;。所以在获取静态属性前，需要调用&lt;code&gt;shouldBeInitialized&lt;/code&gt;方法，判断在获取前是否需要初始化这个类。如果删除创建User对象的语句，运行结果会变为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;b&lt;/strong&gt;、使用&lt;code&gt;defineClass&lt;/code&gt;方法允许程序在运行时动态地创建一个类，方法定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; Class&amp;lt;?&amp;gt; defineClass(String name, &lt;span&gt;byte&lt;/span&gt;[] b, &lt;span&gt;int&lt;/span&gt; off, &lt;span&gt;int&lt;/span&gt; len,&lt;br/&gt;                                   ClassLoader loader,ProtectionDomain protectionDomain);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际使用过程中，可以只传入字节数组、起始字节的下标以及读取的字节长度，默认情况下，类加载器（&lt;code&gt;ClassLoader&lt;/code&gt;）和保护域（&lt;code&gt;ProtectionDomain&lt;/code&gt;）来源于调用此方法的实例。下面的例子中实现了反编译生成后的class文件的功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;defineTest&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String fileName=&lt;span&gt;&quot;F:\\workspace\\unsafe-test\\target\\classes\\com\\cn\\model\\User.class&quot;&lt;/span&gt;;&lt;br/&gt;    File file = &lt;span&gt;new&lt;/span&gt; File(fileName);&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt;(FileInputStream fis = &lt;span&gt;new&lt;/span&gt; FileInputStream(file)) {&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] content=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[(&lt;span&gt;int&lt;/span&gt;)file.length()];&lt;br/&gt;        fis.read(content);&lt;br/&gt;        Class clazz = unsafe.defineClass(&lt;span&gt;null&lt;/span&gt;, content, &lt;span&gt;0&lt;/span&gt;, content.length, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;        Object o = clazz.newInstance();&lt;br/&gt;        Object age = clazz.getMethod(&lt;span&gt;&quot;getAge&quot;&lt;/span&gt;).invoke(o, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;        System.out.println(age);&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的代码中，首先读取了一个&lt;code&gt;class&lt;/code&gt;文件并通过文件流将它转化为字节数组，之后使用&lt;code&gt;defineClass&lt;/code&gt;方法动态的创建了一个类，并在后续完成了它的实例化工作，流程如下图所示，并且通过这种方式创建的类，会跳过JVM的所有安全检查。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23144654088050315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaBXVnRhkLmPqRRBCrEkM8ERxrLgay1uTLziabeWTEt9QGwP2G3fHxPvy3ZgL0pQyuAZutqmtJOhYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;795&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了&lt;code&gt;defineClass&lt;/code&gt;方法外，Unsafe还提供了一个&lt;code&gt;defineAnonymousClass&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; Class&amp;lt;?&amp;gt; defineAnonymousClass(Class&amp;lt;?&amp;gt; hostClass, &lt;span&gt;byte&lt;/span&gt;[] data, Object[] cpPatches);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用该方法可以用来动态的创建一个匿名类，在&lt;code&gt;Lambda&lt;/code&gt;表达式中就是使用ASM动态生成字节码，然后利用该方法定义实现相应的函数式接口的匿名类。在jdk15发布的新特性中，在隐藏类（&lt;code&gt;Hidden classes&lt;/code&gt;）一条中，指出将在未来的版本中弃用Unsafe的&lt;code&gt;defineAnonymousClass&lt;/code&gt;方法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;8、系统信息&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Unsafe中提供的&lt;code&gt;addressSize&lt;/code&gt;和&lt;code&gt;pageSize&lt;/code&gt;方法用于获取系统信息，调用&lt;code&gt;addressSize&lt;/code&gt;方法会返回系统指针的大小，如果在64位系统下默认会返回8，而32位系统则会返回4。调用pageSize方法会返回内存页的大小，值为2的整数幂。使用下面的代码可以直接进行打印：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;systemTest&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(unsafe.addressSize());&lt;br/&gt;    System.out.println(unsafe.pageSize());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4096&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个方法的应用场景比较少，在&lt;code&gt;java.nio.Bits&lt;/code&gt;类中，在使用&lt;code&gt;pageCount&lt;/code&gt;计算所需的内存页的数量时，调用了&lt;code&gt;pageSize&lt;/code&gt;方法获取内存页的大小。另外，在使用&lt;code&gt;copySwapMemory&lt;/code&gt;方法拷贝内存时，调用了&lt;code&gt;addressSize&lt;/code&gt;方法，检测32位系统的情况。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中，我们首先介绍了Unsafe的基本概念、工作原理，并在此基础上，对它的API进行了说明与实践。相信大家通过这一过程，能够发现Unsafe在某些场景下，确实能够为我们提供编程中的便利。但是回到开头的话题，在使用这些便利时，确实存在着一些安全上的隐患，在我看来，一项技术具有不安全因素并不可怕，可怕的是它在使用过程中被滥用。尽管之前有传言说会在java9中移除Unsafe类，不过它还是照样已经存活到了jdk16，按照存在即合理的逻辑，只要使用得当，它还是能给我们带来不少的帮助，因此最后还是建议大家，在使用Unsafe的过程中一定要做到使用谨慎使用、避免滥用。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>