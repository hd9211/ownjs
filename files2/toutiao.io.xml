<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>fee02787791bff2ba4d82049aa9238f7</guid>
<title>[推荐] 前端进阶不可错过的 10 个 GitHub 仓库</title>
<link>https://toutiao.io/k/2eo05hp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2021 年已经来了，相信有一些小伙伴已经开始立 2021 年的 flag 了。在 2020 年有一些小伙伴，私下问阿宝哥有没有前端的学习资料。为了统一回答这个问题，阿宝哥在元旦期间，精心挑选了 Github 上 10 个不错的开源项目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这 10 个开源项目不仅限于前端领域，希望这些项目对小伙伴的进阶能有所帮助。下面我们先来介绍第一个项目 —— build-your-own-x。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;build-your-own-x&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;🤓 Build your own (insert technology here)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;https://github.com/danistefanovic/build-your-own-x&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Watch&lt;/th&gt;&lt;th&gt;Star&lt;/th&gt;&lt;th&gt;Fork&lt;/th&gt;&lt;th&gt;Date&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;3.5K&lt;/td&gt;&lt;td&gt;92.3K&lt;/td&gt;&lt;td&gt;8.1K&lt;/td&gt;&lt;td&gt;2021-01-04&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该仓库涉及了 27 个领域的内容，每个领域会使用特定的语言来实现某个功能。下图是与前端领域相关的内容：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3X2Ze0rhUM6P7hJYF9YHqvRBwpyJYMvdVuBBtfkVUUnoVtFflosU6icwbLicdMMFibk9yTOjMt4IAZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6444444444444445&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;JavaScript Algorithms&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;https://github.com/trekhleb/javascript-algorithms&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Watch&lt;/th&gt;&lt;th&gt;Star&lt;/th&gt;&lt;th&gt;Fork&lt;/th&gt;&lt;th&gt;Date&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;3.6K&lt;/td&gt;&lt;td&gt;91.6K&lt;/td&gt;&lt;td&gt;15.4K&lt;/td&gt;&lt;td&gt;2021-01-04&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该仓库包含了多种 &lt;strong&gt;基于 JavaScript 的算法与数据结构&lt;/strong&gt;。每种算法和数据结构都有自己的 README，包含相关说明和链接，以便进一步阅读 (还有相关的视频) 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3X2Ze0rhUM6P7hJYF9YHqvIola1CjQaZxKoCfLFoB0dELhGicABKq23fba5WnInlKbnvqjXbIRT2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6305555555555555&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;30 Seconds of Code&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Short JavaScript code snippets for all your development needs&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;https://github.com/30-seconds/30-seconds-of-code&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Watch&lt;/th&gt;&lt;th&gt;Star&lt;/th&gt;&lt;th&gt;Fork&lt;/th&gt;&lt;th&gt;Date&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2K&lt;/td&gt;&lt;td&gt;66.9K&lt;/td&gt;&lt;td&gt;7.4K&lt;/td&gt;&lt;td&gt;2021-01-04&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该仓库包含了众多能满足你开发需求，简约的 JavaScript 代码片段。比如以下的 &lt;code&gt;listenOnce&lt;/code&gt; 函数，可以保证事件处理器只执行一次。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; listenOnce = &lt;span&gt;(&lt;span&gt;el, evt, fn&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; fired = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  el.addEventListener(evt, (e) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!fired) fn(e);&lt;br/&gt;    fired = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  });&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;listenOnce(&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;my-btn&#x27;&lt;/span&gt;),&lt;br/&gt;  &lt;span&gt;&#x27;click&#x27;&lt;/span&gt;,&lt;br/&gt;  () =&amp;gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Hello!&#x27;&lt;/span&gt;)&lt;br/&gt;);  &lt;span&gt;// &#x27;Hello!&#x27; will only be logged on the first click&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3X2Ze0rhUM6P7hJYF9YHqv3wwsg3b9wGn6Sz1n34VdmictA96wghgW9ke6MDnczjmlVjTib452g8pg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.5722222222222222&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Node Best Practices&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;✅ The Node.js best practices list&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;https://github.com/goldbergyoni/nodebestpractices&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Watch&lt;/th&gt;&lt;th&gt;Star&lt;/th&gt;&lt;th&gt;Fork&lt;/th&gt;&lt;th&gt;Date&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1.7K&lt;/td&gt;&lt;td&gt;58.5K&lt;/td&gt;&lt;td&gt;5.6K&lt;/td&gt;&lt;td&gt;2021-01-04&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该仓库介绍了 Node.js 应用的最佳实践，包含以下的内容：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3X2Ze0rhUM6P7hJYF9YHqvLfRQGuRkVUbvjJToDHz565AdUDbgY4GNLlxjl8ODvYfVXV6oDHMj4w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.42685185185185187&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;RealWorld example apps&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&quot;The mother of all demo apps&quot; — Exemplary fullstack Medium.com clone powered by React, Angular, Node, Django, and many more 🏅&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;https://github.com/gothinkster/realworld&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Watch&lt;/th&gt;&lt;th&gt;Star&lt;/th&gt;&lt;th&gt;Fork&lt;/th&gt;&lt;th&gt;Date&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1.6K&lt;/td&gt;&lt;td&gt;52.5K&lt;/td&gt;&lt;td&gt;4.5K&lt;/td&gt;&lt;td&gt;2021-01-04&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大多数的 “Todo” 示例来说，它们只是简单介绍了框架的功能，并没有完整介绍使用该框架和相关技术栈，构建真正应用程序所需要的知识和视角。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RealWorld 解决了这个问题，它允许你选择任意前端框架（React，Vue 或 Angular 等）和任意后端框架（Node，Go，Spring 等）来驱动一个真实的、设计精美的全栈应用程序 “Conduit“ 。下图是目前已支持的前端框架（内容较多，只截取部分内容）：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3X2Ze0rhUM6P7hJYF9YHqvjaWjQcjHN1vbsasgocSicPOd6hO0YdvLiaoADmUrb0o35pE650rx0klg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.5611111111111111&quot; data-w=&quot;1080&quot;/&gt;clean-code-javascript&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;🛁 Clean Code concepts adapted for JavaScript&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;https://github.com/ryanmcdermott/clean-code-javascript&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Watch&lt;/th&gt;&lt;th&gt;Star&lt;/th&gt;&lt;th&gt;Fork&lt;/th&gt;&lt;th&gt;Date&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1.5K&lt;/td&gt;&lt;td&gt;43.9K&lt;/td&gt;&lt;td&gt;5.3K&lt;/td&gt;&lt;td&gt;2021-01-04&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该仓库介绍了如何写出整洁的 JavaScript 代码，比如作者建议使用可检索的名称：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不好的&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 86400000 的用途是什么？&lt;/span&gt;&lt;br/&gt;setTimeout(blastOff, &lt;span&gt;86400000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好的&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 使用通俗易懂的常量来描述该值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; MILLISECONDS_IN_A_DAY = &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;24&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;; &lt;span&gt;//86400000;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;setTimeout(blastOff, MILLISECONDS_IN_A_DAY);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该仓库包含了 11 个方面的内容，具体的目录如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3X2Ze0rhUM6P7hJYF9YHqvicIlfjAgcg81G6wTE82OQLdWL40EVcGB17ib6YUnsCksuyrUXnGtdq1g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6046296296296296&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;javascript-questions&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;A long list of (advanced) JavaScript questions, and their explanations ✨&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;https://github.com/lydiahallie/javascript-questions&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Watch&lt;/th&gt;&lt;th&gt;Star&lt;/th&gt;&lt;th&gt;Fork&lt;/th&gt;&lt;th&gt;Date&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;850&lt;/td&gt;&lt;td&gt;27K&lt;/td&gt;&lt;td&gt;3.6K&lt;/td&gt;&lt;td&gt;2021-01-04&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该仓库包含了从基础到进阶的 JavaScript 知识，利用该仓库你可以测试你对 JavaScript 知识的掌握程度，也可以帮助你准备面试。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3X2Ze0rhUM6P7hJYF9YHqvUeZA5NsciceNiafmRRtcYBIHiaibPjpBHyjFKK5gqiatNRaFexOajrQN2mA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.45740740740740743&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;awesome-design-patterns&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;A curated list of software and architecture related design patterns.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;https://github.com/DovAmir/awesome-design-patterns&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Watch&lt;/th&gt;&lt;th&gt;Star&lt;/th&gt;&lt;th&gt;Fork&lt;/th&gt;&lt;th&gt;Date&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;477&lt;/td&gt;&lt;td&gt;11.6K&lt;/td&gt;&lt;td&gt;931&lt;/td&gt;&lt;td&gt;2021-01-04&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该仓库包含了软件与架构相关的设计模式的精选列表。在软件工程中，设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3X2Ze0rhUM6P7hJYF9YHqvxtWbWSGhGf5pbNDwphv22aUGYdAZGdvRBd4BpbEQMBicU2l8tDTlrgg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6046296296296296&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;developer-roadmap&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Roadmap to becoming a web developer in 2021&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;https://github.com/kamranahmedse/developer-roadmap&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Watch&lt;/th&gt;&lt;th&gt;Star&lt;/th&gt;&lt;th&gt;Fork&lt;/th&gt;&lt;th&gt;Date&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;7.4K&lt;/td&gt;&lt;td&gt;142K&lt;/td&gt;&lt;td&gt;21.3K&lt;/td&gt;&lt;td&gt;2021-01-04&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该仓库包含一组图表，这些图表展示了成为一个 Web 开发者的学习路线图。该仓库含有前端、后端和 DevOps 的学习路线图，这里我们只介绍前端的学习路线图（原图是长图，这里只截取部分区域）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3X2Ze0rhUM6P7hJYF9YHqvcSuxwngQcIUlxGyQeuAOicM5Tde4KGUexsNYIEnRkt8WGWmCpcymsnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.5740740740740741&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Free Programming Books&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;📚 Freely available programming books&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;https://github.com/EbookFoundation/free-programming-books&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Watch&lt;/th&gt;&lt;th&gt;Star&lt;/th&gt;&lt;th&gt;Fork&lt;/th&gt;&lt;th&gt;Date&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;9.2K&lt;/td&gt;&lt;td&gt;170K&lt;/td&gt;&lt;td&gt;39.8K&lt;/td&gt;&lt;td&gt;2021-01-04&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该仓库包含了多种语言的免费学习资源列表，下图是中文免费资源列表（内容较多，只截取部分内容）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3X2Ze0rhUM6P7hJYF9YHqvn0cicjYEuCPXnibGlM2PPHDAbsQD2wFYf0eR5BrBExyhWBrfib1Jvo6WQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.5851851851851851&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的，到这里所有的开源项目都已经介绍完了，如果小伙伴有其他不错的开源项目，欢迎给阿宝哥留言哟。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d7c9156e1af0c7f2d6b3102ee149f3ad</guid>
<title>[推荐] 可能是说的最分明的 IaaS, PaaS, FaaS, SaaS, MicroService, Serverless 了</title>
<link>https://toutiao.io/k/p2q8xl8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;&amp;#10;                col-lg-8 col-lg-offset-2&amp;#10;                col-md-10 col-md-offset-1&amp;#10;                post-container&quot;&gt;

&lt;h2 id=&quot;絮语&quot;&gt;絮语&lt;/h2&gt;
&lt;p&gt;如果说哪个行业最会起名字，那么互联网和软件行业称第二的话，估计没人敢称第一，比如什么复盘，赋能，组合拳，引爆点，泛用型，强化认知….
等等这些让你听了是耳濡目旋的，高大上，我完全不知道啥意思。其实在我看来都是新瓶装旧酒，换个马甲，包装了下、或者说就是不说人话，强行装X了。
今天我们来说说同样也是几个高大上的名词，但是他们其实很好理解，但又相互联系，所以经常让人傻傻分不清。&lt;/p&gt;

&lt;h2 id=&quot;云服务&quot;&gt;云服务&lt;/h2&gt;
&lt;p&gt;从以前还望而却步的云计算到现在我们哪哪都是云服务，云的概念已经从概念落到地上，说到云其实也是个不说人话的装X词，说白了就是我们以前和现在
不停使用的服务器罢了，云计算、云服务就是一种更优化的服务器功能，从只是个服务器硬件本身，升级到在这个硬件中集成了很多方便使用，或者开箱即用的
服务，不需要你知道怎么安装，怎么配置，你只要花钱买了，就开箱即用。即有硬件使用，也有服务提供，这就是云服务。如果云服务还有分类的话，那么就是
下面要说的几个既有区别又有联系的分类了，但是不管这些分类怎么变，名字怎么起，怎么高大上，其实在我看来，就是作为客户的你（软件开发者）花钱享受不同
服务，统统都是简化了你要做的事情，把复杂的事情简单了，花钱就行了。看着很憷人，其实很简单。&lt;/p&gt;

&lt;h2 id=&quot;iaas&quot;&gt;IaaS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;基础设施服务，Infrastructure as a service&lt;/strong&gt;，如果把软件开发比作厨师做菜，那么IaaS就是他人提供了厨房，炉子，锅等基础东西，
你自己使用这些东西，自己根据不同需要做出不同的菜。&lt;/p&gt;

&lt;h2 id=&quot;paas&quot;&gt;PaaS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;平台服务，Platform as a service&lt;/strong&gt;，还是做菜比喻，比如我做一个黄焖鸡米饭，除了提供基础东西外，那么PaaS还给你提供了现成剁好的鸡肉，土豆，辣椒，
你只要把这些东西放在一起，加些调料，用个小锅子在炉子上焖个20分钟就好了。&lt;/p&gt;

&lt;h2 id=&quot;faas&quot;&gt;FaaS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;函数服务，Function as a Service&lt;/strong&gt;，同样是做黄焖鸡米饭，这次我只提供酱油，色拉油，盐，醋，味精这些调味料，其他我不提供，你自己根据不同口味是多放点盐，
还是多放点醋，你自己决定。&lt;/p&gt;

&lt;h2 id=&quot;saas&quot;&gt;SaaS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;软件服务，Software as a service&lt;/strong&gt;，同样还是做黄焖鸡米饭，这次是直接现成搞好的一个一个小锅的鸡，什么调料都好了，已经是个成品了，你只要贴个牌，直接卖出
去就行了，做多是在炉子上焖个20分钟。&lt;/p&gt;

&lt;h2 id=&quot;microservice&quot;&gt;MicroService&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;微服务，Micro service&lt;/strong&gt;，微服务是服务整体的细化，如果还是做黄焖鸡米饭，就好比一家供应商提供好了所有调料，一家供应商提供好了所有的鸡块等食材，你只要把这两
家供应商提供的东西做成黄焖鸡米饭就行了。&lt;/p&gt;

&lt;h2 id=&quot;serverless&quot;&gt;Serverless&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;无服务，Server less&lt;/strong&gt;，说是无，其实有，无服务就是一种没有感知的服务，你不需要知道它怎么实现的。如果还是做黄焖鸡米饭，无服务在这里可以比喻为买一袋已经调味好的调料包，你直接往黄焖鸡里倒
就行了，至于怎么调出的口味你不需要知道。&lt;/p&gt;

&lt;p&gt;下面就没有黄焖鸡了😄，我下面需要重点说说几个架构的实体&lt;/p&gt;

&lt;h2 id=&quot;serverless的历史&quot;&gt;Serverless的历史&lt;/h2&gt;
&lt;p&gt;Serverless的概念并不清晰，乍见之下，很容易让人混淆硬件服务器及软件上的服务与其所谓的“服务器”差别，在这里强调的所谓“无服务器”指的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;我们的代码不会明确地部署在某些特定的软件或者硬件的服务器上。
运行代码托管的环境是由例如阿里云或者腾讯云这样的云计算厂商所提供&lt;/code&gt;。其实这听上去又很像Paas,SaaS,FaaS,不错，所以他们之间也充满了联系。&lt;/p&gt;

&lt;h2 id=&quot;serverless-与-paas&quot;&gt;Serverless 与 PaaS&lt;/h2&gt;
&lt;p&gt;PaaS是平台即为服务，Serverless相当于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;平台&lt;/code&gt;提供了更加细粒度和碎片化的服务，从这个层次来说，Serverless=PaaS。&lt;/p&gt;

&lt;h2 id=&quot;serverless-与-saas&quot;&gt;Serverless 与 SaaS&lt;/h2&gt;
&lt;p&gt;SaaS是软件本身即为服务，Serverless相当于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;软件&lt;/code&gt;提供了更加细粒度和碎片化的服务，因为Serverless也是一种软件，从这个层次来说，Serverless=SaaS。&lt;/p&gt;

&lt;h2 id=&quot;serverless-与-faas&quot;&gt;Serverless 与 FaaS&lt;/h2&gt;
&lt;p&gt;FaaS是函数即为服务，Serverless相当于提供的更加细粒度和碎片化服务是一种&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;函数&lt;/code&gt;，从这个层次来说，Serverless=FaaS。&lt;/p&gt;

&lt;h2 id=&quot;serverless-与-microservice&quot;&gt;Serverless 与 MicroService&lt;/h2&gt;
&lt;p&gt;MicroService是微服务，是一种专注于单一责任与功能的小型服务，Serverless相当于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;更加细粒度和碎片化&lt;/code&gt;的单一责任与功能小型服务，他们都是一种特定的小型服务，
从这个层次来说，Serverless=MicroService。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;这几个之间有这么多联系，但是从架构的定义范围也有个包含关系，PaaS &amp;gt; SaaS &amp;gt; FaaS &amp;gt; MicroService &amp;gt; Serverless&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;最后还有个-servicemesh&quot;&gt;最后还有个 ServiceMesh&lt;/h2&gt;
&lt;p&gt;ServiceMesh叫做服务网格，他是依存于MicroService微服务架构存在的，因为微服务之间需要通信，需要数据交换同步等操作。在没有ServiceMesh之前微服务的
通信，数据交换同步也存在，也有比较好的解决方案，如Spring Clould，OSS，Double这些，但他们有个最大的特点就是需要你写入代码中，而且需要深度的写
很多逻辑操作代码，这就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;侵入式&lt;/code&gt;。而ServiceMesh最大的特点是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;非侵入式&lt;/code&gt;，不需要你写特定代码，只是在云服务的层面即可享受微服务之间的通信，数据交换同步等操作，
这里的代表如，docker+K8s，istio，linkerd等。 &lt;br/&gt;
从这里你也可以看出，所有新出来的高大上的东西，都是在简化你的工作。以前可能需要你造轮子才可以，然后到用现成的轮子就可以，再到连轮子你都看不见花钱就可以了🙂。&lt;/p&gt;



                &lt;hr/&gt;

                


                
                
                
                
                
                &lt;p id=&quot;gitalk-container&quot;/&gt;
                
                
                
                
                
                

                

            &lt;/div&gt;  

    
        
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ebc0412367ef07bd26aa88a323abd6e8</guid>
<title>[推荐] 闯过这 54 关，点亮你的 Git 技能树</title>
<link>https://toutiao.io/k/6kqnm2d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;card-body markdown markdown-toc&quot;&gt;
        
        &lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/36eaf186-6a61-427b-8972-04c65a57ad07.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开篇&quot;&gt;开篇&lt;/h2&gt;
&lt;p&gt;如今，Git 大行其道，颇有一统天下之势。
如果你的技能树上 Git 和 Github 的图标还没有点亮的话，你都不好意思说你是程序员。
别说互联网企业，我接触到的许多传统企业都在从 SVN，Clear Case 等迁移到 Git 上，甚至大厂还会有一个团队去定制适合自己企业的 Git 服务器。&lt;/p&gt;

&lt;p&gt;很多人简历上写的「精通 Git 与 Github」，但如果你问他熟悉到什么程度的话，回答通常是「就是会用常用的 add，commit，push 操作」。&lt;/p&gt;

&lt;p&gt;但工作中我们会遇到一些更加复杂的场景：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;忽略某些文件&lt;/li&gt;
&lt;li&gt;创建，删除分支&lt;/li&gt;
&lt;li&gt;找到最后修改某行代码的人&lt;/li&gt;
&lt;li&gt;commit 后发现里边包含一个不应该提交的文件&lt;/li&gt;
&lt;li&gt;commit 后发现少提交了一些文件&lt;/li&gt;
&lt;li&gt;一个文件中的多次有改动，怎么做到只提交其中的一部分？&lt;/li&gt;
&lt;li&gt;怎样整理提交记录使其更加整洁？&lt;/li&gt;
&lt;li&gt;快速定位是哪一次提交引入了 bug&lt;/li&gt;
&lt;li&gt;...
作为一线程序员，我们要如何快速学习 Git 以发挥其最大威力呢？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今天我就要向大家介绍一个工具，准确说应该是「游戏」，名字叫「githug」，它把平常可能遇到的一些场景都实例化，变成一个一个的关卡，一共有 55 个关卡：&lt;/p&gt;
&lt;pre class=&quot;highlight plaintext&quot;&gt;&lt;code&gt;#1: init
#2: config
#3: add
#4: commit
#5: clone
#6: clone_to_folder
#7: ignore
#8: include
#9: status
#10: number_of_files_committed
#11: rm
#12: rm_cached
#13: stash
#14: rename
#15: restructure
#16: log
#17: tag
#18: push_tags
#19: commit_amend
#20: commit_in_future
#21: reset
#22: reset_soft
#23: checkout_file
#24: remote
#25: remote_url
#26: pull
#27: remote_add
#28: push
#29: diff
#30: blame
#31: branch
#32: checkout
#33: checkout_tag
#34: checkout_tag_over_branch
#35: branch_at
#36: delete_branch
#37: push_branch
#38: merge
#39: fetch
#40: rebase
#41: repack
#42: cherry-pick
#43: grep
#44: rename_commit
#45: squash
#46: merge_squash
#47: reorder
#48: bisect
#49: stage_lines
#50: find_old_branch
#51: revert
#52: restore
#53: conflict
#54: submodule
#55: contribute
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;首先我们需要来安装这个游戏，「githug」是用 Ruby 编写的，可通过如下命令安装：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;gem install githug&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果遇到权限问题，请加上 sudo：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;sudo gem install githug&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安装成功后，在 Terminal 里进入你常用的目录，输入 githug，会提示游戏目录不存在，是否要创建一个，输入 y 然后回车：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/33bb1b0e-b9bc-4c91-9930-f89aa1432273.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;根据提示&lt;code&gt;cd git_hug&lt;/code&gt; 进入游戏目录，准备开始游戏。&lt;/p&gt;
&lt;h2 id=&quot;基本命令&quot;&gt;基本命令&lt;/h2&gt;
&lt;p&gt;在开始前我们还需要了解游戏的一些基本操作：&lt;/p&gt;

&lt;p&gt;play - 默认命令，检查是否过关
hint - 显示过关提示
reset - 重启本关，或者重启到指定的某关
levels - 显示关卡列表
来试一下，githug reset：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/05f415e3-0be9-4e00-bca0-daf954e4c5f1.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;我以第一关为例子给大家演示一下玩法。&lt;/p&gt;

&lt;p&gt;第一关的名称是：init，提示是：「一个新目录 git_hug 被创建了，请把它初始化为一个空仓库」。
假设现在我不知道该怎么过关，我可以查看过关提示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/da0dc920-1714-4909-bbdd-85446d4c4c48.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;指示是：「你可以输入 git 命令来查看 git 命令列表」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/00b90da9-0f2e-429f-83c7-499d9dee0f5c.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看最后一行，原来用 git init 就可以初始化一个空仓库，接着输入 githug 进行过关检测：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/a2d14c4f-8586-4c20-b9cf-ec948a2eb427.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;太棒了！顺利进入第二关！&lt;/p&gt;

&lt;p&gt;怎么样？明白了吗？后面的 54 关就靠你自己了哦！&lt;/p&gt;
&lt;h2 id=&quot;友情提示&quot;&gt;友情提示&lt;/h2&gt;
&lt;p&gt;在闯关过程中，尽量使用 githug hint，git help subcommand 获取帮助，也可以根据下面的教程来系统学习：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://backlog.com/git-tutorial/cn/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;&quot;&gt;猴子都能懂的 git 入门&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为保大家都能顺利通关，学到所有的知识点，接下来我会写过关攻略，详细介绍每一关的玩法。&lt;/p&gt;

&lt;p&gt;并且我不会直接给答案，而是演示整个过关的过程。&lt;/p&gt;
        &lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://codingstyle.cn&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;「软件匠艺社区」&lt;/a&gt;旨在传播匠艺精神，通过分享好的「工作方式」，让帮助程序员更加快乐高效地编程！&lt;/p&gt;&lt;/blockquote&gt;
      &lt;/div&gt;
      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dac406fa71b68b094caef9baf2d7ad20</guid>
<title>[推荐] 最近的一些 Java 面试小结</title>
<link>https://toutiao.io/k/ffm07xa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前段时间陆续面试了一些大中小公司，踩了不少坑，挂了很多，同时也有不少感悟和收获。这里想把那段经历记录一下，如果能对亲们有所帮助就再好不过了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试的过程其实也是一个自我认识和学习的过程，即便暂时没打算跳槽，隔段时间出去面一面对自己还是有些好处的：不仅可以评估一下自己在市场的价值和竞争力，同时也能了解一些新技术、更新一下自己的技术栈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且在一个地方待久了，可能不自觉的就会陷入到一种「舒适区」，久而久之，就像温水里的青蛙，万一哪天被“优化”了可能会不知所措。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要从「项目」和「技术」两个方面进行总结，除此之外还有一些比较开放式的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;元旦过了，“金三银四”还会远吗？春节后有想法的亲们，可以嗨起来了！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;项目&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人说：三年一道坎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于工作三年左右的伙伴们来说，「项目经历」可谓重中之重，可以说比具体的技术点更重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术点其实大同小异，有些临时刷刷题就能了解个大概。但项目经历往往难以临时编造，如果不是自己真实做过的项目、或者没有充分的准备，一旦面试官问得稍微深入很可能 hold 不住，面试扣分不少、甚至可能直接挂掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此不少面试官喜欢从项目入手，抽丝剥茧、步步深入，通过项目把技术点串起来考察。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同人的项目千差万别，但还是有一些共同亮点的：比如高并发场景，复杂的架构设计，JVM 调优及问题排查等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些亮点有的话固然更好，但如果平时 CRUD 居多、没太多的亮点，其实也不必太慌，技术亮点不多的话，可以多思考一些业务上的亮点，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;业务模型比较复杂&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对业务整体的架构设计很熟悉&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务模块拆分比较合理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自己在业务中做过哪些扩展和优化？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务数据的上下游流转是怎样的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;遇到过什么问题，如何解决的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些其实也是亮点，可以让面试官看到你平时对业务有自己的思考和理解，而不是只关注自己的那一块，不只是写代码的机器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实面试官对你的项目是一无所知的，他的印象仅仅停留在你简历上描述的那些文字（而且有些面试官可能是被临时拉过来的，别问我为什么知道🐶）。面试官通常的开场白就是让你自我介绍，其实这也是一个考察语言组织能力和口头表达能力的地方。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;技术&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们面的毕竟是技术岗，技术本身的重要性不言而喻。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术面试中，最重要的可以说是「技术体系」。也就是你不仅要有技术的深度和广度，更要能把它们串起来，其实有不少技术点是相通或相似的，如果面试中能够触类旁通、举一反三，是一个很好的加分项。比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Redis 的 AOF 和 MySQL 的 bin log&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring 中的 BeanDefinition 和 JVM 中类的元信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;布隆过滤器和 HashMap&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术的积累虽然主要在平时，但刷刷面试题还是很有必要的，有不少其实就是所谓的“八股文”。这里主要列出本人面试过程中真实遇到的一些面试题，仅供参考。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;锁&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;synchronized 锁升级过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ReentrantLock&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现原理（AQS）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;公平锁如何实现？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile 特性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;HashMap&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HashMap &amp;amp; ConcurrentHashMap 实现原理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ConcurrentHashMap 如何实现线程安全&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;索引&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分类？使用场景？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InnoDB 索引的结构（B+树），为什么不用 B 树？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何查看索引的使用情况？Explain 关注哪些字段？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;事务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;常用数据结构&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常见缓存问题&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;缓存穿透、缓存击穿、缓存雪崩、热点 key&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何解决上述问题？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;持久化：RDB、AOF，二者区别&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 为什么快？线程模型是怎样的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存满了怎么办？淘汰策略有哪些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用什么集群框架？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;IoC、AOP 实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务传播特性、失效场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JDK &amp;amp; CGLib 区别&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Boot 启动原理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Dubbo&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Dubbo 架构&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;负载均衡算法、容错策略、灰度测试&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SPI 机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RPC 调用过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RPC &amp;amp; HTTP&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;二者区别与联系&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么 Spring Cloud 使用 HTTP 而非 RPC？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;JVM&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;运行时内存划分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;垃圾收集算法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个对象的内存分配过程？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMS 收集器&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;收集过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;哪个过程会有 STW？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何处理内存碎片问题？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;G1 收集器特点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GC Roots 有哪些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JVM 常用参数配置有哪些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存占用过多，如何排查？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;RocketMQ&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;整体架构&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何保证消息的可靠性？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何实现顺序消息？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者接口幂等设计&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务消息实现&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;分布式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分布式锁&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Redis 如何实现？命令？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ZooKeeper 如何实现？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取锁失败时如何处理？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;分布式事务&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;2PC：缺点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3PC：解决了 2PC 什么问题？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TCC：缺点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最终一致性：MQ 实现流程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现框架（Seata）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上面的「项目」和「技术」，可能还会问到一些其他问题，比如场景设计与分析、算法，还可能有一些比较开放的问题，下面介绍下我所遇到的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;场景设计&amp;amp;分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较典型的场景设计，电商类的公司很可能会问到，网上有很多案例和文章分析，这里不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个应该不是热门，本人也就遇到过一次，不过那一次被搞得有点懵，可能更多的是考察思路，大家可以多思考一下。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;JVM 问题排查：线上 JVM 内存、CPU 飙升，如何去排查？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要涉及一些常用的 Linux 命令和 JDK 自带工具，比如 top、jstack、jmap 等，以及阿里的开源工具 Arthas 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在实际情况中我们可能很少有机会接触（小小开发通常没权限，还是要运维大佬支持），但这些工具还是要了解的，可以在本地跑个 Demo 去验证，以免到时候答不上来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如线上所有机器（包括服务器、数据库、缓存服务器）全部宕机，如何处理？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;PS: 这些场景设计和分析的问题，通常比较综合，一般是考察对一个场景的整体设计，或者分析和解决问题的思路。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;算法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;PS: 算法问题遇到的不是很多，有些考察算法可能就是单纯的面试流程。当然，字节这类的公司除外，想去的话肯定还是要刷很多算法的。&lt;/p&gt;&lt;p&gt;相比之下，大部分公司更注重「项目深度」和「技术体系」，或者给出一些实际的场景，考察分析和解决问题的经验和思路。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;开放问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些问题比较开放，没有固定的答案，可能就是面试官想看下你的临场发挥吧。遇到的几个问题如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有没有带过人？经历是怎样的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你作为 PM，如何从整体协调一个项目？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你在团队推行 DDD，你会怎么做？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你有什么缺点？优点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;未来三年的职业规划？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在公司主要有哪些成长？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上级、同事对你的评价？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最近在看什么书？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;末了&lt;/span&gt;&lt;/h1&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;面试流程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我所接触的面试大部分是「三轮技术面 + HR 面」的形式，也有一些是两轮技术面，不同公司可能不太一样。一面一般是电话面初筛，后面二三轮技术面和 HR 面通常在一起。这样其实也挺好，跑一趟就行了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;心态&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试的心态也很重要。其实你跟面试官之间是平等的，面试的过程是让他对你更加了解，而不是他对你的考核。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我刚开始面的时候，&lt;/span&gt;&lt;span&gt;由于好久没面试，再加上本来就不太爱说话，刚开始紧张的不行，后来面了几次之后才逐渐有点感觉。&lt;/span&gt;&lt;span&gt;如果较长时间没面试，可以先面一两家练练手、找找感觉。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，整个面试时间也不建议拖得太久，否则整个过程会比较累，最好还是一鼓作气。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;啰里啰嗦一堆，其实面试还是挺看运气的，如果跟面试官聊得比较投机，对你的评分自然也不错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，预祝想跳槽的亲们一路绿灯！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/ophTb90oYCR6eOZrkKMnznEahtiajNrSAicJDk24paw3VDzbZRLXgyibXWEuZ4qhuSgXoeFaqj1gpV96gVpZCHc7g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a339859a171241e036f2091c29c7fb45</guid>
<title>[推荐] Java 线程池总结</title>
<link>https://toutiao.io/k/4z3o5gw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;Java线程池的写法和参数是面试中出现频率很高的基础题。越是基础的东西，特别是对高阶职位的面试者，需要回答的符合自己面试的职位等级。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;这里也不能说是一个多么好的答案，只是说如果是我，我怎么回答，仅供参考。以下回答可想象为面试官的问题是：谈谈线程池。&lt;/section&gt;&lt;section&gt;主要的思路是作为一个宽泛的问题，回答需要体现结构化的思维，这是必选项。在此基础上，可以体现深度，这是加分项。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回答&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线程池设计目标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;Java的线程主流实现都是采用&lt;span&gt;&lt;strong&gt;内核级线程&lt;/strong&gt;&lt;/span&gt;实现，创建线程要进行操作系统状态切换。为了避免资源过度消耗需要设法重用线程执行多个任务。线程池就是一个线程缓存，负责对线程进行统一分配、调优与监控。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线程池实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3477406679764244&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8eRqdxL261ptdgllN1sRBnzvrVJ4UQibWWKxm5Uv2cnS5hUKVtkj67aWnIqaiaxweqycnNhzsYJvTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1527&quot;/&gt;&lt;/p&gt;&lt;section&gt;如上图所示，线程池的Java实现都是继承于JUC(java.util.concurrent)的Executor接口。这个接口只有一个execute方法，代表了其行为。ExecutorService接口继承Executor，加上了生命周期的处理方法。其常用实现类如：ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool的默认参数构造类都有在Executors这个工具类里直接实例化。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;但是阿里巴巴开发手册不推荐使用Executors这个工具类。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2966360856269113&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8eRqdxL261ptdgllN1sRBnx35gicziapBjKRiagEsicicpboyZrODspibicib5ic7HYCMiboBQp0pZnQC0iarjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;981&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;于是，我们需要自己了解ThreadPoolExecutor初始化参数的含义和使用方法。&lt;/section&gt;&lt;pre&gt;&lt;span&gt;/**&lt;br/&gt; * Creates a new {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;ThreadPoolExecutor} with the given initial&lt;br/&gt; * parameters and default rejected execution handler.&lt;br/&gt; *&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@param &lt;/span&gt;&lt;span&gt;corePoolSize &lt;/span&gt;&lt;span&gt;the number of threads to keep in the pool, even&lt;br/&gt; *        if they are idle, unless {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;allowCoreThreadTimeOut} is set&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@param &lt;/span&gt;&lt;span&gt;maximumPoolSize &lt;/span&gt;&lt;span&gt;the maximum number of threads to allow in the&lt;br/&gt; *        pool&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@param &lt;/span&gt;&lt;span&gt;keepAliveTime &lt;/span&gt;&lt;span&gt;when the number of threads is greater than&lt;br/&gt; *        the core, this is the maximum time that excess idle threads&lt;br/&gt; *        will wait for new tasks before terminating.&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@param &lt;/span&gt;&lt;span&gt;unit &lt;/span&gt;&lt;span&gt;the time unit for the {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;keepAliveTime} argument&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@param &lt;/span&gt;&lt;span&gt;workQueue &lt;/span&gt;&lt;span&gt;the queue to use for holding tasks before they are&lt;br/&gt; *        executed.  This queue will hold only the {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;Runnable}&lt;br/&gt; *        tasks submitted by the {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;execute} method.&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@param &lt;/span&gt;&lt;span&gt;threadFactory &lt;/span&gt;&lt;span&gt;the factory to use when the executor&lt;br/&gt; *        creates a new thread&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@throws &lt;/span&gt;&lt;span&gt;IllegalArgumentException if one of the following holds:&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;*         {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;corePoolSize &amp;lt; 0}&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;*         {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;keepAliveTime &amp;lt; 0}&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;*         {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;maximumPoolSize &amp;lt;= 0}&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;*         {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;maximumPoolSize &amp;lt; corePoolSize}&lt;br/&gt; * &lt;/span&gt;&lt;span&gt;@throws &lt;/span&gt;&lt;span&gt;NullPointerException if {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;workQueue}&lt;br/&gt; *         or {&lt;/span&gt;&lt;span&gt;@code &lt;/span&gt;&lt;span&gt;threadFactory} is null&lt;br/&gt; */&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;corePoolSize&lt;span&gt;,&lt;br/&gt;                          int &lt;/span&gt;maximumPoolSize&lt;span&gt;,&lt;br/&gt;                          long &lt;/span&gt;keepAliveTime&lt;span&gt;,&lt;br/&gt;                          &lt;/span&gt;TimeUnit unit&lt;span&gt;,&lt;br/&gt;                          &lt;/span&gt;BlockingQueue&amp;lt;Runnable&amp;gt; workQueue&lt;span&gt;,&lt;br/&gt;                          &lt;/span&gt;ThreadFactory threadFactory) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;(corePoolSize&lt;span&gt;, &lt;/span&gt;maximumPoolSize&lt;span&gt;, &lt;/span&gt;keepAliveTime&lt;span&gt;, &lt;/span&gt;unit&lt;span&gt;, &lt;/span&gt;workQueue&lt;span&gt;,&lt;br/&gt;         &lt;/span&gt;threadFactory&lt;span&gt;, &lt;/span&gt;&lt;span&gt;defaultHandler&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;ThreadPoolExecutor有6个参数，第一个是核心线程数，如果线程池无事可做，还是会保留这些线程。第二个是最大线程数，超过核心线程数的部分都会在第三个和第四个参数合起来决定的最长空闲存活时间超过后被剔除。第五个参数是阻塞队列，线程忙不过来要去这里面排队。最后一个是线程池工厂，主要决定队列也装不下的线程怎么处理，默认策略是抛出异常。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线程池的5种状态设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.369672131147541&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8eRqdxL261ptdgllN1sRBn63JhIzHef1f9QicHHWP1sDOJgfZvGj0icm4ia9SLU9iaibkGjQAm6VUlOow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1220&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.47711088504577825&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8eRqdxL261ptdgllN1sRBnM9d6vLKMnsgy2PRUol8FqaMOdDnM5hia6pBuWNDhO7XJ0erg2iafjYFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;983&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;线程池的底层原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;Java线程的实现是通过调用native方法调用操作系统的pthread API，由内核线程统一管理。一个实现了Runnable的类只是标识可用多线程运行，真正产生大开销的是new Thread()时进行的内核调用。而线程池技术将worker线程缓存下来进行重用。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;补充问答&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线程池的关闭&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关闭线程池可以调用shutdownNow和shutdown两个方法来实现。&lt;br/&gt;shutdownNow：对正在执行的任务全部发出interrupt()，停止执行，对还未开始执行的任务全部取消，并且返回还没开始的任务列表。&lt;br/&gt;shutdown：当我们调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;线程池都有哪几种工作队列&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1、ArrayBlockingQueue&lt;br/&gt;是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。&lt;br/&gt;2、LinkedBlockingQueue&lt;br/&gt;一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列&lt;br/&gt;3、SynchronousQueue&lt;br/&gt;一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。&lt;br/&gt;4、PriorityBlockingQueue&lt;br/&gt;一个具有优先级的无限阻塞队列。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;ForkJoinPool的原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;本质上将一个任务进一步细分，内部使用“工作窃取”算法，让任务在各个CPU上尽可能均衡。&lt;/section&gt;&lt;p&gt;（1）每个工作线程都有自己的工作队列WorkQueue；&lt;/p&gt;&lt;p&gt;（2）这是一个双端队列，它是线程私有的；&lt;/p&gt;&lt;p&gt;（3）ForkJoinTask中fork的子任务，将放入运行该任务的工作线程的队头，工作线程将以LIFO的顺序来处理工作队列中的任务；&lt;/p&gt;&lt;p&gt;（4）为了最大化地利用CPU，空闲的线程将从其它线程的队列中“窃取”任务来执行；&lt;/p&gt;&lt;p&gt;（5）从工作队列的尾部窃取任务，以减少竞争；&lt;/p&gt;&lt;p&gt;（6）双端队列的操作：push()/pop()仅在其所有者工作线程中调用，poll()是由其它线程窃取任务时调用的；&lt;/p&gt;&lt;p&gt;（7）当只剩下最后一个任务时，还是会存在竞争，是通过CAS来实现的；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;本文的回答部分从线程池实现目标、实现和关键设计、底层原理四个方面说明线程池，具有一定的系统性。补充问答部分作为问题的深入在面试时被深入提问问到或者面试官示意继续深入来说的时候使用。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>