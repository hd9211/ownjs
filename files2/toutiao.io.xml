<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c316a4c810aa0dcfaf812443d529f43a</guid>
<title>volatile 关键字的原理和要避免的误区</title>
<link>https://toutiao.io/k/eu5utzp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    最近做code review看到有的同学在承载缓存数据的变量里加了volatile关键字。想起来之前项目中也看到有的同学习惯在从配置中心获取的配置数据的变量上加volatile。今天就来探讨一下这个volatile加的有没有必要。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;volatile关键字的作用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1&amp;gt;防止指令重排&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2&amp;gt;禁用工作内存缓冲区，直接使用主内存。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;经典使用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;场景1&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public static &lt;/span&gt;Singleton &lt;span&gt;getInstance&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;检查     &lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;if &lt;/span&gt;(instance == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;synchronized &lt;/span&gt;(Singleton.&lt;span&gt;class&lt;/span&gt;) {    &lt;span&gt;//1     &lt;br/&gt;&lt;/span&gt;&lt;span&gt;            //&lt;/span&gt;&lt;span&gt;第二次&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;检查       &lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;if &lt;/span&gt;(instance == &lt;span&gt;null&lt;/span&gt;) {          &lt;span&gt;//2  &lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;instance = &lt;span&gt;new &lt;/span&gt;Singleton()&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//3  &lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return &lt;/span&gt;instance&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;section&gt;&lt;span&gt;如果不用volatile，则因为内存模型允许所谓的“无序写入”，可能导致失败&lt;/span&gt;。某个线程可能会获得一个未完全初始化的实例。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;场景2&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;private volatile int &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读&lt;/span&gt;&lt;span&gt;操作，没有&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;，提高性能&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public int &lt;/span&gt;&lt;span&gt;getValue&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;return &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写操作，必&lt;/span&gt;&lt;span&gt;须&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;。因&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;x++&lt;/span&gt;&lt;span&gt;不是原子操作&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public synchronized int &lt;/span&gt;&lt;span&gt;increment&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;return &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;++&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这段代码，可实现一个线程间安全的计数器。因为加了valatile关键字。每次线程都能取到最新值做加减。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;要避免的误区&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;在代码评审的时候看到volatile被滥用的情况。说说我个人的看法：很少变化，对时间不是特别敏感的情况下不建议用volatile关键字。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;举个例子：从公司的配置中心取到一个配置数据。不建议用volatile。&lt;/section&gt;&lt;p&gt;一般来说配置中心的架构是下面这个样子&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6354359925788498&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicNcqZhVe4vd5J2Jf0h4jFSfeTE1z4e65EWhF5nK7xeQlIUDo8CqTJlGqVibQ78ziah43dzdmWssD6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1078&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;一条数据从用户变更到集中存储的配置中心，配置中心下发到真正使用的机器上，之前公司是要经过90s(客户端90s为周期定时去配置中心取最新数据)。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;加了volatile关键字在这种场景只是能更快的看到这个最新值而已。下面我们来测试下这个【更快】有多久。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;span&gt;public class &lt;/span&gt;VolatileTest {&lt;br/&gt;    &lt;span&gt;private boolean &lt;/span&gt;&lt;span&gt;endRun &lt;/span&gt;= &lt;span&gt;false;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;noVolatile&lt;/span&gt;() &lt;span&gt;throws &lt;/span&gt;Exception {&lt;br/&gt;        Runnable r1 = &lt;span&gt;new &lt;/span&gt;Runnable() {&lt;br/&gt;            &lt;span&gt;public void &lt;/span&gt;&lt;span&gt;run&lt;/span&gt;() {&lt;br/&gt;                &lt;span&gt;int &lt;/span&gt;i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                while &lt;/span&gt;(!&lt;span&gt;endRun&lt;/span&gt;) {&lt;br/&gt;                    System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;I am still running&quot; &lt;/span&gt;+ i++)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;}&lt;br/&gt;            }&lt;br/&gt;        }&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;Runnable r2 = &lt;span&gt;new &lt;/span&gt;Runnable() {&lt;br/&gt;            &lt;span&gt;public void &lt;/span&gt;&lt;span&gt;run&lt;/span&gt;() {&lt;br/&gt;                &lt;span&gt;endRun &lt;/span&gt;= &lt;span&gt;true;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;        }&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        new &lt;/span&gt;Thread(r1).start()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        new &lt;/span&gt;Thread(r2).start()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;Thread.&lt;span&gt;sleep&lt;/span&gt;(&lt;span&gt;9000&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;end run&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;section&gt;这个代码里，在第一个线程使用endRun这个变量。第二个线程去改变endRun这个变量的值。一旦第一个线程看到了第二个线程的值的变化，就会马上停止循环。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;运行结果如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4942528735632184&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicNcqZhVe4vd5J2Jf0h4jFSPXLsLhzx9xMulY93Nrc0LKOlcPcJhtkSvMQzkHbzHESqKos95DfMpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;261&quot;/&gt;&lt;/p&gt;&lt;section&gt;说明经过了两个循环的时间，线程就读到了另外一个线程变化的值。对照下面的时间延迟表，我们来计算下：&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7601572739187418&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9RTU7bAofugt8DV5hAXftYHvgaP1abOyv9GdeBicEJTAwvpoTEm4FULj9GmicibBKc0vsLM8ykF9HhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;763&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;平均执行一行简单代码要执行5个指令。如上执行一个指令需要1ns。每次循环执行2行代码，从运行结果来看共执行了2次。共5*1*2*2=20ns。实际数据应该不是如此，而且是变化的。但是应该都是ns级别的。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;相比较90s的可见性延迟，ns级别可以忽略不计。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;再看看为了早ns级看到结果，所花费的开销：volatile关键字本质是让L1缓存、L2缓存这种cpu缓存失效了，直接主存访问。如果要访问的字段在L1缓存里，从配置中心取的数据1天变化一次。以字段放在L2缓存为例。加了volatile关键字，访问时间要从4ns上升到100ns，如果这个变量每个请求都要访问，每秒QPS是1000。则1天为了取这个数据将多花1*24*3600*1000*(100-4)ns约等于8300ms。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;相比获得的收益来讲，代价要大出好几个数量级。但是本身的时间开销本来就很小，坦白说一般的系统一天多花个8.3s也是可以接受的。但是这样的变量多了，也是个不小的负担。而且这个负担会随着系统压力增加而加重。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;定时将缓存加载到内存原理相同，不建议使用volatile。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;其他引申思考&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;上面结论是在对时间敏感度不高的情况下不建议用volatile，但是对于一般的系统，用了对系统的影响也还好。最怕的事情是做了一个实际上意义并不大，却引入系统风险的优化。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;上周我review同学的代码，这个同学是个有技术追求的同学。喜欢写代码的时候进行些小优化。这是个好习惯。但是对review代码的人要求很高。因为普通的业务逻辑影响的就是那么一块范围内的。但是优化却可能会影响其他部分。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;这次他在好几处，把原来打印更新缓存的日志里，原来只打印：【更新缓存成功】的地方加了个【更新缓存成功，影响数据XX条】。这个XX取的是guava Cache的.size()方法。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;这段代码我仔细看了guava cache的初始化方法，这个初始化方法非常复杂，里面用了几处断言(不能为空)。这个初始化方法没有统一的try catch捕获异常，一旦有地方抛出异常。有可能会没有完全实例化。我把自己的这个想法提了出来。他通过代码走查梳理向我证明了，确实不会有空指针的情况。我同意他是对的。但是这整个过程说明了我对这件事情的谨慎。如果我们上线了一个功能，功能有问题，新功能上线会有灰度、观察期慢慢上量的过程，影响不会多大。但是改了其他部分，特别是感觉绝对不会有问题的部分。如果出现问题了，自己团队的信任分一下子就会降下来了。以后再进行变更，需要反复证明影响，非常被动。&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa820b31fcae6d2b121d38fdad76e437</guid>
<title>性能优化：线程资源回收</title>
<link>https://toutiao.io/k/wllqesw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;src-views-article-detail-main-module__content--2qOBd markdown-body&quot;&gt;&lt;h2&gt;一、问题&lt;/h2&gt;
&lt;p&gt;模型服务平台的排序请求出现较多超时情况，且不定时伴随空指针异常。&lt;/p&gt;
&lt;h2&gt;二、问题发生前后的改动&lt;/h2&gt;
&lt;p&gt;召回引擎扩大了召回量，导致排序请求的item数量增加了。&lt;/p&gt;
&lt;h2&gt;三、出问题的模型&lt;/h2&gt;
&lt;p&gt;基于XGBoost预测的全排序模型。&lt;/p&gt;
&lt;h2&gt;四、项目介绍&lt;/h2&gt;
&lt;p&gt;web-rec-model：模型服务平台。用于管理排序模型：XGBoost、TensorFlow、pmml…召回模型：item2item，key2item，vec2item…等模型的上下线、测试模型一致性、模型服务等。&lt;/p&gt;
&lt;h2&gt;五、一次排序请求流程&lt;/h2&gt;
&lt;p&gt;1、如下图所示，一次排序请求流程包含：特征获取、向量获取、数据处理及预测。以上提到的三个步骤均采用多线程并行处理，均以子任务形式执行。每个阶段中间夹杂这数据处理的流程，由主线程进行处理，且每个阶段的执行任务均为超时返回，主线程等待子线程任务时，也采用超时等待的策略。（同事实现的一个树形任务执行，超时等待的线程框架）&lt;/p&gt;
&lt;p&gt;2、特征数据闭环：该步骤为异步执行，将排序计算使用到的特征及分数，模型版本等信息记录。后续作为模型的训练样本，达到特征闭环。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/2019036&quot; alt=&quot;模型请求流程.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、一次排序请求中，&lt;em&gt;&lt;strong&gt;特征获取及向量获取&lt;/strong&gt;&lt;/em&gt;为网络IO（IO密集型任务），超时可直接响应中断，线程可快速返回。&lt;em&gt;&lt;strong&gt;数据处理及模型&lt;/strong&gt;&lt;/em&gt;为计算步骤（CPU密集型任务）。&lt;/p&gt;
&lt;p&gt;4、当前请求耗时情况：特征与向量的获取阶段耗时均为5-8ms，数据处理及模型预测阶段耗时平均在10ms左右。&lt;/p&gt;
&lt;h2&gt;六、问题发生现象&lt;/h2&gt;
&lt;p&gt;1、首先是调用方：推荐策略平台，监控报警排序请求的超时数量变多（调用方超时时间为300ms），且从监控上看发现排序服务的耗时明显变长：50ms+。正常高峰期的期望值为50ms以下。&lt;/p&gt;
&lt;p&gt;2、其次排序服务告警出现大量超时错误。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/2019007&quot; alt=&quot;超时错误.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、第三根据错误信息定位到该错误信息来自于&lt;strong&gt;数据处理及模型预测&lt;/strong&gt;阶段。&lt;/p&gt;
&lt;p&gt;4、除了超时变多以外，服务中会出现偶发性的空指针异常。&lt;/p&gt;
&lt;h2&gt;七、问题排查&lt;/h2&gt;
&lt;p&gt;1、首先解决空指针这类低级错误。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/2019061&quot; alt=&quot;空指针错误.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、根据错误提示找到对应的代码，此处就不粘贴代码了，做一个简单的代码解释。代码逻辑为：从Map&amp;lt;String,Object&amp;gt;中根据特征key获取特征值进行计算。&lt;/p&gt;
&lt;p&gt;3、疑惑点出现，首先该Map&amp;lt;String,Object&amp;gt;用于存放特征及向量键值对，且key均做了空值计算兼容。特征或者向量在查询到空值时，会在Map&amp;lt;String,Object&amp;gt;中放入一个对应的默认值。经过反复的代码确认，报错信息对应的代码不可能出现漏放默认值的情况。&lt;/p&gt;
&lt;p&gt;4、借助Arthas的watch命令，监控空指针异常的入参。方便后面做模拟请求还原现场。&lt;/p&gt;
&lt;p&gt;5、根据报错时的信息进行模拟请求。尝试N次，且使用不同的报错数据进行尝试，均未重现事故。&lt;/p&gt;
&lt;p&gt;6、此时怀疑是多线程并发进行&lt;strong&gt;数据处理及预测&lt;/strong&gt;时，发生对Map&amp;lt;String,Object&amp;gt;进行修改的动作，导致部分键值对丢失。&lt;/p&gt;
&lt;p&gt;7、反复检查代码，确定&lt;strong&gt;数据处理及预测&lt;/strong&gt;均为只读动作，不会对Map&amp;lt;String,Object&amp;gt;进行任何键值对的删改。&lt;/p&gt;
&lt;p&gt;8、线索中断，排查一度搁置。&lt;/p&gt;
&lt;h2&gt;八、豁然开朗&lt;/h2&gt;
&lt;p&gt;1、借用Arthas进行报错观察：使用watch命令，依靠-e参数（指定报错触发打印）以及-x n 参数（打印方法入参及返回值数据层数）&lt;/p&gt;
&lt;p&gt;2、根据观察，发现Map&amp;lt;String,Object&amp;gt;中丢失的均为&lt;strong&gt;向量&lt;/strong&gt;键值对。&lt;/p&gt;
&lt;p&gt;3、找到问题：在排序请求流程图中，在主线程进行&lt;strong&gt;分数归一化&lt;/strong&gt;时，会fork子线程异步做特征数据进行压缩写入kafka。由于Map&amp;lt;String,Object&amp;gt;中存在大量的向量数据，导致保存数据过冗余的情况。此处的做法是先去除所有的&lt;strong&gt;向量&lt;/strong&gt;数据，再进行保存。&lt;/p&gt;
&lt;p&gt;4、但是该动作是发生在&lt;strong&gt;数据处理及模型预测&lt;/strong&gt;后的，为何还会因为Map&amp;lt;String,Object&amp;gt;中删除键值对导致空指针异常呢。&lt;/p&gt;
&lt;p&gt;5、此时怀疑是&lt;strong&gt;数据处理及模型预测&lt;/strong&gt;阶段，多线程任务还没完成时，主线程已经等候超时返回了。&lt;/p&gt;
&lt;h2&gt;九、验证想法&lt;/h2&gt;
&lt;p&gt;1、还是观察超时日志。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/2019068&quot; alt=&quot;超时请求.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/2019094&quot; alt=&quot;空指针数据.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、发现请求已经返回后，才出现空指针异常。那基本就可以验证以上的想法了。&lt;/p&gt;
&lt;h2&gt;十、问题解决&lt;/h2&gt;
&lt;p&gt;1、翻看使用的多线程框架（同事实现），主线程超时等待子线程任务。主线程超时返回后，没有通知子线程任务取消。所以才发生请求已返回，特征数据异步落地后，偶发性出现晚到的空指针异常的情况。如下图，主线程超时返回后，只取消主线程任务。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/2019819&quot; alt=&quot;主线程超时等待.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、解决思路：主线程超时返回后，中断子任务（取消子任务）。由于java的中断机制为软中断，一般是通过中断标志位进行线程中断协作的。当然IO或者sleep的中断由系统帮我们做了中断可以快速返回。对于CPU密集型的任务，是需要使用者在&lt;strong&gt;合适&lt;/strong&gt;的计算点上做标志位判断，确定是否已中断结束任务。以这种协作的方式达到中断。（此处可能有部分理解不当）&lt;/p&gt;
&lt;p&gt;3、修改多线程框架，在主线程超时返回后，修改子线程中断标志位。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/2019106&quot; alt=&quot;取消子线程.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、在计算流程中加入线程中断检查，如果被中断则提前结束计算。&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/2019131&quot; alt=&quot;响应中断.png&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;十一、效果检查&lt;/h2&gt;
&lt;p&gt;1、修改发版后，空指针没再出现。（其实该空指针是不影响排序结果，因为结果已经是错的，该异常只是附带的虫子而已）&lt;br/&gt;
2、超时请求减少，高峰期的超时数据减少三分之一，50ms+的排序请求有明显减少。&lt;/p&gt;
&lt;h2&gt;十二、复盘&lt;/h2&gt;
&lt;p&gt;1、主线程等待子任务的场景下，如果主线程超时返回了。需通知子线程结束执行的任务。首先，主线程返回了，表示子任务已被丢弃。继续执行都是在做无用的计算，占用计算机资源。也不是说占着茅坑不拉屎，而是拉了没人要。应该尽量减少服务器资源用在没必要的消耗上。&lt;/p&gt;
&lt;p&gt;2、该服务在&lt;strong&gt;数据处理及预测&lt;/strong&gt;阶段使用的线程池队列为SynchronousQueue，如果不了解SynchronousQueue的话可以简单理解为一个0长度的队列。任务进池子时必须要有线程进行对接。与常规的BlockingQueue不同的是，任务在池子中不会堆积，对于任务的快速响应比较友好。但是也因为如果没有空闲的线程，则会不停创建线程直到&lt;strong&gt;最高线程数&lt;/strong&gt;限制而触发丢弃策略。在该项目问题中，由于部分子任务在主线程返回后仍然在执行。新的请求进来后，会出现没有空闲线程的情况，导致池子创建新线程接任务。对于CPU密集型任务来说，过多的线程数对服务来说是另一种负担，毕竟线程切换的代价还是比较大的。这就套入死循环了。（个人理解，如表述有误，还望指正）&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>732cf1e2f7af58d068a7c1be6c943799</guid>
<title>Go 错误处理最佳实践</title>
<link>https://toutiao.io/k/lodfgxd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body&quot; id=&quot;post-body&quot;&gt;&lt;blockquote&gt;&lt;p&gt;本系列为极客时间 Go 进阶训练营笔记，同步直播更新，预计一周更新 1 ~ 2 篇文章，到 202103 月更新完成&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;最佳实践&quot;&gt;&lt;a href=&quot;#最佳实践&quot; class=&quot;headerlink&quot; title=&quot;最佳实践&quot;/&gt;最佳实践&lt;/h2&gt;&lt;p&gt;太长不看系列，我们总结一下在 go 中 如何处理 error，具体的原因我们会在下面的内容中进行详细的解释&lt;/p&gt;&lt;h3 id=&quot;panic&quot;&gt;&lt;a href=&quot;#panic&quot; class=&quot;headerlink&quot; title=&quot;panic&quot;/&gt;panic&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;在程序启动的时候，如果有强依赖的服务出现故障时 &lt;code&gt;panic&lt;/code&gt; 退出&lt;/li&gt;&lt;li&gt;在程序启动的时候，如果发现有配置明显不符合要求， 可以 &lt;code&gt;panic&lt;/code&gt; 退出（防御编程）&lt;/li&gt;&lt;li&gt;其他情况下只要不是不可恢复的程序错误，都不应该直接 &lt;code&gt;panic&lt;/code&gt; 应该返回 &lt;code&gt;error&lt;/code&gt;&lt;/li&gt;&lt;li&gt;在程序入口处，例如 &lt;code&gt;gin&lt;/code&gt; 中间件需要使用 &lt;code&gt;recovery&lt;/code&gt; 预防 &lt;code&gt;panic&lt;/code&gt; 程序退出&lt;/li&gt;&lt;li&gt;在程序中我们应该避免使用野生的 &lt;code&gt;goroutine&lt;/code&gt;&lt;ol&gt;&lt;li&gt;如果是在请求中需要执行异步任务，应该使用异步 &lt;code&gt;worker&lt;/code&gt; ，消息通知的方式进行处理，避免请求量大时大量 &lt;code&gt;goroutine&lt;/code&gt; 创建&lt;/li&gt;&lt;li&gt;如果需要使用 &lt;code&gt;goroutine&lt;/code&gt; 时，应该使用同一的 &lt;code&gt;Go&lt;/code&gt; 函数进行创建，这个函数中会进行 &lt;code&gt;recovery&lt;/code&gt; ，避免因为野生 &lt;code&gt;goroutine&lt;/code&gt; panic 导致主进程退出&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Go&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(f &lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt;()&lt;/span&gt;)&lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err := recovery(); err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
                log.Printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;panic: %+v&quot;&lt;/span&gt;, err)
            }
        }()

        f()
    }()
}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;error&quot;&gt;&lt;a href=&quot;#error&quot; class=&quot;headerlink&quot; title=&quot;error&quot;/&gt;error&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;我们在应用程序中使用 &lt;code&gt;github.com/pkg/errors&lt;/code&gt; 处理应用错误，&lt;strong&gt;注意在公共库当中，我们一般不使用这个&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;error&lt;/code&gt; 应该是函数的最后一个返回值，当 &lt;code&gt;error&lt;/code&gt; 不为 &lt;code&gt;nil&lt;/code&gt; 时，函数的其他返回值是不可用的状态，不应该对其他返回值做任何期待&lt;ol&gt;&lt;li&gt;&lt;code&gt;func f() (io.Reader, *S1, error)&lt;/code&gt; 在这里，我们不知道 &lt;code&gt;io.Reader&lt;/code&gt; 中是否有数据，可能有，也有可能有一部分&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;错误处理的时候应该先判断错误， &lt;code&gt;if err != nil&lt;/code&gt; 出现错误及时返回，使代码是一条流畅的直线，避免过多的嵌套&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// good case&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
    a, err := A()
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; err
    }

    &lt;span class=&quot;hljs-comment&quot;&gt;// ... 其他逻辑&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;
}

&lt;span class=&quot;hljs-comment&quot;&gt;// bad case&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
    a, err := A()
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err == &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
    &lt;span class=&quot;hljs-comment&quot;&gt;// 其他逻辑&lt;/span&gt;
    }

    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; err
}&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;在&lt;strong&gt;应用程序&lt;/strong&gt;中出现错误时，使用 &lt;code&gt;errors.New&lt;/code&gt; 或者 &lt;code&gt;errors.Errorf&lt;/code&gt; 返回错误&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(u *usecese)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;usecase1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
    money := u.repo.getMoney(uid)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; money &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; {
        errors.Errorf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;用户余额不足, uid: %d, money: %d&quot;&lt;/span&gt;, uid, money)
    }
    &lt;span class=&quot;hljs-comment&quot;&gt;// 其他逻辑&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;如果是调用&lt;strong&gt;应用程序的&lt;/strong&gt;其他函数出现错误，请直接返回，如果需要携带信息，请使用 &lt;code&gt;errors.WithMessage&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(u *usecese)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;usecase2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
    name, err := u.repo.getUserName(uid)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; errors.WithMessage(err, &lt;span class=&quot;hljs-string&quot;&gt;&quot;其他附加信息&quot;&lt;/span&gt;)
    }

    &lt;span class=&quot;hljs-comment&quot;&gt;// 其他逻辑&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;如果是调用其他库（标准库、企业公共库、开源第三方库等）获取到错误时，请使用 &lt;code&gt;errors.Wrap&lt;/code&gt; 添加堆栈信息&lt;ol&gt;&lt;li&gt;切记，不要每个地方都是用 &lt;code&gt;errors.Wrap&lt;/code&gt; 只需要在错误第一次出现时进行 &lt;code&gt;errors.Wrap&lt;/code&gt; 即可&lt;/li&gt;&lt;li&gt;根据场景进行判断是否需要将其他库的原始错误吞掉，例如可以把 &lt;code&gt;repository&lt;/code&gt; 层的数据库相关错误吞掉，返回业务错误码，避免后续我们分割微服务或者更换 &lt;code&gt;ORM&lt;/code&gt; 库时需要去修改上层代码&lt;/li&gt;&lt;li&gt;注意我们在基础库，被大量引入的第三方库编写时一般不使用 &lt;code&gt;errors.Wrap&lt;/code&gt; 避免堆栈信息重复&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
    err := json.Unmashal(&amp;amp;a, data)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; errors.Wrap(err, &lt;span class=&quot;hljs-string&quot;&gt;&quot;其他附加信息&quot;&lt;/span&gt;)
    }

    &lt;span class=&quot;hljs-comment&quot;&gt;// 其他逻辑&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;&lt;strong&gt;禁止&lt;/strong&gt;每个出错的地方都打日志，&lt;strong&gt;只需要&lt;/strong&gt;在进程的最开始的地方使用 &lt;code&gt;%+v&lt;/code&gt; 进行统一打印，例如 http/rpc 服务的中间件&lt;/li&gt;&lt;li&gt;错误判断使用 &lt;code&gt;errors.Is&lt;/code&gt; 进行比较&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
    err := A()
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; errors.Is(err, io.EOF){
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;
    }

    &lt;span class=&quot;hljs-comment&quot;&gt;// 其他逻辑&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;错误类型判断，使用 &lt;code&gt;errors.As&lt;/code&gt; 进行赋值&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
    err := A()

    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; errA errorA
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; errors.As(err, &amp;amp;errA){
    &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;
    }

    &lt;span class=&quot;hljs-comment&quot;&gt;// 其他逻辑&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;10&quot;&gt;&lt;li&gt;如何判定错误的信息是否足够，想一想当你的代码出现问题需要排查的时候你的错误信息是否可以帮助你快速的定位问题，例如我们在请求中一般会输出参数信息，用于辅助判断错误&lt;/li&gt;&lt;li&gt;对于业务错误，推荐在一个统一的地方创建一个错误字典，错误字典里面应该包含错误的 code，并且在日志中作为独立字段打印，方便做业务告警的判断，错误必须有清晰的错误文档&lt;/li&gt;&lt;li&gt;不需要返回，被忽略的错误&lt;strong&gt;必须&lt;/strong&gt;输出日志信息&lt;/li&gt;&lt;li&gt;同一个地方不停的报错，最好不要不停输出错误日志，这样可能会导致被大量的错误日志信息淹没，无法排查问题，比较好的做法是打印一次错误详情，然后打印出错误出现的次数&lt;/li&gt;&lt;li&gt;对同一个类型的错误，采用相同的模式，例如参数错误，不要有的返回 404 有的返回 200&lt;/li&gt;&lt;li&gt;处理错误的时候，需要处理已分配的资源，使用 &lt;code&gt;defer&lt;/code&gt; 进行清理，例如文件句柄&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;panic-or-error&quot;&gt;&lt;a href=&quot;#panic-or-error&quot; class=&quot;headerlink&quot; title=&quot;panic or error?&quot;/&gt;panic or error?&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;在 Go 中 panic 会导致程序直接退出，是一个致命的错误，如果使用 &lt;code&gt;panic&lt;/code&gt; &lt;code&gt;recovery&lt;/code&gt; 进行处理的话，会存在很多问题&lt;ol&gt;&lt;li&gt;性能问题，频繁 panic recovery 性能不好&lt;/li&gt;&lt;li&gt;容易导致程序异常退出，只要有一个地方没有处理到就会导致程序进程整个退出&lt;/li&gt;&lt;li&gt;不可控，一旦 panic 就将处理逻辑移交给了外部，我们并不能预设外部包一定会进行处理&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;什么时候使用 panic 呢？&lt;ol&gt;&lt;li&gt;对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;使用 error 处理有哪些好处？&lt;ol&gt;&lt;li&gt;简单。&lt;/li&gt;&lt;li&gt;考虑失败，而不是成功(Plan for failure, not success)。&lt;/li&gt;&lt;li&gt;没有隐藏的控制流。&lt;/li&gt;&lt;li&gt;完全交给你来控制 error。&lt;/li&gt;&lt;li&gt;Error are values。&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;为什么标准库中-errors-New-会返回一个指针&quot;&gt;&lt;a href=&quot;#为什么标准库中-errors-New-会返回一个指针&quot; class=&quot;headerlink&quot; title=&quot;为什么标准库中 errors.New 会返回一个指针&quot;/&gt;为什么标准库中 errors.New 会返回一个指针&lt;/h2&gt;&lt;p&gt;翻看标准库的源代码我们可以发现， &lt;code&gt;errors&lt;/code&gt; 库中的 &lt;code&gt;errorString&lt;/code&gt; 结构体实现了 &lt;code&gt;error&lt;/code&gt; 接口，为什么在 &lt;code&gt;New&lt;/code&gt; 一个 error 的时候会返回一个结构体的指针呢？&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// New returns an error that formats as the given text.&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// Each call to New returns a distinct error value even if the text is identical.&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;New&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(text &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;errorString{text}
}

&lt;span class=&quot;hljs-comment&quot;&gt;// errorString is a trivial implementation of error.&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; errorString &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {
s &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(e *errorString)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; e.s
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们先来看一个例子，我们同样创建了 errorString 的结构体，我们自定义的和标准库中的唯一不同就是，自建的这个返回的是值，而不是指针。&lt;br/&gt;在 &lt;code&gt;main&lt;/code&gt; 函数的对比中我们就可以发现，我们自定义的 &lt;code&gt;errorString&lt;/code&gt; 在对比的时候只要对应的字符串相同就会返回 true，但是标准库的包不会。&lt;br/&gt;这是因为，在对比两个 struct 是否相同的时候，会去对比，这两个 struct 里面的各个字段是否是相同的，如果相同就返回 true，但是对比指针的时候会去判断两个指针的地址是否一致。&lt;br/&gt;&lt;strong&gt;如果字符串相等就返回 true 会导致什么问题呢？&lt;/strong&gt;&lt;br/&gt;如果我有两个包定义了字符串相同的想个错误，在其他库调用对比的时候，可能会由于不同的书写顺序走进不同的分支导致一些不可预期的奇奇怪怪的错误&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; errorString &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {
text &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(e errorString)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; e.text
}

&lt;span class=&quot;hljs-comment&quot;&gt;// New 创建一个自定义错误&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;New&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(s &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; errorString{text: s}
}

&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; errorString1 = New(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test a&quot;&lt;/span&gt;)
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; err1 = errors.New(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test b&quot;&lt;/span&gt;)

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; errorString1 == New(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test a&quot;&lt;/span&gt;) {
fmt.Println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;err string a&quot;&lt;/span&gt;) &lt;span class=&quot;hljs-comment&quot;&gt;// 会输出&lt;/span&gt;
}

&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err1 == errors.New(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test b&quot;&lt;/span&gt;) {
fmt.Println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;err b&quot;&lt;/span&gt;) &lt;span class=&quot;hljs-comment&quot;&gt;// 不会输出&lt;/span&gt;
}
}&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;error-type-错误定义与判断&quot;&gt;&lt;a href=&quot;#error-type-错误定义与判断&quot; class=&quot;headerlink&quot; title=&quot;error type: 错误定义与判断&quot;/&gt;error type: 错误定义与判断&lt;/h2&gt;&lt;h3 id=&quot;Sentinel-Error&quot;&gt;&lt;a href=&quot;#Sentinel-Error&quot; class=&quot;headerlink&quot; title=&quot;Sentinel Error&quot;/&gt;Sentinel Error&lt;/h3&gt;&lt;p&gt;哨兵错误，就是定义一些包级别的错误变量，然后在调用的时候外部包可以直接对比变量进行判定，在标准库当中大量的使用了这种方式&lt;br/&gt;例如下方 &lt;code&gt;io&lt;/code&gt; 库中定义的错误&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// EOF is the error returned by Read when no more input is available.&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// Functions should return EOF only to signal a graceful end of input.&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// If the EOF occurs unexpectedly in a structured data stream,&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// the appropriate error is either ErrUnexpectedEOF or some other error&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// giving more detail.&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; EOF = errors.New(&lt;span class=&quot;hljs-string&quot;&gt;&quot;EOF&quot;&lt;/span&gt;)

&lt;span class=&quot;hljs-comment&quot;&gt;// ErrUnexpectedEOF means that EOF was encountered in the&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// middle of reading a fixed-size block or data structure.&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; ErrUnexpectedEOF = errors.New(&lt;span class=&quot;hljs-string&quot;&gt;&quot;unexpected EOF&quot;&lt;/span&gt;)

&lt;span class=&quot;hljs-comment&quot;&gt;// ErrNoProgress is returned by some clients of an io.Reader when&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// many calls to Read have failed to return any data or error,&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// usually the sign of a broken io.Reader implementation.&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; ErrNoProgress = errors.New(&lt;span class=&quot;hljs-string&quot;&gt;&quot;multiple Read calls return no data or error&quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们在外部判定的时候一般使用等值判定或者使用 &lt;code&gt;errors.Is&lt;/code&gt; 进行判断&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err == io.EOF {
&lt;span class=&quot;hljs-comment&quot;&gt;//...&lt;/span&gt;
}

&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; errors.Is(err, io.EOF){
&lt;span class=&quot;hljs-comment&quot;&gt;//...&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种错误处理方式有一个问题是，将 error 当做包的 API 暴露给了第三方，这样会导致在做重构或者升级的时候很麻烦，并且这种方式包含的错误信息会十分的有限&lt;/p&gt;&lt;h3 id=&quot;error-types&quot;&gt;&lt;a href=&quot;#error-types&quot; class=&quot;headerlink&quot; title=&quot;error types&quot;/&gt;error types&lt;/h3&gt;&lt;p&gt;这个就类似我们前面定义的 &lt;code&gt;errorString&lt;/code&gt; 一样实现了 &lt;code&gt;error&lt;/code&gt; 的接口，然后在外部是否类型断言来判断是否是这种错误类型&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; MyStruct &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {
s &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;
    name &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;
    path &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;
}



&lt;span class=&quot;hljs-comment&quot;&gt;// 使用的时候&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;switch&lt;/span&gt; err.(&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt;) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; *MyStruct:
        &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; others:
        &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种方式相对于哨兵来说，可以包含更加丰富的信息，但是同样也将错误的类型暴露给了外部，例如标准库中的 &lt;code&gt;os.PathError&lt;/code&gt;&lt;/p&gt;&lt;h3 id=&quot;Opaque-errors&quot;&gt;&lt;a href=&quot;#Opaque-errors&quot; class=&quot;headerlink&quot; title=&quot;Opaque errors&quot;/&gt;Opaque errors&lt;/h3&gt;&lt;p&gt;不透明的错误处理，这种方式最大的特点就是只返回错误，暴露错误判定接口，不返回类型，这样可以减少 API 的暴露，后续的处理会比较灵活，这个一般用在公共库会比较好&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; temporary &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; {
Temporary() &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt;
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;IsTemporary&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(err error)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; {
te, ok := err.(temporary)
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ok &amp;amp;&amp;amp; te.Temporary()
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种方式我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值&lt;/p&gt;&lt;h2 id=&quot;error-handle-错误处理优化&quot;&gt;&lt;a href=&quot;#error-handle-错误处理优化&quot; class=&quot;headerlink&quot; title=&quot;error handle: 错误处理优化&quot;/&gt;error handle: 错误处理优化&lt;/h2&gt;&lt;p&gt;在 go 中常常会存在大量的 &lt;code&gt;if err&lt;/code&gt; 代码，下面介绍两种常见的减少这种代码的方式&lt;/p&gt;&lt;h3 id=&quot;bufio-scan&quot;&gt;&lt;a href=&quot;#bufio-scan&quot; class=&quot;headerlink&quot; title=&quot;bufio.scan&quot;/&gt;bufio.scan&lt;/h3&gt;&lt;p&gt;对比下面两个函数的处理我们可以发现， &lt;code&gt;count2&lt;/code&gt; 使用 &lt;code&gt;sc.Scan&lt;/code&gt; 之后一个 &lt;code&gt;if err&lt;/code&gt; 的判断都没有，极大的简化了代码，这是因为在 &lt;code&gt;sc.Scan&lt;/code&gt; 做了很多处理，像很多类似的，需要循环读取的都可以考虑像这样包装之后进行处理，这样外部包调用的时候就会非常简洁&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 统计文件行数&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(r io.Reader)&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; (
br    = bufio.NewReader(r)
lines &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;
err   error
)

&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; {
&lt;span class=&quot;hljs-comment&quot;&gt;// 读取到换行符就说明是一行&lt;/span&gt;
_, err = br.ReadString(&lt;span class=&quot;hljs-string&quot;&gt;&#x27;\n&#x27;&lt;/span&gt;)
lines++
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;
}
}

&lt;span class=&quot;hljs-comment&quot;&gt;// 当错误是 EOF 的时候说明文件读取完毕了&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != io.EOF {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, err
}

&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; lines, err
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;count2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(r io.Reader)&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; (
sc    = bufio.NewScanner(r)
lines &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;
)

&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; sc.Scan() {
lines++
}

&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; lines, sc.Err()
}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;error-writer&quot;&gt;&lt;a href=&quot;#error-writer&quot; class=&quot;headerlink&quot; title=&quot;error writer&quot;/&gt;error writer&lt;/h3&gt;&lt;p&gt;看一个来自 go blog 的例子：&lt;a href=&quot;https://blog.golang.org/errors-are-values&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.golang.org/errors-are-values&lt;/a&gt;&lt;br/&gt;一般代码&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;_, err = fd.Write(p0[a:b])
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; err
}
_, err = fd.Write(p1[c:d])
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; err
}
_, err = fd.Write(p2[e:f])
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; err
}
&lt;span class=&quot;hljs-comment&quot;&gt;// and so on&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;errWriter&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; errWriter &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {
    w   io.Writer
    err error
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(ew *errWriter)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(buf []&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ew.err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;
    }
    _, ew.err = ew.w.Write(buf)
}

&lt;span class=&quot;hljs-comment&quot;&gt;// 使用时&lt;/span&gt;
ew := &amp;amp;errWriter{w: fd}
ew.write(p0[a:b])
ew.write(p1[c:d])
ew.write(p2[e:f])
&lt;span class=&quot;hljs-comment&quot;&gt;// and so on&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ew.err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ew.err
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果去翻 标准库中 bufio.Writer 的源代码，你会发现也有这种用法，这种就是将重复的逻辑进行了封装，然后把 error 暂存，然后我们就只需要在最后判断一下 error 就行了&lt;/p&gt;&lt;h2 id=&quot;wrap-error-错误包装&quot;&gt;&lt;a href=&quot;#wrap-error-错误包装&quot; class=&quot;headerlink&quot; title=&quot;wrap error: 错误包装&quot;/&gt;wrap error: 错误包装&lt;/h2&gt;&lt;h3 id=&quot;errors-wrap-有何作用，为什么不用标准库的-fmt-Errorf-quot-w-quot&quot;&gt;&lt;a href=&quot;#errors-wrap-有何作用，为什么不用标准库的-fmt-Errorf-quot-w-quot&quot; class=&quot;headerlink&quot; title=&quot;errors.wrap 有何作用，为什么不用标准库的 fmt.Errorf(&amp;quot;%w&amp;quot;)&quot;/&gt;errors.wrap 有何作用，为什么不用标准库的 &lt;code&gt;fmt.Errorf(&quot;%w&quot;)&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;我们先看一下标准库的源码，我们可以发现当 &lt;code&gt;p.wrappedErr != nil&lt;/code&gt; 的时候（也就是有 %w）的时候，会使用一个 &lt;code&gt;wrapError&lt;/code&gt; 将错误包装，看 &lt;code&gt;wrapError&lt;/code&gt; 的源码可以发现，这个方法只是包装了一下原始错误，并且可以做到附加一些文本信息，但是没有堆栈信息。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Errorf&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(format &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;, a ...&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
p := newPrinter()
p.wrapErrs = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;
p.doPrintf(format, a)
s := &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;(p.buf)
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; err error
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; p.wrappedErr == &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
err = errors.New(s)
} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
err = &amp;amp;wrapError{s, p.wrappedErr}
}
p.free()
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; err
}

&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; wrapError &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {
msg &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;
err error
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(e *wrapError)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; e.msg
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(e *wrapError)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Unwrap&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; e.err
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在看一下 pkg/errors 的源码，我肯可以发现除了使用 &lt;code&gt;withMessage&lt;/code&gt; 附加了错误信息之外还使用 &lt;code&gt;withStack&lt;/code&gt; 附加了堆栈信息，这样我们在程序入口处打印日志信息的时候就可以将堆栈信息一并打出了&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Wrap returns an error annotating err with a stack trace&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// at the point Wrap is called, and the supplied message.&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// If err is nil, Wrap returns nil.&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Wrap&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(err error, message &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err == &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;
}
err = &amp;amp;withMessage{
cause: err,
msg:   message,
}
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;withStack{
err,
callers(),
}
}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;为什么不允许处处使用-errors-Wrap&quot;&gt;&lt;a href=&quot;#为什么不允许处处使用-errors-Wrap&quot; class=&quot;headerlink&quot; title=&quot;为什么不允许处处使用 errors.Wrap&quot;/&gt;为什么不允许处处使用 errors.Wrap&lt;/h3&gt;&lt;p&gt;因为每一次 &lt;code&gt;errors.Wrap&lt;/code&gt; 的调用都会为错误添加堆栈信息，如果处处调用那会有大量的无用堆栈&lt;br/&gt;我们先看一下只有一处 wrap&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
fmt.Printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;err: %+v&quot;&lt;/span&gt;, c())
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; errors.Wrap(fmt.Errorf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;xxx&quot;&lt;/span&gt;), &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;)
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a()
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; b()
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看结果我们可以发现已经可以打印出全部的堆栈信息了&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;err: xxx
test
main.a
        /home/ll/project/Go&lt;span class=&quot;hljs-number&quot;&gt;-000&lt;/span&gt;/Week02/blog/wrap.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;
main.b
        /home/ll/project/Go&lt;span class=&quot;hljs-number&quot;&gt;-000&lt;/span&gt;/Week02/blog/wrap.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;18&lt;/span&gt;
main.c
        /home/ll/project/Go&lt;span class=&quot;hljs-number&quot;&gt;-000&lt;/span&gt;/Week02/blog/wrap.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;
main.main
        /home/ll/project/Go&lt;span class=&quot;hljs-number&quot;&gt;-000&lt;/span&gt;/Week02/blog/wrap.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;
runtime.main
        /usr/local/&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;/src/runtime/proc.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;204&lt;/span&gt;
runtime.goexit
        /usr/local/&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;/src/runtime/asm_amd64.s:&lt;span class=&quot;hljs-number&quot;&gt;1374&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再看多处 wrap 的现象&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
fmt.Printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;err: %+v&quot;&lt;/span&gt;, c())
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; errors.Wrap(fmt.Errorf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;xxx&quot;&lt;/span&gt;), &lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt;)
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; errors.Wrap(a(), &lt;span class=&quot;hljs-string&quot;&gt;&quot;b&quot;&lt;/span&gt;)
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; errors.Wrap(b(), &lt;span class=&quot;hljs-string&quot;&gt;&quot;c&quot;&lt;/span&gt;)
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到每一处 wrap 都添加了一次堆栈信息&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;err: xxx
a
main.a
        /home/ll/project/Go&lt;span class=&quot;hljs-number&quot;&gt;-000&lt;/span&gt;/Week02/blog/wrap.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;
main.b
        /home/ll/project/Go&lt;span class=&quot;hljs-number&quot;&gt;-000&lt;/span&gt;/Week02/blog/wrap.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;18&lt;/span&gt;
main.c
        /home/ll/project/Go&lt;span class=&quot;hljs-number&quot;&gt;-000&lt;/span&gt;/Week02/blog/wrap.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;
main.main
        /home/ll/project/Go&lt;span class=&quot;hljs-number&quot;&gt;-000&lt;/span&gt;/Week02/blog/wrap.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;
runtime.main
        /usr/local/&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;/src/runtime/proc.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;204&lt;/span&gt;
runtime.goexit
        /usr/local/&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;/src/runtime/asm_amd64.s:&lt;span class=&quot;hljs-number&quot;&gt;1374&lt;/span&gt;
b
main.b
        /home/ll/project/Go&lt;span class=&quot;hljs-number&quot;&gt;-000&lt;/span&gt;/Week02/blog/wrap.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;18&lt;/span&gt;
main.c
        /home/ll/project/Go&lt;span class=&quot;hljs-number&quot;&gt;-000&lt;/span&gt;/Week02/blog/wrap.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;
main.main
        /home/ll/project/Go&lt;span class=&quot;hljs-number&quot;&gt;-000&lt;/span&gt;/Week02/blog/wrap.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;
runtime.main
        /usr/local/&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;/src/runtime/proc.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;204&lt;/span&gt;
runtime.goexit
        /usr/local/&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;/src/runtime/asm_amd64.s:&lt;span class=&quot;hljs-number&quot;&gt;1374&lt;/span&gt;
c
main.c
        /home/ll/project/Go&lt;span class=&quot;hljs-number&quot;&gt;-000&lt;/span&gt;/Week02/blog/wrap.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;
main.main
        /home/ll/project/Go&lt;span class=&quot;hljs-number&quot;&gt;-000&lt;/span&gt;/Week02/blog/wrap.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;
runtime.main
        /usr/local/&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;/src/runtime/proc.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;204&lt;/span&gt;
runtime.goexit
        /usr/local/&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;/src/runtime/asm_amd64.s:&lt;span class=&quot;hljs-number&quot;&gt;1374&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;标准库-errors-Is-As-怎么判断错误&quot;&gt;&lt;a href=&quot;#标准库-errors-Is-As-怎么判断错误&quot; class=&quot;headerlink&quot; title=&quot;标准库 errors.Is / As 怎么判断错误&quot;/&gt;标准库 errors.Is / As 怎么判断错误&lt;/h2&gt;&lt;h3 id=&quot;errors-Is&quot;&gt;&lt;a href=&quot;#errors-Is&quot; class=&quot;headerlink&quot; title=&quot;errors.Is&quot;/&gt;errors.Is&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Is&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(err, target error)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; target == &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; err == target
}
&lt;span class=&quot;hljs-comment&quot;&gt;// 通过反射判读 target 是否可以被比较&lt;/span&gt;
isComparable := reflectlite.TypeOf(target).Comparable()
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; {
        &lt;span class=&quot;hljs-comment&quot;&gt;// 循环判断是否相等&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; isComparable &amp;amp;&amp;amp; err == target {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;
}
        &lt;span class=&quot;hljs-comment&quot;&gt;// 判断是否实现了 is 接口，如果有实现就直接判断&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; x, ok := err.(&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{ Is(error) &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; }); ok &amp;amp;&amp;amp; x.Is(target) {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;
}

&lt;span class=&quot;hljs-comment&quot;&gt;// 去判断是否实现了 unwrap 的接口，如果实现了就进行 unwrap&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err = Unwrap(err); err == &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;
}
}
}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;errors-As&quot;&gt;&lt;a href=&quot;#errors-As&quot; class=&quot;headerlink&quot; title=&quot;errors.As&quot;/&gt;errors.As&lt;/h3&gt;&lt;p&gt;和 is 的逻辑类似，就是不断的进行 unwrap 进行比较，只要有一个相同就返回，如果一直到底都不行就返回 false&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;As&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(err error, target &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; target == &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
&lt;span class=&quot;hljs-built_in&quot;&gt;panic&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;errors: target cannot be nil&quot;&lt;/span&gt;)
}
val := reflectlite.ValueOf(target)
typ := val.Type()
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; typ.Kind() != reflectlite.Ptr || val.IsNil() {
&lt;span class=&quot;hljs-built_in&quot;&gt;panic&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;errors: target must be a non-nil pointer&quot;&lt;/span&gt;)
}
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; e := typ.Elem(); e.Kind() != reflectlite.Interface &amp;amp;&amp;amp; !e.Implements(errorType) {
&lt;span class=&quot;hljs-built_in&quot;&gt;panic&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;errors: *target must be interface or implement error&quot;&lt;/span&gt;)
}
targetType := typ.Elem()
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; reflectlite.TypeOf(err).AssignableTo(targetType) {
val.Elem().Set(reflectlite.ValueOf(err))
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;
}
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; x, ok := err.(&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{ As(&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{}) &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; }); ok &amp;amp;&amp;amp; x.As(target) {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;
}
err = Unwrap(err)
}
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;关注我获取更新&quot;&gt;&lt;a href=&quot;#关注我获取更新&quot; class=&quot;headerlink&quot; title=&quot;关注我获取更新&quot;/&gt;关注我获取更新&lt;/h2&gt;&lt;p&gt;看到这里了还不点个关注走一波&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7d79f91c9f612a95ad15aff37d1f18ff</guid>
<title>ssh 偶发性登录卡死之谜</title>
<link>https://toutiao.io/k/0iuneb6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;outline-text-2&quot; id=&quot;text-orgda455a4&quot;&gt;
&lt;p&gt;
今天遇到一个非常诡异的 ssh 登陆失败的情况，：
&lt;/p&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;通过 ssh 登陆某主机（假设为user@Server）经常卡死，但经过多次尝试偶尔会出现登陆成功的情况。&lt;/li&gt;
&lt;li&gt;尝试用 ssh 登陆该主机的其他用户（tmpusr@Server），经常能成功，但是多次尝试会出现偶尔登陆卡死的情况。&lt;/li&gt;
&lt;li&gt;使用 ssh -vvv user@Server 尝试调试，发现能够正常登陆，而且每次都能登陆成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6ab82a662f2cb596f7412260281c5ee4</guid>
<title>浅析构建 SQL-to-SQL 的翻译器</title>
<link>https://toutiao.io/k/vipitc2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;em&gt;如果你爱一个人，就让他写SQL，因为那是天堂。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;如果你恨一个人，就让他写SQL，因为那是地狱。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;天堂，是因为他如此简单，又功能强大，可以极大简化你的程序。&lt;/p&gt;&lt;p&gt;地狱，是因为他如此纷繁，复杂，还有各种方言标准，而且不通用，当你试图切换数据库产品的时候，什么叫生不如死 ......&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那我们就不能构建一个统一的数据库语言么？这个真不能，不是技术上不能，而是利益趋势，大家坚守自己的方言堡垒，而且越建越高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ORM或许是解决这个问题的一个途径，正如其名，既然是对象关系映射，未免就会是一套机械、呆板的程序，我们只能将关系和实体映射出来，所以，这并非是解决问题的根本途径，但不能否认它确实是最受欢迎，使用最广泛，代价最小的方案，没有之一。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那我们是不是能从SQL语言翻译的角度来解决这个问题呢？即在将SQL抛给数据库执行之前，进行一次翻译工作？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们可以对SQL进行语法分析，形成一颗AST（抽象语法树），然后遍历解析&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6798917944093779&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag8WFes5ptLubrlibNBgHnACbsatGAQibib0kelGGZJR1qMDrdibaPoQrGPSOiaxUfdKeKZs6zXVIiagLeyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1109&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们在遍历语法树的时候，就进行一次翻译转换，形成其他方言的SQL。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6798917944093779&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag8WFes5ptLubrlibNBgHnACbkR13ic13ibXMpZft9icXkuViczZwsib0QDfhHoUQUprjSWwPmSiaxLjhXT7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1109&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个方案也许不尽善尽美，但是至少解决了一个类似“同声传译”的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对上述模型进一步演化，在AST层面进行双向转化，那这个实现是不是就看起来非常优雅了？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6798917944093779&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag8WFes5ptLubrlibNBgHnACbeYVCia2lzjOKxA8YXygVrtibTebuegPcolYLapkRmTl8JgIIibtibgibmaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1109&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们已经定制了一条看似合理的Roadmap，那么如何将其实现落地呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下表，是我对可完成上述任务的框架进行的一些总结&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.46796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag8WFes5ptLubrlibNBgHnACb80WUNrpoR2sFgPucjDG5Ww7z71aQMQyDiaUmgNfRVbjAticJdZqRMXdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;个人是十分推崇Calcite的，因为其本身更像是一个没有物理引擎的数据库引擎，这可能听起来有点滑稽，但是确实，他可以很好的解析SQL，并生成执行计划，如果你想，也可以针对其进行你希望的优化，这就让我们的控制力大大加强了，至少在数据库之上，就可以“为所欲为”了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Durid提供的方言包，比较多，上手比较容易（文末附录里，贴出了一个查询的AST，结构还是挺清晰的），不过如果想达到AST层面的转换，对整套API需要进行一定的手术才行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Antlr 可以说是非常强大的，他是单纯的语法解析工具，但是其语法文件比起javacc来，何止是平易近人，简直就是平易近人... 而且，shardingsphere，presto都是基于其开发的。在代码仓库里，也有很多线程的语法文件，可以使用，不过要达到上述目的，也需要走很长的路。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;好了，今天就先扯到这，感谢大家的阅读，如果对你有些帮助，那将是我莫大的荣幸，也期待你能关注我，和我交流。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;附录：以durid为例，下图展示了一条查询语句的AST&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.44453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag8WFes5ptLubrlibNBgHnACbPm6uzoIGMqVFXia9ib5nwg7viaWI1RTT1lPPg0kPT4T5GOXjCWZv7ehqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关注 【&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;麒思妙想&lt;/span&gt;&lt;span&gt;】解锁更多硬核。&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;历史文章导读&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果文章对您有那么一点点帮助，我将倍感荣幸&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;欢迎  &lt;span&gt;&lt;strong&gt;关注、在看、点赞、转发 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8uJ0ic6nAag8EItgzqIEhe3GbK3ibibrSC3kGNLaCYoEXEEEV8vatdHqibkazrs7oLJERAG1cldW9pbVmcTKvXL3fA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>