<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1e22e4414b07b7f0d29b33c0799106a1</guid>
<title>2022 年别再焦虑啦！加入我们！</title>
<link>https://toutiao.io/k/obimloc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e2942b7d42e782caaadd68dae1a38228</guid>
<title>Go 原生并发原语和最佳实践</title>
<link>https://toutiao.io/k/rdpao5x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 编程语言是用并发作为一等公民创建的。它是一种语言，通过抽象出语言中并发原语1背后的并行性细节，您可以轻松编写高度并行的程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大多数语言都将并行化作为标准库的一部分，或者期望开发者生态系统提供并行化库。通过在 Go 语言中包含并发原语，你可以编写并行性的程序，而无需了解编写并行代码的来龙去脉。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、并发（Concurrent）设计&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 的设计者非常重视并发设计，将其作为一种方法论，这种方法论的基础是交流关键信息，而不是阻塞和共享这些信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对并发设计的强调允许应用程序代码正确地按顺序或并行执行，而无需设计和实现并行化，这是常态。并发设计的想法并不新鲜，事实上一个很好的例子是从瀑布式开发到敏捷开发，这实际上是向并发工程实践（早期迭代、可重复过程）的转变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发设计是关于编写“正确”程序与编写“并行”程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 中构建并发程序时要问的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我是否堵塞在临界区？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;是否有更正确（如以 Go 为中心）的方式来编写此代码？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我可以通过通信来提高代码的功能性和可读性吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果其中任何一个是 Yes，那么你应该重新考虑你的设计，考虑用 Go 的最佳实践。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Communicating Sequential Processes (CSP)&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言的一部分的基础来自 Hoare 的一篇论文，该论文讨论了语言需要将并发视为语言的一部分而不是事后的想法。该论文提出了一种线程安全队列，它允许应用程序中不同进程之间的数据通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你通读这篇论文，你会发现Go 中的  &lt;code&gt;channel&lt;/code&gt; 原语与论文中对原语的描述非常相似，实际上这来自 Rob Pike 之前基于 CSP 构建语言的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Pike 的一次演讲中，他将真正的问题确定为“需要一种方法来编写并发软件，以指导我们的设计和实现。”他接着说并发编程不是让程序并行化以更快地运行，而是“利用流程和通信的力量来设计优雅、响应迅速、可靠的系统。”&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;通过通信实现并发&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从 Go 的创建者那里听到的最常见的短语之一是：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Don’t communicate by sharing memory, share memory by communicating. - Rob Pike&lt;/p&gt;&lt;p&gt;即：不要通过共享内存来通信，而是通过通信来共享内存。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种观点反映了 Go 是基于 CSP 的事实，并且该语言具有用于在线程之间通信的本机原语（goroutine）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的代码是使用通信而不是使用 mutex 来管理对共享资源的访问的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Adapted from https://github.com/devnw/ttl&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// a TTL cache implementation for Go.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;readwriteloop&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;  incoming &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{},&lt;br/&gt;)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt;   &lt;span&gt;// Create a channel to send data to.&lt;/span&gt;&lt;br/&gt;  outgoing = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{})&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;    incoming &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{},&lt;br/&gt;    outgoing &lt;span&gt;chan&lt;/span&gt;&amp;lt;- &lt;span&gt;interface&lt;/span&gt;{},&lt;br/&gt;    )&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(outgoing)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// `value` is the shared &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// resource or critical section.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; value &lt;span&gt;interface&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// incoming is the channel where data is&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// sent to set the shared resource.&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; v, ok := &amp;lt;-incoming:&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;// Exit the go routine.&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Write the data to the shared resource.&lt;/span&gt;&lt;br/&gt;        value = v.v&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// outgoing is the channel that &lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// the shared resource on request&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; outgoing &amp;lt;- value:&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }(incoming, outgoing)&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; outgoing&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们看一下代码，看看它做了什么。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;请注意，这没有使用 &lt;code&gt;sync&lt;/code&gt; 包或任何阻塞函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此代码仅使用 Go 并发原语 &lt;code&gt;go&lt;/code&gt;,&lt;code&gt;select&lt;/code&gt;和&lt;code&gt;chan&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;共享资源的所有权由 goroutine 管理。（第 17 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;即使该方法包含一个 goroutine，对共享资源的访问也不会并行发生。（第 30 和 34 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该 &lt;code&gt;select&lt;/code&gt; 语句用于检查读取或写入请求。（第 24 和 34 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 incoming 会更新该值。（第 24 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 goroutine 外部读取的通道使用共享资源的当前值执行对 outgoing 写入。（第 34 行）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于单个 goroutine 本身没有并行性，因此可以通过返回的只读通道安全地访问共享资源 。事实上，&lt;code&gt;select&lt;/code&gt; 这里使用该语句提供了许多好处。选择原语部分对此进行了更详细的介绍。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;堵塞 vs 通信&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堵塞：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;暂停临界区读/写的进程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要了解阻塞的&lt;strong&gt;必要性&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要了解如何避免竞争和死锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存元素由多个进程/线程直接共享&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通信：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据要求共享临界区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当有事情要做时，进程开始工作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存元素是通过通信共享，而不是直接共享的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、Go 原生并发原语&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Goroutine&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是 Goroutine？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;goroutine 是轻量级的线程。一旦 goroutine 从父 goroutine 中分离出来，它就会被移交给 Go 运行时执行。然而，与&amp;amp;in不同的是，bash这些进程被安排在 Go 运行时中执行，而不必并行执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2294455066921606&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowRmDVNKzB72JQwjiaFbUqiaz6lwnibYdtV5HkMD8hIKGgIaVR6NeIpWYGZAheTjDXlLVgWCGgOat49VA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;Goroutine 拆分示例&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里“调度”的区别很重要，因为 Go 运行时多路复用 goroutine 的执行，以提高操作系统调度之上的性能。这意味着无法对 goroutine 何时执行做出任何假设。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Goroutine 的泄露&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由 &lt;code&gt;go&lt;/code&gt; 原语创建的 goroutine 很轻量，但重要的是要知道它们&lt;strong&gt;不是&lt;/strong&gt;免费的。清理 goroutine 对于确保在 Go 运行时中正确收集资源非常重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应该花时间在设计上考虑清理。确保长时间运行的 goroutine 在发生故障时正确退出。同样重要的是不要创建无数的 goroutine。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成一个 goroutine 很简单，因此很容易无节制的生成新的 goroutine，生成的每个 goroutine 的最小开销约为 2kb。如果你的代码创建了太多 goroutine，并且每个 goroutine 都有很大的开销，那么栈空间可能不够。这在生产环境中调试起来非常困难，因为很难判断堆栈在哪里溢出以及堆栈在哪里泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当发生堆栈溢出时，运行时将 panic，程序将退出，每个 goroutine 都会将堆栈信息打印到标准错误。这会在日志中产生大量噪音并且不是很有用。不仅堆栈信息没有用，而且还会输出大量数据（每个 goroutine 的日志，包括它的标识符和状态）。这也很难调试，因为通常操作系统上的日志缓冲区可能太小而无法容纳所有堆栈信息。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：公平地说，我只在应用程序使用&lt;strong&gt;超过 400,000 个&lt;/strong&gt;大型 goroutine 的生产环境中看到这种情况。这可能很少见，对于大多数应用程序来说都不是问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TL;DR：设计 goroutines 时要考虑到最终结果，以便它们在完成时正确停止。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Goroutine 中的 panic&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，Go 应用程序中的 panic 是违反最佳实践的，应该避免。代替 panic，你应该返回并处理函数中的错误。但是，如果有必要使用  &lt;code&gt;panic&lt;/code&gt;，必须知道，在 goroutine 如果没有 defer 的 recover，panic 会导致整个应用程序崩溃。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;最佳实践：&lt;/strong&gt;不要 Panic！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这在生产环境中非常难以调试，因为它需要&lt;code&gt;stderr&lt;/code&gt;重定向到文件，因为你的应用程序很可能作为守护进程运行。如果你有一个日志聚合器并且它被设置为监控标准错误或文件日志，这会更容易。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果不确定，可以在 goroutine 增加 defer/recover&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; r := &lt;span&gt;recover&lt;/span&gt;(); r != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// Handle Panic HERE&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Channels&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go 中的 Channel 是什么？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源自 Hoare (1977) 的 Communicating Sequential Processes 论文通道是 Go 中的一种通信机制，它支持以线程安全的方式传输数据。它可用于安全有效地在并行 goroutine 之间进行通信，而无需 mutex。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道将构建并行代码的困难抽象到 Go 运行时，并提供了一种在 goroutine 之间进行通信的简单方法。从本质上讲，通道的最简单形式是数据队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 Rob Pike 的话来说：“Channels orchestrate; mutexes serialize.”&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通道在 Go 中是如何工作的？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，通道是阻塞的。这意味着，如果你尝试从通道读取，它将阻止该 goroutine 的处理，直到有要读取的内容（即数据发送到通道）。同样，如果你尝试写入通道并且没有数据消费者（即从通道读取），它将阻止该 goroutine 的处理，直到有消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 中，围绕通道有一些非常重要的行为。Go 运行时被设计为非常高效，因此如果有一个 goroutine 在读取或写入通道上被阻塞，则运行时将在等待执行某些操作时使 goroutine 休眠。一旦通道有生产者或消费者，它将唤醒阻塞的 goroutine 并继续处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解这一点非常重要，因为它允许你通过使用通道显式地利用系统的 CPU 争用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 一个 nil 通道总是堵塞&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关闭 Channel&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 完成后，最好关闭它。这通过 &lt;code&gt;close&lt;/code&gt; 实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时可能无法关闭通道，因为它会在应用程序的其他地方引起 panic（即往关闭的通道写入）。在这种情况下，当通道超出作用范围时，它将被垃圾收集。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Create the channel&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Do something with the channel&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Close the channel&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;close&lt;/span&gt;(ch)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果通道被限制在同一个作用域（即函数），你可以使用 &lt;code&gt;defer&lt;/code&gt;关键字来保证函数返回时通道是关闭的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Create the channel&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(ch) &lt;span&gt;// Close the channel when func returns&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Do something with the channel&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个通道关闭时，不允许再写入。注意关闭通道的方式非常重要，因为如果你尝试写入已关闭的通道，运行时将 panic。因此，过早关闭通道可能会产生意想不到的副作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道关闭后，它将不再阻塞读取。这意味着所有阻塞在通道上的 goroutine 都将被唤醒并继续处理。读取时返回的零值将是通道类型的值，读取返回的第二个值将是 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Create the channel&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Do something with the channel&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Close the channel&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;close&lt;/span&gt;(ch)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Read from closed channel&lt;/span&gt;&lt;br/&gt;  data, ok := &amp;lt;-ch&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;    &lt;span&gt;// Channel is closed&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在上面的示例中关闭了通道，则 &lt;code&gt;ok&lt;/code&gt;参数将是 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;  只读 channel 不能关闭&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Channels 类型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 中有几种不同类型的通道。它们每个都有各自的优点和缺点。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;无缓冲 Channels&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Unbuffered channels are the simplest type of channel.&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要创建无缓冲通道，请调用 make 函数，并提供通道类型。不要在第二个参数中提供大小值，如上例所示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无缓冲通道默认是阻塞的，并且会阻塞 goroutine 直到有东西要读取或写入。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓冲 Channels&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Buffered channels are the other primary type of channel.&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要创建缓冲通道，调用 make 函数，提供通道类型和缓冲区大小。上面的示例将创建一个缓冲区大小为 10 的通道。如果你尝试写入已满的通道，它将阻塞 goroutine，直到缓冲区中有空间。如果你试图从一个空的通道中读取，它将阻塞 goroutine，直到有东西要读取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果你想写入通道并且缓冲区有可用空间，则它不会阻塞 goroutine。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 通常，仅在真的需要时才使用缓冲通道。最佳实践是使用无缓冲通道。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;只读和只写 Channels&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道的一个有趣用例是拥有一个仅用于读取或写入的通道。当你有一个需要从通道读取但你不希望该 goroutine 写入时，这很有用，反之亦然。这对于下面描述的所有者模式特别有用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是创建只读或只写通道的语法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Define the variable with var&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; writeOnly &lt;span&gt;chan&lt;/span&gt;&amp;lt;- &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; readOnly &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  mychan := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Assign the channel to the variable&lt;/span&gt;&lt;br/&gt;  readOnly = mychan&lt;br/&gt;  writeOnly = mychan&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;箭头指示通道的方向。&lt;code&gt;chan&lt;/code&gt;前面的箭头表示数据流进入通道，而 &lt;code&gt;chan&lt;/code&gt; 后面的箭头表示数据流流出通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只读通道的一个示例是&lt;code&gt;time.Tick&lt;/code&gt; 函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Tick is a convenience wrapper for NewTicker providing access to the ticking&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// channel only&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Tick&lt;/span&gt;&lt;span&gt;(d Duration)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;Time&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此方法返回一个只读通道，&lt;code&gt;time&lt;/code&gt;包以指定的时间间隔在内部写入该通道。这种模式确保了时钟滴答的实现逻辑与&lt;code&gt;time&lt;/code&gt;包隔离，因为用户不需要往通道写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你需要写入通道但你知道 goroutine 不需要从中读取时，只写通道非常有用。下面描述的所有者模式就是一个很好的例子 。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Channels 的设计注意事项&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计注意事项包括：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;哪个作用域拥有 channel？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非所有者有什么能力？&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;完全所有权&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只读&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只写&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;channel 将如何清理？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;哪个 goroutine 负责清理 channel？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;所有者模式&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Owner Pattern 是 Go 中的一种常见设计模式，用于确保通道的所有权由创建或拥有 goroutine 正确管理。这允许 goroutine 管理通道的整个生命周期并确保正确关闭通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是 Go 中所有者模式的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewTime&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Time&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  tchan := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; time.Time)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(tchan &lt;span&gt;chan&lt;/span&gt;&amp;lt;- time.Time)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(tchan)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; tchan &amp;lt;- time.Now():&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }(tchan)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; tchan&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好处:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;NewTime 控制通道实例化和清理（第 2 行和第 5 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过定义只读/只写边界避免乱用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;限制行为不一致的可能性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于此示例的重要说明。上下文 &lt;code&gt;ctx&lt;/code&gt; 传递给函数 &lt;code&gt;NewTime&lt;/code&gt;并用于指示 goroutine 停止。&lt;code&gt;tchan&lt;/code&gt; 通道是普通的无缓冲通道，但以只读方式返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当传递给内部 goroutine 时，&lt;code&gt;tchan&lt;/code&gt;通道作为只写通道传递。因为内部 goroutine 提供了一个只写通道，所以它有责任在完成时关闭通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;select&lt;/code&gt; 语句，&lt;code&gt;time.Now()&lt;/code&gt; 调用仅在从通道读取时执行。这确保&lt;code&gt;time.Now()&lt;/code&gt; 调用的执行与从通道读取同步。这种类型的模式有助于抢先减少 CPU 周期。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;循环 Channels&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从通道读取的一种方法是使用&lt;code&gt;for&lt;/code&gt;循环。这在某些情况下可能很有用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;var&lt;/span&gt; tchan &amp;lt;-&lt;span&gt;chan&lt;/span&gt; time.Time&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; t := &lt;span&gt;range&lt;/span&gt; tchan {&lt;br/&gt;    fmt.Println(t)&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我不推荐这种方法有几个原因。首先，不能保证通道会关闭（打破循环）。其次，循环不遵守上下文，这意味着如果取消上下文，循环将永远不会退出。&lt;strong&gt;第二点特别重要，因为没有优雅的方式来退出 goroutine。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我建议不要在通道上循环，而是使用以下模式，在该模式中使用带有&lt;code&gt;select&lt;/code&gt;语句的无限循环。这种模式确保检查上下文，如果它被取消，循环退出，同时还允许循环仍然从通道中读取。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;var&lt;/span&gt; tchan &amp;lt;-&lt;span&gt;chan&lt;/span&gt; time.Time&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done(): &lt;span&gt;// Graceful exit&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; t, ok := &amp;lt;-tchan: &lt;span&gt;// Read from the time ticker&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; !ok { &lt;span&gt;// Channel closed, exit&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;      fmt.Println(t)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下文会详细讨论这个。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;转发 Channels&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在适当的情况下，将通道从一个转发到另一个也是一种有用的模式。这是使用&lt;code&gt;&amp;lt;- &amp;lt;-&lt;/code&gt;运算符完成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是将一个通道转发到另一个通道的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;forward&lt;/span&gt;&lt;span&gt;(ctx context.Context, from &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  to := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; to &amp;lt;- &amp;lt;-from: &lt;span&gt;// Forward from into the to channel&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }()&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; to&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 使用此模式，你无法检测&lt;code&gt;from&lt;/code&gt;通道何时关闭。这意味着&lt;code&gt;from&lt;/code&gt;通道将不断地向 &lt;code&gt;to&lt;/code&gt; 通道发送数据，并且内部 goroutine 将永远不会退出，从而导致大量零值数据和 goroutine 泄漏。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据你的使用场景，这可能是可取的，但是，重要的是要注意，当你需要检测关闭的通道时，这种模式不是一个好方式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Select 语句&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select&lt;/code&gt; 语句允许在 Go 应用程序中管理多个通道，并可用于触发操作、管理数据或以其他方式创建逻辑并发流。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; data, ok := &amp;lt;- incoming: &lt;span&gt;// Data Read&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; outgoing &amp;lt;- data: &lt;span&gt;// Data Write&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;default&lt;/span&gt;: &lt;span&gt;// Non-blocking default action&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// ... &lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：&lt;code&gt;select&lt;/code&gt; 本质上是&lt;em&gt;随机&lt;/em&gt;的。这意味着如果有多个通道准备好同时读取或写入，该&lt;code&gt;select&lt;/code&gt;语句将随机选择一个 case 语句来执行。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试 Select 语句&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;select 语句的随机性会使测试 select 语句有点棘手，尤其是在测试以确保上下文取消正确退出例程时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个如何使用统计测试来测试 select 语句的示例，其中测试执行的次数确保测试失败的统计可能性很低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此测试通过在并行例程中运行相同的已取消上下文 100 次来工作，其中两个上下文中只有一个已被取消。在这种情况下，总会有一个通道的消费者，因此每次循环运行时，都有 50% 的可能性会执行 context case。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过运行 100 次，有 50% 的机会选择触发上下文情况，测试将无法检测到所有 100 个测试的上下文取消的可能性非常非常低。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;带上下文的 Work 取消&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在构建 Go 应用程序的早期，用户构建具有&lt;code&gt;done&lt;/code&gt;通道的应用程序，他们将在其中创建一个看起来像这样的通道：&lt;code&gt;done := make(chan struct{})&lt;/code&gt;，这是一种非常简单的方法，可以向 goroutine 发出它应该退出的信号，因为你所要做的就是关闭通道并将其用作退出信号。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Example of a simple done channel&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  done := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt;&lt;br/&gt;    &lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; doWork(done)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Exit anything using the done channel&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(done)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Do some more work&lt;/span&gt;&lt;br/&gt;  }()&lt;br/&gt;&lt;br/&gt;  &amp;lt;-done&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doWork&lt;/span&gt;&lt;span&gt;(done &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-done:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;: &lt;br/&gt;      &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式变得如此普遍，以至于 Go 团队创建了context 包 作为替代。该包提供了一个接口&lt;code&gt;context.Context&lt;/code&gt;，可用于向 goroutine 发出信号，告知它在&lt;code&gt;Done&lt;/code&gt; 方法返回的只读通道返回时退出 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doWork&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;default&lt;/span&gt;: &lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，他们还提供了一些用于创建分层上下文、超时上下文和可以取消的上下文的方法。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;context.WithCancel&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;返回 &lt;code&gt;context.Context&lt;/code&gt;以及&lt;code&gt;context.CancelFunc&lt;/code&gt;，可用于取消上下文的函数字面值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;context.WithTimeout&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;与&lt;code&gt;WithCancel&lt;/code&gt;返回一致，但具有超时，将在指定&lt;code&gt;time.Duration&lt;/code&gt;时间过去后取消上下文。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;context.WithDeadline&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;与 WithCancel 返回一致，但有一个截止日期，将在指定的时间过去后取消上下文。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;：接受上下文的函数的第一个参数应该 &lt;strong&gt;始终&lt;/strong&gt; 是 context，并且应该命名为 &lt;code&gt;ctx&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://benjiv.com/go-native-concurrency-primitives/。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d86ba15fe055b12ff6a79ad76e1b8879</guid>
<title>赵学敏：京东商品图谱构建与实体对齐</title>
<link>https://toutiao.io/k/nrwlirv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-backh=&quot;156&quot; data-backw=&quot;561&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;561&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;187&quot; data-fileid=&quot;100072688&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiatBXkeQWuUGBmUQ4xiahXXVm7Ohkcwd798zgEzw4l4EBMjUqNd5HtdBibHyicSCVfIIpG0ZkFwdSsFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;256&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4421864050455501&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaVOpUgibtUfuPKEm8HfWk4Yjk7FC0PJ9tUeG6hhM56NcLg3SMnXKXessgGBw7MiaJK9JL2yv44tzrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1427&quot;/&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: -10px; margin-left: -8px; max-width: 100%; width: 18px; height: 18px; border-top: 8px solid rgb(54, 65, 173); border-left: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-style=&quot;max-width: 100%; width: 543.333px; background: rgb(247, 247, 247); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;分享嘉宾：赵学敏&lt;/span&gt;&lt;span&gt;博士&lt;/span&gt;&lt;span&gt; 京东科技&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;编辑整理&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;蔡丽萍 &lt;/span&gt;&lt;span&gt;TRS&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;出品平台：DataFunTalk&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; width: 18px; height: 18px; border-bottom: 8px solid rgb(54, 65, 173); border-right: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;在电商企业采购和运营过程中，如果要想掌握商品的实时价格等行情信息，就需要对齐各个电商网站的商品。由于各个电商网站的运营体系不同，网站的类目体系、商品属性等等往往存在很大差异，需要将这些实体信息进行统一的对齐和匹配。此外，还需要考虑在数以亿级的商品体量下，商品信息有各种错误的情况下如何提升算法效果。本文将介绍商品图谱构建与表示、实体对齐等技术在电商领域的一些具体实践和应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要内容包括：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;背景介绍&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkt4MqTg4elflfU3VaMmVaZ8vOTAGUxdF5DTvEctYODANaHviaVZbiaTDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们团队的主要研究方向包括语音识别、自然语言处理、人机对话、知识图谱，负责将这些AI相关的研究落地于京东科技内外部的各种产品中，提高京东科技的机构品牌影响力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkAic6ukLW7M7pRdTmc1UT8GJFibq6tJTCbaVeU76OBPMbr0LDaibyYBRaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在知识图谱方向上，我们围绕金融图谱、商品图谱、药品图谱都有一些具体工作以及落地的应用。我们依托平台内部的一些能力，像大规模图谱处理库、机器学习平台等，为上层的各种应用提供知识图谱底座以及相关算法能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpk8jBNPxhVDpYqoicfibmVXqFovcWjxFpJFiboibYtKScEACqdLOHVqhuE4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天分享的内容是商品图谱当中的一个具体应用。商品图谱是以京东海量的商品为中心，全面沉淀相关的商品知识。构建图谱时区分概念层和实例层：概念层主要是沉淀一些抽象概念，比如品类与属性之间的关系；具体的实例，如属性值或者是商品SKU都会放在实例层。此外，我们还在持续推进商品图谱和通用百科图谱打通的工作，进而更好地为上层的应用提供相关的知识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpk6ytuVx9gdiazUxMHY3Kc0YUU8NooPdVnI5pVc31H1yhxtoWj5Kkahbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在商品图谱中，实体对齐包含商品对齐、属性对齐、属性值对齐，我们的应用中最关心的是商品之间的对齐，尤其是跨电商平台商品之间的对齐。有了这些商品对齐的结果，采销团队可以对京东商品的价格竞争力等等有一个全面的了解。跨电商渠道的商品对齐面临的最大问题是，因为各个电商渠道的运营体系完全不一样，会导致同一商品的具体描述有较大差异。同时，因为执行的运营标准也不一致，像京东自营商品的属性信息要更全一些，但是很多第三方商家的商品属性就有很多缺失，会把关键的信息直接放到标题中。此外，因为电商平台的商品都是海量数据，大数据下也会对算法的选型产生影响。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;技术进展&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 实体对齐任务介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkqwGHkZPTJIiacMcloXjzniaJ15vkWCxgjJc912d0j5WkVll3KdicOWOzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们这里的实体对齐任务是知识图谱中的实体对齐。在很多论文中具体把任务定义为：两个不同的图谱KG1、KG2，当中的实体有一定的对应关系，在已知一些对齐样本的情况下，去预测图谱中其它实体的对齐关系。图谱一般以（E，R，T）表示。E为实体，R为关系，T为图谱中的三元组。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkfDC8MkzEkFLficlV0Siaa2VfJk8iauyB5W0eiac1DfdiaJCRahaxsYrCDEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相关论文中常见的数据集有两个，都是百科图谱对齐的数据集。其中DBP15K是一个跨语言的百科图谱对齐数据集，DWY100K是三个不同来源的百科网站图谱对齐的数据集。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkylweekT7bAhKicCOv2nURmB0bZpibiay5V1dtXCnCc2Hw0meowfapyKbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多图谱对齐算法都以图谱表示学习为基础来实现，先对知识图谱当中的所有实体进行编码，从而提取实体的图谱特征。之前的研究一般采用分布式图表示学习，像TransE及其各种改进算法。目前更多的论文使用了图神经网络GNN。计算得到实体的图谱特征后，会将特征传入对齐模块。对齐模块常用的做法有两种，一种是拉近已知对齐实体特征向量在高维空间中的距离；另一种是使用一些复杂匹配模型，去学习预测实体间的对齐关系。目前主要工作都围绕着图谱编码和对齐模型两个部分展开。具体到评价指标，会把实体对齐看成是一个排序任务，使用搜索排序的相关指标进行评价，如TopK命中率，即统计前K个得分最高的预测结果中，是否包含有正确的对齐实体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 实体对齐算法技术趋势&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpk9XYHyp3eX70DITKahGef09JxHyHNibzxuickOicfkTKxnH1uHMsV2Nt0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近几年图谱对齐的论文有很多，这里可能只列举到一小部分。图谱编码的算法从19年开始，几乎都用到了GNN图神经网络，之前更多的是TransE的各种改进。一方面是图神经网络表达能力比较强，另一方面是因为TransE模型是基于链接预测等任务设计的，而图神经网络可以针对实体对齐任务设计相应的特征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在对齐算法部分，现在采用的对齐算法越来越复杂。除了最开始简单的向量对齐之外，更多的实体特征可以被引入，比如：图谱中的关系表示、邻接节点的匹配关系等等。同时也可以引入匹配模块，专门学习实体对之间的交互特征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们还发现越来越多的论文融合了图谱以外的语义信息，如实体的属性、文本描述等，这和实际应用场景是非常契合的。因为实际应用中图谱里面的实体一般也有一些对应的一些文本描述，甚至是多模态的信息比如图像等等，这些信息都可以加以利用。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;商品图谱中的实体对齐&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 商品图谱对齐需要考虑的问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkB63h8sP8vDBQ5N78dsWwOibwP1vFD3u9ia7Qa2sakfWrBNWeF23NHosw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;商品图谱实体对齐需要解决的问题，包含以下三个方面：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 线上预测流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkOEFicL7tMfwg7aV18RH5kHjFTic0lleSHbWOAm7N3PIbMw4CtL0WubdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是我们目前线上采用的预测流程。我们的任务是将商城A的商品数据和商城B的商品数据进行对齐。如果我们把这个任务看成搜索或者匹配过程的话，我们实际上是以商城A的商品信息作为查询条件，在商城B的所有商品中查找要匹配的商品，同时对查询的候选结果进行排序。当然这个过程也可以反过来，把商城B的商品信息作为查询条件。在我们具体应用中，一般是京东商品和别的渠道商品进行对齐。我们能获取到的京东商品数量远远大于其他渠道的商品数量，所以一般把其他渠道的商品作为查询条件，京东商品作为搜索的候选集，这样可以加速查询匹配的过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对齐可以分成四步：召回、精排、粗排、重排。重排实际上是结果的后处理，主要是根据一些校验规则过滤一些bad case。在匹配之前，我们会预先做一些图谱schema的对齐工作，包括商品类目的对齐、属性的对齐等等。粗排和精排都使用了有监督模型，确保排序结果的准确率，对于属性值缺失的情况，会应用属性抽取模型补齐商品属性，强化商品自身的结构化信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 数据集构建和业务评价方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkdd5yz09oiaphkGNo456peo8Cs3hDicBCL48YJXFyxiaJX1VJcYaeN4erA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面提到粗排和精排都使用了有监督模型，模型训练需要一些正负例的数据。&lt;/span&gt;&lt;span&gt;正例数据是互相匹配的商品pair，正例数据的获取是先通过简单的无监督商品相似度模型得到初步的候选集，再结合一些规则过滤后，通过众包标注确认是否匹配而得到的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;负例数据是不匹配的商品pair。理论上我们可以通过随机采样轻易地获得，但这样得到负例样本非常容易区分，不利于提高我们模型的鲁棒性。我们希望能够尽可能得到一些比较对抗性比较强负例，也就是很相似但又不匹配的样本。我们可以利用电商网站中SPU和SKU的概念去构建大量对抗性的负例。比如我们打开京东app要购买一个手机，通常在一个手机商品的页面上，有很多不同配置的手机，比如内存大小颜色不同。SPU就是同一款商品的概念，SKU就是配置具体到不能再区分的单品。一般情况下同一款SPU下，不同SKU的商品之间仅在个别属性上有区别，这样的商品作为负例的话，对于模型区分的难度是很大的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在具体业务中，我们可以离线评价模型的算法性能指标，比如使用之前提到的TOPK命中率，但在线上业务中，TOPK命中率作为指标就不适合了。这是因为TOPK命中率只是把测试集中的商品样本作为候选，但在线上检测时，面对的是全量的商品库，数量要大得多，同时还存在很多难以区分的商品。所以，我们线上是通过商品检出率和检出商品的准确率两个指标评价模型的效果。我们以京东商品作为查询条件为例，如果能在其他渠道的网站中能找到对应商品，那么我们统计有对应商品的京东商品数量，然后计算这部分京东商品在全部京东商品当中的比例，这个比例就是商品检出率。理论上两个商品库都可以以此方式分别计算检出率，我们的实验结果显示，两个商品库的检出率指标往往是正相关的，我们计算一个就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;检出商品的准确率，是将检出的商品匹配结果进行抽样后，然后标注计算正确结果的比例得到的。随着线上商品上架下架，以及随机采样的差异，检出准确率会有一定范围的波动，我们会调整模型检出阈值等，将准确率稳定在一定范围内。在准确率稳定的情况下，就可以通过比较模型的检出率来评估模型的效果了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. 召回与粗排部分&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkcviccV7LnaU9N2KFpmKBMtK6J4iammO4xd0OKORKc5RyDAUmj8cYZrMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们用到的精排模型是深度图谱对齐模型，模型的运算量比较大，为提高运算效率，候选的商品数量应控制在一定范围内，比如100以内。而召回是通过简单的规则如判断是否为同一品牌的商品等等实现的，召回商品的数量还是很多。因此，需要在中间加入粗排模型，我们使用了一个文本匹配的模型作为粗排模型。该模型训练时，把商品的标题作为输入，然后通过Bert编码得到编码结果后计算两个商品向量的余弦距离来进行匹配的。为了加速，我们将模型进行了蒸馏，提升模型的编码速度。另外，我们还使用了向量索引进一步加速粗排的过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5. 精排算法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkDawqx0PjGwvgX0PAOj531tCzb7Cy8qlMQLcbUfWHZRC6rYXGcicMHBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最开始使用的精排算法也是基于文本匹配来实现的。粗排用到的匹配模型只考虑了标题。人工对比商品时，我们会去比较商品的关键属性，比如笔记本电脑，我们会去看CPU型号是否匹配，内存大小、屏幕大小等等是否一致。除了将标题进行编码外，属性值也要进行编码，然后分别在两个商品之间进行特征匹配。因为商品的属性很多，需要提取关键属性，我们采用attention机制去自动学习各个属性的权重。因为关键属性可能不止一个，我们会保留属性匹配特征的多个加权结果，类似于Transformer里面的Multi-Head机制。对于空值属性，我们使用Mask将其权重直接设置为0。最后再基于关键属性和标题的交互匹配特征计算两个商品之间的相似度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上模型的缺点有两个：一是需要预先将属性进行对齐；二是训练集当中商品样本在商品库当中只占据很小的比例，很多商品属性值在训练阶段都没有见过。因此我们希望引入图谱表示学习对整体的商品库进行建模，从而增强模型的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkoCUNXPB8heRLIZzl6G6iaOwhv17ep4r0bViaB8fgXkNMFFIibykRNMDyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是现在线上使用的图谱匹配模型的框架。我们会预先将商品SKU和对应的属性值组织为图结构，SKU与属性值之间的关系为对应属性类别。另外，已知的一些属性值的对齐关系、品类的对齐关系也放在图谱当中。因此图谱当中主要是两个类型的节点，商品SKU节点和属性值节点，其中SKU节点将商品标题作为该节点的文本描述内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了图谱本身的结构化信息外，模型会融合非结构化的信息如文本等。很多论文将文本编码结果直接作为GNN的输入特征，我们曾经尝试将文本编码器直接放在GNN前面去进行训练，但这样做模型的训练速度非常慢，效果也不及预期。目前的做法分为两步：先预训练一个文本编码器，然后将编码结果作为GNN模块和匹配模块的输入特征。另外，这个文本编码器同时还作为粗排模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图谱模型与前面的文本匹配模型相比，有以下优势：首先，该模型可以建模更复杂的商品关系。将商品和属性构建为图谱后，商品和商品之间的关系、属性和属性之间的关系都可以被建模；其次，可以通过图谱的结构化表示，引入商品在商品库中的全局信息。最后，图谱对齐模型并没有假定两个图谱各自的关系需要事先对齐，在本应用中，也无需预先进行属性的对齐操作，在训练过程中可以自动实现对齐。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6. 处理大规模图谱&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkdeS8NF1bIXN6CiaGrDfnHSmTWekzBvzyffaRvTQHo7Lx51bkpAWqh1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商品图谱的数量一般比较大，我们考虑使用Inductive模型进行训练。传统的GCN等模型都是Transductive模型，需要全部节点参与训练才能得到embedding表示。当节点数量很多时，会因为显存或是内存的限制而无法进行训练。此外，在网络结构发生改变时，模型会直接失效，新加入的节点都需要重新训练才能得到对应的图谱表示。这在实际业务场景中是不可接受的，因为商品会经常有上架下架的操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们采用了Inductive模型，该模型会不断聚合邻接节点的信息去更新目标节点的图谱表示。具体是基于图谱采样来实现的，比如：先查询得到图中红色节点的所有邻接节点，当节点的邻接节点非常多时，要对邻接节点进行采样，控制运算量。图神经网络一般会训练多层的表示特征，每一层节点的表示由上一层的邻接节点的表示聚合而来。经过多层的表示之后，也就集成了多跳的邻接节点信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7. 图谱表示学习&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkMcJKhk6Vy1hF8Mibge1ha3Dw0zTLNkibuz6B7yNSm4usyk88B838OdVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在介绍我们的模型前，我们简单回顾一下图神经网络模型。主流的图神经网络模型，都可以用Message Passing框架来进行描述，具体分为以下几步：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第一步：邻接节点决定向目标节点发送什么样的特征，也就是图中的Message函数，这个过程在图谱当中的每条边上单独执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第二步：目标节点聚合收到的邻接节点的Message特征，也就是图中的Aggregate函数，这个过程在图谱当中的每个节点上单独执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第三步：目标节点根据邻接节点消息聚合结果，以及节点自身的特征，更新节点在网络下一层中的特征表示。也就是图中的Update函数，也是图谱中每个节点都执行一遍。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这也是很多图深度学习框架如DGL等设计其API的基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkHfPMbXlGUHOiaicj9rpEYXnJYWsuKFhOfnVJjQHX1wdxImDTtnzXg2qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在商品图谱中，图谱表示学习必须要考虑到实体之间的关系，我们构建的图中，大部分实体关系都是商品属性类别。前面的模型也提到，并不是所有的属性都对商品匹配有帮助，需要提取关键属性。我们采用的做法是设计特定的Aggregate聚合函数，使得聚合邻接节点的Message的时候，各个邻接节点的重要性权重由每条边上的Relation来决定。Message函数和Update函数我们直接使用线性变换来实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在公式中，mj是目标节点i收到邻接节点j的消息，聚合消息时，会有两个权重：第一个权重αij是根据邻接节点j和目标节点i的消息向量mj和mi拼接后计算得到的。在具体图谱中，这个权重代表了标题和属性值的匹配相关度，通常在标题中出现的属性值重要程度越高。第二个权重βij是根据节点连接边上的关系类型计算得到的，每个关系类型也用一个向量进行表示，然后基于这个关系向量去计算得分。两个权重相乘后，最终得到每个邻接节点在Aggregate函数中的权重。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8. 图谱匹配算法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkzs2g6Dp8bpEGicf4PG2G7CoB6wdE3gEYriaaKrjAmdEpbGhEiabQI0hOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在一开始采用了向量对齐的方式实现图谱对齐，我们使用L1距离作为两个向量距离的度量。在Embedding Loss的影响之下，正样本之间的距离会越来越近，而负样本之间会保持一定的距离γ。与前面的文本匹配模型相比，本模型的检出率相对提升了150%以上。但是该模型有一个缺点，强行拉进两个图谱某些样本之间的距离，会破坏原始图谱表示。另外，这个模型利用到的文本信息、邻近节点信息都要少一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpk3RIurvzwz1BGicGSian8LGwY2m4OlDNvq3xybK92rXGKBDy1t68FQ9yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是我们后来使用的匹配模型，除了将候选实体直接进行匹配外，还要利用邻接节点的匹配信息。这其实是基于一个假设，如果两个图谱当中的实体互相匹配的话，它们的邻接节点往往也有很多节点也存在匹配关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体实现的时候，我们除了用到每个节点的GNN表示外，还要利用邻接节点的GNN表示进行匹配。提取两个向量的匹配特征时，主要是计算向量之间的余弦距离，得到两个向量的相似度得分。因为每个节点的邻接节点有很多个，两个节点的邻接节点两两计算会形成一个矩阵。我们需要对矩阵的关键信息进行提取，对于每个邻接节点来说，与之对应匹配的邻接节点一般也只有一个。这样的话，我们通过Max Pooling就可以提取出最匹配的邻接节点的相似度得分，这个Max Pooling在行、列方向都会进行。另外，不是所有的邻接节点都对最终是否对齐的判定有帮助，在Aggregate过程中得到的邻接节点的权重，可以在这个地方用于确定邻接节点的权重，这个权重与前一步邻接节点的相似度得分Max Pooling结果进行相乘。最后，为了进一步提取邻接节点相似度得分的关键信息，我们使用Kernel pooling，它既保留了关键信息，又没有引入过多噪声。最终预测得分要同时融合Kernel Pooling提取的邻接节点匹配特征、两个节点的GNN表示的余弦相似度特征、两个节点文本表示的余弦相似度特征计算得到。与向量对齐模型相比，本模型的检出率又有进一步提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;9. 商品属性抽取&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpkPG0QDAd9KvUhzNSH0gJ5u2TWdLdIH4hTUKeNNfkAkwurYmNmAuibzqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多第三方卖家的商品属性填值没有那么规范，会存在很多商品属性的缺失或者错误。如右侧图片所示：CPU型号等关键信息都集中放在一些选项卡或者标题当中，没有放在具体属性里面。因此我们要预先对商品进行属性值抽取。商品属性的补全可以大大提升模型的检出率，重点品类的检出率能提升3到5倍。我们使用序列标注模型实现在商品标题当中的属性值提取。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm2M9FGAaKASjVqAMuwcmqpklSN3N1mTDILOwdPhdLYunLYrFfMoWnBQdBOrzp6H2fo2syuW4V4DIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商品属性抽取是一个典型的NER任务，因为商品的属性通常比较多，为了加快计算我们把整个属性抽取分为两步：第一步是预测商品标题中有哪些潜在的属性值；第二步，再去预测这些潜在属性值的类别。在商品属性提取时，使用商品的品类信息对于效果提升有一定帮助，品类的embedding特征会帮助我们在标题中要关注哪些字段。另外，我们根据已知的属性值，通过匹配的方式能在标题中找到一些候选的片段，利用这些候选片段可以提升属性抽取的召回率。商品属性预测也是一个比较大的话题，具体细节就不展开了。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;总结与展望&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 总结 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;本次分享介绍了通过融合了文本表示和图谱结构化表示的实体对齐模型，在电商领域中实现了商品之间的对齐任务，并利用商品属性抽取进一步提升了图谱对齐的检出率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 展望 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来的工作会考虑以下几个方面：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;05&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;精彩问答&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;数据schema对齐过程中，schema数据是人工对齐的吗？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;A：schema对齐目前是采用无监督的方式。因为商品数量比较大，通过简单的无监督模型，效果已经比较好了。也可以结合人工审核去提升schema对齐的准确率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span/&gt;&lt;span&gt;标注过程是需要人工的吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：&lt;/span&gt;&lt;span&gt;匹配结果标注是需要人工参与的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;正负样本的选取过程中，它的比例是如何确定的？负样本的生成，有什么策略？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：负样本的生成主要利用SPU下的不同的SKU来生成，每个正样本都会针对性的生成负样本，正样本商品所在SPU中，其它的SKU商品都可以作为负例，这类负例样本的对抗性更强。也有随机抽取、batch内计算相似度采样等方式。现在正负样本比例是1比10，这个比例是根据实验确定的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;表示学习和对齐的模型中，属性是怎么学习的？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：商品属性会有对应的embedding向量表示，这个embedding在训练过程中是参与优化的。在初始化的时候，我们会通过BERT编码计算所有对应属性值embedding向量，然后平均后作为属性初始化的embedding值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;实体对齐的效率和性能会不会受到实体节点数量的影响?超大规模的节点对整个性能会有多大的影响呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：目前处理速度要慢一些，我们做了几百个品类的对齐，对齐过程需要几个小时，运算量还是很大的，接下来会进一步优化处理效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;数值型的数据是如何在知识图谱中使用的呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：&lt;/span&gt;&lt;span&gt;目前没有单独处理数值型数据，会统一把这类数据当作文本数据来处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;商品实体对齐过程中结构信息占比有多大？它对实验效果有多大影响？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：这个可以对比图谱对齐和文本匹配模型的实验效果：与未使用结构化信息的文本匹配模型相比，使用结构化信息的向量对齐模型检出率相对提升150%以上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;不同品类的对齐用哪些属性有啥策略，这些是人工定义的还是自动生成的？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：目前没有对类别进行特殊的处理，所有商品类别都在一个模型中进行训练。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q&lt;/span&gt;&lt;span&gt;：图注意力网络如何融入边的信息，通过边的信息来影响邻近节点的权重？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：如前文介绍，我们有α和β两个系数，α可以看成标题和属性的匹配程度，β是根据属性类别，也就是边的类型来判断属性相似度。这个权重一方面会在聚合邻近节点时用到，另一方面在最后邻近节点匹配时也会用到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;模型上线部署时，模型推理效率的问题是怎么解决的呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：通过粗排模型减少候选的数量。此外，在文本编码时，可以预先去缓存一些高频属性值编码，这样在第二步训练时这部分内容可以直接作为输入，就不再单独计算了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;请问老师schema构建的过程中，有用propagate这种本体构建工具吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：没有用到。因为大部分数据是商品和属性之间关系，这个关系是商城中天然的结构化的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;正负样本的比例不均衡的话，如何消除样本对结果的影响？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：目前正负样本的比例是经过实验得到的。如果负样本很多的话，确实会对召回率、检出率会产生影响，需要在业务上和效果上需要一个平衡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;在使用图结构融合时，有没有试过把两个实体的多个属性拼接成文本，转化成文本相似匹配的方式去做？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：尝试过类似的模型，因为这种模型可以提前交互文本匹配特征，效果也不错，但是商品属性太多，有时候会影响计算效率。另外图神经网络的优势是可以融入结构化的信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;商品关系里面会有除了属性以外的其他关系吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：我们还用到了属性对齐关系，品类归属关系等等。另外SPU关系也用到了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;在RGCN模型训练中，如果图数据比较小，会影响embedding的效果吗？多大规模的数据训练会比较好呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：我们没有使用RGCN模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;在训练过程中，如果图数据会比较小的话，该怎么处理？因为TransE等模型对于大规模数据效果比较好，但是小样本数据训练的话，该怎么去处理呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：小样本的情况下，仅通过图的结构化信息是很难保证效果的，可以把优化的重点放到额外信息利用上，比如文本信息等等，这时候可以利用BERT等预训练的模型。对于图谱本身而言，样本数量少的话，很难达到预期效果。在小样本的情况下，文本信息可能要更重要一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;在这个训练过程中，如果结构信息不强的长尾实体，即：3元组比较小、比较少。这类长尾实体的匹配，您有什么好的解决办法吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：对于结构信息不强的长尾实体，要设法对其进行信息补全，比如我们做的商品属性抽取的工作就是补全结构化信息。另外还是尽可能利用到额外的信息提升效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;Q：&lt;/span&gt;&lt;span&gt;在实体匹配的过程中，会提前去看文本的匹配效果吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：会提前看。我们使用的粗排模型就是文本匹配模型，同时还作为图神经网络模型的初始化输入，直接影响最终效果。为了在粗排阶段不损失性能，我们训练粗排模型，使得Top100命中率达到一个比较高的效果，比如99%以上，也就是粗排的前100结果中基本都能包含正确结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;今天的分享就到这里，谢谢大家。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在文末分享、点赞、在看，给个3连击呗~&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享嘉宾：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;289&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;289&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaVOpUgibtUfuPKEm8HfWk4YEI5V9Vhibica4xQ7KlJWLRbbvic2tOMWzcoZcDicnCH37R26MJ27jtKTXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关于我们：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;DataFun：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;专注于大数据、人工智能技术应用的分享与交流。发起于2017年，在北京、上海、深圳、杭州等城市举办超过100+线下和100+线上沙龙、论坛及峰会，已邀请近1000位专家和学者参与分享。其公众号 DataFunTalk 累计生产原创文章500+，百万+阅读，12万+精准粉丝。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1NTMyOTI4Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgiaIKm4YqA09u83TvzKbfsabjfX1TLzaXLAK9MWmC4qI6cuTBJnxygZLZPU49O8g6j8QI9264NMqQ/0?wx_fmt=png&quot; data-nickname=&quot;DataFunTalk&quot; data-alias=&quot;datafuntalk&quot; data-signature=&quot;专注于大数据、人工智能技术应用的分享与交流。致力于成就百万数据科学家。定期组织技术分享直播，并整理大数据、推荐/搜索算法、广告算法、NLP 自然语言处理算法、智能风控、自动驾驶、机器学习/深度学习等技术应用文章。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;🧐&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;，给个&lt;strong&gt;3连击&lt;/strong&gt;呗！&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aa8e2862130ff1456ac1f2da8266eb7c</guid>
<title>136  python|第八部分：并发网络编程（一）网络编程上</title>
<link>https://toutiao.io/k/x1af9rz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;套接字&lt;/strong&gt;（Socket）是指&lt;span&gt;实现网络编程进行数据传输的一种技术手段&lt;/span&gt;，网络上各种网络服务大多是基于Socket来完成通信的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;socket模块是Python的标准库模块之一，通过import socket 可以导入模块。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMjU5ODM1Mg==&amp;amp;mid=2247486123&amp;amp;idx=1&amp;amp;sn=5f1f0622a468e4e8eac34ef5da75da04&amp;amp;chksm=f9c82814cebfa10205de75df7c2cd2d3e5ae7788dec397f75bc64c260e4c90d08ebbcc3de55e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;128 python|第三部分：python高级（一）程序结构和异常处理&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;128 python|第三部分：python高级（一）程序结构和异常处理&lt;/a&gt;中主要介绍了Python四类模块中的前两种：内置模块（以&lt;span&gt;random为例&lt;/span&gt;）和标准库模块（以&lt;span&gt;time模块为例&lt;/span&gt;）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMjU5ODM1Mg==&amp;amp;mid=2247497400&amp;amp;idx=1&amp;amp;sn=c5b2040541b8f1ac8d9e1f637fb86c54&amp;amp;chksm=f9cbd407cebc5d116a2ba5e0c240ae223b3b8a50f77219319b19d35a38b7442dafa1c5166a74&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;132 python|第五部分：文件管理&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;132 python|第五部分：文件管理&lt;/a&gt;中简单介绍了Python的标准库模块之一：os模块。更多标准库模块的使用可以在&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/xixi18/p/8406301.html&lt;/span&gt;中查看。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMjU5ODM1Mg==&amp;amp;mid=2247510022&amp;amp;idx=1&amp;amp;sn=93eddca8246e559e3d7206b71bb90d75&amp;amp;chksm=f9cb8ab9cebc03af8a9f9910f0ae07d922b66cfe8714bbdb1062d4c6c8b5b40226a369ae69a8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;135  python|第七部分：数据库（二）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;135  python|第七部分：数据库（二）&lt;/a&gt;中介绍了Python的第三类模块：第三方模块（以&lt;span&gt;pymysql为例&lt;/span&gt;）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMjU5ODM1Mg==&amp;amp;mid=2247492657&amp;amp;idx=1&amp;amp;sn=1671e1350e1f20c6195521c90f13c398&amp;amp;chksm=f9cbc68ecebc4f981f953909f3d7ee6d9aabc9187c5894d42aabaf44c92fe64c900b134d808d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;130 python|第三部分：python高级（三）函数式编程&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;130 python|第三部分：python高级（三）函数式编程&lt;/a&gt;中介绍了Python的第四类模块：自定义模块（以可迭代对象工具集为例）。&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;31&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;31&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uyZsSl2gvXUQ2ORiaDHIlr4Xw64zhj0RpicIt7q38C2p7EVuCvOoOutGuaPFXd4HBUnftjrfh8R3TtuKwZdWrkaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong&gt;2.2 UDP套接字编程&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.6666666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6YvdEMX0kT31okKDRaWh9A8St97VpkXnibEaFLNMcvcr1LKjEeCtjTfxbf8W5QGaILDbWrQiaG6PKU0IC8yTQ37g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;18&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01.查看socket内容&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.6666666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/jTVLNicGIe9FqpJ9W89PibqicaJAjFZyODAibGjnF9BLeRDGTtywClYg7Kxo9eDYB5zXq0x35J97NYZMkdZk958niaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;18&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;通过python3—import socket—dir(socket)，可以在终端查看socket的内容，socket是一个比较庞大的模块，其中很多是基于底层测试的，本文主要学习它的应用编程部分。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.37398373983739835&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uyZsSl2gvXUwW1xz9NbPhL3RKs0vRUicaEt2mVBicCP2xELp2xI8k4ibBicxZtrH7ibKAIUgF3FIUQLFlvOE3AE4q3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1845&quot;/&gt;&lt;/p&gt;&lt;section&gt;图中显示内容里的全大写字母在python中常被看做有特殊含义的变量，是不会对其进行修改的，可以当做常量看待，比如&lt;span&gt;AF_INET表示的是ipv4的地址；&lt;span&gt;SOCK_DGRAM&lt;/span&gt;&lt;span&gt;表示选择udp套接字服务进行数据传输。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.6666666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6YvdEMX0kT31okKDRaWh9A8St97VpkXnibEaFLNMcvcr1LKjEeCtjTfxbf8W5QGaILDbWrQiaG6PKU0IC8yTQ37g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;18&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02.功能&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.6666666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/jTVLNicGIe9FqpJ9W89PibqicaJAjFZyODAibGjnF9BLeRDGTtywClYg7Kxo9eDYB5zXq0x35J97NYZMkdZk958niaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;18&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;table align=&quot;center&quot; interlaced=&quot;enabled&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;th rowspan=&quot;1&quot; colspan=&quot;2&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;UDP套接字编程&lt;br/&gt;&lt;/th&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;语法&amp;amp;说明&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; colspan=&quot;1&quot; rowspan=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;创建套接字&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;sock = socket.&lt;span&gt;&lt;strong&gt;socket&lt;/strong&gt;&lt;/span&gt;(family,type)&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;功能：创建套接字&lt;br/&gt;参数：&lt;br/&gt;  family 网络地址类型 AF_INET表示ipv4&lt;br/&gt;  type 套接字类型 &lt;span&gt;SOCK_DGRAM&lt;/span&gt;表示udp套接字（或数据报套接字）&lt;br/&gt;返回值：套接字对象&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;2&quot; colspan=&quot;1&quot;&gt;&lt;span&gt;&lt;strong&gt;绑定地址&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;sock.&lt;span&gt;&lt;strong&gt;bind&lt;/strong&gt;&lt;/span&gt;(addr)&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;功能：绑定本机网络地址&lt;br/&gt;参数：二元元祖（ip,port）(&#x27;0.0.0.0&#x27;，7777)&lt;br/&gt;&lt;span&gt;port可以自定义，&lt;/span&gt;&lt;span&gt;bind功能通常只有服务端使用&lt;/span&gt;。&lt;br/&gt;地址设置：&lt;br/&gt;只本地地址：&#x27;localhost&#x27;,&#x27;127.0.0.1&#x27;&lt;br/&gt;网络地址：通过ifconfig查看&lt;br/&gt;自动获取地址：&lt;span&gt;&#x27;0.0.0.0&#x27;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;2&quot; colspan=&quot;1&quot;&gt;&lt;span&gt;&lt;strong&gt;消息收发&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;data,addr = sock.&lt;span&gt;&lt;strong&gt;recvfrom&lt;/strong&gt;&lt;/span&gt;(buffersize)&lt;br/&gt;n = sock.&lt;span&gt;&lt;strong&gt;sendto&lt;/strong&gt;&lt;/span&gt;(data,addr)&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;top&quot; align=&quot;left&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;1)功能：接收UDP消息&lt;br/&gt;参数：每次最多接收多少字节，一般会写&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0769230769230769&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uyZsSl2gvXUwW1xz9NbPhL3RKs0vRUicadic9FpTOY3HAiaPicRTJXiaLSSAmibV9mYZo7qEZ2ibVum9oBBS3SKvHrJlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;39&quot;/&gt;，比如1024&lt;br/&gt;返回值：&lt;br/&gt;  data：接收到的内容&lt;br/&gt;  addr：消息发送方地址（给他人发消息时，自己的地址也会随之暴露）&lt;br/&gt;recvfrom是一个阻塞函数，没人发消息时，接收方会阻塞等待&lt;br/&gt;&lt;br/&gt;2&lt;span&gt;)功能：发送&lt;/span&gt;&lt;span&gt;UDP消息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;参数：&lt;br/&gt;&lt;/span&gt;&lt;span&gt;  &lt;span&gt;d&lt;/span&gt;&lt;span&gt;ata ：发送的内容  bytes格式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  addr：目标地址&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;返回值：发送的字节数&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;&lt;strong&gt;关闭套接字&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;sock.&lt;span&gt;&lt;strong&gt;close&lt;/strong&gt;&lt;/span&gt;()&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;创建套接字&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import socket&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;udp_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;绑定地址（三选一）&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;服务端绑定不同的地址，客户端用不同的方式访问&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#　1）测试地址　　客户端必须在本地计算机&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#  客户端用 (&quot;127&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.1&lt;/span&gt;&quot;,7777) 访问服务端&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;udp_socket&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.bind&lt;/span&gt;((&quot;127&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.1&lt;/span&gt;&quot;,7777))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 2）网络地址   客户端服务端可以在不同计算机相互通信&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#  客户端用 (&quot;172&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.40&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.210&lt;/span&gt;&quot;,7777) 访问服务端&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;udp_socket&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.bind&lt;/span&gt;((&quot;172&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.40&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.210&lt;/span&gt;&quot;,7777))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 3）自动匹配合适的网络通信地址  等同于上边两种之和&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#  客户端用 (&quot;127&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.1&lt;/span&gt;&quot;,7777)或(&quot;172&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.40&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.210&lt;/span&gt;&quot;,7777) 访问服务端&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;udp_socket&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.bind&lt;/span&gt;((&quot;0&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&quot;,7777))  #&quot;0&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&quot;是用来绑定的，不是用来访问的&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.6666666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6YvdEMX0kT31okKDRaWh9A8St97VpkXnibEaFLNMcvcr1LKjEeCtjTfxbf8W5QGaILDbWrQiaG6PKU0IC8yTQ37g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;18&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;03.实例1&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.6666666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/jTVLNicGIe9FqpJ9W89PibqicaJAjFZyODAibGjnF9BLeRDGTtywClYg7Kxo9eDYB5zXq0x35J97NYZMkdZk958niaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;18&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;服务端和客户端的操作流程&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;服务端（server）：&lt;/p&gt;&lt;p&gt;socket()→bind()→recvfrom()/sendto()→close()&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;客户端（client）：&lt;/p&gt;&lt;p&gt;socket()→-----→sendto()/recvfrom()→close()&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;udp服务端示例&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;socket import *&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;udp_sock&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;socket(AF_INET,SOCK_DGRAM)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;udp_sock.bind((&quot;0.0.0.0&quot;,7777))&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;data,addr&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;udp_sock.recvfrom(1024)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;print(addr,&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,data.decode()) #data:bytes&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;udp_sock.sendto(b&#x27;Thanks&#x27;,addr) #给addr地址回复&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;udp_sock.close()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;udp客户端示例&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;socket import *&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;ADDR&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;(&quot;192.168.5.221&quot;,7777)#服务器地址&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;udp_sock&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;socket(AF_INET,SOCK_DGRAM)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;msg&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;input(&quot;&amp;gt;&amp;gt;&quot;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;udp_sock.sendto(msg.encode(),ADDR)&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;#发字节串&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;data,addr&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;udp_sock.recvfrom(1024)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;print(&quot;From&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;server:&quot;,data.decode())#打印接收内容&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;udp_sock.close()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;先运行服务端，再运行客户端（在客户端输入并发送信息）&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要注意的是，一般先启动服务端&lt;/span&gt;&lt;span&gt;，因为如果先&lt;/span&gt;&lt;span&gt;启动客户端，发出去的消息无人接收，消息会丢失。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23162134944612287&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uyZsSl2gvXUwW1xz9NbPhL3RKs0vRUicaYSyrMgyvh4bCibPibutzZ1r2crmdibyjqib8aYH2ya90veAvqrPfXia1dUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;993&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7faea312da67631b41a0ff6feba26697</guid>
<title>递归调用uGo函数</title>
<link>https://toutiao.io/k/hetjoek</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;main&gt;
                        
&lt;p&gt;本节将实现递归调用µGo函数，需要解决函数类型的解析、函数参数的Scope和代码生成等问题。&lt;/p&gt;

&lt;p&gt;完善ast包的函数节点，添加类型信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 函数信息
type Func struct {
...
Type    *FuncType
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数的类型主要由函数参数和返回值类型组成：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 函数类型
type FuncType struct {
Func   token.Pos
Params *FieldList
Result *Ident
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数数一个参数名和类型对组成的列表，返回值只有一个表示类型的名字。&lt;/p&gt;
&lt;p&gt;参数列表定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 参数/属性 列表
type FieldList struct {
Opening token.Pos
List    []*Field
Closing token.Pos
}

// 参数/属性
type Field struct {
Name *Ident // 名称
Type *Ident // 类型
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;uGo不支持Go语言中多个参数共用一个类型的写法，名字和类型时一一对应的，用&lt;code&gt;Field&lt;/code&gt;表示。&lt;/p&gt;

&lt;p&gt;在前面章节中，uGo实现的main函数没有参数和返回值，现在增加函数类型解析。改造&lt;code&gt;parser&lt;/code&gt;包的&lt;code&gt;Parser.parseFunc&lt;/code&gt;解析方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (p *Parser) parseFunc() *ast.Func {
tokFunc := p.MustAcceptToken(token.FUNC)
tokFuncIdent := p.MustAcceptToken(token.IDENT)

fn := &amp;amp;ast.Func{
FuncPos: tokFunc.Pos,
NamePos: tokFuncIdent.Pos,
Name:    tokFuncIdent.Literal,
Type: &amp;amp;ast.FuncType{
Params: &amp;amp;ast.FieldList{},
},
}
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先构造函数节点对象，然后解析函数参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (p *Parser) parseFunc() *ast.Func {
...
// parsr params
p.MustAcceptToken(token.LPAREN) // (
for {
// )
if _, ok := p.AcceptToken(token.RPAREN); ok {
break
}

// arg type, ...
tokArg := p.MustAcceptToken(token.IDENT)
tokTyp := p.MustAcceptToken(token.IDENT)

fn.Type.Params.List = append(fn.Type.Params.List, &amp;amp;ast.Field{
Name: &amp;amp;ast.Ident{
NamePos: tokArg.Pos,
Name:    tokArg.Literal,
},
Type: &amp;amp;ast.Ident{
NamePos: tokTyp.Pos,
Name:    tokTyp.Literal,
},
})
}
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后解析可选的返回值类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (p *Parser) parseFunc() *ast.Func {
...
// result type
if _, ok := p.AcceptToken(token.LBRACE, token.SEMICOLON); ok {
p.UnreadToken()
} else {
tok := p.MustAcceptToken(token.IDENT)
fn.Type.Result = &amp;amp;ast.Ident{
NamePos: tok.Pos,
Name:    tok.Literal,
}
}
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后是函数Body部分：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (p *Parser) parseFunc() *ast.Func {
...

// body: {}
if _, ok := p.AcceptToken(token.LBRACE); ok {
p.UnreadToken()
fn.Body = p.parseStmt_block()
}

return fn
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就完成了函数类型的解析，读者可以自行通过&lt;code&gt;ugo ast a.ugo&lt;/code&gt;命令测试。&lt;/p&gt;

&lt;p&gt;要实现递归函数调用，需要提前将函数的名字添加到Scope中。改造&lt;code&gt;compiler&lt;/code&gt;包的&lt;code&gt;Compiler.compileFile&lt;/code&gt;方法，将函数注册到当前文件对应的scope：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (p *Compiler) compileFile(w io.Writer, file *ast.File) {
...
// global vars
for _, g := range file.Globals {
...
}

// global funcs
for _, fn := range file.Funcs {
var mangledName = fmt.Sprintf(&quot;@ugo_%s_%s&quot;, file.Pkg.Name, fn.Name)
p.scope.Insert(&amp;amp;Object{
Name:        fn.Name,
MangledName: mangledName,
Node:        fn,
})
}
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数的注册过程和全局变量类似。&lt;/p&gt;
&lt;p&gt;然后是改造&lt;code&gt;Compiler.compileFunc&lt;/code&gt;函数，增加对函数参数的支持：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (p *Compiler) compileFunc(w io.Writer, file *ast.File, fn *ast.Func) {
...

// args
var argNameList []string
for _, arg := range fn.Type.Params.List {
var mangledName = fmt.Sprintf(&quot;%%local_%s.pos.%d&quot;, arg.Name.Name, arg.Name.NamePos)
argNameList = append(argNameList, mangledName)
}
...

// fn body
func() {
// args+body scope
defer p.restoreScope(p.scope)
p.enterScope()

// args
for i, arg := range fn.Type.Params.List {
var argRegName = fmt.Sprintf(&quot;%s.arg%d&quot;, argNameList[i], i)
var mangledName = argNameList[i]
p.scope.Insert(&amp;amp;Object{
Name:        arg.Name.Name,
MangledName: mangledName,
Node:        fn,
})

fmt.Fprintf(w, &quot;\t%s = alloca i32, align 4\n&quot;, mangledName)
fmt.Fprintf(
w, &quot;\tstore i32 %s, i32* %s\n&quot;,
argRegName, mangledName,
)
}

// body
for _, x := range fn.Body.List {
p.compileStmt(w, x)
}
}()
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新代码将函数的翻译封装到一个闭包函数中，这样做的原因是函数参数的名字空间和函数Body共享，因此需要特别处理。另外需要注意的是LLVM-IR的函数参数类似一个只读的虚拟寄存器，并不是alloc指令分配的可取地址的内存空间。我们需要将函数参数映射为alloc指令分配的空间，这样才可以统一函数参数和局部变量的操作。&lt;/p&gt;

&lt;p&gt;现在构造一个递归版本的斐波那契：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

func main() {
for i := 0; i &amp;lt; 20; i = i + 1 {
if n := fib(i); n &amp;lt;= 100 {
println(n)
}
}
}

func fib(n int) int {
if n &amp;gt;= 2 {
return fib(n-1) + fib(n-2)
}
return 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行以下命令测试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go run main.go -debug run ./_examples/fib2.ugo
1
1
2
3
5
8
13
21
34
55
89
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果正常。&lt;/p&gt;

                    &lt;/main&gt;

                    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>