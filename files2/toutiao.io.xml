<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>34f212d7a2fe04dde4b5b0854999063a</guid>
<title>美团外卖美食知识图谱的迭代及应用</title>
<link>https://toutiao.io/k/hlwpt15</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1. 背景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2. 需求及挑战&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3. 外卖美食知识图谱的迭代&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.1 菜品类目&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.2 类目、口味、食材、荤素、做法等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.3 健康餐&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.4 菜品实体对齐&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4. 应用&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.1 套餐搭配-表征菜品&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.2 交互式推荐&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.3 搜索&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5. 未来规划&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5.1 场景化标签的挖掘&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5.2 基于图谱的推荐技术研究&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6. 参考文献&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7. 作者简介&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文系外卖美食知识图谱系列的第一篇文章，这篇文章系统地介绍了美团外卖美食知识图谱的标签体系结构，包括菜品类目标签、标准菜品名、美食基础属性（&lt;span&gt;食材、口味等&lt;/span&gt;）和美食业务主题属性（&lt;span&gt;商家招牌、类目经典等&lt;/span&gt;）。在技术层面，举例对标签体系的具体构建方法进行介绍，例如基于BERT预训练的分类模型。在应用方面，介绍了美食知识图谱在美团外卖业务的具体应用，包括支撑套餐搭配的菜品表征、提升搜索和商家推荐等业务的用户体验。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 背景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;知识图谱，旨在描述真实世界中存在的各种实体和实体之间的关系。在美团外卖业务中，美食商品是美团向用户提供服务的基础，美食知识图谱的建设，可以帮助我们向用户提供更加准确、更加丰富、更加个性化的美食服务。另外，美团外卖业务向用户提供“到家”吃饭的服务，到店餐饮业务则向用户提供“到店”吃饭的服务，而外卖和到店的商家和菜品有相当程度的重合，菜品数据的对齐，为我们进行线上（&lt;/span&gt;&lt;span&gt;外卖场景&lt;/span&gt;&lt;span&gt;）线下（&lt;/span&gt;&lt;span&gt;到店场景&lt;/span&gt;&lt;span&gt;）数据的对比分析也提供了一个很好的“抓手”。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文介绍了外卖美食知识图谱的建设，基于对外卖业务数据（&lt;/span&gt;&lt;span&gt;外卖交易数据、商家录入的商品标签信息、专业描述PGC、用户评论UGC、商品图片等&lt;/span&gt;&lt;span&gt;）的挖掘和分析，形成了针对外卖美食的分类体系（&lt;/span&gt;&lt;span&gt;美食类目标签&lt;/span&gt;&lt;span&gt;）和标准化体系（&lt;/span&gt;&lt;span&gt;标准菜品名标签&lt;/span&gt;&lt;span&gt;），并进一步针对不同类型的美食商品，构建包含口味、食材等众多美食基础属性体系。同时，依托美团外卖的业务特性，构建美食商品在外卖业务中涉及的主题属性体系，例如商家招牌、商家主营、类目经典等。目前，外卖美食知识图谱的标签结构如下图1所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;466&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;226&quot; data-ratio=&quot;0.510989010989011&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWfyMTop4riaWsUY4lToThgg0Ywjad8ezca1WXTCl3mGZKXrq0XwYcAiapibuSIBR2wkoIjyXXztPJ8g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;728&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图1 美食知识图谱标签体系&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;外卖美食知识图谱包含以下四种维度的标签（&lt;/span&gt;&lt;span&gt;以“宫保鸡丁”为例，如下图2所示&lt;/span&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;类目标签&lt;/strong&gt;：包括主食、小吃、菜品等类目，并在每个类目下，形成了层级化的三百多种细分类目。例如“宫保鸡丁”的类目是“菜品”。类目标签是美食商品的基础分类信息，根据类目的不同，美食商品的基础属性也不同。例如“菜品”类目存在“荤素”、“菜系”之分，而“酒水饮品”类目则没有这种属性标签。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;标准菜品名标签&lt;/strong&gt;：标准菜品名标签主要为标准商品信息，例如“宫保鸡丁（&lt;/span&gt;&lt;span&gt;招牌必点&lt;/span&gt;&lt;span&gt;）”的标准商品是“宫保鸡丁”。因商家输入商品的多样性，标准菜标签的建设，实现了相同美食的聚合。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;基础属性&lt;/strong&gt;：根据美食商品的类目不同，构建包括美食的食材、菜系、口味、制作方法、荤素等基础属性。例如“宫保鸡丁”的菜系是“川菜”，食材有“鸡胸”和“花生”，荤素标签是“荤”。基础属性的挖掘对我们理解商品起到关键作用，在商品的筛选、展示、商品表征等业务需求方面，提供基本的数据特征。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;主题属性&lt;/strong&gt;：主题属性主要体现美食的业务主题，包括美食在外卖的交易行为、美食在商家的定位、美食在用户反馈中的好评度等。例如某商家的“宫保鸡丁（&lt;/span&gt;&lt;span&gt;招牌必点&lt;/span&gt;&lt;span&gt;）”是该商家的“招牌菜”。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;333&quot; data-ratio=&quot;0.6906019007391764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWfyMTop4riaWsUY4lToThggGxqyNYnvgrpnaPvp0bA4Sjso4kA0K2ydUtgKEgvuAp6teaz5TaleXA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;947&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2 外卖美食知识图谱样例&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;菜品对齐，涉及到菜品数据，来自外卖在线菜品、点评推荐菜品、美团商家套餐等。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 需求及挑战&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前，外卖美食知识图谱已经应用于美团外卖的多个场景，例如推荐、搜索、套餐搭配、运营分析等。业务的深入发展，对美食知识图谱的建设和迭代也提出了更加复杂的要求，例如：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;美食商品越来越多样，相应的美食知识图谱则需要越来越精细和准确。例如美食知识图谱的类目标签从零开始，建设了包含一百多种类目的类目标签体系。但随着业务发展，部分类目存在明显的可细化空间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;图谱标签的挖掘，偏向于静态标签的挖掘，对于相同图谱标签下的美食，缺少业务相关的主题属性描述。例如同样包含“花生”的“酒鬼花生”，相比“宫保鸡丁”，更能代表“花生”相关的美食。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;外卖美食知识图谱主要描述外卖美食商品，而同一商家的美食商品，也可能会出现在该店的线下收银等业务中。通过对齐不同业务的美食商品，可以在美食实体层面，完善美食知识图谱对商家美食的描述，从而指导商品和商家运营。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为满足业务需求，我们对类目标签和基础属性进行了迭代和优化；同时，构建了业务相关的主题属性。另外，我们将外卖菜品和到餐菜品进行了实体对齐。其中，挖掘主题属性，即挖掘业务相关的图谱知识，是一个需要综合考虑外卖业务和商品本身属性的复杂过程。外卖菜品和到餐菜品的对齐，则需要综合考虑菜品多样性表述和菜品主体归一。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;外卖美食知识图谱的迭代难点主要体现在以下几点：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务相关的主题属性挖掘，并没有现成的体系可以参考，在构建过程中，涉及大量的分析和体系设计工作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主题属性的挖掘，最重要的是需要从用户的需求出发，分析用户对商品的需求点，并将其反映在商品的图谱层面，形成相应的主题属性标签。同时，商家的商品信息是一个动态变化的过程，例如销量、供给、商品标签等，前后两天的信息可能就会完全不同。因此业务性主题属性的挖掘，一方面需要建设相对完善的体系，另一方面也需要适配业务数据的动态变化过程，也就在图谱挖掘和需求匹配上带来了极大的挑战。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;商家录入菜品时，对菜品存在多样性表述，例如同一道菜在分量、口味、食材等方面存在的差异。菜品对齐时，则需要对这些多样性表述进行平衡，例如是否忽略分量因素等。但目前并没有现成的对齐标准可以参考。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 外卖美食知识图谱的迭代&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因篇幅受限，本文主要对其中菜品类目，不同类目、口味、食材、荤素、做法下的经典美食，健康餐等图谱标签的挖掘进行介绍。其中，在图谱标签挖掘中涉及到的数据来源和采用的技术，大致如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3159509202453988&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWfyMTop4riaWsUY4lToThgg3F0oVlWnXEfzgxXG92r0a4ichoTiblViaTmJCY3Yw8am9vlibOGf7veXnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1304&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 菜品类目&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;菜品类目标签的挖掘，主要解决美食菜品是什么类别的问题。实现这一目标的挑战有两方面：首先是类目体系如何建立，其次是如何将商品链接到相应的类目节点。在最开始的体系构建时，我们从美食商品的特点以及业务的具体需求出发，从零开始建立起包含一百多种类别的层次化类别体系，部分实例如图3（&lt;/span&gt;&lt;span&gt;左&lt;/span&gt;&lt;span&gt;）所示。同时，构建基于CNN+CRF的分类模型，对美食商品进行类目分类，如图4（&lt;/span&gt;&lt;span&gt;左&lt;/span&gt;&lt;span&gt;）所示。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然而，随着业务的发展，已有分类目已经无法支持现有业务的需求。例如：原先的类目体系，对热菜描述不够详细，譬如没有区分热菜的做法等。为此，我们与外卖的供给规划部合作，将类目体系扩充到细分的三百多种类目标签，划分更加详细，覆盖也更加全面，部分实例如图3（&lt;/span&gt;&lt;span&gt;右&lt;/span&gt;&lt;span&gt;）所示。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24324324324324326&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWfyMTop4riaWsUY4lToThgg1uOKMd5sFd5UibT3NxaxkjPu5ytib2mTSVtMibOIKwB6rASXMWxPj1R6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1073&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图3 类目体系的迭代&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类目的细分，要求模型更加精确。在进行类目识别时，可用的数据包括菜品名、商家店内侧边栏分类名称、商家名等。考虑到可使用的信息大多为文本信息，并且，商家录入的文本并没有一定的规范，菜品名也多种多样，为提高模型精度，我们将原先的CNN+CRF的分类模型进行了升级，采用模型容量更大的BERT预训练+Fine-Tuning的模型。模型结构如下图4（&lt;/span&gt;&lt;span&gt;右&lt;/span&gt;&lt;span&gt;）所示。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;1&quot; data-cropselx2=&quot;522&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;179&quot; data-ratio=&quot;0.3569350145489816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWfyMTop4riaWsUY4lToThggiaBgSibxLGpMb3YwiaiaVesdKWHCNVHGRhhdvYrno4juIuFAAULuicupP9Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1031&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图4 类目模型迭代&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 不同类目、口味、食材、荤素、做法下的经典美食标签&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们在建设主题属性时，首先在基础属性标签维度，综合考虑商品的销量和供给情况，对菜品进行选优。例如类目下的经典美食等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类目经典美食等指的是销量较高、供给量丰富的类目美食商品，例如主食经典美食、小吃经典美食。口味、食材、做法经典美食标签等也是相似的定义。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在建设过程中，我们发现，假如直接在商品维度进行识别，因为商品的更新频率相对较高，对新录入的暂时没有销量或者暂时销量低的美食商品不友好，销量水平需要考虑在线时间的影响。因此我们使用标准菜品进行类目、口味经典等的识别，并通过标准菜品，泛化到具体的美食商品上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中，“标准菜品”借用其它类电商业务中的“标品”概念，虽然绝大部分菜品的生产都不是标准化的过程，但是这里我们只关注主要的共性部分，忽略次要的差异部分。例如“西红柿鸡蛋”、“番茄炒蛋”都是同一类菜品。从结果上看，目前我们聚合出来的“标准菜品”达到几十万的量级，并且能够覆盖大部分美食商品。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;借助标准菜品，我们将类目、口味、食材、荤素、做法等标签聚合到标准菜品维度，并将销量、供给量进行标准菜品维度计算，这样就解决了商品在线时间长短的问题。在具体打标过程中，例如类目经典，我们基于销量和供给，在类目维度对标准菜进行排序，并选择Top n%标准菜进行打标，作为类目经典下的商品。例如在“面食”类目下，“西红柿鸡蛋面”的销量和供给量均在Top n%的水平，因此就认为“西红柿鸡蛋面”是一个面食类经典美食。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 健康餐&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里的健康餐主要指低脂低卡餐，即低卡路里、低脂肪、高纤维、制作简单、原汁原味、健康营养的食物，一般为蔬菜水果（&lt;/span&gt;&lt;span&gt;如罗勒、甘蓝、秋葵、牛油果等&lt;/span&gt;&lt;span&gt;），富含优质蛋白的肉类（&lt;/span&gt;&lt;span&gt;如三文鱼、虾、贝类、鸡胸等&lt;/span&gt;&lt;span&gt;），谷物（&lt;/span&gt;&lt;span&gt;主要以粗粮为主，如燕麦、高粱、藜麦等&lt;/span&gt;&lt;span&gt;）。烹饪方法也坚持“少油，少盐，少糖”的原则，主要做法为蒸、煮、少煎、凉拌等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;健康餐的识别，主要挑战在于本身的样本较少，但是因为健康餐的特殊性，商家在进行商品录入时，一般会对其进行描述，例如指出这个美食商品是“健康”的、“低卡”的、“健身”类型的，因此我们构建了一个分类模型，对健康餐进行识别。可使用的数据，包括商品名、商家导航栏、商家名称、商家对商品的描述等。而商家类目与商品的类目处于迭代状态，因此并没有对这部分信息进行使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;识别过程如下&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;训练数据构建&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：因健康餐本身的占比相对较少，因此首先总结和健康餐相关的关键词，使用关键词进行文本匹配，采样概率相对较高的健康餐数据，进行外包数据标注。此处，我们总结出“沙拉、谷物饭、谷物碗、低油、低卡、无糖、减脂、减肥、轻食、轻卡”等关键词。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;模型构建&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：同一个商品因其中使用的配料不同，在健康餐识别方面也会不同，例如菜名为“招牌沙拉”的商品，假如沙拉中添加了芝士，则有可能商品就不会被识别成健康餐。为了综合考虑商家录入的商品信息，使用商品名、商家名、导航栏名称、商家录入的商品描述等。这四种数据为不同尺度的数据源，商品名等为相对较短的文本，因此在模型构建时，考虑使用类似Text-CNN[1]的结构进行字级别的特征提取；商品描述则是相对较长的文本，因此在构建时，考虑使用类似Transformer[3]的结构进行特征提取，使用Multi-head Attention的机制，提取长文本中，“字”层面的特征。具体结构如下：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据迭代增强&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：因为使用关键词进行样本构建，在模型训练时，模型会朝着包含这些关键词的方向学习，因此存在漏召回的情况。在这里，我们进行了一定的训练数据增强，例如在评估时，选取可识别出健康餐的商家，对该商家中漏召回的数据进行训练数据补充；同时，对部分特征明显的关键词，进行补充并扩充正例。通过对训练样本的多次扩充，最终完成健康餐的高准确率识别。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;452&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;266&quot; data-ratio=&quot;0.6045197740112994&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWfyMTop4riaWsUY4lToThggrarWgrmNEoNsy8Vmkl78FQ18PJb4oTYSMgyyTVBaxUWy04OPhmcxpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;708&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图5 健康餐识别模型&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4 菜品实体对齐&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;考虑到同一商家菜品在不同业务线的菜品名可能略有差异，我们设计了一套菜品名匹配的算法，通过拆解菜品名称的量词、拼音、前后缀、子字符串、顺序等特征，利用美食类目识别、标准菜品名抽取、同义关系匹配等进行菜品实体对齐。例如：碳烧鸽=炭烧鸽、重庆辣子鸡=重庆歌乐山辣子鸡、茄子肉泥盖饭=茄子肉泥盖浇饭、番茄炒蛋=西红柿炒蛋等。目前，形成如下图的菜品归一体系：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;511&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;221&quot; data-ratio=&quot;0.45420326223337515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWfyMTop4riaWsUY4lToThggrjNjUNvuUUDu1BzFFCgpXWfaSIF1gJTUHbnZOrFr7kdxoItLCbMcAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;797&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图6 菜品归一体系&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 应用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里对外卖美食知识图谱的应用，进行举例说明。主要涉及套餐搭配、美食商品展示等。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 套餐搭配-表征菜品&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为满足用户的搭配成单需求，进行套餐搭配技术的探索。套餐搭配技术的关键在于，对美食商品的认知，而外卖美食知识图谱，则提供了最全面的数据基础。我们基于同商家内的商品信息和历史成单信息，对商品的搭配关系进行拟合，参考指针网络[2]等结构，构建了基于Multi-Head Attention[3]的Enc-Dec模型，具体的模型结构如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;① &lt;strong&gt;Encoder&lt;/strong&gt;：对商家菜单进行建模，因菜单为无序数据，因此采用Attention的方式进行建模。商品的信息主要包括商品名、商品图谱标签、交易统计数据等三部分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;a. 对菜名、商品标签分别进行Self-Attention计算，得到菜名和商品标签对应的向量信息，然后与交易统计数据进行Concat，作为商品的初步表示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;b. 对商品的初步表示进行Self-Attention计算，以对同商家的商品有所感知。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;② &lt;strong&gt;Deocoder&lt;/strong&gt;：对搭配关系进行学习，基于当前已选择的商品，对下一个可能的搭配进行预估。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;a. 在搭配输出时，使用Beam-Search进行多种搭配结果的输出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;b. 为了保证输出搭配中的商品的多样性，添加Coverage机制[2]。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③ 训练之后，将Encoder部分分离，进行离线调度，可实现每天的向量产出。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;具体的模型结构如下图7所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5400763358778626&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWfyMTop4riaWsUY4lToThggTgmyJRN64mCmrvv2t9eQEtNIWHOAic1M54VXh9ywTRxYow1MuaJe7Ww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;524&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图7 套餐搭配模型&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于外卖美食知识图谱构建的套餐搭配模型，在多个入口（&lt;/span&gt;&lt;span&gt;“满减神器”、“对话点餐”、“菜品详情页”等&lt;/span&gt;&lt;span&gt;）取得转化的提升。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 交互式推荐&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过分析外卖用户的需求，发现用户存在跨店相似商品对比的需求，为打破商家界限的选购流程特点，提供便捷的跨店对比决策方式。交互式推荐，通过新的交互模式，打造推荐产品的突破点。在用户的交互过程中，根据用户的历史偏好、实时的点击行为，向用户推荐可能喜欢的美食商品。如下图8（&lt;/span&gt;&lt;span&gt;左&lt;/span&gt;&lt;span&gt;）所示，在向用户进行同类美食的推荐时，美食知识图谱中的标准菜品标签提供了主要的数据支撑。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3 搜索&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;搜索作为外卖核心流量入口，承载了用户明确的外卖需求。用户通过输入关键词，进行菜品检索。在实际使用中，从搜索的关键词类型看，可能是某个具体的菜品，也可能是某种食材、某种菜系。在美食知识图谱中，图谱标签的高准确率和高覆盖，有助于提升搜索入口的用户体验，最新的实验也表明了这一点（新增部分食材、菜系、功效等标签，在搜索的线上实验效果正向）。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;384&quot; data-ratio=&quot;0.4769392033542977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWfyMTop4riaWsUY4lToThggrFLRicOaM8YIcXl5X1xrubVKGOwMCeDzzvNk9tJIdGe9fK58tricp6OQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;954&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图8 交互式推荐和搜索&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 未来规划&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.1 场景化标签的挖掘&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;美食与我们的生活息息相关，美团外卖每天为千万用户提供美食方面的服务。然而，用户的需求是多种多样的，在不同的环境、不同的场景下，对美食的需求也不尽相同。目前美食知识图谱挖掘，在场景相关的标签较为缺失，例如某些节气、节日等图谱知识；特定天气情况下的图谱知识；特定人群（增肌人群、减肥人群）等的图谱知识。接下来我们会在场景化标签的挖掘方面进行探索。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在挖掘方法方面，目前的挖掘数据主要为文本信息。在商品图片、描述、结构化标签等信息的融合方面，挖掘不够深入，模型的效果也有待提升。因此在多模态识别模型方面，我们也会进行相应的探索。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.2 基于图谱的推荐技术研究&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;美团外卖在理解美食的基础上，向用户进行美食推荐，以更好地满足用户对美食的需求。外卖美食知识图谱和外卖业务数据，作为实现这一点的数据基础，包含上亿的节点信息和十几亿的关系数据。通过对用户的商品搜索、点击、购买等行为进行建模分析，可以更加贴合用户的需求，向用户进行商品推荐，例如，将美食知识图谱和外卖行为数据融合，以用户为起点，进行随机游走，向用户推荐相关的美食。在接下来的图谱应用方面的探索中，我们也会更加深入的探索基于美食知识图谱和用户行为的推荐技术。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6. 参考文献&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;[1] Kim Y. Convolutional neural networks for sentence classification[J]. arXiv preprint arXiv:1408.5882, 2014.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[2] See A, Liu P J, Manning C D. Get to the point: Summarization with pointer-generator networks[J]. arXiv preprint arXiv:1704.04368, 2017.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[3] Vaswani A, Shazeer N, Parmar N, et al. Attention is all you need[C]//Advances in neural information processing systems. 2017: 5998-6008.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[4] Hamilton W, Ying Z, Leskovec J. Inductive representation learning on large graphs[C]//Advances in Neural Information Processing Systems. 2017: 1024-1034.&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7. 作者简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;杨林、郭同、海超、懋地等，均来自美团外卖技术团队。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;---&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7r&quot; textvalue=&quot;前端&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;前端&lt;/a&gt;&lt;strong&gt;&lt;span&gt; |&lt;/span&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt; &lt;/strong&gt; &lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jsdG&quot; textvalue=&quot;算法&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;算法&lt;/a&gt;&lt;strong&gt; |&lt;/strong&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jsWK&quot; textvalue=&quot;后端&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;后端&lt;/a&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt; | &lt;/span&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jqRZ&quot; textvalue=&quot;数据&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;数据&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;安全&lt;/a&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jui4&quot; textvalue=&quot;Android&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Android&lt;/a&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jtXE&quot; textvalue=&quot;iOS&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;iOS&lt;/a&gt; &lt;strong&gt; |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7K&quot; textvalue=&quot;运维&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;运维&lt;/a&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jtsX&quot; textvalue=&quot;测试&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;测试&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e9e7c4768f77850c84bff441b02d87ab</guid>
<title>25 张图，一万字，拆解 Linux 网络包发送过程</title>
<link>https://toutiao.io/k/z26byeu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;问1：我们在查看内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;问2：为什么你服务器上的 /proc/softirqs 里 NET_RX 要比 NET_TX 大的多的多？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;问3：发送网络数据的时候都涉及到哪些内存拷贝操作？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些问题虽然在线上经常看到，但我们似乎很少去深究。如果真的能透彻地把这些问题理解到位，我们对性能的掌控能力将会变得更强。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带着这三个问题，我们开始今天对 Linux 内核网络发送过程的深度剖析。还是按照我们之前的传统，先从一段简单的代码作为切入。如下代码是一个典型服务器程序的典型的缩微代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;int &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;(){  &lt;br/&gt; fd = socket(AF_INET, SOCK_STREAM, 0);  &lt;br/&gt; &lt;span&gt;bind&lt;/span&gt;(fd, ...);  &lt;br/&gt; listen(fd, ...);  &lt;br/&gt;  &lt;br/&gt; cfd = accept(fd, ...);  &lt;br/&gt;  &lt;br/&gt; // 接收用户请求  &lt;br/&gt; &lt;span&gt;read&lt;/span&gt;(cfd, ...);  &lt;br/&gt;  &lt;br/&gt; // 用户请求处理  &lt;br/&gt; dosometing();   &lt;br/&gt;  &lt;br/&gt; // 给用户返回结果  &lt;br/&gt; send(cfd, buf, sizeof(buf), 0);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们来讨论上述代码中，调用 send 之后内核是怎么样把数据包发送出去的。本文基于Linux 3.10，网卡驱动采用Intel的igb网卡举例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;预警：本文共有一万多字，25 张图，长文慎入！&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、Linux 网络发送过程总览&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得看 Linux 源码最重要的是得有整体上的把握，而不是一开始就陷入各种细节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这里先给大家准备了一个总的流程图，简单阐述下 send 发送了的数据是如何一步一步被发送到网卡的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNX1x1UEBIyveezFWoBqbfqcQO85kXF1L3YvcIS86ianMkm25OeWHg9sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9399141630901288&quot; data-w=&quot;466&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这幅图中，我们看到用户数据被拷贝到内核态，然后经过协议栈处理后进入到了 RingBuffer 中。随后网卡驱动真正将数据发送了出去。当发送完成的时候，是通过硬中断来通知 CPU，然后清理 RingBuffer。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为文章后面要进入源码，所以我们再从源码的角度给出一个流程图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNN5ndOR5DB5xHMjaV4XlJnY9iajk0ia1nAsm7CDzBrUDNzuiaJy4wPSL3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;3.65283540802213&quot; data-w=&quot;723&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然数据这时已经发送完毕，但是其实还有一件重要的事情没有做，那就是释放缓存队列等内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那内核是如何知道什么时候才能释放内存的呢，当然是等网络发送完毕之后。网卡在发送完毕的时候，会给 CPU 发送一个硬中断来通知 CPU。更完整的流程看图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNHO50EyzavTV4lzNMXbgmqXBzwibOH4fe4SEpTMYX93nHYf1MUDiaAPgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.525874125874126&quot; data-w=&quot;715&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，我们今天的主题虽然是发送数据，但是硬中断最终触发的软中断却是 NET_RX_SOFTIRQ，而并不是 NET_TX_SOFTIRQ ！！！（T 是 transmit 的缩写，R 表示 receive）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;意不意外，惊不惊喜？？？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这就是开篇问题 1 的一部分的原因（注意，这只是一部分原因）。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;问1：在服务器上查看 /proc/softirqs，为什么 NET_RX 要比 NET_TX 大的多的多？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传输完成最终会触发 NET_RX，而不是 NET_TX。所以自然你观测 /proc/softirqs 也就能看到 NET_RX 更多了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，现在你已经对内核是怎么发送网络包的有一个全局上的把握了。不要得意，我们需要了解的细节才是更有价值的地方，让我们继续！！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、网卡启动准备&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的服务器上的网卡一般都是支持多队列的。每一个队列上都是由一个 RingBuffer 表示的，开启了多队列以后的的网卡就会对应有多个 RingBuffer。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNdydA6qUibicwic6KVIO5L9v0ZqYx7WRbnDK7NbylJiaFruhSNRrNDcklLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3608521970705726&quot; data-w=&quot;751&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网卡在启动时最重要的任务之一就是分配和初始化 RingBuffer，理解了 RingBuffer 将会非常有助于后面我们掌握发送。因为今天的主题是发送，所以就以传输队列为例，我们来看下网卡启动时分配 RingBuffer 的实际过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在网卡启动的时候，会调用到 __igb_open 函数，RingBuffer 就是在这里分配的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static int __igb_open(struct net_device *netdev, bool resuming)  &lt;br/&gt;{  &lt;br/&gt; struct igb_adapter *adapter = netdev_priv(netdev);  &lt;br/&gt;  &lt;br/&gt; //分配传输描述符数组  &lt;br/&gt; err = igb_setup_all_tx_resources(adapter);  &lt;br/&gt;  &lt;br/&gt; //分配接收描述符数组  &lt;br/&gt; err = igb_setup_all_rx_resources(adapter);  &lt;br/&gt;  &lt;br/&gt; //开启全部队列  &lt;br/&gt; netif_tx_start_all_queues(netdev);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面 __igb_open 函数调用 igb_setup_all_tx_resources 分配所有的传输 RingBuffer, 调用 igb_setup_all_rx_resources 创建所有的接收 RingBuffer。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static int igb_setup_all_tx_resources(struct igb_adapter *adapter)  &lt;br/&gt;{  &lt;br/&gt; //有几个队列就构造几个 RingBuffer  &lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; adapter-&amp;gt;num_tx_queues; i++) {  &lt;br/&gt;  igb_setup_tx_resources(adapter-&amp;gt;tx_ring[i]);  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真正的 RingBuffer 构造过程是在 igb_setup_tx_resources 中完成的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;int igb_setup_tx_resources(struct igb_ring *tx_ring)  &lt;br/&gt;{  &lt;br/&gt; //1.申请 igb_tx_buffer 数组内存  &lt;br/&gt; size = sizeof(struct igb_tx_buffer) * tx_ring-&amp;gt;count;  &lt;br/&gt; tx_ring-&amp;gt;tx_buffer_info = vzalloc(size);  &lt;br/&gt;  &lt;br/&gt; //2.申请 e1000_adv_tx_desc DMA 数组内存  &lt;br/&gt; tx_ring-&amp;gt;size = tx_ring-&amp;gt;count * sizeof(union e1000_adv_tx_desc);  &lt;br/&gt; tx_ring-&amp;gt;size = ALIGN(tx_ring-&amp;gt;size, 4096);  &lt;br/&gt; tx_ring-&amp;gt;desc = dma_alloc_coherent(dev, tx_ring-&amp;gt;size,  &lt;br/&gt;        &amp;amp;tx_ring-&amp;gt;dma, GFP_KERNEL);  &lt;br/&gt;  &lt;br/&gt; //3.初始化队列成员  &lt;br/&gt; tx_ring-&amp;gt;next_to_use = 0;  &lt;br/&gt; tx_ring-&amp;gt;next_to_clean = 0;  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述源码可以看到，实际上一个 RingBuffer 的内部不仅仅是一个环形队列数组，而是有两个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）igb_tx_buffer 数组：这个数组是内核使用的，通过 vzalloc 申请的。&lt;br/&gt;2）e1000_adv_tx_desc 数组：这个数组是网卡硬件使用的，硬件是可以通过 DMA 直接访问这块内存，通过 dma_alloc_coherent 分配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候它们之间还没有啥联系。将来在发送的时候，这两个环形数组中相同位置的指针将都将指向同一个 skb。这样，内核和硬件就能共同访问同样的数据了，内核往 skb 里写数据，网卡硬件负责发送。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNshNxj7ESgnlCGrw6pp71S9AmZKBZNzibib8HyZ5BMOlO1noHLCDImBUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4416243654822335&quot; data-w=&quot;591&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后调用 netif_tx_start_all_queues 开启队列。另外，对于硬中断的处理函数 igb_msix_ring 其实也是在 __igb_open 中注册的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、accept 创建新 socket&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在发送数据之前，我们往往还需要一个已经建立好连接的 socket。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们就以开篇服务器缩微源代码中提到的 accept 为例，当 accept 之后，进程会创建一个新的 socket 出来，然后把它放到当前进程的打开文件列表中，专门用于和对应的客户端通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设服务器进程通过 accept 和客户端建立了两条连接，我们来简单看一下这两条连接和进程的关联关系。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNf9vlJUUicDicIQQRX6Gm7sibzKTxeCPeXLkmNNszwdy512ny7LFmdYhXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3532219570405728&quot; data-w=&quot;838&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中代表一条连接的 socket 内核对象更为具体一点的结构图如下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNRlsujDHEyc56Miaicdz52ibMTZk9JRv6RH8ibk7ZoommWkyVic9jhl8NaJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7654155495978552&quot; data-w=&quot;746&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免喧宾夺主，accept 详细的源码过程这里就不介绍了，感兴趣请参考 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNjMxMTA5Mw==&amp;amp;mid=2651343800&amp;amp;idx=1&amp;amp;sn=eebe219df007e200a4b9a777b32f4c06&amp;amp;chksm=80f3b662b7843f743a65d22c437b9f5f80ec8ee79d1a3d8ecd637ab4b66c13d85326b135a9ee&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！》&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！》&lt;/a&gt;。一文中的第一部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们还是把重点放到数据发送过程上。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、发送数据真正开始&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 send 系统调用实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;send 系统调用的源码位于文件 net/socket.c 中。在这个系统调用里，内部其实真正使用的是 sendto 系统调用。整个调用链条虽然不短，但其实主要只干了两件简单的事情，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一是在内核中把真正的 socket 找出来，在这个对象里记录着各种协议栈的函数地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二是构造一个 struct msghdr 对象，把用户传入的数据，比如 buffer地址、数据长度啥的，统统都装进去.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;剩下的事情就交给下一层，协议栈里的函数 inet_sendmsg 了，其中 inet_sendmsg 函数的地址是通过 socket 内核对象里的 ops 成员找到的。大致流程如图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNVf6gq2hiawPInMbFBzuKPB0yediaicpl4nsKwicpYj4JUWFFPibXZzIGL5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6823956442831216&quot; data-w=&quot;551&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了上面的了解，我们再看起源码就要容易许多了。源码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/socket.c  &lt;br/&gt;SYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len,  &lt;br/&gt;  unsigned int, flags)  &lt;br/&gt;{  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; sys_sendto(fd, buff, len, flags, NULL, 0);  &lt;br/&gt;}  &lt;br/&gt;  &lt;br/&gt;SYSCALL_DEFINE6(......)  &lt;br/&gt;{  &lt;br/&gt; //1.根据 fd 查找到 socket  &lt;br/&gt; sock = sockfd_lookup_light(fd, &amp;amp;err, &amp;amp;fput_needed);  &lt;br/&gt;  &lt;br/&gt; //2.构造 msghdr  &lt;br/&gt; struct msghdr msg;  &lt;br/&gt; struct iovec iov;  &lt;br/&gt;  &lt;br/&gt; iov.iov_base = buff;  &lt;br/&gt; iov.iov_len = len;  &lt;br/&gt; msg.msg_iovlen = 1;  &lt;br/&gt;  &lt;br/&gt; msg.msg_iov = &amp;amp;iov;  &lt;br/&gt; msg.msg_flags = flags;  &lt;br/&gt; ......  &lt;br/&gt;  &lt;br/&gt; //3.发送数据  &lt;br/&gt; sock_sendmsg(sock, &amp;amp;msg, len);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从源码可以看到，我们在用户态使用的 send 函数和 sendto 函数其实都是 sendto 系统调用实现的。send 只是为了方便，封装出来的一个更易于调用的方式而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 sendto 系统调用里，首先根据用户传进来的 socket 句柄号来查找真正的 socket 内核对象。接着把用户请求的 buff、len、flag 等参数都统统打包到一个 struct msghdr 对象中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着调用了 sock_sendmsg =&amp;gt; __sock_sendmsg ==&amp;gt;  __sock_sendmsg_nosec。在__sock_sendmsg_nosec 中，调用将会由系统调用进入到协议栈，我们来看它的源码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/socket.c  &lt;br/&gt;static inline int __sock_sendmsg_nosec(...)  &lt;br/&gt;{  &lt;br/&gt; ......  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; sock-&amp;gt;ops-&amp;gt;sendmsg(iocb, sock, msg, size);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过第三节里的 socket 内核对象结构图，我们可以看到，这里调用的是 sock-&amp;gt;ops-&amp;gt;sendmsg 实际执行的是 inet_sendmsg。这个函数是 AF_INET 协议族提供的通用发送函数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 传输层处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1）传输层拷贝&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进入到协议栈 inet_sendmsg 以后，内核接着会找到 socket 上的具体协议发送函数。对于 TCP 协议来说，那就是 tcp_sendmsg（同样也是通过 socket 内核对象找到的）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个函数中，内核会申请一个内核态的 skb 内存，将用户待发送的数据拷贝进去。注意这个时候不一定会真正开始发送，如果没有达到发送条件的话很可能这次调用直接就返回了。大概过程如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZN02G9vIU8FIBvo1gkvLKQt1w8HBbupcpW28g7qmibEicVFbAISSnoP77g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.644808743169399&quot; data-w=&quot;549&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看 inet_sendmsg 函数的源码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/af_inet.c  &lt;br/&gt;int inet_sendmsg(......)  &lt;br/&gt;{  &lt;br/&gt; ......  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; sk-&amp;gt;sk_prot-&amp;gt;sendmsg(iocb, sk, msg, size);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个函数中会调用到具体协议的发送函数。同样参考第三节里的 socket 内核对象结构图，我们看到对于 TCP 协议下的 socket 来说，来说 sk-&amp;gt;sk_prot-&amp;gt;sendmsg 指向的是 tcp_sendmsg（对于 UPD 来说是 udp_sendmsg）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcp_sendmsg 这个函数比较长，我们分多次来看它。先看这一段&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/tcp.c  &lt;br/&gt;int tcp_sendmsg(...)  &lt;br/&gt;{  &lt;br/&gt; &lt;span&gt;while&lt;/span&gt;(...){  &lt;br/&gt;  &lt;span&gt;while&lt;/span&gt;(...){  &lt;br/&gt;   //获取发送队列  &lt;br/&gt;   skb = tcp_write_queue_tail(sk);  &lt;br/&gt;  &lt;br/&gt;   //申请skb 并拷贝  &lt;br/&gt;   ......  &lt;br/&gt;  }  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: include/net/tcp.h  &lt;br/&gt;static inline struct sk_buff *tcp_write_queue_tail(const struct sock *sk)  &lt;br/&gt;{  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; skb_peek_tail(&amp;amp;sk-&amp;gt;sk_write_queue);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解对 socket 调用 tcp_write_queue_tail 是理解发送的前提。如上所示，这个函数是在获取 socket 发送队列中的最后一个 skb。skb 是 struct sk_buff 对象的简称，用户的发送队列就是该对象组成的一个链表。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNNMPkROrRkYKc4Jsu6ibkFn4eWK4pNl2CUQMBOt2kKXic6PufZH4OObwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.17608695652173914&quot; data-w=&quot;460&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再接着看 tcp_sendmsg 的其它部分。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/tcp.c  &lt;br/&gt;int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,  &lt;br/&gt;  size_t size)  &lt;br/&gt;{  &lt;br/&gt; //获取用户传递过来的数据和标志  &lt;br/&gt; iov = msg-&amp;gt;msg_iov; //用户数据地址  &lt;br/&gt; iovlen = msg-&amp;gt;msg_iovlen; //数据块数为1  &lt;br/&gt; flags = msg-&amp;gt;msg_flags; //各种标志  &lt;br/&gt;  &lt;br/&gt; //遍历用户层的数据块  &lt;br/&gt; &lt;span&gt;while&lt;/span&gt; (--iovlen &amp;gt;= 0) {  &lt;br/&gt;  &lt;br/&gt;  //待发送数据块的地址  &lt;br/&gt;  unsigned char __user *from = iov-&amp;gt;iov_base;  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (seglen &amp;gt; 0) {  &lt;br/&gt;  &lt;br/&gt;   //需要申请新的 skb  &lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (copy &amp;lt;= 0) {  &lt;br/&gt;  &lt;br/&gt;    //申请 skb，并添加到发送队列的尾部  &lt;br/&gt;    skb = sk_stream_alloc_skb(sk,  &lt;br/&gt;         select_size(sk, sg),  &lt;br/&gt;         sk-&amp;gt;sk_allocation);  &lt;br/&gt;  &lt;br/&gt;    //把 skb 挂到socket的发送队列上  &lt;br/&gt;    skb_entail(sk, skb);  &lt;br/&gt;   }  &lt;br/&gt;  &lt;br/&gt;   // skb 中有足够的空间  &lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (skb_availroom(skb) &amp;gt; 0) {  &lt;br/&gt;    //拷贝用户空间的数据到内核空间，同时计算校验和  &lt;br/&gt;    //from是用户空间的数据地址   &lt;br/&gt;    skb_add_data_nocache(sk, skb, from, copy);  &lt;br/&gt;   }   &lt;br/&gt;   ......  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个函数比较长，不过其实逻辑并不复杂。其中 msg-&amp;gt;msg_iov 存储的是用户态内存的要发送的数据的 buffer。接下来在内核态申请内核内存，比如 skb，并把用户内存里的数据拷贝到内核态内存中。&lt;strong&gt;这就会涉及到一次或者几次内存拷贝的开销&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZN1Ueyic8TiaLVOjSsmdfCOHFtgcsdbhBuF2p9RxBA2Mj2nmeam2ba60BQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.27235772357723576&quot; data-w=&quot;492&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于内核什么时候真正把 skb 发送出去。在 tcp_sendmsg 中会进行一些判断。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/tcp.c  &lt;br/&gt;int tcp_sendmsg(...)  &lt;br/&gt;{  &lt;br/&gt; &lt;span&gt;while&lt;/span&gt;(...){  &lt;br/&gt;  &lt;span&gt;while&lt;/span&gt;(...){  &lt;br/&gt;   //申请内核内存并进行拷贝  &lt;br/&gt;  &lt;br/&gt;   //发送判断  &lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (forced_push(tp)) {  &lt;br/&gt;    tcp_mark_push(tp, skb);  &lt;br/&gt;    __tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);  &lt;br/&gt;   } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (skb == tcp_send_head(sk))  &lt;br/&gt;    tcp_push_one(sk, mss_now);    &lt;br/&gt;   }  &lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;;  &lt;br/&gt;  }  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有满足 forced_push(tp) 或者 skb == tcp_send_head(sk) 成立的时候，内核才会真正启动发送数据包。其中 forced_push(tp) 判断的是未发送的数据数据是否已经超过最大窗口的一半了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;条件都不满足的话，&lt;strong&gt;这次的用户要发送的数据只是拷贝到内核就算完事了！&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2）传输层发送&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设现在内核发送条件已经满足了，我们再来跟踪一下实际的发送过程。对于上小节函数中，当满足真正发送条件的时候，无论调用的是 __tcp_push_pending_frames 还是 tcp_push_one 最终都实际会执行到 tcp_write_xmit。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们直接从 tcp_write_xmit 看起，这个函数处理了传输层的拥塞控制、滑动窗口相关的工作。满足窗口要求的时候，设置一下 TCP 头然后将 skb 传到更低的网络层进行处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNmvAvBIicvqQ6wfzLVRuk7giaCnLDvpERYJ2CYeePictS7k1c4mT7tfccA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6118299445471349&quot; data-w=&quot;541&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下 tcp_write_xmit 的源码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/tcp_output.c  &lt;br/&gt;static bool tcp_write_xmit(struct sock *sk, unsigned int mss_now, int nonagle,  &lt;br/&gt;      int push_one, gfp_t gfp)  &lt;br/&gt;{  &lt;br/&gt; //循环获取待发送 skb  &lt;br/&gt; &lt;span&gt;while&lt;/span&gt; ((skb = tcp_send_head(sk)))   &lt;br/&gt; {  &lt;br/&gt;  //滑动窗口相关  &lt;br/&gt;  cwnd_quota = tcp_cwnd_test(tp, skb);  &lt;br/&gt;  tcp_snd_wnd_test(tp, skb, mss_now);  &lt;br/&gt;  tcp_mss_split_point(...);  &lt;br/&gt;  tso_fragment(sk, skb, ...);  &lt;br/&gt;  ......  &lt;br/&gt;  &lt;br/&gt;  //真正开启发送  &lt;br/&gt;  tcp_transmit_skb(sk, skb, 1, gfp);  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到我们之前在网络协议里学的滑动窗口、拥塞控制就是在这个函数中完成的，这部分就不过多展开了，感兴趣同学自己找这段源码来读。我们今天只看发送主过程，那就走到了 tcp_transmit_skb。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/tcp_output.c  &lt;br/&gt;static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,  &lt;br/&gt;    gfp_t gfp_mask)  &lt;br/&gt;{  &lt;br/&gt; //1.克隆新 skb 出来  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (likely(clone_it)) {  &lt;br/&gt;  skb = skb_clone(skb, gfp_mask);  &lt;br/&gt;  ......  &lt;br/&gt; }  &lt;br/&gt;  &lt;br/&gt; //2.封装 TCP 头  &lt;br/&gt; th = tcp_hdr(skb);  &lt;br/&gt; th-&amp;gt;&lt;span&gt;source&lt;/span&gt;  = inet-&amp;gt;inet_sport;  &lt;br/&gt; th-&amp;gt;dest  = inet-&amp;gt;inet_dport;  &lt;br/&gt; th-&amp;gt;window  = ...;  &lt;br/&gt; th-&amp;gt;urg   = ...;  &lt;br/&gt; ......  &lt;br/&gt;  &lt;br/&gt; //3.调用网络层发送接口  &lt;br/&gt; err = icsk-&amp;gt;icsk_af_ops-&amp;gt;queue_xmit(skb, &amp;amp;inet-&amp;gt;cork.fl);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一件事是先克隆一个新的 skb，这里重点说下为什么要复制一个 skb 出来呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是因为 skb 后续在调用网络层，最后到达网卡发送完成的时候，这个 skb 会被释放掉。而我们知道 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 skb 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 skb 的一个拷贝。等收到 ACK 再真正删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二件事是修改 skb 中的 TCP header，根据实际情况把 TCP 头设置好。这里要介绍一个小技巧，skb 内部其实包含了网络协议中所有的 header。在设置 TCP 头的时候，只是把指针指向 skb 的合适位置。后面再设置 IP 头的时候，在把指针挪一挪就行，避免频繁的内存申请和拷贝，效率很高。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNRqslNiblOrkbl9qQmlBLyDa20xUCALE5QsAlD7uyCOia0IChPZqUDP9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.23161764705882354&quot; data-w=&quot;544&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcp_transmit_skb 是发送数据位于传输层的最后一步，接下来就可以进入到网络层进行下一层的操作了。调用了网络层提供的发送接口icsk-&amp;gt;icsk_af_ops-&amp;gt;queue_xmit()。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下面的这个源码中，我们的知道了 queue_xmit 其实指向的是 ip_queue_xmit 函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/tcp_ipv4.c  &lt;br/&gt;const struct inet_connection_sock_af_ops ipv4_specific = {  &lt;br/&gt; .queue_xmit    = ip_queue_xmit,  &lt;br/&gt; .send_check    = tcp_v4_send_check,  &lt;br/&gt; ...  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自此，传输层的工作也就都完成了。数据离开了传输层，接下来将会进入到内核在网络层的实现里。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 网络层发送处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 内核网络层的发送的实现位于 net/ipv4/ip_output.c 这个文件。传输层调用到的 ip_queue_xmit 也在这里。（从文件名上也能看出来进入到 IP 层了，源文件名已经从 tcp_xxx 变成了 ip_xxx。）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在网络层里主要处理路由项查找、IP 头设置、netfilter 过滤、skb 切分（大于 MTU 的话）等几项工作，处理完这些工作后会交给更下层的邻居子系统来处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNHKljuAcgia19LTvD0E6gZT0KcSwD7XNV5rmSUib2icIqLPYrl6cicGPO0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7814113597246127&quot; data-w=&quot;581&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看网络层入口函数 ip_queue_xmit 的源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/ip_output.c  &lt;br/&gt;int ip_queue_xmit(struct sk_buff *skb, struct flowi *fl)  &lt;br/&gt;{  &lt;br/&gt; //检查 socket 中是否有缓存的路由表  &lt;br/&gt; rt = (struct rtable *)__sk_dst_check(sk, 0);  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (rt == NULL) {  &lt;br/&gt;  //没有缓存则展开查找  &lt;br/&gt;  //则查找路由项， 并缓存到 socket 中  &lt;br/&gt;  rt = ip_route_output_ports(...);  &lt;br/&gt;  sk_setup_caps(sk, &amp;amp;rt-&amp;gt;dst);  &lt;br/&gt; }  &lt;br/&gt;  &lt;br/&gt; //为 skb 设置路由表  &lt;br/&gt; skb_dst_set_noref(skb, &amp;amp;rt-&amp;gt;dst);  &lt;br/&gt;  &lt;br/&gt; //设置 IP header  &lt;br/&gt; iph = ip_hdr(skb);  &lt;br/&gt; iph-&amp;gt;protocol = sk-&amp;gt;sk_protocol;  &lt;br/&gt; iph-&amp;gt;ttl      = ip_select_ttl(inet, &amp;amp;rt-&amp;gt;dst);  &lt;br/&gt; iph-&amp;gt;frag_off = ...;  &lt;br/&gt;  &lt;br/&gt; //发送  &lt;br/&gt; ip_local_out(skb);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ip_queue_xmit 已经到了网络层，在这个函数里我们看到了网络层相关的功能路由项查找，如果找到了则设置到 skb 上（没有路由的话就直接报错返回了）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 上通过 route 命令可以看到你本机的路由配置。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNdr7Zib9CBF65ARWmR1v6V4PnTXbMDibNGicC3icd7iaLObnhqIIPzomcY2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.15364916773367476&quot; data-w=&quot;781&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在路由表中，可以查到某个目的网络应该通过哪个 Iface（网卡），哪个 Gateway（网卡）发送出去。查找出来以后缓存到 socket 上，下次再发送数据就不用查了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着把路由表地址也放到 skb 里去。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: include/linux/skbuff.h  &lt;br/&gt;struct sk_buff {  &lt;br/&gt; //保存了一些路由相关信息  &lt;br/&gt; unsigned long  _skb_refdst;  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来就是定位到 skb 里的 IP 头的位置上，然后开始按照协议规范设置 IP header。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNqIZkibKCHoqCAiapVUqdMrAryG98I9muj6CMkfvGu45rFOYcM3l27wTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.23161764705882354&quot; data-w=&quot;544&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再通过 ip_local_out 进入到下一步的处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/ip_output.c    &lt;br/&gt;int ip_local_out(struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; //执行 netfilter 过滤  &lt;br/&gt; err = __ip_local_out(skb);  &lt;br/&gt;  &lt;br/&gt; //开始发送数据  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (likely(err == 1))  &lt;br/&gt; &amp;amp;nbsnbsp;err = dst_output(skb);  &lt;br/&gt; ......  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ip_local_out =&amp;gt; __ip_local_out =&amp;gt; nf_hook 会执行 netfilter 过滤。如果你使用 iptables 配置了一些规则，那么这里将检测是否命中规则。&lt;strong&gt;如果你设置了非常复杂的 netfilter 规则，在这个函数这里将会导致你的进程 CPU 开销会极大增加&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是不多展开说，继续只聊和发送有关的过程 dst_output。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: include/net/dst.h  &lt;br/&gt;static inline int dst_output(struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; skb_dst(skb)-&amp;gt;output(skb);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此函数找到到这个 skb 的路由表（dst 条目） ，然后调用路由表的 output 方法。这又是一个函数指针，指向的是 ip_output 方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/ip_output.c  &lt;br/&gt;int ip_output(struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; //统计  &lt;br/&gt; .....  &lt;br/&gt;  &lt;br/&gt; //再次交给 netfilter，完毕后回调 ip_finish_output  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING, skb, NULL, dev,  &lt;br/&gt;    ip_finish_output,  &lt;br/&gt;    !(IPCB(skb)-&amp;gt;flags &amp;amp; IPSKB_REROUTED));  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ip_output 中进行一些简单的，统计工作，再次执行 netfilter 过滤。过滤通过之后回调 ip_finish_output。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/ip_output.c  &lt;br/&gt;static int ip_finish_output(struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; //大于 mtu 的话就要进行分片了  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (skb-&amp;gt;len &amp;gt; ip_skb_dst_mtu(skb) &amp;amp;&amp;amp; !skb_is_gso(skb))  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ip_fragment(skb, ip_finish_output2);  &lt;br/&gt; &lt;span&gt;else&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ip_finish_output2(skb);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ip_finish_output 中我们看到，&lt;strong&gt;如果数据大于 MTU 的话，是会执行分片的。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实际 MTU 大小确定依赖 MTU 发现，以太网帧为 1500 字节。之前 QQ 团队在早期的时候，会尽量控制自己数据包尺寸小于 MTU，通过这种方式来优化网络性能。因为分片会带来两个问题：1、需要进行额外的切分处理，有额外性能开销。2、只要一个分片丢失，整个包都得重传。所以避免分片既杜绝了分片开销，也大大降低了重传率。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ip_finish_output2 中，终于发送过程会进入到下一层，邻居子系统中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/ip_output.c  &lt;br/&gt;static inline int ip_finish_output2(struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; //根据下一跳 IP 地址查找邻居项，找不到就创建一个  &lt;br/&gt; nexthop = (__force u32) rt_nexthop(rt, ip_hdr(skb)-&amp;gt;daddr);    &lt;br/&gt; neigh = __ipv4_neigh_lookup_noref(dev, nexthop);  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (unlikely(!neigh))  &lt;br/&gt;  neigh = __neigh_create(&amp;amp;arp_tbl, &amp;amp;nexthop, dev, &lt;span&gt;false&lt;/span&gt;);  &lt;br/&gt;  &lt;br/&gt; //继续向下层传递  &lt;br/&gt; int res = dst_neigh_output(dst, neigh, skb);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 邻居子系统&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;邻居子系统是位于网络层和数据链路层中间的一个系统，其作用是对网络层提供一个封装，让网络层不必关心下层的地址信息，让下层来决定发送到哪个 MAC 地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且这个邻居子系统并不位于协议栈 net/ipv4/ 目录内，而是位于 net/core/neighbour.c。因为无论是对于 IPv4 还是 IPv6 ，都需要使用该模块。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNJZBziacZ2g4pYHa8A4TFHnfumx1Tmz21BrRnVMmhAWmCP9wr9JYUtog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3197278911564626&quot; data-w=&quot;441&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在邻居子系统里主要是查找或者创建邻居项，在创造邻居项的时候，有可能会发出实际的 arp 请求。然后封装一下 MAC 头，将发送过程再传递到更下层的网络设备子系统。大致流程如图。&lt;br/&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNL6qiaV60wqwUvibIQpj5vic8vNREQq1jTEwhOdn5zzN5YedSmiccaUFXNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5690184049079755&quot; data-w=&quot;652&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了大致流程，我们再回头看源码。在上面小节 ip_finish_output2 源码中调用了 __ipv4_neigh_lookup_noref。它是在 arp 缓存中进行查找，其第二个参数传入的是路由下一跳 IP 信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: include/net/arp.h  &lt;br/&gt;extern struct neigh_table arp_tbl;  &lt;br/&gt;static inline struct neighbour *__ipv4_neigh_lookup_noref(  &lt;br/&gt; struct net_device *dev, u32 key)  &lt;br/&gt;{  &lt;br/&gt; struct neigh_hash_table *nht = rcu_dereference_bh(arp_tbl.nht);  &lt;br/&gt;  &lt;br/&gt; //计算 &lt;span&gt;hash&lt;/span&gt; 值，加速查找  &lt;br/&gt; hash_val = arp_hashfn(......);  &lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (n = rcu_dereference_bh(nht-&amp;gt;hash_buckets[hash_val]);  &lt;br/&gt;   n != NULL;  &lt;br/&gt;   n = rcu_dereference_bh(n-&amp;gt;next)) {  &lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (n-&amp;gt;dev == dev &amp;amp;&amp;amp; *(u32 *)n-&amp;gt;primary_key == key)  &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; n;  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果查找不到，则调用 __neigh_create 创建一个邻居。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/neighbour.c  &lt;br/&gt;struct neighbour *__neigh_create(......)  &lt;br/&gt;{  &lt;br/&gt; //申请邻居表项  &lt;br/&gt; struct neighbour *n1, *rc, *n = neigh_alloc(tbl, dev);  &lt;br/&gt;  &lt;br/&gt; //构造赋值  &lt;br/&gt; memcpy(n-&amp;gt;primary_key, pkey, key_len);  &lt;br/&gt; n-&amp;gt;dev = dev;  &lt;br/&gt; n-&amp;gt;parms-&amp;gt;neigh_setup(n);  &lt;br/&gt;  &lt;br/&gt; //最后添加到邻居 hashtable 中  &lt;br/&gt; rcu_assign_pointer(nht-&amp;gt;hash_buckets[hash_val], n);  &lt;br/&gt; ......  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了邻居项以后，此时仍然还不具备发送 IP 报文的能力，因为目的 MAC 地址还未获取。调用 dst_neigh_output 继续传递 skb。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: include/net/dst.h  &lt;br/&gt;static inline int dst_neigh_output(struct dst_entry *dst,   &lt;br/&gt;     struct neighbour *n, struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; ......  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; n-&amp;gt;output(n, skb);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用 output，实际指向的是 neigh_resolve_output。在这个函数内部有可能会发出 arp 网络请求。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/neighbour.c  &lt;br/&gt;int &lt;span&gt;&lt;span&gt;neigh_resolve_output&lt;/span&gt;&lt;/span&gt;(){  &lt;br/&gt;  &lt;br/&gt; //注意：这里可能会触发 arp 请求  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!neigh_event_send(neigh, skb)) {  &lt;br/&gt;  &lt;br/&gt;  //neigh-&amp;gt;ha 是 MAC 地址  &lt;br/&gt;  dev_hard_header(skb, dev, ntohs(skb-&amp;gt;protocol),  &lt;br/&gt;           neigh-&amp;gt;ha, NULL, skb-&amp;gt;len);  &lt;br/&gt;  //发送  &lt;br/&gt;  dev_queue_xmit(skb);  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当获取到硬件 MAC 地址以后，就可以封装 skb 的 MAC 头了。最后调用 dev_queue_xmit 将 skb 传递给 Linux 网络设备子系统。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.5 网络设备子系统&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNWlqeL1lcN9nsJ7J4cX1v3yYPYED4gV6uyBBlpwfCFDzPp3abYrT47Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7246127366609294&quot; data-w=&quot;581&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;邻居子系统通过 dev_queue_xmit 进入到网络设备子系统中来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/dev.c   &lt;br/&gt;int dev_queue_xmit(struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; //选择发送队列  &lt;br/&gt; txq = netdev_pick_tx(dev, skb);  &lt;br/&gt;  &lt;br/&gt; //获取与此队列关联的排队规则  &lt;br/&gt; q = rcu_dereference_bh(txq-&amp;gt;qdisc);  &lt;br/&gt;  &lt;br/&gt; //如果有队列，则调用__dev_xmit_skb 继续处理数据  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (q-&amp;gt;enqueue) {  &lt;br/&gt;  rc = __dev_xmit_skb(skb, q, dev, txq);  &lt;br/&gt;  goto out;  &lt;br/&gt; }  &lt;br/&gt;  &lt;br/&gt; //没有队列的是回环设备和隧道设备  &lt;br/&gt; ......  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开篇第二节网卡启动准备里我们说过，网卡是有多个发送队列的（尤其是现在的网卡）。上面对 netdev_pick_tx 函数的调用就是选择一个队列进行发送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;netdev_pick_tx 发送队列的选择受 XPS 等配置的影响，而且还有缓存，也是一套小复杂的逻辑。这里我们只关注两个逻辑，首先会获取用户的 XPS 配置，否则就自动计算了。代码见 netdev_pick_tx =&amp;gt; __netdev_pick_tx。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/flow_dissector.c  &lt;br/&gt;u16 __netdev_pick_tx(struct net_device *dev, struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; //获取 XPS 配置  &lt;br/&gt; int new_index = get_xps_queue(dev, skb);  &lt;br/&gt;  &lt;br/&gt; //自动计算队列  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (new_index &amp;lt; 0)  &lt;br/&gt;  new_index = skb_tx_hash(dev, skb);}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后获取与此队列关联的 qdisc。在 linux 上通过 tc 命令可以看到 qdisc 类型，例如对于我的某台多队列网卡机器上是 mq disc。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#tc qdisc  &lt;/span&gt;&lt;br/&gt;qdisc mq 0: dev eth0 root  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分的设备都有队列（回环设备和隧道设备除外），所以现在我们进入到 __dev_xmit_skb。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/dev.c  &lt;br/&gt;static inline int __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,  &lt;br/&gt;     struct net_device *dev,  &lt;br/&gt;     struct netdev_queue *txq)  &lt;br/&gt;{  &lt;br/&gt; //1.如果可以绕开排队系统  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; ((q-&amp;gt;flags &amp;amp; TCQ_F_CAN_BYPASS) &amp;amp;&amp;amp; !qdisc_qlen(q) &amp;amp;&amp;amp;  &lt;br/&gt;     qdisc_run_begin(q)) {  &lt;br/&gt;  ......  &lt;br/&gt; }  &lt;br/&gt;  &lt;br/&gt; //2.正常排队  &lt;br/&gt; &lt;span&gt;else&lt;/span&gt; {  &lt;br/&gt;  &lt;br/&gt;  //入队  &lt;br/&gt;  q-&amp;gt;enqueue(skb, q)  &lt;br/&gt;  &lt;br/&gt;  //开始发送  &lt;br/&gt;  __qdisc_run(q);  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述代码中分两种情况，1 是可以 bypass（绕过）排队系统的，另外一种是正常排队。我们只看第二种情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先调用 q-&amp;gt;enqueue 把 skb 添加到队列里。然后调用 __qdisc_run 开始发送。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/&lt;span&gt;sched&lt;/span&gt;/sch_generic.c  &lt;br/&gt;void __qdisc_run(struct Qdisc *q)  &lt;br/&gt;{  &lt;br/&gt; int quota = weight_p;  &lt;br/&gt;  &lt;br/&gt; //循环从队列取出一个 skb 并发送  &lt;br/&gt; &lt;span&gt;while&lt;/span&gt; (qdisc_restart(q)) {  &lt;br/&gt;    &lt;br/&gt;  // 如果发生下面情况之一，则延后处理：  &lt;br/&gt;  // 1. quota 用尽  &lt;br/&gt;  // 2. 其他进程需要 CPU  &lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (--quota &amp;lt;= 0 || need_resched()) {  &lt;br/&gt;   //将触发一次 NET_TX_SOFTIRQ 类型 softirq  &lt;br/&gt;   __netif_schedule(q);  &lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;;  &lt;br/&gt;  }  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述代码中，我们看到 while 循环不断地从队列中取出 skb 并进行发送。注意，这个时候其实都占用的是用户进程的系统态时间(sy)。只有当 quota 用尽或者其它进程需要 CPU 的时候才触发软中断进行发送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以这就是为什么一般服务器上查看 /proc/softirqs，一般 NET_RX 都要比 NET_TX 大的多的第二个原因&lt;/strong&gt;。对于读来说，都是要经过 NET_RX 软中断，而对于发送来说，只有系统态配额用尽才让软中断上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来把精力在放到 qdisc_restart 上，继续看发送过程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;static inline int qdisc_restart(struct Qdisc *q)  &lt;br/&gt;{  &lt;br/&gt; //从 qdisc 中取出要发送的 skb  &lt;br/&gt; skb = dequeue_skb(q);  &lt;br/&gt; ...  &lt;br/&gt;  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; sch_direct_xmit(skb, q, dev, txq, root_lock);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;qdisc_restart 从队列中取出一个 skb，并调用 sch_direct_xmit 继续发送。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/&lt;span&gt;sched&lt;/span&gt;/sch_generic.c  &lt;br/&gt;int sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q,  &lt;br/&gt;   struct net_device *dev, struct netdev_queue *txq,  &lt;br/&gt;   spinlock_t *root_lock)  &lt;br/&gt;{  &lt;br/&gt; //调用驱动程序来发送数据  &lt;br/&gt; ret = dev_hard_start_xmit(skb, dev, txq);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.6 软中断调度&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 4.5 咱们看到了如果系统态 CPU 发送网络包不够用的时候，会调用 __netif_schedule 触发一个软中断。该函数会进入到 __netif_reschedule，由它来实际发出 NET_TX_SOFTIRQ 类型软中断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软中断是由内核线程来运行的，该线程会进入到 net_tx_action 函数，在该函数中能获取到发送队列，并也最终调用到驱动程序里的入口函数 dev_hard_start_xmit。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNYsGqxicD45mB3SES9U7W7noexasRKmqKsFnZbSk0YOXOMBEXU1sI1hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.8336106489184693&quot; data-w=&quot;601&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/dev.c  &lt;br/&gt;static inline void __netif_reschedule(struct Qdisc *q)  &lt;br/&gt;{  &lt;br/&gt; sd = &amp;amp;__get_cpu_var(softnet_data);  &lt;br/&gt; q-&amp;gt;next_sched = NULL;  &lt;br/&gt; *sd-&amp;gt;output_queue_tailp = q;  &lt;br/&gt; sd-&amp;gt;output_queue_tailp = &amp;amp;q-&amp;gt;next_sched;  &lt;br/&gt;  &lt;br/&gt; ......  &lt;br/&gt; raise_softirq_irqoff(NET_TX_SOFTIRQ);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在该函数里在软中断能访问到的 softnet_data 里设置了要发送的数据队列，添加到了 output_queue 里了。紧接着触发了 NET_TX_SOFTIRQ 类型的软中断。（T 代表 transmit 传输）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软中断的入口代码我这里也不详细扒了，感兴趣的同学&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666548640&amp;amp;idx=1&amp;amp;sn=7e6dcbbcd569ad4f3c20e915b78b3bac&amp;amp;chksm=80dc890bb7ab001d4cd880c773b3e7b3b9ee4d7d9d4fac0ebbeaa6d247c70084d8cde829bcf2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《图解Linux网络包接收过程》&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《图解Linux网络包接收过程》&lt;/a&gt;&lt;span&gt;参考&lt;/span&gt;&lt;span&gt;一&lt;/span&gt;&lt;span&gt;文&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;小&lt;/span&gt;&lt;span&gt;节&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;- k&lt;/span&gt;&lt;span&gt;so&lt;/span&gt;&lt;span&gt;ft&lt;/span&gt;&lt;span&gt;irqd&lt;/span&gt;&lt;span&gt;内核&lt;/span&gt;&lt;span&gt;线&lt;/span&gt;&lt;span&gt;程处&lt;/span&gt;&lt;span&gt;理&lt;/span&gt;&lt;span&gt;软&lt;/span&gt;&lt;span&gt;中断。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们直接从 NET_TX_SOFTIRQ softirq 注册的回调函数 net_tx_action讲起。用户态进程触发完软中断之后，会有一个软中断内核线程会执行到 net_tx_action。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;牢记，这以后发送数据消耗的 CPU 就都显示在 si 这里了，不会消耗用户进程的系统时间了&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/dev.c  &lt;br/&gt;static void net_tx_action(struct softirq_action *h)  &lt;br/&gt;{  &lt;br/&gt; //通过 softnet_data 获取发送队列  &lt;br/&gt; struct softnet_data *sd = &amp;amp;__get_cpu_var(softnet_data);  &lt;br/&gt;  &lt;br/&gt; // 如果 output queue 上有 qdisc  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (sd-&amp;gt;output_queue) {  &lt;br/&gt;  &lt;br/&gt;  // 将 head 指向第一个 qdisc  &lt;br/&gt;  head = sd-&amp;gt;output_queue;  &lt;br/&gt;  &lt;br/&gt;  //遍历 qdsics 列表  &lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (head) {  &lt;br/&gt;   struct Qdisc *q = head;  &lt;br/&gt;   head = head-&amp;gt;next_sched;  &lt;br/&gt;  &lt;br/&gt;   //发送数据  &lt;br/&gt;   qdisc_run(q);  &lt;br/&gt;  }  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软中断这里会获取 softnet_data。前面我们看到进程内核态在调用 __netif_reschedule 的时候把发送队列写到 softnet_data 的 output_queue 里了。软中断循环遍历 sd-&amp;gt;output_queue 发送数据帧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看 qdisc_run，它和进程用户态一样，也会调用到 __qdisc_run。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: include/net/pkt_sched.h  &lt;br/&gt;static inline void qdisc_run(struct Qdisc *q)  &lt;br/&gt;{  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (qdisc_run_begin(q))  &lt;br/&gt;  __qdisc_run(q);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后一样就是进入 qdisc_restart =&amp;gt; sch_direct_xmit，直到驱动程序函数 dev_hard_start_xmit。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.7 igb 网卡驱动发送&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们前面看到，无论是对于用户进程的内核态，还是对于软中断上下文，都会调用到网络设备子系统中的 dev_hard_start_xmit 函数。在这个函数中，会调用到驱动里的发送函数 igb_xmit_frame。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在驱动函数里，将 skb 会挂到 RingBuffer上，驱动调用完毕后，数据包将真正从网卡发送出去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNCibicYkezt2Mz8oaq1DWJuPEcGPHn0XLKtAGHmm75GoAIg6hUlxJXJlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9139414802065404&quot; data-w=&quot;581&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看看实际的源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/dev.c  &lt;br/&gt;int dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev,  &lt;br/&gt;   struct netdev_queue *txq)  &lt;br/&gt;{  &lt;br/&gt; //获取设备的回调函数集合 ops  &lt;br/&gt; const struct net_device_ops *ops = dev-&amp;gt;netdev_ops;  &lt;br/&gt;  &lt;br/&gt; //获取设备支持的功能列表  &lt;br/&gt; features = netif_skb_features(skb);  &lt;br/&gt;  &lt;br/&gt; //调用驱动的 ops 里面的发送回调函数 ndo_start_xmit 将数据包传给网卡设备  &lt;br/&gt; skb_len = skb-&amp;gt;len;  &lt;br/&gt; rc = ops-&amp;gt;ndo_start_xmit(skb, dev);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 ndo_start_xmit 是网卡驱动要实现的一个函数，是在 net_device_ops 中定义的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: include/linux/netdevice.h  &lt;br/&gt;struct net_device_ops {  &lt;br/&gt; netdev_tx_t  (*ndo_start_xmit) (struct sk_buff *skb,  &lt;br/&gt;         struct net_device *dev);  &lt;br/&gt;  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 igb 网卡驱动源码中，我们找到了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static const struct net_device_ops igb_netdev_ops = {  &lt;br/&gt; .ndo_open  = igb_open,  &lt;br/&gt; .ndo_stop  = igb_close,  &lt;br/&gt; .ndo_start_xmit  = igb_xmit_frame,   &lt;br/&gt; ...  &lt;br/&gt;};  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，对于网络设备层定义的 ndo_start_xmit， igb 的实现函数是 igb_xmit_frame。这个函数是在网卡驱动初始化的时候被赋值的。具体初始化过程参见&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666548640&amp;amp;idx=1&amp;amp;sn=7e6dcbbcd569ad4f3c20e915b78b3bac&amp;amp;chksm=80dc890bb7ab001d4cd880c773b3e7b3b9ee4d7d9d4fac0ebbeaa6d247c70084d8cde829bcf2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《图解Linux网络包接收过程》&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《图解Linux网络包接收过程》&lt;/a&gt;一文中的 2.4 节，网卡驱动初始化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在上面网络设备层调用 ops-&amp;gt;ndo_start_xmit 的时候，会实际上进入 igb_xmit_frame 这个函数中。我们进入这个函数来看看驱动程序是如何工作的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static netdev_tx_t igb_xmit_frame(struct sk_buff *skb,  &lt;br/&gt;      struct net_device *netdev)  &lt;br/&gt;{  &lt;br/&gt; ......  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; igb_xmit_frame_ring(skb, igb_tx_queue_mapping(adapter, skb));  &lt;br/&gt;}  &lt;br/&gt;  &lt;br/&gt;netdev_tx_t igb_xmit_frame_ring(struct sk_buff *skb,  &lt;br/&gt;    struct igb_ring *tx_ring)  &lt;br/&gt;{  &lt;br/&gt; //获取TX Queue 中下一个可用缓冲区信息  &lt;br/&gt; first = &amp;amp;tx_ring-&amp;gt;tx_buffer_info[tx_ring-&amp;gt;next_to_use];  &lt;br/&gt; first-&amp;gt;skb = skb;  &lt;br/&gt; first-&amp;gt;bytecount = skb-&amp;gt;len;  &lt;br/&gt; first-&amp;gt;gso_segs = 1;  &lt;br/&gt;  &lt;br/&gt; //igb_tx_map 函数准备给设备发送的数据。  &lt;br/&gt; igb_tx_map(tx_ring, first, hdr_len);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里从网卡的发送队列的 RingBuffer 中取下来一个元素，并将 skb 挂到元素上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNwYLpPquCuztmAAqmcV41gzMST63ovYfoD96CgPcBArWJTI1D0nwBEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.25277161862527714&quot; data-w=&quot;451&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;igb_tx_map 函数处理将 skb 数据映射到网卡可访问的内存 DMA 区域。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static void igb_tx_map(struct igb_ring *tx_ring,  &lt;br/&gt;      struct igb_tx_buffer *first,  &lt;br/&gt;      const u8 hdr_len)  &lt;br/&gt;{  &lt;br/&gt; //获取下一个可用描述符指针  &lt;br/&gt; tx_desc = IGB_TX_DESC(tx_ring, i);  &lt;br/&gt;  &lt;br/&gt; //为 skb-&amp;gt;data 构造内存映射，以允许设备通过 DMA 从 RAM 中读取数据  &lt;br/&gt; dma = dma_map_single(tx_ring-&amp;gt;dev, skb-&amp;gt;data, size, DMA_TO_DEVICE);  &lt;br/&gt;  &lt;br/&gt; //遍历该数据包的所有分片,为 skb 的每个分片生成有效映射  &lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (frag = &amp;amp;skb_shinfo(skb)-&amp;gt;frags[0];; frag++) {  &lt;br/&gt;  &lt;br/&gt;  tx_desc-&amp;gt;read.buffer_addr = cpu_to_le64(dma);  &lt;br/&gt;  tx_desc-&amp;gt;read.cmd_type_len = ...;  &lt;br/&gt;  tx_desc-&amp;gt;read.olinfo_status = 0;  &lt;br/&gt; }  &lt;br/&gt;  &lt;br/&gt; //设置最后一个descriptor  &lt;br/&gt; cmd_type |= size | IGB_TXD_DCMD;  &lt;br/&gt; tx_desc-&amp;gt;read.cmd_type_len = cpu_to_le32(cmd_type);  &lt;br/&gt;  &lt;br/&gt; /* Force memory writes to complete before letting h/w know there  &lt;br/&gt;  * are new descriptors to fetch  &lt;br/&gt;  */  &lt;br/&gt; wmb();  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当所有需要的描述符都已建好，且 skb 的所有数据都映射到 DMA 地址后，驱动就会进入到它的最后一步，触发真实的发送。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.8 发送完成硬中断&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当数据发送完成以后，其实工作并没有结束。因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666548640&amp;amp;idx=1&amp;amp;sn=7e6dcbbcd569ad4f3c20e915b78b3bac&amp;amp;chksm=80dc890bb7ab001d4cd880c773b3e7b3b9ee4d7d9d4fac0ebbeaa6d247c70084d8cde829bcf2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《图解Linux网络包接收过程》&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《图解Linux网络包接收过程》&lt;/a&gt; 一文中的 3.1 和 3.2 小节，我们详细讲述过硬中断和软中断的处理过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在发送完成硬中断里，会执行 RingBuffer 内存的清理工作，如图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNvsEmEtnv3YYBYMib8fLSyw8dm6kcZP77zdFWymvg4u8SBs9ttGTAeZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6867469879518072&quot; data-w=&quot;581&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再回头看一下硬中断触发软中断的源码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static inline void ____napi_schedule(...){  &lt;br/&gt; list_add_tail(&amp;amp;napi-&amp;gt;poll_list, &amp;amp;sd-&amp;gt;poll_list);  &lt;br/&gt; __raise_softirq_irqoff(NET_RX_SOFTIRQ);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个很有意思的细节，无论硬中断是因为是有数据要接收，还是说发送完成通知，&lt;strong&gt;从硬中断触发的软中断都是 NET_RX_SOFTIRQ&lt;/strong&gt;。这个我们在第一节说过了，这是软中断统计中 RX 要高于 TX 的一个原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好我们接着进入软中断的回调函数 igb_poll。在这个函数里，我们注意到有一行 igb_clean_tx_irq，参见源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static int igb_poll(struct napi_struct *napi, int budget)  &lt;br/&gt;{  &lt;br/&gt; //performs the transmit completion operations  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (q_vector-&amp;gt;tx.ring)  &lt;br/&gt;  clean_complete = igb_clean_tx_irq(q_vector);  &lt;br/&gt; ...  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看看当传输完成的时候，igb_clean_tx_irq 都干啥了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static bool igb_clean_tx_irq(struct igb_q_vector *q_vector)  &lt;br/&gt;{  &lt;br/&gt; //free the skb  &lt;br/&gt; dev_kfree_skb_any(tx_buffer-&amp;gt;skb);  &lt;br/&gt;  &lt;br/&gt; //clear tx_buffer data  &lt;br/&gt; tx_buffer-&amp;gt;skb = NULL;  &lt;br/&gt; dma_unmap_len_set(tx_buffer, len, 0);  &lt;br/&gt;  &lt;br/&gt; // clear last DMA location and unmap remaining buffers */  &lt;br/&gt; &lt;span&gt;while&lt;/span&gt; (tx_desc != eop_desc) {  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无非就是清理了 skb，解除了 DMA 映射等等。到了这一步，传输才算是基本完成了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为啥我说是基本完成，而不是全部完成了呢？因为传输层需要保证可靠性，所以 skb 其实还没有删除。它得等收到对方的 ACK 之后才会真正删除，那个时候才算是彻底的发送完毕。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一张图总结一下整个发送过程&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNC00DTfspwPMWXLjTYWB23MPL7Uz1TsDhgdsdOF920V4GqZwJyZs8gg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.4696673189823874&quot; data-w=&quot;511&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了整个发送过程以后，我们回头再来回顾开篇提到的几个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.我们在监控内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在网络包的发送过程中，用户进程（在内核态）完成了绝大部分的工作，甚至连调用驱动的事情都干了。只有当内核态进程被切走前才会发起软中断。发送过程中，绝大部分（90%）以上的开销都是在用户进程内核态消耗掉的。只&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一少部分情况下才会触发软中断（NET_TX 类型），由软中断 ksoftirqd 内核进程来发送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在监控网络 IO 对服务器造成的 CPU 开销的时候，不能仅仅只看 si，而是应该把 si、sy 都考虑进来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2. 在服务器上查看 /proc/softirqs，为什么 NET_RX 要比 NET_TX 大的多的多？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我认为 NET_RX 是读取，NET_TX 是传输。对于一个既收取用户请求，又给用户返回的 Server 来说。这两块的数字应该差不多才对，至少不会有数量级的差异。但事实上，飞哥手头的一台服务器是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNyMmfBRBc22wSuW4caOVsZeiaBticLr9tXeRZibyav6AylEwzWibmHUv6RA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4419889502762431&quot; data-w=&quot;543&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过今天的源码分析，发现这个问题的原因有两个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个原因是当数据发送完成以后，通过硬中断的方式来通知驱动发送完毕。但是硬中断无论是有数据接收，还是对于发送完毕，触发的软中断都是 NET_RX_SOFTIRQ，而并不是 NET_TX_SOFTIRQ。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个原因是对于读来说，都是要经过 NET_RX 软中断的，都走 ksoftirqd 内核进程。而对于发送来说，绝大部分工作都是在用户进程内核态处理了，只有系统态配额用尽才会发出 NET_TX，让软中断上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上两个原因，那么在机器上查看 NET_RX 比 NET_TX 大的多就不难理解了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.发送网络数据的时候都涉及到哪些内存拷贝操作？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的内存拷贝，我们只特指待发送数据的内存拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次拷贝操作是内核申请完 skb 之后，这时候会将用户传递进来的 buffer 里的数据内容都拷贝到 skb 中。如果要发送的数据量比较大的话，这个拷贝操作开销还是不小的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二次拷贝操作是从传输层进入网络层的时候，每一个 skb 都会被克隆一个新的副本出来。网络层以及下面的驱动、软中断等组件在发送完成的时候会将这个副本删除。传输层保存着原始的 skb，在当网络对方没有 ack 的时候，还可以重新发送，以实现 TCP 中要求的可靠传输。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三次拷贝不是必须的，只有当 IP 层发现 skb 大于 MTU 时才需要进行。会再申请额外的 skb，并将原来的 skb 拷贝为多个小的 skb。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里插入个题外话，大家在网络性能优化中经常听到的零拷贝，我觉得这有点点夸张的成分。TCP 为了保证可靠性，第二次的拷贝根本就没法省。如果包再大于 MTU 的话，分片时的拷贝同样也避免不了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，相信内核发送数据包对于你来说，已经不再是一个完全不懂的黑盒了。本文哪怕你只看懂十分之一，你也已经掌握了这个黑盒的打开方式。这在你将来优化网络性能时你就会知道从哪儿下手了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>21484c824da3ebc3ee739666254b1e1a</guid>
<title>从源码角度研究 Java 动态代理</title>
<link>https://toutiao.io/k/uq1g9e6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBUjjhibDYY3cmoaeFQic49V1CKkdiaJkrUORUp32TicCwosMhcn0xVlyLibg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近，看了一下关于RMI(Remote Method Invocation)相关的知识，遇到了一个动态代理的问题，然后就决定探究一下动态代理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里先科普一下RMI。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RMI&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像我们平时写的程序，对象之间互相调用方法都是在同一个JVM中进行，而RMI可以实现一个JVM上的对象调用另一个JVM上对象的方法，即远程调用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;接口定义&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义一个远程对象接口，实现Remote接口来进行标记。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;UserInterface&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Remote&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; RemoteException&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;远程对象定义&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义一个远程对象类，继承UnicastRemoteObject来实现Serializable和Remote接口，并实现接口方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;UnicastRemoteObject&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;UserInterface&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;User&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; RemoteException &lt;/span&gt;{}&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;服务端&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动服务端，将user对象在注册表上进行注册。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RmiServer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; RemoteException, AlreadyBoundException, MalformedURLException &lt;/span&gt;{&lt;br/&gt;        User user = &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;        LocateRegistry.createRegistry(&lt;span&gt;8888&lt;/span&gt;);&lt;br/&gt;        Naming.bind(&lt;span&gt;&quot;rmi://127.0.0.1:8888/user&quot;&lt;/span&gt;, user);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;rmi server is starting...&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动服务端：&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBSibicduTBlGicqFqg3H9rVG26yzJ6PFa2vxwmibRQOVXqTpnVEKowZmsibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3333333333333333&quot; data-w=&quot;672&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;客户端&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从服务端注册表获取远程对象，在服务端调用sayHello()方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RmiClient&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; RemoteException, NotBoundException, MalformedURLException &lt;/span&gt;{&lt;br/&gt;        UserInterface user = (UserInterface) Naming.lookup(&lt;span&gt;&quot;rmi://127.0.0.1:8888/user&quot;&lt;/span&gt;);&lt;br/&gt;        user.sayHello();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端运行结果：&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBlm20Dow5wTQK32RtglHqIFmeBlxB2zoOPWia3CfMndO1ib0KNZibQIib5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.23201856148491878&quot; data-w=&quot;862&quot;/&gt;至此，一个简单的RMI demo完成。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;动态代理&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;提出问题&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了看RMI代码，觉得UserInterface这个接口有点多余，如果客户端使用Naming.lookup()获取的对象不强转成UserInterface，直接强转成User是不是也可以，于是试了一下，就报了以下错误：&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBs2pBw2aAKHLG2M8rPaetlc1euxvAdsq9BYg1XkSE91rotnJVgian5Ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.05462962962962963&quot; data-w=&quot;1080&quot;/&gt;似曾相识又有点陌生的$Proxy0，翻了翻尘封的笔记找到了是动态代理的知识点，寥寥几笔带过，所以决定梳理一下动态代理，重新整理一份笔记。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;动态代理Demo&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;接口定义&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;UserInterface&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;真实角色定义&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;UserInterface&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;调用处理类定义&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代理类调用真实角色的方法时，其实是调用与真实角色绑定的处理类对象的invoke()方法，而invoke()调用的是真实角色的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要实现 &lt;span&gt;InvocationHandler&lt;/span&gt; 接口以及invoke()方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserHandler&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InvocationHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; User user;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;UserProxy&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.user = user;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;invoke&lt;/span&gt;&lt;span&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;invoking start....&quot;&lt;/span&gt;);&lt;br/&gt;        method.invoke(user);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;invoking stop....&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;执行类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        User user = &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;        &lt;span&gt;// 处理类和真实角色绑定&lt;/span&gt;&lt;br/&gt;        UserHandler userHandler = &lt;span&gt;new&lt;/span&gt; UserHandler(user);&lt;br/&gt;        &lt;span&gt;// 开启将代理类class文件保存到本地模式，平时可以省略&lt;/span&gt;&lt;br/&gt;        System.getProperties().put(&lt;span&gt;&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;&lt;/span&gt;, &lt;span&gt;&quot;true&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 动态代理生成代理对象$Proxy0&lt;/span&gt;&lt;br/&gt;        Object o = Proxy.newProxyInstance(Main&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getClassLoader&lt;/span&gt;(), &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Class&lt;/span&gt;[]&lt;/span&gt;{UserInterface&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;}, &lt;span&gt;userHandler&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 调用的其实是invoke()&lt;/span&gt;&lt;br/&gt;        ((UserInterface)o).sayHello();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBoUib5KPHJebH3mwAWuwyLRoMkRiaJZFvSJmmSCuWxpCYFkrKuUWNW7dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.2631578947368421&quot; data-w=&quot;1026&quot;/&gt;这样动态代理的基本用法就学完了，可是还有好多问题不明白。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;动态代理是怎么调用的invoke()方法？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;处理类UserHandler有什么作用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么要将类加载器和接口类数组当作参数传入newProxyInstance？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假如让你去实现动态代理，你有什么设计思路？&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;猜想&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动态代理，是不是和静态代理，即设计模式的代理模式有相同之处呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单捋一捋代理模式实现原理：真实角色和代理角色共同实现一个接口并实现抽象方法A，代理类持有真实角色对象，代理类在A方法中调用真实角色对象的A方法。在Main中实例化代理对象，调用其A方法，间接调用了真实角色的A方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「实现代码」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 接口和真实角色对象就用上面代码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 代理类，实现UserInterface接口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserProxy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;UserInterface&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;// 持有真实角色对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; User user = &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;invoking start....&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 在代理对象的sayHello()里调用真实角色的sayHello()&lt;/span&gt;&lt;br/&gt;        user.sayHello();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;invoking stop....&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       &lt;span&gt;// 实例化代理角色对象&lt;/span&gt;&lt;br/&gt;        UserInterface userProxy = &lt;span&gt;new&lt;/span&gt; UserProxy();&lt;br/&gt;        &lt;span&gt;// 调用了代理对象的sayHello()，其实是调用了真实角色的sayHello()&lt;/span&gt;&lt;br/&gt;        userProxy.sayHello();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿开始的动态代理代码和静态代理比较，接口、真实角色都有了，区别就是多了一个UserHandler处理类，少了一个UserProxy代理类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着对比一下两者的处理类和代理类，发现UserHandler的invoke()和UserProxy的sayHello()这两个方法的代码都是一样的。那么，是不是新建一个UserProxy类，然后实现UserInterface接口并持有UserHandler的对象，在sayHello()方法中调用UserHandler的invoke()方法，就可以动态代理了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「代码大概就是这样的」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 猜想的代理类结构，动态代理生成的代理是com.sun.proxy.$Proxy0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserProxy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;UserInterface&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;// 持有处理类的对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; InvocationHandler handler;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;UserProxy&lt;/span&gt;&lt;span&gt;(InvocationHandler handler)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.handler = handler;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 实现sayHello()方法，并调用invoke()&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            handler.invoke(&lt;span&gt;this&lt;/span&gt;, UserInterface&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getMethod&lt;/span&gt;(&quot;&lt;span&gt;sayHello&lt;/span&gt;&quot;), &lt;span&gt;null&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable throwable) {&lt;br/&gt;            throwable.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 执行类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        User user = &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;        UserHandler userHandler = &lt;span&gt;new&lt;/span&gt; UserHandler(user);&lt;br/&gt;        UserProxy proxy = &lt;span&gt;new&lt;/span&gt; UserProxy(userHandler);&lt;br/&gt;        proxy.sayHello();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBaFOib5PG9Pzr8osOASjvYMgBQUWtVTE0pXRIXIGOAOibwvoE3iaicpZzPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.20190023752969122&quot; data-w=&quot;842&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代理类代码是写死的，而动态代理是当你调用Proxy.newProxyInstance()时，会根据你传入的参数来动态生成这个代理类代码，如果让我实现，会是以下这个流程。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据你传入的Class[]接口数组，代理类会来实现这些接口及其方法(这里就是sayHello())，并且持有你传入的userHandler对象，使用文件流将预先设定的包名、类名、方法名等一行行代码写到本地磁盘，生成$Proxy0.java文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用编译器将&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;Proxy0.java编译成&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 8564.8 955&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;50&quot; d=&quot;M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(751, 0)&quot;&gt;&lt;path data-c=&quot;72&quot; d=&quot;M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1202, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1687, 0)&quot;&gt;&lt;path data-c=&quot;78&quot; d=&quot;M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2259, 0)&quot;&gt;&lt;path data-c=&quot;79&quot; d=&quot;M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(2749, 0)&quot;&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot;/&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3527, 0)&quot;&gt;&lt;path data-c=&quot;6A&quot; d=&quot;M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3939, 0)&quot;&gt;&lt;path data-c=&quot;61&quot; d=&quot;M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4468, 0)&quot;&gt;&lt;path data-c=&quot;76&quot; d=&quot;M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4953, 0)&quot;&gt;&lt;path data-c=&quot;61&quot; d=&quot;M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5759.8, 0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot; font-size=&quot;935.2px&quot; font-family=&quot;serif&quot;&gt;编&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(935, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;935.2px&quot; font-family=&quot;serif&quot;&gt;译&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(1870, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;935.2px&quot; font-family=&quot;serif&quot;&gt;成&lt;/text&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;Proxy0.class&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据你传入的ClassLoader将$Proxy0.class加载到JMV中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用Proxy.newProxyInstance()就会返回一个$Proxy0的对象，然后调用sayHello()，就执行了里面userHandler的invoke()&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是对动态代理的一个猜想过程，下面就通过debug看看源码是怎么实现的。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;在困惑的日子里学会拥抱源码&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBnO2gic8fJ06jHDLwrmE4hfwS1Yfb8xiaMHzEJ3HsLEAGT3r32k4aECZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.47129629629629627&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;拥抱源码&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;调用流程图&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里先用PPT画一个流程图，可以跟着流程图来看后面的源码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBbFc1JS0O3pwJmo4cV8S3N7uAg8hK3AiaU9aTCnibSc4Z6S1zb1Q50R6w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.5703703703703704&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;流程图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「从newProxyInstance()设置断点」&lt;/strong&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBoIvC95qYckppLL4A7mv6D1hh3UvKUmgBib5DrazIjSCMBjKscpia3BTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.13055555555555556&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;newProxyInstance()&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;newProxyInstance()代码分为上下两部分，上部分是获取类&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;Proxy0.class，下部分是通过反射构建&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 16287.9 955&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;50&quot; d=&quot;M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(751, 0)&quot;&gt;&lt;path data-c=&quot;72&quot; d=&quot;M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1202, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1687, 0)&quot;&gt;&lt;path data-c=&quot;78&quot; d=&quot;M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2259, 0)&quot;&gt;&lt;path data-c=&quot;79&quot; d=&quot;M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(2749, 0)&quot;&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot;/&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3527, 0)&quot;&gt;&lt;path data-c=&quot;63&quot; d=&quot;M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3960, 0)&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4258, 0)&quot;&gt;&lt;path data-c=&quot;61&quot; d=&quot;M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4787, 0)&quot;&gt;&lt;path data-c=&quot;73&quot; d=&quot;M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(5256, 0)&quot;&gt;&lt;path data-c=&quot;73&quot; d=&quot;M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(6002.8, 0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;，&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(935, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;下&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(1870, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;部&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(2805, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;分&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(3740.1, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;是&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(4675.1, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;通&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(5610.1, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;过&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(6545.1, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;反&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(7480.1, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;射&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(8415.1, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;构&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(9350.2, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;建&lt;/text&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;Proxy0对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「上部分代码」&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBv22fZnOvicibUlYLa5rdC47mQuOlOa6wyf2c8aSfZgOqOmrQibJE9AKHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.35648148148148145&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;newProxyInstance()&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从名字看就知道getProxyClass0()是核心方法，step into&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;getProxyClass0()&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBS0bzNryO7ib6BKpQicMsC30T8lZViaibOXxZfxTlSRItgibj8XiapbZcaZaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;getProxyClass()&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;里面调用了WeakCache对象的get()方法，这里暂停一下debug，先讲讲WeakCache类。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;WeakCache&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义，它是一个弱引用缓存。那什么是是弱引用呢，是不是还有强引用呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;弱引用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WeakReference就是弱引用类，作为包装类来包装其他对象，在进行GC时，其中的包装对象会被回收，而WeakReference对象会被放到引用队列中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个栗子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;// 这就是强引用，只要不写str1 = null，str1指向的这个字符串不就会被垃圾回收&lt;/span&gt;&lt;br/&gt; String str1 = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;);&lt;br/&gt; ReferenceQueue referenceQueue = &lt;span&gt;new&lt;/span&gt; ReferenceQueue();&lt;br/&gt; &lt;span&gt;// 只要垃圾回收，这个str2里面包装的对象就会被回收，但是这个弱引用对象不会被回收，即word会被回收，但是str2指向的弱引用对象不会&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 每个弱引用关联一个ReferenceQueue，当包装的对象被回收，这个弱引用对象会被放入引用队列中&lt;/span&gt;&lt;br/&gt; WeakReference&amp;lt;String&amp;gt; str2 = &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;world&quot;&lt;/span&gt;), referenceQueue);&lt;br/&gt; &lt;span&gt;// 执行gc&lt;/span&gt;&lt;br/&gt; System.gc();&lt;br/&gt; Thread.sleep(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt; &lt;span&gt;// 输出被回收包装对象的弱引用对象：java.lang.ref.WeakReference@2077d4de&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 可以debug看一下，弱引用对象的referent变量指向的包装对象已经为null&lt;/span&gt;&lt;br/&gt; System.out.println(referenceQueue.poll());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;WeakCache的结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实整个WeakCache的都是围绕着成员变量map来工作的，构建了一个一个&amp;lt;K,&amp;lt;K,V&amp;gt;&amp;gt;格式的二级缓存，在动态代理中对应的类型是&amp;lt;类加载器, &amp;lt;接口Class, 代理Class&amp;gt;&amp;gt;，它们都使用了弱引用进行包装，这样在垃圾回收的时候就可以直接回收，减少了堆内存占用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 存放已回收弱引用的队列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReferenceQueue&amp;lt;K&amp;gt; refQueue = &lt;span&gt;new&lt;/span&gt; ReferenceQueue&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span&gt;// 使用ConcurrentMap实现的二级缓存结构&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;Object, ConcurrentMap&amp;lt;Object, Supplier&amp;lt;V&amp;gt;&amp;gt;&amp;gt; map = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span&gt;// 可以不关注这个，这个是用来标识二级缓存中的value是否存在的，即Supplier是否被回收&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;Supplier&amp;lt;V&amp;gt;, Boolean&amp;gt; reverseMap = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span&gt;// 包装传入的接口class，生成二级缓存的Key&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; BiFunction&amp;lt;K, P, ?&amp;gt; subKeyFactory = &lt;span&gt;new&lt;/span&gt; KeyFactory();&lt;br/&gt;&lt;span&gt;// 包装$Proxy0，生成二级缓存的Value&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; BiFunction&amp;lt;K, P, V&amp;gt; valueFactory = &lt;span&gt;new&lt;/span&gt; ProxyClassFactory();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;WeakCache的get()&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到debug，接着进入get()方法，看看map二级缓存是怎么生成KV的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; V &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(K key, P parameter)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Objects.requireNonNull(parameter);&lt;br/&gt;        &lt;span&gt;// 遍历refQueue，然后将缓存map中对应的失效value删除&lt;/span&gt;&lt;br/&gt;        expungeStaleEntries();&lt;br/&gt;        &lt;span&gt;// 以ClassLoader为key，构建map的一级缓存的Key，是CacheKey对象&lt;/span&gt;&lt;br/&gt;        Object cacheKey = CacheK.valueOf(key, refQueue);&lt;br/&gt;        &lt;span&gt;// 通过Key从map中获取一级缓存的value，即ConcurrentMap&lt;/span&gt;&lt;br/&gt;        ConcurrentMap&amp;lt;Object, Supplier&amp;lt;V&amp;gt;&amp;gt; valuesMap = map.get(cacheKey);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (valuesMap == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;         &lt;span&gt;// 如果Key不存在，就新建一个ConCurrentMap放入map，这里使用的是putIfAbsent&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;// 如果key已经存在了，就不覆盖并返回里面的value，不存在就返回null并放入Key&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;// 现在缓存map的结构就是ConCurrentMap&amp;lt;CacheKey, ConCurrentMap&amp;lt;Object, Supplier&amp;gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            ConcurrentMap&amp;lt;Object, Supplier&amp;lt;V&amp;gt;&amp;gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;());&lt;br/&gt;            &lt;span&gt;// 如果其他线程已经创建了这个Key并放入就可以复用了&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (oldValuesMap != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                valuesMap = oldValuesMap;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 生成二级缓存的subKey，现在缓存map的结构就是ConCurrentMap&amp;lt;CacheKey, ConCurrentMap&amp;lt;Key1, Supplier&amp;gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 看后面的&amp;lt;生成二级缓存Key&amp;gt;！！！&lt;/span&gt;&lt;br/&gt;        Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));&lt;br/&gt;        &lt;span&gt;// 根据二级缓存的subKey获取value&lt;/span&gt;&lt;br/&gt;        Supplier&amp;lt;V&amp;gt; supplier = valuesMap.get(subKey);&lt;br/&gt;        Factory factory = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;br/&gt;&lt;span&gt;// ！！！直到完成二级缓存Value的构建才结束，Value是弱引用的$Proxy0.class！！！&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;           &lt;span&gt;// 第一次循环：suppiler肯定是null，因为还没有将放入二级缓存的KV值&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;// 第二次循环：这里suppiler不为null了！！！进入if&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (supplier != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;// 第二次循环：真正生成代理对象，&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 往后翻，看&amp;lt;生成二级缓存Value&amp;gt;，核心!!!!!&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 看完后面回到这里：value就是弱引用后的$Proxy0.class&lt;/span&gt;&lt;br/&gt;                V value = supplier.get();&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;             &lt;span&gt;// 本方法及上部分的最后一行代码，跳转最后的&amp;lt;构建$Proxy对象&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;          &lt;span&gt;// 第一次循环：factory肯定为null，生成二级缓存的Value&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (factory == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                factory = &lt;span&gt;new&lt;/span&gt; Factory(key, parameter, subKey, valuesMap);&lt;br/&gt;            }&lt;br/&gt;         &lt;span&gt;// 第一次循环：将subKey和factory作为KV放入二级缓存&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (supplier == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                supplier = valuesMap.putIfAbsent(subKey, factory);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (supplier == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;// 第一次循环：赋值之后suppiler就不为空了，记住！！！！！&lt;/span&gt;&lt;br/&gt;                    supplier = factory;&lt;br/&gt;                }&lt;br/&gt;            } &lt;br/&gt;           }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;生成二级缓存Key&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在get()中调用subKeyFactory.apply(key, parameter)，根据你newProxyInstance()传入的接口Class[]的个数来生成二级缓存的Key，这里我们就传入了一个UserInterface.class，所以就返回了Key1对象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBL51Su1TmuFzeqN5UZGziaibmpbwDmtsxpXTRY5ic86pzN4jCIVQmWKEeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.2777777777777778&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;KeyFactory.apply()&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不论是Key1、Key2还是KeyX，他们都继承了WeakReference，都是包装对象是Class的弱引用类。这里看看Key1的代码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBBwPOk0XeOiaIzxVjkhTvpLVfVKFg8cP0sYzyU8r6IndkQc5ic5r3fdOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.2638888888888889&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Key1&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;生成二级缓存Value&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的while循环中，第一次循环只是生成了一个空的Factory对象放入了二级缓存的ConcurrentMap中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在第二次循环中，才开始通过get()方法来真正的构建value。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;别回头，接着往下看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Factory.get()生成弱引用value&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「CacheValue」&lt;/strong&gt;类是一个弱引用，是二级缓存的Value值，包装的是class，在这里就是$Proxy0.class，至于这个类如何生成的，根据下面代码注释一直看完&lt;span&gt;Class文件的生成&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; V &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;// 检查是否被回收，如果被回收，会继续执行上面的while循环，重新生成Factory&lt;/span&gt;&lt;br/&gt;            Supplier&amp;lt;V&amp;gt; supplier = valuesMap.get(subKey);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (supplier != &lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 这里的V的类型是Class&lt;/span&gt;&lt;br/&gt;            V value = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;// 这行是核心代码，看后面&amp;lt;class文件的生成&amp;gt;，记住这里返回的是Class&lt;/span&gt;&lt;br/&gt;            value = Objects.requireNonNull(valueFactory.apply(key, parameter));&lt;br/&gt;            &lt;span&gt;// 将Class对象包装成弱引用&lt;/span&gt;&lt;br/&gt;            CacheValue&amp;lt;V&amp;gt; cacheValue = &lt;span&gt;new&lt;/span&gt; CacheValue&amp;lt;&amp;gt;(value);&lt;br/&gt;            &lt;span&gt;// 回到上面&amp;lt;WeakCache的get()方法&amp;gt;V value = supplier.get();&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBOmLibWicqxsTqz5Wo1Eb5OsY4FicslO36Qd6D5zpUFh48Gl5yjoGewXnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4212962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;CacheValue&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;Class文件的生成&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;包名类名的定义与验证&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入valueFactory.apply(key, parameter)方法，看看class文件是怎么生成的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String proxyClassNamePrefix = &lt;span&gt;&quot;$Proxy&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; apply(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces) {&lt;br/&gt;            Map&amp;lt;Class&amp;lt;?&amp;gt;, Boolean&amp;gt; interfaceSet = &lt;span&gt;new&lt;/span&gt; IdentityHashMap&amp;lt;&amp;gt;(interfaces.length);&lt;br/&gt;            &lt;span&gt;// 遍历你传入的Class[]，我们只传入了UserInterface.class&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt; intf : interfaces) {&lt;br/&gt;                Class&amp;lt;?&amp;gt; interfaceClass = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;                 &lt;span&gt;// 获取接口类&lt;/span&gt;&lt;br/&gt;                interfaceClass = Class.forName(intf.getName(), &lt;span&gt;false&lt;/span&gt;, loader);&lt;br/&gt;                 &lt;span&gt;// 这里就很明确为什么只能传入接口类，不是接口类会报错&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!interfaceClass.isInterface()) {&lt;br/&gt;                    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;br/&gt;                        interfaceClass.getName() + &lt;span&gt;&quot; is not an interface&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            String proxyPkg = &lt;span&gt;null&lt;/span&gt;; &lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; accessFlags = Modifier.PUBLIC | Modifier.FINAL;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt; intf : interfaces) {&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; flags = intf.getModifiers();&lt;br/&gt;                &lt;span&gt;// 验证接口是否是public，不是public代理类会用接口的package，因为只有在同一包内才能继承&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 我们的UserInterface是public，所以跳过&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!Modifier.isPublic(flags)) {&lt;br/&gt;                    accessFlags = Modifier.FINAL;&lt;br/&gt;                    String name = intf.getName();&lt;br/&gt;                    &lt;span&gt;int&lt;/span&gt; n = name.lastIndexOf(&lt;span&gt;&#x27;.&#x27;&lt;/span&gt;);&lt;br/&gt;                    String pkg = ((n == -&lt;span&gt;1&lt;/span&gt;) ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : name.substring(&lt;span&gt;0&lt;/span&gt;, n + &lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (proxyPkg == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                        proxyPkg = pkg;&lt;br/&gt;                    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!pkg.equals(proxyPkg)) {&lt;br/&gt;                        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;br/&gt;                            &lt;span&gt;&quot;non-public interfaces from different packages&quot;&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;         &lt;span&gt;// 如果接口类是public，则用默认的包&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (proxyPkg == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;// PROXY_PACKAGE = &quot;com.sun.proxy&quot;;&lt;/span&gt;&lt;br/&gt;                proxyPkg = ReflectUtil.PROXY_PACKAGE + &lt;span&gt;&quot;.&quot;&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;         &lt;span&gt;// 原子Int，此时num = 0&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;long&lt;/span&gt; num = nextUniqueNumber.getAndIncrement();&lt;br/&gt;            &lt;span&gt;// com.sun.proxy.$Proxy0，这里包名和类名就出现了！！！&lt;/span&gt;&lt;br/&gt;            String proxyName = proxyPkg + proxyClassNamePrefix + num;&lt;br/&gt;         &lt;span&gt;// ！！！！生成class文件，查看后面&amp;lt;class文件写入本地&amp;gt; 核心！！！！&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;byte&lt;/span&gt;[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);&lt;br/&gt;            &lt;span&gt;// ！！！看完下面再回来看这行！！！！&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 获取了字节数组之后，获取了class的二进制流将类加载到了JVM中&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 并且返回了$Proxy0.class，返回给Factory.get()来包装&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; defineClass0(loader, proxyName,proxyClassFile, &lt;span&gt;0&lt;/span&gt;, proxyClassFile.length);&lt;br/&gt;           &lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;defineClass0()是Proxy类自定义的类加载的native方法，会获取class文件的二进制流加载到JVM中，以获取对应的Class对象，这一块可以参考JVM类加载器。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;class文件写入本地&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;generateProxyClass()方法会将class二进制文件写入本地目录，并返回class文件的二进制流，使用你传入的类加载器加载，&lt;strong&gt;「这里你知道类加载器的作用了么」&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] generateProxyClass(&lt;span&gt;final&lt;/span&gt; String name,&lt;br/&gt;                                            Class[] interfaces)&lt;br/&gt;    {&lt;br/&gt;        ProxyGenerator gen = &lt;span&gt;new&lt;/span&gt; ProxyGenerator(name, interfaces);&lt;br/&gt;        &lt;span&gt;// 生成class文件的二进制，查看后面&amp;lt;生成class文件二进制&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] classFile = gen.generateClassFile();&lt;br/&gt;      &lt;span&gt;// 将class文件写入本地  &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (saveGeneratedFiles) {&lt;br/&gt;            java.security.AccessController.doPrivileged(&lt;br/&gt;            &lt;span&gt;new&lt;/span&gt; java.security.PrivilegedAction&amp;lt;Void&amp;gt;() {&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Void &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        FileOutputStream file =&lt;br/&gt;                            &lt;span&gt;new&lt;/span&gt; FileOutputStream(dotToSlash(name) + &lt;span&gt;&quot;.class&quot;&lt;/span&gt;);&lt;br/&gt;                        file.write(classFile);&lt;br/&gt;                        file.close();&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InternalError(&lt;br/&gt;                            &lt;span&gt;&quot;I/O exception saving generated file: &quot;&lt;/span&gt; + e);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        }&lt;br/&gt;      &lt;span&gt;// 返回$Proxy0.class字节数组，回到上面&amp;lt;class文件生成&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; classFile;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;生成class文件二进制流&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;generateClassFile()生成class文件，并存放到字节数组，&lt;strong&gt;「可以顺便学一下class结构，这里也体现了你传入的class[]的作用」&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] generateClassFile() {&lt;br/&gt;      &lt;span&gt;// 将hashcode、equals、toString是三个方法放入代理类中&lt;/span&gt;&lt;br/&gt;        addProxyMethod(hashCodeMethod, Object&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        addProxyMethod(equalsMethod, Object&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        addProxyMethod(toStringMethod, Object&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; interfaces.length; i++) {&lt;br/&gt;            Method[] methods = interfaces[i].getMethods();&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; methods.length; j++) {&lt;br/&gt;             &lt;span&gt;// 将接口类的方法放入新建的代理类中，这里就是sayHello()&lt;/span&gt;&lt;br/&gt;                addProxyMethod(methods[j], interfaces[i]);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (List&amp;lt;ProxyMethod&amp;gt; sigmethods : proxyMethods.values()) {&lt;br/&gt;            checkReturnTypes(sigmethods);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 给代理类增加构造方法&lt;/span&gt;&lt;br/&gt;        methods.add(generateConstructor());&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (List&amp;lt;ProxyMethod&amp;gt; sigmethods : proxyMethods.values()) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (ProxyMethod pm : sigmethods) {&lt;br/&gt;                   &lt;span&gt;// 将上面的四个方法都封装成Method类型成员变量&lt;/span&gt;&lt;br/&gt;                    fields.add(&lt;span&gt;new&lt;/span&gt; FieldInfo(pm.methodFieldName,&lt;br/&gt;                        &lt;span&gt;&quot;Ljava/lang/reflect/Method;&quot;&lt;/span&gt;,&lt;br/&gt;                         ACC_PRIVATE | ACC_STATIC));&lt;br/&gt;                    &lt;span&gt;// generate code for proxy method and add it&lt;/span&gt;&lt;br/&gt;                    methods.add(pm.generateMethod());&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;      &lt;span&gt;// static静态块构造&lt;/span&gt;&lt;br/&gt;        methods.add(generateStaticInitializer());&lt;br/&gt;        cp.getClass(dotToSlash(className));&lt;br/&gt;        cp.getClass(superclassName);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; interfaces.length; i++) {&lt;br/&gt;            cp.getClass(dotToSlash(interfaces[i].getName()));&lt;br/&gt;        }&lt;br/&gt;        cp.setReadOnly();&lt;br/&gt;        ByteArrayOutputStream bout = &lt;span&gt;new&lt;/span&gt; ByteArrayOutputStream();&lt;br/&gt;        DataOutputStream dout = &lt;span&gt;new&lt;/span&gt; DataOutputStream(bout);&lt;br/&gt;      &lt;span&gt;// !!!核心点来了！这里就开始构建class文件了，以下都是class的结构，只写一部分&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {   &lt;br/&gt;            &lt;span&gt;// u4 magic，class文件的魔数，确认是否为一个能被JVM接受的class&lt;/span&gt;&lt;br/&gt;            dout.writeInt(&lt;span&gt;0xCAFEBABE&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;// u2 minor_version，0&lt;/span&gt;&lt;br/&gt;            dout.writeShort(CLASSFILE_MINOR_VERSION);&lt;br/&gt;            &lt;span&gt;// u2 major_version，主版本号，Java8对应的是52;&lt;/span&gt;&lt;br/&gt;            dout.writeShort(CLASSFILE_MAJOR_VERSION);&lt;br/&gt;            &lt;span&gt;// 常量池&lt;/span&gt;&lt;br/&gt;            cp.write(dout);&lt;br/&gt;            &lt;span&gt;// 其他结构，可参考class文件结构&lt;/span&gt;&lt;br/&gt;            dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);&lt;br/&gt;            dout.writeShort(cp.getClass(dotToSlash(className)));&lt;br/&gt;            dout.writeShort(cp.getClass(superclassName));&lt;br/&gt;            dout.writeShort(interfaces.length);&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; interfaces.length; i++) {&lt;br/&gt;                dout.writeShort(cp.getClass(&lt;br/&gt;                    dotToSlash(interfaces[i].getName())));&lt;br/&gt;            }&lt;br/&gt;            dout.writeShort(fields.size());&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (FieldInfo f : fields) {&lt;br/&gt;                f.write(dout);&lt;br/&gt;            }&lt;br/&gt;            dout.writeShort(methods.size());           &lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (MethodInfo m : methods) {&lt;br/&gt;                m.write(dout);&lt;br/&gt;            }&lt;br/&gt;            dout.writeShort(&lt;span&gt;0&lt;/span&gt;); &lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InternalError(&lt;span&gt;&quot;unexpected I/O Exception&quot;&lt;/span&gt;, e);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 将class文件字节数组返回&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bout.toByteArray();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;构建$Proxy对象&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;newProxyInstance()上半部分经过上面层层代码调用，获取了$Proxy0.class，接下来看下部分代码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBicGjrXvBEiaeqBzxT2dUa19TtdpJZUCq2MmichvAIjiaiaBqSDu23ksqGpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3861111111111111&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;newInstance&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cl就是上面获取的Proxy0.class，h就是上面传入的userHandler，被当做构造参数来创建$Proxy0对象。然后获取这个动态代理对象，调用sayHello()方法，相当于调用了UserHandler的invoke()，&lt;strong&gt;「这里就是UserHandler的作用」&lt;/strong&gt;！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;$Proxy.class文件&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们开启了将代理class写到本地目录的功能，在项目下的com/sum/proxy目录下找到了$Proxy0的class文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「看一下反编译的class」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.sun.proxy;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.test.proxy.UserInterface;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.reflect.InvocationHandler;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.reflect.Method;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.reflect.Proxy;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.reflect.UndeclaredThrowableException;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; $&lt;span&gt;Proxy0&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;UserInterface&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Method m1;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Method m3;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Method m2;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Method m0;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; $Proxy0(InvocationHandler var1) &lt;span&gt;throws&lt;/span&gt;  {&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(var1);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;equals&lt;/span&gt;&lt;span&gt;(Object var1)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (Boolean)&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m1, &lt;span&gt;new&lt;/span&gt; Object[]{var1});&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (RuntimeException | Error var3) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; var3;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable var4) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UndeclaredThrowableException(var4);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m3, (Object[])&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (RuntimeException | Error var2) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; var2;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable var3) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UndeclaredThrowableException(var3);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (String)&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m2, (Object[])&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (RuntimeException | Error var2) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; var2;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable var3) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UndeclaredThrowableException(var3);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hashCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (Integer)&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m0, (Object[])&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (RuntimeException | Error var2) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; var2;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable var3) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UndeclaredThrowableException(var3);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            m1 = Class.forName(&lt;span&gt;&quot;java.lang.Object&quot;&lt;/span&gt;).getMethod(&lt;span&gt;&quot;equals&quot;&lt;/span&gt;, Class.forName(&lt;span&gt;&quot;java.lang.Object&quot;&lt;/span&gt;));&lt;br/&gt;            m3 = Class.forName(&lt;span&gt;&quot;com.test.proxy.UserInterface&quot;&lt;/span&gt;).getMethod(&lt;span&gt;&quot;sayHello&quot;&lt;/span&gt;);&lt;br/&gt;            m2 = Class.forName(&lt;span&gt;&quot;java.lang.Object&quot;&lt;/span&gt;).getMethod(&lt;span&gt;&quot;toString&quot;&lt;/span&gt;);&lt;br/&gt;            m0 = Class.forName(&lt;span&gt;&quot;java.lang.Object&quot;&lt;/span&gt;).getMethod(&lt;span&gt;&quot;hashCode&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (NoSuchMethodException var2) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NoSuchMethodError(var2.getMessage());&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (ClassNotFoundException var3) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NoClassDefFoundError(var3.getMessage());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结语&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面就是动态代理源码的调试过程，与之前的猜想的代理类的生成过程比较，动态代理是直接生成class文件，省去了java文件和编译这一块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚开始看可能比较绕，跟着注释及跳转指引，耐心多看两遍就明白了。动态代理涉及的知识点比较多，我自己看的时候，在WeakCache这一块纠结了一阵，其实把它当成一个两层的map对待即可，只不过里面所有的KV都被弱引用包装。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a543be999ae32bff2cd8740a9bc59e6b</guid>
<title>安全左移理念，腾讯 DevSecOps 如何实践？</title>
<link>https://toutiao.io/k/ushzvi4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.18125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zjibooUqFtwnfJQNdvaqXibEl3KJyCebyKsFgf1QD1ZiacOdCmmp0UA9Jg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;文｜&lt;/strong&gt;腾讯研发安全团队&lt;/p&gt;&lt;p&gt;Martinzhou、Spine&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.7748918&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zy2OoDMiaYcTtP1QXGNDzEmkPxDibsicOicHlyxvRZsWiar5fdRXz79acfKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;693&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;引子&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着DevOps模式的落地，快字当头。研效提速也意味着出现安全漏洞的数量和概率随之上涨。过去安全风险的管控主要依赖于DAST类技术，即：采用黑盒测试技术，对待检查目标发起含检查用例的请求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;DevOps给这一模式带来了挑战，安全检查速度慢、周期长，容易给业务带来干扰，一定程度上有阻碍业务持续交付的风险。另据Capers Jones的研究结论：解决缺陷的成本，在研发流程中越靠后越高。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;因此，安全机制的左移在开展DevSecOps建设时就变得更为重要了。&lt;/strong&gt;左是指软件开发生命周期的早期，也就是设计、编码阶段。发生安全漏洞研发的早期阶段存在哪些问题？我们认为可以总结为三类：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;(1) 开发人员不了解安全编写代码的知识&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(2) 开发人员有一定安全意识，但因为赶进度或疏忽遗漏编写安全机制，或是错误地实现安全校验逻辑&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(3) 代码编写是否安全仅凭开发人员自觉，缺乏检查和卡点机制&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;调研业界理念与实践基础上，团队进行了安全左移建设的探索，主要包括三个机制：&lt;strong&gt;面向开发人员的代码安全指南、默认安全框架组件、嵌入基础设施的代码安全检查。&lt;/strong&gt;作为前述项目的参与者，我们想与业界同行分享交流其中的一些思考与经验。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Ⅰ. 代码安全指南&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;1.1 背景&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;首先是开发人员缺乏安全编写代码知识的问题。&lt;/strong&gt;在开展日常安全运营过程中，常常会遇到如下与之关联的挑战：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一个业务被发现问题，如何把这种“踩坑”的经验沉淀下来，分享给其他业务以及新加入公司的同事？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如何帮助开发人员建立起安全编码意识，实现代码写出来就没有漏洞？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当检出安全漏洞时，如何给予开发人员详细、可操作的改进指引？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;安全编码意识和漏洞修复指引，两份材料是否合二为一？&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;综合上述背景，去年梳理了一份统一代码安全指南。从开发人员视角讲述安全注意事项，并配套了丰富的代码示例。覆盖常见的8门编程语言，包括：C#、C,C++、Go、JavaScript、Java、Objective-C、PHP、Python。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5388889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zmcHBk02TonsdoHDmkOSegO2fLiaJRQmrD1eiazSjozX62toztqttksHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;1.2 设计理念&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;代码安全指南的内容呈树状结构展开，共分5层，如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4833333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zW90dL9lTVW70ibsqgRRiaKfwxa6FmnMMNxhvicceEiafJ63fOrwPwia9jMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 1.2.1 语言 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每种语言面临安全的风险种类不同，需要分别开展详述。如：go和javascript对比，go就不存在原型链污染的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同时，由于公司内的代码风格规范亦分语言展开，安全规范采取相同的分语言方式能保持整体的连贯性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 1.2.2 端 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里的端是指不同的终端，如：Web、安卓客户端、iOS客户端、PC客户端。实践过程中，将内容按端区分的原因有：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1. 同一门编程语言，&lt;strong&gt;用在不同的终端应用开发，其面临的风险类型和数量有着天壤之别。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;p&gt;JavaScript应用于前端页面开发时，面临的主要风险是DOM XSS；但JavaScript亦可依托Node.js进行Web后端接口开发，如果编码不当，则存在命令注入、SQL注入等风险。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2. 大型互联网公司内，项目开发采取“流水线”化作业，分工往往精细明确，将不同端的场景作为主干目录，&lt;strong&gt;更便于开发人员检索、快速了解编码安全知识。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 1.2.3 场景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过复盘历史漏洞，安全风险可按成因粗略归为两类：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 代码漏洞&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;指代码编写时，因不安全的API使用和逻辑编写产生的安全风险。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. 运维漏洞&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;指代码的运行环境、配置和依赖等系统运维相关的安全风险。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如腾讯蓝军分享的《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzE1NjA0MQ==&amp;amp;mid=2651204093&amp;amp;idx=1&amp;amp;sn=6ccbed17a237f24d4c2fdf772c5d04a8&amp;amp;chksm=bd2ccc5b8a5b454d432fda68db33e8eec2d59914344ac6cf6af512ef823e04ef2a99d0fadbdf&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;浅析软件供应链攻击之包抢注低成本钓鱼&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;浅析软件供应链攻击之包抢注低成本钓鱼&lt;/a&gt;》一文，涉及的安全风险本质上是是：部分语言依赖包管理，当部分企业私有软件包仅在公司内部软件源注册时，攻击者就可以在外部公共软件源上抢注。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果公司内员工使用包管理软件拉取时，未配置公司镜像源时，就会拉取到攻击者抢注的恶意包。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 1.2.4 功能 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在对内、外部发现的漏洞进行复盘过程中，我们发现安全风险与业务场景高度相关，例如：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3768519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zAO6DaInekmicIIP4tXmKbpvezDwUrVaCYkjEcibjBJI6ExLfVJzwxryg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于代码安全指南的目标受众是开发人员看的。在撰写指南过程中，我们尝试将漏洞转化为功能场景，作为主干目录。&lt;strong&gt;由于与具体的业务场景关联，在开发时能更容易想起相关的注意事项，由此可降低认知、学习成本。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 1.2.5 API/sink点 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于开发人员来说， 各类API是程序代码的基础组成部分。对安全团队来说，API也就是编写安全检查策略要收集整理的sink点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 为什么要在代码安全指引中，枚举API/sink点？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对开发人员来说，API是实现业务逻辑时，高频接触对象。通常安全漏洞往往可归因为API的错误使用。对安全工程师来说，sink点是编写安全策略、组件是非常重要的一部分，直接决定了SAST系统的扫描能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;业界也不乏类似的探讨，如Google在ICSE &#x27;21的论文《If It’s Not Secure, It Should Not Compile: Preventing DOM-Based XSS in Large-Scale Web Development with API Hardening》中，阐释了Google加固前端组件，使其Web页面能天然“免疫”DOM XSS漏洞的实践过程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中主要的思路是对.innerHTML等容易被误用产生安全问题的API做了加固，封装为前端组件中新的函数对象。形成了JavaScript公共库https://github.com/google/closure-library，并设计了对应的编译时检查工具。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;自2018年在其内部逐步推广后，截止2020年Q2外部向Google报告全部漏洞类型中，DOM XSS已由原先的20%降低至2%。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5240741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zHnSD1dXD6tib4BjTU7kGOaXrGMylOo2zhNB5ibAfjsttfNjibxNq7C5jA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在上述实践过程中，最为重要的一步是：&lt;strong&gt;XSS sink点的提取，也就是易被误用产生安全漏洞的API。&lt;/strong&gt;原文指出sink点的提取是开展API加固极为重要的一步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;em&gt;We  would  like  to  mention  that  many  other  XSS  counter-measures, such as data-flow analyses, also need to identify areasonably comprehensive  set  of  XSS  sinks  to  be  effective.&lt;strong&gt; Therefore, enumerating the sinks are somewhat orthogonal to API hardening&lt;/strong&gt;.&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6006006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5z3Gd8RcU2Kqp8dBIT7IlibmsqXdmz8pk6hiatghJQX0b5FrbQbk8H4phQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;666&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;与上述实践类似，&lt;strong&gt;我们认为在代码安全指南中，清楚地列出容易被误用的API，对日常开发和安全策略建设均有帮助&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 如何确保所枚举API的完善性？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这也是上述论文中抛出的一大难点，原文提到：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;em&gt;It  is  unrealistic  to  cover  all  browser-specific XSS sinks because many browsers have undocumented behaviors. As our best effort, we work with the developers of some mainstream browsers  to  stay  informed  about  new  browser  features  that may  have  security  implications.&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;文章指出，这是一项非常有挑战的任务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;编写代码安全指引时，我们亦遇到了类似的挑战，采取的解决思路是：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(1) 整合各语言、组件、框架文档中的最佳安全实践。在编写安全指南初期，我们重点参考了CWE、OWASP等材料。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(2) 结合内、外部已知的漏洞案例的复盘、抽象，做校对补充。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(3) 举一反三，推导鲜有提及的风险点。例如，使用jQuery的页面，会因为不安全地使用.html()方法产生DOM XSS漏洞。那是否还有其他函数有同样的风险呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过查阅jQuery的开发者手册https://api.jquery.com/html/发现，.html函数接受的入参类型为htmlString和function。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3909574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zL5f4Gia3s7yu3jicQ8svJHwyRiblg5LPypkeicMzs4L9nRiaYiaoXf5w43eg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;752&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;官方文档给出的示例如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1608247&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zkXrjaluprQz8MEaSVrNhLTnTicvqpevhKsGCyoLomQWFWAHOO9ogc7A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;970&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zjSI01Ae7GiacDp9SVQcIHDPTMbibvAXaPq2tJONuqtDJfdgjK3Hg7xnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此可以得出产生漏洞的原因是：从用户可控来源获取切未经过滤的值，可定义为htmlString类型并经.html()写入页面，进而产生XSS漏洞。顺藤摸瓜可以整理出：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;.append()、.prepend()、.wrap()、.replaceWith()、.wrapAll()、.wrapInner()、.after()、.before() &lt;/em&gt;等API存在同样的因误用产生安全风险的可能性。最终，针对上述场景下的指引要求描述如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1527778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zvEhGu4gm6ewcaCLTBxEr1j725D3yVOrGxhVsg4oBRcQMgESMrBlM5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;除列出所有风险API，让开发人员在使用时，脑海里能对快速关联到指引要求外，在编写指引时，我们约定还采取了两种额外的表述注意点，来保证指引内容的可操作性：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;限定产生安全风险的开发场景，更明确；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;明确给出安全漏洞的规避方式，或是提供可选的“开箱即用”式安全方案。最终，效果如下：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1833333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5z0FKYibuPnYlcYz7iaf5yQXsDeia1jCP6wbuAgzadlGoYz2uygf1pofg4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;1.3 效果与不足&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过上述的思路，撰写代码安全指南并配套在线学习课程和考试，&lt;strong&gt;我们试图解决开发人员不了解如何安全地开发的问题。&lt;/strong&gt;当前，该方向仍存在两项挑战：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 补充完善sink点的工作长尾且任务量大，需要随着内外部发现的漏洞、编程语言&amp;amp;框架的迭代不断迭代。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为此我们决定将上述代码安全指南通过Github开源，&lt;strong&gt;希望和社区携手，一道维护完善。&lt;/strong&gt;项目地址：https://github.com/Tencent/secguide&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.662963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zicc63iaHd9ajVR7dMD9iaGWbSygQeAgap0LZATgkbhuyGQ8kq8BlB87PQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 代码安全指南只是安全左移建设的第一步，&lt;/strong&gt;&lt;/span&gt;还需解决的挑战有：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(1) 开发人员有一定安全意识，但因为赶进度或疏忽遗漏编写安全机制，或是错误地实现安全校验逻辑；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(2) 代码编写是否安全全凭开发人员自觉，缺乏提示、检查和卡点机制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Ⅱ. 静态代码安全检查&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;2.1 现有技术&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“代码编写是否安全全凭开发人员自觉，缺乏提示、检查和卡点机制”的问题，解决方式是：静态代码安全检查解决。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;要对代码安全规范扫描，我们首先需要考虑的就是将源码表示成一种方便检查的形式，然后选择合适的方式进行扫描。常规的源码表示方式以AST（抽象语法树）和 IR（中间表达）为主：以C++ 为例， clang可以将C/C++源码转换为clang AST和LLVM IR。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一般而言，IR是从AST经过层层转换而来，所以会比AST拥有更多信息。但相对的，每种语言一般会有自己不同的IR，处理起来会相对比较困难。而AST的形式则简单直观，操作起来也比较容易。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2736486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5ztT5U0cZUEHxB4gGrb85HicticxdJ0cCaDTjGibne7JFu9WKwKGBXuQBoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;296&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;em&gt;源码&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1518519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zECIfGnJReTM1gTWNu984VZQ0vjOLCjgczwykzVVs56OEaw2YNlDWfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;em&gt;Clang AST&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.164794&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zZYO8fOMq9e9PnU3IuNFAsGYhN8XROPdyPdErKOB3tSM2uCVbocYWPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;em&gt;LLVM IR&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;根据选择的源码表示不同，有不同的方式做代码检查：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 方式一、AST匹配 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一种方式是在AST上做检查，既然源码被表示成了树的形式，我们就可以遍历AST，使用一些pattern去检查代码规范中的问题。如：Go语言代码安全指南中的1.7.2条目（CSRF防护）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5898438&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zXJne0iaYyarfbIDp6icf2BkHlUUX7nd0lunplHaMJib9p4Rrwc4St6lfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于该样例，我们需要做两个检查：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(1) 检查http.ListenAndServe参数中是否存在CSRF防护相关配置&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(2) 检查该配置的正确&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;具体实现上，我们可以遍历该文件的AST，寻找到http.ListenAndServe调用所在的节点，遍历它的参数，观察是否存在CSRF防护相关的参数，再对参数的内容正确性做检查。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过使用AST的方式我们能方便快捷的进行相关规范条目的验证。但对于一些条目，例如C++的1.2条目：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zVLic02N31OJ3b1YFjPFtRkhR5TwBN7IIBuudmkgoiadCJhEaD3YYdNUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;很显然，这里如果要判断它违反规范需要满足两个条件：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(1) cmdline含有用户输入&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(2) 没有对cmdline做相关检查&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果说第二个条件还能通过模式匹配的方式检查的话，第一个条件就很难通过模式匹配的方式检查了，所以我们需要另一种检查方式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;方式二、污点分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;污点分析是更为常用的检查安全漏洞的方法。通过标记外部输入点、基于程序数据流观察数据是否能到达危险函数（如：SQL查询，命令执行等函数）来检查安全漏洞。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;要实现污点分析，有三个核心的关键点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(1) source点：表示外部输入，如web输入，文件输入等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(2) sink点：表示危险的函数调用或者变量赋值，如system等函数&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(2) sanitizer：表示过滤点，经过过滤点的数据将被取消标记。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以下面这段代码为例，污点分析从user_input一路进行数据流追踪（一般因为source点的数量远远大于sink点的数量，会反过来从sink点开始回溯以提升效率），中间的检查就是sanitizer，这时候会取消标记，因此该漏洞并不成立。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4738806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5z4S9sIDHZCo1L7AicgR9vegyW5clibr14c1RNPblb63OrsHIh4c3Cmhhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1072&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用污点分析，由于是通过数据流追踪的方式得到漏洞，我们能得到程序相对精确的漏洞触发流程，便于研发二次检查。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同时因为依赖手动配置source点、sink点和sanitizer，会有部分漏报。而且研发往往会采用不同的过滤方式，不同的写法，导致sanitizer并不能很好的确定下来。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在大型项目中，组件往往分布于不同仓库，加上许多自定义的通信框架，完整的程序数据流会很难得到。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;综上我们可以总结出两种不同的扫描方式各自的优缺点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3766447&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zYgQEemcyvvemAibZttzvzBf7r5VVBQgwKJBKge7xxsNhXialsBibQ0ib3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;2.2 工具调研&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在初步了解了扫描方式后，就要对社区工具做调研。针对单一语言的工具写起来就太多了（各种语言的lint），这里主要提两个工具：Semgrep和CodeQL。一是这两个工具支持语言都不止一个，二是在各自技术领域它们都比较有代表性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 2.2.1 Semgrep &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Semgrep是一款基于Facebook开源SAST工具pfff中的sgrep组件开发的开源SAST工具，目前由安全公司r2c统一开发维护，提供强于grep工具的代码匹配检索能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其核心技术原理可以用下面这张图概述：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6879921&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5znveeicZdiaC2htN0vZHpwHOP4H7NFiaKjdCc3YNKACCgPQlSwPibILP1rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Semgrep支持两种类型的代码模式匹配。一种是基于AST的匹配，&lt;/strong&gt;使用tree-sitter parse各种语言的源码，并将它们转换成generic AST（Semgrep内的一种通用AST格式），然后再使用规则匹配。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举个例子，如果要检索代码中使用strcpy的代码行，可以编写如下ripgrep命令：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.0719101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zvicCTQSbEV5YfOWvr6WiaXlYP6CicVAvH51ibRo1DUgORibMpHjibsOlh6wA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;890&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但类似如下的代码也会被匹配到，实际上它仅为注释，并没有真正调用strcpy：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.0685185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zxkibwFHiagxqW55j4IlicSXYVoKxPuzibGictuWvpNVN1HDqs2WfQSQRCiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而运行如下semgrep命令，即可基于AST搜索，实现更精准的匹配。其中 ... 是semgrep提供的代码模式匹配语法——省略号运算符（Ellipsis operator），用于代表若干参数、语句或字符：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.0669546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zAqBjUutV3yCWS45sMttoTUqmiaicwtmXIA42SAIJKlXH2flMGEQA8yBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;另一种模式是generic pattern matching，&lt;/strong&gt;使用一个通用文本parser（spacegrep），通过分词和特殊字符的识别来做代码模式匹配。相比基于AST的匹配，该模式能力较弱，但拓宽了工具对各类编程语言的覆盖能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如对YAML、ERB、Jinja等语言，就可以使用该模式进行检查。假设有一个配置文件如下，想要检索其中不正确的“allowed_origins”配置：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4635108&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5ziar96BQsO47Ff5ER7Fzr8HxdnjoTic4tnWTCccrUw4ebxoVrJZdkX48w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;尽管还不支持解析该文件格式的AST，可以基于spacegrep提供的能力，编写如下规则对代码库进行检索：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2614108&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zSibhicws4xFNxoc2LtDbuH7woU9jgbGxofxPPVysfggsgn0LggwzZrJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;723&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;但该种匹配模式下，有时无法区分出是真实的API调用，还是代码注释。两种模式对同一代码片段匹配效果，比对如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2564815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zuG4L6nsdhbLEuKHhJ0eCs0eGIDj6qxSfoEMAicIfzXoAK0MaDcWPwsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;综上，Semgrep的特点如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;(1) 安装便捷。通过包管理工具安装cli，即装即用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(2) 规则上手、编写简单。采用yaml配置文件编写扫描规则，语法简单但表现能力相较于传统grep类工具更强大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(3) 引擎本身和规则集均开源，且支持的规则集丰富，已经开源包含总计有1000+条规则。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(4) 扫描速度快。直接基于AST/文本匹配，工具效率会相对较高。经测试，扫描速度可达到2~10w行代码/秒。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(5)支持代码自动修复替换。通过AutoFix语法可自动修复存在安全风险的代码。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(6) 易于集成，官方已给出了一系列和CI集成的配置，涉及14款CI平台，如Jenkins、Gitlab、Circle CI等。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 2.2.2 CodeQL &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CodeQL是Semmle公司推出的一款静态代码分析工具（以前叫Semmle QL），后被Github收购，并成立了Security Lab支持Github的开源代码安全检查能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相对于Semgrep，CodeQL走的是深度分析的技术路线，核心技术原理是分析源码并将其转换成代码快照，然后通过它自己的QL查询语言做代码查询来达到扫描的目的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7796296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5z2pybfRxCT0xJqoDAjzswCG4tuSsejHlPnr3ichBKsPKjiaIkFtujjHOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如上图，先提取不同语言的源代码文件到代码快照，然后将查询规则（.ql文件）编译成CodeQL内部的查询形式，再对代码快照进行查询。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2481481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zEtS7jVYoia75LicZsHb8MlZGOz7WFic2LlWB5QcgPSHcgcTvN5Ilq5RZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其规则形式如上（一部分），编写起来会比较复杂。CodeQL的优势是支持完整的污点分析和过程间分析，相对不可避免的，分析时间会大大上升。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;两款工具都对策略规则写法做了统一，能较好地解决跨编程语言检查的需求。&lt;/strong&gt;设想一下：如果用每种语言的lint编写检查规则，不同lint间的规则语法不一致，将会带来比较高的维护门槛。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4012739&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zZnhM2EGAOyibsWXAj7Tcyrkz0Sq8p3dMUzG6dX3hVibVas3XAIkL7dQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;942&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 2.2.3 比对及选型 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常，编写代码涉及三个环节——编码、代码托管、CI/CD，开发人员在各阶段对检查工具和结果的期望和要求是不同的。可以简单概括并比对如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6401327&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5z1n8HCE4NYZI9RTwYCzQHib39oex8cricYDBIwedWsUpKrtjo2iavic1mrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;603&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;两款代码检查工具可简单比对总结如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5277778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5ziaefdyBaTQia0EDrWEuTQ4mj5bVLftTKADUhWE8wmQVCZpkkKyjOuibtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;2.3 结论与实践&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在编写代码的不同阶段，开发人员对检查工具和结果的预期和要求各不相同。在不同编码阶段采取的静态代码安全检查方案可概括如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 本地编写阶段&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在本阶段，对工具有一定要求：速度快，容错性要高。而且往往这个点代码还未写完，工具的检查错误可以快速得到修复。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这时候AST模式匹配就会是一个很好的检查方式。在编码阶段，可以使用semgrep等类似lint、grep工具，封装为IDE插件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实践过程中，还可以尝试引入一些更激进的策略，如：提示并要求修改不安全的SQL查询拼接逻辑。开发人员可根据提示快速判断，如果风险确实存在，即借助自动修复功能修改代码，进而在代码构建前收敛安全风险。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 构建部署阶段&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个阶段代码已签入代码仓库，类似semgrep或CodeQL的方案可封装为流水线原子，提供给开发人员使用，并配套提供安全卡点（质量红线）机制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果检查出安全漏洞，应给出详细的漏洞触发路径，并提示风险关联的代码安全指南条目来引导修复。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 日常检查阶段，代码仓库检查&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该阶段一般为纯旁路的检查，时效性可以适当放宽，可进行一系列复杂的分析。但需要注意的是，由于代码仓库是纯静态代码，如果工具对编译有要求（如Clang，CodeQL的部分语言），在该阶段检查应注意编译环境的适配。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;值得一提的是，代码安全规范/指南也在编写策略的过程中扮演非常重要的角色。&lt;/strong&gt;如果公司内有一份比较清晰、完善的规范，能详细地列出各类容易出错的API，编写检查规则会容易许多。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Ⅲ. 默认安全的框架组件&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;3.1 背景&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当有了一份代码安全指南和配套的静态检查机制后，&lt;strong&gt;开发人员仍需要自行在项目中引入或实现安全校验逻辑。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;这时候就会遇到“开发人员有一定安全意识，但因为赶进度或疏忽遗漏编写安全机制，或是错误地实现安全校验逻辑”的问题。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;深挖背后的原因及“痛点”，我们认为可以归纳为如下三点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;(1) 全凭安全意识不靠谱。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;即便是安全工程师也会犯错，需要将安全指南的要求转化为开箱即用式的安全组件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;(2) 重检查，轻具可操作性、便捷的解决方案。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;检查工具聚焦于发现问题，但开发人员在解决问题的时候，如果没可操作的解决方案，修复工作往往难以推动。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;(3) 研发效率与质量。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不同业务重复在写安全校验逻辑，不仅浪费人力，还容易出错。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过分析业界相关理论与实践，借助公司建设统一后台框架的契机，我们开展了开展默认安全的框架组件建设。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;3.2 分析与解决&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 3.2.1 业界理论与实践 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 嵌入框架的安全组件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Google在《Building Secure and Reliable Systems: Best Practices for Designing, Implementing, and Maintaining Systems》一书的第12章中分享了其内部在代码编写阶段开展的安全左移建设实践。可概括为：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;(1) “越早越好”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;应该在软件设计初期就考量安全、稳定性问题。否则，越往后代价越高，过程会很痛苦。（笔者注：本质上就是安全左移）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;(2) “安全意识教育很重要，但不是银弹，即便是安全工程师也会犯错”。 &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;依赖安全意识教育，效果不佳。这是因为，业务开发阶段，关注点往往是功能的实现，要兼顾安全和稳定性设计方面的权衡，会很难。因此，应侧重关注安全机制、工具的建设。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;(3) Google团队认为，安全能力嵌入框架大有裨益，&lt;/strong&gt;如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;a. 规范化与一致性，&lt;strong&gt;复用最佳实践。&lt;/strong&gt; 某些功能容易出问题，通过框架封装，能减少由业务各自实现产生的风险&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;b. &lt;/span&gt;&lt;strong&gt;提升研效。&lt;/strong&gt;&lt;span&gt; 业务逻辑与通用功能抽离，专注业务逻辑开发，无需关注其他细节。不仅能减少代码审阅的精力，也能缩短修复问题的时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;c. &lt;strong&gt;降低修复成本及时间。&lt;/strong&gt; 虽然框架不能保证预防、解决所有安全问题，但出现问题时，只需要在“一个点”集中解决&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. Security by Design&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;USNIX15&#x27;的议题《Preventing Security Bugs through Software Design》中抛出了与众不同却巧妙的观点：&lt;strong&gt;写出漏洞不一定是开发者的问题，而可能是API设计得容易出错。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以SQL注入为例，尽管大部分语言、组件和框架都提供了参数绑定（参数化查询）的功能，安全规范也有不断强调。但开发人员仍非常容易写出带SQL注入问题的代码。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为解决前述问题，&lt;strong&gt;提出了一种名为trustedsqlstring的机制，从接口设计层拒绝拼接SQL查询语句传入。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以Go语言例，各类参数需要标注静态类型的机制。通过修改SQL查询组件导出操作函数的入参类型，可以从API设计机制上禁用查询拼接，仅允许通过占位符动态拼接参数值进入查询语句。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zL7ciaCDCicZ4K7rvC4TTkyyfK91q2uRcJzD2BkMGI5h9dWGpSlFZLPTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;虽然Google仅分享了针对XSS和SQL注入做组件加固的方案，并不足以覆盖所有应用漏洞。但核心思路仍具有借鉴价值，可归纳为：&lt;strong&gt;基于白名单模式，对现有组件做安全加固，使安全机制在默认情况下能生效。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 3.2.2 安全组件方案分析 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过整理汇总，可以把现有的安全过滤方案分为三类：&lt;strong&gt;校验、过滤和组件。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5785124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zbBkMXBO0GxbSC7xKGxs9ZcxKYiaDhtlgibArE3jic5T5t2TITcicyDibt8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;605&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从上述对比来看，&lt;strong&gt;组合采用校验，和带默认安全机制的功能组件（融入Security by Design设计思路）两个方案是最优解。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 3.2.3 落地案例 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;数据校验是几乎每份安全规范类文档会囊括的要点，但实际在业务研发过程中，落地情况并不理想。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一方面，引入数据校验有一定成本和门槛，导致该逻辑往往会被省略；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另一方面，即便是编写了数据校验逻辑，其准确性和安全性也鲜有检查。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;结果是：我们在内部安全工单系统中，能看到许多开发人员在漏洞处理结论时备注“未做数据校验，已经通过添加相关逻辑解决”。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;据内部复盘数据统计，这类可通过数据校验规避的漏洞约占历史Web漏洞安全工单数量的70%~80%。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;为此，我们为公司级RPC框架引入了一套Validation组件和检查、卡点机制，并取得了不错的效果。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;公司级RPC框架使用Protocol Buffer作为IDL，根据设计理念，Protocol Buffer原本就带有一定数据校验类似的特性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但经分析，其不足以支撑业务和安全的需求，例如：校验入参是否为空？传入的是否是字母数字组合，这些需求是PB原生的能力无法支持的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此，需要引入第三方数据校验组件补充这部分能力，当前主要有两类方案：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;方案1：在代码中引入validator，并编写校验规则&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;方案2：在IDL文件中编写校验规则并自动生成代码的protoc插件&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过分析对比，&lt;strong&gt;最终选择了方案2——开发人员在定义proto文件时即在拓展字段中定义好校验规则，&lt;/strong&gt;过程如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2944444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zYrA60Dvahz4iazHiaEhWfAQcHak7z9PaltRfyLS3DZ7RE9RCkweib6RTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同时，通过对历史漏洞的复盘分析，我们发现许多漏洞是string类型的字段未限制字符集产生的。如：id参数功能上仅允许数字传入，但未做校验，允许传入`)(&#x27;&quot;等字符，带入经拼接产生的SQL查询语句，最终产生了SQL注入漏洞。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;于是，我们在内部代码安全指南中添加了明确的要求：&lt;strong&gt;请求（Req）消息体中的String类型字段必须限定格式/字符范围+长度。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另一方面，我们还与基础设施开发团队合作，将上述组件嵌入了proto管理平台默认提供的文件模版中。开发人员几乎可以无额外成本，快速上手使用这套机制：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2472222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zghKJfRunXzyqjWWoiaMcSxpw0k1gwMk2jZrOOUmia0959ETjqWtyBPSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此外，我们还设计了静态安全检查和卡点机制，并引入上述平台，来保证数据校验逻辑的准确性和安全性。&lt;strong&gt;开发人员在保存proto文件时，能立即获得提示并及时修正存在的安全隐患。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1805556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5z8aefwlqsN5MCZBpdkh3F2uLASjgeiccSPzkIZABE8NVHCnd7ZemAAKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;综上，数据校验本身是一项业务需求，通过降低开发门槛、给出安全要求并配套自动化检查和卡点机制，在框架层提供组件让每个业务模块都能做好数据校验。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于前述思路建设的组件还有不少，包括：DB组件、网络资源请求组件等。&lt;strong&gt;这些组件不是自成一体的安全过滤函数库，而是与某项特定功能需求结合的特定组件。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 3.3 效果与小结 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;结合对业界现有理念与实践的分析，我们基于代码安全指南在公司级框架上建设了一系列“默认安全”的组件，并设计了一系列检查工具嵌入在统一的研发基础设施中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;理想情况下，组件是和代码安全指南高度对应的。举个例子，&lt;strong&gt;开发人员&lt;/strong&gt;在Go项目编写资源请求功能时，&lt;strong&gt;无需在每个项目中自行实现SSRF防御逻辑，只需引入组件即可快速实现业务功能，又确保安全。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6251874&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zuHtetFV4maicx5P1DCicByoaHdLEKJUibGFkV3H0LmKSEChVRbMibDDnng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;667&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;由此带来的&lt;span&gt;&lt;strong&gt;收益&lt;/strong&gt;&lt;/span&gt;是：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;(1) 更高的业务接受度，安全机制内置在功能组件中，使用几乎无感知，且会被当作一种最佳业务实践口口相传，逐步获得高覆盖度&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(2) 代码安全检查更准确方便&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(3) 研发效能的提升，开发人员无需自行、重复实现安全校验/检查代码&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当然，上述工作也给安全和基础组件研发团队提出了&lt;strong&gt;挑战：既要对应用安全风险有全面且深入的了解，在开发安全组件时，还要兼顾功能灵活性（业务需求）和安全性（安全需求）。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Ⅳ. 总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;综上，借助代码安全指南、默认安全框架组件、嵌入基础设施的静态代码安全检查三项机制联动，我们试图在软件研发生命周期的最初阶段收敛漏洞。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2037736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zqx8RSaXVP0CfVovbibW4dKvBlAqkhibibNU1qzzl8ibuEyDMBqHg519Xpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;795&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在上述框架下，研发和安全人员日常开展工作的模式为：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 研发人员&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;(1) 阅读学习代码安全指南、安全组件文档&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(2) 业务基于统一框架、组件设计功能，聚焦于业务逻辑&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(3) 使用自助安全检查工具，在DevOps各环节检查漏洞，漏洞修复指引会链接回代码安全规范，形成闭环。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 安全人员&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;(1) 有新的漏洞进来 -&amp;gt; 分析提炼漏洞模式（变体分析）-&amp;gt; 沉淀至代码安全规范&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(2) 基于代码安全规范编写检查规则（浅层和深层）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;(3) 推出对应的安全组件&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在安全左移探索过程中仍有许多机制尚待优化，我们希望通过逐步开源上述解决方案，与业界一道丰富安全左移的理论和实践。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上述探索过程中，获得了基础设施研发团队（框架、持续集成平台）、业务侧研发安全团队的支持，在此献上诚挚的谢意。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1] Kern, Christoph. &quot;Preventing security bugs through software design.&quot; (2015).&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2] Wang, Pei, Julian Bangert, and Christoph Kern. &quot;If It’s Not Secure, It Should Not Compile: Preventing DOM-Based XSS in Large-Scale Web Development with API Hardening.&quot; 2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE). IEEE, 2021.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[3] Adkins, Heather, et al. Building Secure and Reliable Systems: Best Practices for Designing, Implementing, and Maintaining Systems. O&#x27;Reilly Media, 2020.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[4] 轻量级开源SAST工具semgrep分析&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;# 推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;安全左移系列&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzE1NjA0MQ==&amp;amp;mid=2651204486&amp;amp;idx=1&amp;amp;sn=f4b649182545b51adada5f308ce17b83&amp;amp;chksm=bd2cce208a5b4736a37ec50318c05cab22dc4319196337afb92b701e4120e25e399605a4581a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.4255556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5znJb1nbPWnRiapglENPlpjCCyFWPVUichicBxkK0XQ7hnJHjXIw2Ds4VjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;腾讯研发安全团队&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;腾讯公司内部与自研业务贴合最紧密的一线安全工程团队之一。团队负责软件生命周期各阶段的安全机制建设，包括：制定安全规范/标准/流程、实施内部安全培训、设计安全编码方案、构建安全漏洞检测（SAST/DAST/IAST）与Web应用防护（WAF）系统等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在持续为QQ、微信、云、游戏等重点业务提供服务外，也将积累十余年的安全经验向外部输出。通过为腾讯云的漏洞扫描、WAF等产品提供底层技术支撑，助力产业互联网客户安全能力升级。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/JMH1pEQ7qP6Cm4l50Guk4hQnsUbjIA5zLfBM7YHVxrcFIE0AT3IDzeVPkfCyamLGbvdlObS7HX6jQ48E0J1Jiaw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;点击【阅读原文】访问&lt;strong&gt;腾讯代码安全指南&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>db2d60cd66dd8a5834a32b59f552962f</guid>
<title>性能分析场景下，一种实时分位数计算的系统及方法</title>
<link>https://toutiao.io/k/4vo46r0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;960&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9xvkqvD6o9s7zbeyK87RuCEd618PIDRzBAcxJXeqjQbaFEM3Ok4tDpeicG4Xrrx2vczuJcic9EF9RQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;性能分析等场景对实时分位数有强烈诉求。在计算累计时长时，可以将不同时间段的时长简单相加，而分位数却无法先计算不同维度下的分位值，然后对其直接聚合，该特性对实时计算带来了较大挑战。我们基于TDigest数据结构，利用Redis和Doris等高性能存储，预先计算所有可能查询的分位值指标，既可以快速计算指标，同时可以保障查询效率。该系统已经对百度内内核性能、网络性能等业务场景进行输出，并能有效满足业务高时效的分析需求。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;全文3663字，预计阅读时间10分钟。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;一、问题描述与技术挑战&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实际工作中，我们发现许多业务场景中都有对某一数值型指标实时统计分位数的需求，一般要求计算结果有很高准确率同时具备极低的计算延迟，实现这类需求给数据RD的开发工作带来一定的挑战，其中主要的技术挑战包括以下三个方面：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;无法对全量数据进行排序&lt;/span&gt;：由于在实时计算场景中是逐条处理数据的，无法对全量数据排序，进而无法获得全量数据的分位数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;计算逻辑复杂，计算延迟高&lt;/span&gt;：即时在能够排序的场景中，高复杂度的排序操作也会带来很高的计算延迟，无法满足实时计算的低延迟要求&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;分位数结果无法聚合&lt;/span&gt;：两个计算得出的分位数结果无法像求和结果那样直接累加合并得到新的结果，这为分位数计算结果的存储方式带来挑战&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对上述问题，我们基于TDigest数据结构，实现了实时计算环境下的分位数计算方法，封装为基础组件并向上提供API接口，可以在不同的业务场景（内核性能、搜索性能、PUSH等）下提供实时、准确的分位数计算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、基础架构与解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本节我们将从计算分位数的常用数据结构、我们实现分位数计算的基础架构、解决方案三部分介绍流式计算场景下的分位数计算方法：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.1 分位数的常用数据结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TDigest计算分位数&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;TDigest是一个简单，快速，精确度高，可并行化的近似百分位算法，被Spark, ES, Kylin等系统使用。TDigest的核心思想是通过聚类的方法将离散的数据点聚集为多个不同的质心，在通过线性插值法计算分位数，线性插值法是最简单的插值算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通俗的讲：传统方法是对离散的数据进行排序，在排序结果中直接获得分位数。而TDigest是将离散的数据聚类为多个质心，然后对质心进行近似的“排序”，最后通过插值法求取分位数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.42838709677419357&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9xvkqvD6o9s7zbeyK87RuCP1Z87Sb6d5SL83nr78EQic1dnN0axzVU38CQian5F2tTwG3QnyQD1MFQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，将离散的数据点(图中无色的数据点)聚类为多个不同的质心(图中彩色的数据点)，其中每个质心周围的数据点数决定了该质心所占的权重(图中质心的大小)，最后通过对所有的质心进行排序，就可以使用线性插值法求取对应的分位数，其中数据点与质心的距离和权重关系如下图所示。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6880466472303207&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9xvkqvD6o9s7zbeyK87RuCF8P3W4RgSuY8059z1zWtwVE1wgSB7Bm2J1jppKDdlQqJIjjRuGwhicw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;特别地，在每个TDigest创建时有一个重要的compression参数，主要用于在计算的精确度与空间复杂度之间做权衡：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当compression参数设置越大时，聚类得到的质心越多，则差分法求取的分位数精确度越高&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当compression参数设置越大时，TDigest数据结构占用的存储空间越大，则分位数计算的空间复杂度越高&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设置合适的compression参数，能够在提高计算准确率的同时，尽可能降低存储空间，从而满足业务的实际需求&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了帮助大家在做分位数计算时能够选取合适的参数，我们选择百万级的数据量(即统计100w个随机变量的分位数)，在不同参数下的计算精确度和空间复杂的如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8942857142857142&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;700&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9xvkqvD6o9s7zbeyK87RuCkLrvWVlic0ypQ5LkhtpImFJKPFBwPzicw5YzasmOYkMLicRcuoEIGsmqg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对上表所示的数据，我们将做出以下三点说明：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本次测试使用MergingDigest数据结构，该结构占用的空间与compression参数的取值有关，与统计的数据量无关；&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;随着数据量的增大，compression的取值应适当增大，能够有效提高计算的准确率&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.2 分位数组建的基础架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于实时分位数计算是一个常见统计方法，在许多业务场景都会提出类似的需求，对需求方关注的统计指标计算不同的分位数。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为节约人力成本，缩短迭代开发的时间周期，我们基于TDigest数据结构，封装了通用的基础组件，从而在不同的业务场景下快速实现实时分位数统计的开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2814667988107037&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1009&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9xvkqvD6o9s7zbeyK87RuCTqKtX1yoUMibhnAXPE950c0DEV2RZaZiakrkmCneKPhpA3eESmGYKfSw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，在实时分位数计算的通用组件中，其基础架构和执行过程主要分为以下几个关键步骤：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1) 从上游业务方读取需要统计分位数的原始数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2) 根据业务方需求的分组规则，按分组聚合为TDigest数据结构，将聚合结果存入Redis中，或与Redis中已存在对应的数据进行合并，以获取准确的计算结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3) 从TDigest结构中获取分位数的计算结果，并向上返回&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;综上所述，我们通过封装基础组件并向上提供API的方式，实现了通用、灵活且对应用方透明的分位数计算方法，能够保证实时性的同时，实现高准确率、低空间复杂度的分位数计算，目前已经在性能平台、搜索、PUSH等厂内多个业务需求中落地应用&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.3 整体实现方案&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于上述介绍的实时分位数基础组件，在厂内的大多数业务场景中，通常从消息队列中获取应用方上报的原始数据，经过一系列解析和计算后，将计算结果存储Doris等OLAP引擎或DB中，共需求方查询和生成对应报表，这是一个通用的解决方案。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;根据上述分析，我们就可以得到一个分位数实时计算作业的基本架构，其架构模型如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2157279489904357&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9xvkqvD6o9s7zbeyK87RuCC4WtmgCiaPCoOGTb9cMCiclJe7KJulc6besy8grsJUfJKvMrcg3w1d8g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，在厂内的环境中，实时分位数计算任务的常用基本架构主要包括以下几个关键步骤：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）从消息队列中读取业务方上报的基础数据，并按业务逻辑进行数据解析；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）通过FlatMap方法，按不同字段将一条数据展开为多条（具体内容将在第3节详细介绍）；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）根据业务设计的查询维度，按不同的key对数据进行分组操作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）分别将每个key的数据合并为一个TDigest数据结构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5）将聚合后的数据与Redis中存储的数据进行合并，同时将合并结果写回Redis中&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6）最后根据数据聚合结构，从每个分组对应的TDigest结构中获取对应的分位数&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;综过以上步骤，可以实现高实时性、高精确度和低空间复杂度的实时分位数计算方法，能够满足大多数实时分位数业务的需求，在更多的业务场景中可能需要根据实际需求进行适当的调整。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、解决分位数无法聚合的问题&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3.1 问题描述&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在实际的业务需求中，我们可能需要按照不同的时间、查询维度等信息检索统计的分位数。但是，已经计算好的两个分位数结果是无法进行聚合操作的。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;例如：针对手百APP的用户访问时长，我们可以将某一天中每个小时访问时长的和(SUM)进行累加，从而获得这一天的访问时长总和。但我们如果记录了每个小时中访问时长的80分位数，则无法对这些分位数进行聚合，即无法求得这一天中访问时长的80分位数。这种现象被称为分位数的“不可聚合性”&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;因此，在实际应用中，如果业务需求要对不同时间、不同维度下的指标分位数进行任意聚合、查询等操作，就为分位数的计算和存储提出新的技术挑战。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2 分位数聚合方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对上述问题，我们提出按所有查询维度进行提前聚合计算的解决方案，即针对每一种可能出现的查询维度组合，我们都提前计算分位数并存储，这样在查询过程中直接检索对应查询维度的聚合计算结果，在解决了分位数的“不可聚合性”问题的同时，也避免了重复的聚合计算带来的时间开销，缩短了查询耗时，提升了用户体验。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来，我们通过一个简单实例讲解具体的聚合计算方法：假设在某业务场景中，用户关注的查询维度共有三个字段，分别为：APP版本(app_version)、厂商(manufacturer)和客户端操作系统版本(os_version)。则对于任意维度组合的查询操作，用户有可能采用 2^3=8 种聚合查询方式。因此，我们通过排列组合的方式，枚举中所有可能的聚合查询方式，分别统计分位数。假设从上游读取到的部分数据如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5748587570621468&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;708&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9xvkqvD6o9s7zbeyK87RuCMeKxJhCKLVQQ8uJaZLia2ZNEcnQTkPXlzhyN2X4ibsHDiaEs874trpoOg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并且，如果对某一字段进行聚合查询，我们将该字段的取值记为关键词 “ALL”，则这条数据共对应2^3=8 种可能的聚合查询方式。为了模拟出8种不同的维度排列组合方式，我们利用二进制排列组合的方式，让每个字段严格对应二进制数据中的一位：如果该位的取值为0，则字段内容为上报的原始值（即上表中的实际取值）；若该位的取值为1，则对应字段的取值记为关键词“ALL”。此外，二进制数据中从右至左每一位与字段的对应关系为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第1位对应os_version&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第2位对应manufacturer&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第3位对应app_version&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由此可得，任意字段聚合查询的排列如何方式如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.471671388101983&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5p8giadRibbO9xvkqvD6o9s7zbeyK87RuC4BI2SxLuciawbxhAgmGBYZQ2DWnr7ia1dyyan6G1p9EbSpX9vyhvcaeA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这样，我们就通过二进制排列组合的方式，枚举出所有可能的维度组合查询方式。在实际的计算过程中，可以利用流式计算的FlatMap算子，按照上述的排列组合方式，将一条数据扩展为多条数据，并进行分组聚合、计算分位数，将最终的计算结果存入Doris等存储引擎中供用户查询。此时，计算结果中实际已经包含了所有可能的聚合查询方式，业务方可以按需要直接查询到最终的分位数结果，而无需另外进行聚合计算操作，在有效提高查询效率的同时保证了用户体验。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;四、结语&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以上内容是我们从宏观的角度，对实时分位数计算方法的核心技术、基础架构和技术难点进行了简要介绍。如有任何问题或建议，欢迎大家随时沟通交流。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本期作者 | 子阳，负责百度性能平台的实时数据开发工作，主要研究方向为流式计算、智能预测等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;招聘信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;百度APP技术平台研发部负责百度APP和百家号技术平台建设，也承载着PUSH、消息、互动、交易、日志、性能、审核、B端等一系列标杆中台的建设，欢迎大家加盟，期待着你的到来！ &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;无论你是后端，前端，还是大数据，这里有若干职位在等你，欢迎投递简历，百度APP技术平台研发部期待你的加入！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;简历投递：geektalk@baidu.com （投递备注【百度APP技术】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;lt;EOF&amp;gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;高可用架构技术直播活动预告：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;高可用架构直播又来了！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;PolarDB 是下一代云原生关系型数据库。其发布以来就以高性能，高并发等能力备受关注。因此我们邀请了阿里云数据库产品事业部高级技术专家，著名开源项目pika的作者，陈宗志老师为了揭秘PolarDB 内核实现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;周三（5月26日）晚上8点，直播室见。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.7786666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOMGYjkQPyDvYVI38eBsn9kn0CBzGDmR0wSwxbqlLu1oORjd3PX0pDicbIvG0ZOcfV5qPmS61uiakqRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;高可用架构&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;改变互联网的构建方式&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;img data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;200&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOPOK9rQud9XibGhPOPsA3gA8Wr4CEnzmhfZQzSGu0Q09GOuk18S9icZtuVnQewvyqZtOWyDnJPBDn1A/640?wx_fmt=jpeg&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>