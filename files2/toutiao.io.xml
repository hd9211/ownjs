<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>81a426122bacfc3c908f02b1c37a1ad7</guid>
<title>字节跳动前端日常实习一二三面面经（Offer 还愿）</title>
<link>https://toutiao.io/k/lu4qgp2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-topic-des nc-post-content&quot;&gt;
&lt;h1&gt; 时间线 &lt;/h1&gt; 
&lt;p&gt;
  5.19投递简历 
&lt;/p&gt; 
&lt;p&gt;
  5.20hr约一面 
&lt;/p&gt; 
&lt;p&gt;
  5.24一面 
&lt;/p&gt; 
&lt;p&gt;
  5.25中午一面通过，hr约二面时间。本来约的是6月1号，但面试官临时请假，改到了3号 
&lt;/p&gt; 
&lt;p&gt;
  6.3二面 
&lt;/p&gt; 
&lt;p&gt;
  6.4下午二面通过，hr约三面时间 
&lt;/p&gt; 
&lt;p&gt;
  6.8三面 
&lt;/p&gt; 
&lt;p&gt;
  6.9中午三面通过，hr约10号三面 
&lt;/p&gt; 
&lt;p&gt;
  有些问题可能不是面试官的本意，还有一些问题没听懂，从场景题提取问题出来还是挺难的 
&lt;/p&gt; 
&lt;div&gt;
 &lt;span&gt; 其实15号中午的时候就offer了，现在来添加&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%9D%A2%E7%BB%8F&quot; target=&quot;_blank&quot;&gt;面经&lt;/a&gt;答案，答案只是我的见解哈，有些部分也没给出来，如果有错误欢迎指出 &lt;/span&gt;
&lt;/div&gt; 
 
&lt;h1&gt; &lt;span&gt;&lt;span&gt;一面（&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;50mins）&lt;/span&gt;&lt;/span&gt; &lt;/h1&gt; 
&lt;div&gt; 
 &lt;span&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么判断两个网站是否同域&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;浏览器从一个域向另一个域的服务器发送请求来访问其资源。 浏览器的同源策略：协议、域名、端口号一致。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;保持登录状态能够使用什么实现&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;cookie,token&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;externals是怎么实现的&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span/&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;你这些外部的资源是存在公共的CDN上，还是有现成可以直接用的托管CDN&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;回答了公共的CDN&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;是哪种类型的CDN呢，具体是哪些域名&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;为什么CDN能够加速用户访问一个网站，它的原理是什么&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;最简单的CDN网络由一个DNS服务器和几台缓存服务器组成：&lt;/span&gt; &lt;/p&gt; 
     &lt;ol&gt; 
      &lt;li&gt; &lt;p&gt; &lt;span&gt;当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;用户向CDN的全局负载均衡设备发起内容URL访问请求&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;全局负载均衡设备把服务器的IP地址返回给用户&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
     &lt;/ol&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么确定哪个CDN节点离用户最近呢&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;上个问题答案的第4.5点&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;假设同样的资源，我用域名去访问，访问到哪个服务器取决于什么？&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;DNS &lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;DNS解析过程&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/yanshuanche3765/article/details/82589210&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;简单的来说，浏览器先检查自身有没有缓存，如果没有就检查操作系统有没有缓存，如果还是没有就会向本地域名服务器发起一个请求来解析这个域名；如果本地域名服务器还是没有，则会从根域名服务器开始递归查找域名，直到找到为止。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;DNS解析过程中，某个DNS服务器的记录被篡改过，指向一个恶意网站，这种情况会对用户的访问造成安全风险，这么防范。怎么防范DNS污染（应该是这个问题）&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;感觉这个问题不是很重要&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;DNS使用什么网络协议&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_41563161/article/details/106069473?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;amp;spm=1001.2101.3001.4242&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;DNS区域传输的时候使用TCP协议：&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;1.辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;2.TCP是一种可靠连接，保证了数据的准确性。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;域名解析时使用UDP协议：&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;除了打包体积减小，还有哪些手段可以提升用户的访问速度&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;缓存，懒加载，代码优化，SSR...&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;HTTP缓存怎么设置&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/jiang_yonghui/article/details/100569565&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考这个&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;通过设置Cache-Control/Pragma、Expires(过期时间)、Last-Modified/Etag。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;确定协商缓存有效性的协商过程是怎么样的&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;在第一次请求服务器时，服务器会返回资源，并且返回一个资源的缓存标识，一起存到浏览器的缓存数据库。当第二次请求资源时，浏览器会首先将缓存标识发送给服务器，服务器拿到标识后判断标识是否匹配，如果不匹配，表示资源有更新，服务器会将新数据和新的缓存标识一起返回到浏览器；如果缓存标识匹配，表示资源没有更新，并且返回 &lt;/span&gt;&lt;span&gt;304&lt;/span&gt;&lt;span&gt; 状态码，浏览器就读取本地缓存服务器中的数据。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;有些资源打开页面的时候不需要，需要的时候在加载&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/bury_/article/details/79516223&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;懒加载原理&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;懒加载&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;不同类型的东西处理方式不一样，例如图片，js代码，他们分别怎么懒加载&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;js通过设置defer和async&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;建议图片懒加载多去看看实现方法&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/w1418899532/article/details/90515969?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;图片懒加载&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;有没有更简单的方式去判断图片离浏览器顶部距离的方法&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;阮一峰老师的文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;面试官建议：intersectionObserver?这个API，可以监控一个元素即将进入到窗口的范围&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;说一下Vue的工作原理（响应式原理）&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Vue响应式底层实现方法是 Object.defineProperty() 方法，该方法中存在一个getter和setter的可选项，可以对属性值的获取和设置造成影响&lt;/span&gt; &lt;/p&gt; 
     &lt;ul&gt; 
      &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;当你把一个普通的 &lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=JavaScript&quot; target=&quot;_blank&quot;&gt;JavaScript&lt;/a&gt; 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
     &lt;/ul&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;我改变了一个Data中数据后，他怎么更新到实际页面的DOM，这个过程是怎样的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;模板里面，对于一个字段的引用是怎么收集的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;对于这个字段的依赖是在什么时候建立的呢，是怎么建立的呢&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;假设有A，B两个请求，希望在A请求完后拿到一个结果，之后将A的结果作为参数给B，B发起请求，这样的过程要怎么实现&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;异步操作&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;如果A，B没有依赖关系，希望两个都拿到结果之后，在执行一些操作，要怎么实现&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Promise.all&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;你提到Promise.all，那假设浏览器没有这个东西，你给我整一个&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;div&gt; 
      &lt;span&gt;接下来是20分钟的修改代码过程...&lt;/span&gt;
      &lt;span&gt; &lt;pre class=&quot;prettyprint lang-js&quot; from-niu=&quot;default&quot;&gt;function myPromiseAll(promises) {
  let results = [];
  let promiseCount = 0;
  let promisesLength = promises.length;
  return new Promise(function(resolve, reject) {
    for(let i = 0; i &amp;lt; promises.length; i++){
      Promise.resolve(promises[i]).then(function(res) {
        promiseCount++;
        results[i] = res;
        // 当所有函数都正确执行了，resolve输出所有返回结果。
        if (promiseCount === promisesLength) {
          return resolve(results);
        }
      }, function(err) {
        return reject(err);
      });
    }
  });
};
&lt;/pre&gt; &lt;br/&gt; &lt;span/&gt;&lt;/span&gt; 
     &lt;/div&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;反问&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;部门：交叉面试&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;建议：多实践&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
  &lt;/ol&gt; &lt;br/&gt; &lt;/span&gt; 
&lt;/div&gt; 
&lt;h1&gt; &lt;span&gt;&lt;span&gt;二面（&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;38mins）&lt;/span&gt;&lt;/span&gt; &lt;/h1&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;简单问了下&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;的东西&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;里有订单管理的功能，一般来说订单要考虑什么状态呢&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;如何实时拿到这些状态呢&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;最近在学什么呢&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;span&gt; &lt;p&gt; &lt;span&gt;vue框架有什么特点&lt;/span&gt; &lt;/p&gt; 
   &lt;blockquote&gt; 
    &lt;p&gt; &lt;span&gt;数据驱动、组件化&lt;/span&gt; &lt;/p&gt; 
   &lt;/blockquote&gt; &lt;/span&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;手撕代码（写完说思路&lt;/span&gt; &lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;div&gt; 
    &lt;span&gt;&lt;span&gt;冒泡，快速&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt; &lt;/span&gt;&lt;pre class=&quot;prettyprint lang-js&quot; from-niu=&quot;default&quot;&gt;function bubbleSort(array){
    let length = array.length;
    for(let i = 0; i &amp;lt; length - 1; i++){
        for(let j = 0; j &amp;lt; length - i -1; j++){
            if(array[j] &amp;lt; array[j+1]){
                [array[j],array[j+1]] = [array[j+1],array[j]];
            }
        }
    }
}

let test = [6,8,4,5,1];
bubbleSort(test);
console.log(test);

function quickSort(array){
    if(array.length &amp;lt; 2) return array;
    let leftArray = [];
    let rightArray = [];
    let base = array[0];
    array.forEach((element) =&amp;gt; {
        if(element &amp;gt; base){
            leftArray.push(element);
        } else if(element &amp;lt; base){
            rightArray.push(element);
        }
    });
    return quickSort(leftArray).concat(base,quickSort(rightArray));
};

let test2 = [5,3,2,1,4];
let res = quickSort(test2);

console.log(res);&lt;/pre&gt; &lt;br/&gt; &lt;span/&gt;&lt;/span&gt; 
   &lt;/div&gt; 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt; &lt;span&gt;实现一个函数，把一个字符串数组（[&#x27;zm&#x27;, &#x27;za&#x27;, &#x27;b&#x27;, &#x27;lm&#x27;, &#x27;ln&#x27;, &#x27;k&#x27;]）格式化成一个对象 { &#x27;b&#x27;: [&#x27;b&#x27;], &#x27;k&#x27;: [&#x27;k&#x27;], &#x27;l&#x27;: [&#x27;lm&#x27;, &#x27;ln&#x27;], &#x27;z&#x27;: [&#x27;za&#x27;, &#x27;zm&#x27;] }&lt;/span&gt; &lt;/p&gt; 
  &lt;/blockquote&gt; &lt;p&gt; &lt;span&gt;这道题没写完整，说了下思路用伪代码写了下。&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;近一两年的规划&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt; &lt;p&gt; &lt;span&gt;为什么选择字节&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt; &lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
&lt;/ol&gt; 
&lt;h1&gt; &lt;span&gt;&lt;span&gt;三面6.8（&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;38mins）&lt;/span&gt;&lt;span/&gt;&lt;/span&gt; &lt;/h1&gt; 
&lt;div&gt; 
 &lt;span&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt; &lt;span&gt;聊了下之前的笔试&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;参与之前的面试下来，有什么感受，有没有总结出自己的长处与短板&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;提到了要深入学原理&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%BA%90%E7%A0%81&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;啥的&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;你打算怎么看&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%BA%90%E7%A0%81&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;聊一下&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;为什么做这个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;有没有你自己想的一些功能&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;怎样从零搭建&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/baidu_41690072/article/details/88820400&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;感觉就是看你是不是真的自己做了一遍&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;使用vue-cli初始化的步骤&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;vue-cli主要帮你完成了哪些事情&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;1.ES6代码转换成ES5代码 2. scss/sass/less/stylus转css 3. .vue文件转换成js文件 4. 使用 jpg、png，font等资源文件 4. 自动添加css各浏览器产商的前缀 5. 代码热更新 6. 资源预加载 7. 每次构建代码清除之前生成的代码 8. 定义环境变量 9. 区分开发环境打包跟生产环境打包 ......&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;其中生成的那些文件，分别是干什么的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;packjson文件里有一些key，value。其中一个key叫dependencies和devDependencies，能说说作用吗&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;package.json:&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;主要用来定义&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;中需要依赖的包&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;package-lock.json：&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;在 &lt;/span&gt;&lt;span&gt;npm install&lt;/span&gt;&lt;span&gt;时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&#x27;^&#x27; :&lt;/span&gt;放在版本号之前，表示向后兼容依赖，说白了就是在大版本号不变的情况下，下载最新版的包 &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;中引入的包版本号之前经常会加^号，每次在执行npm install之后，下载的包都会发生变化，为了系统的稳定性考虑，每次执行完npm install之后会对应生成package-lock文件，该文件记录了上一次安装的具体的版本号，相当于是提供了一个参考，在出现版本兼容性问题的时候，就可以参考这个文件来修改版本号即可。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; 
    &lt;blockquote&gt; 
     &lt;ol&gt; 
      &lt;li&gt; &lt;p&gt; &lt;span&gt;“dependencies”&lt;/span&gt;&lt;span&gt; 运行依赖，需引入页面使用&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
      &lt;li&gt; &lt;p&gt; &lt;span&gt;“devDependencies”&lt;/span&gt;&lt;span&gt; 开发依赖(生产环境使用)，只是开发阶段需要&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
     &lt;/ol&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;babel.config.js的作用&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Babel是一个JS编译器，主要作用是将ECMAScript 2015+ 版本的代码，转换为向后兼容的JS语法，以便能够运行在当前和旧版本的浏览器或其它环境中。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;Vue&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;中普遍使用ES6语法，若要求兼容低版本浏览器，就需要引入Babel，将ES6转换为ES5。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;babel怎么把es6转成es5&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;es6哪些特性你觉得比较常用或者好用&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;let const var区别&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;变量提升方面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;let和const不存在变量提升问题(&lt;/span&gt;&lt;span&gt;注意这个‘问题’后缀，其实是有提升的，只不过是let和const具有一个暂时性死区的概念，即没有到其赋值时，之前就不能用&lt;/span&gt;&lt;span&gt;)，即它们所声明的变量一定要在声明后使用，否则报错。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;块级作用域方面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：var不存在块级作用域,let和const存在块级作用域&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;&lt;strong&gt;声明方面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：var允许重复声明变量,let和const在同一作用域不允许重复声明变量。其中const声明一个只读的常量(因为如此，其声明时就一定要赋值，不然报错)。一旦声明，常量的值就不能改变。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;回到&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;，登录功能怎么实现的&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;token怎么保持登录状态&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/u014322206/article/details/85089481&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;&lt;span&gt;当用户请求页面，输入用户信息，服务端经过验证后，会生成一个token安全令牌（随机字符串），并返回给&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;，当&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;发送下一次请求的时候，直接携带这个token，服务端识别后，就可以直接访问页面，不需要再次登录了&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;sessionStorage有什么优势，token应该放在哪&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/fejerry/p/10898530.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;sessionStorage的特点&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;+各个标签页的sessionStorage 是独立的 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+在a标签页写入修改删除sessionStorage ，不会影响到已经打开的标签页中的sessionStorage 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+通过a标签，window.open,window.location,windows.history ，右键复制 等方式在新标签页，本页，iframe ，新窗口中打开新页面，当前标签页的 sessionStorage 会传递到新页面。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+通过按住 ctrl键打开新标签页，或者右键菜单打开新标签页，新窗口 ，当前标签页的 sessionStorage 是不会传递到新页面的 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+关闭某个标签页，该标签页的sessionStorage 会被销毁。不影响其他标签页或者窗口 。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;+在某个标签页即使跳出了当前站点，返回来的时候，sessionStorage 也还在的 。&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;鉴于它有以上特点 ：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1，可以用来做多账户登录 ， sessionid 不用cookie存储，用 sessionStorage 来存储。spa应用比较适合 。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/qq_43618136/article/details/114656505&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;token存放位置参考&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地“存储”数据而生。而token的安全和性能都是中肯的，唯一的问题就是cookie的存储性能和提取安全性太低，而localstorage更安全而且能够跨会话实现身份鉴别，很明显token应该存在localstorage里。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;localStorage里可以存图片吗，怎么存&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/cockroach02/article/details/49926595&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;我们的想法是做到将已经当前页面中已缓存的图片保存到本地存储中。不过就像我们之前已经确定的，本地存储只支持字符串的存取，那么我们要做的就是将图片转换成 &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Data_URI_scheme&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;&lt;span&gt;Data URI&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt; 。其中一种实现方式就是用canvas元素来加载图片。然后你可以以Data URI的形式从canvas中读取出当前展示的内容。&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;token能放在cookie里吗&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;可以&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;xss能不能取到sessionStorage里的数据&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;可以&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;hash路由和history路由&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;除了这个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;还有别的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;吗&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;翻页功能怎么实现&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;数据是&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;来分页还是后端来分页&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;能实现&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;分页吗&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么实现&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;数据存哪&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;vuex有用过吗&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;vuex的目的是什么&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;已经有sessionStorage这类的放数据的地方，为什么还要有vuex，有什么特别的价值吗&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;聊了下笔试&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;问了下是不是还没有开始复习&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;和数据结构&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;说一个最近在复习的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;再说说对应的例题&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;说了道最大无重复子串，双指针&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;复杂度&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&quot; target=&quot;_blank&quot;&gt;动态规划&lt;/a&gt;一般解决什么样类型的问题&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&quot; target=&quot;_blank&quot;&gt;动态规划&lt;/a&gt;相比于回溯，有什么优势&lt;/span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;异步组件的懒加载是你自己想的还是教程有的&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;怎么实现懒加载&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;优化效果有看过吗&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;看到面评，问实习是想积累经验还是想转正&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;
   &lt;li&gt; &lt;p&gt; &lt;span&gt;反问&lt;/span&gt; &lt;/p&gt; 
    &lt;blockquote&gt; 
     &lt;p&gt; &lt;span&gt;部门：技术中台&lt;/span&gt; &lt;/p&gt; 
     &lt;p&gt; &lt;span&gt;看重实习生哪些方面&lt;/span&gt; &lt;/p&gt; 
    &lt;/blockquote&gt; &lt;/li&gt;
  &lt;/ol&gt; &lt;br/&gt; &lt;/span&gt; 
&lt;/div&gt; 
&lt;h1&gt; 碎碎念 &lt;/h1&gt; 
&lt;div&gt;&lt;p&gt;
  字节的面试官是能够看到你之前投递的简历，参加过的笔试和面试结果，所以如果要投的话一定要认真对待面试和笔试吧。
 &lt;/p&gt;&lt;span&gt;&lt;span&gt;另外我看到&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%89%9B%E5%AE%A2&quot; target=&quot;_blank&quot;&gt;牛客&lt;/a&gt;网也有&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;的课程，笔试面试会涉及到的知识点里边基本都会涵盖，如果大家不知道从哪里开始学起的话可以报名这种课程~&lt;/span&gt;&lt;img data-card-emoji=&quot;[考得全会]&quot; src=&quot;https://uploadfiles.nowcoder.com/images/20191018/63_1571399956257_2484A7DF36877A14689574EEBDA6DD7C&quot;/&gt;&lt;/span&gt; 
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>123f6b0dc0ba56056e8671c24714f668</guid>
<title>[推荐] 我在 GitHub 上读清华</title>
<link>https://toutiao.io/k/d749gee</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2bd1853983d81bad07bef6afff30b30b</guid>
<title>[推荐] 徒手用 Go 写个 Redis 服务器</title>
<link>https://toutiao.io/k/t9ic9wp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNPWkD6xmM3YDpLKRk9icwRvyvo6aWc1Pz3duHADKROA748khObVndvFBt9tZwTqMfIKZ876WHEDibww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;span&gt;作者：HDT3213&lt;br/&gt;&lt;/span&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天给大家带来的开源项目是 Godis：一个用 Go 语言实现的 Redis 服务器。支持：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;5 种数据结构（string、list、hash、set、sortedset）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动过期（TTL）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发布订阅、地理位置、持久化等功能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2294736842105263&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNPWkD6xmM3YDpLKRk9icwRvyyIuib3RuttVFnsljC8XwPgicGkL1zibBcKKAhTERZRwKnzEaesYZhcfXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1900&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你或许不需要自己实现 Redis 服务，但你是否厌烦了每天都是写增删改查的业务代码，想提高编程水平试图从零写个项目打开 IDE 却发现无从下手？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动手造轮子一定是提高编程能力的好办法，下面就带大家用 Go 从零开始写一个 Redis 服务器（Godis），从中你将学到：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如何编写 Go 语言 TCP 服务器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计并实现安全可靠的通信协议（redis 协议）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何使用 Go 语言开发高并发程序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计和实现分布式集群以及分布式事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;熟悉链表、哈希表、跳表以及时间轮等常用数据结构&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;千万不要担心内容太难！！虽然示例代码是 Go，但就算你不会 Go 语言也不会影响你理解 Redis 的原理和底层协议以及高性能的秘密。而且作者为了照顾到广大读者，对技术的讲解做了优化。示例代码在原项目基础上做了简化，并逐行地加了注释。如果是高级玩家，请直接访问项目阅读源码：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/HDT3213/godis&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面让我们一起拨开 Redis 的迷雾。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、写个 TCP 服务器&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知 Redis 是 C/S 模型，使用 TCP 协议进行通信。接下来就从实现 TCP 服务端开始。作为广泛用于服务端的编程语言 Golang 提供了非常简洁的 TCP 接口，所以实现起来十分方便。示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ListenAndServe&lt;/span&gt;&lt;span&gt;(address &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 绑定监听地址&lt;/span&gt;&lt;br/&gt;    listener, err := net.Listen(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, address)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        log.Fatal(fmt.Sprintf(&lt;span&gt;&quot;listen err: %v&quot;&lt;/span&gt;, err))&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; listener.Close()&lt;br/&gt;    log.Println(fmt.Sprintf(&lt;span&gt;&quot;bind: %s, start listening...&quot;&lt;/span&gt;, address))&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// Accept 会一直阻塞直到有新的连接建立或者listen中断才会返回&lt;/span&gt;&lt;br/&gt;        conn, err := listener.Accept()&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 通常是由于listener被关闭无法继续监听导致的错误&lt;/span&gt;&lt;br/&gt;            log.Fatal(fmt.Sprintf(&lt;span&gt;&quot;accept err: %v&quot;&lt;/span&gt;, err))&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 开启新的 goroutine 处理该连接&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; Handle(conn)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Handle&lt;/span&gt;&lt;span&gt;(conn net.Conn)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    reader := bufio.NewReader(conn)&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// ReadString 会一直阻塞直到遇到分隔符 &#x27;\n&#x27;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 遇到分隔符后 ReadString 会返回上次遇到分隔符到现在收到的所有数据&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 若在遇到分隔符之前发生异常, ReadString 会返回已收到的数据和错误信息&lt;/span&gt;&lt;br/&gt;        msg, err := reader.ReadString(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 通常遇到的错误是连接中断或被关闭，用io.EOF表示&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err == io.EOF {&lt;br/&gt;                log.Println(&lt;span&gt;&quot;connection close&quot;&lt;/span&gt;)&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                log.Println(err)&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        b := []&lt;span&gt;byte&lt;/span&gt;(msg)&lt;br/&gt;        &lt;span&gt;// 将收到的信息发送给客户端&lt;/span&gt;&lt;br/&gt;        conn.Write(b)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    ListenAndServe(&lt;span&gt;&quot;:8000&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;👌 至此只用了 40 行代码就搞定服务端啦！启动上面的 TCP 服务后，在终端中输入 &lt;code&gt;telnet 127.0.0.1 8000&lt;/code&gt; 就可以连接到刚写好的服务器，它会将你发送的消息原样返回给你（所以请不要骂它）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2675925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNPWkD6xmM3YDpLKRk9icwRvyuibu0TPqyuw0zws5DwMnC0m4dRic0QxoiaqrxVsC3ZxU93z9qGVx6licKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 TCP 服务器的非常简单，主协程调用 accept 函数来监听端口，接受新连接后开启一个 Goroutine 来处理它。这种简单的阻塞 IO 模型有些类似于早期的 Tomcat/Apache 服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阻塞 IO 模型是使用&lt;strong&gt;一个线程处理一个连接&lt;/strong&gt;，在没有收到新数据时监听线程处于阻塞状态，直到数据就绪后线程被唤醒进行处理。因为阻塞 IO 模型需要开启大量线程并且频繁地进行上下文切换，所以它的效率很低。而 Redis 使用的 epoll 技术（IO 多路复用）用&lt;strong&gt;一个线程处理大量连接&lt;/strong&gt;，极大地提高了吞吐量。那么我们的 TCP 服务器会比 Redis 慢很多吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然不会，Golang 利用 Goroutine 调度开销远远小于线程调度开销的优势封装出 &lt;code&gt;goroutine-per-connection&lt;/code&gt; 风格的极简接口，而且 net/tcp 库将 epoll 封装成了阻塞 IO 的样子，在享受 epoll 高性能的同时避免了原生 epoll 接口所需的复杂异步代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在作者的电脑上 Redis 每秒可以响应 10.6k 个 PING 命令，而 Godis（完整代码） 的吞吐量为 9.2 kqps 相差并不大。想了解更多 Golang 高性能的㊙️密，可以搜索 &lt;code&gt;go netpoller&lt;/code&gt; 或者 &lt;code&gt;go 语言 网络轮询器&lt;/code&gt; 关键字&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，合格的 TCP 的服务器在关闭的时候不应该一停了之，而需要完成响应已接收的请求、释放 TCP 连接等必要的清理工作。这个功能我们一般称为 &lt;code&gt;优雅关闭&lt;/code&gt; 或者 &lt;code&gt;graceful shutdown&lt;/code&gt;，优雅关闭步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，关闭 listener 停止接受新连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，遍历所有存活连接逐个关闭&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优雅关闭的代码比较多，这里就不完整贴出了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、透视 Redis 协议&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在解决完通信后，下一步就是搞清楚 Redis 的协议，其实就是一套序列化协议类似 JSON、Protocol Buffers，你看底层其实也就是一些基础的知识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自 Redis 2.0 以后的通信统一为 RESP 协议（REdis Serialization Protocol)，该协议易于实现不仅可以高效的被程序解析，还能够被人类读懂容易调试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RESP 是一个二进制安全的文本协议，工作于 TCP 协议上。RESP 以行作为单位，客户端和服务器发送的命令或数据一律以 &lt;code&gt;\r\n&lt;/code&gt;（CRLF）作为换行符。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二进制安全是指允许协议中出现任意字符而不会导致故障。比如 C 语言的字符串以 &lt;code&gt;\0&lt;/code&gt; 作为结尾不允许字符串中间出现 &lt;code&gt;\0&lt;/code&gt;，而 Go 语言的 string 则允许出现 &lt;code&gt;\0&lt;/code&gt;，我们说 Go 语言的 string 是二进制安全的，而 C 语言字符串不是二进制安全的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RESP 的二进制安全性允许我们在 key 或者 value 中包含 &lt;code&gt;\r&lt;/code&gt; 或者 &lt;code&gt;\n&lt;/code&gt; 这样的特殊字符。在使用 Redis 存储 protobuf、msgpack 等二进制数据时，二进制安全性尤为重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RESP 定义了 5 种格式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;简单字符串（Simple String）：服务器用来返回简单的结果，比如 &quot;OK&quot; 非二进制安全，且不允许换行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;错误信息（Error）：服务器用来返回简单的错误信息，比如 &quot;ERR Invalid Synatx&quot; 非二进制安全，且不允许换行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;整数（Integer）：llen、scard 等命令的返回值，64 位有符号整数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字符串（Bulk String）：二进制安全字符串，比如 get 等命令的返回值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数组（Array，又称 Multi Bulk Strings）：Bulk String 数组，客户端发送指令以及 lrange 等命令响应的格式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RESP 通过第一个字符来表示格式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;简单字符串：以&quot;+&quot; 开始， 如：&quot;+OK\r\n&quot;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;错误：以&quot;-&quot; 开始，如：&quot;-ERR Invalid Synatx\r\n&quot;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;整数：以&quot;:&quot;开始，如：&quot;:1\r\n&quot;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字符串：以 &lt;code&gt;$&lt;/code&gt; 开始&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数组：以 &lt;code&gt;*&lt;/code&gt; 开始&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面让我们通过一些实际例子来理解协议。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 字符串&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串（Bulk String）有两行，第一行为 &lt;code&gt;$&lt;/code&gt;+正文长度，第二行为实际内容。如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$3&lt;/span&gt;\r\nSET\r\n&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串（Bulk String）是二进制安全的，就是说可以在 Bulk String 内部包含 &quot;\r\n&quot; 字符（行尾的 CRLF 被隐藏）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$4&lt;/span&gt;&lt;br/&gt;a\r\nb&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 空&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$-1&lt;/code&gt; 表示 nil，比如使用 get 命令查询一个不存在的 key 时，响应即为 &lt;code&gt;$-1&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 数组&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组（Array）格式第一行为 &quot;*&quot;+数组长度，其后是相应数量的 字符串（Bulk String）。比如 &lt;code&gt;[&quot;foo&quot;, &quot;bar&quot;]&lt;/code&gt; 的报文（传输时的内容）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;*2&lt;br/&gt;&lt;span&gt;$3&lt;/span&gt;&lt;br/&gt;foo&lt;br/&gt;&lt;span&gt;$3&lt;/span&gt;&lt;br/&gt;bar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端也使用 数组（Array）格式向服务端发送指令。命令本身将作为第一个参数，比如 &lt;code&gt;SET key value&lt;/code&gt; 指令的 RESP 报文：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;*3&lt;br/&gt;&lt;span&gt;$3&lt;/span&gt;&lt;br/&gt;SET&lt;br/&gt;&lt;span&gt;$3&lt;/span&gt;&lt;br/&gt;key&lt;br/&gt;&lt;span&gt;$5&lt;/span&gt;&lt;br/&gt;value&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将换行符打印出来：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 解析预备&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道常用的 RESP 报文内容后，就可以开始着手解析了。但需要注意的是 RESP 是 &lt;code&gt;二进制安全&lt;/code&gt; 的协议，它允许在正文中使用 &lt;code&gt;\r\n&lt;/code&gt; 字符。举例来说 Redis 可以正确接收并执行 &lt;code&gt;SET &quot;a\r\nb&quot; hellogithub&lt;/code&gt; 指令，这条指令的正确报文是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;*3  &lt;br/&gt;&lt;span&gt;$3&lt;/span&gt;&lt;br/&gt;SET&lt;br/&gt;&lt;span&gt;$4&lt;/span&gt;&lt;br/&gt;a\r\nb &lt;br/&gt;&lt;span&gt;$11&lt;/span&gt;&lt;br/&gt;hellogithub&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 &lt;code&gt;ReadBytes&lt;/code&gt; 读取到第五行 &quot;a\r\nb\r\n&quot; 时会将其误认为两行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;*3  &lt;br/&gt;&lt;span&gt;$3&lt;/span&gt;&lt;br/&gt;SET&lt;br/&gt;&lt;span&gt;$4&lt;/span&gt;&lt;br/&gt;a  // 错误的分行&lt;br/&gt;b // 错误的分行&lt;br/&gt;&lt;span&gt;$11&lt;/span&gt;&lt;br/&gt;hellogithub&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此当读取到第四行 &lt;code&gt;$4&lt;/code&gt; 后，不应该继续使用 &lt;code&gt;ReadBytes(&#x27;\n&#x27;)&lt;/code&gt; 读取下一行，应使用 &lt;code&gt;io.ReadFull(reader, msg)&lt;/code&gt; 方法来读取指定长度的内容。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;msg = &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;// 正文长度4 + 换行符长度2&lt;/span&gt;&lt;br/&gt;_, err = io.ReadFull(reader, msg)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 编写 RESP 协议解析器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决完上面内容包含 &quot;\r\n&quot; 的问题，我们就可以开始放手编写 Redis 协议解析器啦！&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Payload &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Data redis.Reply&lt;br/&gt; Err  error&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ParseStream 通过 io.Reader 读取数据并将结果通过 channel 将结果返回给调用者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 流式处理的接口适合供客户端/服务端使用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ParseStream&lt;/span&gt;&lt;span&gt;(reader io.Reader)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; *&lt;span&gt;Payload&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; *Payload)&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; parse0(reader, ch)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; ch&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于解析器的代码比较多，这里只简单地介绍一下核心流程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;parse0&lt;/span&gt;&lt;span&gt;(reader io.Reader, ch &lt;span&gt;chan&lt;/span&gt;&amp;lt;- *Payload)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 初始化读取状态&lt;/span&gt;&lt;br/&gt;    readingMultiLine := &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    expectedArgsCount := &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; args [][]&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; bulkLen &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 上文中我们提到 RESP 是以行为单位的&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 因为行分为简单字符串和二进制安全的 BulkString，我们需要封装一个 readLine 函数来兼容&lt;/span&gt;&lt;br/&gt;        line, err = readLine(reader, bulkLen)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; { &lt;br/&gt;            &lt;span&gt;// 处理错误&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 接下来我们对刚刚读取的行进行解析&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 我们简单的将 Reply 分为两类:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 单行: StatusReply, IntReply, ErrorReply&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 多行: BulkReply, MultiBulkReply&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; !readingMultiLine {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; isMulitBulkHeader(line) {&lt;br/&gt;                &lt;span&gt;// 我们收到了 MulitBulkReply 的第一行&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 获得 MulitBulkReply 中 BulkString 的个数&lt;/span&gt;&lt;br/&gt;                expectedArgsCount = parseMulitBulkHeader(line)&lt;br/&gt;                &lt;span&gt;// 等待 MulitBulkReply 后续行&lt;/span&gt;&lt;br/&gt;                readingMultiLine = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; isBulkHeader(line) {&lt;br/&gt;                &lt;span&gt;// 我们收到了 BulkReply 的第一行&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 获得 BulkReply 第二行的长度, 通过 bulkLen 告诉 readLine 函数下一行 BulkString 的长度&lt;/span&gt;&lt;br/&gt;                bulkLen = parseBulkHeader()&lt;br/&gt;                &lt;span&gt;// 这个 Reply 中一共有 1 个 BulkString&lt;/span&gt;&lt;br/&gt;                expectedArgsCount = &lt;span&gt;1&lt;/span&gt; &lt;br/&gt;                &lt;span&gt;// 等待 BulkReply 后续行&lt;/span&gt;&lt;br/&gt;                readingMultiLine = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// 处理 StatusReply, IntReply, ErrorReply 等单行 Reply&lt;/span&gt;&lt;br/&gt;                reply := parseSingleLineReply(line)&lt;br/&gt;                &lt;span&gt;// 通过 ch 返回结果&lt;/span&gt;&lt;br/&gt;                emitReply(ch)&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 进入此分支说明我们正在等待 MulitBulkReply 或 BulkReply 的后续行&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// MulitBulkReply 的后续行有两种，BulkHeader 或者 BulkString&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; isBulkHeader(line) {&lt;br/&gt;                bulkLen = parseBulkHeader()&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// 我们正在读取一个 BulkString, 它可能是 MulitBulkReply 或 BulkReply &lt;/span&gt;&lt;br/&gt;                args = &lt;span&gt;append&lt;/span&gt;(args, line)&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(args) == expectedArgsCount { &lt;span&gt;// 我们已经读取了所有后续行&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 通过 ch 返回结果&lt;/span&gt;&lt;br/&gt;                emitReply(ch)&lt;br/&gt;                &lt;span&gt;// 重置状态, 准备解析下一条 Reply&lt;/span&gt;&lt;br/&gt;                readingMultiLine = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;                expectedArgsCount = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;                args = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;                bulkLen = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、实现内存数据库&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此我们已经搞定数据接收和解析的部分了，剩下就是我们应该把数据存在哪里了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;抛开持久化部分，作为基于内存的 KV 数据库 Redis 的所有数据需要都存储在内存中的哈希表，而这个哈希表就是我们今天需要编写的最后一个组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与单线程的 Redis 不同我们实现的 Redis（godis）是并行工作的，所以我们必须考虑各种并发安全问题。常见的并发安全哈希表设计有几种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;sync.map&lt;/code&gt;：Golang 官方提供的并发哈希表，适合读多写少的场景。但是在 &lt;code&gt;m.dirty&lt;/code&gt; 刚被提升后会将 &lt;code&gt;m.read&lt;/code&gt; 复制到新的 &lt;code&gt;m.dirty&lt;/code&gt; 中，在数据量较大的情况下复制操作会阻塞所有协程，存在较大的隐患。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;juc.ConcurrentHashMap&lt;/code&gt;：Java 的并发哈希表采用分段锁实现。在进行扩容时访问哈希表线程都将协助进行 rehash 操作，在 rehash 结束前所有的读写操作都会阻塞。因为缓存数据库中键值对数量巨大且对读写操作响应时间要求较高，使用 juc 的策略是不合适的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;memcached hashtable&lt;/code&gt;：在后台线程进行 rehash 操作时，主线程会判断要访问的哈希槽是否已被 rehash 从而决定操作 old_hashtable 还是操作 new_hashtable。这种设计被称为&lt;strong&gt;渐进式 rehash&lt;/strong&gt; 它的优点是 rehash 操作基本不会阻塞主线程的读写，是最理想的的方案。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但渐进式 rehash 的实现非常复杂，所以 godis 采用 Golang 社区广泛使用的分段锁策略（非上面的三种），就是将 key 分散到固定数量的 shard 中避免进行整体 rehash 操作。shard 是有锁保护的 map，当 shard 进行 rehash 时会阻塞 shard 内的读写，但不会对其他 shard 造成影响。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5855728429985856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNPWkD6xmM3YDpLKRk9icwRvyAgDiaNQU6ny3uGJqrZIhKlT4MLibuX6BWDeHwaAN5BdbYBs7XRhhawgg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;707&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; ConcurrentDict &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    table []*Shard&lt;br/&gt;    count &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Shard &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    m     &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;interface&lt;/span&gt;{}&lt;br/&gt;    mutex sync.RWMutex&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(dict *ConcurrentDict)&lt;/span&gt; &lt;span&gt;spread&lt;/span&gt;&lt;span&gt;(hashCode &lt;span&gt;uint32&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;uint32&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; tableSize := &lt;span&gt;uint32&lt;/span&gt;(&lt;span&gt;len&lt;/span&gt;(dict.table))&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; (tableSize - &lt;span&gt;1&lt;/span&gt;) &amp;amp; &lt;span&gt;uint32&lt;/span&gt;(hashCode)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(dict *ConcurrentDict)&lt;/span&gt; &lt;span&gt;getShard&lt;/span&gt;&lt;span&gt;(index &lt;span&gt;uint32&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;Shard&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; dict.table[index]&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(dict *ConcurrentDict)&lt;/span&gt; &lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(val &lt;span&gt;interface&lt;/span&gt;{}, exists &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; hashCode := fnv32(key)&lt;br/&gt; index := dict.spread(hashCode)&lt;br/&gt; shard := dict.getShard(index)&lt;br/&gt; shard.mutex.RLock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; shard.mutex.RUnlock()&lt;br/&gt; val, exists = shard.m[key]&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(dict *ConcurrentDict)&lt;/span&gt; &lt;span&gt;Put&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;, val &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(result &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; dict == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(&lt;span&gt;&quot;dict is nil&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; hashCode := fnv32(key)&lt;br/&gt; index := dict.spread(hashCode)&lt;br/&gt; shard := dict.getShard(index)&lt;br/&gt; shard.mutex.Lock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; shard.mutex.Unlock()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; _, ok := shard.m[key]; ok {&lt;br/&gt;  shard.m[key] = val&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  shard.m[key] = val&lt;br/&gt;  dict.addCount()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ConcurrentDict&lt;/code&gt; 可以保证对单个 key 操作的并发安全性，但是仍然无法满足并发安全的需求，举例来说：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Incr 命令需要完成：&lt;code&gt;读取 -&amp;gt; 做加法 -&amp;gt; 写入&lt;/code&gt; 三步操作，读取和写入两步操作不是原子性的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MSETNX 命令当且仅当所有给定键都不存在时所有给定键设置值，我们需要保证「检查多个key是否存在」以及「写入多个key」这两个操作的原子性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们需要实现 &lt;code&gt;db.Locker&lt;/code&gt; 用于锁定一个或一组 key 直到我们完成所有操作后再释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现 &lt;code&gt;db.Locker&lt;/code&gt; 最直接的想法是使用一个 &lt;code&gt;map[string]*sync.RWMutex&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加锁过程分为两步：初始化 mutex -&amp;gt; 加锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解锁过程也分为两步: 解锁 -&amp;gt; 释放mutex&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么存在一个无法解决的并发问题：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;时间&lt;/th&gt;&lt;th&gt;协程A&lt;/th&gt;&lt;th&gt;协程B&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;locker[&quot;a&quot;].Unlock()&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;locker[&quot;a&quot;] = &amp;amp;sync.RWMutex{}&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;delete(locker[&quot;a&quot;])&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;locker[&quot;a&quot;].Lock()&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 t3 时协程 B 释放了锁，t4 时协程 A 试图加锁会失败。若协程B在解锁时不执行 &lt;code&gt;delete(locker[&quot;a&quot;])&lt;/code&gt; 就可以避免该异常的发生，但是这样会造成严重的内存泄露。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们注意到哈希槽的数量远少于 key 的数量，反过来说多个键可以共用一个哈希槽。所以我们不再直接对 key 进行加锁而是锁定 key 所在的哈希槽也可以保证安全，另一方面哈希槽数量较少即使不释放也不会消耗太多内存。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Locks &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    table []*sync.RWMutex&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Make&lt;/span&gt;&lt;span&gt;(tableSize &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;Locks&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    table := &lt;span&gt;make&lt;/span&gt;([]*sync.RWMutex, tableSize)&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; tableSize; i++ {&lt;br/&gt;        table[i] = &amp;amp;sync.RWMutex{}&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;Locks{&lt;br/&gt;        table: table,&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(locks *Locks)&lt;/span&gt;&lt;span&gt;Lock&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    index := locks.spread(fnv32(key))&lt;br/&gt;    mu := locks.table[index]&lt;br/&gt;    mu.Lock()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(locks *Locks)&lt;/span&gt;&lt;span&gt;UnLock&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    index := locks.spread(fnv32(key))&lt;br/&gt;    mu := locks.table[index]&lt;br/&gt;    mu.Unlock()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在锁定多个 key 时需要注意，若 协程A 持有 键a 的锁试图获得 键b 的锁，此时 协程B 持有 键b 的锁试图获得 键a 的锁则会形成死锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决方法是所有协程都按照相同顺序加锁，若两个协程都想获得 键a 和 键b 的锁，那么必须先获取 键a 的锁后获取 键b 的锁，这样就可以避免循环等待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到目前为止构建 Redis 服务器所需的基本组件已经备齐，只需要将 TCP 服务器、协议解析器与哈希表组装起来我们的 Redis 服务器就可以开始工作啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，以上代码均简化自我写的 Godis：一个开源仅用 Go 语言实现的 Redis 服务器。期待您的关注和 Star：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;项目地址：https://github.com/HDT3213/godis&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四、结束&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多朋友的日常工作主要是编写业务代码，对于框架、数据库、中间件这些“架构”、“底层代码” 有一些恐惧感。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但本文我们只写了 3 个组件，共计几百行代码就实现了一个基本的 Redis 服务器。所以底层的技术并不难，只要你对技术感兴趣由浅入深、从简到繁，“底层代码”也并不神秘。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5MzYyNzQ0MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOqkqThUJBICyFBlvLvTyOCgBpibwWotSxGExfnOYFfPiaL9yn3GMUOCEVYN2RNslGCdQwgZy6ticdyA/0?wx_fmt=png&quot; data-nickname=&quot;HelloGitHub&quot; data-alias=&quot;GitHub520&quot; data-signature=&quot;分享 GitHub 上有趣、入门级的开源项目。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;兴趣是最好的老师，&lt;strong&gt;HelloGitHub&lt;/strong&gt; 发现编程的乐趣&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d901213929ddb9effbfb2c955e99d23a</guid>
<title>[推荐] [译] 如何优化您的日常决策</title>
<link>https://toutiao.io/k/88ebc7h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Post-body&quot;&gt;
                    &lt;p&gt;当今的生活和工作都是&lt;strong&gt;快节奏&lt;/strong&gt;的，人们每天都会遇到各种各样的事情，并需要做出做相应的&lt;strong&gt;决策&lt;/strong&gt;：哪些事情先做，哪些事情后做，哪些事情应该做，哪些事情不应该做。前些天有读到一篇文章：&lt;a href=&quot;https://jamesclear.com/design-default&quot; rel=&quot; nofollow ugc&quot;&gt;How to Optimize Your Daily Decisions&lt;/a&gt;，作者所做的思考，以及给出的建议，不仅通俗易懂，而且也方便用于日常工作、生活。因此有翻译成中文，分享给有需要的朋友；以下是原文。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lovejade.oss-cn-shenzhen.aliyuncs.com/decisions.png&quot; title=&quot;&quot; alt=&quot;如何优化您的日常决策&quot;/&gt;&lt;/p&gt;

&lt;p&gt;您可能会假设人们购买产品是因为它们是什么，但事实是，我们经常购买东西是因为它们的位置。例如，与视线齐平的商店货架上的商品往往比不太显眼的货架上的商品购买得更多。&lt;/p&gt;

&lt;p&gt;在畅销书 &lt;a href=&quot;https://jamesclear.com/book/nudge&quot; rel=&quot; nofollow ugc&quot; title=&quot;理查德·塞勒 (Richard Thaler) 和卡斯·桑斯坦 (Cass Sunstein) 的推动&quot;&gt;Nudge&lt;/a&gt; ( &lt;a href=&quot;https://jamesclear.com/ebook/nudge&quot; rel=&quot; nofollow ugc&quot; title=&quot;轻推电子书&quot;&gt;Kindle&lt;/a&gt; | &lt;a href=&quot;https://jamesclear.com/audiobook/nudge&quot; rel=&quot; nofollow ugc&quot; title=&quot;轻推有声读物&quot;&gt;Audiobook&lt;/a&gt; ) 中，作者 Richard Thaler 和 Cass Sunstein 解释了我们日常决策受周围世界影响的各种方式。视线水平的货架对我们购买习惯的影响只是一个例子。&lt;/p&gt;

&lt;p&gt;这是另一个：&lt;/p&gt;

&lt;p&gt;过道的尽头是零售商的赚钱机器。根据《纽约时报》引用的数据，可口可乐 45% 的销售额专门来自过道尽头的货架。&lt;/p&gt;

&lt;p&gt;这就是为什么这很重要：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一些东西&lt;/strong&gt;必须放在与视线齐平的架子上。必须在过道尽头的架子上放&lt;em&gt;一些东西&lt;/em&gt;。某些东西必须是默认选择。某些东西必须是最能见度和最突出的选项。这不仅适用于商店，而且适用于我们生活的几乎每个领域。您的办公室、汽车、厨房和客厅都有默认选择。&lt;/p&gt;

&lt;p&gt;我的论点是这样的：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果你为生活中的默认而设计，而不是接受交给你的任何东西，那么过上更好的生活会更容易&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;现在让我们谈谈如何做到这一点。&lt;/p&gt;

&lt;h2&gt;默认设计&lt;/h2&gt;

&lt;p&gt;尽管我们中的大多数人在任何特定时刻都有做出广泛选择的自由，但我们经常根据所处的环境做出决定。&lt;/p&gt;

&lt;p&gt;例如，如果我想这样做，我可以在写这篇文章时喝一杯啤酒。但是，我目前坐在办公桌前，旁边放着一杯水。看不到啤酒。虽然我有能力起床、步行到我的车、开车去商店和买啤酒，但我可能不会，因为我周围有更简单的选择——即饮用水。在这种情况下，喝一口水是默认的决定，很容易的决定。&lt;/p&gt;

&lt;p&gt;考虑在您的个人和职业生涯中如何设计您的默认决定。例如：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;如果您睡觉时将手机放在床边，那么醒来后立即查看社交媒体和电子邮件可能是默认决定。&lt;/li&gt;
&lt;li&gt;如果你走进你的客厅，你的沙发和椅子都面向电视机，那么看电视很可能是默认的决定。&lt;/li&gt;
&lt;li&gt;如果您在厨房里放酒，那么持续饮酒更有可能成为默认决定。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;当然，默认值也可以是正数。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;如果你在工作时在办公桌旁边放一个哑铃，那么做一些快速的弯举更有可能是默认的决定。&lt;/li&gt;
&lt;li&gt;如果你全天都带着水瓶，那么喝水而不是苏打水更有可能是默认的决定。&lt;/li&gt;
&lt;li&gt;如果您将牙线放在可见的位置（例如牙刷旁边），则使用牙线更可能是默认决定。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;研究人员将环境违约对我们决策的影响称为&lt;a href=&quot;https://jamesclear.com/choice-architecture&quot; rel=&quot; nofollow ugc&quot; title=&quot;选择架构&quot;&gt;选择架构&lt;/a&gt;。重要的是要意识到您可以成为您选择的架构师。您可以设计为默认。&lt;/p&gt;

&lt;h2&gt;如何优化您的默认决策&lt;/h2&gt;

&lt;p&gt;以下是我在尝试为我的生活中的默认设计时发现的一些有用的策略：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简单&lt;/strong&gt;。当您经常被噪音包围时，很难将注意力集中在信号上。当你的厨房里堆满垃圾食品时，要吃得健康就更难了。当您在浏览器中打开 10 个选项卡时，更难以专注于阅读博客文章。当您陷入&lt;a href=&quot;https://jamesclear.com/multitasking-myth&quot; rel=&quot; nofollow ugc&quot; title=&quot;多任务处理的神话：为什么更少的优先级会导致更好的工作&quot;&gt;一心多用的神话&lt;/a&gt;时，完成最重要的任务就更加困难了。如有疑问，消除选项。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;视觉提示&lt;/strong&gt;。在超市中，将商品放在与视线齐平的货架上会使它们更具视觉效果并且更有可能被购买。在超市之外，您可以使用诸如&lt;a href=&quot;https://jamesclear.com/paper-clips&quot; rel=&quot; nofollow ugc&quot; title=&quot;如何通过使用回形针策略坚持每天的好习惯&quot;&gt;回形针法&lt;/a&gt;或&lt;a href=&quot;https://jamesclear.com/stop-procrastinating-seinfeld-strategy&quot; rel=&quot; nofollow ugc&quot; title=&quot;如何使用宋飞正传策略停止拖延你的目标&quot;&gt;宋飞策略之&lt;/a&gt;类的视觉提示来创建一个环境，在视觉上将您的行为推向正确的方向。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;选择退出与选择加入&lt;/strong&gt;。有一项&lt;a href=&quot;https://jamesclear.com/environment-design-organ-donation&quot; rel=&quot; nofollow ugc&quot; title=&quot;器官捐献与环境设计&quot;&gt;著名的器官捐赠研究&lt;/a&gt;揭示了多个欧洲国家如何提高器官捐赠率：他们要求公民选择不捐赠而不是选择捐赠。通过提前让未来的自己养成更好的习惯，你可以在生活中做一些类似的事情。例如，您可以将瑜伽课程安排在下周，而您今天感到有动力。当您的锻炼开始时，您必须证明选择退出是合理的，而不是激励自己选择加入。&lt;/p&gt;

&lt;p&gt;默认设计归结为一个非常简单的前提：改变你的环境，让好的行为更容易，坏的行为更难。&lt;/p&gt;

&lt;h2&gt;为您设计与由您设计&lt;/h2&gt;

&lt;p&gt;默认选择本身并不坏，但整个世界的设计都没有考虑到您的目标。事实上，许多公司的目标与您的目标直接竞争（食品公司可能希望您购买他们的薯片袋，而您想减肥）。出于这个原因，您应该谨慎接受每一个默认值，就好像它应该是最佳选择一样。&lt;/p&gt;

&lt;p&gt;我通过过自己设计的生活而不是接受别人给我的标准生活，从而获得了更多的成功。质疑一切。你需要改变、调整和改变你的环境，直到它符合你想要的生活。&lt;/p&gt;

&lt;p&gt;是的，你周围的世界塑造了你的习惯和选择，但有一件重要的事情需要意识到：首先必须有人来塑造这个世界。现在，有人可以是你。&lt;/p&gt;

&lt;p&gt;如果你想要更多关于改掉坏习惯和养成好习惯的实用想法，请查看我的书&lt;a href=&quot;https://jamesclear.com/book/atomic-habits&quot; rel=&quot; nofollow ugc&quot;&gt;原子习惯&lt;/a&gt;，它会告诉你习惯的微小改变如何带来显着的结果。&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;通过该文的阅读，可以给生活、工作带来哪些启示？下面跟大家分享一些（如您有更多建议，欢迎留言分享）：&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;定时对浏览器所打开的页面，加以阅读、消化、整理，然后关闭；从而提升专注；&lt;/li&gt;
&lt;li&gt;不再将短视频、微信等浪费时间，却没有太大价值的应用，放置手机桌面显眼位置；&lt;/li&gt;
&lt;li&gt;如您也有游戏瘾，周末将至，列出读一本书，或看几部电影的计划，尽量不去想玩游戏这事儿；&lt;/li&gt;
&lt;li&gt;如一定要玩儿，那么再玩了几盘，尽兴之后，删除游戏，让下次打开游戏，变得困难......&lt;/li&gt;&lt;/ol&gt;
                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa9378bfcfa4d1df5e8535c009ee905a</guid>
<title>[推荐] 中后台领域低代码搭建设计与实践</title>
<link>https://toutiao.io/k/9mznc2m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;108&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.1859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPiadQyCOHNzUdyYbWTfk32WkUfq4DV9FJsfiatfYcicXiaL0Dwm8UdSDemw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;2021年5月22日，哈啰技术沙龙-大前端的探索与实践，在杭州成功举办。&lt;br/&gt;以下是由 @杜诗晨（庙爷）分享的主题&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPLliaW0A8SjYmsv7pEaOPNziaeRGVLSBoNw1HJHhKQuVAea3h433s7oFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1620&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;什么是低代码搭建&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;通过提供一种可视化的应用开发环境，降低或去除对原生代码编写的需求量快速构建应用程序。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;传统开发交付一个产品的流程，首先产品输出 prd，然后设计 ui 设计进行设计，设计完成给到前端，前端再去开发。如果是个新项目可能还要这种配置各种复杂环境。同时后端也在开发，然后联调、测试。其实现在大部分的公司都是这种开发流程。那这种缺点就很明显，涉及到的人非常多，开发周期也变得非常长。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPtOS1u4Cl3aOgShwe38SfJeVNeUwxzkrkjOXKymScEr02cesdiaouVEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;低代码搭建是一个什么样的流程？如果是一个成熟的配置搭建平台，只需要提供一个配置平台，开发人员不论是刚毕业的大学生或者是前端小白，甚至可能是一个后端开发，都可以通过这个配置平台搭建，快速生成网页。&lt;/p&gt;&lt;p&gt;关于低代码的市场规模和衍生的历史大家可以从下图中了解一下，这里提供两份报告作为延伸学习：海比研究报告 | 艾瑞咨询&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPMicFWOGIhnFvY0kibU57uAwpHmQQf4YDqhIialSRibhZyJDQD3T6giaD03A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;概念衍生历史&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;低代码这个概念其实很早就有了，80年代的时候提出了第四代编程语言，这个第四代是什么意思呢，第一代是机器语言，第二代汇编语言，第三代高级语言。前三代都是操作语言，需要编程指出怎么做，一步一步的写运行步骤，这样是有学习成本的，并且项目开发周期长，出于商业需要第四代语言被软件厂商提出，在一定程度上只需要说明做什么，有什么目的，不需要写出怎么做的过程。&lt;/p&gt;&lt;p&gt;2000 年 vpl 被提出，可视化编程语言，意思就是用户用过图形化操作程序元素而不是通过文本制定来创建程序，基于流的概念比如虚幻引擎，还有一些运用在3D编程，音乐合成，信号处理，物联网嵌入式等等领域。&lt;/p&gt;&lt;p&gt;2014年知名咨询公司提出了低代码/零代码的概念，在这之前国外有很多低代码产品出现并且商业化&lt;/p&gt;&lt;p&gt;2016年，国内相继发布这些低代码的平台。国内知名的像阿里百度腾讯，他们都有这种搭建平台。&lt;/p&gt;&lt;p&gt;在今年（2021），整个中国市场已经形成了完整的低代码无代码的生态体系。就比如说像现在这种 aPass 平台或者是 Sass 平台之类的，平台会包含的低代码去快速搭建这种应用。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPoAWlumsz3iaE2bEv1YfoNdrA4MCet3TFKBohYH9ibhPkJW0m5yaOkuibA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;市场规模&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;投资界似乎也发现了这种趋势，全球规模在去年的时候已经达到了八十四亿美元。预计今年超过百亿。23年超过200亿。&lt;/p&gt;&lt;p&gt;比如说二月份的时候，就有一家创业公司，他们融了大概上亿美元，估值也有几十亿。所以说这一块从全球的低代码的市场规模来说，低代码还是非常有潜力的。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPyYa4lGG9S22xhiaGbZoibdicDq5icOg2UGCwSB2tW394djib3Dwz1k1v1hQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;搭建分类&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;现在市场上基本上分为两类搭建类型，一类是营销类搭建 no code，一类是通用类搭建，就是我们所说的 low code 和 pro code。营销类 no node 无需编码，直接生成营销活动，前端资源紧缺的时候，后端开发人员也可通过 low code 可搭建中台领域的页面，前端这边为了避免各种工程环境，减低门槛也可通过 pro code 的形式来去搭建。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPUTtjuEjyaH1S3gBm6wwBYsBh8asSEg8NysWooFMXXhS4fqiaZl3YASg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;面向人群&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;那么这么分类我认为是面向的人群不同，一个特别通用的搭建平台，可能复杂度就上升了很高，所以说我们要做这个低代码搭建平台的时候，一定要想好我们面向的人群是什么？&lt;br/&gt;营销类 no node 无需编码，直接生成营销活动，前端资源紧缺的时候，后端开发人员也可通过 low code 可搭建中台领域的页面，前端这边为了避免各种工程环境，减低门槛也可通过 pro code 的形式来去搭建&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPQyMUSThEYuXTFOveibzCLxWLUwQvibpOdvqAzPHLPbloDarBBdzPhVmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;中后台领域痛点&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;首先交互不统一，比如说有一些很相似的页面，但是由不同的产品或者设计师出的图。&lt;br/&gt;那实际上他们想要达到的效果是很相似的。但是交互不同，不同的前端开发出来的效果也不一样。不同职级的开发可维护性就会差一点，代码可能会复杂一些，会出现不同的编码风格。中台还有一个痛点的就是中台的系统非常多，业务重，人员有缺口。我之前负责的那个域，前后端比例当时是有 1：7 的样子，借人也好，招人也好，都是很难去补上这个缺口。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPQd03Ta3ibMkOAVibnGRwQsICj1P5xjS3R35FbyXcicwvMicAEHk1H5o7fg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;设定目标&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;所以我们设定了三个目标，一个是提效降本。我们怎么样去把这一块的研发效能提上来。&lt;br/&gt;第二个目标是部分生产力可转移后端，让后端也有能力输出前端页面&lt;br/&gt;第三点就是抽象中后台的系统基础组件。前端在组件化的过程中逐渐沉淀，复用这些能力，赋能到搭建平台中。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;如何做？波塞冬建站平台&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;有了这些目标，促使我们做了波塞冬建站平台，通过可视化操作 + 部分编码(或者不编码)生成中后台系统。让前端业务开发变成组件开发，逐渐沉淀可复用组件，让简单业务少编码甚至不编码。为前端增效，为后端赋能。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPvpiaBRx4ViaRSNRWYhxRxMHEh08I0zxKR9mA5vL4mjeficcOLDiaVMhkcg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;使用数据&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;这个平台上线之后，线上的有117个页面在运行，共发布了870次，其中已经设计了6个团队，提升的人效也很显著，假设我们平均开发一个增量页面需要3人日，用波塞冬只需要一人日，老页面迭代修改配置也只需要0.5d&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPOhSrM6IIQicQAldHHsMMUuiaUCYo4htAYSNQHjOiakVZHvwHvK0HQibGKg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;平台流程&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;给大家讲解下平台原理，比如说一个创建者，他首先要去波塞冬平台创建页面，生成一份 schema ，这份 schema 被波塞冬后端保存在SQL中，我们的用户，也就是页面访问者，通过业务平台网站获取页面，这里边相当于业务平台网站有个sdk，他直接取拉波塞冬保存的schema，sdk通过 schema 渲染组件 和 业务数据的接口，这样一个页面就展示出来了&lt;br/&gt;那我们这边也有很多组件贡献者，如果创建者不满足需求的，贡献者这边去维护组件这样就能贡献生态&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPZ08hKMr6JKFcwUYgkXXJ3xIWiaW9GicWrRicxf567r3RNUqsB45x3BrvA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;平台架构&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;整个平台的架构是这样的：&lt;br/&gt;底层我们是拿vue搭建，不过这块技术选型哪个框架都可以，只要定义好 schema，react + antd 也能搞&lt;br/&gt;组件这一块就是根据固定的 schema 进行封装，未来可能还有一些业务组件接入&lt;br/&gt;渲染这一层主要是提供给开发者用来丰富组件库或一些其他业务场景&lt;br/&gt;平台能力也就是我们要提供的这个界面，主要是一些用户可以操作的功能，这些功能想一下入手还有一点小成本，我们提供了文档，视频等，可以做到边接入边开发，还提供了一些实例供配置方借鉴&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPTCUSNfcjCVy43TEss2hvkOcxw5xN1xuLSl5xEGicTGhKNOxCNzCdAyg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;接入方式&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;我们的解析方式有三种，一种是 sdk直接引入，这样方便升级，也方便二次开发，sdk的引入方式非常灵活。&lt;br/&gt;还有一种是 ifame 引入，这样只需引入一个标签即可，剩下的都在波塞冬里配置。&lt;br/&gt;一键建站的方式，相当于站点维度，没有项目的概念，域名菜单权限页面，都是在波塞冬里完成的，不需要本地环境，这种比较适合后端开发人员&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPYIFicTOAKdIugLe0eumicq90LiaUkuKJIWDxiaJXhqrQRvRsGiaicJLj99Hw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;渲染引擎&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;展示一下 sdk 的引用，我们可能会在不同开发环境中引入，这里提供环境变量的配置&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPA65kczibOWUc6vy7J6ZTPXtjlguSqGCm9WLkm6mF0Dp4xuB3jZuDYtg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;一键建站&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;刚才有介绍我们有三种引入方式，给大家看下第三种一键建站是怎么做的，我们加强了应用管理，一个应用就是一个站点，菜单，域名都是在平台里申请，这样用户通过页面访问就是配置的界面，完全不需要再去申请工程，这里我们用了代理的方式进行一个转发，转发的目标是一个基座，类似微前端的那个基座，只不过这个基座我们通过当前域名拉取配置，最终提供给用户。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPVfuBTLcG5rzYZDNTb4qxRJVGTKbGgGfib1ZONpekgDfAh8xr7IycdXw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;页面布局&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;带大家看一下创建页面的布局，最左侧是组件区，目前是基础组件，这里未来可能会做组件分类，把业务组件和自定义组件也接进来，中间是布局设计区，比如说列表页有固定三个区域，筛选项，中部功能区，列表，表单页不做限制，右侧为配置区，可以配置绑定字段和文案还有一些额外属性，组件的交互，像select这种option是接口调用的数据，还可以配置远程接口&lt;/p&gt;&lt;h5&gt;&lt;span&gt;模型设计（JSON SCHEMA）&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;我们创建页面后，会生成一份 schema ，什么是 json schema ，简单介绍一下，json shema 是 json 的一种约束，用来定义json的数据结构和验证格式，我们在这里用来保证数据的一致性&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPLkXHvc0UVVl9icYwlXNBz40Rsq1PhIygKvza4SrQ7kpGEe5oMFMZH6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;每个页面有一个主体，用来描述版本和一些原信息，body就是他的内容&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPHdTia1gbvHAoF8TJQj1Bw8ZaYwz5qUFT8P06MChLSmJtXUTpjq2xcqA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;JSON SCHEMA&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;我们目前页面分为两种，一种就是列表页面，一种是 form 页，但是他们的描述协议都是一样的，那基本的组件描述我们定义好了，这样其实简单的需求就能实现了，但是前端避免不了交互这一层，比如说一个选择框，当我选择了 A，B会触发一个事件，并且B还要拿到A所携带的入参信息&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPmB9USaibXAe33MWt5L43sUCMaHXcwgHOibp7TaibfvsKMoZ8gj7XXYqicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;操作事件&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;我们这边做了一个操作事件功能，我们只需要把组件的 ref 设置好，操作事件这一块就可以定义他的出参入参，方便交互&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPt5rtLJC35qWP1DEBPKNxQCGLiaVMLPkNaiaTIxCq6bp7q6TzIqNPUaOQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;数据中心&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;接口配置这里，比如说一个 select 从远程接口获取到一个枚举，就可以存下来，给其他组件消费&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPkeaNNJc9kRU3FOaicR5FEichfT9Cl0SYPRlErhRKLQTDO8ao1s0DjpLQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;自定义插槽&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;比如说平台目前有不支持的组件或交互，还没有维护在平台里的，这里可以利用 vue 的 slot 进行二次开发，只需要拖入一个 slot&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPwyViaJdGAkBanhSENuGH0hNl8f7X1wD0jDNYGEgNlibFZCrQ3wIicB5TQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;自定义插槽-编码&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;slot 里的组件可以获取到配置里的 ref 和想要拿到的 scope，做任何你想做的事儿&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPgN4Of1tWWJpE94mLUVEjDKyU1jVqWflfrmdVgicKlNJ6UibeTIHI04IQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;480&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;稳定性&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;我们做低代码平台，归根到底是一个渲染引擎渲染一组 schema ，那么稳定性也得考虑，我们每次修改线上配置，可能心情如图，那我发布时怎么保证准确性，传统开发我们会有一个review 的过程，我们就把这个过程也搬上来了&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPYuGtczw1hRcH849icrwiaG54LBopoUMdkHiavde2v8G1aibeTQS5Vvhd0Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;SCHEMA DIFF &amp;amp; 版本对比&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;schema diff 每次发布时，需要选择版本来确认我改了什么，大大降低了风险。&lt;br/&gt;发布时也要进行二次确认&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPmmTb0uyDmKlibyxiaq1gZtdVtiaggp3tlH7BnH83pE4ZY6CgurMxS7Ztg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;未来规划&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPJsKkXnlxN4Jht7eWpWTV04ultiblzntWyBpvFBXciaY9KC85VzAHTHnw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;AUTO-CODE&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;我们目前的能力，在版本对比这一块希望能做到 merge，并且提供可视化，也就是说你不一定非要看 schema 这种东西，组件这里继续丰富，能承载更多的需求，low-code 目标就做到 no-code 让非开发人员直接生成页面，不需要写一点代码，最终这个生产力就可以转移，终极目标就是做成 auto-code ，利用机器学习识别设计图，直接生成网站，抹去大部分配置，auto-code 目前业界有很多公司已经实现，我们也在慢慢摸索。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-darkmode-color-16057140139831=&quot;rgb(162, 162, 162)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(68, 68, 68)&quot; data-style=&quot;padding-top: 7px; padding-bottom: 7px; color: rgb(68, 68, 68); font-size: 14px; line-height: 1.8; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Lucida Grande&amp;quot;, Arial, &amp;quot;Hiragino Sans GB&amp;quot;, 微软雅黑, &amp;quot;WenQuanYi Micro Hei&amp;quot;, STHeiti, SimSun, sans-serif; text-align: center;&quot;&gt;&lt;span&gt;The End&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-darkmode-color-16057140139831=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(0,0,0)&quot; data-style=&quot;padding-right: 10px; padding-left: 10px; font-size: 16px; color: black; line-height: 1.6; letter-spacing: 0px; word-break: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif;&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: rgb(89, 89, 89);&quot;&gt;&lt;span&gt;如果你觉得这篇内容对你挺有启发，请你轻轻点下小手指，帮我两个小忙呗：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: rgb(89, 89, 89);&quot;&gt;&lt;span&gt;1、点亮&lt;strong data-darkmode-color-16057140139831=&quot;rgb(71, 193, 168)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(71, 193, 168)&quot;&gt;「在看」&lt;/strong&gt;，让更多的人看到这篇满满干货的内容；&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: rgb(89, 89, 89);&quot;&gt;&lt;span&gt;2、关注公众号「哈啰技术团队」，可第一时间收到最新技术推文。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: rgb(89, 89, 89);&quot;&gt;&lt;span&gt;如果喜欢就点个👍喔，有您的喜欢⛽️，我们会更有动力输出有价值的技术分享滴；&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3365323096609085&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xdDaByDutCja1wGKtp4IvKFbKKgKS8L0kQO9PzXxFoTia27KOzppMGsiba5RdY3TAY6XTpIDGsLJLrYCBRCKMKnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1563&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>