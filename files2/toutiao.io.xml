<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>93d8035f6cafa2da040c511b9b3055bc</guid>
<title>收钱吧多泳道环境的演进</title>
<link>https://toutiao.io/k/59oz4qo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5241545893719807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1Qj2bOmgI3Y2DxYAylSr8zHHJQUbMqPea7iaCpErbfx1h8hRFia2Zy42h21417sZIxAQfAXdHbFVbvyMtibczh3MA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，在研发过程中往往需要多套环境以满足不同的阶段的研发需求，如开发、测试、预发布环境。好的环境方案可以提高开发调试、项目测试的效率，也可以降低上线的风险，从而缩短整个需求的交付周期，提高生产效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为应对业务快速发展的需求，收钱吧在多环境的治理上经历了数个版本的迭代。本文主要介绍这几代测试环境的发展与技术实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;早期测试环境&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2018年之前，收钱吧的测试环境是两套物理隔离的环境：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;给予独立的硬件资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个服务为每个环境准备独立的配置文件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;span&gt;Jenkins&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;+&lt;span&gt;Docker&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;部署，两套环境之间互不影响。这套部署方案，技术上相对成熟，操作上简单直观，但存在以下的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;测试环境新增服务需要运维介入，创建Jenkins任务、配置Jenkins脚本、配置域名解析等，流程繁琐&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要切换服务分支时，Jenkins需要checkout源码、编译源码、构建Docker镜像、部署服务，整个流程耗时较久&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同一个服务只能有两个需求并行开发测试，无法满足快速增长的需求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个服务的配置文件是工程师手动维护，如果配置出错，有可能造成两套环境的交叉调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;很难拓展出第三、四套环境，需要大量的硬件资源以及需要为每个服务新增配置文件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.363855421686747&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3Y2DxYAylSr8zHHJQUbMqPeiaVa6fqhT3MNTwZt27KPOXLzZck6zKFtXGI4fcQZPnL4FJqHRfVJBrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上问题也对应着我们的各种诉求：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;我们想要研发同学不需要太多的运维知识就能快速部署新服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们想要服务分支的切换更加快捷容易&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们不想要跟其他人抢环境，不想测试到一半被人切了分支&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们想要减少一些重复的工作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多泳道环境 1.0&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2018年，收钱吧决定将服务迁往&lt;span&gt;Kubernetes&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;集群，原来的CI构建也从Jenkins迁移到&lt;span&gt;Gitlab CI&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;。Gitlab CI的使用，使得从checkout源码到构建Docker镜像的整个流程透明化，而依托于Kubernetes的能力，服务部署、升级等操作流程也不再繁琐，更容易与内部系统集成，实现自动化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然将服务迁移到Kubernetes集群解决了测试环境中的很多问题，但在业务需求快速迭代的场景下，测试环境最核心的诉求：&lt;strong&gt;同一个服务在环境中能够多版本共存&lt;/strong&gt;，并没有得到有效解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Kubernetes原生网络中，让请求访问同一个服务的两个不同版本，我们只有两种选择：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;多个版本的Pod配置相同label，Service中配置对应selector。这种情况下，流量在不同版本的Pod之间随机路由，显然无法在这样的场景下做测试。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不同版本配置不同的Service。这种情况相当于把服务的不同版本当成不同的服务处理。想要让下游服务访问特定版本，需要下游服务修改配置文件，这也不是可行的方案。流量的路由应该由用户决定，而不是由链路中的某个节点决定。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多泳道环境的构思&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然Kubernetes原生网络无法提供足够的支持，我们需要能够精确控制流量路由到哪个版本。在此背景下，受到&lt;span&gt;阿里特性环境&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;的启发，我们提出了多泳道环境的构想。蓝图如下，同时引入了环境泳道的概念。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4892578125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3Y2DxYAylSr8zHHJQUbMqPeZeefgExs9rWkHU1bpVMvibpI7TIiaEgmcDzSx6hC7pReH6mgkbbWQzeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;环境泳道是逻辑而非物理上的概念，同一泳道的服务之间可以直接访问，跨泳道的访问需要携带对应标识，访问的服务在泳道内不存在，请求也不携带标识，则默认路由到基础泳道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若干个环境泳道，组成了多泳道环境：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;同一服务不同版本，使用同一个域名，服务发现由底层设施负责&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环境泳道可以任意创建和释放&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;入口请求的流量需要带上特殊标识，来标识流量所属泳道&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个服务透传请求携带的标识&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的设计之下，我们认为传统的物理上的多环境将转变成逻辑上的多环境，从而可以大量节省硬件资源，处于开发、测试阶段的项目不会再因为环境数量限制而导致排队等待了，另外通过底层设施来控制路由，也不会再出现不同环境交叉使用的乱象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;依托于Istio的实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上构想，正是当时&lt;span&gt;Service Mesh&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;着力解决的问题。不管是RedHat，还是&lt;span&gt;Nginx&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;，给出的Service Mesh方案都是使用Control Plane + &lt;span&gt;Sidecar&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt; Proxy的模式。所以工程效率团队调研了当时相对成熟的解决方案&lt;span&gt;Istio&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从Istio的&lt;span&gt;Bookinfo&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;这个样例上可以了解到，Istio流量管理的核心功能是通过两份&lt;span&gt;CRD&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;--&lt;code&gt;VirtualService&lt;/code&gt;和&lt;code&gt;DestinationRule&lt;/code&gt;的配置来完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中&lt;code&gt;VirtualService&lt;/code&gt;用于配置路由规则，它可以作用于L4、L7，对于常见的HTTP流量还可以对header、uri、queryParams等进行匹配路由，如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;VirtualService&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;reviews-route&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;hosts:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;reviews.prod.svc.cluster.local&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;http:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;&quot;reviews-v2-routes&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;match:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;uri:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;prefix:&lt;/span&gt; &lt;span&gt;&quot;/wpcatalog&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;route:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;destination:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;host:&lt;/span&gt; &lt;span&gt;reviews.prod.svc.cluster.local&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;subset:&lt;/span&gt; &lt;span&gt;v2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;&quot;reviews-v1-route&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;route:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;destination:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;host:&lt;/span&gt; &lt;span&gt;reviews.prod.svc.cluster.local&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;subset:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;DestinationRule&lt;/code&gt;定义了服务的不同版本，如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;DestinationRule&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;bookinfo-ratings&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;host:&lt;/span&gt; &lt;span&gt;ratings.prod.svc.cluster.local&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;subsets:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;testversion&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;version:&lt;/span&gt; &lt;span&gt;v3&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;trafficPolicy:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;loadBalancer:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;simple:&lt;/span&gt; &lt;span&gt;ROUND_ROBIN&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样来，对于多泳道环境的构思，依托于Istio的能力，可以被简化成以下逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; headers.x-env-flag == v2:&lt;br/&gt;    route(subset_v2)&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; request.sourceLabels.version == v2:&lt;br/&gt;    request.headers.x-env-flag = v2&lt;br/&gt;    route(subset_v2)&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;    route(subset_v1)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用基础设施层进行流量的路由的实现还有个显而易见的好处：&lt;strong&gt;对当前服务的改造成本极小&lt;/strong&gt;。当时第一批接入的后端服务，只需要升级&lt;code&gt;RPC&lt;/code&gt;库的版本即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，我们也配套开发了多泳道环境管理平台——Volac。它的作用便是创建环境泳道，并根据环境泳道配置对应的VirtualService和DestinationRule。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改造后测试环境的控制逻辑如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7293447293447294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3Y2DxYAylSr8zHHJQUbMqPe8JVlzv0m2bBicAdoTiapIviapoxCsJ3GpHtPbm8F0icicQXgVIWyPfCM9Zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Volac创建&lt;code&gt;VirtualService&lt;/code&gt;和&lt;code&gt;DestinationRule&lt;/code&gt;，并部署服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Istio给服务注入&lt;code&gt;Envoy&lt;/code&gt;容器作为sidecar，同时Istio控制面监听&lt;code&gt;VirtualService&lt;/code&gt;和&lt;code&gt;DestinationRule&lt;/code&gt;的变化，动态地给&lt;code&gt;Envoy&lt;/code&gt;下发路由配置。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改造后的业务流量如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6133720930232558&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3Y2DxYAylSr8zHHJQUbMqPeaCtvkVgnyQRH3trACEdxWycibfEsPMgib9wfuib70nibiaElQ9ApJqcvGfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;688&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;带特定标识的请求，会路由到特定的环境&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环境泳道中没有对应服务，请求会路由到基础泳道&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多泳道环境 2.0&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上述改造，基本解决了早期测试环境中的问题，但是却带来了新的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公司内部服务部署系统涉及很多业务方面的需求，例如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也涉及很多技术方面的细节，如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;调用Kubernetes接口部署服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用Istio API创建资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综合以上，在多泳道环境管理平台Volac的实现过程中，还存在一些问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;业务和技术的过度耦合&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;过度依赖第三方的实现实现，即Istio，Service Mesh解决方案可能存在更好的实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务配置状态存储在数据库，无法迅速完成多集群迁移和扩展&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上原因，我们将Volac的业务逻辑与技术细节拆解：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;业务逻辑演变为Next平台：收钱吧内部集应用发布、项目管理、研发效能报表等于一体的平台&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;技术细节实现演变为&lt;span&gt;elastic-env-operator&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;更&lt;span&gt;Kubernetes的方式&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终，测试环境的控制逻辑如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6440251572327044&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3Y2DxYAylSr8zHHJQUbMqPe4ECboNxOwbFcR8NxrWkK8zibicQoicVvxibRG5uhw059mIyiaBrhyIh50VA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;795&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，依托于Kubernetes的CRD扩展和operator，测试环境实现了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不依赖于业务，可以独立存在&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更好的扩展性，如支持监控系统的VictoriaMetrics&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不与第三方实现紧耦合，可在业务无感知的情况下替换实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以迅速将环境扩展或迁移到多个集群&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多泳道环境1.0在2019年上线，最终带来了很多直接和间接收益。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接收益：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;去掉了一套固定环境，节省了将近一半云服务器资源。随着服务数量的不断增长，这项收益也在不断变大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目不再需要维护两份测试配置，节省了人力，减少了出错成本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环境按需伸缩（现在运行着近600套环境），需求交付不再需要排队等待测试环境，提高了交付效率。随着业务发展，这项收益也越发明显&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;间接收益：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;环境实现自动化，更容易与CI/CD集成，减少人工维护，节省成本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环境更易迁移与扩展，为异云部署打下基础&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于作者&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刘宁，来自技术平台部&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Jenkins: &lt;em&gt;https://www.jenkins.io/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Docker: &lt;em&gt;https://www.docker.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Kubernetes: &lt;em&gt;https://kubernetes.io/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;Gitlab CI: &lt;em&gt;https://docs.gitlab.com/ee/ci/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;在阿里，我们如何管理测试环境: &lt;em&gt;https://developer.aliyun.com/article/688852&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;What&#x27;s a service mesh?: &lt;em&gt;https://www.redhat.com/en/topics/microservices/what-is-a-service-mesh&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;What Is a Service Mesh?: &lt;em&gt;https://www.nginx.com/blog/what-is-a-service-mesh/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;Microsoft: Sidecar Pattern: &lt;em&gt;https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Istio: &lt;em&gt;https://istio.io/latest/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;Bookinfo Application: &lt;em&gt;https://istio.io/latest/docs/examples/bookinfo/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;Extend the Kubernetes API with CustomResourceDefinitions: &lt;em&gt;https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;Wosai/elastic-env-operator: &lt;em&gt;https://github.com/WoSai/elastic-env-operator&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;Extending Kubernetes: Operator Pattern: &lt;em&gt;https://kubernetes.io/docs/concepts/extend-kubernetes/operator/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a5e5dc1f0903dbbc26719bb841ca45d6</guid>
<title>Go 语言整洁架构实践</title>
<link>https://toutiao.io/k/uco7j8y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大家好，我是 frank。&lt;br/&gt;欢迎大家点击标题下方&lt;span&gt;蓝色&lt;/span&gt;文字「Golang 语言开发栈」关注公众号。&lt;br/&gt;&lt;strong&gt;设为星标&lt;/strong&gt;，第一时间接收推送文章。&lt;br/&gt;&lt;strong&gt;文末扫码&lt;/strong&gt;，加群一起学 Golang 语言。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bob 大叔在他的一篇标题为「整洁架构」的博客中提及，现在一些流行的系统架构，都采用软件分层设计，都主张以下 5 个规则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;独立于框架&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可测试的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独立于用户界面&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独立于数据库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独立于任何外部依赖&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bob 大叔的架构设计遵循依赖规则，他画了一张同心圆的图，共分为 4 层，同心圆由内向外依次为 Entities、Use Cases、Interface Adapters 和 Frameworks and Drivers，该规则规定依赖只能是由外向内，内圈不关心外圈，外圈不要影响内圈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，不要认为必须是分为这四层，这里描述的四层只是一个示例，也许你会发现你的业务不仅仅需要这四层，重点是要遵循由外向内的依赖规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们介绍整洁架构在 Go 语言中的实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整洁架构分层设计&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参照 Bob 大叔的整洁架构软件分层设计，我们将架构分层分为以下 4 层：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Models&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Repository&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Usecase&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Delivery&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，Models 与 Entities 相同，将在所有层中使用，我们可以将所有对象的结构体和方法，以及其他需要在所有层中使用的变量、常量和函数放在 Models 层。这也可以避免遇到循环导入的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Repository 层，我们可以将处理数据库的程序和调用微服务的程序放在该层，仅处理数据输入和输出，不要有其它关于业务逻辑的代码。该层依赖操作的数据库或调用的微服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Usecase 层，我们可以将业务逻辑代码放在该层，它负责接收表示层的输入数据，将数据处理之后，调用 Repository 层，将处理后的数据存储在数据库或传递给调用的微服务。反之，将数据库中的数据或调用微服务的返回数据，处理之后，返回给 &lt;span&gt;Delivery &lt;/span&gt;层。该层依赖 Repository 层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Delivery 层，负责将处理后的数据展示出来，可以采用 RESTful、HTML 或 gRPC 等各种形式。同时，它也负责接收用户输入的数据，将数据传递给 Usecase 层。该层依赖 Usecase 层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实践应用的目录：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;.&lt;br/&gt;├── app&lt;br/&gt;│   └── main.go&lt;br/&gt;├── go.mod&lt;br/&gt;├── go.sum&lt;br/&gt;└── todoList&lt;br/&gt;    ├── delivery&lt;br/&gt;    │   └── http&lt;br/&gt;    │       └── todoList.go&lt;br/&gt;    ├── models&lt;br/&gt;    │   └── todoList.go&lt;br/&gt;    ├── repository&lt;br/&gt;    │   └── mysql&lt;br/&gt;    │       └── todoList.go&lt;br/&gt;    └── usecase&lt;br/&gt;        └── todoList.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;03 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分层之间通信&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分层之间是怎么通信的，除了 Models 层之外，其它层之间通过接口通信，例如 Usecase 层与 Repository 层之间通信，Repository 层定义接口，并实现接口中的所有方法。Usecase 层通过接口与 Repository 层通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; TodoListRepository &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Create(ctx context.Context, t *Todolist) (err error)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，Delivery 层与 Usecase 层之间通信，Usecase 层定义接口，并实现接口中的所有方法。Delivery 层通过接口与 Usecase 层通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; TodoListUsecase &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Create(context.Context, *Todolist) (err error)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们介绍整洁架构的软件分层设计，并且通过一个简单的 TodoList 项目，在 Go 语言中实践「整洁架构」的架构设计。但是，在 Go 语言中实际上并没有标准的架构设计，我们可以尝试构建自己的标准。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;完整代码，请查阅 github。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485863&amp;amp;idx=1&amp;amp;sn=6e119515e734fddacc87713bb3b26ce8&amp;amp;chksm=9f81a3c9a8f62adf7d4b6e2b91538919799dd0b27ff0064780db052a1e5636f2a46a6f51a446&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言微服务的服务发现组件 Consul 的系统架构介绍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言微服务的服务发现组件 Consul 的系统架构介绍&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247486020&amp;amp;idx=1&amp;amp;sn=0782a4791d0e5262ad46ecd7d5a1c198&amp;amp;chksm=9f81a02aa8f6293c9cf5db8f8945433dde8ec3c264a94877a7af7c23a8e327a227473ea2c42d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Go 微服务工具包 Go kit 怎么集成 gRPC？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Go 微服务工具包 Go kit 怎么集成 gRPC？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485896&amp;amp;idx=1&amp;amp;sn=7f13caa0a4a0efc9aa52f91449f1eee7&amp;amp;chksm=9f81a3a6a8f62ab0e4476eab641b65fc0376f817c7393dabdefeb239fcf8fb879bec353df558&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言的多种变量声明方式和使用场景&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言的多种变量声明方式和使用场景&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485871&amp;amp;idx=1&amp;amp;sn=5e9eac1cce46b90fdab7be5ea14be9ef&amp;amp;chksm=9f81a3c1a8f62ad7f00ae7659154d87c2790097944d8606cf440aa5cd58e29c9b13cedad2099&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言 vendor 在 GOPATH 和 Modules 中的区别&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言 vendor 在 GOPATH 和 Modules 中的区别&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247483747&amp;amp;idx=1&amp;amp;sn=2cd231dba19ef72a6d507ddb3d275cfd&amp;amp;chksm=9f81ab0da8f6221b3f3c8760eb2489d8aaad017178f443fe4012b623ec727510297a8ab9b537&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Go 语言学习之运算符&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Go 语言学习之运算符&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;br/&gt;https://hackernoon.com/golang-clean-archithecture-efd6d7c43047 &lt;br/&gt;https://hackernoon.com/trying-clean-architecture-on-golang-2-44d615bf8fdf &lt;br/&gt;https://github.com/bxcodec/go-clean-arch &lt;br/&gt;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html &lt;br/&gt;https://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/ &lt;/p&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001962&quot; data-ratio=&quot;0.07625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gf7zJ2NXUibGWic6DENZvSZyv968a9qRfrBXx1yLA8pfI2WO7LLeQfpBswpBndJyBCibkLibqoBkjFfw31ticEBdAEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;扫描二维码或回复「微信群」，加入微信群&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001964&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gf7zJ2NXUibHZrWwlicibPeLk8qoykuL5yg6tiaXRStcfNOX4aSO8uH7gjibKglg1Qmfd8SAfDbn0Fnbn5aMLDXkqqg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点「赞」和「在看」是最大的支持&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages __bg_gif wxw-img&quot; data-backh=&quot;122&quot; data-backw=&quot;578&quot; data-fileid=&quot;100001963&quot; data-ratio=&quot;0.21066666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/gf7zJ2NXUibGWic6DENZvSZyv968a9qRfr90n88LFic7fPLv6sQuibcpcpCsEDguL2rIdxvkoQ96YU1XGgTfhKMNgA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;👇更多精彩内容，请点击&lt;strong&gt;「&lt;/strong&gt;&lt;span&gt;阅读原文&lt;/span&gt;」&lt;/strong&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>28b2fa63c0545cb6d028d523349f7c35</guid>
<title>国内再添开源图形引擎：蚂蚁 Oasis Engine 实践之路</title>
<link>https://toutiao.io/k/9h9igaa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;采访嘉宾 | 烧鹅&lt;/section&gt;&lt;section&gt;
编辑 | 闫园园&lt;/section&gt;&lt;p&gt;随着互联网技术的发展，Web 前端也出现了不同分支，除了传统网页开发以外，前端图形领域也逐渐独立为一个重要方向。虽然目前从整体上来看，前端图形领域还是比较小众的领域，但从发展势头来看，其未来发展前景还是值得关注。&lt;/p&gt;&lt;p&gt;然而，进入 3D 图形世界除了能看到炫酷的效果以外还是非常令人生畏的，如果不了解 3D 渲染的原理，反而很容易让自己陷入泥潭。那么目前国内外前端图形领域现状究竟怎样？入手前端图形领域又该有怎样的准备？带着以上疑问，InfoQ 特别采访了蚂蚁 Oasis &lt;span&gt;Engine &lt;/span&gt;团队负责人烧鹅。Oasis Engine （以下简称 &lt;span&gt;Oasis&lt;/span&gt;）是驱动支付宝五福、打年兽等互动游戏的图形引擎，由蚂蚁集团 RichLab 互动科技团队自研，刚刚度过开源一周年生日。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;图形学现状与发展前景&lt;/span&gt;
&lt;/section&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：首先请您聊聊前端与图形学的关系。&lt;/section&gt;&lt;p&gt;&lt;strong&gt;烧鹅：&lt;/strong&gt;前端与图形学的关系，我们从两方面来谈：&lt;/p&gt;&lt;p&gt;第一，标准方面。往 Web 图形技术的底层去深究，首先要追溯到国际组织 Khronos Group ，Khronos Group 专注于创立开放标准，免授权费的移动设备接口程序 API , 其制定了 OpenGL 标准，这也是行业领域中最为广泛接纳的 2D/3D 图形 API。&lt;/p&gt;&lt;p&gt;而后基于 OpenGL 在移动端的分支标准 OpenGL ES，Khronos Group 制定了 WebGL 标准，WebGL 标准提供了 3D 图形的 API，允许使用 HTML5 中的 Canvas 调用相关接口。后来 W3C 组织制定了 WebGPU 标准，与 WebGL 不同的是，WebGPU 不是 OpenGL 的包装，而是直接驱动 Vulkan、Metal 和 DirectX 12 等新生代图形接口，最新版的 Chrome 100 已经默认开启了 WebGPU 的能力。目前，WebGPU 还是一个草案阶段，WebGL 已经发展到 2.0 阶段，这两个标准也是前端实现图形应用的基础 API。&lt;/p&gt;&lt;p&gt;第二，领域方面。前端图形开发可以说是平行于传统前端开发的领域，通常情况下，普通的前端开发基于 React、Vue 等框架，而前端图形开发则依靠图形引擎与游戏开发框架去开发应用，这一点类似于游戏开发与传统软件开发的区别。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：目前国内外前端图形领域的技术发展现状是怎样的？未来前景如何？&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;目前从国内外总体发展现状来看，前端图形领域还是相对比较年轻的，毕竟从标准上来看，2011 年 3 月 WebGL 1.0 规范发布，距今也仅仅 11 年的时间。不过随着标准的逐渐成熟，前端图形引擎也像雨后春笋般涌现出来，就像游戏开发依赖于游戏引擎，前端图形开发也依赖于前端图形引擎，而一个优秀的前端图形引擎的出现势必将会带动整个生态的发展。&lt;/p&gt;&lt;p&gt;另外，目前整个前端图形领域发展滞后的原因，除了标准的滞后还有就是人才的缺失。在大多数开发者眼里，在 Web 里运行图形的性能远远不如原生图形，与其费力不讨好研究 Web 图形，不如转而研究原生图形，这种根深蒂固观念的影响也导致很多人才并没有引入到前端图形领域。&lt;/p&gt;&lt;p&gt;不过，从未来发展趋势来看，前端图形领域还是值得关注的。之前受限于各种软硬件的条件，3D 图形效果在 Web 上往往不能很好实现，而随着硬件设备和网络带宽的不断升级，情况已经大大改善。可以预见，前端在未来业务方面也会面临越来越多的 3D 图形需求。&lt;/p&gt;&lt;p&gt;其次，目前互联网公司内前端图形开发工作大多数还是由 Web 前端工程师担任，相关需求的增多必然会要求前端工程师逐步具备 3D 图形开发能力。总的来说，前端图形领域虽然可能不会有一个爆发式的增长趋势，但长期会出现相对缓慢的增长趋势。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;Oasis 的前端图形学实践&lt;/span&gt;
&lt;/section&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：Oasis 的发展历程中经历了几个重要节点？&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;Oasis 的发展历程可以分为两个重要时期：内部孵化和开源时期。2016 年底，阿里巴巴和蚂蚁的移动端业务发展迅速，在 Web 3D 引擎方面，主要依赖于 Three.js 引擎。虽然 Three.js 引擎本身已经成熟，但其毕竟不是为移动端而生，而且本身功能局限于渲染，三方生态又良莠不齐。另一方面，从技术发展战略上，公司当时已经认识到，面向移动端图形业务，自身有必要去做一个引擎。&lt;/p&gt;&lt;p&gt;在此契机下，仙剑三游戏主程景夫加入蚂蚁开始了引擎的开发，这也是 Oasis 的前身— R3 项目 ，当时，R3 服务的项目还是比较少的，不过直到现在依旧有迹可循，比如我们经常玩的蚂蚁庄园，里面“星星球”的项目就是由这个引擎驱动的，后来，项目也暂停过一个阶段，并没有太多技术上的突破。&lt;/p&gt;&lt;p&gt;直到 2018 年，RichLab 团队接手，开始确定做一个开源引擎。2020 年，拥有多年图形引擎架构和开发经验的尘沫加入团队，主导了整个引擎的重构，也是从这时候开始，团队对引擎功能、性能、易用性等方面有了更高的要求。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：聊聊 Oasis 组件化设计的初衷是什么？组件化架构的设计对于引擎开发有没有带来相关挑战，团队是怎样解决的。&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;组件化架构初衷有两方面， 首先，就图形引擎或者游戏引擎而言，其本身的功能是非常复杂的，除了需要具备三维渲染能力，还需要包含非常多细分领域的功能，比如 2D、3D、UI、音频、物理、VR/AR、逻辑编写等等。采用组件化架构，功能本身就是一个模块，以组件的形式插拔，灵活组合。这样可以更加优雅地组织场景，避免面向对象编程中继承式设计带来的嵌套以及性能损耗。&lt;/p&gt;&lt;p&gt;其次，组件化架构设计对编辑器的可视化展示也是非常友好的。在编辑器上，功能的展示也是扁平罗列出来，从视觉上就可以清楚的判断哪个功能需要，这对于使用者来说也比较简单。&lt;/p&gt;&lt;p&gt;当然组件化架构设计也并非一帆风顺，在重构过程中，团队也面临了诸多挑战。在组件化架构第一版，我们简单粗暴地去递归遍历场景中的每个节点和节点下的组件，而非用缓存组件队列，也没有设计配套的脚本组件接口，导致性能和功能都存在较大缺陷。后期通过引擎的进一步重构，组件化性能问题才得以解决。&lt;/p&gt;&lt;p&gt;另外，组件化架构和编辑器的有机融合，即组件功能在编辑器里的展示，中间也多涉及交互层的设计，目前团队也仍在持续解决中。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：Oasis 应用的是 TypeScript 语言，是如何考虑的，有怎样的意义？&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;Oasis 的开发语言采用了 TypeScript，TypeScript 是 JavaScript 的超集，相比弱类型的 JavaScript 具有非常大的优势。尤其对于大型复杂项目来说，TypeScript 带来的研发效率优势非常明显。&lt;/p&gt;&lt;p&gt;我们用 Typescript 有两方面的原因，首先对于引擎用户开发者来说，Typescript 最大的优势是有代码提示。作为一个 API 功能非常复杂的引擎来说，查 API 手册就像翻阅一本新华字典，这对于开发者来说是一种压力，这种情况下，代码提示显得尤为重要。&lt;/p&gt;&lt;p&gt;其次，对于引擎开发者来说，TypeScript 定义了弱类型语言缺失的能力，比如装饰器、枚举、类型转换等等。这些新的类型和方法，能够帮助开发者减少引擎的代码量，比如我们用了装饰器之后，代码设计非常干净，而运用了枚举，能够高效地组织代码结构、提升代码的健壮性。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：除了功能，Oasis 在提升性能方面做了哪些技术上的努力？&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;Web 图形引擎性能优化一个核心的思想就是：重 GPU 轻 CPU，在这个思想下面再去做一些针对细节的优化 。&lt;/p&gt;&lt;p&gt;虽然 GPU 在复杂计算方面能力弱一点，但是它能够同时进行更多简单的任务，而且就目前现状来看，JS 相对 C++ 等原生 CPU 语言运行效率更低，所以引擎整体性能优化即重 GPU 轻 CPU，一方面把骨骼动画、粒子动画等较大规模的原本 CPU 的计算量转嫁到 GPU 中，另一方面减少 CPU 到 GPU 的资源传输，包括传输量和传输频率，通过这种方式，提升了引擎本身性能。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;Oasis 未来发展规划&lt;/span&gt;
&lt;/section&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：能否介绍一下 Oasis 下一步技术规划是怎样的？&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;第一，我们继续深入完善引擎本身更多高级功能，包括物理系统、动画等，增加更多项目案例，进一步降低开发者的上手成本；第二，我们计划在年底开放编辑器，打造一些插件功能；第三，我们也将进一步加强开源影响力建设，不拘泥于国内，而是增加国际影响力。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：您认为 Oasis 作为一个 Web 3D 互动图形引擎开源的意义是什么？建立一个持续、健康的开源项目需要哪些准备或者要素。&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;首先，Oasis 开源的意义在于把引擎往更丰富的业务场景里面去应用，同时也能依靠社区的力量进一步扩大引擎的生态，举个例子，比如适配微信小程序，可能我们没有精力去做，但社区里的开发者会进行相应的完善；其次，开源能够让团队不再拘泥于开发思维而是扩展更多产品、业务思维，这对于自身发展成长也是大有裨益；最重要的一点，选择开源也希望引擎对整个前端图形领域有一定的贡献。很多前端工程师都表示 Oasis Engine 是接触的第一个图形引擎，容易上手，这也可以帮助更多对图形学感兴趣的前端工程师们增加对此领域的了解。&lt;/p&gt;&lt;p&gt;当然，真正的开源，是一种可持续、健康的状态。做开源的话需要做到三点：第一，不要去做所谓的代码开源，而要做到流程规划、问题管理等全部开源；第二，不要只停留在国内，而要多接触国外开发者；第三，持续地做出社区感兴趣的应用，扩大影响力。比如，Unity 每年都会做开发者大会，展示引擎的新功能以及酷炫、让人眼前一亮的效果，他们在内容制作这方面也是值得大家学习的。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
InfoQ：最后，您有没有想跟打算学习或者入行前端图形领域的前端工程师们分享的经验或者看法。&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅&lt;/span&gt;：&lt;/strong&gt;随着时代的变化，一些传统的前端工程师已经不满足于现在的界面开发，想去拓宽自己的技术栈，比如图形学方向。&lt;/p&gt;&lt;p&gt;首先，如果前端开发者不满足控制 CSS 的盒模型，而是渴望控制的屏幕上的每个像素，去绘制更有想象力的空间，我认为现在是一个转向前端图形领域不错的时机；其次，经验方面，可以先学图形学的基础课程，对图形学有高屋建瓴的认知，这是很关键的，进一步判断自己是否真正感兴趣，如果感兴趣的话可以开始上手使用一些引擎，比如 Unity 、Oasis 等，通过对引擎的使用，掌握常见的图形学里面的概念，比如灯光、材质等。&lt;/p&gt;&lt;p&gt;另一方面，如果有同学想转引擎开发工程师的话，需要更深度的学习。因为引擎里面的分支也是非常复杂的，包括像我们现在做的互动，也只是一个比较窄和小众的领域。计算机图形领域是一个非常庞大的领域，需要有很深的知识储备，掌握基础知识之后再去挑选自己感兴趣的分支领域发展，比如渲染、物理、动画等等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Oasis 官网：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://oasisengine.cn/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Github 地址：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://github.com/oasis-engine/engine&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
嘉宾介绍：&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;烧鹅（徐乾伟）&lt;/span&gt;：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;蚂蚁集团 Oasis Engine 团队负责人，高级前端技术专家，主导了阿里集团和蚂蚁集团互动图形方向的技术发展，目前致力于 Oasis Engine 引擎和编辑器的产品化建设。&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>08205541f462154a92b25faeb17365d7</guid>
<title>FastDFS 海量小文件存储解决之道</title>
<link>https://toutiao.io/k/d85mi3w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一、FastDFS原理介绍&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;FastDFS是一个C语言实现的开源轻量级分布式文件系统 。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;支持 Linux、FreeBSD、AID 等Unix系统，解决了大容量的文件存储和高并发访问问题，文件存取实现了负载均衡，适合存储 4KB~500MB 之间的小文件，特别适合以文件为载体的在线服务，如图片、视频、文档等等。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、FastDFS 架构&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;FastDFS 由三个部分构成：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;客户端（Client）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;跟踪服务器（TrackerServer）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;存储服务器（StorageServer）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6766766766766766&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4dOWd7AD0U8Vfo8XnXGsmib5icASNXjTkOEF2HhXibT9B5QQ5RRPKiclFBzRsddicbbBGhvgyFhXO8wQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;999&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2.1 Tracker Server (跟踪服务器)&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Tracker Server (跟踪服务器) &lt;/strong&gt;主要是做调度工作，起到负载均衡的作用。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（1）【服务注册】&lt;/strong&gt;管理StorageServer存储集群，StorageServer启动时，会把自己注册到TrackerServer上，并且定期报告自身状态信息，包括磁盘剩余空间、文件同步状况、文件上传下载次数等统计信息。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（2）【服务发现】&lt;/strong&gt;Client访问StorageServer之前，必须先访问TrackerServer，动态获取到StorageServer的连接信息，最终数据是和一个可用的StorageServer进行传输。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（3）【负载均衡】&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;store group分配策略：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;0：轮询方式&lt;/p&gt;&lt;p&gt;1：指定组&lt;/p&gt;&lt;p&gt;2：平衡负载(选择最大剩余空间的组(卷)上传)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;store server分配策略：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;0：轮询方式&lt;/p&gt;&lt;p&gt;1：根据 IP 地址进行排序选择第一个服务器（ IP 地址最小者）&lt;/p&gt;&lt;p&gt;2：根据优先级进行排序（上传优先级由storage server来设置，参数名为upload_priority）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;stroe path分配 ：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;0：轮流方式，多个目录依次存放文件&lt;/p&gt;&lt;p&gt;2：选择剩余空间最大的目录存放文件（注意：剩余磁盘空间是动态的，因此存储到的目录或磁盘可能也是变化的）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 Tracker Server (跟踪服务器)&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Tracker Server (跟踪服务器) &lt;/strong&gt;主要提供容量和备份服务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;【分组管理】&lt;/strong&gt;以Group为单位，每个Group包含多台Storage Server，数据互为备份，存储容量以Group内容量最小的 storage 为准，已 Group 为单位组织存储方便应用隔离、负载均衡和副本数据定制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;Group容量受单机存储容量的限制，数据恢复只能依赖Group其他机器重新同步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;【数据同步】&lt;/strong&gt;文件同步只能在 Group 内的Storage Server之间进行，采用push方式，即源服务器同步给目标服务器。源服务器读取 binlog 文件，将文件内容解析后，按操作命令发送给目标服务器，有目标服务按命令进行操作。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、上传下载流程&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 上传流程解析&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;404&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6997578692493946&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4dOWd7AD0U8Vfo8XnXGsmibLotQ2hpib6mhCOzqTxEiaUl6HJibEWR7GdaD6oom7Twk9F0uy5DkpxfzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.1.1 选择Tracker Server&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;集群中的 tracker 之间都是对等的，客户端在上传文件时可任意选择一个 tracker 即可。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.1.2 分配Group、Stroage Server 和storage path（磁盘或者挂载点）&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;tracker 接收到上传请求时会先给该文件分配一个可以存储的 Group ，然后在Group中分配一个Storage Server给客户端，最后在接收到客户端写文件请求时，Storage Server 会分配一个数据存储目录并写入。&lt;/p&gt;&lt;p&gt;（该过程中的分配策略详见：【负载均衡】）&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.1.3 生成file_id写入并返回&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Storage 会生成一个 file_id 来作为当前文件名，file_id 采用 base64 编码，包含：&lt;span&gt;源 storage server ip&lt;/span&gt;、&lt;span&gt;文件创建时间&lt;/span&gt;、&lt;span&gt;文件大小&lt;/span&gt;、&lt;span&gt;文件CRC32校验码&lt;/span&gt; 和 &lt;span&gt;随机数&lt;/span&gt;。每个存储目录下 有两个256*256个子目录。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Storage 会根据 file_id 进行两次 hash 路由到其中一个子目录中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后以file_id为文件名存储文件到该子目录下并返回文件路径给客户端。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最终文件存储路径：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;**分组 |磁盘|子目录| 文件名 **&lt;/p&gt;&lt;p&gt;group1/M00/00/89/eQ6h3FKJf_PRl8p4AUz4wO8tqaA688.apk&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2  下载流程解析&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6233031674208145&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4dOWd7AD0U8Vfo8XnXGsmibaKu9AJsQoomwukErdshic8j380rqWgKnRFnm8OVn907icAqiaJSt0Vsww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;884&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.1 解析路径并路由&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;tracker 接收 client 发送的下载请求时，tracker 从文件名中解析出 Group、大小、创建时间等信息，然后根据Group 选择一个 storage server 返回。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.2 校验读取并返回&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;客户端和 Storage Server 建立链接，校验文件是否存在，最终返回文件数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;Group之间文件同步是异步进行的，可能上传的文件还未同步到当前访问的 Storage Server 这台机器上或者延迟原因，将导致下载文件出现404。所以引入nginx_fastdfs_module 可以很好的解决同步和延迟问题。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.3 引入fastdfs_nginx_module组件后的下载架构&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7222222222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4dOWd7AD0U8Vfo8XnXGsmibVH7OAsApfgVV3xqSHLPJFicskkkpicajDcTibgxX7eneXnnz1n059juibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;990&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;FastDFS Nginx Module功能介绍&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（1）【防盗链检查】&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;利用 FastDFS nginx 扩展功能动态生成token，设置http.conf 配置。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;【token 生成算法】：md5(fileid_without_group + privKey + ts) 同时ts没有超过 ttl 范围。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;服务器会自动根据token,st 以及设置的秘钥来验证合法性。访问链接形式如：&lt;/p&gt;&lt;p&gt;http://localhost/G1/M00/00/01/wKgBD01c15nvKU1cAABAOeCdFS466570.jpg?token=b32cd06a53dea4376e43d71cc882f9cb&amp;amp;ts=1297930137&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（2）【文件元数据解析】&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;根据 file_id 获取元数据信息, 包括：&lt;strong&gt;源&lt;/strong&gt;&lt;strong&gt;storage ip，文件路径，名称，大小&lt;/strong&gt; 等。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（3）【文件访问路由】&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因文件的file_Id 包含了上传文件时的源 Storage Server IP ，所以在获取不到本机下的文件时（未同步或者延迟情况下）FastDFS 扩展组件，会根据源服务器IP 来重定向或者代理方式获取文件。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、同步机制&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.1 同步规则&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;同步只发生在本组的 Storage Server 之间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;源头数据才需要同步，备份数据不需要再次同步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;新增 Storage Server 时，会由已有一台 Storage Server 将已有的所有数据（源头数据和备份数据）同步给新增服务器。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 Binlog 复制&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;FastDFS 文件同步采用binlog异步复制方式，Storage Server 使用binlog文件记录文件上传、删除等操作，根据Binlog进行文件同步。Binlog中只记录文件ID和操作，不记录文件内容 .binlog 格式如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;时间戳 | 操作类型 | 文件名&lt;/p&gt;&lt;p&gt;1490251373 C M02/52/CB/&lt;/p&gt;&lt;p&gt;CtAqWVjTbm2AIqTkAAACd_nIZ7M797.jpg&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;操作类型（部分）：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;C表示源创建、c表示副本创建&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A表示源追加、a表示副本追加&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;D表示源删除、d表示副本删除&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;. . . . . . .&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.3 同步流程&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5050890585241731&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4dOWd7AD0U8Vfo8XnXGsmibO7Wrm8TaTS84U08MlYbEocjb6Xic4JaZPjHEb4cRJf2iauzUic8uwaBxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;新增 Storage Server 后，组内其他 Storage Server 服务器会启动同步线程，在 tracker的协调下向新增服务器发起全量和增量同步操作。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（1）Storage C启动后向tracker 上报所属group、ip、port、版本号、存储目录数、子目录数、启动时间、老数据是否同步完成，当前状态等信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（2）tracker 收到Storage C 加入申请请求后，更新本地storage list，返回给C，并适时同步给A、B。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（3）storage C向tracker 申请同步请求，响应后变更自身状态为WAIT_SYNC。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（3）storage A 和B 在心跳周期内从同步到的新storage list 发现没有C，则启动同步线程，先向tracker发起同步申请&lt;/p&gt;&lt;p&gt;（TRACKER_PROTO_CMD_STORAGE_SYNC_SRC_REQ）,tracker会把同步源IP级同步时间戳返回给A和B,如果源IP和自己本地IP一致，则标记自己作为同步源用来做老数据同步（全量同步源），如果不一致，则标记自己作为增量同步源（只有在C节点状态为Active时才同步）。该决策是由tracker 选择产生的，不可A、B同时作为同步源，同时同步给C。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（3）同步源（假设是storage A）以 .mark为后缀的文件记录目标机器同步信息，并上报变更storage C状态为SYNCING。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（4）从/data.sync目录下读取binlog.index 中的，binlog文件Id，binlog.000读取逐行读取，进行解析.(详见上面binlog 内格式) 发送数据给storage C ，C接收并保存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（5）数据同步过程中 storage C 的状态变更过程OFFLINE-&amp;gt;ONLINE-&amp;gt;ACTIVE。ACTIVE 是最终状态，表示storage C 已对外提供服务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、文件存储&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.1 LOSF问题&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;小文件存储（LOSF）面临的问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对小文件存储问题，FastDFS 提供了文件合并解决方案。FastDFS 默认创建大文件为 64M，大文件可以存储很多小文件，容纳一个小文件的空间叫slot，solt 最小256字节，最大16M。小于256字节当256字节存储，超过16M文件单独存储。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.2 存储方式&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（1）【默认存储方式】&lt;/strong&gt;未开启合并 ，FastDFS生成的file_id 和磁盘上实际存储的文件一一对应。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2）【合并存储方式】&lt;/strong&gt;多个file_id对应文件被存储成了一个大文件 。trunk文件名格式：/fastdfs/data/00/000001 文件名从1开始递增。而生成的file_id 更长，会新增16个字节额外内容用来保存偏移量等信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;【file_size】：占用大文件的空间（注意按照最小slot-256字节进行对齐）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【mtime】：文件修改时间 &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【crc32】：文件内容的crc32码 &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【formatted_ext_name】：文件扩展名 &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【alloc_size】：文件大小与size相等 &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【id】：大文件ID如000001&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【offset】：文件内容在trunk文件中的偏移量 &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【size】：文件大小。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.4 存储空间管理&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（1）【Trunk Server】&lt;/strong&gt;由tracker leader 在一组Storage Server 选择出来的，并通知给该组内所有Storage Server，负责为该组内所有upload操作分配空间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2）【空闲平衡树】&lt;/strong&gt;trunk server 会为每个store_path构造一个空闲平衡树，相同大小的空闲块保存在链表中，每次上传请求时会到根据上传的文件大小到平衡树中查找获取大于或者接近的空闲块，然后从空闲块中分割出多余的作为新的空闲块，重新加入平衡树。如果找不到则会重建一个新的trunk文件，并加入到平衡树中。该分配过程即是一个维护空闲平衡树的过程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（3）【Trunk Binlog】&lt;/strong&gt;开启了合并存储后，Trunk Server 会多出一个TrunkBinlog同步。TrunkBinlog记录了TrunkServer 所有分配与回收的空闲块操作，并由Trunk Server同步给同组中其他storage server。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;TrunkBinlog格式如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;时间戳 | 操作类型 | store_path_index | &lt;/p&gt;&lt;p&gt;sub_path_high| sub_path_low | &lt;/p&gt;&lt;p&gt;file.id| offset | &lt;/p&gt;&lt;p&gt;size 1410750754 A 0 0 0 1 0 67108864&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;各字段含义如下： &lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;六、文件去重&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;FastDFS不具备文件去重能力，必须引入FastDHT 来配合完成。FastDHT 是一个键值对的高效分布式hash系统，底层采用Berkeley DB 来做数据库持久化，同步方式使用binlog复制方式。在FastDFS去重场景中，对文件内容做hash，然后判断文件是否一致。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在文件上传成功后，查看 Storage存储对应存储路径，会发现返回的是一个软链接，之后每次重复上传都是返回一个指向第一次上传的文件的软链接。也就保证了文件只保存了一份。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（注意：FastDFS不会返回原始文件的索引，返回的全部都是软链接，当所有的软链接都被删除的时候，原始文件也会从FastDFS中被删除）。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;七、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;FastDFS 真正意义上只是一个管理文件的系统（应用级文件系统），比如管理上传文件、图片等。并不像系统磁盘文件系统NTFS或者FAT 等这种系统级文件系统。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:1.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo互联网技术&quot; data-alias=&quot;vivoVMIC&quot; data-signature=&quot;分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8eaa9afeb2b13b91e95e936cbdc9c92e</guid>
<title>性能分析优化的道与术</title>
<link>https://toutiao.io/k/2bi822s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;h2&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;之前有很多同学问我，性能测试中到底该如何去定位分析瓶颈并进行性能优化？感觉压测场景设计做的很全面，分析工具也用了很多，但一直无法快速的定位分析并进行优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;性能分析和优化一直是技术领域热门的一个话题，无论是三高（高性能、高可用、高稳定），还是CAP（数据一致性、服务可用性、分区容错性），都强调了服务的性能和可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这篇文章，我想谈谈我对于性能分析和优化的一些理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;请求是如何被处理的？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;“工欲善其事，必先利其器；欲利其器，必晓其理”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在进行性能分析优化之前，先来看看一个请求处理的生命周期图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4707792207792207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ftksfIbzTWia60vicqBiczz1o6lfbMTaIWUdLibasxuEFJeT6BXYCXOyuKQo1SZIqQAqks0NIbQXASBxibvlFDkTJUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，是常见的一个微服务分布式架构下的请求处理过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们经常谈的性能快和慢，实际上是一个相对的数值，它更多的是我们对于用户使用系统时访问速度体验的评估。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此在进行性能定位分析之前，一定要清楚请求经过了哪些链路环节？它们的耗时分别是多少？是否是正常数值区间？如果数值异常，可能的原因是什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过快速排除法，将性能分析和优化的点聚焦在一定范围内，这样才能快速定位排查原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;常见的性能问题与原因&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;看了上面的请求处理生命周期流程图，可以得到下面几点影响性能的因素。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;网络带宽&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;网络对性能的影响不言而喻。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果带宽不足，单位时间内的请求过多，就会导致数据包的传输延迟较大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果网络不稳定，也会导致RT的曲线抖动较为剧烈，产生毛刺甚至丢包，这个时候P90/P99的数值也可能变大。&lt;/span&gt;&lt;span&gt;因此稳定和足够的网络带宽，对系统的性能来说是很重要的。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;负载均衡&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;现在的SLB层已经优化的足够好，但如果负载均衡出现问题，可能会导致流量分发不均匀，导致部分应用节点流量异常，健康检查不通过从而被踢下线。甚至服务注册重试失败或者弹性扩容不够及时，还会导致可用的节点承受了较多的请求最终导致雪崩效应。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;安全策略&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;现在的软件系统，常见的安全防护策略有ddos高防以及WAF，一般都是部署在SLB和流量网关之间或者更上层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;安全防护策略常见的场景有异常检测、输入验证、安全补丁、状态管理以及基于规则和异常的保护功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些安全策略能够有效的保护系统不受到一些恶意的攻击和侵入，但这些策略生效也是需要耗费时间的。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;流量网关&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;上面提到的几个部分都可以看做是互联网时代的基础通用层，而网关是伴随着微服务和容器化出现的，作为用户流量的系统入口，网关也承担了较多的功能，比如：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;日志&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;身份鉴权&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;灰度发布&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;限流熔断&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可观测性metrics&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;应用限流apm tracing&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;上述的功能，无论是身份鉴权还是可观测性的metrics的实现，都需要耗费一定时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;特别是对于请求的RT比较敏感的业务，对流量网关功能的耗时要求更为严格。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Web应用层&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近几年前后端分离的系统设计越来越多，web层更多的负责页面的渲染展示和部分讨好用户的交互设计。&lt;/span&gt;&lt;span&gt;如何让用户更快感知到他所感兴趣的东西，这个时候CDN和缓存就派上用场了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用CDN和缓存特性“就近加载”，让用户感知的性能更快，也是性能优化领域很重要的一点。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;APP应用层&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;前面讲了web层负责页面渲染展示和友好的交互，那App应用层（即我们常说的后端服务）则更多的负责逻辑计算。&lt;/span&gt;&lt;span&gt;逻辑计算是很吃资源的，当然和它的一些参数配置以及技术架构也有较大关联。&lt;/span&gt;&lt;span&gt;常见的影响后端服务性能的因素如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据存储层&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据存储层即数据库，数据库层面影响性能的因素应该是最常见也是最多的。比如：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;锁：不合理的锁使用导致的请求等待；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;索引：未加索引或索引未生效导致慢SQL；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据量：表数据量过大导致的读写变慢等问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;针对业务扩张及数据量变大问题，常见的优化策略有分库分表、垂直拆分、读写分离。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;压测不是发现问题的唯一手段&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;回到性能定位分析和优化的话题上，关于性能优化，如下三点是必须铭记的。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;性能优化的目标&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在保持和降低系统99%RT的前提下，不断提高系统吞吐量，提高流量高峰时期的服务可用性。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;性能优化的挑战&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;日益增长的用户量（带来访问量的提升，大数据量的存储和处理）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;越来越多样的业务（业务的不断迭代和发展，会使其复杂性指数提升）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;越来越复杂的系统（为了支撑业务迭代发展，系统架构会变得很复杂）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;性能优化的路径&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;PS：三者关系在某些场景下互相矛盾冲突，不可兼得&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;！&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;性能优化的道法术器&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;基于上述的几点内容，结合我个人实践经验和看法，性能定位和分析有下面四个境界：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;道：熟悉业务逻辑，了解系统架构；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;法：掌握技术原理，熟知问题定位和分析优化的软件工程方法论；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;术：不断实践踩坑，总结归纳性能验证、定位分析的方法和经验；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;器：熟练使用性能测试、监控追踪、问题分析和优化的各种工具并擅加利用；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;如何让系统运行的更快更稳定&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;时间空间&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;软件系统的三高（高性能、高可用、高稳定）要求，归根结底实际上需要在成本、收益、风险之间做取舍，我们很难做到用最低的成本达到最好的效果。有个很早之前的优化理论，叫做“时间换空间，空间换时间”，讲的就是在响应时间和硬件资源消耗之间做平衡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;性能优化的关键在于平衡各部分组件的性能平衡点，如果CPU资源有空闲，但是&lt;/span&gt;&lt;span&gt;内存&lt;/span&gt;&lt;span&gt;使用紧张，便可以使用时间换空间的策略，达到整体的性能优化；反之CPU资源紧张，内存资源有空闲，则可以使用空间换时间的策略，提升整体性能。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;分层优化&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;请求的处理过程要经过多个链路环节，除了优化耗时最长难度和成本较低的环节之外，在每个环节都进行一定优化，则对整体性能的提升有很大帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面是流量高峰时的一些优化或者说应对案例：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;扩容&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：DB是有状态服务，计算层便于扩容，将DB节点放到容器中，有需要扩容；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;灾备&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：对于大流量读场景可通过流量切换方式，将部分流量迁移到备份集群分流；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;巡检&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：慢SQL是常见的问题，可通过自动监控和历史数据分析，提供辅助式决策；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;应用层(计算层)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;67311&quot; data-type=&quot;lspecial02&quot; data-tools=&quot;速排小蚂蚁编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;如果喜欢我文章，点赞、关注、在看三走起。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;如果想阅读更多文章，可以关注我的公众号。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NDAwMjM1NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ftksfIbzTWhnnG3FnMGxk4tujZAJv8cPZibDbChbEzPK3FJD5aM9XFQQicu4Lu3L3eo5ldtz5Q63ctdpxhAD25rw/0?wx_fmt=png&quot; data-nickname=&quot;老张的求知思考世界&quot; data-alias=&quot;Engineer_Way&quot; data-signature=&quot;专注互联网技术及相关领域，也分享职场成长、读书思考的内容。这是一个求知探索之人，在寻找更多可能性的旅途中的记录。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>