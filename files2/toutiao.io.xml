<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5c2877b25df558462e2bb2149049e027</guid>
<title>@Autowired 的这些新姿势，你学会了？</title>
<link>https://toutiao.io/k/rffhesh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxODkzNTQ3Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uL371281oDHlDcdbjNJic1yCwAu2dmJ9AunIQh9DXdm5JE7v9libnPgJQicoaGs9Eiaee2kPeFGWJxsPkZ9zCQbrIw/0?wx_fmt=png&quot; data-nickname=&quot;苏三说技术&quot; data-alias=&quot;susanSayJava&quot; data-signature=&quot;「苏三说技术」 维护者目前就职于某知名互联网公司，从事开发、架构和部分管理工作。实战经验丰富，对jdk、spring、springboot、springcloud、mybatis等开源框架源码有一定研究，欢迎关注，和我一起交流。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近review别人代码的时候，看到了一些&lt;code&gt;@Autowired&lt;/code&gt;不一样的用法，觉得有些意思，特定花时间研究了一下，收获了不少东西，现在分享给大家。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也许&lt;code&gt;@Autowired&lt;/code&gt;比你想象中更强大。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.577490774907749&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFRH6sbHueZibfW3m5gu2UDFQKicQyKI4h9e20iaW4Qib4iauQiba94m0FSicvRSp9C7WRTbQ34VicRGGKUTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1084&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. @Autowired的默认装配&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道在spring中@Autowired注解，是用来自动装配对象的。通常，我们在项目中是这样用的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.sue.cache.service;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.stereotype.Service;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.sue.cache.service;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.stereotype.Service;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，这样是能够装配成功的，因为默认情况下spring是按照类型装配的，也就是我们所说的&lt;code&gt;byType&lt;/code&gt;方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，@Autowired注解的&lt;code&gt;required&lt;/code&gt;参数默认是true，表示开启自动装配，有些时候我们不想使用自动装配功能，可以将该参数设置成false。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 相同类型的对象不只一个时&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面&lt;code&gt;byType&lt;/code&gt;方式主要针对相同类型的对象有且只有一个的情况，此时对象类型是唯一的，可以找到正确的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果相同类型的对象不只一个时，会发生什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目的test目录下，建了一个同名的类TestService1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.sue.cache.service.test;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.stereotype.Service;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重新启动项目时：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Caused by: org.springframework.context.annotation.ConflictingBeanDefinitionException: Annotation-specified bean name &lt;span&gt;&#x27;testService1&#x27;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; bean &lt;span&gt;&lt;span&gt;class&lt;/span&gt; [&lt;span&gt;com&lt;/span&gt;.&lt;span&gt;sue&lt;/span&gt;.&lt;span&gt;cache&lt;/span&gt;.&lt;span&gt;service&lt;/span&gt;.&lt;span&gt;test&lt;/span&gt;.&lt;span&gt;TestService1&lt;/span&gt;] &lt;span&gt;conflicts&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; &lt;span&gt;existing&lt;/span&gt;, &lt;span&gt;non&lt;/span&gt;-&lt;span&gt;compatible&lt;/span&gt; &lt;span&gt;bean&lt;/span&gt; &lt;span&gt;definition&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; &lt;span&gt;same&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; [&lt;span&gt;com&lt;/span&gt;.&lt;span&gt;sue&lt;/span&gt;.&lt;span&gt;cache&lt;/span&gt;.&lt;span&gt;service&lt;/span&gt;.&lt;span&gt;TestService1&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果报错了，报类类名称有冲突，直接导致项目启动不来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意，这种情况不是相同类型的对象在Autowired时有两个导致的，非常容易产生混淆。这种情况是因为spring的@Service方法不允许出现相同的类名，因为spring会将类名的第一个字母转换成小写，作为bean的名称，比如：testService1，而默认情况下bean名称必须是唯一的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看看如何产生两个相同的类型bean：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;(&lt;span&gt;&quot;test1&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TestService1 &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TestService1();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;(&lt;span&gt;&quot;test2&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TestService1 &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TestService1();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在TestConfig类中手动创建TestService1实例，并且去掉TestService1类上原有的@Service注解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重新启动项目：&lt;img data-ratio=&quot;0.17408906882591094&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFRH6sbHueZibfW3m5gu2UDFcpw5DY021wCmdt6IdBL7muhAxrjwCG6OQH9ozpoEgfFEzAnWMj5XpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1482&quot;/&gt;果然报错了，提示testService1是单例的，却找到两个对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实还有一个情况会产生两个相同的类型bean：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IUser&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User1&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IUser&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User2&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IUser&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目重新启动时：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.07684824902723736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFRH6sbHueZibfW3m5gu2UDFAbpTK71p09ibgwZ7uAG9PknA0pcVTb7n1WjguOnnkxqibLm8ZIHlagQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2056&quot;/&gt;报错了，提示跟上面一样，testService1是单例的，却找到两个对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种情况在实际的项目中出现得更多一些，后面的例子，我们主要针对第二种情况。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. @Qualifier和@Primary&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然在spring中，按照Autowired默认的装配方式：byType，是无法解决上面的问题的，这时可以改用按名称装配：byName。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需在代码上加上&lt;code&gt;@Qualifier&lt;/code&gt;注解即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Qualifier&lt;/span&gt;(&lt;span&gt;&quot;user1&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调整之后，项目就能正常启动了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Qualifier意思是合格者，一般跟Autowired配合使用，需要指定一个bean的名称，通过bean名称就能找到需要装配的bean。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上面的&lt;code&gt;@Qualifier&lt;/code&gt;注解之外，还能使用&lt;code&gt;@Primary&lt;/code&gt;注解解决上面的问题。在User1上面加上@Primary注解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Primary&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User1&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IUser&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;去掉UserService上的@Qualifier注解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重新启动项目，一样能正常运行。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当我们使用自动配置的方式装配Bean时，如果这个Bean有多个候选者，假如其中一个候选者具有@Primary注解修饰，该候选者会被选中，作为自动配置的值。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. @Autowired的使用范围&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的实例中@Autowired注解，都是使用在成员变量上，但@Autowired的强大之处，远非如此。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看@Autowired注解的定义：&lt;img data-ratio=&quot;0.26450892857142855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFRH6sbHueZibfW3m5gu2UDFiaPb1ic9zhnPpMOoMPw2pMxhxjCIET0P11sQcPqc7uQEicoXqlYbxPtWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1792&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中可以看出该注解能够使用在5种目标类型上，下面用一张图总结一下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.577490774907749&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFRH6sbHueZibfW3m5gu2UDFQKicQyKI4h9e20iaW4Qib4iauQiba94m0FSicvRSp9C7WRTbQ34VicRGGKUTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1084&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4.1 成员变量&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在成员变量上使用Autowired注解：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种方式可能是平时用得最多的。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4.2 构造器&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在构造器上使用Autowired注解：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt;&lt;span&gt;(IUser user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.user = user;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;user:&quot;&lt;/span&gt; + user);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;注意，在构造器上加Autowired注解，实际上还是使用了Autowired装配方式，并非构造器装配。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;4.3 方法&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在普通方法上加Autowired注解：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(IUser user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       user.say();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;spring会在项目启动的过程中，自动调用一次加了@Autowired注解的方法，我们可以在该方法做一些初始化的工作。&lt;/p&gt;&lt;p&gt;也可以在setter方法上Autowired注解：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setUser&lt;/span&gt;&lt;span&gt;(IUser user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.user = user;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;4.4 参数&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;可以在构造器的入参上加Autowired注解：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt;&lt;span&gt;(@Autowired IUser user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.user = user;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;user:&quot;&lt;/span&gt; + user);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以在非静态方法的入参上加Autowired注解：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(@Autowired IUser user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       user.say();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;4.5 注解&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;这种方式其实用得不多，我就不过多介绍了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. @Autowired的高端玩法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实上面举的例子都是通过@Autowired自动装配单个实例，但这里我会告诉你，它也能自动装配多个实例，怎么回事呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将UserService方法调整一下，用一个List集合接收IUser类型的参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; List&amp;lt;IUser&amp;gt; userList;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Set&amp;lt;IUser&amp;gt; userSet;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, IUser&amp;gt; userMap;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;userList:&quot;&lt;/span&gt; + userList);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;userSet:&quot;&lt;/span&gt; + userSet);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;userMap:&quot;&lt;/span&gt; + userMap);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;增加一个controller：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/u&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserService userService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        userService.test();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;success&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用该接口后：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.0810126582278481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFRH6sbHueZibfW3m5gu2UDFa2I31masQia5vBAnguX2kB59xibe2zt8Z4M1Dlf7eWtunbFKNiaKbfOKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1580&quot;/&gt;从上图中看出：userList、userSet和userMap都打印出了两个元素，说明@Autowired会自动把相同类型的IUser对象收集到集合中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;意不意外，惊不惊喜？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. @Autowired一定能装配成功？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面介绍了@Autowired注解这么多牛逼之处，其实有些情况下，即使使用了@Autowired装配的对象还是null，到底是什么原因呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.1 没有加@Service注解&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在类上面忘了加@Controller、@Service、@Component、@Repository等注解，spring就无法完成自动装配的功能，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        user.say();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况应该是最常见的错误了，不会因为你长得帅，就不会犯这种低级的错误。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.2 注入Filter或Listener&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;web应用启动的顺序是：&lt;code&gt;listener&lt;/code&gt;-&amp;gt;&lt;code&gt;filter&lt;/code&gt;-&amp;gt;&lt;code&gt;servlet&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4131736526946108&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFRH6sbHueZibfW3m5gu2UDFGibPg7VnbKVR3T5JU3EPSnyNMzGmGg1ahDY8lusibRkibPuq5dxV5pOIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;334&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来看看这个案例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserFilter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Filter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(FilterConfig filterConfig)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ServletException &lt;/span&gt;{&lt;br/&gt;        user.say();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doFilter&lt;/span&gt;&lt;span&gt;(ServletRequest request, ServletResponse response, FilterChain chain)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException, ServletException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FilterConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; FilterRegistrationBean &lt;span&gt;filterRegistrationBean&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        FilterRegistrationBean bean = &lt;span&gt;new&lt;/span&gt; FilterRegistrationBean();&lt;br/&gt;        bean.setFilter(&lt;span&gt;new&lt;/span&gt; UserFilter());&lt;br/&gt;        bean.addUrlPatterns(&lt;span&gt;&quot;/*&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序启动会报错：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2995169082125604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFRH6sbHueZibfW3m5gu2UDFEzZrEFgnIChWIqiapL9LzutA4saQCbvPe9KhEXBv34SNpsoeYYd3m0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1656&quot;/&gt;tomcat无法正常启动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么原因呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，springmvc的启动是在DisptachServlet里面做的，而它是在listener和filter之后执行。如果我们想在listener和filter里面@Autowired某个bean，肯定是不行的，因为filter初始化的时候，此时bean还没有初始化，无法自动装配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果工作当中真的需要这样做，我们该如何解决这个问题呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserFilter&lt;/span&gt;  &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Filter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; IUser user;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(FilterConfig filterConfig)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ServletException &lt;/span&gt;{&lt;br/&gt;        ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(filterConfig.getServletContext());&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.user = ((IUser)(applicationContext.getBean(&lt;span&gt;&quot;user1&quot;&lt;/span&gt;)));&lt;br/&gt;        user.say();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doFilter&lt;/span&gt;&lt;span&gt;(ServletRequest request, ServletResponse response, FilterChain chain)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException, ServletException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是使用WebApplicationContextUtils.getWebApplicationContext获取当前的ApplicationContext，再通过它获取到bean实例。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.3 注解未被@ComponentScan扫描&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，@Controller、@Service、@Component、@Repository、@Configuration等注解，是需要通过@ComponentScan注解扫描，收集元数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果没有加@ComponentScan注解，或者@ComponentScan注解扫描的路径不对，或者路径范围太小，会导致有些注解无法收集，到后面无法使用@Autowired完成自动装配的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有个好消息是，在springboot项目中，如果使用了&lt;code&gt;@SpringBootApplication&lt;/code&gt;注解，它里面内置了@ComponentScan注解的功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.4 循环依赖问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果A依赖于B，B依赖于C，C又依赖于A，这样就形成了一个死循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7452830188679245&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFRH6sbHueZibfW3m5gu2UDF4rOziaoHdlTIiaHr0FmianaF2dsT9BaJ5C3bqsooeibkPJFqUqHPAoayoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot;/&gt;spring的bean默认是单例的，如果单例bean使用@Autowired装配，大多数情况，能解决循环依赖问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果bean是多例的，会出现循环依赖问题，导致bean自动装配不了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有有些情况下，如果创建了代理对象，即使bean是单例的，依然会出现循环依赖问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你对循环依赖问题比较感兴趣，也可以看一下我的另一篇专题《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODkzNTQ3Nw==&amp;amp;mid=2247485600&amp;amp;idx=1&amp;amp;sn=0c49b94e7fbd35c88c4470e936023e3e&amp;amp;chksm=f9800e7acef7876ca05ab45ce9420ea140f188e84153f23d0af9d044f475458ad38d49a6546a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;spring：我是如何解决循环依赖的？&lt;/a&gt;》，里面介绍的非常详细。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. @Autowired和@Resouce的区别&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@Autowired功能虽说非常强大，但是也有些不足之处。比如：比如它跟spring强耦合了，如果换成了JFinal等其他框架，功能就会失效。而@Resource是JSR-250提供的，它是Java标准，绝大部分框架都支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，有些场景使用@Autowired无法满足的要求，改成@Resource却能解决问题。接下来，我们重点看看@Autowired和@Resource的区别。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;@Autowired默认按byType自动装配，而@Resource默认byName自动装配。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Autowired只包含一个参数：required，表示是否开启自动准入，默认是true。而@Resource包含七个参数，其中最重要的两个参数是：name 和 type。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Autowired如果要使用byName，需要使用@Qualifier一起配合。而@Resource如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Autowired能够用在：构造器、方法、参数、成员变量和注解上，而@Resource能用在：类、成员变量和方法上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Autowired是spring定义的注解，而@Resource是JSR-250定义的注解。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，它们的装配顺序不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@Autowired的装配顺序如下：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.777059773828756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFRH6sbHueZibfW3m5gu2UDFYOULzz2w16ricuC0KWfXaSAJ65NoZ82CEiatqO1PJwDicURT0LBh2ial3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1238&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;@Resource的装配顺序如下：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果同时指定了name和type：&lt;img data-ratio=&quot;0.8&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFRH6sbHueZibfW3m5gu2UDFlwdmglIXBpwu0xtCCtFKl46QgFuolGYR3z7nFNlvLSMk0avSFYM5uQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果指定了name：&lt;img data-ratio=&quot;0.939873417721519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFRH6sbHueZibfW3m5gu2UDFYb1AAhTf2Khw8lbA4JsPibMickTsALc5LK55hacamZJO41bcCFeNicoYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;632&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果指定了type：&lt;img data-ratio=&quot;0.8559322033898306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFRH6sbHueZibfW3m5gu2UDF4BVH3UCHXibiaPlM8J9nE9byrQPqmRsIZG5SG8PNB8oSav7ep7FKKniag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果既没有指定name，也没有指定type：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0344827586206897&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFRH6sbHueZibfW3m5gu2UDFJChLpKqUYxTP2DMBhLBd6KvK0YWeuIY4DjGp7X93zHK7ZvDFROUUfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我原本打算接下来写@Autowired原理分析和源码解读的，但是由于篇幅太长了，不适合放在一起，后面打算开个专题。如果有兴趣的朋友，可以持续关注我后续的文章，相信你读完必定会有些收获。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后说一句(求关注，别白嫖我)&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这篇文章对您有所帮助，或者有所启发的话，帮忙扫描下发二维码关注一下，您的支持是我坚持写作最大的动力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;求一键三连：点赞、转发、在看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注公众号：【苏三说技术】，在公众号中回复：面试、代码神器、开发手册、时间管理有超赞的粉丝福利，另外回复：加群，可以跟很多BAT大厂的前辈交流和学习。&lt;/p&gt;&lt;p&gt; 个人公众号&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDHUdzOhPCwBUOUgBJ8TrNhn8g5OiaO1C12Y71FPVcyqFkOzz4FnwsLyvZic0dNSYw8hfSjQOeJhDnWw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt; 个人微信&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0048309178743962&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;414&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHUdzOhPCwBUOUgBJ8TrNhnfLeme2LIF0wf8xJX3Oich2efGXhGJic7ibdIDhY9icZiaPAyAFSvVn8AM6w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>59d214a5d512c13f2153bd10779ebf6f</guid>
<title>面阿里 P7，竟问这么简单的题目？</title>
<link>https://toutiao.io/k/9kxllh2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;大家好，我是石头哥。&lt;/p&gt;&lt;p&gt;作为面试官，不管是社招还是校招，我都有多年的经验了。在我参与的所有面试中，我都尽量期望能让候选人有所收获。（当然也期望自己在面试中也有所收获）&lt;/p&gt;&lt;p&gt;当面试完，不管是否通过，当候选人自己或通过 HR 转述表达感激之情时，作为面试官，心理还是蛮高兴的。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2635542168674699&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibtsk25EEJibbywW9v6ZQMzTQmBExyuyibuJz6jNiayhQ0VBAERR6vssuWyXqG1GQicY7ZK6KW2AIZFcQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;figcaption&gt;HR/候选人的好评&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;今天分享的这个问题是我在最近的阿里社招面试中的一道笔试题目。期望通过这道题目的解析，能够让大家了解面试的套路。从面试官角度解读面试过程，希望能让大家有收获。&lt;/p&gt;&lt;p&gt;在正式解析题目之前，先给大家分享下在阿里在线笔试的流程。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;阿里在线 coding&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;需要说明的是，不同部门，不同面试官可能用到的工具或形式不一样。本文提到的是公司系统推荐工具。&lt;/p&gt;&lt;p&gt;一般笔试前，面试官会通过公司的代码评测系统中，给候选人邮箱发送一份测评邀请。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.27710843373493976&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibtsk25EEJibbywW9v6ZQMzTQj2J8g1DxSwyH7mqCJg9JZGffsk8kba88Be7EP5WYWpsz5NLPo4q8ZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1328&quot;/&gt;&lt;figcaption&gt;候选人收到的测评邀请&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;居然暴露了年少时候的火星文 QQ 昵称😑，还记得你第一个 QQ 昵称吗？欢迎评论区留言~&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;点击链接，会进入到在线编程系统，如下图所示：&lt;span/&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.627906976744186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibtsk25EEJibbywW9v6ZQMzTQL2J6XiadrdhxuBeTEWNDnazJibmO3VBF3pCP0P8qfPHDhJ2l4tGkXFOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1978&quot;/&gt;&lt;figcaption&gt;阿里在线测评系统&lt;span/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;该系统有内置系统题库（如下图，5000+道题目，不过我很少看），其实每个面试官基本都会有自己的小题库的。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.621859296482412&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ZMXDhhGnYibtsk25EEJibbywW9v6ZQMzTQWrCpOKxtvibnQWMARaXL7O0AibZblN2WZxJpGqnavglm6BK50nlkN0WQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1592&quot;/&gt;&lt;figcaption&gt;阿里面试题库(题目已打码)&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;根据面试官的风格，可能会选择开启视频，进行视频面试。&lt;/p&gt;&lt;p&gt;候选人可点击左上角切换不用的编程语言，甚至可以切换到 &quot;vim&quot; 模式进行编程。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这里补充分享下石头&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;amp;mid=2247487786&amp;amp;idx=1&amp;amp;sn=842202cc524477ec1546b4747bdbf1a8&amp;amp;chksm=eb4710cedc3099d86953451729c7f569866e6e58abbbec5c7ebe7423d12e1f11e189bb417f80&amp;amp;scene=21&amp;amp;cur_album_id=1514114646956425216#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;使用的 vim 插件列表&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5550122249388753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibtsk25EEJibbywW9v6ZQMzTQvVqGDHmOUiaH9sl2jCzYjuqjk0maSAh859ehIVWicbn3vIAx5Sgq0ttw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另外，提醒下大家，这个系统只是实时在线共享编辑，并不像 leetcode 刷题网站那样能直接编译提交。&lt;/p&gt;&lt;p&gt;面试官其实也主要是考察思路，代码编写风格等，并不是说非得你写出代码能够 AC。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;题目&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;下面，回到本文的题目，我将分享在面试过程中遇到的各种场景。&lt;/p&gt;&lt;p&gt;原本以为这道题目是一道非常简单的题目，但在实际面试过程中，部分候选人的表现却有些出乎意料。&lt;/p&gt;&lt;p&gt;题目本身针对社招P6、P7开发岗位。需要说明的是，这个题目只是整个面试过程中的一个很小的考察环节，能够答对这道题目不代表就一定能通过整个面试。&lt;/p&gt;&lt;p&gt;一般这个题目回答完毕后，后面还会有一道题目。不过很多时候，很多人连这道题目也不会。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 有序数组去重 &lt;br/&gt;输入：[0, 1, 1, 2, 3, 3] &lt;br/&gt;输出：[0, 1, 2, 3]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;这也太简单了吧？看到这里，大家先不要慌着急退出。请耐心看完……&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span&gt;面试过程&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;部分候选人，看到这个题目，然后二话不说，就直接开始写了。&lt;/p&gt;&lt;p&gt;比如，用 Python 的同学可能直接如下；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;foo = [&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;foo = set(foo)&lt;br/&gt;print(foo)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;候选人：写好了。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;面试官：恩。&lt;code&gt;set&lt;/code&gt; 确实能去重，你这个实现跟 &lt;code&gt;foo&lt;/code&gt; 是不是有序是不是没有关系？这个输出是有序的吗？&lt;/p&gt;&lt;p&gt;候选人： &lt;code&gt;set&lt;/code&gt; 本来就是升序的。确实跟输入是否有序没关系。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;面试官：那题目输入是降序的呢？另外，你知道这个时间复杂度是多少吗？&lt;/p&gt;&lt;p&gt;候选人：如果是降序，那后面输出的时候再 &lt;code&gt;sort&lt;/code&gt; 一下就好了。时间复杂度，这个。。。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们拿到一个面试题目，一定要和面试官先沟通清楚，这个题目需求是什么。沟通，也是面试考察的一个重点。相当于，我们拿到一个产品的需求，得通过来回沟通，揣摩用户需求。&lt;/p&gt;&lt;p&gt;对应到代码面试题而言，就是要通过和面试官沟通，对方期望的是一个怎样的结果。是直接写几行代码解决这个问题呢？还是明确设计一个接口实现，输入输出如何？&lt;/p&gt;&lt;p&gt;类似的，用 Java 的候选人，写出来了如下代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    List&amp;lt;Integer&amp;gt; inputNumbers = Arrays.asList(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;    System.out.println(inputNumbers.stream().distinct().collect(Collectors.toList()));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;面试官内心OS：恩，Java 8 stream API 应该用得多。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;面试官：恩，能完成功能。我把题目明确一下，请自行设计接口（方法）完成上述功能，尽量用时间复杂度低的方式实现。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;于是又开始写了。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(List&amp;lt;Integer&amp;gt; a)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;....&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;面试官：请注意，编码风格，包括函数、变量命名等都在我们的考察范围。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;又改了下。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span&gt;quchong&lt;/span&gt;&lt;span&gt;(List&amp;lt;Integer&amp;gt; input)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;....&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;中英夹杂，其实不是很推荐。候选人如果能主动沟通，比如 “去重” 单次一时忘了，先用拼音替换等等都是 OK 的。一再强调，一定要多沟通。&lt;/p&gt;&lt;p&gt;比如比较好的方法签名如下（举例），通过函数名称知道背后的逻辑，入参 &lt;code&gt;sortedData&lt;/code&gt; 也能看到，要求输入的有序的。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span&gt;removeDuplicated&lt;/span&gt;&lt;span&gt;(List&amp;lt;Integer&amp;gt; sortedData)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，如果候选人能主动如下沟通，肯定有加分的。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;输入都是正整数吗？这里可以设计成泛型（或 C++ 模板），方便扩展，不一定要求是&lt;code&gt;Integer&lt;/code&gt;，可以是 &lt;code&gt;Double, Long&lt;/code&gt; 等等都可以。我就简单用 Integer 代替了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;输入确保是有序的吗？我有必要检查一遍输入是否有序吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;接着看函数的实现。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;面试官：你可以尝试不用库函数，&lt;code&gt;set&lt;/code&gt;, &lt;code&gt;distinct&lt;/code&gt; 之类的。充分利用输入是有序数组。你想想，有序数组的特点，如果重复的数字，那么一定是相邻的。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;候选人：哦，我好像知道了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;其实，一般这样稍微提示，就能写出来了。&lt;/p&gt;&lt;p&gt;但，还是有部分候选人嘴里知道了，还是长时间没有敲键盘。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;面试官：你前后用两个“指针”（下标），前面一个指针 2一直往后找，直到找到一个和指针 1 代表的数字不相同的，是不是就是我们预期想保留的？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;其实很多时候，大部分人，还是能写出如下代码的。只是，希望候选人在写代码的时候，一定要注意边界等情况。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5029797377830751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibtsk25EEJibbywW9v6ZQMzTQsMKvTt6a5PfGhnaworttgpWmhy52X6Zdw7so6Ntlhia83Snic2zdcG3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1678&quot;/&gt;&lt;span&gt;候选人答案，大家来找茬&lt;/span&gt;&lt;/p&gt;&lt;p&gt;跟我们在写实际项目代码一样，如果是对外暴露的接口，一定要对输入参数进行合法性校验。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;面试官: 如果 &lt;code&gt;inputNumbers&lt;/code&gt; 为空会怎么样？&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;候选人：啊，忘了。我再加个为空的判断。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;噼里啪啦，加了是否为空的判断了。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (Objects.isNull(inputNumbers)) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; inputNumbers;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;面试官: 如果 &lt;code&gt;inputNumbers&lt;/code&gt; 数组只含有 1 个元素呢？你的输出是啥？&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;候选人：啊，有问题。我再改改。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;面试官: 你自己再写几个测试用例吧。如果别人设计了这样一个接口，你会从哪些方面考虑去进行测试。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;提醒大家，在写完代码之后，一定要注意自测。比较好的候选人一般写完代码之后，会主动自己写几个输入输出自测的。我们在实际项目中也是，要注意自测，写单测覆盖等。&lt;/p&gt;&lt;p&gt;经过来回几次修改，可能代码主题逻辑也写得差不多了。这个时候，可能面试官会进行“压力”面试（面试官可能心里也没有答案）。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;面试官：如果我非要你对这段代码进行优化，你会如何优化？我举个例子，比如你的第 7 行代码。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; distinctNumbers = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;面试官可能随时从中跳出一个知识点和候选人进行讨论的。这里，就考察候选人是否对 &lt;code&gt;ArrayList&lt;/code&gt; 扩容过程有所了解。&lt;/p&gt;&lt;p&gt;比如前文中 &lt;code&gt;set&lt;/code&gt; 的实现，候选人若对某种语言的不熟悉，可以主动讲述对其他熟悉的语言的了解，比如 C++里面的可能有 &lt;code&gt;set&lt;/code&gt; 和 &lt;code&gt;unordered_set&lt;/code&gt; 不同的实现。作为面试官也不一定清楚的，再次强调，沟通！&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;面试官：如果允许修改输入数组，怎样实现能使空间复杂度从 &lt;code&gt;O(N)&lt;/code&gt; 减小到 &lt;code&gt;O(1)&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;候选人：好的。那我接口定义稍微改下，不返回了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这道题目本身其实来源于 Leetcode，我记得不错的话，原题就是直接要求修改原数组的情况下进行提交。&lt;/p&gt;&lt;p&gt;这里也提醒下大家，如果你曾经遇到这道题目。也一定要和面试官沟通清楚题目要求，此题目不一定非此题目。比如，面试官可没说可以直接修改输入？&lt;/p&gt;&lt;p&gt;我印象特别深，在我当初毕业校招面试微软的时候，就遇到了一个自己做过的“原&lt;span&gt;”&lt;/span&gt;题，我噼里啪啦写完，最后面试官告诉我，题目 XX条件不一样。&lt;/p&gt;&lt;p&gt;另外，一般在面试过程中，遇到刷过的原题，特别是校招的时候，候选人可以主动提出说这个题目刚做过。我曾经作为候选人参加一些公司的校招时，就被要求如果做过的题目，要主动说。&lt;/p&gt;&lt;p&gt;不过，你不说也无所谓的。一个优秀的面试官，肯定不是为了考查某道具体的题目而考查的。一个优秀的候选人可以给面试官下套引导答题的，可以看看之前&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;amp;mid=2247492598&amp;amp;idx=1&amp;amp;sn=5904b3800a2091ad4215aaf156d59133&amp;amp;chksm=eb44e212dc336b04c37320664cb3bd4c036b1e2329810b91d393e100b9a34f495194d05c15f7&amp;amp;token=643157578&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;分享的面试技巧&lt;/a&gt;，&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;amp;mid=2247491116&amp;amp;idx=1&amp;amp;sn=676c6dab8dbb095a31e6fb45cb31a828&amp;amp;chksm=eb471fc8dc3096dea5f1a8600fdc9163d3ce228e640ddb93fad310d44e739f9d719d0722efd7&amp;amp;token=1903173876&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;大厂 Offer 面经和硬核面试攻略&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;好了，有了前文的基础，可直接修改原输入的情况下，应该能写出来了吧？只需要稍微变动上面的代码即可。&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎留言讨论你的答案，让大家来找茬&lt;/span&gt;。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;题目曝光了，以后面试可能会酌情考虑不出这道题目了。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;啊，我好像多虑了。说得好像我公众号阅读很多似的 😝 感觉完全没必要担心呀，毕竟题目也不是我原创的（属于Leetcode超级Easy的题目了）。😑&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;强调一下，面试这道题目并不是想考察这个题目本身，期望以这道题目为契机，考察候选人在解决实际问题时候的沟通能力（本文一直强调&lt;span&gt;多沟通，多沟通，多沟通&lt;/span&gt;），逻辑思维方式等。&lt;/p&gt;&lt;p&gt;当然最后也会看看实实在在的 Code，从编码过程中看候选人的&lt;span&gt;编程习惯，编码风格&lt;/span&gt;等等。&lt;/p&gt;&lt;p&gt;你可能还对如下文章感兴趣（真&lt;span&gt;人工&lt;/span&gt;智能推荐 hhh）：&lt;/p&gt;&lt;p&gt;数据结构和算法是重中之重，这里我跟大家推荐一本 Leetcode 刷题指南，质量还挺不错的，推荐给大家参考。获取方式，在公众号后台回复 &lt;span&gt;leetcode01&lt;/span&gt; 即可获取。&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.4186046511627908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibtsk25EEJibbywW9v6ZQMzTQuFIiaCMD6Wy8qvicSG32rJhW28uz3GwWqPkVflBDIFmMhubEoflSGS8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;946&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.4423076923076923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibtsk25EEJibbywW9v6ZQMzTQ6ianZhMws61OGpicgh0NqujgSicqqJ1vC3n0jic0hjfGg15OCKMNdWicmUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&amp;lt;&amp;lt;&amp;lt; 左右滑动见更多 &amp;gt;&amp;gt;&amp;gt;&lt;/p&gt;&lt;p&gt;最后，你有没有发现总是收不到我的推送，因为微信公众号改版了，非星标公众号文章能看到真的是看缘分。所以，还请你&lt;span&gt;帮忙加个星标&lt;/span&gt;，本号会定期分享一些技术干货、职场经验等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.076923076923077&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ZMXDhhGnYibtsk25EEJibbywW9v6ZQMzTQy4aK1dGMFqDoqIohSUVC7xkfju7HfuDo4YYFAB8cKyV5xjt0aLGJ1w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;325&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果大家对阿里或者其他大厂感兴趣，也可以找我内推，我可以帮忙提供简历 review 等，希望能和大家积极交流讨论，一起学习、共同进步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>711501bcf2949edbca626879275bbec1</guid>
<title>Java 反射机制：跟着代码学反射</title>
<link>https://toutiao.io/k/ralhzed</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;微信搜索：码农StayUp&lt;/p&gt;&lt;p&gt;主页地址：https://gozhuyinglong.github.io&lt;/p&gt;&lt;p&gt;源码分享：https://github.com/gozhuyinglong/blog-demos&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在OOP的世界里，万物皆对象。也就是说，我们可以将任何东西抽象成一个对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如人，可以抽象成一个Person类，通过new Person()来实例化一个对象；再比如鸭子，可以抽象成一个Duck类，也可以对其进行实例化……那么这一个个类本身是不是也可以抽象成一个类呢？Java提供了一个特殊的类&lt;code&gt;Class&lt;/code&gt;，用来描述类的内部信息，是反射的核心类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图是本篇讲述内容：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.29379760609358&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BVLibTm82CYCW7tWaOrd5AoeFU5OmXngudeMLTKtKq3C8VSY1lmlsGexTrT4LmF4GfYmx2NCvBxzkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;919&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. Java反射机制概述&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java反射（Reflection）允许应用程序在&lt;strong&gt;运行时&lt;/strong&gt;借助于反射API，来获取所有类或接口的内部信息，并且能直接操作任意对象的内部属性及方法。反射机制的核心类为&lt;code&gt;java.lang.Class&lt;/code&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;类加载完后，会在堆内存的方法区中产生一个&lt;code&gt;Class&lt;/code&gt;类型的对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Class&lt;/code&gt;类没有公开的构造函数，是由类加载器的&lt;code&gt;defineClass&lt;/code&gt;方法构造而成。所以&lt;code&gt;Class&lt;/code&gt;对象不是“new”出来的，而是通过方法来获取的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个&lt;code&gt;Class&lt;/code&gt;对象具有类的完整结构信息，并且一个类只有一个&lt;code&gt;Class&lt;/code&gt;对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 获取Class对象&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取&lt;code&gt;Class&lt;/code&gt;对象有以下四种方式：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过类对象获取；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过类直接调用class获取；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过Class.forName获取；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过类加载器获取。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面使用代码展示获取 Person 类的&lt;code&gt;Class&lt;/code&gt;对象的四种方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testClassFor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 1.通过类实例获取&lt;/span&gt;&lt;br/&gt;    Person person = &lt;span&gt;new&lt;/span&gt; Person();&lt;br/&gt;    Class&amp;lt;? extends Person&amp;gt; clazz1 = person.getClass();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;01 - &quot;&lt;/span&gt; + clazz1);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 2.通过类直接调用class获取&lt;/span&gt;&lt;br/&gt;    Class&amp;lt;Person&amp;gt; clazz2 = Person&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;02 - &quot;&lt;/span&gt; + clazz2);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 3.通过Class.forName获取&lt;/span&gt;&lt;br/&gt;    Class&amp;lt;?&amp;gt; clazz3 = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        clazz3 = Class.forName(&lt;span&gt;&quot;io.github.gozhuyinglong.reflection.Person&quot;&lt;/span&gt;);&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (ClassNotFoundException e) {&lt;br/&gt;        &lt;span&gt;// 当找不到指定类时，会抛出此异常&lt;/span&gt;&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;03 - &quot;&lt;/span&gt; + clazz3);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 4.通过类加载器获取&lt;/span&gt;&lt;br/&gt;    ClassLoader classLoader = &lt;span&gt;this&lt;/span&gt;.getClass().getClassLoader();&lt;br/&gt;    Class&amp;lt;?&amp;gt; clazz4 = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        clazz4 = classLoader.loadClass(&lt;span&gt;&quot;io.github.gozhuyinglong.reflection.Person&quot;&lt;/span&gt;);&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (ClassNotFoundException e) {&lt;br/&gt;        &lt;span&gt;// 当找不到指定类时，会抛出此异常&lt;/span&gt;&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;04 - &quot;&lt;/span&gt; + clazz4);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// hashCode相等，说明这四种方式获取的是同一个实例&lt;/span&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;05 - &quot;&lt;/span&gt; + clazz1.hashCode());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;06 - &quot;&lt;/span&gt; + clazz2.hashCode());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;07 - &quot;&lt;/span&gt; + clazz3.hashCode());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;08 - &quot;&lt;/span&gt; + clazz4.hashCode());&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;01 - class io.github.gozhuyinglong.reflection.Person&lt;br/&gt;02 - class io.github.gozhuyinglong.reflection.Person&lt;br/&gt;03 - class io.github.gozhuyinglong.reflection.Person&lt;br/&gt;04 - class io.github.gozhuyinglong.reflection.Person&lt;br/&gt;05 - 721748895&lt;br/&gt;06 - 721748895&lt;br/&gt;07 - 721748895&lt;br/&gt;08 - 721748895&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的输出结果可以看出，这四个&lt;code&gt;Class&lt;/code&gt;对象的&lt;code&gt;hashCode&lt;/code&gt;相同，说明使用这四种方式获取的是同一个对象。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 一些特殊的类和接口的Class对象&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在源码注释中提到一些特殊的类和接口：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;枚举是一种类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注解是一种接口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数组也属于一个反映为&lt;code&gt;Class&lt;/code&gt;对象的类。具有相同元素类型和维数的数组，也具有相同的&lt;code&gt;Class&lt;/code&gt;对象（也就是说，元素类型不同，或数组维数不同，其&lt;code&gt;Class&lt;/code&gt;对象也不同）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;原始Java类型（&lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;,&lt;code&gt;double&lt;/code&gt;）和关键字 &lt;code&gt;void&lt;/code&gt; 也表示为&lt;code&gt;Class&lt;/code&gt;对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面通过代码来验证：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testClassOther&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 枚举是一种类&lt;/span&gt;&lt;br/&gt;    Class&amp;lt;PersonEnum&amp;gt; clazz1 = PersonEnum&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;01 - &quot;&lt;/span&gt; + clazz1);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 注解是一种接口&lt;/span&gt;&lt;br/&gt;    Class&amp;lt;PersonAnnotation&amp;gt; clazz2 = PersonAnnotation&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;02 - &quot;&lt;/span&gt; + clazz2);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 数组也属于一个反应 Class 实例的类&lt;/span&gt;&lt;br/&gt;    Person[] personArray3 = &lt;span&gt;new&lt;/span&gt; Person[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;    Class&amp;lt;? extends Person[]&amp;gt; clazz3 = personArray3.getClass();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;03 - &quot;&lt;/span&gt; + clazz3);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 具有相同元素类型和维数的数组，也具有相同的 Class 实例&lt;/span&gt;&lt;br/&gt;    Person[] personArray4 = &lt;span&gt;new&lt;/span&gt; Person[&lt;span&gt;4&lt;/span&gt;];&lt;br/&gt;    Class&amp;lt;?&amp;gt; clazz4 = personArray4.getClass();&lt;br/&gt;&lt;br/&gt;    Person[][] personArray5 = &lt;span&gt;new&lt;/span&gt; Person[&lt;span&gt;1&lt;/span&gt;][];&lt;br/&gt;    Class&amp;lt;?&amp;gt; clazz5 = personArray5.getClass();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 两个一维数组的 hashCode 相等，说明是同一实例&lt;/span&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;04 - &quot;&lt;/span&gt; + clazz3.hashCode());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;05 - &quot;&lt;/span&gt; + clazz4.hashCode());&lt;br/&gt;    &lt;span&gt;// 一维数组与二维数组的 hashCode 不相等，说明不是同一实例&lt;/span&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;06 - &quot;&lt;/span&gt; + clazz5.hashCode());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 原始 Java 类型和关键字 void 也表示为 Class 实例&lt;/span&gt;&lt;br/&gt;    Class&amp;lt;Integer&amp;gt; clazz6 = &lt;span&gt;int&lt;/span&gt;&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;07 - &quot;&lt;/span&gt; + clazz6);&lt;br/&gt;&lt;br/&gt;    Class&amp;lt;Double&amp;gt; clazz7 = &lt;span&gt;double&lt;/span&gt;&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;08 - &quot;&lt;/span&gt; + clazz7);&lt;br/&gt;&lt;br/&gt;    Class&amp;lt;Void&amp;gt; clazz8 = &lt;span&gt;void&lt;/span&gt;&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;09 - &quot;&lt;/span&gt; + clazz8);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;01 - class io.github.gozhuyinglong.reflection.PersonEnum&lt;br/&gt;02 - interface io.github.gozhuyinglong.reflection.PersonAnnotation&lt;br/&gt;03 - class [Lio.github.gozhuyinglong.reflection.Person;&lt;br/&gt;04 - 721748895&lt;br/&gt;05 - 721748895&lt;br/&gt;06 - 1642534850&lt;br/&gt;07 - int&lt;br/&gt;08 - double&lt;br/&gt;09 - void&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过输出结果可以看出，确如源码中描述那样。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. Java反射API&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java提供了一套反射API，该API由&lt;code&gt;Class&lt;/code&gt;类与&lt;code&gt;java.lang.reflect&lt;/code&gt;类库组成。该类库包含了&lt;code&gt;Field&lt;/code&gt;、&lt;code&gt;Method&lt;/code&gt;、&lt;code&gt;Constructor&lt;/code&gt;等类。这些类型的对象是由JVM在运行时创建的，用以表示未知类里对应的成员。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反射允许以编程的方式访问已加载类的字段、方法和构造函数信息，并在安全限制内利用反射对其进行操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面将介绍一些常用的类：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 Class（类）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java.lang.Class&lt;/code&gt;类用来描述类的内部信息，&lt;code&gt;Class&lt;/code&gt;的实例可以获取类的包、注解、修饰符、名称、超类、接口等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testClass&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    Class&amp;lt;?&amp;gt; clazz = Class.forName(&lt;span&gt;&quot;io.github.gozhuyinglong.reflection.Person&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取该类所在包路径&lt;/span&gt;&lt;br/&gt;    Package aPackage = clazz.getPackage();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;01 - &quot;&lt;/span&gt; + aPackage);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取该类上所有注解&lt;/span&gt;&lt;br/&gt;    Annotation[] declaredAnnotations = clazz.getDeclaredAnnotations();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Annotation temp : declaredAnnotations) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;02 - &quot;&lt;/span&gt; + temp);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取类上的修饰符&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; modifiers = clazz.getModifiers();&lt;br/&gt;    String modifier = Modifier.toString(modifiers);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;03 - &quot;&lt;/span&gt; + modifier);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取类名称&lt;/span&gt;&lt;br/&gt;    String name = clazz.getName();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;04 - &quot;&lt;/span&gt; + name);&lt;br/&gt;    &lt;span&gt;// 获取简单类名&lt;/span&gt;&lt;br/&gt;    String simpleName = clazz.getSimpleName();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;05 - &quot;&lt;/span&gt; + simpleName);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取直属超类&lt;/span&gt;&lt;br/&gt;    Type genericSuperclass = clazz.getGenericSuperclass();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;06 - &quot;&lt;/span&gt; + genericSuperclass);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取直属实现的接口&lt;/span&gt;&lt;br/&gt;    Type[] genericInterfaces = clazz.getGenericInterfaces();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Type temp : genericInterfaces) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;07 - &quot;&lt;/span&gt; + temp);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;01 - package io.github.gozhuyinglong.reflection&lt;br/&gt;02 - @io.github.gozhuyinglong.reflection.PersonAnnotation()&lt;br/&gt;03 - public final&lt;br/&gt;04 - io.github.gozhuyinglong.reflection.Person&lt;br/&gt;05 - Person&lt;br/&gt;06 - class io.github.gozhuyinglong.reflection.PersonParent&lt;br/&gt;07 - interface io.github.gozhuyinglong.reflection.PersonInterface&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 Constructor（构造函数）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java.lang.reflect.Constructor&lt;/code&gt;提供了类的构造函数信息。可以获取构造函数上的注解信息、参数类型等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testConstructor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    Class&amp;lt;?&amp;gt; clazz = Class.forName(&lt;span&gt;&quot;io.github.gozhuyinglong.reflection.Person&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取一个声明为 public 构造函数实例&lt;/span&gt;&lt;br/&gt;    Constructor&amp;lt;?&amp;gt; constructor1 = clazz.getConstructor(String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;PersonEnum&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;01 - &quot;&lt;/span&gt; + constructor1);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取所有声明为 public 构造函数实例&lt;/span&gt;&lt;br/&gt;    Constructor&amp;lt;?&amp;gt;[] constructorArray1 = clazz.getConstructors();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Constructor&amp;lt;?&amp;gt; constructor : constructorArray1) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;02 - &quot;&lt;/span&gt; + constructor);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取一个声明的构造函数实例&lt;/span&gt;&lt;br/&gt;    Constructor&amp;lt;?&amp;gt; constructor2 = clazz.getDeclaredConstructor(String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;03 - &quot;&lt;/span&gt; + constructor2);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取所有声明的构造函数实例&lt;/span&gt;&lt;br/&gt;    Constructor&amp;lt;?&amp;gt;[] constructorArray2 = clazz.getDeclaredConstructors();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Constructor&amp;lt;?&amp;gt; constructor : constructorArray2) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;04 - &quot;&lt;/span&gt; + constructor);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 根据构造函数创建一个实例&lt;/span&gt;&lt;br/&gt;    Object o1 = constructor1.newInstance(&lt;span&gt;&quot;杨过&quot;&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;, PersonEnum.MAN);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;05 - &quot;&lt;/span&gt; + o1);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 将构造函数的可访问标志设为 true 后，可以通过私有构造函数创建实例&lt;/span&gt;&lt;br/&gt;    constructor2.setAccessible(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    Object o2 = constructor2.newInstance(&lt;span&gt;&quot;小龙女&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;06 - &quot;&lt;/span&gt; + o2);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取该构造函数上的所有注解&lt;/span&gt;&lt;br/&gt;    Annotation[] annotations = constructor1.getDeclaredAnnotations();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Annotation annotation : annotations) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;07 - &quot;&lt;/span&gt; + annotation);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取该构造函数上的所有参数类型&lt;/span&gt;&lt;br/&gt;    Type[] genericParameterTypes = constructor1.getGenericParameterTypes();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Type genericParameterType : genericParameterTypes) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;08 - &quot;&lt;/span&gt; + genericParameterType);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;01 - public io.github.gozhuyinglong.reflection.Person(java.lang.String,int,io.github.gozhuyinglong.reflection.PersonEnum)&lt;br/&gt;02 - public io.github.gozhuyinglong.reflection.Person(java.lang.String,int,io.github.gozhuyinglong.reflection.PersonEnum)&lt;br/&gt;02 - public io.github.gozhuyinglong.reflection.Person(java.lang.String,int)&lt;br/&gt;02 - public io.github.gozhuyinglong.reflection.Person()&lt;br/&gt;03 - private io.github.gozhuyinglong.reflection.Person(java.lang.String)&lt;br/&gt;04 - public io.github.gozhuyinglong.reflection.Person(java.lang.String,int,io.github.gozhuyinglong.reflection.PersonEnum)&lt;br/&gt;04 - public io.github.gozhuyinglong.reflection.Person(java.lang.String,int)&lt;br/&gt;04 - private io.github.gozhuyinglong.reflection.Person(java.lang.String)&lt;br/&gt;04 - public io.github.gozhuyinglong.reflection.Person()&lt;br/&gt;05 - Person{name=&lt;span&gt;&#x27;杨过&#x27;&lt;/span&gt;, age=25, sex=&lt;span&gt;&#x27;MAN&#x27;&lt;/span&gt;}&lt;br/&gt;06 - Person{name=&lt;span&gt;&#x27;小龙女&#x27;&lt;/span&gt;, age=0, sex=&lt;span&gt;&#x27;null&#x27;&lt;/span&gt;}&lt;br/&gt;07 - @io.github.gozhuyinglong.reflection.PersonAnnotation()&lt;br/&gt;08 - class java.lang.String&lt;br/&gt;08 - int&lt;br/&gt;08 - class io.github.gozhuyinglong.reflection.PersonEnum&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 Field（属性）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java.lang.reflect.Field&lt;/code&gt;提供了类的属性信息。可以获取属性上的注解、修饰符、属性类型、属性名等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testField&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    Class&amp;lt;?&amp;gt; clazz = Class.forName(&lt;span&gt;&quot;io.github.gozhuyinglong.reflection.Person&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取一个该类或父类中声明为 public 的属性&lt;/span&gt;&lt;br/&gt;    Field field1 = clazz.getField(&lt;span&gt;&quot;hobby&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;01 - &quot;&lt;/span&gt; + field1);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取该类及父类中所有声明为 public 的属性&lt;/span&gt;&lt;br/&gt;    Field[] fieldArray1 = clazz.getFields();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Field field : fieldArray1) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;02 - &quot;&lt;/span&gt; + field);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取一个该类中声明的属性&lt;/span&gt;&lt;br/&gt;    Field field2 = clazz.getDeclaredField(&lt;span&gt;&quot;name&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;03 - &quot;&lt;/span&gt; + field2);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取该类中所有声明的属性&lt;/span&gt;&lt;br/&gt;    Field[] fieldArray2 = clazz.getDeclaredFields();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Field field : fieldArray2) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;04 - &quot;&lt;/span&gt; + field);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取该属性上的所有注解&lt;/span&gt;&lt;br/&gt;    Annotation[] declaredAnnotations = field2.getDeclaredAnnotations();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Annotation declaredAnnotation : declaredAnnotations) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;05 - &quot;&lt;/span&gt; + declaredAnnotation);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取修饰符&lt;/span&gt;&lt;br/&gt;    String modifier = Modifier.toString(field2.getModifiers());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;06 - &quot;&lt;/span&gt; + modifier);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取属性类型，返回类对象&lt;/span&gt;&lt;br/&gt;    Class&amp;lt;?&amp;gt; type = field2.getType();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;07 - &quot;&lt;/span&gt; + type);&lt;br/&gt;    &lt;span&gt;// 获取属性类型，返回Type对象&lt;/span&gt;&lt;br/&gt;    Type genericType = field2.getGenericType();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;08 - &quot;&lt;/span&gt; + genericType);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取属性名称&lt;/span&gt;&lt;br/&gt;    String name = field2.getName();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;09 - &quot;&lt;/span&gt; + name);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;01 - public java.lang.String io.github.gozhuyinglong.reflection.PersonParent.hobby&lt;br/&gt;02 - public int io.github.gozhuyinglong.reflection.Person.height&lt;br/&gt;02 - public java.lang.String io.github.gozhuyinglong.reflection.PersonParent.hobby&lt;br/&gt;03 - private java.lang.String io.github.gozhuyinglong.reflection.Person.name&lt;br/&gt;04 - private java.lang.String io.github.gozhuyinglong.reflection.Person.name&lt;br/&gt;04 - private int io.github.gozhuyinglong.reflection.Person.age&lt;br/&gt;04 - public int io.github.gozhuyinglong.reflection.Person.height&lt;br/&gt;05 - @io.github.gozhuyinglong.reflection.PersonAnnotation()&lt;br/&gt;06 - private&lt;br/&gt;07 - class java.lang.String&lt;br/&gt;08 - class java.lang.String&lt;br/&gt;09 - name&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.4 Method（方法）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java.lang.reflect.Method&lt;/code&gt;提供了类的方法信息。可以获取方法上的注解、修饰符、返回值类型、方法名称、所有参数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testMethod&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    Class&amp;lt;?&amp;gt; clazz = Class.forName(&lt;span&gt;&quot;io.github.gozhuyinglong.reflection.Person&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取一个该类及父类中声明为 public 的方法，需要指定方法的入参类型&lt;/span&gt;&lt;br/&gt;    Method method = clazz.getMethod(&lt;span&gt;&quot;setName&quot;&lt;/span&gt;, String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;01 - &quot;&lt;/span&gt; + method);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取该类及父类中所有声明为 public 的方法&lt;/span&gt;&lt;br/&gt;    Method[] methods = clazz.getMethods();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Method temp : methods) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;02 - &quot;&lt;/span&gt; + temp);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取一个在该类中声明的方法&lt;/span&gt;&lt;br/&gt;    Method declaredMethod = clazz.getDeclaredMethod(&lt;span&gt;&quot;display&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;03 - &quot;&lt;/span&gt; + declaredMethod);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取所有在该类中声明的方法&lt;/span&gt;&lt;br/&gt;    Method[] declaredMethods = clazz.getDeclaredMethods();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Method temp : declaredMethods) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;04 - &quot;&lt;/span&gt; + temp);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取该方法上的所有注解&lt;/span&gt;&lt;br/&gt;    Annotation[] declaredAnnotations = method.getDeclaredAnnotations();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Annotation temp : declaredAnnotations) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;05 - &quot;&lt;/span&gt; + temp);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取修饰符&lt;/span&gt;&lt;br/&gt;    String modifier = Modifier.toString(method.getModifiers());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;06 - &quot;&lt;/span&gt; + modifier);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取返回值类型，返回类对象&lt;/span&gt;&lt;br/&gt;    Class&amp;lt;?&amp;gt; returnType = method.getReturnType();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;07 - &quot;&lt;/span&gt; + returnType);&lt;br/&gt;    &lt;span&gt;// 获取返回值类型，返回Type对象&lt;/span&gt;&lt;br/&gt;    Type genericReturnType = method.getGenericReturnType();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;08 - &quot;&lt;/span&gt; + genericReturnType);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取方法名称&lt;/span&gt;&lt;br/&gt;    String name = method.getName();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;09 - &quot;&lt;/span&gt; + name);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取所有入参&lt;/span&gt;&lt;br/&gt;    Parameter[] parameters = method.getParameters();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Parameter temp : parameters) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;10 - &quot;&lt;/span&gt; + temp);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;01 - public void io.github.gozhuyinglong.reflection.Person.setName(java.lang.String)&lt;br/&gt;02 - public java.lang.String io.github.gozhuyinglong.reflection.Person.toString()&lt;br/&gt;02 - public java.lang.String io.github.gozhuyinglong.reflection.Person.getName()&lt;br/&gt;02 - public void io.github.gozhuyinglong.reflection.Person.setName(java.lang.String)&lt;br/&gt;02 - public int io.github.gozhuyinglong.reflection.Person.getAge()&lt;br/&gt;02 - public void io.github.gozhuyinglong.reflection.Person.setAge(int)&lt;br/&gt;02 - public java.lang.String io.github.gozhuyinglong.reflection.Person.sayHello()&lt;br/&gt;02 - public io.github.gozhuyinglong.reflection.PersonEnum io.github.gozhuyinglong.reflection.PersonParent.getSex()&lt;br/&gt;02 - public void io.github.gozhuyinglong.reflection.PersonParent.setSex(io.github.gozhuyinglong.reflection.PersonEnum)&lt;br/&gt;02 - public final void java.lang.Object.wait() throws java.lang.InterruptedException&lt;br/&gt;02 - public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException&lt;br/&gt;02 - public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException&lt;br/&gt;02 - public boolean java.lang.Object.equals(java.lang.Object)&lt;br/&gt;02 - public native int java.lang.Object.hashCode()&lt;br/&gt;02 - public final native java.lang.Class java.lang.Object.getClass()&lt;br/&gt;02 - public final native void java.lang.Object.notify()&lt;br/&gt;02 - public final native void java.lang.Object.notifyAll()&lt;br/&gt;03 - private java.lang.String io.github.gozhuyinglong.reflection.Person.display()&lt;br/&gt;04 - public java.lang.String io.github.gozhuyinglong.reflection.Person.toString()&lt;br/&gt;04 - public java.lang.String io.github.gozhuyinglong.reflection.Person.getName()&lt;br/&gt;04 - public void io.github.gozhuyinglong.reflection.Person.setName(java.lang.String)&lt;br/&gt;04 - private java.lang.String io.github.gozhuyinglong.reflection.Person.display()&lt;br/&gt;04 - public int io.github.gozhuyinglong.reflection.Person.getAge()&lt;br/&gt;04 - public void io.github.gozhuyinglong.reflection.Person.setAge(int)&lt;br/&gt;04 - public java.lang.String io.github.gozhuyinglong.reflection.Person.sayHello()&lt;br/&gt;05 - @io.github.gozhuyinglong.reflection.PersonAnnotation()&lt;br/&gt;06 - public&lt;br/&gt;07 - void&lt;br/&gt;08 - void&lt;br/&gt;09 - setName&lt;br/&gt;10 - java.lang.String arg0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.5 Modifier（修饰符）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java.lang.reflect.Modifier&lt;/code&gt;提供了访问修饰符信息。通过&lt;code&gt;Class&lt;/code&gt;、&lt;code&gt;Field&lt;/code&gt;、&lt;code&gt;Method&lt;/code&gt;、&lt;code&gt;Constructor&lt;/code&gt;等对象都可以获取修饰符，这个访问修饰符是一个整数，可以通过&lt;code&gt;Modifier.toString&lt;/code&gt;方法来查看修饰符描述。并且该类提供了一些静态方法和常量来解码访问修饰符。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testModifier&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    Class&amp;lt;?&amp;gt; clazz = Class.forName(&lt;span&gt;&quot;io.github.gozhuyinglong.reflection.Person&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取类的修饰符值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; modifiers1 = clazz.getModifiers();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;01 - &quot;&lt;/span&gt; + modifiers1);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取属性的修饰符值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; modifiers2 = clazz.getDeclaredField(&lt;span&gt;&quot;name&quot;&lt;/span&gt;).getModifiers();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;02 - &quot;&lt;/span&gt; + modifiers2);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取构造函数的修饰符值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; modifiers3 = clazz.getDeclaredConstructor(String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;getModifiers&lt;/span&gt;()&lt;/span&gt;;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;03 - &quot;&lt;/span&gt; + modifiers3);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取方法的修饰符值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; modifiers4 = clazz.getDeclaredMethod(&lt;span&gt;&quot;display&quot;&lt;/span&gt;).getModifiers();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;04 - &quot;&lt;/span&gt; + modifiers4);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 判断修饰符值是否 final 类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; isFinal = Modifier.isFinal(modifiers1);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;05 - &quot;&lt;/span&gt; + isFinal);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 判断修饰符值是否 public 类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; isPublic = Modifier.isPublic(modifiers2);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;06 - &quot;&lt;/span&gt; + isPublic);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 根据修饰符值，获取修饰符标志的字符串&lt;/span&gt;&lt;br/&gt;    String modifier = Modifier.toString(modifiers1);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;07 - &quot;&lt;/span&gt; + modifier);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;08 - &quot;&lt;/span&gt; + Modifier.toString(modifiers2));&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;01 - 17&lt;br/&gt;02 - 2&lt;br/&gt;03 - 2&lt;br/&gt;04 - 2&lt;br/&gt;05 - &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;06 - &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;07 - public final&lt;br/&gt;08 - private&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.6 Parameter（参数）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java.lang.reflect.Parameter&lt;/code&gt;提供了方法的参数信息。可以获取方法上的注解、参数名称、参数类型等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testParameter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    Class&amp;lt;?&amp;gt; clazz = Class.forName(&lt;span&gt;&quot;io.github.gozhuyinglong.reflection.Person&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取构造函数的参数&lt;/span&gt;&lt;br/&gt;    Constructor&amp;lt;?&amp;gt; constructor = clazz.getConstructor(String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;PersonEnum&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    Parameter[] parameterArray1 = constructor.getParameters();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Parameter temp : parameterArray1) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;01 - &quot;&lt;/span&gt; + temp);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取方法的参数&lt;/span&gt;&lt;br/&gt;    Method method = clazz.getMethod(&lt;span&gt;&quot;setName&quot;&lt;/span&gt;, String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    Parameter[] parameterArray2 = method.getParameters();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Parameter temp : parameterArray2) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;02 - &quot;&lt;/span&gt; + temp);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    Parameter parameter = parameterArray1[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;// 获取参数上的注解&lt;/span&gt;&lt;br/&gt;    Annotation[] annotationArray = parameter.getAnnotations();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Annotation temp : annotationArray) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;02 - &quot;&lt;/span&gt; + temp);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取参数名称&lt;/span&gt;&lt;br/&gt;    String name = parameter.getName();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;03 - &quot;&lt;/span&gt; + name);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取参数类型&lt;/span&gt;&lt;br/&gt;    Type parameterizedType = parameter.getParameterizedType();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;04 - &quot;&lt;/span&gt; + parameterizedType);&lt;br/&gt;    Class&amp;lt;?&amp;gt; type = parameter.getType();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;05 - &quot;&lt;/span&gt; + type);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;01 - java.lang.String arg0&lt;br/&gt;01 - int arg1&lt;br/&gt;01 - io.github.gozhuyinglong.reflection.PersonEnum arg2&lt;br/&gt;02 - java.lang.String arg0&lt;br/&gt;02 - @io.github.gozhuyinglong.reflection.PersonAnnotation()&lt;br/&gt;03 - arg0&lt;br/&gt;04 - class java.lang.String&lt;br/&gt;05 - class java.lang.String&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.7 AccessibleObject（可访问标志）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java.lang.reflect.AccessibleObject&lt;/code&gt;类是&lt;code&gt;Field&lt;/code&gt;、&lt;code&gt;Method&lt;/code&gt;和&lt;code&gt;Constructor&lt;/code&gt;类的超类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该类提供了对类、方法、构造函数的访问控制检查的能力（如：私有方法只允许当前类访问）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该&lt;strong&gt;访问检查&lt;/strong&gt;在设置/获取属性、调用方法、创建/初始化类的实例时执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过&lt;code&gt;setAccessible&lt;/code&gt;方法将可访问标志设为&lt;code&gt;true&lt;/code&gt;（默认为&lt;code&gt;false&lt;/code&gt;），会关闭&lt;strong&gt;访问检查&lt;/strong&gt;。这样即使是私有的属性、方法或构造函数，也可以访问。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 通过反射动态创建对象并执行方法&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以利用反射来创建对象，并可执行方法，下面看代码示例：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过&lt;code&gt;Class&lt;/code&gt;类的&lt;code&gt;newInstance&lt;/code&gt;创建一个实例。（该方法调用无参构造器）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过构造函数&lt;code&gt;Constructor&lt;/code&gt;类创建一个实例。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取方法，再通过 &lt;code&gt;invoke&lt;/code&gt; 方法来调用，第一个参数为实例，后面参数为方法的&lt;code&gt;Parameter&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取字段，因为 age 字段是私有的，所以将其设置为可访问（不设置会报异常）。并通过 &lt;code&gt;set&lt;/code&gt; 方法来赋值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testInvoke&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    Class&amp;lt;?&amp;gt; clazz = Class.forName(&lt;span&gt;&quot;io.github.gozhuyinglong.reflection.Person&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 通过Class类的newInstance创建一个实例。（该方法调用无参构造器）&lt;/span&gt;&lt;br/&gt;    Object o1 = clazz.newInstance();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;01 - &quot;&lt;/span&gt; + o1.toString());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 通过构造函数Constructor类创建一个实例&lt;/span&gt;&lt;br/&gt;    Constructor&amp;lt;?&amp;gt; constructor = clazz.getConstructor(String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;PersonEnum&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    Object o2 = constructor.newInstance(&lt;span&gt;&quot;杨过&quot;&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;, PersonEnum.MAN);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;02 - &quot;&lt;/span&gt; + o2.toString());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 先获取方法，再通过 invoke 方法来调用，第一个参数为实例，后面参数为方法的Parameter&lt;/span&gt;&lt;br/&gt;    Method method = clazz.getMethod(&lt;span&gt;&quot;setName&quot;&lt;/span&gt;, String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    method.invoke(o1, &lt;span&gt;&quot;小龙女&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;03 - &quot;&lt;/span&gt; + o1.toString());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取字段，因为 age 字段是私有的，所以将其设置为可访问（不设置会报异常）。并通过 set 方法来赋值&lt;/span&gt;&lt;br/&gt;    Field field = clazz.getDeclaredField(&lt;span&gt;&quot;age&quot;&lt;/span&gt;);&lt;br/&gt;    field.setAccessible(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    field.set(o1, &lt;span&gt;28&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;04 - &quot;&lt;/span&gt; + o1.toString());&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;01 - Person{name=&lt;span&gt;&#x27;null&#x27;&lt;/span&gt;, age=0, sex=&lt;span&gt;&#x27;null&#x27;&lt;/span&gt;}&lt;br/&gt;02 - Person{name=&lt;span&gt;&#x27;杨过&#x27;&lt;/span&gt;, age=25, sex=&lt;span&gt;&#x27;MAN&#x27;&lt;/span&gt;}&lt;br/&gt;03 - Person{name=&lt;span&gt;&#x27;小龙女&#x27;&lt;/span&gt;, age=0, sex=&lt;span&gt;&#x27;null&#x27;&lt;/span&gt;}&lt;br/&gt;04 - Person{name=&lt;span&gt;&#x27;小龙女&#x27;&lt;/span&gt;, age=28, sex=&lt;span&gt;&#x27;null&#x27;&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 反射的缺点&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;引自官方指南：https://docs.oracle.com/javase/tutorial/reflect/index.html&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反射虽是强大的，但不可随意使用。如果可以在不使用反射的情况下执行操作，则应避免使用它。因为通过反射访问代码时，会有以下缺点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 性能开销&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反射包括了一些动态类型，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 安全限制&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如Applet，那么这就是个问题了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.3 内部暴露&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于反射允许代码执行一些在正常情况下不被允许的操作，比如访问私有的属性和方法。所以使用反射可能会导致意料之外的副作用：代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. 完整代码&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整代码请访问我的Github，若对你有帮助，欢迎给个⭐，感谢~~🌹🌹🌹&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/gozhuyinglong/blog-demos/tree/main/java-source-analysis/src/main/java/io/github/gozhuyinglong/reflection&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. 参考资料&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Java™ Platform, Standard Edition 8 API Specification&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;The Java™ Tutorials&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6933333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/hXEWOsco2BVLibTm82CYCW7tWaOrd5Aoe3EHIlN5oxNoqo0FfELzLGFCtyibMSoqkn4m5EVUpaEKDOGSEibfrJpHw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;750&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cffd7aa8f374c94c61e24f00e24d303a</guid>
<title>做一次黑客，入侵一次服务器</title>
<link>https://toutiao.io/k/3tudqnj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;前两天刚买了个腾讯服务器(CVM)，这次登陆上去的时候特别卡，通过top发现负载特别高，因为是刚搭建的环境，也没有运行什么应用程序，所以我觉得这有点不正常。&lt;/p&gt;

&lt;p&gt;我就想着把docker、mysql的后台服务停了，然后再观察一下负载能不能降下来，结果我发现常用的命令都无法使用了。&lt;/p&gt;

&lt;p&gt;后来发现是docker远程服务入侵，所以就利用docker远程服务和redis服务，模拟入侵了一次自己的服务器。&lt;/p&gt;

&lt;h2&gt;问题还原&lt;/h2&gt;

&lt;p&gt;又是平平淡淡似往常的一天，当我使用systemctl命令想停掉后台服务的时候，才发现我居然没有执行权限。
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210501211013884.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;之前从没遇到过这种情况，在我的认知里，root就是最高的存在。&lt;/p&gt;

&lt;p&gt;先求助了一波客服，客服说是被入侵了，让我重装系统。在重装前，又求助了我亲爱的大学舍友，一安全大佬：冯胖，不！是冯佬。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210507145420943.jpg#pic_center&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;问题分析&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;我&lt;/em&gt;：冯啊，我这个systemctl不能用了，咋回事啊？&lt;/p&gt;

&lt;p&gt;&lt;em&gt;冯&lt;/em&gt;：我上去给你看看也。&lt;/p&gt;

&lt;p&gt;A few moments later....&lt;/p&gt;

&lt;p&gt;&lt;em&gt;冯&lt;/em&gt;：你这个2375端口是啥服务，有没有开启远程服务之类的。。。
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210501210902299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;我&lt;/em&gt;：这，这不是我前两天刚开的docker远程服务么。。。
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210504191110438.gif#pic_center&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;冯&lt;/em&gt;：那就对了，通过docker远程服务器入侵了你的服务器，然后再利用masscan扫描其他服务器的docker远程服务服务，然后进行入侵。你这是&lt;strong&gt;被远程入侵当做矿机了&lt;/strong&gt;，具体信息去/usr/share目录看看就知道了&lt;/p&gt;

&lt;p&gt;接着我去这个目录看了一下。
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210501211215219.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;打开config_background.json文件看了一下，果不其然，monero：门罗币。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210501211105624.jpg&quot; alt=&quot;config.json&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;我&lt;/em&gt;：他是怎么登录我的服务器呢？&lt;/p&gt;

&lt;p&gt;&lt;em&gt;冯&lt;/em&gt;：你忘了docker可以挂载主机目录么，挂载.ssh目录，然后把他的&lt;strong&gt;主机公钥直接放到authorized_keys中，不就可以免密登录了吗&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;恍然大悟！！！我去看了看，果然多了一个puppet的公钥，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210506110649220.jpg&quot; alt=&quot;authorized_key&quot;/&gt;&lt;/p&gt;

&lt;p&gt;同时，home下也多了一个用户目录。
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210501211350423.jpg#pic_center&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;我&lt;/em&gt;：最后一个问题，我用root用户，为什么很多命令都无法执行？&lt;/p&gt;

&lt;p&gt;&lt;em&gt;冯&lt;/em&gt;：先用chmod将命令修改为读写状态，这样就无法执行了。再用chattr将命令属性修改为只读，这样chmod就无法修改此命令权限了。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;我&lt;/em&gt;：那我去查查资料....&lt;/p&gt;

&lt;p&gt;查完资料后，我操作试了试。
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210504201841562.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如图，这里拿ls举例。根据421规则，1代表执行权限，我先将ls权限修改为666，即只有读写权限，没有执行权限。其中lsattr用来查看文件属性，chattr修改文件属性，也可以理解为比chmod管理更底层的文件权限的一个命令。&lt;/p&gt;

&lt;p&gt;chattr +i就是让ls只有只读属性，从图中可以看出这时候ls就已经无法执行，使用lsattr也看到ls多了个&lt;em&gt;i&lt;/em&gt;属性，这时候我打算用chmod将其修改为755，即可执行状态，这时候却提示没有权限。&lt;/p&gt;

&lt;p&gt;接着我使用chattr -i去掉ls只读属性，就可以使用chmod将其修改为755可执行状态了，如图，ls正常执行。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;我&lt;/em&gt;：可是为什么我连chattr命令都没有执行权限？&lt;/p&gt;

&lt;p&gt;&lt;em&gt;冯&lt;/em&gt;：......
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210504204134123.jpg#pic_center&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;我&lt;/em&gt;：大哥！！！
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210504204702756.gif#pic_center&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;冯&lt;/em&gt;：复制一个chattr，起个别名，然后用新的命令将chattr也修改成只读，然后删除命令的不就行了&lt;/p&gt;

&lt;p&gt;&lt;em&gt;我&lt;/em&gt;：不愧是我冯...&lt;/p&gt;

&lt;p&gt;&lt;em&gt;冯&lt;/em&gt;：周末去哪吃&lt;/p&gt;

&lt;p&gt;&lt;em&gt;我&lt;/em&gt;：.....
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210507154642710.jpg#pic_center&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;ssh公钥注入实现提权&lt;/h2&gt;

&lt;p&gt;通过查阅一些资料，原理就是通过一些服务端口，将自己主机的公钥写入到靶机，实现免密登录，获取靶机root用户权限。&lt;/p&gt;

&lt;p&gt;关于ssh公钥之前也讲过。就是将A主机的公钥，拷贝到B主机~/.ssh目录下的&lt;em&gt;authorized_keys&lt;/em&gt;文件中，即可建立互信实现免密登录，即A主机登录B主机将不需要输入密码。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;而入侵者通过docker远程服务和redis的快照功能，将某台主机的公钥写入到authorized_keys，而免密登录目标主机，获取root权限的行为，就是ssh公钥提权。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;之前只听过sql注入、DDoS攻击。对于这种可以直接登录服务器进行操作的还是第一次遇见，所以我就拿自己的服务器实验一下，反正一会儿都要重装系统了。&lt;/p&gt;

&lt;p&gt;这里准备了两台服务器，A主机用来运行docker的远程服务和redis服务，B主机用来远程连接。&lt;/p&gt;

&lt;h3&gt;docker远程服务入侵&lt;/h3&gt;

&lt;p&gt;其原理是利用docker的远程服务，可以远程在靶机上起一个docker容器，并将靶机.ssh目录挂载到容器中，然后进入docker的bash，直接将公钥写入到authorized_keys中。&lt;/p&gt;

&lt;h4&gt;开启远程端口&lt;/h4&gt;

&lt;p&gt;默认端口是2375，为了防止被其他机器扫到，所以这里先修改成6666。
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210506140448832.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;远程连接docker&lt;/h4&gt;

&lt;p&gt;登录B主机并执行下面命令，即可查看远程主机运行了哪些容器。&lt;/p&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;docker -H tcp://47.102.xxx.xxx:6666 ps -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;平时我们都是使用docker ps来查看本机运行的容器，这里使用-H，指定A主机的IP和端口，即可以查看远程主机的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210506141353124.jpg&quot; alt=&quot;docker ps&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接着我们看看这台主机上有什么镜像：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210506151627290.jpg&quot; alt=&quot;images&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;远程运行容器&lt;/h4&gt;

&lt;p&gt;在B主机上执行以下命令，即可在B主机上远程使用A主机上的镜像，在A主机上运行一个容器。&lt;/p&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;# 挂载/etc/ssh目录是为了修改sshd_config中PermitRootLogin为yes，允许root登录
# 默认是允许root登录的，所以没对/etc/ssh/sshd_config进行修改
docker -H tcp://47.102.xxx.xxx:6666 run -it -v /root:/tmp/root -v /etc/ssh:/tmp/ect/ssh centos bash 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过-v将/root/.ssh目录挂载到容器中的/tmp/root目录下，那么在容器中就可以直接修改A主机上的authorized_keys，这里我只要将B主机的公钥添加进去，B主机就可以免密登录A主机了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210506163135974.jpg&quot; alt=&quot;运行容器&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如图，创建并运行了一个容器后，直接通过bash进入了容器。&lt;/p&gt;

&lt;h4&gt;写入公钥，实现入侵登陆&lt;/h4&gt;

&lt;p&gt;在容器中，查看authorized_keys文件的内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210506171108349.jpg&quot; alt=&quot;authorized_keys&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如图，目前authorized_keys只有一个公钥，我们通过vi将B主机的公钥添加进去，wq保存退出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210506172549529.jpg&quot; alt=&quot;写入公钥&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接着测试一下是否可以免密登录。
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210506172549130.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如图，B主机到A主机成功免密登录。&lt;/p&gt;

&lt;h3&gt;redis动态配置入侵&lt;/h3&gt;

&lt;p&gt;其原理是利用redis的&lt;strong&gt;RDB快照备份和命名行config命令动态修改配置功能&lt;/strong&gt;，将RDB的保存目录修改成.ssh，文件名修改成authorized_keys。然后将公钥作为value写入redis，并使用&lt;em&gt;bgsave&lt;/em&gt;命令开始备份，则将公钥成功写入到authorized_keys，实现免密登录。&lt;/p&gt;

&lt;h4&gt;前提条件&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;使用root用户运行的redis&lt;/li&gt;
&lt;li&gt;没有设置密码&lt;/li&gt;
&lt;li&gt;使用默认的6379端口&lt;/li&gt;
&lt;li&gt;允许远程IP访问，即注释掉&lt;em&gt;bind&lt;/em&gt;配置以及将&lt;em&gt;protected mode&lt;/em&gt;修改为no&lt;/li&gt;
&lt;li&gt;没有禁止动态修改配置功能&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;启动redis&lt;/h4&gt;

&lt;p&gt;这里在A主机启动了redis服务，允许远程访问，并将端口修改为6666.&lt;/p&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;./redis-server ../conf/redis.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210506174112133.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;远程连接redis&lt;/h4&gt;

&lt;p&gt;登录B主机，远程连接A主机的redis服务。&lt;/p&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;./redis-cli -h 47.102.xxx.xxx -p 6666
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;写入公钥，实现入侵登陆&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210506181951118.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如图，先拷贝B主机的公钥，为了在写到authorized_keys后公钥能占单独一行，所以前后都进行了换行。&lt;/p&gt;

&lt;p&gt;然后执行以下命令，通过redis-cli将B主机公钥写入redis中。&lt;/p&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;cat id_das.pub | ./redis-cli -h 47.102.xxx.xxx -p 6666 -x set ssh-key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;em&gt;-h&lt;/em&gt;：指定A主机的IP， &lt;em&gt;-p&lt;/em&gt;：指定redis的端口，&lt;em&gt;-x&lt;/em&gt;：将标准输入作为后面命令的参数&lt;/p&gt;

&lt;p&gt;将公钥写入redis之后，再通过动态配置来修改RDB的目录和文件名。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 修改存储目录
config set dir /root/.ssh
# 修改rbd的文件名
config set dbfilename authorized_keys
# 立即将数据保存到文件中
bgsave

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着到A主机查看公钥是否已经写入到authorized_keys中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210501210827367.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如图，B主机公钥写入成功，最后也是成功免密登录。&lt;/p&gt;

&lt;p&gt;这时候可能会有人问，这是啥，authorized_keys中又是问号又是其他字符的，不会影响登陆吗？&lt;/p&gt;

&lt;p&gt;其实，这算是RDB文件的格式，所以为了不影响公钥，之前我也在公钥文件中前后都添加了换行，这样就可以让公钥独占一行，从而不影响免密登录。&lt;/p&gt;

&lt;h2&gt;预防措施&lt;/h2&gt;

&lt;h3&gt;docker&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;修改2375默认端口&lt;/li&gt;
&lt;li&gt;远程服务添加认证&lt;/li&gt;
&lt;li&gt;或者直接不开放远程服务&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;redis&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;修改6379默认端口&lt;/li&gt;
&lt;li&gt;使用非root用户运行redis&lt;/li&gt;
&lt;li&gt;通过requirepass来设置密码&lt;/li&gt;
&lt;li&gt;禁止使用动态配置&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;# 在redis.conf中添加如下配置
rename-command CONFIG &quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，在命令行就无法使用config命令进行动态配置。
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210507135817326.jpg#pic_center&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;上面通过redis和docker来获取主机权限的手段，可能真实的场景要更复杂地多，对安全大佬更是不值一提，但是对于我这种安全零基础的人来说，遇到还是很新奇的，所以通过文章记录了一下此次经历，也当做一次颇为有趣的体验。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;font face=&quot;微软雅黑&quot; size=&quot;2&quot;&gt;95后小程序员，写的都是日常工作中的亲身实践，置身于初学者的角度从0写到1，详细且认真。文章会在公众号 [&lt;strong&gt;入门到放弃之路&lt;/strong&gt;] 首发，期待你的关注。
&lt;/font&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20210401142825437.png&quot; alt=&quot;感谢每一份关注&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3519d3826f8625574d7acf8bc549c732</guid>
<title>蜻蜓FM 信息流推荐探索与实践</title>
<link>https://toutiao.io/k/a3b7d7v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                                    


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;323&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;324&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5589101620029455&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVHPQeicSKia9smZY5C7Vic7OYNwPicbxAWektV8VQsiaJFgI4jnBqZ4iaChibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1358&quot;/&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;font-variant-numeric: normal; font-variant-east-asian: normal; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; line-height: 27.2px; widows: 1; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: -10px; margin-left: -8px; max-width: 100%; width: 18px; height: 18px; border-top: 8px solid rgb(54, 65, 173); border-left: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-style=&quot;max-width: 100%; width: 543.333px; background: rgb(247, 247, 247); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;文章作者：季飞 蜻蜓FM 推荐技术负责人&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;内容来源：&lt;/span&gt;&lt;span&gt;作者授权&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;出品平台：DataFunTalk&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; width: 18px; height: 18px; border-bottom: 8px solid rgb(54, 65, 173); border-right: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如今的推荐系统在互联网中随处可见，无论是刷抖音、逛淘宝还是看新闻背后都有强大的推荐系统的支持。&lt;/span&gt;&lt;span&gt;音频行业的内容如何分发？&lt;/span&gt;&lt;span&gt;如何提高用户发现音频内容的效率？&lt;/span&gt;&lt;span&gt;蜻蜓FM作为国内首家互联网音频媒体平台，在音频行业深耕了10年，对此也有一些沉淀和经验想要和大家分享。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVdUialBuDlujlK7faXLBwPL3DxSWouiboOXe6ZicEr9AtXmtUB7cNuBOPQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要内容包括：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;蜻蜓首页场景怎样从人工运营演进到个性化推荐&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;蜻蜓信息流推荐由哪些算法组成，彼此怎么配合&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;整体推荐系统架构及算法模型如何部署到线上&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;蜻蜓信息流推荐场景后续发展的一些思考&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;场景&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 人工推荐时期&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVDebZVLNMICMAlU2icSo0Fwrqo5gL82GbxYN2YevKoBFmLxjibDcNffUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;早期蜻蜓首页流量的分发是以模块形式展示，每个模块可配置横排和竖排的个数。此时只有个性推荐模块的内容由推荐算法生成，其他模块则是由运营人工维护。模块中的内容需要运营定期进行更换，展示内容的更新完全依赖人工，效率显得很低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了&lt;/span&gt;&lt;span&gt;提高运营人工工作效率，我们引入了策略推荐。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 策略推荐时期&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;策略推荐时期运营的工作由之前每天更新模块中的内容，变成了为模块绑定内容库和选择合适的排序策略。内容库中的内容是由配置的分类、属性动态生成和更新，运营为单个模块的配置基本可以做到了一劳永逸。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVhu4QrV4icbSyZFqgxicOGWJZiasvwJAiaGibHib230iaqhnBAJ23b1vEI5v8A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;模块之间怎么排序？模块中的内容排序策略怎么选才能收益最大化？成了新的挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 个性推荐时期&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVKbVIpSvmvme9lAy8f5LgQYWh0SMHTs0APFbcOFeTP3xJvotLdnSjoA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过数据发现个性推荐模块效率高于其他策略推荐的模块，首先尝试了扩大个性推荐模块中内容的数量，由3个变6个。验证了对首页整体效果有提升后，把多个模块合并成一个信息流的个性化推荐的想法应运而生，线上AB实验结果表明信息流的个性化推荐各项指标均高于多个模块的策略推荐。信息流的形态是单排还是双排？经过AB实验，最后选择了效果更优的双排。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVFBE86BOxn04AdfsMSCCV4ic3mK0Gu61mGPB1DwxX6X74NxrO6k2B8cw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;个性推荐时期运营对于少数专辑依然会有流量扶持、推广的的述求，在个性化推荐的基础上增加了投放系统。投放系统中还支持通过不同标题、封面对单个投放计划生成多个创意，多个创意之间数据表现好的沉淀下来推广到更多的场景中。运营不再局限于选择内容，更为重要的是重新组织创造了内容，充分发挥出了运营在想象力、创造力上的价值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. 小结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVSBZLm98SjVJX1gKnGNG83n2ua8e8yTQUD5K2F8B9EHuXvibH50LRgbw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首页场景经历人工推荐、策略推荐、个性推荐三个阶段。策略推荐基本解决了人工效率问题，个性推荐进一步解放人力的同时也带来了数据指标的显著提升。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;算法&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;伴随着首页场景的演进，蜻蜓的推荐算法也在不断的完善和迭代。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 推荐算法流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnV6IMYUcKsuF4ic74wZk54po85KbiaibT13wxhOaXnKyJicZPP7Ep4XD5YUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐算法的流程大致如下：内容池中达到推荐标准的内容的有几十万个，召回层从中选出用户可能喜欢的几千个进入粗排层，召回层的覆盖度决定了整体推荐内容的覆盖上限。粗排层从召回结果中挑选出几百个给到精排层，粗排层主要为了减小在线算力减轻精排的压力。精排层选几十个给到重排层，精排层专注于推荐的准确性。最后，重排层对推荐结果进行重新排序给到用户，这一层兼顾准确性的同时还需要保证多样性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;级联结构简单，分工明确。兼顾了覆盖度、性能、准确性和多样性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 多路召回&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnV2mbw9cS2xMVhvqS5uiaMzrRV7rovn2TeWKMyY11Vl2lFzX5J5NyI0bA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;熟悉了推荐的算法的大致流程后，首先，我们来了解一下多路召回。多路召回在蜻蜓主要分为三类：基于内容、协同过滤和Embedding向量召回。基于内容的召回包括热门、属性、上新策略的召回；协同过滤包括User Based和Item Based；Embedding向量召回有Word2vec和Bert。召回环节处理的数据量大，复杂度不能太高，多路召回的设计可以方便加入新的策略或者算法。我们在实践中发现，早期建立完善指标，追踪每路召回的效果，有助优胜劣汰；召回的效果并不是召回算法越复杂越好，不同的业务特点不一样适合的召回也可能不一样，比如蜻蜓当下表现最优的召回来自ItemCF和热门；随着召回的算法越加越多，新的召回需要与现有召回有差异性、互补才会有存在的价值。召回环节还会承载业务及平台建设的使命比如用户和物品的冷启动、业务流量扶持等，召回环节的好坏直接决定了后续环节的上限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 粗排&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVSMeetHCPMke53Ndrz5KotW8WhZmomFuJickeqkmQlsx95nYVsibUIjwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着是粗排，早期的推进系统中粗排常常用简单的融合策略进行，实践中发现粗排中引入算法是值得的。策略的组合较多测试周期长，双塔模型的应用既解决了多路召回组合的效率问题，又避免了精排的性能问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;双塔模型扩展性好便于自由添加自定义的网络，User和Item塔解偶，同时点积的计算所需算力小。在蜻蜓为了保障粗排推理数据的实时性，User向量的生成及点积的计算都是实时的。粗排的加入在数据指标指标上也获得了不错的收益，其中信息流UV收听转化率增加了3.54%，人均收听时长增加了5.44%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. 精排&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnV5V3Z8ve4BicmThzicSSrQm3qkmwmkOMRmx3AdV1sNnKOnXWB7MSECiciaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后是精排，精排往往在推荐系统中最受关注，精排直接对准确性负责，相对容易拿到直接的收益。我们在精排的投入相对较大，从中获得的收益也相对颇多。蜻蜓的精排经历了三个阶段：线性模型的逻辑回归和FM、树模型的XGBoost以及神经网络模型的DeepFM。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVNMuLOrOqdlZiaIBwzJIXibOc3Z7PEFp8jpDjpXR6TTHcF3jMAA6Xpu4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;XGBoost迭代时间最久，其中模型参数的调优、特征挖掘（包括交叉特征和实时特征的引入）、日志数据的准确性优化以及实时排序，这些整体给在线收听数据带来了近35%的提升。XGBoost之后我们尝试过许多模型包括XGBoost+LR，Wide&amp;amp;Deep等均没有取得预期的收益，在DeepFM上的尝试探索则获得了9.3%收听相关指标的提升。DeepFM顺理成章地成为了精排模型的主力，也开启了蜻蜓推荐算法在深度学习道路上的大门。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5. 重排&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVLichYCYy7BJnBicssw2ruqYZ6YPwftLxtcjpZkEGNzN9UKPlo9gxbX6g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后是重排，重排跟召回一样承载了很多业务向的目标和期许。这里主要讲一下多样性，提升多样性一方面希望打破推荐系统的信息茧房，另一方面也希望提升用户的长期使用体验。开始是通过打散策略实现，当前主要是MMR和DPP两个算法在尝试迭代，实验中MMR表现优于DPP，这里简单介绍一下。MMR(Maximal Marginal Relevance)最大边际相关性算法，保证相关性的同时提高多样性。通过λ参数来调节多样性和相关性的权重，λ越大相关性越高，λ越小则多样性越高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVf5lMqlKZknB9J7lD5E9GwW0dJ6XdFDRkGJdPmV1jicdbiagd3kraSzVA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MMR算法中有两个相似度，用户和物品的相似度用精排的打分值来表示，物品之间的相似度基于协同过滤的物品相似度。重排的预期是达到帕累托最优，在其他指标都不降低的情况下，提升多样性指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVsaE4R5wOMp0pqkImhaEtt5dicwcQegFH7J4c7HWjB4tvYgZicCRR57UA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终也达到了预期，人均曝光专辑数量增加8.84%，人均收听二级分类数量提升7.06%。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;架构&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 整体架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVnsbicWzt5fI8fnRFh346JKuTZKKjGfwdBAEbfgaLSNlmR4Nm99PaOsw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐系统能高效稳定地运作，离不开优秀的架构支持。蜻蜓的推荐架构是典型的三层架构，即离线、近线、在线三层。离线层负责数据的处理、模型的训练以及数据报表；近线层实时特征处理、召回、粗排；在线层承载了用户请求响应、精排、重排以及投放系统等业务逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 算法模型部署&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVPt0KmAmVXWGibWPn1jic6sAsHaNZc5rrOtLUU4YBtfsGnpNeiceCrJIHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;算法模型如何高效地部署到线上？是算法和工程同学共同面临的挑战。开始的时候我们的模型预测服务和推荐API都是用Golang实现，特征的获取处理在推荐API测完成，模型预测服务负责加载模型并对对获取的数据进行预测。在线特征拼接处理使用Golang，离线特征拼接处理使用Scala，跨语言的对齐与校验耗费了开发很多的时间。离线和在线能否公用一套算子进行特征的拼接与处理？为此我们将模型预测服务切换成了Scala的Play框架，基于Scala开发出了一个feature获取处理的库，给Spark和Play共同使用，保证了特征处理逻辑层面的一致性。同时，模型预测服务中增加了对多模型、多版本的支持以及模型的自动更新进一步提高了模型部署的效率。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;展望&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVwFSCf0yX8ngvnsyRg68lHtTceKIicScxeqflh2trkyvjBvibsnzH4tiaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首页信息流推荐从0到1建立起来，迭代、优化、完善到现在取得了不错的增长，面向未来还有许多工作需要我们去尝试和探索。内容方面，如何帮助新品内容一步一步变成曝款，产品、研发、运营如何合作建立出完善的内容生态系统；业务方面，信息流支持的业务越来越多包括专辑、直播、听单、节目、广播等，多业务如何更好的融合在一起也是一个挑战；用户方面，新用户的冷启动，沉默用户、潜在流失用户如何激活还有很长的路要走；算法方面，模型的训练如何做到更加实时，多目标的排序是否有望代替单目标排序。这些都将是我们接下来探索的方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16008590572276=&quot;rgb(136, 151, 171)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(63, 74, 89)&quot; data-style=&quot;color: rgb(63, 74, 89); font-family: 微软雅黑; font-size: 11pt; letter-spacing: 0.4pt; text-align: left; text-indent: 0pt; visibility: visible;&quot;&gt;今天的分享就到这里，谢谢大家。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;团队内推：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;蜻蜓 FM 智能运营团队目前正在招聘推荐算法和 Golang 开发，感兴趣的同学请将简历发送&lt;/span&gt;&lt;span&gt;至下方邮箱，&lt;span&gt;直接&lt;/span&gt;&lt;span&gt;与技术负责人对话~&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;jifei@qingting.fm&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在文末分享、点赞、在看，给个3连击呗~&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;文章作者：&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;209&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;209&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVm8XuqBu1dib7fGJS87tM10aFtavvEnLibbwuujcBf27oXvtDAI5OXQMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;季飞&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;蜻蜓FM | 推荐技&lt;/span&gt;&lt;span&gt;术负责人&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;9年推荐、搜索相关工作经验，目前负责蜻蜓FM推荐、搜索等流量分发业务的架构与算法开发工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;活动推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6月1-3日，张宏江携手Bengio等图灵奖得主及200+AI领袖，邀您参加2021北京智源大会啦，30+论坛全覆盖，识别海报二维码即可报名～&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;999&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.728624535315985&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPg9JKGkGU7BGZzW2l4MNMnVFR4z42g8icRmSW8Q40mWQ4dvF4z8YgrP77SDLVIeNXdibiaHSAOHzibKbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1076&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关于我们：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;DataFunTalk &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;专注于大数据、人工智能技术应用的分享与交流。发起于2017年，在北京、上海、深圳、杭州等城市举办超过100场线下沙龙、论坛及峰会，已邀请近600位专家和学者参与分享。其公众号 DataFunTalk 累计生产原创文章300+，百万+阅读，10万+精准粉丝。&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1NTMyOTI4Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgiaIKm4YqA09u83TvzKbfsabjfX1TLzaXLAK9MWmC4qI6cuTBJnxygZLZPU49O8g6j8QI9264NMqQ/0?wx_fmt=png&quot; data-nickname=&quot;DataFunTalk&quot; data-alias=&quot;datafuntalk&quot; data-signature=&quot;专注于大数据、人工智能技术应用的分享与交流。致力于成就百万数据科学家。定期组织技术分享直播，并整理大数据、推荐/搜索算法、广告算法、NLP 自然语言处理算法、智能风控、自动驾驶、机器学习/深度学习等技术应用文章。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;🧐&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;，给个&lt;strong&gt;3连击&lt;/strong&gt;呗！&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>