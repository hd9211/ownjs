<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a720392ac0888efce9116e50045487e0</guid>
<title>[推荐] 《一年顶十年》干货读书笔记</title>
<link>https://toutiao.io/k/okqtla6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者彪悍一只猫是范登读书首席社群顾问，一天的咨询费20万元。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;书非常薄，一共170+篇文章，每篇都很短，我花了2个多小时就读完了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下的作者观点，非常有共鸣。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;摘抄下来，和大家共勉，一起精进！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、时间更少，为何更好！&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，除了少数必须花很多时间才能做好的事情外，对于一般的事情，真没必要给自己留太多时间，完全可以把截止时间提前，甚至大大提前。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、时间投资评估&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做这件事，其实就是回答五个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;（一）今天都做了什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（二）所做的事情分别有什么产出？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（三）做这些事情，分别花了多少时间？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（四）哪些事情是应该做的，哪些事情是不应该做的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（五）在时间花费上，还有哪些方面需要改进？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、稻盛和夫的六项精进&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;（一）付出不亚于任何人的努力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（二）要谦虚，不要骄傲&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（三）要每天反省&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（四）活着，就要感谢&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（五）积善行，思利他&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（六）不要有感性的烦恼&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、为什么要帮助他人&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个内心能量不足的人，往往通过给他人提供帮助，让自己的内心变得更阳光，从而拥有更好的状态。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5、爱好&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至少培养一项&lt;strong&gt;爱好&lt;/strong&gt;，做自己真正热爱的事情，你会感到很快乐。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6、为什么要尽早实战？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽早进入实战，并不是急于求成，而是让自己在行动中得到&lt;strong&gt;反馈&lt;/strong&gt;，让自己学的更好，更能解决实际问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7、如何面对各种错误&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果犯错了，请记住，错了就是错了，你要做的不是纠结和狡辩，而是想办法去弥补过失，并让自己变得更强，成为真正的高手。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8、为何要读透几本书？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在你的专业领域，一定有非常经典、非常值得去读的书籍。你要反复去啃这些书，并反复在实践中应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;站在巨人的肩膀上创新，比纯靠自己摸索，更高效，更有优势。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9、读书一定要记住吗？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用，才是更好的读。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;（一）重复读，多读几遍。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（二）读的过程中思考怎么去用，还要真的去用，且努力做出成绩。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（三）分享给更多人。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10、要不要写读书笔记？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是写践行清单，你不仅要思考哪些内容是真正自己用得上的，还要去琢磨自己能怎么用，接下来该怎么做。效果自然要好很多。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11、如何才能受欢迎&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你真能做到“简单易懂、非常好用、充满力量”，你的课肯定会更受欢迎。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12、为何别把顾客当爷&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你要记住，你和顾客的关系，最起码是平等的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你是去帮助顾客的，如果他买了你的产品，他的问题将得到解决，他的需求将被满足，甚至是被超预期满足。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13、为什么要成为专家&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你应该找到一个&lt;strong&gt;细分领域&lt;/strong&gt;，通过学习、实践、分享，努力成为这个领域的专家，你将得到更多机会，你的时间也会更值钱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;走专家路线，会让你更容易脱颖而出。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14、保持渴望&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我渴望成大事，而且是持续&lt;strong&gt;渴望&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15、常被碾压&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我有一个习惯，就是坚持去找能在某方面碾压我的人，跟他交流，感受差距，向他学习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想要持续高效地成长，你就必须不断走出&lt;strong&gt;舒适区&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16、边学边帮&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想学得更好，发展的更快，我们不仅要不断“想上学”——向厉害的人学习，还要不断“向下帮”——帮助需要我们的人。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17、日拱一卒&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我坚信，就算底子不如人，只要保持每日精进，总有一天我会脱颖而出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你也希望自己能成为一个厉害的人，不妨找一件值得坚持的小事，每天都做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不用管什么结果，因为结果会随时间的积累而显现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18、解决一切问题的关键&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让自己变好，是解决一切问题的关键。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读书笔记摘抄日期是2020年3月29日。今天再读一遍，还是感觉能量满满，很受用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤其：“向上学、向下帮“是新时代个人学习、精进技术、提升自己的非常重要的方法论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;向上学——开阔视野和眼界，看到自己的“圈层”看不到的东西；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;向下帮——夯实基础、加深认知，帮助别人的同时提升自己。&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;推荐：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDY1MTA3OQ==&amp;amp;mid=2247484469&amp;amp;idx=1&amp;amp;sn=1e2b354e6fd031d041f888ad6b1c0689&amp;amp;chksm=eaa82c1ddddfa50b39883162eba2e493bcde3f3e4e866bfd1a1f8c6b67a6afad9529b483313d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;升级这十点认知，你就是大佬！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDY1MTA3OQ==&amp;amp;mid=2247484343&amp;amp;idx=1&amp;amp;sn=858e47e8aa649acebb60a800fc199aff&amp;amp;chksm=eaa82b9fdddfa28948f852d83ad861207ddf24d3270c9155224e00850d779305aacb186d5905&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;认知升级——不做开始爱好者！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;204&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.3649122807017544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9b9Xcyef7ctwTotdPcicKx6E5CJ3iaWUjiciaBdd0ricW2ekneVvuEEpC7Lybu0Jedh0onEWia9RUzZ2g7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;span&gt;可能&lt;/span&gt;&lt;span&gt;是中国人数最多的非官方 Elastic 公众号！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on WeChat for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>94a9112ab8d66d1f262da1a2bea7c20d</guid>
<title>[推荐] 一个每秒超过 3 万请求的微服务开发经历</title>
<link>https://toutiao.io/k/s2yudly</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;导读：本文介绍的是一个国外的外卖平台 ifood 的微服务案例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ifood 是一家巴西外卖平台公司，平均每天送出 100 多万份订单，每年增长 110% 左右。作为一家外卖平台，访问峰值大多出现在午餐和晚餐前后，周末的时候会更高一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在一些特殊的日子里（比如由于营销活动），访问量曾打破记录，平台获得了历史最高峰值，去年 6 月 12 日。我们一个微服务达到了每分钟 20 0万请求的峰值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;故事背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我在公司平台部门的账号与身份团队工作了大约一年半的时间，这是一个相当长的旅程，由于公司的快速发展，我们时常会面临很多挑战。&lt;strong&gt;在设计新的解决方案时，我们总是要牢记这样一个想法：在几个月后，系统的使用量会增长 2 - 3 倍。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;今天要讲的故事就是上面案例的一种情况，这个系统是在 2018 年左右开发的，当时公司每个月的订单量是 1300 万。如今已经超过 3000 万了。在这个案例中，系统的使用量是随着公司用户的增长比例而增长的，当然后来增长速度更加迅猛。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在内部，我们把这个微服务称为账号元数据。尽管这是一个通用的名字，但它也解释了这个服务的目的：它处理账号的元数据。什么是账号元数据？主要是指那些非关键的用户信息。举个例子：如果用户喜欢通过短信或邮件收到通知，喜欢的食物类型（比如汉堡、意大利面、日本料理等），一些功能标志，为该用户做的订单数量等等。它就像一个通用的存储，把不同地方的数据汇总起来，方便地服务于客户端调用，同时也服务于其他微服务，这样他们只需要调用一个微服务，而不是 10 个微服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最早在 2018 年时，账号元数据的建立主要是为了放一些杂乱的（并不怎么用的）信息，说实话，没有其他地方可以放。我们需要一点结构和查询能力，而且很容易扩展，所以我们选择了 AWS 提供的 DynamoDB。在这里要说明一下，我们明白系统可能会增长，当时公司也已经相当大了，平均负载是有挑战的。但是，我们还是没有预估到，我们会从每分钟 1 万个请求增长到 20 万，然后最终达到了 200万。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个微服务刚发布后，并没有多少人使用（与账号团队的其他微服务相比）。然而，几周后做出的一些新的架构调整，让这个系统变得非常重要，它将成为客户端获取用户所有信息的首批调用目标之一。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在此之后的几个月，其他团队开始把账号元数据看作是一个很好的功能，可以把分散存储在多个地方的信息都搬来这里，依赖多个服务毕竟很麻烦。另外，我们开始创建更多的聚合，让其他微服务的调用变得非常简单，也让其他团队更多的了解了它的知名度和重要性。现在，账号元数据除了用户每次打开应用的时候都会被调用，而且被很多团队在很多其他不同的场景下访问。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面就是一个非常简单的总结，介绍了从 2018 年到现在发生的事情，系统为何变得如此重要。在这期间，团队（我加上八个非常优秀的同事，非常幸运地与他们一起工作）积极地进行了工作，但工作并未停止，我们仍然在为我们负责的其他十个微服务进行优化、开发以及维护。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们做了一大堆的改动，如果要展开我们经历的所有场景，会花费太多时间，所以我只把当前要说的这个架构描述清楚，我们需要能够稳定地每分钟处理 200万个请求。是时候深入到技术部分了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;深入技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;正如前面所说，这个微服务存储了账号的元数据。在数据库中，我们将这些元数据分割成不同的上下文（在代码中称之为 namespace 命名空间）。一个客户（customer_id 作为分区键）可以有 1 到 N 个 namespace（作为排序键），而且每个 namespace 都有一个固定的、强制性的 schema，插入前通过  jsonschema 来定义和检查。有了它，我们就可以确保无论如何将数据插入到哪个 namespace 中（后面会有更多的细节），都会遵从它的模式和正确的用法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们使用这种方法，是因为这个系统中，读和写是由不同的团队来完成的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;插入工作是由数据科学团队完成的，他们每天都会从内部工具中导出数百万条记录到这个微服务中，并通过 API 将这数百万条记录分割成每次 500 条进行批量调用。所以，一天中的某个特定时间，这个微服务会收到数百万次的调用（间隔 10 到 20 分钟），将数据插入到 DynamoDB 中。如果接收 API 直接将数据写入数据库，就会碰到 Dynamo 扩展的一些问题，而且响应时间过慢也是个问题。解决这个瓶颈的方法是数据团队直接将数据写入数据库，但是，我们必须检查这些记录是否符合命名对应空间的 jsonschema，这是此微服务的责任。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以解决方案是，API 接收这批记录，并将它们发布在 SNS/SQS 消息队列上，而 SNS/SQS 将被另外一个模块来消费，然后验证这些记录，如果没问题，就保存在 Dynamo 上。通过这种方式，接收到这批记录的接口可以非常快速地响应，我们不依赖 HTTP 连接进行写入（这一点相当重要，因为与 Dynamo 的通信可能会失败，再次尝试可能会使 HTTP 响应时间变得非常慢）。另一个好处是，我们可以通过调整队列消费程序，来控制从 SQS 读取数据以及在 Dynamo 上写入数据的快慢。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这个流程之外，账号元数据也会被另一个服务调用，每当平台收到一个新订单就会调用它，并更新这个订单的一些信息。鉴于 ifood 每天订单量超过 100 多万，微服务也会接受到这个数量的调用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;虽然上面提到有一个非常繁重的写的过程，但是这个服务 95% 的负载来自于 API 调用读取的请求。前面也提到，读写数据是由公司不同的团队完成的，读的调用牵涉到非常多的团队，包括客户端的调用。比较幸运的是，这个微服务读请求要比写请求多得多，因此它的扩展就更容易一些。因为任何一个大量读取数据的系统都需要一个缓存，这个也是如此，AWS 没有使用 Redis 之类的东西，而是提供了 DAX 作为 DynamoDB 的 &quot;内置&quot; 缓存。要使用它，你只需要让客户端理解不同查询操作中可能存在有复制延迟。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这样的调用量下，出现一些异常的情况也是很正常的。在我们的案例中，我们看到 Dynamo 中的一些查询耗时超过 2 - 3 秒，而 99.99% 的调用都在 17ms 以下。尽管这些慢查询每天只有几千次，但我们希望为团队提供更好的 SLA。所以我们决定如果碰到 Dynamo 超时就进行重试。也相关团队也讨论过，让他们在调用我们的 API 时配置一个低超时。他们大多数 HTTP 客户端的默认时间是 2s，所以我们改成了大约 100ms。如果他们碰到超时（比方说微服务对 dynamo 做了重试，但又失败了），他们可以重试，并且很可能会马上得到响应。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了部署它，我们使用 k8s（达到 70 个左右的 pod），并随着每秒请求的增长而进行扩展。DynamoDB 被设置为供应（provision）而非按需。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一个重要的步骤是确保系统能够在真正高吞吐量的情况下健康地工作，我们每天对它进行负载/压力测试，以确保新版本部署没有降低性能。通过这个负载测试的结果，我们可以跟踪一个接口是随着时间的推移和它的发展而变好还是变坏。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着时间的推移，这个微服务变得越来越重要，如果由于某些原因出现故障，那就是一个不可承受的问题。为了解决这个问题，我们要求团队通过 Kong（我们的 API 网关）来调用微服务，并在那里配置了一个 fallback。如果微服务宕机或返回 500，Kong 会激活回调，客户端会得到一个默认结果。在这种情况下，fallback 目前指向一个 S3 bucket，里面有系统会提供的数据副本。它可能是一些过时数据，但这总比不返回任何数据要好。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后总结一下，本文简单描述了一个高性能微服务工作方式。虽然微服务还包括一些其他的工作流程，跟主题无关就不展开赘述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;再谈下微服务接下来的工作，尽管目前还不是完全清晰。微服务的使用量可能会更多，我们可能会达到一个点，开始变得越来越难让它 scale。一个替代方案可能是将其拆分成不同的微服务（甚至可能使用不同的数据库），或者聚合更多的数据以更好地服务于他们。不管如何，我们还是会不断地测试，找到瓶颈，并持续优化它们。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;英文原文：&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://medium.com/swlh/developing-a-microservice-to-handle-over-30k-requests-per-second-at-ifood-3e2d7b822b0e&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;参考阅读：&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文由高可用架构翻译，技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;高可用架构&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;改变互联网的构建方式&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;img data-w=&quot;200&quot; data-type=&quot;jpeg&quot; data-s=&quot;300,640&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOPOK9rQud9XibGhPOPsA3gA8Wr4CEnzmhfZQzSGu0Q09GOuk18S9icZtuVnQewvyqZtOWyDnJPBDn1A/640?wx_fmt=jpeg&quot;/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;长按二维码 关注「高可用架构」公众号&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8cf6011684ceda836394bc433aa80de0</guid>
<title>[推荐] 分布式事务精华总结篇，实打实的干货</title>
<link>https://toutiao.io/k/xdryz90</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b99326297969dc3b812c876ca20a4c9d</guid>
<title>[推荐] 大厂面试爱问的 “调度算法”，20 张图一举拿下</title>
<link>https://toutiao.io/k/zu9e79n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6456456456456456&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZgwDtjYM4HYicfVdQtHtWzYNCY6ibiaOjhqibkgONPk78B6ibhG5iaAJEHw8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;999&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;最近，我偷偷潜伏在各大技术群，因为秋招在即，看到不少小伙伴分享的大厂面经。&lt;/p&gt;&lt;p&gt;然后发现，操作系统的知识点考察还是比较多的，大厂就是大厂就爱问基础知识。其中，关于操作系统的「调度算法」考察也算比较频繁。&lt;/p&gt;&lt;p&gt;所以，我这边总结了操作系统的三大调度机制，分别是「&lt;strong&gt;进程调度/页面置换/磁盘调度算法&lt;/strong&gt;」，供大家复习，希望大家在秋招能斩获自己心意的 offer。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8977528089887641&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZibhicbtgKkdVkLs3SyuQXdpJgAy2HQ2MmBjA7FWk8AxGvWQXrZKrQTBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1780&quot; title=&quot;本文提纲&quot;/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;进程调度算法&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。&lt;/p&gt;&lt;p&gt;当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。&lt;/p&gt;&lt;p&gt;什么时候会发生 CPU 调度呢？通常有以下情况：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当进程从运行状态转到等待状态；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当进程从运行状态转到就绪状态；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当进程从等待状态转到就绪状态；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当进程从运行状态转到终止状态；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。&lt;/p&gt;&lt;p&gt;非抢占式的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。&lt;/p&gt;&lt;p&gt;而抢占式调度，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。&lt;/p&gt;&lt;p&gt;你可能会好奇为什么第 3 种情况也会发生 CPU 调度呢？假设有一个进程是处于等待状态的，但是它的优先级比较高，如果该进程等待的事件发生了，它就会转到就绪状态，一旦它转到就绪状态，如果我们的调度算法是以优先级来进行调度的，那么它就会立马抢占正在运行的进程，所以这个时候就会发生 CPU 调度。&lt;/p&gt;&lt;p&gt;那第 2 种状态通常是时间片到的情况，因为时间片到了就会发生中断，于是就会抢占正在运行的进程，从而占用 CPU。&lt;/p&gt;&lt;p&gt;调度算法影响的是等待时间（进程在就绪队列中等待调度的时间总和），而不能影响进程真在使用 CPU 的时间和 I/O 时间。&lt;/p&gt;&lt;p&gt;接下来，说说常见的调度算法：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;先来先服务调度算法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最短作业优先调度算法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;高响应比优先调度算法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;时间片轮转调度算法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最高优先级调度算法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;多级反馈队列调度算法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;先来先服务调度算法&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;最简单的一个调度算法，就是非抢占式的&lt;strong&gt;先来先服务（&lt;em&gt;First Come First Severd, FCFS&lt;/em&gt;）算法&lt;/strong&gt;了。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.1845841784989858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZoxM6N7Jy6UKza3ZpdJ3cuooUKialnynrtsNF5XLlJujA1q4bVwXgsrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;986&quot; title=&quot;FCFS 调度算法&quot;/&gt;&lt;figcaption&gt;FCFS 调度算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;顾名思义，先来后到，&lt;strong&gt;每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。&lt;/p&gt;&lt;p&gt;FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;最短作业优先调度算法&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;最短作业优先（&lt;em&gt;Shortest Job First, SJF&lt;/em&gt;）调度算法&lt;/strong&gt;同样也是顾名思义，它会&lt;strong&gt;优先选择运行时间最短的进程来运行&lt;/strong&gt;，这有助于提高系统的吞吐量。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.25747348119575697&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZibWluoGY8jSBlJcC3kf3icJOwav0eaBjKCsSYiaibH2HMuFcfNI3BNevoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1037&quot; title=&quot;SJF 调度算法&quot;/&gt;&lt;figcaption&gt;SJF 调度算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这显然对长作业不利，很容易造成一种极端现象。&lt;/p&gt;&lt;p&gt;比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;高响应比优先调度算法&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。&lt;/p&gt;&lt;p&gt;那么，&lt;strong&gt;高响应比优先
（&lt;em&gt;Highest Response Ratio Next, HRRN&lt;/em&gt;）调度算法&lt;/strong&gt;主要是权衡了短作业和长作业。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行&lt;/strong&gt;，「响应比优先级」的计算公式：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.30244755244755245&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZoNApBywj8b0beDyqGSmcLgo5JaFX9e0cFIRu7hy07surhTHGmlguWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;572&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从上面的公式，可以发现：&lt;/p&gt;&lt;h4&gt;&lt;span&gt;时间片轮转调度算法&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;最古老、最简单、最公平且使用最广的算法就是&lt;strong&gt;时间片轮转（&lt;em&gt;Round Robin, RR&lt;/em&gt;）调度算法&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.36328125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZP4gVjlLVicB8dgLia61oPDNDMXtibDvwonFJayjX6ib0WfPwuUbsvmpicrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot; title=&quot;RR 调度算法&quot;/&gt;&lt;figcaption&gt;RR 调度算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;每个进程被分配一个时间段，称为时间片（&lt;em&gt;Quantum&lt;/em&gt;），即允许该进程在该时间段中运行。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;另外，时间片的长度就是一个很关键的点：&lt;/p&gt;&lt;p&gt;通常时间片设为 &lt;code&gt;20ms~50ms&lt;/code&gt; 通常是一个比较合理的折中值。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;最高优先级调度算法&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。&lt;/p&gt;&lt;p&gt;但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能&lt;strong&gt;从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（&lt;em&gt;Highest Priority First，HPF&lt;/em&gt;）调度算法&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;进程的优先级可以分为，静态优先级或动态优先级：&lt;/p&gt;&lt;p&gt;该算法也有两种处理优先级高的方法，非抢占式和抢占式：&lt;/p&gt;&lt;p&gt;但是依然有缺点，可能会导致低优先级的进程永远不会运行。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;多级反馈队列调度算法&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;多级反馈队列（&lt;em&gt;Multilevel Feedback Queue&lt;/em&gt;）调度算法&lt;/strong&gt;是「时间片轮转算法」和「最高优先级算法」的综合和发展。&lt;/p&gt;&lt;p&gt;顾名思义：&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7403189066059226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZndTQo5RomnKeOoMXITZJnwEEHMPiaqia1WUuApRNLpIJKLEWU8TurWicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;878&quot; title=&quot;多级反馈队列&quot;/&gt;&lt;figcaption&gt;多级反馈队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;来看看，它是如何工作的：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;设置了多个队列，赋予每个队列不同的优先级，每个&lt;strong&gt;队列优先级从高到低&lt;/strong&gt;，同时&lt;strong&gt;优先级越高时间片越短&lt;/strong&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的&lt;strong&gt;兼顾了长短作业，同时有较好的响应时间。&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;内存页面置换算法&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在了解内存页面置换算法前，我们得先谈一下&lt;strong&gt;缺页异常（缺页中断）&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它与一般中断的主要区别在于：&lt;/p&gt;&lt;p&gt;我们来看一下缺页中断的处理流程，如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.85431654676259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2Z7X4NI9kMPxkB7RXL1XQpC3YKsicK7HKibFib6YzO3bCWW2snWVpo2kMaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1112&quot; title=&quot;缺页中断的处理流程&quot;/&gt;&lt;figcaption&gt;缺页中断的处理流程&lt;br/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在 CPU 里访问一条 Load M 指令，然后 CPU 会去找 M 所对应的页表项。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果该页表项的状态位是「有效的」，那 CPU 就可以直接去访问物理内存了，如果状态位是「无效的」，则 CPU 则会发送缺页中断请求。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;操作系统收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面的位置。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但是在换入前，需要在物理内存中找空闲页，如果找到空闲页，就把页面换入到物理内存中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为「有效的」。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最后，CPU 重新执行导致缺页异常的指令。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上面所说的过程，第 4 步是能在物理内存找到空闲页的情况，那如果找不到呢？&lt;/p&gt;&lt;p&gt;找不到空闲页的话，就说明此时内存已满了，这时候，就需要「页面置换算法」选择一个物理页，如果该物理页有被修改过（脏页），则把它换出到磁盘，然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。&lt;/p&gt;&lt;p&gt;这里提一下，页表项通常有如下图的字段：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.08587257617728532&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZQ3iaBAKQ8hiakicib5jIezwgFMhkESbal18lOgXbiaNCMibiaRlJT4r7JennQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1083&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;那其中：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;状态位&lt;/em&gt;：用于表示该页是否有效，也就是说是否在物理内存中，供程序访问时参考。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;访问字段&lt;/em&gt;：用于记录该页在一段时间被访问的次数，供页面置换算法选择出页面时参考。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;修改位&lt;/em&gt;：表示该页在调入内存后是否有被修改过，由于内存中的每一页都在磁盘上保留一份副本，因此，如果没有修改，在置换该页时就不需要将该页写回到磁盘上，以减少系统的开销；如果已经被修改，则将该页重写到磁盘上，以保证磁盘中所保留的始终是最新的副本。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;硬盘地址&lt;/em&gt;：用于指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里我整理了虚拟内存的管理整个流程，你可以从下面这张图看到：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.6638655462184875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZMZKkeg0rv1uGP3t5B8rTk8Q5nwMXHExnvbfCOBsJTgff15ZGIXBv5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1190&quot; title=&quot;虚拟内存的流程&quot;/&gt;&lt;figcaption&gt;虚拟内存的流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;所以，页面置换算法的功能是，&lt;strong&gt;当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面&lt;/strong&gt;，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页。&lt;/p&gt;&lt;p&gt;那其算法目标则是，尽可能减少页面的换入换出的次数，常见的页面置换算法有如下几种：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;最佳页面置换算法（&lt;em&gt;OPT&lt;/em&gt;）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;先进先出置换算法（&lt;em&gt;FIFO&lt;/em&gt;）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最近最久未使用的置换算法（&lt;em&gt;LRU&lt;/em&gt;）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;时钟页面置换算法（&lt;em&gt;Lock&lt;/em&gt;）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最不常用置换算法（&lt;em&gt;LFU&lt;/em&gt;）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;最佳页面置换算法&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;最佳页面置换算法基本思路是，&lt;strong&gt;置换在「未来」最长时间不访问的页面&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;所以，该算法实现需要计算内存中每个逻辑页面的「下一次」访问时间，然后比较，选择未来最长时间不访问的页面。&lt;/p&gt;&lt;p&gt;我们举个例子，假设一开始有 3 个空闲的物理页，然后有请求的页面序列，那它的置换过程如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3920092646207296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZnmYwiam1r7gMMfhibS6OgpYxaqYSQSX8802CicuMQ2BY477UaaMAzYbyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1727&quot; title=&quot;最佳页面置换算法&quot;/&gt;&lt;figcaption&gt;最佳页面置换算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在这个请求的页面序列中，缺页共发生了 &lt;code&gt;7&lt;/code&gt; 次（空闲页换入 3 次 + 最优页面置换 4 次），页面置换共发生了 &lt;code&gt;4&lt;/code&gt; 次。&lt;/p&gt;&lt;p&gt;这很理想，但是实际系统中无法实现，因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间。&lt;/p&gt;&lt;p&gt;所以，最佳页面置换算法作用是为了衡量你的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;先进先出置换算法&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;既然我们无法预知页面在下一次访问前所需的等待时间，那我们可以&lt;strong&gt;选择在内存驻留时间很长的页面进行中置换&lt;/strong&gt;，这个就是「先进先出置换」算法的思想。&lt;/p&gt;&lt;p&gt;还是以前面的请求的页面序列作为例子，假设使用先进先出置换算法，则过程如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3920092646207296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZeDaPGdiccfN3Eg0iboib5aXqzy91dRW7glSXHm6ePTDSpT7nKMD8ZpWicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1727&quot; title=&quot;先进先出置换算法&quot;/&gt;&lt;figcaption&gt;先进先出置换算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在这个请求的页面序列中，缺页共发生了 &lt;code&gt;10&lt;/code&gt; 次，页面置换共发生了 &lt;code&gt;7&lt;/code&gt; 次，跟最佳页面置换算法比较起来，性能明显差了很多。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;最近最久未使用的置换算法&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;最近最久未使用（&lt;em&gt;LRU&lt;/em&gt;）的置换算法的基本思路是，发生缺页时，&lt;strong&gt;选择最长时间没有被访问的页面进行置换&lt;/strong&gt;，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。&lt;/p&gt;&lt;p&gt;这种算法近似最优置换算法，最优置换算法是通过「未来」的使用情况来推测要淘汰的页面，而 LRU 则是通过「历史」的使用情况来推测要淘汰的页面。&lt;/p&gt;&lt;p&gt;还是以前面的请求的页面序列作为例子，假设使用最近最久未使用的置换算法，则过程如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3920092646207296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZV5q0UFx7mm4hpAPrLACUHGZ4dLNibUeGEmvHSica2PzuczKaSPWapJgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1727&quot; title=&quot;最近最久未使用的置换算法&quot;/&gt;&lt;figcaption&gt;最近最久未使用的置换算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在这个请求的页面序列中，缺页共发生了 &lt;code&gt;9&lt;/code&gt; 次，页面置换共发生了 &lt;code&gt;6&lt;/code&gt; 次，跟先进先出置换算法比较起来，性能提高了一些。&lt;/p&gt;&lt;p&gt;虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。&lt;/p&gt;&lt;p&gt;困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。&lt;/p&gt;&lt;p&gt;所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;时钟页面置换算法&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;那有没有一种即能优化置换的次数，也能方便实现的算法呢？&lt;/p&gt;&lt;p&gt;时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。&lt;/p&gt;&lt;p&gt;该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。&lt;/p&gt;&lt;p&gt;当发生缺页中断时，算法首先检查表针指向的页面：&lt;/p&gt;&lt;p&gt;我画了一副时钟页面置换算法的工作流程图，你可以在下方看到：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.1595197255574614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZB5X3lticb34c2wOrFgYhZ3aEn8TemDBHPvibrSUTTer71ibcc6dTH2S1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1166&quot; title=&quot;时钟页面置换算法&quot;/&gt;&lt;figcaption&gt;时钟页面置换算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;了解了这个算法的工作方式，就明白为什么它被称为时钟（&lt;em&gt;Clock&lt;/em&gt;）算法了。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;最不常用算法&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;最不常用（&lt;em&gt;LFU&lt;/em&gt;）算法，这名字听起来很调皮，但是它的意思不是指这个算法不常用，而是&lt;strong&gt;当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。&lt;/p&gt;&lt;p&gt;看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，我们需要考虑效率和硬件成本的。&lt;/p&gt;&lt;p&gt;要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。&lt;/p&gt;&lt;p&gt;但还有个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。&lt;/p&gt;&lt;p&gt;那这个问题的解决的办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2，也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;磁盘调度算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;我们来看看磁盘的结构，如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZfUPvKzYwW29lCAyicASoicQV0B0ZcfgJ7LZjR5cRJ8GYp0GM6lu3v9MA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; title=&quot;磁盘的结构&quot;/&gt;&lt;figcaption&gt;磁盘的结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;常见的机械磁盘是上图左边的样子，中间圆的部分是磁盘的盘片，一般会有多个盘片，每个盘面都有自己的磁头。右边的图就是一个盘片的结构，盘片中的每一层分为多个磁道，每个磁道分多个扇区，每个扇区是 &lt;code&gt;512&lt;/code&gt; 字节。那么，多个具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面，如上图里中间的样子。&lt;/p&gt;&lt;p&gt;磁盘调度算法的目的很简单，就是为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做到的。&lt;/p&gt;&lt;p&gt;寻道的时间是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。&lt;/p&gt;&lt;p&gt;假设有下面一个请求序列，每个数字代表磁道的位置：&lt;/p&gt;&lt;p&gt;98，183，37，122，14，124，65，67&lt;/p&gt;&lt;p&gt;初始磁头当前的位置是在第 &lt;code&gt;53&lt;/code&gt; 磁道。&lt;/p&gt;&lt;p&gt;接下来，分别对以上的序列，作为每个调度算法的例子，那常见的磁盘调度算法有：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;先来先服务算法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最短寻道时间优先算法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;扫描算法算法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;循环扫描算法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;LOOK 与 C-LOOK 算法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;先来先服务&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;先来先服务（&lt;em&gt;First-Come，First-Served，FCFS&lt;/em&gt;），顾名思义，先到来的请求，先被服务。&lt;/p&gt;&lt;p&gt;那按照这个序列的话：&lt;/p&gt;&lt;p&gt;98，183，37，122，14，124，65，67&lt;/p&gt;&lt;p&gt;那么，磁盘的写入顺序是从左到右，如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6327102803738318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2Z0wlwYlWoibKZaXpuV6yNHawXmC0df8TVSybia8ftic4hBYiaBEyElDT9gg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1070&quot; title=&quot;先来先服务&quot;/&gt;&lt;figcaption&gt;先来先服务&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;先来先服务算法总共移动了 &lt;code&gt;640&lt;/code&gt; 个磁道的距离，这么一看这种算法，比较简单粗暴，但是如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散，那先来先服务算法在性能上就会显得很差，因为寻道时间过长。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;最短寻道时间优先&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;最短寻道时间优先（&lt;em&gt;Shortest Seek First，SSF&lt;/em&gt;）算法的工作方式是，优先选择从当前磁头位置所需寻道时间最短的请求，还是以这个序列为例子：&lt;/p&gt;&lt;p&gt;98，183，37，122，14，124，65，67&lt;/p&gt;&lt;p&gt;那么，那么根据距离磁头（ 53 位置）最近的请求的算法，具体的请求则会是下列从左到右的顺序：&lt;/p&gt;&lt;p&gt;65，67，37，14，98，122，124，183&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7832369942196532&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZwibNLqUzibxCmqg4icRTx7Qgic2hDpssia1L4QZCCZw3icFlIIWzMGP7uiaPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1038&quot; title=&quot;最短寻道时间优先&quot;/&gt;&lt;figcaption&gt;最短寻道时间优先&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;磁头移动的总距离是 &lt;code&gt;236&lt;/code&gt; 磁道，相比先来先服务性能提高了不少。&lt;/p&gt;&lt;p&gt;但这个算法可能存在某些请求的&lt;strong&gt;饥饿&lt;/strong&gt;，因为本次例子我们是静态的序列，看不出问题，假设是一个动态的请求，如果后续来的请求都是小于 183 磁道的，那么 183 磁道可能永远不会被响应，于是就产生了饥饿现象，这里&lt;strong&gt;产生饥饿的原因是磁头在一小块区域来回移动&lt;/strong&gt;。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;扫描算法&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;最短寻道时间优先算法会产生饥饿的原因在于：磁头有可能再一个小区域内来回得移动。&lt;/p&gt;&lt;p&gt;为了防止这个问题，可以规定：&lt;strong&gt;磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（&lt;em&gt;Scan&lt;/em&gt;）算法&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;这种算法也叫做电梯算法，比如电梯保持按一个方向移动，直到在那个方向上没有请求为止，然后改变方向。&lt;/p&gt;&lt;p&gt;还是以这个序列为例子，磁头的初始位置是 53：&lt;/p&gt;&lt;p&gt;98，183，37，122，14，124，65，67&lt;/p&gt;&lt;p&gt;那么，假设扫描调度算先朝磁道号减少的方向移动，具体请求则会是下列从左到右的顺序：&lt;/p&gt;&lt;p&gt;37，14，&lt;code&gt;0&lt;/code&gt;，65，67，98，122，124，183&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8961538461538462&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZbUw0TGdzhnovtWNO2HhaoA9KOaxE5wse5nGv8hSicfWRv3OmZGatvMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1040&quot; title=&quot;扫描算法&quot;/&gt;&lt;figcaption&gt;扫描算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;磁头先响应左边的请求，直到到达最左端（ 0 磁道）后，才开始反向移动，响应右边的请求。&lt;/p&gt;&lt;p&gt;扫描调度算法性能较好，不会产生饥饿现象，但是存在这样的问题，中间部分的磁道会比较占便宜，中间部分相比其他部分响应的频率会比较多，也就是说每个磁道的响应频率存在差异。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;循环扫描算法&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;扫描算法使得每个磁道响应的频率存在差异，那么要优化这个问题的话，可以总是按相同的方向进行扫描，使得每个磁道的响应频率基本一致。&lt;/p&gt;&lt;p&gt;循环扫描（&lt;em&gt;Circular Scan, CSCAN&lt;/em&gt; ）规定：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且&lt;strong&gt;返回中途不处理任何请求&lt;/strong&gt;，该算法的特点，就是&lt;strong&gt;磁道只响应一个方向上的请求&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;还是以这个序列为例子，磁头的初始位置是 53：&lt;/p&gt;&lt;p&gt;98，183，37，122，14，124，65，67&lt;/p&gt;&lt;p&gt;那么，假设循环扫描调度算先朝磁道增加的方向移动，具体请求会是下列从左到右的顺序：&lt;/p&gt;&lt;p&gt;65，67，98，122，124，183，&lt;code&gt;199&lt;/code&gt;，&lt;code&gt;0&lt;/code&gt;，14，37&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7984570877531341&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2Zg7FnRFcvX5xzKKM8LgVUAZicPS786BuQVwjOBGYiagTicJagMic53ZtpYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1037&quot; title=&quot;循环扫描算法&quot;/&gt;&lt;figcaption&gt;循环扫描算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;磁头先响应了右边的请求，直到碰到了最右端的磁道 199，就立即回到磁盘的开始处（磁道 0），但这个返回的途中是不响应任何请求的，直到到达最开始的磁道后，才继续顺序响应右边的请求。&lt;/p&gt;&lt;p&gt;循环扫描算法相比于扫描算法，对于各个位置磁道响应频率相对比较平均。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;LOOK 与 C-LOOK算法&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;我们前面说到的扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。&lt;/p&gt;&lt;p&gt;那这其实是可以优化的，优化的思路就是&lt;strong&gt;磁头在移动到「最远的请求」位置，然后立即反向移动。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;那针对 SCAN 算法的优化则叫 LOOK 算法，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，&lt;strong&gt;反向移动的途中会响应请求&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8961538461538462&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZGZNn1JPaaQyE6le2KicZdMuTps5jAibkk59I8mNLujic2lLOicialWSnXcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1040&quot; title=&quot;LOOK 算法&quot;/&gt;&lt;figcaption&gt;LOOK 算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;而针 C-SCAN 算法的优化则叫 C-LOOK，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，&lt;strong&gt;反向移动的途中不会响应请求&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7974927675988428&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2Z4X9ryz0DLunZhf7DU6zarbJ7dDs7wBh3FLQqprqAIGwqbpxxNGfMwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1037&quot; title=&quot;C-LOOK 算法&quot;/&gt;&lt;figcaption&gt;C-LOOK 算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;絮叨&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;上周，奔波了不少城市，先后见到了帅地、敖丙、三歪和 JavaGuide，大家都是年轻的帅小伙。&lt;/p&gt;&lt;p&gt;接着，一同去苏州参加了技术类的公众号交流会，一下见到了好多个百万/千万的大佬，明天给大家分享下此次的行程和感悟。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5608108108108109&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZenXmtfRBFTOmjAxShC4v2ZbJPrKnwfJVZpr4LwQKhyyaV2ibAXd1cZbt3W5yPfQYfLibaiauY3onQfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;大家好，我是小林，一个专为大家图解的工具人，我们下次见！&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>983720bfed81471d5217cb6932713376</guid>
<title>[推荐] 如何产出规范、安全、高质量的代码？</title>
<link>https://toutiao.io/k/rd2k0cu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;blockquote&gt;
&lt;p&gt;对于一个软件开发团队，可以通过哪些代码质量指标和扫描方法让团队产出规范、安全、高质量的代码？让开发团队运行的安全、透明、可靠？本文总结了其中一些实践和工具，包含常见代码质量扫描工具、代码质量指标、第三方依赖管理、安全运维等几个方面，主要适用于 Java/JavaScript 技术栈的 web 项目，希望对于想要规范化自己的项目的 Tech Lead 有所帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于一个软件开发团队，可以通过哪些代码质量指标和扫描方法让团队产出规范、安全、高质量的代码？让开发团队运行的安全、透明、可靠？&lt;/p&gt;
&lt;p&gt;本文总结了其中一些实践和工具，包含常见代码质量扫描工具、代码质量指标、第三方依赖管理、安全运维等几个方面，主要适用于 Java/JavaScript 技术栈的 web 项目，希望对于想要规范化自己的项目的 Tech Lead 有所帮助。&lt;/p&gt;
&lt;h3&gt;代码扫描和常见质量指标&lt;/h3&gt;
&lt;p&gt;“祸患常积于忽微”，往往一些奇怪的 bug 都是一些不规范的小问题造成的。德国飞机涡轮机的发明者帕布斯·海恩提出的一个在航空界关于飞行安全的法则，法则指出: 每一起严重事故的背后，必然有 29 次轻微事故和 300 起未遂先兆以及 1000 起事故隐患。应用于软件开发中，如果项目中代码混乱不堪，必然会在某个时候最终爆发大量的问题。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/1-security-high-quality-code.jpg&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/1-security-high-quality-code-768x383.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里整理了一些常见的扫描工具和代码质量指标，可以在搭建项目基础设施时引入，用于自动化的检查代码中潜在的问题，达到控制代码产出质量的目的。&lt;/p&gt;
&lt;h4&gt;扫描工具&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;checkstyle&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;checkstyle 是常用于 java 项目的扫描工具，检查源代码是否与代码规范相符，检查项目主要包括：Javadoc 注释、imports、过长的类和方法、空格、重复文件、圈复杂度等，默认使用 sun 的代码规则，也可以配置自定义的代码规则，例如阿里就发布了相应的检查规则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;findbugs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 Bug Patterns 的概念，寻找代码中可能出现的 bug，检查项目主要包括：不良编程习惯导致的问题、性能问题、安全问题、线程问题等。例如，应使用 equals 判断相等，而不是 “ =” 操作符、流需要关闭、线程资源需要释放等问题。findbugs 的模式库对编程经验也有较好的提升作用。还可以导入和编写自己的 Bug Patterns 完善检查机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;simian&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;simian 是一个用于检查重复和相似代码的工具，它的重复检查类似于论文查重，会提示一定的相似度。可以单独运行，也可以作为 checkstyle 插件来使用，相对来来说比较小众。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pmd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pmd 是一款跨语言的通用静态扫描工具，具备一部分 checkstyle、findbugs 的功能，不再赘述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ESlint/TSlint&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前端界的 checkstyle , TSlint 设计用来做 TypeScript 类型检查，ESlint 作为代码风格检查工具。不过现在 ESlint 也提供了TypeScript 类型检查功能，基本上 ESlint 能整合这两个功能。由于性能问题， TypeScript 也采用了 ESLint 作为 TSlint替代的检查工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SonarQube&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SonarQube 是一款用于代码质量管理的开源工具，它主要用于管理源代码的质量。 SonarQube 和上面的工具不太一样，SonarQube 设计目的是提供一个平台，通过插件的方式提供对各个语言进行支持，也可以和 checkstyle、pmd、simian 等工具进行集成。SonarQube 一般需要单独部署成一个服务，提供数据库，可以记录扫描结果等信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;npm audit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;npm audit 是 npm 6 之后的版本 自带的一个前端安全扫描工具，可以扫描 npm 依赖中的潜在的漏洞威胁。这些引入的漏洞可能威胁用户开发的机，另外也可能被带入 bundle 文件发布到线上，带来安全问题。目前 npm audit 会在 npm install 完成后自动执行，需要留意安全威胁报告。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fortify SCA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fortify SCA(Source Code Analyzer) 是一款非常优秀的代码安全扫描工具，用于分析代码中潜在的安全问题。通过调用语言的编译器或者解释器把代码（Java、C、C++等源代码）转换成一种中间媒体文件 NST（Normal Syntax Trcc），然后通过模式匹配相关的方式抓取存在于漏洞库中的漏洞。例如，上传的文件没有做检查等 XSS 攻击。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OWASP  Dependency-Track&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开放式 Web 应用程序安全项目（OWASP）是一个非营利组织，提供了很多安全标准、数据库、社区和培训。其中一个工具就是 OWASP  Dependency-Track，可以对第三方依赖包中的知名漏洞进行检查，扫描结果受到漏洞数据库的更新影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;archunit 架构规范检查&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面的检查是代码层面，archunit 可以用于代码架构检查，可以定义规则检查每个包中的实现是否符合规范。例如，controller 包中的类不能实现 service 的接口，repository 下的类必须实现 Repository 接口。通过 archunit 可以减少 codereview 的工作量，避免项目的结构被破坏。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/2-security-high-quality-code.jpg&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/2-security-high-quality-code-768x439.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;统计工具&lt;/h4&gt;
&lt;p&gt;sloccount、sourcemointor 这两个工具可以用于统计代码数量，包括行数、文件数、注释等。除了在项目中扫描 bug 之外，配置代码统计工具可以对项目有一个整体的认知。&lt;br/&gt;
其他的扫描工具还很多，例如 coverity、codemars、binscope、synk、appscan、retire.js 等工具，不再一一列举。&lt;/p&gt;
&lt;h4&gt;最佳搭配&lt;/h4&gt;
&lt;p&gt;这几款工具之间的功能有所重叠，在实际工作中，我们可以根据上面推荐的关注的点，重点清除这些问题。这些扫描工具全部用上除了会带来团队压力和维护成本之外，代码质量不会随着引入的插件增多。除开有质量团队的大厂提供这些扫描平台外，敏捷团队往往不会太大，团队持续关注一个精简的扫描组合更好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 后端&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;checkstyle&lt;/strong&gt; Java 代码风格守护，Java 项目至少应该配置一个默认的 checkstyle 规则。至少让项目干净，没有无用、重复的代码，以及超大的类和方法。建议做到每次提交代码前检查。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;findbugs&lt;/strong&gt; 常见不规范的代码检查，一些空指针、equals 检查非常有用，而且 IDE  的插件也很好用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;前端&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;eslint&lt;/strong&gt; 守护 JavaScript 代码风格，eslint 搭配一个 .editorconfig ，可以方便的让编辑器保持同 eslint 一致的代码风格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;npm audit&lt;/strong&gt; 项目中第三方包的威胁扫描，npm 自带无需额外安装，npm 6 以后自运行，需要关注并修复报出的安全问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;安全&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;fortify&lt;/strong&gt; 扫描代码中的漏洞，用它检查出来的大部分安全问题都是注入攻击、XSS 等攻击，这些问题明显可以在开发过程中避免。可以作为 Jenkins 插件配置，和单元测试作为同一阶段运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;OWASP 插件&lt;/strong&gt;  用来扫描第三方依赖漏洞，因为项目中的依赖不会像源代码一样频繁变化，推荐使用 Jekins 插件，定期执行即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为什么不用 SonarQube 呢，SonarQube 是一个非常优秀的代码质量开放平台，需要单独的配置安装，需要花费额外的时间维护，对于小团队来说成本较高，如果有专门的质量团队可以考虑维护一套。&lt;/p&gt;
&lt;h4&gt;常用代码质量指标参考&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编译告警数，大部分程序员基本上忽略 warning，但是编译器出现了告警是一种不好的体现，意味着软件可能工作，但是存在不好的实践，而这种不确定性，会带来不确定的 bug 最终让人一头雾水。编译过程中的告警，尽量消除掉，编译告警的值推荐消除到 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均函数代码行数，过大的函数会导致阅读困难，而且往往过大的函数职责不够单一，一般将一个方法代码行数控制到 30 - 50 行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均文件代码行，和平均函数代码行一样，过长的文件一样难以维护，一般一个文件10多个方法，因此文件的代码行数一般控制到 300 - 500 行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;冗余代码，有时候我们代码中可能存在未使用的方法、变量等代码，这让维护者一头雾水，通常需要清零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总文件重复率，出现重复文件的次数。除了编写单元测试的情况下，业务代码不应该出现重复代码，推荐值为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总代码重复度，代码的重复度检查，限于扫描工具的识别模式，需要有一定的容忍度，推荐值在 5% - 10%&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均函数圈复杂度，圈复杂度用来衡量一个模块判定结构的复杂程度。如果一个方法内部有大量的 if 语句嵌套，意味着这个方法的实现质量低下，且程序复杂度高不利于维护，推荐值小于 5%。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全告警，如果配置了安全扫描工具，例如 Fortify，安全威胁应该被清零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码缺陷，如果配置了缺陷扫描工具，例如 Findbugs，需要清零。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div id=&quot;attachment_12941&quot; class=&quot;wp-caption aligncenter&quot;&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/4-security-high-quality-code.png&quot;&gt;&lt;img aria-describedby=&quot;caption-attachment-12941&quot; src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/4-security-high-quality-code-768x798.png&quot; alt=&quot;常用代码质量指标参考&quot; class=&quot;size-medium_large wp-image-12941&quot; srcset=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/4-security-high-quality-code-768x798.png 768w, https://insights.thoughtworks.cn/wp-content/uploads/2020/09/4-security-high-quality-code-289x300.png 289w, https://insights.thoughtworks.cn/wp-content/uploads/2020/09/4-security-high-quality-code-986x1024.png 986w, https://insights.thoughtworks.cn/wp-content/uploads/2020/09/4-security-high-quality-code.png 1090w&quot; sizes=&quot;(max-width: 700px) 100vw, 700px&quot;/&gt;&lt;/a&gt;&lt;p id=&quot;caption-attachment-12941&quot; class=&quot;wp-caption-text&quot;&gt;常用代码质量指标参考&lt;/p&gt;&lt;/div&gt;
&lt;h3&gt;第三方依赖规范化&lt;/h3&gt;
&lt;p&gt;软件开发过程中，不可避免的需要引入第三方或者开源软件包作为库或者框架引入。“第三方” 其实不是一个软件工程术语，现今在软件行业里面的理解是：第一方为自研的软件，第二方为内部发布的软件，第三方为从社区或者外部商业途径引入的软件包。&lt;/p&gt;
&lt;p&gt;对于个人开发者而言，面向“搜索引擎”编程往往将来源不明的代码片段和程序包引入到项目中。对于企业来说，考虑到的不仅仅是功能是否能实现，还要考虑引入时带来的成本和问题，例如是否需要授权、开源协议是否合理、是否会带来安全威胁。&lt;/p&gt;
&lt;p&gt;企业对于第三方依赖的引入分为几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作为开发工具引入&lt;/strong&gt;，例如 gcc、Jenkins，基本没有开源协议问题，但是需要注意开发机、CI 会有安全风险。Jenkins 曾出现过漏洞，CI 服务器被当做远程矿机使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作为服务部署使用（SaaS&lt;/strong&gt;），部分开源协议会限制这种使用方式，第三方依赖的安全问题会威胁服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;通过软件包再发布&lt;/strong&gt;，大部分开源软件对这种使用方式有较多要求，例如 GPL 开源协议具有传染性，要求使用了 GPL 的项目也要开源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;拷贝源代码引入项目&lt;/strong&gt;，非常不推荐这种方式，尽量通过包管理的方式引入。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;引入第三方依赖需要充分考虑，尽可能最小成本的引入。在一个 React 的前端项目中，有不熟悉的工程师，为了使用一个简单的手风琴效果，引入了整套 bootstrap。不仅破坏了使用 React 的最佳实践，而且让输出的 bundle 文件大小激增数倍，造成首屏加载的性能问题。&lt;/p&gt;
&lt;h3&gt;常见商业友好的开源协议&lt;/h3&gt;
&lt;p&gt;商业用户常用的开源协议实际上只有6种左右，即 LGPL、Mozilla、GPL、BSD、MIT、Apache，另外还有极其宽松的 The Unlicense，但采用的开源软件不多。&lt;/p&gt;
&lt;p&gt;GitHub 提供了一个 license 清单的列表 &lt;a href=&quot;https://choosealicense.com/licenses/&quot;&gt;https://choosealicense.com/licenses/&lt;/a&gt;，&lt;br/&gt;
我根据开源协议的宽松程度，整理了一个列表，方便查看：&lt;/p&gt;
&lt;div id=&quot;attachment_12942&quot; class=&quot;wp-caption aligncenter&quot;&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/5-security-high-quality-code.png&quot;&gt;&lt;img aria-describedby=&quot;caption-attachment-12942&quot; src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/5-security-high-quality-code-768x872.png&quot; alt=&quot;开源协议&quot; class=&quot;size-medium_large wp-image-12942&quot; srcset=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/5-security-high-quality-code-768x872.png 768w, https://insights.thoughtworks.cn/wp-content/uploads/2020/09/5-security-high-quality-code-264x300.png 264w, https://insights.thoughtworks.cn/wp-content/uploads/2020/09/5-security-high-quality-code-902x1024.png 902w, https://insights.thoughtworks.cn/wp-content/uploads/2020/09/5-security-high-quality-code.png 988w&quot; sizes=&quot;(max-width: 700px) 100vw, 700px&quot;/&gt;&lt;/a&gt;&lt;p id=&quot;caption-attachment-12942&quot; class=&quot;wp-caption-text&quot;&gt;开源协议&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;几乎所有的开源协议有一个共同的注意事项：&lt;strong&gt;采用该开源协议的软件项目，不提供任何责任转移和质量保证&lt;/strong&gt;。也就是说采用开源软件造成的法律问题和开源项目无关，另外需要使用者承担因质量问题造成的所有后果。另外，除了引入的程序包之外，字体、图片、特效音、手册等媒体资源也算广义上的“软件”需要考虑开源协议和使用场景。&lt;/p&gt;
&lt;h3&gt;第三方依赖管理&lt;/h3&gt;
&lt;p&gt;对项目中出现的任何第三方依赖有效的管理有非常重要的意义，通过扫描工具，识别出项目中是否有源码、jar包、二进制文件是否来源于某个开源项目。&lt;/p&gt;
&lt;p&gt;任何的第三方软件需要申请入库管理（内部其他团队申请通过可以直接使用），质量团队对申请的软件进行评估：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是否有开源义务需要履行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引入的第三方依赖是否有 CVEs等漏洞&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三方开源软件是否仍然在维护&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;质量团队根据上面的一些条件，决定出申请的软件能否在项目中使用，允许被采用的软件会定义出优选级别，优先推荐团队使用较为优选的软件，并对项目整体的优选率有一定要求。如果项目中出现了无法识别的二进制文件、非约定目录下的代码片段，需要报备。通过良好的依赖管理和规范化，能减少不良第三方依赖的引入，让软件项目透明、可信。&lt;/p&gt;
&lt;p&gt;一些商业公司提供这些完整的服务，例如 fossid、blackduck、code-climate 等。&lt;/p&gt;
&lt;h3&gt;运维安全&lt;/h3&gt;
&lt;p&gt;大的软件公司，往往有一堆流程和要求。虽然一线开发对堡垒机、防火墙、各种安全规范显得不耐烦，但这些安全措施也在保护开发者。&lt;/p&gt;
&lt;h4&gt;防火墙用于环境隔离&lt;/h4&gt;
&lt;p&gt;往往开发者理解的防火墙用于防止网络入侵、审计、入侵检测等功能，除此之外，防火墙还可以用于各个环境的隔离。一般来说，企业对于生产环境的数据控制比较严格，不会将生产环境的权限交给团队所有开发者，但网络连接有可能疏漏。&lt;/p&gt;
&lt;p&gt;曾经出现过一次线上事故，由于配置文件错误，将原本应该连接到测试的数据库连接到了生产环境，造成大量脏数据写入。如果通过防火墙规则对各个环境进行隔离，这类问题将不会出现。&lt;/p&gt;
&lt;p&gt;另外也可以设计 DMZ 区，将面向用户侧的网关部署到 DMZ 区，仅仅开放必要的端口给网关，实现内外网的物理隔离。同时，对整个系统的防火墙策略应该清晰地记录，否则在做大的基础设施更新时，梳理出所有的防火墙策略，是一件比较困难的事情。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/6-security-high-quality-code.jpg&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2020/09/6-security-high-quality-code-768x363.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;凭据管理&lt;/h4&gt;
&lt;p&gt;项目中会用到大量的凭据，例如数据库、第三方系统对接的 key，使用明文不是一件好事。理想的情况下，对项目中所有的密码信息进行掩盖(mask)，避免 CI、日志中敏感信息的泄露。&lt;/p&gt;
&lt;p&gt;有很多种方法可以掩盖项目中的密码信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用环境变量对密码信息进行覆盖。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用Spring boot 的项目可以配置 jasypt，使用 jasypt 将密码加密，将生成的加密串配置 ENC(加密串) 到工程的配置文件中。加密过程可以加盐作为解密的凭据，“盐” 可以不存放到工程中，在工程部署的时候注入即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果使用 Jenkins 等 CI/CD 工具，可以使用构建平台提供的凭证管理工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果使用 Spring cloud，可以使用 spring cloud vault 组件部署一个凭证管理服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，建议不要用任何个人凭据用作系统对接，应该使用一个公共的应用凭据。&lt;/p&gt;
&lt;h4&gt;堡垒机&lt;/h4&gt;
&lt;p&gt;一般来说我们管理服务器，所有的运维操作需要通过堡垒机进行操作。开放 22 等高危端口，允许开发者直接登录到服务器是一种不安全的做法。&lt;/p&gt;
&lt;p&gt;堡垒机，通俗的来说是跳板机 + 监控。最初使用的跳板机配置了两张网卡，用于连接开发环境和生产环境，并没有监控功能。在此基础上，堡垒机增加了统一运维管理的功能，往往需要两步验证（SMS 或 Email），并对所有的操作进行记录和监控。&lt;/p&gt;
&lt;p&gt;在需要团队参与运维工作的场景中，非常有必要部署一套堡垒机服务，并使用 LDAP 对接到团队成员的 ID 上，便于集中运维管理。&lt;/p&gt;
&lt;h4&gt;定期对系统软件扫描&lt;/h4&gt;
&lt;p&gt;Linux 系统往往有云厂商推送安全补丁和风险提示，但是安装到服务器上的软件，例如 JDK、nodejs，需要自己检查安全问题。因此需要在系统中安装并定期运行 CVEs 检查并及时更新。有一款 cvechecker 可以帮助运维人员，编写一个脚本定期运行 cvechecker  检查系统中已知的软件是否存在 CVEs 漏洞，并提醒开发者及时更新。&lt;/p&gt;
&lt;h3&gt;写在后面&lt;/h3&gt;
&lt;p&gt;刚开始工作时候，喜欢动态的、灵活的编程语言，讨厌的死板的、套路化的编程语言，然而需要很长一段时间，才能意识到 “约束是程序员的朋友”。对一些安全知识了解的来源大多来自修复 SonarQube 的经历，使用 findbugs 也让我对 Java 基础认识的更加深刻。&lt;/p&gt;
&lt;p&gt;类似的，在使用一些框架、平台的时候往往存在大量的限制，有时候开发者难以意识到 “限制” 正是框架、平台的作者 “保护” 应用开发者的一种方式。有一些开发者以 Hack 框架、平台为乐，但是这样会带来潜在的隐患，在用户量上来之后负面效应表现的尤为明显。&lt;/p&gt;
&lt;p&gt;项目的规范化对于 Tech Lead来说可以减少程序的运行事故和 codereview 时间，对于团队来说也许可以少加班吧。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;更多精彩洞见，请关注微信公众号：ThoughtWorks洞见&lt;/strong&gt;&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>