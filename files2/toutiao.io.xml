<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>74ac97a80f1c58ba45a80842d2e3896a</guid>
<title>MySQL 索引连环 18 问</title>
<link>https://toutiao.io/k/x7420rp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-topic-des nc-post-content&quot;&gt;
&lt;p&gt;MySQL作为互联网中非常热门的数据库，现在大厂面试题横竖绕不开MySQL，其中MySQL索引是大厂必考面试题。今天带来了MySQL索引的常考面试题，看看你能答对多少~ &lt;/p&gt; 
&lt;p&gt;这是本期的MySQL索引面试题目录，不会的快快查漏补缺~&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;目录&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752025/image-20210411230042052.png&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;1. 索引是什么？&lt;/h2&gt; 
&lt;p&gt;索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;索引是一种数据结构。数据库索引，是数据库管理系统中一个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。而且索引是一个文件，它是要占据物理空间的。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。&lt;/p&gt; 
&lt;h2&gt;2. 索引有哪些优缺点？&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;索引的优点&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 &lt;/li&gt;
 &lt;li&gt;通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;索引的缺点&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率； &lt;/li&gt;
 &lt;li&gt;空间方面：索引需要占物理空间。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;3. MySQL有哪几种索引类型？&lt;/h2&gt; 
&lt;p&gt;1、从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，&lt;/p&gt; 
&lt;p&gt;2、从应用层次来分：普通索引，唯一索引，复合索引。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;普通索引：即一个索引只包含单个列，一个表可以有多个单列索引&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;唯一索引：索引列的值必须唯一，但允许有空值&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;非聚簇索引： 不是聚簇索引，就是非聚簇索引&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;3、根据中数据的物理顺序与键值的逻辑（索引）顺序关系： 聚集索引，非聚集索引。&lt;/p&gt; 
&lt;h2&gt;4. 说一说索引的底层实现？&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;Hash索引&lt;/strong&gt; &lt;/p&gt; 
&lt;p&gt;&lt;span&gt;基于&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;哈希表&lt;/a&gt;实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;图片来源：&lt;a href=&quot;https://www.javazhiyin.com/40232.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.javazhiyin.com/40232.html&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752261/image-20210411215012443.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;B-Tree索引&lt;/strong&gt;（MySQL使用B+Tree）&lt;/p&gt; 
&lt;p&gt;B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752112/image-20210411215023820.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;B+Tree索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。&lt;/p&gt; 
&lt;p&gt;B+tree性质：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;B+ 树中，数据对象的插入和删除仅在叶节点上进行。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752195/image-20210411215044332.png&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span&gt;5. 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;二叉树&lt;/a&gt;，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;？&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;B-tree： 从两个方面来回答&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B(B-)树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对&lt;code&gt;IO读写次数就降低&lt;/code&gt;了。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在&lt;code&gt;区间查询&lt;/code&gt;的情况，所以通常B+树用于数据库索引。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;Hash： &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;虽然可以快速定位，但是没有顺序，IO复杂度高；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;基于Hash表实现，只有Memory存储引擎显式支持哈希索引 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;适合&lt;strong&gt;等值查询&lt;/strong&gt;，如=、in()、&amp;lt;=&amp;gt;，不支持范围查询 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成&lt;a target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;排序&lt;/a&gt; ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;Hash索引在查询等值时非常快 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;因为Hash索引始终索引的&lt;strong&gt;所有列的全部内容&lt;/strong&gt;，所以不支持部分索引列的匹配查找 ；&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;二叉树&lt;/a&gt;： 树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;： 树的高度随着数据量增加而增加，IO代价高。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;6. 讲一讲聚簇索引与非聚簇索引？&lt;/h2&gt; 
&lt;p&gt;在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。&lt;/p&gt; 
&lt;p&gt;而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引、二级索引。&lt;/p&gt; 
&lt;p&gt;聚簇索引与非聚簇索引的区别：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号） &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为&lt;strong&gt;回表&lt;/strong&gt;。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可 &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;7. 非聚簇索引一定会回表查询吗？&lt;/h2&gt; 
&lt;p&gt;不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为&quot;覆盖索引&quot;。&lt;/p&gt; 
&lt;p&gt;举个简单的例子，假设我们在学生表的成绩上建立了索引，那么当进行&lt;code&gt;select score from student where score &amp;gt; 90&lt;/code&gt;的查询时，在索引的叶子节点上，已经包含了score 信息，不会再次进行回表查询。&lt;/p&gt; 
&lt;h2&gt;8. 联合索引是什么？为什么需要注意联合索引中的顺序？&lt;/h2&gt; 
&lt;p&gt;MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。&lt;/p&gt; 
&lt;p&gt;具体原因为:&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;MySQL使用索引时需要索引有序，假设现在建立了&quot;name，age，school&quot;的联合索引，那么索引的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;为: 先按照name&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;，如果name相同，则按照age&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;，如果age的值也相等，则按照school进行&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。&lt;/p&gt; 
&lt;h2&gt;9. 讲一讲MySQL的最左前缀原则?&lt;/h2&gt; 
&lt;p&gt;最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。&lt;br/&gt;mysql会一直向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &amp;gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。&lt;/p&gt; 
&lt;p&gt;=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。&lt;/p&gt; 
&lt;h2&gt;10. 讲一讲前缀索引？&lt;/h2&gt; 
&lt;p&gt;因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，order by不支持前缀索引 。&lt;/p&gt; 
&lt;p&gt; 流程是： &lt;/p&gt; 
&lt;p&gt; 先计算完整列的选择性 :&lt;code&gt;select count(distinct col_1)/count(1) from table_1&lt;/code&gt;&lt;/p&gt; 
&lt;p&gt; 再计算不同前缀长度的选择性 :&lt;code&gt;select count(distinct left(col_1,4))/count(1) from table_1&lt;/code&gt;&lt;/p&gt; 
&lt;p&gt; 找到最优长度之后，创建前缀索引 :&lt;code&gt;create index idx_front on table_1 (col_1(4))&lt;/code&gt;&lt;/p&gt; 
&lt;h2&gt;11. 了解索引下推吗？&lt;/h2&gt; 
&lt;p&gt;MySQL 5.6引入了索引下推优化。默认开启，使用SET optimizer_switch = ‘index_condition_pushdown=off’;可以将其关闭。 &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;有了索引下推优化，可以在&lt;strong&gt;减少回表次数&lt;/strong&gt; &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;在InnoDB中只针对二级索引有效&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;官方文档中给的例子和解释如下：&lt;/p&gt; 
&lt;p&gt;在 people_table中有一个二级索引(zipcode，lastname，address)，查询是SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’; &lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;如果没有使用索引下推技术，则MySQL会通过zipcode=’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断数据是否符合条件 &lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=’95054’的索引，然后根据lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;12. 怎么查看MySQL语句有没有用到索引？&lt;/h2&gt; 
&lt;p&gt;通过explain，如以下例子：&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&#x27;10001&#x27; AND title=&#x27;Senior Engineer&#x27; AND from_date=&#x27;1986-06-26&#x27;;&lt;/code&gt;&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;id&lt;/th&gt; 
   &lt;th&gt;select_type&lt;/th&gt; 
   &lt;th&gt;table&lt;/th&gt; 
   &lt;th&gt;partitions&lt;/th&gt; 
   &lt;th&gt;type&lt;/th&gt; 
   &lt;th&gt;possible_keys&lt;/th&gt; 
   &lt;th&gt;key&lt;/th&gt; 
   &lt;th&gt;key_len&lt;/th&gt; 
   &lt;th&gt;ref&lt;/th&gt; 
   &lt;th&gt;filtered&lt;/th&gt; 
   &lt;th&gt;rows&lt;/th&gt; 
   &lt;th&gt;Extra&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt;
  &lt;tr&gt; 
   &lt;td&gt;1&lt;/td&gt; 
   &lt;td&gt;SIMPLE&lt;/td&gt; 
   &lt;td&gt;titles&lt;/td&gt; 
   &lt;td&gt;null&lt;/td&gt; 
   &lt;td&gt;const&lt;/td&gt; 
   &lt;td&gt;PRIMARY&lt;/td&gt; 
   &lt;td&gt;PRIMARY&lt;/td&gt; 
   &lt;td&gt;59&lt;/td&gt; 
   &lt;td&gt;const,const,const&lt;/td&gt; 
   &lt;td&gt;10&lt;/td&gt; 
   &lt;td&gt;1&lt;/td&gt; 
   &lt;td/&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt;
&lt;/table&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;id：在⼀个⼤的查询语句中每个&lt;strong&gt;SELECT&lt;/strong&gt;关键字都对应⼀个唯⼀的id ，如explain select * from s1 where id = (select id from s1 where name = &#x27;egon1&#x27;);第一个select的id是1，第二个select的id是2。有时候会出现两个select，但是id却都是1，这是因为优化器把子查询变成了连接查询 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;select_type：select关键字对应的那个查询的类型，如SIMPLE,PRIMARY,SUBQUERY,DEPENDENT,SNION 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;table：每个查询对应的表名 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;type：&lt;code&gt;type&lt;/code&gt; 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 &lt;code&gt;type&lt;/code&gt; 字段, 我们判断此次查询是 &lt;code&gt;全表扫描&lt;/code&gt; 还是 &lt;code&gt;索引扫描&lt;/code&gt; 等。如const(主键索引或者唯一二级索引进行等值匹配的情况下),ref(普通的⼆级索引列与常量进⾏等值匹配),index(扫描全表索引的覆盖索引) 。&lt;/p&gt; &lt;p&gt;通常来说, 不同的 type 类型的性能关系如下:&lt;br/&gt;&lt;code&gt;ALL &amp;lt; index &amp;lt; range ~ index_merge &amp;lt; ref &amp;lt; eq_ref &amp;lt; const &amp;lt; system&lt;/code&gt;&lt;br/&gt;&lt;code&gt;ALL&lt;/code&gt; 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.&lt;br/&gt;而 &lt;code&gt;index&lt;/code&gt; 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;possible_key：查询中可能用到的索引&lt;em&gt;(可以把用不到的删掉，降低优化器的优化时间)&lt;/em&gt; 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;key：此字段是 MySQL 在当前查询时所真正使用到的索引。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;filtered：查询器预测满足下一次查询条件的百分比 。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.&lt;br/&gt;这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;extra：表示额外信息，如Using where,Start temporary,End temporary,Using temporary等。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;13. 为什么官方建议使用自增长主键作为索引？&lt;/h2&gt; 
&lt;p&gt;结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。&lt;/p&gt; 
&lt;p&gt;插入连续的数据：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;图片来自：&lt;a href=&quot;https://www.javazhiyin.com/40232.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.javazhiyin.com/40232.html&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752160/java10-1562726251.gif&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;插入非连续的数据：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752674/java8-1562726251.gif&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;14. 如何创建索引？&lt;/h2&gt; 
&lt;p&gt;创建索引有三种方式。&lt;/p&gt; 
&lt;p&gt;1、 在执行CREATE TABLE时创建索引&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-sql&quot; from-niu=&quot;default&quot;&gt;CREATE TABLE user_index2 (
    id INT auto_increment PRIMARY KEY,
    first_name VARCHAR (16),
    last_name VARCHAR (16),
    id_card VARCHAR (18),
    information text,
    KEY name (first_name, last_name),
    FULLTEXT KEY (information),
    UNIQUE KEY (id_card)
);
&lt;/pre&gt; 
&lt;p&gt;2、 使用ALTER TABLE命令去增加索引。&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-sql&quot; from-niu=&quot;default&quot;&gt;ALTER TABLE table_name ADD INDEX index_name (column_list);&lt;/pre&gt; 
&lt;p&gt;ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。&lt;/p&gt; 
&lt;p&gt;其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。&lt;/p&gt; 
&lt;p&gt;索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。&lt;br/&gt;3、 使用CREATE INDEX命令创建。&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-sql&quot; from-niu=&quot;default&quot;&gt;CREATE INDEX index_name ON table_name (column_list);&lt;/pre&gt; 
&lt;h2&gt;15. 创建索引时需要注意什么？&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值； &lt;/li&gt;
 &lt;li&gt;取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高； &lt;/li&gt;
 &lt;li&gt;索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;16. 建索引的原则有哪些？&lt;/h2&gt; 
&lt;p&gt;1、最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &amp;gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。&lt;/p&gt; 
&lt;p&gt;2、=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。&lt;/p&gt; 
&lt;p&gt;3、尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。&lt;/p&gt; 
&lt;p&gt;4、索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。&lt;/p&gt; 
&lt;p&gt;5、尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。&lt;/p&gt; 
&lt;h2&gt;17. 使用索引查询一定能提高查询的性能吗？&lt;/h2&gt; 
&lt;p&gt;通常通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。&lt;/p&gt; 
&lt;p&gt;索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的I* NSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;基于一个范围的检索，一般查询返回结果集小于表中记录数的30%。 &lt;/li&gt;
 &lt;li&gt;基于非唯一性索引的检索。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;18. 什么情况下不走索引（索引失效）？&lt;/h2&gt; 
&lt;h5&gt;1、使用!= 或者 &amp;lt;&amp;gt; 导致索引失效&lt;/h5&gt; 
&lt;h5&gt;2、类型不一致导致的索引失效&lt;/h5&gt; 
&lt;h5&gt;3、函数导致的索引失效&lt;/h5&gt; 
&lt;p&gt;如：&lt;/p&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE DATE(create_time) = &#x27;2020-09-03&#x27;;&lt;/pre&gt;
&lt;p&gt;如果你的索引字段使用了函数，对不起，他是真的不走索引的。&lt;/p&gt; 
&lt;h5&gt;4、运算符导致的索引失效&lt;/h5&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE age - 1 = 20;&lt;/pre&gt;
&lt;p&gt;如果你对列进行了（+，-，*，/，!）, 那么都将不会走索引。&lt;/p&gt; 
&lt;h5&gt;5、OR引起的索引失效&lt;/h5&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE `name` = &#x27;张三&#x27; OR height = &#x27;175&#x27;;&lt;/pre&gt;
&lt;p&gt;OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。&lt;/p&gt; 
&lt;h5&gt;6、模糊搜索导致的索引失效&lt;/h5&gt; 
&lt;pre class=&quot;prettyprint&quot; from-niu=&quot;default&quot;&gt;SELECT * FROM `user` WHERE `name` LIKE &#x27;%冰&#x27;;&lt;/pre&gt;
&lt;p&gt;当&lt;code&gt;%&lt;/code&gt;放在匹配字段前是不走索引的，放在后面才会走索引。&lt;/p&gt; 
&lt;h5&gt;7、NOT IN、NOT EXISTS导致索引失效&lt;/h5&gt; 
&lt;h2 id=&quot;end&quot;&gt;End&lt;/h2&gt; 
&lt;p&gt;整理不易，点个赞呗！&lt;/p&gt; 
&lt;h2&gt;巨人的肩膀&lt;/h2&gt; 
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ThinkWon/article/details/104778621&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://blog.csdn.net/ThinkWon/article/details/104778621&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.javazhiyin.com/40232.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.javazhiyin.com/40232.html&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844904039860142088&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://juejin.cn/post/6844904039860142088&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ThinkWon/article/details/104778621&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://blog.csdn.net/ThinkWon/article/details/104778621&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008131735&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://segmentfault.com/a/1190000008131735&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d11ff44c280e28f1b108aedebe8624a2</guid>
<title>[推荐] 携程最终一致和强一致性缓存实践</title>
<link>https://toutiao.io/k/nvmnd0f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:0.title1&quot;&gt;&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;GSF，携程高级技术专家，关注高可用、高并发系统建设，致力于用技术驱动业务。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;一、前言&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程金融从成立至今，整体架构经历了从0到1再到10的变化，其中有多个场景使用了缓存来提升服务质量。从系统层面看，使用缓存的目的无外乎缓解DB压力（主要是读压力），提升服务响应速度。引入缓存，就不可避免地引入了缓存与业务DB数据的一致性问题，而不同的业务场景，对数据一致性的要求也不同。本文将从以下两个场景介绍我们的一些缓存实践方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：我们DB用的是MySQL，缓存介质用的是携程高可用Redis服务，存储介质的选型及存储服务的高可用不是本文重点，后文也不再做特别说明。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;二、最终一致性分布式缓存场景&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2.1 场景描述&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过几年演进，携程金融形成了自顶向下的多层次系统架构，如业务层、平台层、基础服务层等，其中用户信息、产品信息、订单信息等基础数据由基础平台等底层系统产生，服务于所有的金融系统，对这部分基础数据我们引入了统一的缓存服务（系统名utag），缓存数据有三大特点：全量、准实时、永久有效，在数据实时性要求不高的场景下，业务系统可直接调用统一的缓存查询接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的典型使用场景有：风控流程、APP入口信息提示等，而对数据一致性要求高的场景依然需要走实时的业务接口查询。引入缓存前后系统架构对比如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cQzdDVSm0jV87CjsyvX1dq6G3wyHYyH4YsN0ICytVicNlYFX8amhZnyicNAygAuZMtTGe71VpbGL5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;统一缓存服务的构建给部门的整体系统架构带来了一些优势：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对业务系统：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;对基础服务：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;整体而言，缓存服务处于中间层，数据的写入方和数据查询方解耦，数据甚至可以在底层系统不感知的情况下写入（见下文），而数据使用方的查询也可在底层服务不可用或“堵塞”时候仍然保持可用（前提是缓存服务是可用的，而缓存服务的处理逻辑简单、统一且有多种手段保证，其可用性比单个子系统都高），整体上服务的稳定性得到了提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在构建此统一缓存服务时候，有三个关键目标：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据准确性：DB中单条数据的更新一定要准确同步到缓存服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据完整性：将对应DB表的全量数据进行缓存且永久有效，从而可以替代对应的DB查询。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;系统可用性：我们多个产品线的多个核心服务都已经接入，utag的高可用性显的尤为关键。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来先说明统一缓存服务的整体方案，再逐一介绍此三个关键特性的设计实现方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2.2 整体方案&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;我们的系统在多地都有部署，故缓存服务也做了相应的异地多机房部署，一来可以让不同地区的服务调用本地区服务，无需跨越网络专线，二来也可以作为一种灾备方案，增加可用性。&lt;/h3&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于缓存的写入，由于缓存服务是独立部署的，因此需要感知业务DB数据变更然后触发缓存的更新，本着“可以多次更新，但不能漏更新”的原则，我们设计了多种数据更新触发源：定时任务扫描，业务系统MQ、binlog变更MQ，相互之间作为互补来保证数据不会漏更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外为了缓存更新流程的统一和与触发源的解耦，我们使用MQ来驱动多地多机房的缓存更新，在不同的触发源触发后，会查询最新的DB数据，然后发出一个缓存更新的MQ消息，不同地区机房的缓存系统同时监听该主题并各自进行缓存的更新。对于MQ我们使用携程开源消息中间件QMQ 和 Kafka，在公司内部QMQ和Kafka也做了异地机房的互通。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于缓存的读取，utag系统提供dubbo协议的缓存查询接口，业务系统可调用本地区的接口，省去了网络专线的耗时（50ms延迟）。在utag内部查询redis数据，并反序列化为对应的业务model，再通过接口返回给业务方。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了描述方便，以下异地多机房部署统一使用AB两地部署的概念进行说明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体框架如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.434375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cQzdDVSm0jV87CjsyvX1dqZxgdChGjkglNX2bdaY3KWGZLXYu8yw8MWdQDz9C8gfLIhKPCjR3nag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;接下来介绍一下几个关键点的设计 。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2.3  数据准确性设计&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同的触发源，对缓存更新过程是一样的，整个更新步骤可抽象为4步：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;step1：触发更新，查询DB中的新数据，并发送统一的MQ&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;step2：接收MQ，查询缓存中的老数据&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;step3：新老数据对比，判断是否需要更新&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;step4：若需要，则更新缓存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于我们业务的大部分核心系统和所有的DB都在A地机房，所以触发源（如binlog的消费、业务MQ的接收、扫表任务的执行）都在A侧，触发更新后，第一步查询DB数据也只能在A侧查询（避免跨网络专线的数据库连接，影响性能）。查询到新数据后，发送更新缓存的MQ，两地机房的utag服务进行消费，之后进行统一的缓存更新流程。总体的缓存更新方案如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.24765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cQzdDVSm0jV87CjsyvX1dqbEKRHU1XBjvibPRFOdHibroiau3YDLuL1ia4S3UIX2vqBexgykjSgOFjTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于有多个触发源，不同的触发源之间可能会对同一条数据的缓存更新请求出现并发，此外可能出现同一条数据在极短时间内（如1秒内）更新多次，无法区分数据更新顺序，因此需要做两方面的操作来确保数据更新的准确性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）并发控制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若一条DB数据出现了多次更新，且刚好被不同的触发源触发，更新缓存时候若未加控制，可能出现数据更新错乱，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.20859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6ka2RxW76IBUXLWZsrkCfHNG1auzKDKYwGQTe0lib0lXKJBZVibdD2w3Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;故需要将第2、3、4步加锁，使得缓存刷新操作全部串行化。由于utag本身就依赖了redis，此处我们的分布式锁就基于redis实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）基于updateTime的更新顺序控制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即使加了锁，也需要进一步判断当前db数据与缓存数据的新老，因为到达缓存更新流程的顺序并不代表数据的真正更新顺序。我们通过对比新老数据的更新时间来实现数据更新顺序的控制。若新数据的更新时间大于老数据的更新时间，则认为当前数据可以直接写入缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们系统从建立之初就有自己的MySQL规范，每张表都必须有update_time字段，且设置为ON UPDATE CURRENT_TIMESTAMP，但是并没有约束时间字段的精度，大部分都是秒级别的，因此在同一秒内的多次更新操作就无法识别出数据的新老。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对同一秒数据的更新策略我们采用的方案是：先进行数据对比，若当前数据与缓存数据不相等，则直接更新，并且发送一条延迟消息，延迟1秒后再次触发更新流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举个例子：假设同一秒内同一条数据出现了两次更新，value=1和value=2，期望最终缓存中的数据是value=2。若这两次更新后的数据被先后触发，分两种情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1680064308681672&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kfTib68l3Ddht8K0UFPzQkicv6wfcFILJF76HBaKy1mfAjib2gxaX1a1Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1244&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过以上方案我们可以确保缓存数据的准确性。有几个点需要额外说明：  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实不用延迟消息也是可以的，毕竟DB数据的更新时间是不变的，但是考虑到出现同一秒更新的可能是高频更新场景，若直接发消息，然后立即消费并触发二次更新，可能依然查到同一秒内更新的其他数据，为减少此种情况下的多次循环更新，延迟几秒再刷新可作为一种优化策略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为删除操作和update操作无法进行数据对比，无法确定操作的先后顺序，进而可能导致更新错乱。而在数据异常宝贵的时代，一般的业务系统中也没有物理删除的逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以将查DB、查缓存、数据对比、更新缓存这四个步骤全部放到锁的范围内，这样就不需要处理同一秒的顺序问题。因为在这个串行化操作中每次都从DB中查询到了最新的数据，可以直接更新，而时间的判断、值的判断可以作为优化操作，减少缓存的更新次数，也可以减少锁定的时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而我们为何不采用该方案？因为查询DB的操作我们只能在一侧机房处理，无法让AB两地系统的更新流程统一，也就降低了二者互备的可能性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2.4  数据完整性设计&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述数据准确性是从单条数据更新角度的设计，而我们构建缓存服务的目的是替代对应DB表的查询，因此需要缓存对应DB表的全量数据，而数据的完整性从以下三个方面得到保证：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）“把鸡蛋放到多个篮子里”，使用多种触发源（定时任务，业务MQ，binglog MQ）来最大限度降低单条数据更新缺失的可能性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;单一触发源有可能出现问题，比如消息类的触发依赖业务系统、中间件canel、中间件QMQ和Kafka，扫表任务依赖分布式调度平台、MySQL等。中间任何一环都可能出现问题，而这些中间服务同时出概率的可能相对来说就极小了，相互之间可以作为互补。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）全量数据刷新任务：全表扫描定时任务，每周执行一次来进行兜底，确保缓存数据的全量准确同步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）数据校验任务：监控Redis和DB数据是否同步并进行补偿。   &lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2.5  系统可用性设计&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;统一缓存服务被多个业务线的核心系统所依赖，所以缓存服务的高可用是至关重要的。而对高可用的建设，除了集群部署、容量规划、熔断降级等常用手段外，针对我们自己的场景也做了一些方案。主要有以下三点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）异地机房互备&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上所述，我们的服务在AB两地部署，两机房的缓存通过两地互通的MQ同时写入。在这套机制下，本地区的业务系统可以直接读取本地区的缓存，如果出现了本地区utag应用异常或redis服务异常，则可以快速降级到调用另外机房的服务接口。具体方案如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.57265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cQzdDVSm0jV87CjsyvX1dqMnBSyTVfyyg70GAnrBEphhoBwiaofnMAVywNUmrCDz2mhrDL2Gkn3og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本地业务系统通过dubbo调用本地的utag服务，在utag的本地处理流程中，查询本地缓存前后分别可根据一定的条件进行服务降级，即查询另一机房。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了避免循环调用，在降级调用前，需要判断当前请求是否来自本地，而此功能通过Dubbo的RpcContext透传特定标识来实现。除此之外，还建立了两机房的应用心跳，来辅助切换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kN6bU5TCvYGhU2EP9utQ1L3NOBSkwWP8AibZuLt0BJtbHrrBaE3ykurQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）QMQ和Kafka互备&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缓存更新流程通过MQ来驱动，虽然公司的MQ中间件服务由专人维护，但是万一出现问题长时间不能恢复，对我们来说将是致命的。所以我们决定同时采用Kafka和QMQ两种中间件来作为互备方案。默认情况下对于全表扫描任务和binlog消费这类大批量消息场景使用Kafka来驱动，而其他场景通过QMQ来驱动。所有的场景都可以通过开关来控制走Kafka或者QMQ。目前该功能可通过配置管理平台来实现快速切换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）快速恢复&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在极端情况下，可能出现Redis数据丢失的情况，如主机房（A机房）突然断网，redis集群切换过程出现数据丢失或同步错乱，此时很可能无法通过自动触发来补齐数据，因此设计了全表快速扫描的补偿机制，通过多任务并行调度，可在30分钟内将全量数据完成刷新。此功能需要人工判断并触发。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2.6 总结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上介绍了我们最终一致性分布式缓存服务的设计思路和要点，其中的关键点为数据准确性、数据完整性、系统可用性的设计。除此之外，还有一些优化点如降级方案的自动触发、异地机房缓存之间、缓存与DB之间做旁路数据diff，可进一步确保缓存服务整体的健壮性，在后续的版本中进行迭代。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;三、强一致性分布式缓存场景&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.1 场景描述&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;强一致性分布式缓存目前主要应用在我们携程金融的消金贷前服务中。随着我们用户量和业务量的增涨，贷前服务的查询量激增，给数据库带来了很大的压力，解决此问题有几种可选方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）分库分表：成本和复杂度相对较高，我们场景下只是数据查询流量较大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）读写分离：出于数据库性能考虑，我们的MySQL大部分采用异步复制的方式，而由于我们的场景对数据实时性要求较高，因此无法直接利用读写分离的优势来分担主库压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综合来看，增加缓存是更加合适的方案，我们决定设计一套高可用的满足强一致性要求的分布式缓存。接下来介绍我们的具体设计实现方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.2 整体方案&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缓存的处理我们采用了较为常见的处理思路：在更新操作中，先更新数据库，再删除缓存，查询操作中，触发缓存更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3497164461247637&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kqDF2emTIUY3df2B0ibAA4MRpibmL8dYm2VrVqA2vIWUtVq4sbgvpnLew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在此过程中，若不加控制，则会存在数据不一致性问题，主要是由于缓存操作和DB更新之间的并发导致的。具体分析如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）缓存读取和DB更新并发&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示，查询时候若缓存已经存在，则会直接返回缓存数据。若查询缓存的操作，发生在“更新DB数据”和“删除缓存”之间，则本次查询到数据为缓存中的老数据，导致不一致。当然下次查询可能就会查询到最新的数据。这种并发在我们服务中是存在的，比如某个产品开通后，会在更新DB（产品开通状态）后立即发送MQ（事务型消息）告知业务，业务侧处理流程中会立即发起查询操作。此场景中数据库的更新和数据的查询间隔极短，很容易出现此种并发问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.38515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6ka3hvMuBHXJATPeIlfnWnAvVbY9O13mVjaFm5BQf61bYBE7sAUoYp9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）缓存更新与DB更新并发&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示，查询的时候，若缓存不存在，则更新缓存，流程是先查询DB再更新Redis。若更新缓存时候，出现以下时序：查询DB老数据（T0时刻，DB中value=1）→ 更新DB（T1时刻，更新DB为value=2）→ 删除Redis（T2）→ 更新Redis（T3），则会导致本次查询返回数据及缓存中的数据与DB数据不一致，即接口返回和更新后的缓存都为脏数据。若T2和T3互换，即更新DB后，先更新Redis，再删除Redis ，由于缓存被删除在下次更新可能会被正确更新，但本次返回数据依然与DB更新后的数据不一致。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.32421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kJhHvrn84jZkXPHEic6uj2hYngfbAlZx5LOMsWiazD6auRjnjgGWzj54Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于以上分析，为了避免并发带来的缓存不一致问题，需要将&quot;更新DB&quot;+&quot;删除缓存&quot;、&quot;查询DB&quot;+&quot;更新缓存&quot;两个流程都进行加锁。此处需要加的是分布式锁，我们使用的是redis分布式锁实现。加锁后的读写整体流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kpGC0WQbFQ9GTLs1n44GpgzWpFR48pPrvYE5NtwXoNyxhDy8c05NAnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，有两处加锁，更新DB时加锁，锁范围为&quot;更新DB&quot;+&quot;删除cache&quot;（图中lock1），更新缓存时加锁，锁范围为&quot;查询DB&quot; + &quot;更新cache&quot;（图中lock2），两处对应的锁key是相同的。基于此方案，对于上面所说的两种并发场景，做针对性分析如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）缓存查询和DB更新的并发控制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查询操作流程中，先判断lock是否存在，若存在，则表示当前DB或缓存正在更新，不能直接查询缓存，在查询DB后返回数据。之所以这么做，还是由场景决定的，如前文所述，我们场景下的基本处理思路是，缓存仅作为“DB降压”的辅助手段，在不确定缓存数据是否最新的情况下，宁可多查询几次DB，也不要查询到缓存中的不一致数据。此外，更新操作相对于查询操作是很少的，在我们贷前服务中，读写比例约为8:1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此处另外的一个可行方案是可在检测到有锁后可进行短暂的等待和重试，好处是可进一步增加缓存的命中率，但是多一次锁等待，可能会影响到查询接口的性能。可根据自身场景进行抉择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，为了进行降级，在锁判断前也增加了降级开关判断，若降级开关开启，也会直接查询DB。而降级主要是由于redis故障引起的，下文详述。若检测是否有锁时发生了异常同样也会直接查询DB。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）缓存更新和DB更新的并发控制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查询操作流程中，若缓存不存在，则进行缓存的更新，在更新时候先尝试进行加锁，若当前有锁说明当前有DB或缓存正在更新，则进行等待和重试，从而可避免查询到DB中的老数据更新到缓存中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中lock2的流程（load cache），我们是同步进行的。另外一个可行的方案是，异步发起缓存的加载，可减少锁等待时间，但是若出现瞬时的高并发查询，可能缓存无法及时加载产生从而频繁产生瞬时压力。可根据自身场景进行抉择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上为我们的整体设计思路，接下来从实现的角度分别描述一下基于本地消息表的缓存删除策略，缓存的降级和恢复这两个方面的具体方案。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.3 缓存删除策略&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在更新操作中，在锁的范围内，先更新DB，再删除缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中锁的选型，我们采用与缓存同介质的redis分布式锁，这样做的好处是若因为redis服务不可用导致的锁处理失败，对于缓存本身也就不可用，可以自动走降级方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，更新流程还要考虑两点：锁的范围和删除缓存失败后如何补偿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）锁粒度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更新操作中加锁粒度有以下三种方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案一：事务提交后加锁，只锁定删除缓存操作。对原事务无任何额外影响，但是在事务提交后到删除缓存之间存在与查询的并发可能性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案二：在事务提交前加锁，删除缓存后解锁。在满足一致性要求的前提下，锁的粒度可以做到最小，但是增加了DB事务的范围，若redis出现超时则可能导致事务时间拉长，进而影响DB操作性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案三：在事务开始前加锁，删除缓存后解锁。锁的范围较大，但是能满足我们一致性要求，对单个DB事务也基本无影响。且对同一个用户来说，贷前数据的更新并不频繁，锁范围稍大一些是我们可以接受的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kMBiaYaAqReicL7Fs264A4RTd053loSsXTmKcQEic96zQQicERh3Y1Sajnw/0?wx_fmt=png&quot; data-cropx1=&quot;1.679300308968452&quot; data-cropx2=&quot;972.3148788927336&quot; data-cropy1=&quot;18.52864884866979&quot; data-cropy2=&quot;614.8142572513157&quot; data-ratio=&quot;0.6125385405960946&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6k1YlA9KfrSvcO3dHak47Oyicribib07q7SIVh4jTuMS5XuT8FlgMsyMtAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;973&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;立足自身场景，权衡一致性要求和服务性能要求，我们剔除了方案二，默认情况下使用方案三，但是若在事务开始前加锁失败，为了不影响原业务流程（缓存只是辅助方案，redis故障不影响原应用功能）会自动降级到方案一，即在事务提交后删除缓存前再加锁。而这种降级，若出现并发的查询操作，依然可能出现上述不一致的问题，但是是可以容忍的，原因如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常情况下加锁失败是由于操作redis异常或者锁竞争引起的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;若出现redis异常，同时出现了并发的查询，而并发的两个操作时间间隔是极短的，因此查询时候，锁检测操作通常也是异常的，此时查询会自动降级为查询DB。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;若极短时间内的redis集群抖动，事务执行前redis不可用，事务执行后redis恢复，而此时在加锁操作还没有完成前恰巧又进行了并发的查询操作，检测锁成功且锁不存在，才可能会出现查询出老数据的情况。这种是极其严苛的并发条件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;而加锁过程会进行重试（可动态调整配置），多次重试后可解决大部分的锁竞争情况。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;综上，在上述锁降级的方案下，数据不一致出现的情况虽然无法完全避免，但是产生条件极其苛刻，而应对这种极其极端的情况，在系统层面做更加强的方案带来的复杂度提升与收益是不成正比的，一般情况下做好日志记录、监控、报警，通过人工介入来弥补即可。从该方案上线后至今两年多的时间内，没有出现过该情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）删除缓存失败的补偿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外要考虑的问题是，如果更新DB成功但删除缓存失败要后如何处理，而此种情况往往因应用服务器故障、网络故障、redis故障等原因导致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若应用服务器突然故障，则服务整体不可用，跟缓存就没多大关系了。若是由于网络、redis故障等原因导致的删除缓存失败，此时查询缓存也不可用，查询走DB，但需要可靠地记录下哪些数据做了变更，待redis可用后需要进行恢复，需要将中间变更的记录对应的缓存全部删除。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此处的一个关键点在于数据变更的可靠性记录，受到QMQ事务消息实现方案的启发，我们的方案是构建一张简易的记录表（代表发生变更的DB数据），每次DB变更后，将该变更记录表的插入和业务DB操作放在一个事务中处理。事务提交后，对应的变更记录持久化，之后进行删除缓存，若缓存删除成功，则将对应的记录表数据也删除掉。若缓存删除失败，则可根据记录表的数据进行补偿删除，而在redis的恢复流程中，需要校验记录表中是否存在数据，若存在则表示有变更后的数据对应的缓存未清除，不可进行缓存读取的恢复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外删除操作还要进行异步重试，来避免偶尔超时引起的缓存删除失败。此方案整体流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6k0VSZWI4Wiaxr2h6WyBVjiadCa2vaoYlo908TKRHcnh48zahLHunzqyvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中cache_key_queue表即为我们的变更记录表，放在业务的同DB内。其表结构非常简单，只有插入和删除操作，对业务DB的额外影响可以忽略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;CREATE TABLE `cache_key_queue` (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    `cache_key` varchar(1024) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;待删除的缓存key&#x27;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    PRIMARY KEY (`id`)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;) ENGINE = InnoDB AUTO_INCREMENT = 0 CHARSET = utf8 COMMENT &#x27;缓存删除队列表&#x27;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;基于以上分析，为了锁范围尽可能小，且为了尽可能降低极端的redis抖动情况下产生的影响，我们期望可以在事务提交后立即触发缓存的删除操作。为了能够对redis不可用期间发生变更的数据进行清除，我们需要可靠地记录数据变更记录。幸运的是，基于Spring的事务同步机制 TransactionSynchronization，可以很容易实现该方案。简单来说，该机制提供了Spring环境中事务执行前后的AOP功能，可以在spring事务的执行前后添加自己的操作，如下所示（代码和注释经过了简化）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public interface TransactionSynchronization extends Flushable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 事务同步器挂起处理&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    void suspend();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 事务同步器恢复处理&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    void resume();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 事务提交前处理&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    void beforeCommit(boolean readOnly);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 事务完成(提交或回滚)前处理&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    void beforeCompletion();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 事务提交后处理&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    void afterCommit();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 事务完成(提交或回滚)后处理&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    void afterCompletion(int status);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;基于此机制，我们可以很方便且相对优雅地实现我们的设计思路，即在 beforeCommit方法中，插入cache_key_queue记录；在 afterCommit方法中同步删除缓存，若删除缓存成功则同步删除cache_key_queue表记录；在afterCompletion方法中进行锁的释放处理。若同步删除缓存失败，则cache_key_queue表记录也会保留下来，之后触发异步删除，并启动定时任务不断扫描cache_key_queue表进行缓存删除的补偿。需要注意的是可能存在嵌套事务，一个完整事务中，可能存在多次数据更新，可借助ThreadLocal进行多条更新记录的汇总。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.4 缓存的熔断和恢复&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了上述锁处理流程中讨论的redis抖动问题外，还需要考虑缓存服务redis集群不可用（网络问题、redis集群问题等）。按照我们的基本原则，引入的缓存服务仅做辅助，并不能强依赖。如果缓存不可用，主业务依然要保持可用，这就是我们接下来要讨论的缓存的熔断和恢复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）缓存熔断&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;熔断的目的是在redis不可用时避免每次调用（查询或更新）都进行额外的缓存操作，这些缓存操作会进行多次尝试，比如加锁操作我们设置的自动重试3次，每次间隔50ms，总耗时会增加150ms。若redis不可用则每次调用的耗时都会有额外增加，这对主业务功能可能会产生影响，降低底层服务的质量和性能。因此我们需要识别出 redis不可用的情况，并进行熔断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的熔断判断逻辑为：每个redis操作都try-catch异常，并做计数统计（不区分读写操作），若在M秒内出现N次异常则开启熔断。我们的场景下设置为10秒内出现50次异常就熔断，可根据自身场景设置，需要注意的是如果redis请求次数比较少，则需要在配置上保证在M秒内至少出现N次请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外熔断开关的配置是放在应用服务器的内存中，即单机熔断，而非集群熔断，这样做的原因是，redis服务不可用有可能是单机与redis服务的连通性问题导致，而在其他机器上依然可以访问缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）缓存恢复&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;熔断之后的恢复策略相对复杂一些，需要区分缓存的读操作恢复和写操作恢复。具体如下流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kxeESTdYL05cFvcJr8qI3oea4og4fl1vyPgoM37D45jMBf0A226J6qg/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1254&quot; data-cropy1=&quot;36.88235294117647&quot; data-cropy2=&quot;242.98961937716265&quot; data-ratio=&quot;0.16507177033492823&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kvucAnlzYHgRhWJPhfF4WBeHj21BAGwOxj2V2qqbYU1jFmYU86fNyrg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1254&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;step1：校验redis是否可用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;判断逻辑为，连续发起特定的set操作N次，每次间隔一定时间，若都成功，则认为redis恢复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此处需要注意的是，我们的redis集群是Cluster模式，不同的key会散落在不同的redis主节点上，因此最保险的做法是判断当前集群中所有的主节点都恢复才认为操作恢复，而简单的做法是每次探测恢复的set操作都设置不同的key以求能尽可能散列到不同的节点去。可按照自身场景进行方案抉择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;step2：恢复缓存写操作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若redis恢复，缓存的写操作就可以恢复了。即可在更新操作中进行加锁、更新DB、删除缓存。但是此时读操作还不能立即恢复，因为redis不可用期间发生了DB变更但是缓存并没有变更，依然为老数据，因此需要将这部分老数据剔除后才能恢复读操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;step3：校验挤压的cache_key_queue记录&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;轮训查看cache_key_queue表中是否有记录存在，若存在记录则认为当前有不一致的缓存数据，需要等待定时任务将暂存的key表记录对应的缓存全部删除（同时也会删除cache_key_queue表记录）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; step4：恢复缓存读操作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;若当前不存在cache_key_queue记录则可恢复读操作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;      &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以上阐述了redis缓存的自动熔断和恢复方案。需要明确的是，能够进行熔断是有前提条件的，即应用完全去掉缓存，DB还是可以抗住一段时间压力的，否则一旦出现缓存服务故障，流量全部走到应用，超过了应用和DB的承受能力，将服务压垮，后果更加严重。所以不能强依赖熔断机制，不能强依赖缓存，而这就需要接口限流等其他手段来从整体上保证服务的高可用。此外可进行定期压测，来锚定服务性能上限，进而不断优化对各种策略和资源的配置。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.5 总结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上描述了我们强一致性缓存方案的设计思路及一些实现细节。基于该方案，我们核心数据库的QPS降低了80%，缓存的命中率达到92%。而该方案的关键是通过加锁来控制读写，&lt;/span&gt;&lt;span&gt;从表面上看会牺牲一些性能，但是实际上高缓存命中率同样弥补了此缺陷，缓存的建立使得我们服务查询接口AVG响应时间降低了10%左右。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.18125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kJxFSbkwNJfHIWReJ21wvic2jXhMuwr6CNDk1pjGuSZ3zRVZDEcQ42hQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;四、结语&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上分别描述了我们的最终一致性和强一致性缓存设计和实现思路。两套缓存方案侧重点各有不同：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;此外，我们的最终一致性缓存方案是独立的缓存服务，而该强一致缓存方案，是需要嵌入到应用系统中去使用的。方案的选择需要立足于自身场景，希望我们的分享能够给大家带来一些启发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;团队招聘信息&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们是携程金融团队，从事支付、信贷等金融业务，这里拥有优秀、强大、富有创造性的团队，可以与你一起不断研究行业新技术，找寻业务解决方案的最优解，构建可驱动业务发展的技术价值体系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你热爱技术，喜欢挑战，渴望不断成长，携程金融期待与你一起腾飞。目前我们前端、后端、测试等大量技术职位开放。简历投递邮箱：tech@trip.com，邮件标题：【姓名】-【携程金融】-【投递职位】。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;【推荐阅读】&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1fJ4bmKmXiaR8Lu16W0yug6kxzSLSBveXYicSqD1JgdicDpl9NoNy6zeY9vEBZZoxtWDDKsVlcfVwu5Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; “携程技术”公众号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  分享，交流，成长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa9378bfcfa4d1df5e8535c009ee905a</guid>
<title>[推荐] 中后台领域低代码搭建设计与实践</title>
<link>https://toutiao.io/k/9mznc2m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;108&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.1859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPiadQyCOHNzUdyYbWTfk32WkUfq4DV9FJsfiatfYcicXiaL0Dwm8UdSDemw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;2021年5月22日，哈啰技术沙龙-大前端的探索与实践，在杭州成功举办。&lt;br/&gt;以下是由 @杜诗晨（庙爷）分享的主题&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPLliaW0A8SjYmsv7pEaOPNziaeRGVLSBoNw1HJHhKQuVAea3h433s7oFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1620&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;什么是低代码搭建&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;通过提供一种可视化的应用开发环境，降低或去除对原生代码编写的需求量快速构建应用程序。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;传统开发交付一个产品的流程，首先产品输出 prd，然后设计 ui 设计进行设计，设计完成给到前端，前端再去开发。如果是个新项目可能还要这种配置各种复杂环境。同时后端也在开发，然后联调、测试。其实现在大部分的公司都是这种开发流程。那这种缺点就很明显，涉及到的人非常多，开发周期也变得非常长。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPtOS1u4Cl3aOgShwe38SfJeVNeUwxzkrkjOXKymScEr02cesdiaouVEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;低代码搭建是一个什么样的流程？如果是一个成熟的配置搭建平台，只需要提供一个配置平台，开发人员不论是刚毕业的大学生或者是前端小白，甚至可能是一个后端开发，都可以通过这个配置平台搭建，快速生成网页。&lt;/p&gt;&lt;p&gt;关于低代码的市场规模和衍生的历史大家可以从下图中了解一下，这里提供两份报告作为延伸学习：海比研究报告 | 艾瑞咨询&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPMicFWOGIhnFvY0kibU57uAwpHmQQf4YDqhIialSRibhZyJDQD3T6giaD03A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;概念衍生历史&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;低代码这个概念其实很早就有了，80年代的时候提出了第四代编程语言，这个第四代是什么意思呢，第一代是机器语言，第二代汇编语言，第三代高级语言。前三代都是操作语言，需要编程指出怎么做，一步一步的写运行步骤，这样是有学习成本的，并且项目开发周期长，出于商业需要第四代语言被软件厂商提出，在一定程度上只需要说明做什么，有什么目的，不需要写出怎么做的过程。&lt;/p&gt;&lt;p&gt;2000 年 vpl 被提出，可视化编程语言，意思就是用户用过图形化操作程序元素而不是通过文本制定来创建程序，基于流的概念比如虚幻引擎，还有一些运用在3D编程，音乐合成，信号处理，物联网嵌入式等等领域。&lt;/p&gt;&lt;p&gt;2014年知名咨询公司提出了低代码/零代码的概念，在这之前国外有很多低代码产品出现并且商业化&lt;/p&gt;&lt;p&gt;2016年，国内相继发布这些低代码的平台。国内知名的像阿里百度腾讯，他们都有这种搭建平台。&lt;/p&gt;&lt;p&gt;在今年（2021），整个中国市场已经形成了完整的低代码无代码的生态体系。就比如说像现在这种 aPass 平台或者是 Sass 平台之类的，平台会包含的低代码去快速搭建这种应用。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPoAWlumsz3iaE2bEv1YfoNdrA4MCet3TFKBohYH9ibhPkJW0m5yaOkuibA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;市场规模&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;投资界似乎也发现了这种趋势，全球规模在去年的时候已经达到了八十四亿美元。预计今年超过百亿。23年超过200亿。&lt;/p&gt;&lt;p&gt;比如说二月份的时候，就有一家创业公司，他们融了大概上亿美元，估值也有几十亿。所以说这一块从全球的低代码的市场规模来说，低代码还是非常有潜力的。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPyYa4lGG9S22xhiaGbZoibdicDq5icOg2UGCwSB2tW394djib3Dwz1k1v1hQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;搭建分类&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;现在市场上基本上分为两类搭建类型，一类是营销类搭建 no code，一类是通用类搭建，就是我们所说的 low code 和 pro code。营销类 no node 无需编码，直接生成营销活动，前端资源紧缺的时候，后端开发人员也可通过 low code 可搭建中台领域的页面，前端这边为了避免各种工程环境，减低门槛也可通过 pro code 的形式来去搭建。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPUTtjuEjyaH1S3gBm6wwBYsBh8asSEg8NysWooFMXXhS4fqiaZl3YASg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;面向人群&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;那么这么分类我认为是面向的人群不同，一个特别通用的搭建平台，可能复杂度就上升了很高，所以说我们要做这个低代码搭建平台的时候，一定要想好我们面向的人群是什么？&lt;br/&gt;营销类 no node 无需编码，直接生成营销活动，前端资源紧缺的时候，后端开发人员也可通过 low code 可搭建中台领域的页面，前端这边为了避免各种工程环境，减低门槛也可通过 pro code 的形式来去搭建&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPQyMUSThEYuXTFOveibzCLxWLUwQvibpOdvqAzPHLPbloDarBBdzPhVmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;中后台领域痛点&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;首先交互不统一，比如说有一些很相似的页面，但是由不同的产品或者设计师出的图。&lt;br/&gt;那实际上他们想要达到的效果是很相似的。但是交互不同，不同的前端开发出来的效果也不一样。不同职级的开发可维护性就会差一点，代码可能会复杂一些，会出现不同的编码风格。中台还有一个痛点的就是中台的系统非常多，业务重，人员有缺口。我之前负责的那个域，前后端比例当时是有 1：7 的样子，借人也好，招人也好，都是很难去补上这个缺口。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPQd03Ta3ibMkOAVibnGRwQsICj1P5xjS3R35FbyXcicwvMicAEHk1H5o7fg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;设定目标&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;所以我们设定了三个目标，一个是提效降本。我们怎么样去把这一块的研发效能提上来。&lt;br/&gt;第二个目标是部分生产力可转移后端，让后端也有能力输出前端页面&lt;br/&gt;第三点就是抽象中后台的系统基础组件。前端在组件化的过程中逐渐沉淀，复用这些能力，赋能到搭建平台中。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;如何做？波塞冬建站平台&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;有了这些目标，促使我们做了波塞冬建站平台，通过可视化操作 + 部分编码(或者不编码)生成中后台系统。让前端业务开发变成组件开发，逐渐沉淀可复用组件，让简单业务少编码甚至不编码。为前端增效，为后端赋能。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPvpiaBRx4ViaRSNRWYhxRxMHEh08I0zxKR9mA5vL4mjeficcOLDiaVMhkcg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;使用数据&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;这个平台上线之后，线上的有117个页面在运行，共发布了870次，其中已经设计了6个团队，提升的人效也很显著，假设我们平均开发一个增量页面需要3人日，用波塞冬只需要一人日，老页面迭代修改配置也只需要0.5d&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPOhSrM6IIQicQAldHHsMMUuiaUCYo4htAYSNQHjOiakVZHvwHvK0HQibGKg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;平台流程&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;给大家讲解下平台原理，比如说一个创建者，他首先要去波塞冬平台创建页面，生成一份 schema ，这份 schema 被波塞冬后端保存在SQL中，我们的用户，也就是页面访问者，通过业务平台网站获取页面，这里边相当于业务平台网站有个sdk，他直接取拉波塞冬保存的schema，sdk通过 schema 渲染组件 和 业务数据的接口，这样一个页面就展示出来了&lt;br/&gt;那我们这边也有很多组件贡献者，如果创建者不满足需求的，贡献者这边去维护组件这样就能贡献生态&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPZ08hKMr6JKFcwUYgkXXJ3xIWiaW9GicWrRicxf567r3RNUqsB45x3BrvA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;平台架构&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;整个平台的架构是这样的：&lt;br/&gt;底层我们是拿vue搭建，不过这块技术选型哪个框架都可以，只要定义好 schema，react + antd 也能搞&lt;br/&gt;组件这一块就是根据固定的 schema 进行封装，未来可能还有一些业务组件接入&lt;br/&gt;渲染这一层主要是提供给开发者用来丰富组件库或一些其他业务场景&lt;br/&gt;平台能力也就是我们要提供的这个界面，主要是一些用户可以操作的功能，这些功能想一下入手还有一点小成本，我们提供了文档，视频等，可以做到边接入边开发，还提供了一些实例供配置方借鉴&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPTCUSNfcjCVy43TEss2hvkOcxw5xN1xuLSl5xEGicTGhKNOxCNzCdAyg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;接入方式&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;我们的解析方式有三种，一种是 sdk直接引入，这样方便升级，也方便二次开发，sdk的引入方式非常灵活。&lt;br/&gt;还有一种是 ifame 引入，这样只需引入一个标签即可，剩下的都在波塞冬里配置。&lt;br/&gt;一键建站的方式，相当于站点维度，没有项目的概念，域名菜单权限页面，都是在波塞冬里完成的，不需要本地环境，这种比较适合后端开发人员&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPYIFicTOAKdIugLe0eumicq90LiaUkuKJIWDxiaJXhqrQRvRsGiaicJLj99Hw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;渲染引擎&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;展示一下 sdk 的引用，我们可能会在不同开发环境中引入，这里提供环境变量的配置&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPA65kczibOWUc6vy7J6ZTPXtjlguSqGCm9WLkm6mF0Dp4xuB3jZuDYtg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;一键建站&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;刚才有介绍我们有三种引入方式，给大家看下第三种一键建站是怎么做的，我们加强了应用管理，一个应用就是一个站点，菜单，域名都是在平台里申请，这样用户通过页面访问就是配置的界面，完全不需要再去申请工程，这里我们用了代理的方式进行一个转发，转发的目标是一个基座，类似微前端的那个基座，只不过这个基座我们通过当前域名拉取配置，最终提供给用户。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPVfuBTLcG5rzYZDNTb4qxRJVGTKbGgGfib1ZONpekgDfAh8xr7IycdXw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;页面布局&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;带大家看一下创建页面的布局，最左侧是组件区，目前是基础组件，这里未来可能会做组件分类，把业务组件和自定义组件也接进来，中间是布局设计区，比如说列表页有固定三个区域，筛选项，中部功能区，列表，表单页不做限制，右侧为配置区，可以配置绑定字段和文案还有一些额外属性，组件的交互，像select这种option是接口调用的数据，还可以配置远程接口&lt;/p&gt;&lt;h5&gt;&lt;span&gt;模型设计（JSON SCHEMA）&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;我们创建页面后，会生成一份 schema ，什么是 json schema ，简单介绍一下，json shema 是 json 的一种约束，用来定义json的数据结构和验证格式，我们在这里用来保证数据的一致性&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPLkXHvc0UVVl9icYwlXNBz40Rsq1PhIygKvza4SrQ7kpGEe5oMFMZH6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;每个页面有一个主体，用来描述版本和一些原信息，body就是他的内容&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPHdTia1gbvHAoF8TJQj1Bw8ZaYwz5qUFT8P06MChLSmJtXUTpjq2xcqA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;JSON SCHEMA&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;我们目前页面分为两种，一种就是列表页面，一种是 form 页，但是他们的描述协议都是一样的，那基本的组件描述我们定义好了，这样其实简单的需求就能实现了，但是前端避免不了交互这一层，比如说一个选择框，当我选择了 A，B会触发一个事件，并且B还要拿到A所携带的入参信息&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPmB9USaibXAe33MWt5L43sUCMaHXcwgHOibp7TaibfvsKMoZ8gj7XXYqicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;操作事件&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;我们这边做了一个操作事件功能，我们只需要把组件的 ref 设置好，操作事件这一块就可以定义他的出参入参，方便交互&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPt5rtLJC35qWP1DEBPKNxQCGLiaVMLPkNaiaTIxCq6bp7q6TzIqNPUaOQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;数据中心&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;接口配置这里，比如说一个 select 从远程接口获取到一个枚举，就可以存下来，给其他组件消费&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPkeaNNJc9kRU3FOaicR5FEichfT9Cl0SYPRlErhRKLQTDO8ao1s0DjpLQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;自定义插槽&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;比如说平台目前有不支持的组件或交互，还没有维护在平台里的，这里可以利用 vue 的 slot 进行二次开发，只需要拖入一个 slot&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPwyViaJdGAkBanhSENuGH0hNl8f7X1wD0jDNYGEgNlibFZCrQ3wIicB5TQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;自定义插槽-编码&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;slot 里的组件可以获取到配置里的 ref 和想要拿到的 scope，做任何你想做的事儿&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPgN4Of1tWWJpE94mLUVEjDKyU1jVqWflfrmdVgicKlNJ6UibeTIHI04IQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;480&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;稳定性&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;我们做低代码平台，归根到底是一个渲染引擎渲染一组 schema ，那么稳定性也得考虑，我们每次修改线上配置，可能心情如图，那我发布时怎么保证准确性，传统开发我们会有一个review 的过程，我们就把这个过程也搬上来了&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPYuGtczw1hRcH849icrwiaG54LBopoUMdkHiavde2v8G1aibeTQS5Vvhd0Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;SCHEMA DIFF &amp;amp; 版本对比&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;schema diff 每次发布时，需要选择版本来确认我改了什么，大大降低了风险。&lt;br/&gt;发布时也要进行二次确认&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPmmTb0uyDmKlibyxiaq1gZtdVtiaggp3tlH7BnH83pE4ZY6CgurMxS7Ztg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;未来规划&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xdDaByDutCjAmyLtEqTAMsib5OJh6S6mPJsKkXnlxN4Jht7eWpWTV04ultiblzntWyBpvFBXciaY9KC85VzAHTHnw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;AUTO-CODE&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;我们目前的能力，在版本对比这一块希望能做到 merge，并且提供可视化，也就是说你不一定非要看 schema 这种东西，组件这里继续丰富，能承载更多的需求，low-code 目标就做到 no-code 让非开发人员直接生成页面，不需要写一点代码，最终这个生产力就可以转移，终极目标就是做成 auto-code ，利用机器学习识别设计图，直接生成网站，抹去大部分配置，auto-code 目前业界有很多公司已经实现，我们也在慢慢摸索。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-darkmode-color-16057140139831=&quot;rgb(162, 162, 162)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(68, 68, 68)&quot; data-style=&quot;padding-top: 7px; padding-bottom: 7px; color: rgb(68, 68, 68); font-size: 14px; line-height: 1.8; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Lucida Grande&amp;quot;, Arial, &amp;quot;Hiragino Sans GB&amp;quot;, 微软雅黑, &amp;quot;WenQuanYi Micro Hei&amp;quot;, STHeiti, SimSun, sans-serif; text-align: center;&quot;&gt;&lt;span&gt;The End&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-darkmode-color-16057140139831=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(0,0,0)&quot; data-style=&quot;padding-right: 10px; padding-left: 10px; font-size: 16px; color: black; line-height: 1.6; letter-spacing: 0px; word-break: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif;&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: rgb(89, 89, 89);&quot;&gt;&lt;span&gt;如果你觉得这篇内容对你挺有启发，请你轻轻点下小手指，帮我两个小忙呗：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: rgb(89, 89, 89);&quot;&gt;&lt;span&gt;1、点亮&lt;strong data-darkmode-color-16057140139831=&quot;rgb(71, 193, 168)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(71, 193, 168)&quot;&gt;「在看」&lt;/strong&gt;，让更多的人看到这篇满满干货的内容；&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: rgb(89, 89, 89);&quot;&gt;&lt;span&gt;2、关注公众号「哈啰技术团队」，可第一时间收到最新技术推文。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: rgb(89, 89, 89);&quot;&gt;&lt;span&gt;如果喜欢就点个👍喔，有您的喜欢⛽️，我们会更有动力输出有价值的技术分享滴；&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3365323096609085&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xdDaByDutCja1wGKtp4IvKFbKKgKS8L0kQO9PzXxFoTia27KOzppMGsiba5RdY3TAY6XTpIDGsLJLrYCBRCKMKnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1563&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e82bfcb42cf524d36d016c94f3375720</guid>
<title>[推荐] 聊聊 Spring Boot 项目引用第三平台私有 jar 踩到的坑</title>
<link>https://toutiao.io/k/lwp4q3t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.4482758620689655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/x3PUSozJwwAaJw4zXjqfPRUA7lJmekCwibg7BQjEA5DnAL3micemNQFaQ8qM1HKwxibZS7icibtYnBfZjXwSAice1RqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;58&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点击上方&lt;span data-mid=&quot;&quot;&gt;蓝字&lt;/span&gt;关注我们&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.4482758620689655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hY4KIU3VygBDHnandGNlscl5JDiaYsa0ADibK059RiaNjG21YZJZgr9qNRqjvDMQtbh0EqnBylWaIdBVB9vxfSibmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;58&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;最近和朋友闲聊，他说他遇到一个问题，他引用了第三方公司私有API包，他在本地项目启动没问题，打包运行却找不到这个API包，于是我就问他怎么引用这个jar。&lt;/p&gt;&lt;p&gt;他工程项目第三jar存放的位置类似如下&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7557077625570776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIdkf8Ta2OMxib11Y5Bty7HgIXyQKhJLnPiaHOcKGfxwvsI7n5pM93QO4Ec06PmibzLELqr4rRHbWZsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;438&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在pom做如下引用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.example&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;demo-api&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;system&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;systemPath&lt;/span&gt;&amp;gt;&lt;/span&gt;${project.basedir}/lib/demo-api.jar&lt;span&gt;&amp;lt;/&lt;span&gt;systemPath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;pom打包插件用springboot自带的插件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;executions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    &lt;span&gt;&amp;lt;&lt;span&gt;execution&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                        &lt;span&gt;&amp;lt;&lt;span&gt;goals&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                            &lt;span&gt;&amp;lt;&lt;span&gt;goal&lt;/span&gt;&amp;gt;&lt;/span&gt;repackage&lt;span&gt;&amp;lt;/&lt;span&gt;goal&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                        &lt;span&gt;&amp;lt;/&lt;span&gt;goals&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    &lt;span&gt;&amp;lt;/&lt;span&gt;execution&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;/&lt;span&gt;executions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;看到这个插件，大概就知道问题所在了，springboot默认的打包插件是不会把systemscope的jar打进springboot项目的BOOT-INF/lib/。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; springboot项目默认会引用BOOT-INF/lib/里面的jar&lt;/p&gt;&lt;p&gt;于是我就跟朋友说，不要用systemscope了，直接搭建maven私仓，然后把第三方jar上传到私仓中，pom做如下引用&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.example&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;demo-api&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;朋友给回复是公司没有私仓，我一脸懵逼，我就问他应该不至于吧，再次确认，得到他同样的回复后。后边就提供了下边的几种方案，让他参考选择&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;springboot如何引用没有发布到私仓的第三jar&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;整体思路&lt;/strong&gt;&lt;span&gt;：因为springboot提供的打包插件，默认是会把位于BOOT-INF/lib/里面的jar编译成class文件然后供项目引用。因此我们只需确保BOOT-INF/lib/里面含有我们要引用的第三方jar即可&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mYa0sCia1qwCvHOMJjG9CpYS2Dxg4BTswGyYqHicBiblUPjYtNVRRV8FfvmjHGrv2QDbXSTonQI2cxWbClolxgR1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zG8IRvK3Jv7v7KkHWz3icB3KyTibM5FHc8agmPbXe6JmlEBp8DaAicJnXP6uGW3ib9GC27vCvuiadzB0wiaticmUqWAUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;方案一：pom指定jar范围为system+springboot插件加入includeSystemScope标签的属性为true&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DVZP48AYchdT255kFMRWTzyhjz4G7gCkibZoIZzGyRL8tC8TmnwMNRXvnQzXIQfpXicBhryMc8v4iczz9jcOKVTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O8ibmtKwBdw2y81ibxiaccicUBbaVmPQtu2EYiaUDwicb704E6QHad6o5oJhLeibDSMewvakJR9UNJ43ibibLCyYeAkWZVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.example&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;demo-api&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;system&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;systemPath&lt;/span&gt;&amp;gt;&lt;/span&gt;${project.basedir}/lib/demo-api.jar&lt;span&gt;&amp;lt;/&lt;span&gt;systemPath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    &lt;span&gt;&amp;lt;&lt;span&gt;includeSystemScope&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;span&gt;includeSystemScope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;/&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;executions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    &lt;span&gt;&amp;lt;&lt;span&gt;execution&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                        &lt;span&gt;&amp;lt;&lt;span&gt;goals&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                            &lt;span&gt;&amp;lt;&lt;span&gt;goal&lt;/span&gt;&amp;gt;&lt;/span&gt;repackage&lt;span&gt;&amp;lt;/&lt;span&gt;goal&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                        &lt;span&gt;&amp;lt;/&lt;span&gt;goals&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    &lt;span&gt;&amp;lt;/&lt;span&gt;execution&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;/&lt;span&gt;executions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mYa0sCia1qwCvHOMJjG9CpYS2Dxg4BTswGyYqHicBiblUPjYtNVRRV8FfvmjHGrv2QDbXSTonQI2cxWbClolxgR1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zG8IRvK3Jv7v7KkHWz3icB3KyTibM5FHc8agmPbXe6JmlEBp8DaAicJnXP6uGW3ib9GC27vCvuiadzB0wiaticmUqWAUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;方案二：pom指定jar范围为system+resources标签引入要包含的jar&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DVZP48AYchdT255kFMRWTzyhjz4G7gCkibZoIZzGyRL8tC8TmnwMNRXvnQzXIQfpXicBhryMc8v4iczz9jcOKVTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O8ibmtKwBdw2y81ibxiaccicUBbaVmPQtu2EYiaUDwicb704E6QHad6o5oJhLeibDSMewvakJR9UNJ43ibibLCyYeAkWZVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.example&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;demo-api&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;system&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;systemPath&lt;/span&gt;&amp;gt;&lt;/span&gt;${project.basedir}/lib/demo-api.jar&lt;span&gt;&amp;lt;/&lt;span&gt;systemPath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;resources&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;resource&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;directory&lt;/span&gt;&amp;gt;&lt;/span&gt;${project.basedir}/lib&lt;span&gt;&amp;lt;/&lt;span&gt;directory&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;targetPath&lt;/span&gt;&amp;gt;&lt;/span&gt;BOOT-INF/lib/&lt;span&gt;&amp;lt;/&lt;span&gt;targetPath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;includes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    &lt;span&gt;&amp;lt;&lt;span&gt;include&lt;/span&gt;&amp;gt;&lt;/span&gt;**/*.jar&lt;span&gt;&amp;lt;/&lt;span&gt;include&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;/&lt;span&gt;includes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;resource&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;resources&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;executions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    &lt;span&gt;&amp;lt;&lt;span&gt;execution&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                        &lt;span&gt;&amp;lt;&lt;span&gt;goals&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                            &lt;span&gt;&amp;lt;&lt;span&gt;goal&lt;/span&gt;&amp;gt;&lt;/span&gt;repackage&lt;span&gt;&amp;lt;/&lt;span&gt;goal&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                        &lt;span&gt;&amp;lt;/&lt;span&gt;goals&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    &lt;span&gt;&amp;lt;/&lt;span&gt;execution&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;&amp;lt;/&lt;span&gt;executions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mYa0sCia1qwCvHOMJjG9CpYS2Dxg4BTswGyYqHicBiblUPjYtNVRRV8FfvmjHGrv2QDbXSTonQI2cxWbClolxgR1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zG8IRvK3Jv7v7KkHWz3icB3KyTibM5FHc8agmPbXe6JmlEBp8DaAicJnXP6uGW3ib9GC27vCvuiadzB0wiaticmUqWAUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;方案三：直接将第三方jar打进要发布的本地仓库&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DVZP48AYchdT255kFMRWTzyhjz4G7gCkibZoIZzGyRL8tC8TmnwMNRXvnQzXIQfpXicBhryMc8v4iczz9jcOKVTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O8ibmtKwBdw2y81ibxiaccicUBbaVmPQtu2EYiaUDwicb704E6QHad6o5oJhLeibDSMewvakJR9UNJ43ibibLCyYeAkWZVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.856020942408377&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIdkf8Ta2OMxib11Y5Bty7Hg85Pdria48HU2ibqHEIjGAK0Bz3dOh0Xmg4iasEOmdhVkvKfRNr7OAYTyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;764&quot;/&gt;&lt;/p&gt;&lt;p&gt;上图是maven官方的仓库流程图，其实对maven比较熟悉的朋友应该会知道，maven会先从本地仓库找jar，本地仓库找不到jar，就会再从私仓（如果有搭建私仓）里面找，私仓没有再从中央仓库找，然后找到的jar再存放到本地仓库。&lt;/p&gt;&lt;p&gt;因此我们执行如下命令就可以将第三方jar直接打进本地仓库&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;mvn &lt;span&gt;install&lt;/span&gt;:&lt;span&gt;install&lt;/span&gt;-&lt;span&gt;file&lt;/span&gt; -DgroupId=org.example -DartifactId=demo-api -Dversion=&lt;span&gt;1.0&lt;/span&gt;-&lt;span&gt;SNAPSHOT&lt;/span&gt; -Dfile=F:\boot-thirdparty\lib\demo-api.jar -Dpackaging=jar&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;项目的pom直接像如下引入第三方jar即可&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.example&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;demo-api&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mYa0sCia1qwCvHOMJjG9CpYS2Dxg4BTswGyYqHicBiblUPjYtNVRRV8FfvmjHGrv2QDbXSTonQI2cxWbClolxgR1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zG8IRvK3Jv7v7KkHWz3icB3KyTibM5FHc8agmPbXe6JmlEBp8DaAicJnXP6uGW3ib9GC27vCvuiadzB0wiaticmUqWAUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;方案四：搭建maven私仓，将第三方jar上传到maven私仓&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DVZP48AYchdT255kFMRWTzyhjz4G7gCkibZoIZzGyRL8tC8TmnwMNRXvnQzXIQfpXicBhryMc8v4iczz9jcOKVTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9411764705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O8ibmtKwBdw2y81ibxiaccicUBbaVmPQtu2EYiaUDwicb704E6QHad6o5oJhLeibDSMewvakJR9UNJ43ibibLCyYeAkWZVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 搭建私仓不在本文论述范围，就讲下如何将第三方jar上传到私仓&lt;/p&gt;&lt;p&gt;&lt;strong&gt;a、&lt;/strong&gt; 先在maven的settings.xml的servers标签配置如下内容&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;server&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;nexus&lt;span&gt;&amp;lt;/&lt;span&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;username&lt;/span&gt;&amp;gt;&lt;/span&gt;admin&lt;span&gt;&amp;lt;/&lt;span&gt;username&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;password&lt;/span&gt;&amp;gt;&lt;/span&gt;admin123&lt;span&gt;&amp;lt;/&lt;span&gt;password&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;server&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;b、&lt;/strong&gt;&lt;span&gt; 执行发布命令行，如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;mvn deploy:deploy-&lt;span&gt;file&lt;/span&gt; -DgroupId=org.example -DartifactId=demo-api -Dversion=&lt;span&gt;1.0&lt;/span&gt;-SNAPSHOT -Dpackaging=jar -Dfile=F:\boot-thirdparty\lib\demo-api.jar -Durl=你的私仓地址 -DrepositoryId=和settings.xml配置server标签id一致，如上的nexus&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;或者也可以利用maven私仓自带的可视化界面进行上传&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面几种方案，个人是比较倾向方案三和方案四，因为本来就是用maven来管理jar了，在项目中还要额外把jar引进来，然后再修改插件，看着就感觉有点变扭&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d901213929ddb9effbfb2c955e99d23a</guid>
<title>[推荐] [译] 如何优化您的日常决策</title>
<link>https://toutiao.io/k/88ebc7h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Post-body&quot;&gt;
                    &lt;p&gt;当今的生活和工作都是&lt;strong&gt;快节奏&lt;/strong&gt;的，人们每天都会遇到各种各样的事情，并需要做出做相应的&lt;strong&gt;决策&lt;/strong&gt;：哪些事情先做，哪些事情后做，哪些事情应该做，哪些事情不应该做。前些天有读到一篇文章：&lt;a href=&quot;https://jamesclear.com/design-default&quot; rel=&quot; nofollow ugc&quot;&gt;How to Optimize Your Daily Decisions&lt;/a&gt;，作者所做的思考，以及给出的建议，不仅通俗易懂，而且也方便用于日常工作、生活。因此有翻译成中文，分享给有需要的朋友；以下是原文。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lovejade.oss-cn-shenzhen.aliyuncs.com/decisions.png&quot; title=&quot;&quot; alt=&quot;如何优化您的日常决策&quot;/&gt;&lt;/p&gt;

&lt;p&gt;您可能会假设人们购买产品是因为它们是什么，但事实是，我们经常购买东西是因为它们的位置。例如，与视线齐平的商店货架上的商品往往比不太显眼的货架上的商品购买得更多。&lt;/p&gt;

&lt;p&gt;在畅销书 &lt;a href=&quot;https://jamesclear.com/book/nudge&quot; rel=&quot; nofollow ugc&quot; title=&quot;理查德·塞勒 (Richard Thaler) 和卡斯·桑斯坦 (Cass Sunstein) 的推动&quot;&gt;Nudge&lt;/a&gt; ( &lt;a href=&quot;https://jamesclear.com/ebook/nudge&quot; rel=&quot; nofollow ugc&quot; title=&quot;轻推电子书&quot;&gt;Kindle&lt;/a&gt; | &lt;a href=&quot;https://jamesclear.com/audiobook/nudge&quot; rel=&quot; nofollow ugc&quot; title=&quot;轻推有声读物&quot;&gt;Audiobook&lt;/a&gt; ) 中，作者 Richard Thaler 和 Cass Sunstein 解释了我们日常决策受周围世界影响的各种方式。视线水平的货架对我们购买习惯的影响只是一个例子。&lt;/p&gt;

&lt;p&gt;这是另一个：&lt;/p&gt;

&lt;p&gt;过道的尽头是零售商的赚钱机器。根据《纽约时报》引用的数据，可口可乐 45% 的销售额专门来自过道尽头的货架。&lt;/p&gt;

&lt;p&gt;这就是为什么这很重要：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一些东西&lt;/strong&gt;必须放在与视线齐平的架子上。必须在过道尽头的架子上放&lt;em&gt;一些东西&lt;/em&gt;。某些东西必须是默认选择。某些东西必须是最能见度和最突出的选项。这不仅适用于商店，而且适用于我们生活的几乎每个领域。您的办公室、汽车、厨房和客厅都有默认选择。&lt;/p&gt;

&lt;p&gt;我的论点是这样的：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果你为生活中的默认而设计，而不是接受交给你的任何东西，那么过上更好的生活会更容易&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;现在让我们谈谈如何做到这一点。&lt;/p&gt;

&lt;h2&gt;默认设计&lt;/h2&gt;

&lt;p&gt;尽管我们中的大多数人在任何特定时刻都有做出广泛选择的自由，但我们经常根据所处的环境做出决定。&lt;/p&gt;

&lt;p&gt;例如，如果我想这样做，我可以在写这篇文章时喝一杯啤酒。但是，我目前坐在办公桌前，旁边放着一杯水。看不到啤酒。虽然我有能力起床、步行到我的车、开车去商店和买啤酒，但我可能不会，因为我周围有更简单的选择——即饮用水。在这种情况下，喝一口水是默认的决定，很容易的决定。&lt;/p&gt;

&lt;p&gt;考虑在您的个人和职业生涯中如何设计您的默认决定。例如：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;如果您睡觉时将手机放在床边，那么醒来后立即查看社交媒体和电子邮件可能是默认决定。&lt;/li&gt;
&lt;li&gt;如果你走进你的客厅，你的沙发和椅子都面向电视机，那么看电视很可能是默认的决定。&lt;/li&gt;
&lt;li&gt;如果您在厨房里放酒，那么持续饮酒更有可能成为默认决定。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;当然，默认值也可以是正数。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;如果你在工作时在办公桌旁边放一个哑铃，那么做一些快速的弯举更有可能是默认的决定。&lt;/li&gt;
&lt;li&gt;如果你全天都带着水瓶，那么喝水而不是苏打水更有可能是默认的决定。&lt;/li&gt;
&lt;li&gt;如果您将牙线放在可见的位置（例如牙刷旁边），则使用牙线更可能是默认决定。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;研究人员将环境违约对我们决策的影响称为&lt;a href=&quot;https://jamesclear.com/choice-architecture&quot; rel=&quot; nofollow ugc&quot; title=&quot;选择架构&quot;&gt;选择架构&lt;/a&gt;。重要的是要意识到您可以成为您选择的架构师。您可以设计为默认。&lt;/p&gt;

&lt;h2&gt;如何优化您的默认决策&lt;/h2&gt;

&lt;p&gt;以下是我在尝试为我的生活中的默认设计时发现的一些有用的策略：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简单&lt;/strong&gt;。当您经常被噪音包围时，很难将注意力集中在信号上。当你的厨房里堆满垃圾食品时，要吃得健康就更难了。当您在浏览器中打开 10 个选项卡时，更难以专注于阅读博客文章。当您陷入&lt;a href=&quot;https://jamesclear.com/multitasking-myth&quot; rel=&quot; nofollow ugc&quot; title=&quot;多任务处理的神话：为什么更少的优先级会导致更好的工作&quot;&gt;一心多用的神话&lt;/a&gt;时，完成最重要的任务就更加困难了。如有疑问，消除选项。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;视觉提示&lt;/strong&gt;。在超市中，将商品放在与视线齐平的货架上会使它们更具视觉效果并且更有可能被购买。在超市之外，您可以使用诸如&lt;a href=&quot;https://jamesclear.com/paper-clips&quot; rel=&quot; nofollow ugc&quot; title=&quot;如何通过使用回形针策略坚持每天的好习惯&quot;&gt;回形针法&lt;/a&gt;或&lt;a href=&quot;https://jamesclear.com/stop-procrastinating-seinfeld-strategy&quot; rel=&quot; nofollow ugc&quot; title=&quot;如何使用宋飞正传策略停止拖延你的目标&quot;&gt;宋飞策略之&lt;/a&gt;类的视觉提示来创建一个环境，在视觉上将您的行为推向正确的方向。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;选择退出与选择加入&lt;/strong&gt;。有一项&lt;a href=&quot;https://jamesclear.com/environment-design-organ-donation&quot; rel=&quot; nofollow ugc&quot; title=&quot;器官捐献与环境设计&quot;&gt;著名的器官捐赠研究&lt;/a&gt;揭示了多个欧洲国家如何提高器官捐赠率：他们要求公民选择不捐赠而不是选择捐赠。通过提前让未来的自己养成更好的习惯，你可以在生活中做一些类似的事情。例如，您可以将瑜伽课程安排在下周，而您今天感到有动力。当您的锻炼开始时，您必须证明选择退出是合理的，而不是激励自己选择加入。&lt;/p&gt;

&lt;p&gt;默认设计归结为一个非常简单的前提：改变你的环境，让好的行为更容易，坏的行为更难。&lt;/p&gt;

&lt;h2&gt;为您设计与由您设计&lt;/h2&gt;

&lt;p&gt;默认选择本身并不坏，但整个世界的设计都没有考虑到您的目标。事实上，许多公司的目标与您的目标直接竞争（食品公司可能希望您购买他们的薯片袋，而您想减肥）。出于这个原因，您应该谨慎接受每一个默认值，就好像它应该是最佳选择一样。&lt;/p&gt;

&lt;p&gt;我通过过自己设计的生活而不是接受别人给我的标准生活，从而获得了更多的成功。质疑一切。你需要改变、调整和改变你的环境，直到它符合你想要的生活。&lt;/p&gt;

&lt;p&gt;是的，你周围的世界塑造了你的习惯和选择，但有一件重要的事情需要意识到：首先必须有人来塑造这个世界。现在，有人可以是你。&lt;/p&gt;

&lt;p&gt;如果你想要更多关于改掉坏习惯和养成好习惯的实用想法，请查看我的书&lt;a href=&quot;https://jamesclear.com/book/atomic-habits&quot; rel=&quot; nofollow ugc&quot;&gt;原子习惯&lt;/a&gt;，它会告诉你习惯的微小改变如何带来显着的结果。&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;通过该文的阅读，可以给生活、工作带来哪些启示？下面跟大家分享一些（如您有更多建议，欢迎留言分享）：&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;定时对浏览器所打开的页面，加以阅读、消化、整理，然后关闭；从而提升专注；&lt;/li&gt;
&lt;li&gt;不再将短视频、微信等浪费时间，却没有太大价值的应用，放置手机桌面显眼位置；&lt;/li&gt;
&lt;li&gt;如您也有游戏瘾，周末将至，列出读一本书，或看几部电影的计划，尽量不去想玩游戏这事儿；&lt;/li&gt;
&lt;li&gt;如一定要玩儿，那么再玩了几盘，尽兴之后，删除游戏，让下次打开游戏，变得困难......&lt;/li&gt;&lt;/ol&gt;
                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>