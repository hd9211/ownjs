<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b969ba6f7f4c954bef603687df78d995</guid>
<title>面试官问: ES 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？</title>
<link>https://toutiao.io/k/kiapnd2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;解题思路&lt;/h2&gt;

&lt;p&gt;需要从ES搜索优化作答&lt;/p&gt;

&lt;p&gt;es的性能优化，主要是围绕着 fileSystem cache 也可以叫做OS cache来进行；es写入数据实际
上数据最终都会写入到磁盘中去，当我们搜索读取的时候，系统会将数据放入到os cache中，而
es严重依赖于这个os cache，如果我们给机器的内存足够多，在es里存的书库里昂小于内存容
量，那么搜索的效率是非常高的，&lt;/p&gt;

&lt;h2&gt;性能优化的杀手锏——filesystem cache&lt;/h2&gt;

&lt;p&gt;你往 es 里写的数据，实际上都写到磁盘文件里去了，查询的时候，操作系统会将磁盘文件里的数据自动缓存到 filesystem cache 里面去。es 的搜索引擎严重依赖于底层的 filesystem cache，你如果给 filesystem cache 更多的内存，尽量让内存可以容纳所有的 idx segment file 索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。&lt;/p&gt;

&lt;h2&gt;减少字段&lt;/h2&gt;

&lt;p&gt;如果我们的表里有很多的字段，而我们只需要往es库里写入我们需要检索的那几个字段就可以了，对于其他的字段我们可以存到mysql或者说其他的比如Hbase中，hbase的特点是适用于海量数据的在线存储，就是对hbase可以写入海量数据，不要做复杂的搜索，就是做很简单的一些根据id或者范围进行查询的这么一个操作就可以了，从es中根据检索的字段去搜索，拿到的结果可能就十几个doc id，然后根据doc id到hbase里去查询每个doc id对应的完整的数据，给查出来，再返回给前端。简单地说就是：elastcisearch减少数据量仅仅放要用于搜索的几个关键字段即可，尽量写入es的数据量跟es机器的filesystem cache是差不多的就可以了；其他不用来检索的数据放hbas里，或者mysql。&lt;/p&gt;

&lt;h2&gt;数据预热&lt;/h2&gt;

&lt;p&gt;如果说我们按照方案一的方法做了之后，效率还是不行，存的数据量还是超过os cache的空间，那么我们就可以吧一些比较热门的数据，比如在电商系统中，像一些热门的商品，我们可以在后台单独的写一个子系统，每隔一段时间，我们就访问一下，然数据进入到os cache中，这样用户来访问的时候就访问到的是os cache中的数据，就比较快。&lt;/p&gt;

&lt;h2&gt;冷热分离&lt;/h2&gt;

&lt;p&gt;elasticsearch 可以做类似于 mysql 的水平拆分，就是说将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。最好是将冷数据写入一个索引中，然后热数据写入另外一个索引中，这样可以确保热数据在被预热之后，尽量都让他们留在 filesystem os cache里，别让冷数据给冲刷掉。&lt;/p&gt;

&lt;p&gt;假设你有 6 台机器， 2 个索引，一个放冷数据，一个放热数据，每个索引 3 个 shard。 3 台机器放热数据 index，另外 3 台机器放冷数据 index。然后这样的话，你大量的时间是在访问热数据 index，热数据可能就占总数据量的 10%，此时数据量很少，几乎全都保留在 filesystem cache 里面了，就可以确保热数据的访问性能是很高的。但是对于冷数据而言，是在别的 index 里的，跟热数据 index 不在相同的机器上，大家互相之间都没什么联系了。如果有人访问冷数据，可能大量数据是在磁盘上的，此时性能差点，就 10% 的人去访问冷数据，90% 的人在访问热数据，也无所谓了。&lt;/p&gt;

&lt;h2&gt;document 模型设计&lt;/h2&gt;

&lt;p&gt;对于 MySQL，我们经常有一些复杂的关联查询。在 es 里该怎么玩儿，es 里面的复杂的关联查询尽量别用，一旦用了性能一般都不太好。最好是先在 Java 系统里就完成关联，将关联好的数据直接写入 es 中。搜索的时候，就不需要利用 es的搜索语法来完成 join 之类的关联搜索了。
  document 模型设计是非常重要的，很多操作，不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es 能支持的操作就那么多，不要考虑用 es 做一些它不好操作的事情。如果真的有那种操作，尽量在 document 模型设计的时候，写入的时候就完成。另外对于一些太复杂的操作，比如
join/nested/parent-child 搜索都要尽量避免，性能都很差的。&lt;/p&gt;

&lt;h2&gt;分页性能优化&lt;/h2&gt;

&lt;h3&gt;不允许深度分页（默认深度分页性能很差）&lt;/h3&gt;

&lt;p&gt;类似于 app 里的推荐商品不断下拉出来一页一页的，你可以用 scroll api scroll 会一次性给你生成所有数据的一个快照然后每次滑动向后翻页就是通过游标scroll_id移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。初始化时必须指定scroll` 参数，告诉 es 要保存此次搜索的上下文多长时间。你需要确保用户不会持续不断翻页翻几个小时，否则可能因为超时而失败。除了用 scroll api ，你也可以用 search_after 来做，search_after 的思想是使用前一页的结果来帮助检索下一页的数据，显然，这种方式也不允许你随意翻页，你只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。&lt;/p&gt;

&lt;h2&gt;号外号外&lt;/h2&gt;

&lt;p&gt;给大家整理了Java最新大厂面试题及答案，并且整理成了PDF格式方便阅读。 欢迎大家关注”浅谈架构“ 公众号 (后台私信”面试“即可获取)。另外需要大厂内推同学也可以私信我。 &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.bytearch.com/images/mianshiti.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1e9835f450f348d5df6db10c5fab0572</guid>
<title>35岁程序猿，也是要进阿里的</title>
<link>https://toutiao.io/k/o5xvksj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家好我是小Q，今天我来和大家聊聊“35岁程序员那些事”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在IT行业兢兢业业的工作了10年，小Q是非常了解这个行业的潜规则的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近几年，小Q每年都会面试几百个候选人，候选人的能力层次不齐，其中，有非常有潜力的95后程序员，也有经验非常丰富的90后程序员，当然也有年龄偏大的85后程序员。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小Q来聊聊自己的一些感想，面试这个东西其实是看眼缘和能力，一个经验非常丰富的面试官，他几乎可以不用和你聊就大概知道你的技术能力是否匹配HC岗位的要求，但是面试官为什么还要面试呢？其实主要的原因还是要考察候选人的心智能力，所谓心智能力，主要是指“智商”和“情商”的组合能力，用一个简单的术语来解释，就是看你是否“讨他喜欢”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有人或许会说，面试又不是“选美”，怎么还要“讨他喜欢”呢？咱们换位思考一下，如果你是面试官（甚至你就是HC岗位的直接主管），你会招聘一个“不讨你喜欢”的人过来做事情吗？哈哈，我想你应该不会。所以小Q认为，面试能力是硬实力，那么“讨他喜欢”是直接影响面试官决策的“润滑剂”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在“讨他喜欢”这个“润滑剂”上，35岁程序员尤其是要注意的，如果你是本科毕业，到了35岁你就已经工作至少13年了；如果你是专科毕业，到了35岁你就已经工作至少15年了；如果你是硕士毕业，到了35岁你就已经工作至少10年了。好吧，一般都了这个年龄，面试官会默认你的技术能力是达到要求的（当然如果你一直生活在技术能力的安逸区，这个需要另当别论）。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;35岁程序猿，也是要进阿里的&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小Q也是一名大龄“35岁程序员”，小Q能够深深的体会这个年龄的尴尬，尤其是还没有完全转型到技术管理的，年龄优势已经不复存在了，但是还要和年轻人抢饭碗。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，35岁程序员要进阿里需要具备“20岁程序员归零的思维”。这个要求“35岁程序员”具备随时重新来过的勇气，阿里不是有一个非常鲜明的价值观“求变”，也就是说“现有成就”是你立足过去和现在的基石，但是“求变”是你突破自己，并决胜千里的“长远规划”。只有具备了归零思维，你才会一直保持非常强烈的“好奇心”，并一直把自己当做一个小白，虚心的接受别人的建议，这样才能突破“35岁程序员”的门槛。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，35岁程序员要进阿里需要具备“可以认证的技术品牌”。这个要求“35岁程序员”具备长期的人生规划能力。一个能规划自己人生的人，那么他大概率会在职场上最大程度的发挥他的价值，从而更好的服务公司，所以阿里不是有一个非常鲜明的价值观“创新”。小Q觉得打造个人技术品牌真的很重要，尤其是想跨过“35岁程序员”门槛的技术人员，一定要获得自己特色的技术品牌，并持之以恒的输出，这样才能更大程度的让自己保持“20岁程序员归零的思维”，不是有一句俗话，叫做“后生可畏”吗？虽然你的年龄到了35岁，你的阅历和经验到了35岁，但是你的求知欲确还是一个“后生”的状态，这样的你是多么的优秀。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，35岁程序员进阿里需要具备“过硬的技术驱动能力”。这个是“35岁程序员”最基本的硬实力，不管你是哪个年龄段“技术才是王道”，咱们祖国不是一直在实施“科教兴国”和“科技是第一生产力”的N个五年计划吗？那么如何提高自己“过硬的技术驱动能力”呢？小Q是这样认为的，35岁程序员不是说你懂的技术越多越好，而是要将这些技术归类，按领域去驱动自己去学习，并能学会融会贯通的能力，所谓“一桶百通，焕然大悟”才是“35岁程序员”最后技术能力的体现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结，35岁程序员除了将过硬的技术驱动能力作为基石，还要将可以认证的技术品牌作为自己人生的长期规划，以及要具备“20岁程序员归零的思维”，最后还是要具备利用和保持“资源和人脉”的能力，因为有人的地方就有“江湖”，所谓“人在江湖，生不由己”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;35岁程序员需要刷“算法题”吗&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;算法题是候选人面试的第一大痛点，小Q认为“算法”这个东西不用刻意的去研究，为甚么呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，小Q认为，我们学习的目的是为了“用和实践”，算法这个东西在咱们实际的项目中真的是没有机会用，因为如果你的项目中如果真的用到了算法，也会采用“工业级”的算法引擎来计算你的业务逻辑，而从事“工业级”算法开发的程序员就那么一波人。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，小Q认为，35岁程序员怎么准备算法呢？可以从中间件着手，比如RocketMQ、Spring Cloud Alibaba、Sentinel、Nacos以及Dubbo中用到了那些算法和数据结构，并从具体的技术场景中去体会算法和数据结构的架构思想。当然这里小Q只是举个例子，实际上还是有很多其它技术案例的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，小Q认为，算法这个东西是“35岁程序员”的编程基础的体现，如果你基础不好，那么“算法”肯定不好，如果你“算法”不好，但是懂得如何利用“中间件”去实现“算法”，那也是一种能力的体现。所以，最后还是要夯实基础，不要眼高手低，只有熟悉技术细节的人，才会觉得做技术的人太不容易了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本公众号后续文章会用尽量少的文字来带着大家拓展新的技术，言简意赅是文章的特色，要让读者不能白读文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎书友们认真的品读小Q的技术品牌系列书籍“Spring Cloud Alibaba微服务架构实战派（上下册）“，多多熟悉更多牛逼的技术。”35岁程序员“有一个比较特色的口号，”不要让技术成为你跨越35岁门槛的瓶颈“，要让技术成为你的黄金圣衣，辅助你防御更多大Boss的组合拳。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小Q会孜孜不倦的给大家介绍“Spring Cloud Alibaba全家桶技术栈”，书友们也要持之以恒的多多关注小Q。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，Spring Cloud Alibaba是一个微服务基础框架，它本身具备一定的微服务治理的能力，比如分布式服务治理、分布式配置治理、分布式流量治理、分布式事务、分布式网关、分布式消息治理等。如果项目直接使用Spring Cloud Alibaba提供的功能，完全可以满足中等项目的微服务开发的业务场景，开发人员只需要熟悉Spring Cloud Alibaba就可以成为一个微服务领域的开发专家。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，既然是微服务基础框架，它还可以扩展自身的没有的微服务治理能力，比如Skywalking、Discovery、ShardingSphere、DataX等。Spring Cloud Alibaba是基于Spring Boot的思想来设计的，Spring Boot又是基于Spring Framework来设计的，也就是说凡是Spring Framework生态的技术栈，Spring Cloud Alibaba均可以扩展。这样无论是开源社区提供的微服务技术能力，还是公司自研的微服务技术能力，都可以被Spring Cloud Alibaba引入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，Spring Cloud Alibaba是Spring Cloud的超集，它具备Spring Cloud整个微服务生态系统的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结，Spring Cloud Alibaba绝对是微服务架构领域的巨无霸，通过它开发人员可以快速的搭建高可用、高稳定性和高性能的微服务架构。在搭建的过程中，还会驱动开发人员去扩展Spring Cloud Alibaba还不支持的微服务技术。Spring Cloud Alibaba是让开发人员入门和进阶微服务架构的一步到位的最佳选择，通过它开发人员可以快速的熟悉微服务架构的全栈支撑技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;本公众号文章，全部是自己一手原创的，希望朋友们多多关注本人的公众号。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bdf6b3ca7bc21521224d18091067bcff</guid>
<title>优质网站同好者周刊（第 49 期）- 倾城之链 - 悠然宜想亭</title>
<link>https://toutiao.io/k/enw1a6g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Post-body&quot;&gt;
                    &lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot; rel=&quot; nofollow ugc&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot; rel=&quot; nofollow ugc&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot; rel=&quot; nofollow ugc&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot; rel=&quot; nofollow ugc&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot; rel=&quot; nofollow ugc&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E7%A4%BE%E5%8C%BA&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;社区&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%88%86%E4%BA%AB&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;分享&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Wiki&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;Wiki&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;且夫天地之间，物各有主，苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭。是造物者之无尽藏也，而吾与子之所共适。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/wiki.lovejade.cn.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - 清风明月阁&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://wiki.lovejade.cn/&quot; rel=&quot; nofollow ugc&quot;&gt;清风明月阁&lt;/a&gt;，基于 &lt;a href=&quot;https://nicelinks.site/post/61a334f7465c2155e2d15886&quot; rel=&quot; nofollow ugc&quot;&gt;Wiki&lt;/a&gt; 搭建的 Web 应用，名字取自：“惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色”。年与时驰，意与岁去，念其功能之丰盈，特在此：记余之所造，录吾之所闻，享愚之所学，载我之随感.....人生漫短，白首时回顾，堪凭这些许文字以自怜。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;初衷&lt;/strong&gt;：早先搭建的十余个网站，有些实属为体验「&lt;a href=&quot;https://nicelinks.site/tags/%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%99%A8&quot; rel=&quot; nofollow ugc&quot;&gt;网站构建工具&lt;/a&gt;」而起；岁月蹉跎中折腾多了，那种兴之所至、行之所往的冲动，早已隐去；而今，却又“重蹈覆辙”，实在是感念 &lt;a href=&quot;https://nicelinks.site/post/61a334f7465c2155e2d15886&quot; rel=&quot; nofollow ugc&quot;&gt;Wiki.js&lt;/a&gt; 之强大，一时为其蕴藏的「哲思」所着迷；一直以来呢，也在探索文档、Wiki 最佳撰写工具；而前段时间，又恰巧购得云服务器一台；这好奇的念头，与适宜的环境，结合的恰到好处，于是，便有了&lt;a href=&quot;https://wiki.lovejade.cn/zh/&quot; rel=&quot; nofollow ugc&quot;&gt;“清风明月阁”&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/61e96fec3bc51624375150aa&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - 清风明月阁&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/AI&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;AI&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B7%A5%E5%85%B7&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;工具&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%8A%A8%E7%94%BB&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;动画&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：Motion Capture, 3D Animation, AI Animation, AI Motion Capture, Mocap, Animation Software, Motion Tracking&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Plask is a browser-based AI motion capture tool and animation editor. With any camera, creators can digitize their movements, automate animation work, collaborate with colleagues, and export them all on one platform.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/plask.ai.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Plask&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://plask.ai/&quot; rel=&quot; nofollow ugc&quot;&gt;Plask&lt;/a&gt;，一款基于浏览器的免费 AI 动作捕捉和动画工具。只需在网络摄像头上录制视频。智能 AI 将为您捕捉动作，让动画变得轻而易举。使用 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://plask.ai/&quot; rel=&quot; nofollow ugc&quot;&gt;Plask&lt;/a&gt; 基于浏览器的编辑工具编辑您的动画，只需一处即可找到所有必要工具，让您的动画完美无缺。&lt;a href=&quot;https://nicelinks.site/redirect?url=https://plask.ai/&quot; rel=&quot; nofollow ugc&quot;&gt;Plask&lt;/a&gt; 支持您直接在浏览器中共享、查看和协作。使用 Plask 在浏览器中管理您的想法和项目。无论您是单独工作还是与团队合作，它都可以无缝集成到您的工作流程中。它支持大多数专业文件格式，包括 GLB、FBX、BVH 等。每个人的动画，为每个人服务，使用 &lt;code&gt;Plask&lt;/code&gt;，专业质量的工具唾手可得！&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/61e960713bc51624375150a8&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Plask&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/SVG&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;SVG&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%9B%BE%E7%89%87&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;图片&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%AE%BE%E8%AE%A1&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;设计&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;SVG Wave is a minimal svg wave generator with lot of customization. It lets you abiltiy to generate and export pngs and svgs of beautiful waves. SVG wave also lets you layer multiple waves. Create SVGs for your website designs.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/svgwave.in.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Svg Wave - A free &amp;amp; beautiful gradient SVG wave Generator.&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://svgwave.in/&quot; rel=&quot; nofollow ugc&quot;&gt;Svg Wave&lt;/a&gt;，一个免费且漂亮的渐变 SVG 波形图生成器。它支持您自由的对波浪 🌊 进行调整，如波浪的高度、图层数量、弯曲度，颜色等等，也支持重制、反转等操作，以便您可以生成自己满意的图形；除此外，&lt;a href=&quot;https://nicelinks.site/redirect?url=https://svgwave.in/&quot; rel=&quot; nofollow ugc&quot;&gt;Svg Wave&lt;/a&gt; 还支持生成波浪动画（只适用于 Chrome 浏览器）；它可以导出 &lt;code&gt;SVG&lt;/code&gt;、&lt;code&gt;PNG&lt;/code&gt; 两种格式。另外值得一提的是，&lt;a href=&quot;https://nicelinks.site/redirect?url=https://svgwave.in/&quot; rel=&quot; nofollow ugc&quot;&gt;Svg Wave&lt;/a&gt; 这个网站设计的干净、清爽，看着令人颇为舒适。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/61e95a223bc51624375150a6&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Svg Wave - A free &amp;amp; beautiful gradient SVG wave Generator.&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E8%A7%86%E9%A2%91&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;视频&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%B4%A0%E6%9D%90&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;素材&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%B5%84%E6%BA%90&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;资源&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Download Free Stock Video Footage, Stock Music &amp;amp; Premiere Pro Templates for your next video editing project. All assets can be downloaded for free!&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/mixkit.co.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Mixkit - Awesome free assets for your next video project&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://mixkit.co/&quot; rel=&quot; nofollow ugc&quot;&gt;Mixkit&lt;/a&gt;，为您的下一个视频项目提供很棒的&lt;strong&gt;免费&lt;/strong&gt;资源，如：视频剪辑、库存音乐（100 多个免费的 Ambient Stock 音乐曲目。从梦幻般的背景音乐到大气、郁郁葱葱的器乐，用我们的环境音乐曲目之一设定完美的基调。）、声音效果和视频模板。他们精心策划了一些世界上最有才华的创作者的剪辑、曲调和模板，所有内容都是免费提供的。&lt;a href=&quot;https://nicelinks.site/redirect?url=https://mixkit.co/&quot; rel=&quot; nofollow ugc&quot;&gt;Mixkit&lt;/a&gt; 的免费图书馆正在快速增长，每周都有新的视频资产被添加进来，你总能找到完美的高质量项目来下载，并在你的项目中使用。您可以根据需要下载视频、声音和模板，无需署名或注册。如果您从事或有意愿从事视频相关内容创造，&lt;a href=&quot;https://nicelinks.site/redirect?url=https://mixkit.co/&quot; rel=&quot; nofollow ugc&quot;&gt;Mixkit&lt;/a&gt; 是您非常值得关注的网站。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/61e82e723bc516243751509d&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Mixkit - Awesome free assets for your next video project&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/JavaScript&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;JavaScript&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Framework&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;Framework&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;评论系统&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;一款基于 Valine 衍生的简洁、安全的评论系统。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/waline.js.org.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Waline | Waline&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://waline.js.org/&quot; rel=&quot; nofollow ugc&quot;&gt;Waline&lt;/a&gt;，一款基于 Valine 衍生的简洁、安全的评论系统。可以将 Waline 等价成 With backend Valine。它具有以下功能特征：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;自由评论&lt;/strong&gt;：完全的 Markdown 支持，同时包含表情、数学公式、HTML 嵌入；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;轻量&lt;/strong&gt;：54kB gzip 的完整客户端大小；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强大的安全性&lt;/strong&gt;：内容校验、防灌水、保护敏感数据等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;登录支持&lt;/strong&gt;：在允许匿名评论的基础上，支持账号注册，保持身份；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完全免费部署&lt;/strong&gt;：可免费部署在 Vercel 上；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;易于部署&lt;/strong&gt;：多种部署部署方式和存储服务支持。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;除了以上特征外，&lt;a href=&quot;https://nicelinks.site/redirect?url=https://waline.js.org/&quot; rel=&quot; nofollow ugc&quot;&gt;Waline&lt;/a&gt; 已经完成非常多优质功能，诸如：邮件（ 微信、 QQ、Telegram）通知，评论管理、评论删除、登录支持、Akismet、文章统计、多语言同步、基于 IP 的发布评论频率限制、 IP 黑名单、 重复内容检测、置顶评论、其它数据库支持（已支持 LeanCloud, MySQL, MongoDB, SQLite, PostgreSQL, CloudBase, Deta, 轻服务, GitHub）等等。最值得一提的是，它支持&lt;strong&gt;独立部署&lt;/strong&gt;，您可以基于 &lt;a href=&quot;https://nicelinks.site/post/5b7036890f8719053c094d68&quot; rel=&quot; nofollow ugc&quot;&gt;Docker&lt;/a&gt;（docker-compose 或 Node），部署在自己的服务器上。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/61e6e0783bc516243751509b&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Waline | Waline&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; title=&quot;&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;本期文末寄语&lt;/h2&gt;

&lt;p&gt;我曾七次鄙视自己的灵魂： 第一次，&lt;strong&gt;当它本可进取时，却故作谦卑&lt;/strong&gt;； 第二次，&lt;strong&gt;当它在空虚时，用爱欲来填充&lt;/strong&gt;； 第三次，&lt;strong&gt;在困难和容易之间，它选择了容易&lt;/strong&gt;； 第四次，&lt;strong&gt;它犯了错，却借由别人也会犯错来宽慰自己&lt;/strong&gt;； 第五次，它自由软弱，却把它认为是生命的坚韧； 第六次，&lt;strong&gt;当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副&lt;/strong&gt;； 第七次，&lt;strong&gt;它侧身于生活的污泥中，虽不甘心，却又畏首畏尾&lt;/strong&gt;。 ── 黎巴嫩裔美国诗人、画家 · 纪伯伦《我曾七次鄙视自己的灵魂》&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/300/h/300/interlace/1/ignore-error/1&quot; title=&quot;&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;您可能感兴趣的文章&lt;/h3&gt;



                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0fcfc303178e7a337775d94596e8d502</guid>
<title>超实用教程！一探Golang怎样践行Clean Architecture？</title>
<link>https://toutiao.io/k/4a3bgsg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                                    


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe977Xa5zfy5iaV3agpS11Cqm4psjPOibic6BZSicnBFh6uWzCFp3uqN5R114Fq85DmuCzdL3eESlQ37bFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;导语 |&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;由于golang不像java一样有一个统一的编码模式，并且在同一个组中，不同项目分包可能也不尽相同，所以这篇文章主要借鉴一下clean architecture思想来归纳一下我理想中项目应该怎么规范分包与分层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;引言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;鉴于golang不像java一样有一个统一的编码模式，所以我们和其他团队一样，采用了&lt;/span&gt;&lt;span&gt;Go面向包的设计和架构分层中&lt;/span&gt;&lt;span&gt;介绍的一些理论，然后再结合以往的项目经验来进行分包：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;├── cmd/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   └── main.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;├── etc&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   └── dev_conf.yaml              &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;├── global&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   └── global.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;├── internal/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│       └── service/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│           └── xxx_service.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│           └── xxx_service_test.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│       └── model/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│           └── xxx_info.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│       └── api/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│           └── xxx_api.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│       └── router/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│           └── router.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│       └── pkg/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│           └── datetool&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│           └── jsontool&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;99138864bfd8cedf2d8d3c5a77767838&quot;&gt;&lt;span&gt;其实上面的这个划分只是简单的将功能分了一下包，在项目实践的过程中还是有很多问题。比如：&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;86e2842d8fe330c643b7fd990e681b5a&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;86e2842d8fe330c643b7fd990e681b5a&quot;&gt;&lt;span&gt;对于功能实现我是通过function的参数传递还是通过结构体的变量传递？&lt;/span&gt;&lt;span&gt;使用一个数据库的全局变量引用传递是否安全？&lt;/span&gt;&lt;span&gt;是否存在过度耦合？&lt;/span&gt;&lt;span&gt;在代码实现过程中几乎全部都是依赖于实现，而不是依赖于接口，那么将MySQL切换为MongDB是不是要修改所有的实现？&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;d90b8cb901f69272e23f56afa97fc03b&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;d90b8cb901f69272e23f56afa97fc03b&quot;&gt;&lt;span&gt;所以现在在我们工作中随着代码越来越多，代码中各种init，function，struct，全局变量感觉也越来越乱。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;e641b52b9698d34ce9932b432afc8971&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;e641b52b9698d34ce9932b432afc8971&quot;&gt;&lt;span&gt;每个模块不独立，看似按逻辑分了模块，但没有明确的上下层关系，数据流的流向和逻辑也不明确，很难看清代码调用情况。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;e3f4eca9446b3600983b89dcac42ac46&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;e3f4eca9446b3600983b89dcac42ac46&quot;&gt;&lt;span&gt;不过就像《重构》中所说：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;先让代码工作起来-如果代码不能工作，就不能产生价值；然后再试图将它变好-通过对代码进行重构，让我们自己和其他人更好地理解代码，并能按照需求不断地修改代码&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;268dab3b3984121780ba9dc87aab3b90&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;268dab3b3984121780ba9dc87aab3b90&quot;&gt;&lt;span&gt;所以我觉得是时候自我改变一下。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;268dab3b3984121780ba9dc87aab3b90&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;268dab3b3984121780ba9dc87aab3b90&quot;&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、The Clean Architecture&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在简洁架构里面对我们的项目提出了&lt;/span&gt;&lt;span&gt;几点要求：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7344559585492227&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe954kMf12fcrtkLCa6ricGr24FEPzBBp0vibEPen7dBqVcKFEn81OSuUxKicslCAiby8orAAaE59Id6GrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;772&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;625b2675a4aa047cc13f17b7ff3da999&quot;&gt;&lt;span&gt;上图中同心圆代表各种不同领域的软件。一般来说，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;越深入代表你的软件层次越高&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;外圆是战术实现机制，内圆的是战略核心策略&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;a4784b3da22d123ff625ff76c2db3a48&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;a4784b3da22d123ff625ff76c2db3a48&quot;&gt;&lt;span&gt;对于我们的项目来说，代码依赖应该由外向内，单向单层依赖，这种依赖包含代码名称，或类的函数，变量或任何其他命名软件实体。&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;472b035d9d30b4682f277f6eaeefaea0&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;472b035d9d30b4682f277f6eaeefaea0&quot;&gt;&lt;span&gt;对于简洁架构来说分为了&lt;/span&gt;&lt;span&gt;&lt;strong&gt;四层&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;05f249907cb9c9326ee85152fff8620a&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;05f249907cb9c9326ee85152fff8620a&quot;&gt;&lt;span&gt;那么对于我的项目来说，参考了&lt;/span&gt;&lt;span&gt;trpc-go&lt;/span&gt;&lt;span&gt;的代码分层，将我的项目也分为了四层：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5564516129032258&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe954kMf12fcrtkLCa6ricGr24YbuYfiaKgeIzaAjp4hXQLZicVxnaoz4s1kVT8keNX3K28XrF0AGOgu9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;3acf39c3b75624d47945405a558d1b0b&quot;&gt;&lt;span&gt;&lt;strong&gt;（一）models&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;06cc97ed600eddb1307601f796015f60&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;06cc97ed600eddb1307601f796015f60&quot;&gt;&lt;span&gt;封装了各种实体类对象，与数据库交互的、与UI交互的等等，任何的实体类都应该放在这里。如：&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;06cc97ed600eddb1307601f796015f60&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;time&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; Article &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ID        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;     &lt;span class=&quot;code-snippet__string&quot;&gt;`json:&quot;id&quot;`&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Title     &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;`json:&quot;title&quot;`&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Content   &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;`json:&quot;content&quot;`&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  UpdatedAt time.Time &lt;span class=&quot;code-snippet__string&quot;&gt;`json:&quot;updated_at&quot;`&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  CreatedAt time.Time &lt;span class=&quot;code-snippet__string&quot;&gt;`json:&quot;created_at&quot;`&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;60189a3e6850d14a4aeffa50f71a8cb6&quot;&gt;&lt;span&gt;&lt;strong&gt;（二）repo&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;3a3dd1ed619db5004a7e6a7af3e821e3&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;3a3dd1ed619db5004a7e6a7af3e821e3&quot;&gt;&lt;span&gt;这里存放的是数据库操作类，数据库CRUD都在这里。需要注意的是，这里不包含任何的业务逻辑代码，很多同学喜欢将业务逻辑也放到这里。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;f085a762de5b8ae3119be2d7f79fd899&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;f085a762de5b8ae3119be2d7f79fd899&quot;&gt;&lt;span&gt;如果使用ORM，那么这里放入的ORM操作相关的代码；如果使用微服务，那么这里放的是其他服务请求的代码。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;f085a762de5b8ae3119be2d7f79fd899&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;b6e6792b538a4767e82ed41d0233aac5&quot;&gt;&lt;span&gt;&lt;strong&gt;（三）service&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;c252579ebcc819fcc1bd513bb314ed9f&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;c252579ebcc819fcc1bd513bb314ed9f&quot;&gt;&lt;span&gt;这里是业务逻辑层，所有的业务过程处理代码都应该放在这里。这一层会决定是请求repo层的什么代码，是操作数据库还是调用其他服务；所有的业务数据计算也应该放在这里；这里接受的入参应该是controller传入的。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;c252579ebcc819fcc1bd513bb314ed9f&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;c252579ebcc819fcc1bd513bb314ed9f&quot;&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;017b75728cd42c046548fea973d4933e&quot;&gt;&lt;span&gt;&lt;strong&gt;（四）api&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;cb4def08f56cac33130532b4fb3c41e7&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;cb4def08f56cac33130532b4fb3c41e7&quot;&gt;&lt;span&gt;这里是接收外部请求的代码，如：gin对应的handler、gRPC、其他REST API框架接入层等等。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;cb4def08f56cac33130532b4fb3c41e7&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;cb4def08f56cac33130532b4fb3c41e7&quot;&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、面向接口编程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-lines=&quot;1&quot; data-sign=&quot;0b2d5baf9daf1150f56e7915e55b9b17&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;26adffbb8cc3ab22afb1827e3b48be3e&quot;&gt;&lt;span&gt;除了models层，层与层之间应该通过接口交互，而不是实现。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;如果要用service调用repo层，那么应该调用repo的接口&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。那么修改底层实现的时候我们上层的基类不需要变更，只需要更换一下底层实现即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;c7240c8c4741f67e47423b8c8d887232&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;c7240c8c4741f67e47423b8c8d887232&quot;&gt;&lt;span&gt;例如我们想要将所有文章查询出来，那么可以在repo提供这样的接口：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;package&lt;/span&gt; repo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;context&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/models&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;time&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; IArticleRepo &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Fetch(ctx context.Context, createdDate time.Time, num &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;) (res []models.Article, err error)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个接口的实现类就可以根据需求变更，比如说当我们想要mysql来作为存储查询，那么只需要提供一个这样的基类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; mysqlArticleRepository &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  DB *gorm.DB&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;NewMysqlArticleRepository&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(DB *gorm.DB)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;IArticleRepo&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &amp;amp;mysqlArticleRepository{DB}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(m *mysqlArticleRepository)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Fetch&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context, createdDate time.Time,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  num &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(res []models.Article, err error)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  err = m.DB.WithContext(ctx).Model(&amp;amp;models.Article{}).&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Select(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;id,title,content, updated_at, created_at&quot;&lt;/span&gt;).&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Where(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;created_at &amp;gt; ?&quot;&lt;/span&gt;, createdDate).Limit(num).Find(&amp;amp;res).Error&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;4e5f9e740d0ae8ed1007bae27bafaf67&quot;&gt;&lt;span&gt;如果改天想要换成MongoDB来实现我们的存储，那么只需要定义一个结构体实现IArticleRepo接口即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;01f21d325cfa52b0bd4f9b8a2de2aa38&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;01f21d325cfa52b0bd4f9b8a2de2aa38&quot;&gt;&lt;span&gt;那么在service层实现的时候就可以按照我们的需求来将对应的repo实现注入即可，从而不需要改动service层的实现：&lt;/span&gt;&lt;/p&gt;&lt;pre/&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; articleService &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  articleRepo repo.IArticleRepo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;NewArticleService&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(a repo.IArticleRepo)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;IArticleService&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &amp;amp;articleService{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    articleRepo: a,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(a *articleService)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Fetch&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context, createdDate time.Time, num &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(res []models.Article, err error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; num == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    num = &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  res, err = a.articleRepo.Fetch(ctx, createdDate, num)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;, err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;三、依赖注入DI&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;836a083fc64895e12f30067a719437e5&quot;&gt;&lt;span&gt;依赖注入，英文名dependency injection，简称DI。DI以前在java工程里面经常遇到，但是在go里面很多人都说不需要，但是我觉得在大型软件开发过程中还是有必要的，否则只能通过全局变量或者方法参数来进行传递。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;fe90f6d64f3586ebf8fd465c680a90bd&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;fe90f6d64f3586ebf8fd465c680a90bd&quot;&gt;&lt;span&gt;至于具体什么是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;DI&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，简单来说就是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;被依赖的模块&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，在&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;创建模块时，被注入到（即当作参数传入）模块的里面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。想要更加深入的了解什么是DI这里再推荐一下&lt;/span&gt;&lt;span&gt;Dependency injection&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Inversion of Control Containers and the Dependency Injection pattern&lt;/span&gt;&lt;span&gt;这两篇文章。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;82f3cde3fa91049d419b63991bf17edb&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;82f3cde3fa91049d419b63991bf17edb&quot;&gt;&lt;span&gt;如果不用DI主要有两大不方便的地方，一个是底层类的修改需要修改上层类，在大型软件开发过程中基类是很多的，一条链路改下来动辄要修改几十个文件；另一方面就是就是层与层之间单元测试不太方便。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;dafbacddebab5e6d48a75ce959ca9d41&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;dafbacddebab5e6d48a75ce959ca9d41&quot;&gt;&lt;span&gt;因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的new，比如我们的项目中需要这样：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/api&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/api/handlers&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/app&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/repo&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/service&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  db := app.InitDB() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  repository := repo.NewMysqlArticleRepository(db)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  articleService := service.NewArticleService(repository)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  handler := handlers.NewArticleHandler(articleService)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  router := api.NewRouter(handler)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  engine := app.NewGinEngine()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  server := app.NewServer(engine, router)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  server.Start()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;2d6321a7fc713fa385f4f58b4eed2786&quot;&gt;&lt;span&gt;那么对于这么一段代码，我们有没有办法不用自己写呢？这里我们就可以借助框架的力量来生成我们的注入代码。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;70b077ce28182035eb095bbe0f553325&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;70b077ce28182035eb095bbe0f553325&quot;&gt;&lt;span&gt;在go里面DI的工具相对来说没有java这么方便，技术框架一般主要有：wire、dig、fx等。由于wire是使用代码生成来进行注入，性能会比较高，并且它是google推出的DI框架，所以我们这里使用wire进行注入。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;689ebf67ad75746035047bf7d667fc90&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;689ebf67ad75746035047bf7d667fc90&quot;&gt;&lt;span&gt;wire的要求很简单，新建一个wire.go文件（文件名可以随意），创建我们的初始化函数。比如，我们要创建并初始化一个server对象，我们就可以这样：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package main&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;github.com/google/wire&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/api&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/api/handlers&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/app&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/repo&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/service&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;InitServer&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; *app.&lt;span class=&quot;code-snippet__type&quot;&gt;Server&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  wire.&lt;span class=&quot;code-snippet__type&quot;&gt;Build&lt;/span&gt;(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    app.&lt;span class=&quot;code-snippet__type&quot;&gt;InitDB&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    repo.&lt;span class=&quot;code-snippet__type&quot;&gt;NewMysqlArticleRepository&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    service.&lt;span class=&quot;code-snippet__type&quot;&gt;NewArticleService&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    handlers.&lt;span class=&quot;code-snippet__type&quot;&gt;NewArticleHandler&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    api.&lt;span class=&quot;code-snippet__type&quot;&gt;NewRouter&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    app.&lt;span class=&quot;code-snippet__type&quot;&gt;NewServer&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    app.&lt;span class=&quot;code-snippet__type&quot;&gt;NewGinEngine&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &amp;amp;app.&lt;span class=&quot;code-snippet__type&quot;&gt;Server&lt;/span&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;09f5eba2114aefcccfb2a1d5d44b6dc2&quot;&gt;&lt;span&gt;需要注意的是，第一行的注解：+build wireinject，表示这是一个注入器。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;09f5eba2114aefcccfb2a1d5d44b6dc2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;433dda338673226f15280885d584e693&quot;&gt;&lt;span&gt;在函数中，我们调用wire.Build()将创建Server所依赖的类型的构造器传进去。写完wire.go文件之后执行wire命令，就会自动生成一个wire_gen.go文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/api&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/api/handlers&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/app&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/repo&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my-clean-rchitecture/service&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;InitServer&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;code-snippet__title&quot;&gt;Server&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  engine := app.NewGinEngine()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  db := app.InitDB()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  iArticleRepo := repo.NewMysqlArticleRepository(db)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  iArticleService := service.NewArticleService(iArticleRepo)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  articleHandler := handlers.NewArticleHandler(iArticleService)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  router := api.NewRouter(articleHandler)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  server := app.NewServer(engine, router)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; server&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到wire自动帮我们生成了InitServer方法，此方法中依次初始化了所有要初始化的基类。之后在我们的main函数中就只需调用这个InitServer即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;main&lt;/span&gt;() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attribute&quot;&gt;server &lt;/span&gt;:= &lt;span class=&quot;code-snippet__built_in&quot;&gt;InitServer&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  server.&lt;span class=&quot;code-snippet__built_in&quot;&gt;Start&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;四、测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-lines=&quot;1&quot; data-sign=&quot;201be8a65b8069170f3f773c661fa024&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;0b2fd1f85f65171fc21066392f559907&quot;&gt;&lt;span&gt;在上面我们定义好了每一层应该做什么，那么对于每一层我们应该都是可单独测试的，即使另外一层不存在。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;1ed80d9c07906c63bf6d2cf54fdb4507&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;1ed80d9c07906c63bf6d2cf54fdb4507&quot;&gt;&lt;span&gt;由于我们是通过github.com/golang/mock/gomock来进行mock，所以需要执行一下代码生成，生成的mock代码我们放入到mock包中：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mockgen -destination .\mock\repo_mock.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; -source .\repo\repo.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; -&lt;span class=&quot;code-snippet__keyword&quot;&gt;package&lt;/span&gt; mock&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mockgen -destination .\mock\service_mock.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; -source .\service\service.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; -&lt;span class=&quot;code-snippet__keyword&quot;&gt;package&lt;/span&gt; mock&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;e5d83c1af1fccfd31da19dc8752102bb&quot;&gt;&lt;span&gt;上面这两个命令会通过接口帮我自动生成mock函数。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;e5d83c1af1fccfd31da19dc8752102bb&quot;&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;83bd12c00726d030005d585d7ee65df1&quot;&gt;&lt;span&gt;&lt;strong&gt;（一）repo层测试&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;95858338fb3665d2c393d3452dc54671&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;95858338fb3665d2c393d3452dc54671&quot;&gt;&lt;span&gt;在项目中，由于我们用了gorm来作为我们的orm库，所以我们需要使用github.com/DATA-DOG/go-sqlmock结合gorm来进行mock：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getSqlMock&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(mock sqlmock.Sqlmock, gormDB *gorm.DB)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; err error&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; db *sql.DB&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  db, mock, err = sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;panic&lt;/span&gt;(err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  gormDB, err = gorm.Open(mysql.New(mysql.Config{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SkipInitializeWithVersion: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Conn:                      db,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }), &amp;amp;gorm.Config{})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; != err {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    log.Fatalf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Init DB with sqlmock failed, err %v&quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Test_mysqlArticleRepository_Fetch&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  createAt := time.Now()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  updateAt := time.Now()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; articles = []models.Article{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;test1&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;content&quot;&lt;/span&gt;, updateAt, createAt},&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;test2&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;content2&quot;&lt;/span&gt;, updateAt, createAt},&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  limit := &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  mock, db := getSqlMock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  mock.ExpectQuery(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;SELECT id,title,content, updated_at, created_at FROM `articles` WHERE created_at &amp;gt; ? LIMIT 2&quot;&lt;/span&gt;).&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    WithArgs(createAt).&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    WillReturnRows(sqlmock.NewRows([]&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;{&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;id&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;title&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;content&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;updated_at&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;created_at&quot;&lt;/span&gt;}).&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      AddRow(articles[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;].ID, articles[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;].Title, articles[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;].Content, articles[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;].UpdatedAt, articles[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;].CreatedAt).&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      AddRow(articles[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;].ID, articles[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;].Title, articles[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;].Content, articles[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;].UpdatedAt, articles[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;].CreatedAt))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  repository := NewMysqlArticleRepository(db)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  result, err := repository.Fetch(context.TODO(), createAt, limit)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  assert.Nil(t, err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  assert.Equal(t, articles, result)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;d6df771e192edc440faee06058bcf2ec&quot;&gt;&lt;span&gt;&lt;strong&gt;（二）service层测试&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;5cf314a284b726115b47dd52400f4dcd&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;5cf314a284b726115b47dd52400f4dcd&quot;&gt;&lt;span&gt;这里主要就是用我们gomock生成的代码来mock repo层：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Test_articleService_Fetch&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;t&lt;/span&gt; *&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.T&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attribute&quot;&gt;ctl &lt;/span&gt;:= gomock.&lt;span class=&quot;code-snippet__built_in&quot;&gt;NewController&lt;/span&gt;(t)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  defer ctl.&lt;span class=&quot;code-snippet__built_in&quot;&gt;Finish&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  now := time.&lt;span class=&quot;code-snippet__built_in&quot;&gt;Now&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  mockRepo := mock.&lt;span class=&quot;code-snippet__built_in&quot;&gt;NewMockIArticleRepo&lt;/span&gt;(ctl)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  gomock.&lt;span class=&quot;code-snippet__built_in&quot;&gt;InOrder&lt;/span&gt;(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mockRepo.EXPECT().&lt;span class=&quot;code-snippet__built_in&quot;&gt;Fetch&lt;/span&gt;(context.TODO(), now, &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;).&lt;span class=&quot;code-snippet__built_in&quot;&gt;Return&lt;/span&gt;(nil, nil),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  service := &lt;span class=&quot;code-snippet__built_in&quot;&gt;NewArticleService&lt;/span&gt;(mockRepo)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fetch, _ := service.&lt;span class=&quot;code-snippet__built_in&quot;&gt;Fetch&lt;/span&gt;(context.TODO(), now, &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fmt.&lt;span class=&quot;code-snippet__built_in&quot;&gt;Println&lt;/span&gt;(fetch)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;39b83e364f86c400c7453010b5029128&quot;&gt;&lt;span&gt;&lt;strong&gt;（三）api层测试&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6f3f5a8464a73c567109b22115dc1ee7&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6f3f5a8464a73c567109b22115dc1ee7&quot;&gt;&lt;span&gt;对于这一层，我们不仅要mock service层，还需要发送httptest来模拟请求发送：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TestArticleHandler_FetchArticle&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ctl := gomock.NewController(t)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; ctl.Finish()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  createAt, _ := time.Parse(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;2006-01-02&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;2021-12-26&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  mockService := mock.NewMockIArticleService(ctl)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  gomock.InOrder(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mockService.EXPECT().Fetch(gomock.Any(), createAt, &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;).Return(&lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  article := NewArticleHandler(mockService)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  gin.SetMode(gin.TestMode)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  r := gin.Default()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  r.GET(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/articles&quot;&lt;/span&gt;, article.FetchArticle)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  req, err := http.NewRequest(http.MethodGet, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/articles?num=10&amp;amp;create_date=2021-12-26&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    t.Fatalf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Couldn&#x27;t create request: %v\n&quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  w := httptest.NewRecorder()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  r.ServeHTTP(w, req)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; w.Code != http.StatusOK {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    t.Fatalf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Expected to get status %d but instead got %d\n&quot;&lt;/span&gt;, http.StatusOK, w.Code)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;五、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;9305dd9f632630c16fc56ba9a7a54e16&quot;&gt;&lt;span&gt;以上就是我对golang的项目中发现问题的一点点总结与思考，思考的先不管对不对，总归是解决了我们当下的一些问题。不过，项目总归是需要不断重构完善的，所以下次有问题的时候下次再改呗。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;25f3aea7e8f60952cc14039b790e0e8b&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;25f3aea7e8f60952cc14039b790e0e8b&quot;&gt;&lt;span&gt;对于我上面的总结和描述感觉有不对的地方，请随时指出来一起讨论。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;dca4608149a8e9389911c7fd0308d2fc&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;dca4608149a8e9389911c7fd0308d2fc&quot;&gt;&lt;span&gt;项目代码位置：&lt;/span&gt;&lt;span&gt;https://github.com/devYun/go-clean-architecture&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;dca4608149a8e9389911c7fd0308d2fc&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;dca4608149a8e9389911c7fd0308d2fc&quot;&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;dca4608149a8e9389911c7fd0308d2fc&quot;&gt;&lt;span&gt;1.The Clean Architecture&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;dca4608149a8e9389911c7fd0308d2fc&quot;&gt;&lt;span&gt;2.bxcodec&lt;/span&gt;&lt;span&gt;/go-clean-arch&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;dca4608149a8e9389911c7fd0308d2fc&quot;&gt;&lt;span&gt;3.Trying Clean Architecture on Golang&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;dca4608149a8e9389911c7fd0308d2fc&quot;&gt;&lt;span&gt;4.理解一下依赖注入，以及如何用wire&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;105&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;107&quot; data-fileid=&quot;100044396&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe954kMf12fcrtkLCa6ricGr24n5P6ciacmQhd6Bb7d7ZWKc0ia7s6b3XZ82ERK6Lic07SfEBwTuicUILPnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;罗志赟&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯后台开发工程师&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯后台开发工程师，负责IEG游戏推荐相关后端业务，深入研究过Go runtime相关代码，喜欢专研技术细节，探索技术中有趣的实践分享给大家。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247532481&amp;amp;idx=1&amp;amp;sn=acd788f649593e2e06a9fd355aa37a52&amp;amp;chksm=eaa86591dddfec871a95fde6f16db61e96e40094794140953f0ddea62480b333e0f67f9d920e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;高并发场景下，6种方案，保证缓存和数据库的最终一致性！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;高并发场景下，6种方案，保证缓存和数据库的最终一致性！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247532357&amp;amp;idx=1&amp;amp;sn=84088fd7cc97b36a2d93986591b3a41c&amp;amp;chksm=eaa86515dddfec0388340a6132315dedfa82ee1dcb4f4b4e2d057ad4f297c286eb468f0e4f7a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;颠覆Kafka的统治，新一代云原生消息系统Pulsar震撼来袭！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;颠覆Kafka的统治，新一代云原生消息系统Pulsar震撼来袭！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247532240&amp;amp;idx=1&amp;amp;sn=bb7e1b07f9eef04f074bd32305a7d9f1&amp;amp;chksm=eaa86480dddfed968078a46456d86586cb78ab6a91ea8e28f36c5a09c5a5e1c72eaca804b235&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;七年激荡！Serverless的下一站将去往何方？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;七年激荡！Serverless的下一站将去往何方？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247532236&amp;amp;idx=1&amp;amp;sn=98558d0331d44be6b9385e8b40aa957c&amp;amp;chksm=eaa8649cdddfed8a278d3fe8e6975982d6b34f7e0127af85c505c96d6a86c2f461d43e71c901&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基于流计算Oceanus和Elasticsearch Service构建百亿级实时监控系统&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;基于流计算Oceanus和Elasticsearch Service构建百亿级实时监控系统&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI2NDU4OTExOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96FK2eEg86vUicOR3n6kAHk1PHvTb8VBicYk0RmNQYsQyibgg8iaZqT0bCEU9VKo3Z3iceoQfgycyMpKWQ/0?wx_fmt=png&quot; data-nickname=&quot;云加社区&quot; data-alias=&quot;QcloudCommunity&quot; data-signature=&quot;腾讯云官方社区公众号，汇聚技术开发者群体，分享技术干货，打造技术影响力交流社区。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.59375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe977Xa5zfy5iaV3agpS11Cqm4xV7ckfbmtFLyUjFID2k7yO4q8hvB4OqYoNkARZ2xuvzKvMtnmVN2BQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>58d02a2fb19a797ca1e5ce3464a65bf5</guid>
<title>聊聊Netty那些事儿之从内核角度看IO模型</title>
<link>https://toutiao.io/k/kn9asp3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们来聊聊Netty的那些事儿，我们都知道Netty是一个高性能异步事件驱动的网络框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的设计异常优雅简洁，扩展性高，稳定性强。拥有非常详细完整的用户文档。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时内置了很多非常有用的模块基本上做到了开箱即用，用户只需要编写短短几行代码，就可以快速构建出一个具有&lt;code&gt;高吞吐&lt;/code&gt;，&lt;code&gt;低延时&lt;/code&gt;，&lt;code&gt;更少的资源消耗&lt;/code&gt;，&lt;code&gt;高性能（非必要的内存拷贝最小化）&lt;/code&gt;等特征的高并发网络应用程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们来探讨下支持Netty具有&lt;code&gt;高吞吐&lt;/code&gt;，&lt;code&gt;低延时&lt;/code&gt;特征的基石----netty的&lt;code&gt;网络IO模型&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由Netty的&lt;code&gt;网络IO模型&lt;/code&gt;开始，我们来正式揭开本系列Netty源码解析的序幕：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网络包接收流程&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8943548387096775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEAVqTQC2CLFPicUHhicvVfVnFGUOEwWI1ueTic9xAtwibD0iaGVmSMxkuJcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;网络包收发过程.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当&lt;code&gt;网络数据帧&lt;/code&gt;通过网络传输到达网卡时，网卡会将网络数据帧通过&lt;code&gt;DMA的方式&lt;/code&gt;放到&lt;code&gt;环形缓冲区RingBuffer&lt;/code&gt;中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;RingBuffer&lt;/code&gt;是网卡在启动的时候&lt;code&gt;分配和初始化&lt;/code&gt;的&lt;code&gt;环形缓冲队列&lt;/code&gt;。当&lt;code&gt;RingBuffer满&lt;/code&gt;的时候，新来的数据包就会被&lt;code&gt;丢弃&lt;/code&gt;。我们可以通过&lt;code&gt;ifconfig&lt;/code&gt;命令查看网卡收发数据包的情况。其中&lt;code&gt;overruns&lt;/code&gt;数据项表示当&lt;code&gt;RingBuffer满&lt;/code&gt;时，被&lt;code&gt;丢弃的数据包&lt;/code&gt;。如果发现出现丢包情况，可以通过&lt;code&gt;ethtool命令&lt;/code&gt;来增大RingBuffer长度。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当&lt;code&gt;DMA操作完成&lt;/code&gt;时，网卡会向CPU发起一个&lt;code&gt;硬中断&lt;/code&gt;，告诉&lt;code&gt;CPU&lt;/code&gt;有网络数据到达。CPU调用网卡驱动注册的&lt;code&gt;硬中断响应程序&lt;/code&gt;。网卡硬中断响应程序会为网络数据帧创建内核数据结构&lt;code&gt;sk_buffer&lt;/code&gt;，并将网络数据帧&lt;code&gt;拷贝&lt;/code&gt;到&lt;code&gt;sk_buffer&lt;/code&gt;中。然后发起&lt;code&gt;软中断请求&lt;/code&gt;，通知&lt;code&gt;内核&lt;/code&gt;有新的网络数据帧到达。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;sk_buff&lt;/code&gt;缓冲区，是一个维护网络帧结构的&lt;code&gt;双向链表&lt;/code&gt;，链表中的每一个元素都是一个&lt;code&gt;网络帧&lt;/code&gt;。虽然 TCP/IP 协议栈分了好几层，但上下不同层之间的传递，实际上只需要操作这个数据结构中的指针，而&lt;code&gt;无需进行数据复制&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内核线程&lt;code&gt;ksoftirqd&lt;/code&gt;发现有软中断请求到来，随后调用网卡驱动注册的&lt;code&gt;poll函数&lt;/code&gt;，&lt;code&gt;poll函数&lt;/code&gt;将&lt;code&gt;sk_buffer&lt;/code&gt;中的&lt;code&gt;网络数据包&lt;/code&gt;送到内核协议栈中注册的&lt;code&gt;ip_rcv函数&lt;/code&gt;中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;每个CPU&lt;/code&gt;会绑定&lt;code&gt;一个ksoftirqd&lt;/code&gt;内核线程&lt;code&gt;专门&lt;/code&gt;用来处理&lt;code&gt;软中断响应&lt;/code&gt;。2个 CPU 时，就会有 &lt;code&gt;ksoftirqd/0&lt;/code&gt; 和 &lt;code&gt;ksoftirqd/1&lt;/code&gt;这两个内核线程。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;这里有个事情需要注意下：&lt;/strong&gt; 网卡接收到数据后，当&lt;code&gt;DMA拷贝完成&lt;/code&gt;时，向CPU发出&lt;code&gt;硬中断&lt;/code&gt;，这时&lt;code&gt;哪个CPU&lt;/code&gt;上响应了这个&lt;code&gt;硬中断&lt;/code&gt;，那么在网卡&lt;code&gt;硬中断响应程序&lt;/code&gt;中发出的&lt;code&gt;软中断请求&lt;/code&gt;也会在&lt;code&gt;这个CPU绑定的ksoftirqd线程&lt;/code&gt;中响应。所以如果发现Linux软中断，CPU消耗都&lt;code&gt;集中在一个核上&lt;/code&gt;的话，那么就需要调整硬中断的&lt;code&gt;CPU亲和性&lt;/code&gt;，来将硬中断&lt;code&gt;打散&lt;/code&gt;到&lt;code&gt;不通的CPU核&lt;/code&gt;上去。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;ip_rcv函数&lt;/code&gt;中也就是上图中的&lt;code&gt;网络层&lt;/code&gt;，&lt;code&gt;取出&lt;/code&gt;数据包的&lt;code&gt;IP头&lt;/code&gt;，判断该数据包下一跳的走向，如果数据包是发送给本机的，则取出传输层的协议类型（&lt;code&gt;TCP&lt;/code&gt;或者&lt;code&gt;UDP&lt;/code&gt;)，并&lt;code&gt;去掉&lt;/code&gt;数据包的&lt;code&gt;IP头&lt;/code&gt;，将数据包交给上图中得&lt;code&gt;传输层&lt;/code&gt;处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;传输层的处理函数：&lt;code&gt;TCP协议&lt;/code&gt;对应内核协议栈中注册的&lt;code&gt;tcp_rcv函数&lt;/code&gt;，&lt;code&gt;UDP协议&lt;/code&gt;对应内核协议栈中注册的&lt;code&gt;udp_rcv函数&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当我们采用的是&lt;code&gt;TCP协议&lt;/code&gt;时，数据包到达传输层时，会在内核协议栈中的&lt;code&gt;tcp_rcv函数&lt;/code&gt;处理，在tcp_rcv函数中&lt;code&gt;去掉&lt;/code&gt;TCP头，根据&lt;code&gt;四元组（源IP，源端口，目的IP，目的端口）&lt;/code&gt;查找&lt;code&gt;对应的Socket&lt;/code&gt;，如果找到对应的Socket则将网络数据包中的传输数据拷贝到&lt;code&gt;Socket&lt;/code&gt;中的&lt;code&gt;接收缓冲区&lt;/code&gt;中。如果没有找到，则发送一个&lt;code&gt;目标不可达&lt;/code&gt;的&lt;code&gt;icmp&lt;/code&gt;包。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内核在接收网络数据包时所做的工作我们就介绍完了，现在我们把视角放到应用层，当我们程序通过系统调用&lt;code&gt;read&lt;/code&gt;读取&lt;code&gt;Socket接收缓冲区&lt;/code&gt;中的数据时，如果接收缓冲区中&lt;code&gt;没有数据&lt;/code&gt;，那么应用程序就会在系统调用上&lt;code&gt;阻塞&lt;/code&gt;，直到Socket接收缓冲区&lt;code&gt;有数据&lt;/code&gt;，然后&lt;code&gt;CPU&lt;/code&gt;将&lt;code&gt;内核空间&lt;/code&gt;（Socket接收缓冲区）的数据&lt;code&gt;拷贝&lt;/code&gt;到&lt;code&gt;用户空间&lt;/code&gt;，最后系统调用&lt;code&gt;read返回&lt;/code&gt;，应用程序&lt;code&gt;读取&lt;/code&gt;数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;性能开销&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从内核处理网络数据包接收的整个过程来看，内核帮我们做了非常之多的工作，最终我们的应用程序才能读取到网络数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着而来的也带来了很多的性能开销，结合前面介绍的网络数据包接收过程我们来看下网络数据包接收的过程中都有哪些性能开销：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;应用程序通过&lt;code&gt;系统调用&lt;/code&gt;从&lt;code&gt;用户态&lt;/code&gt;转为&lt;code&gt;内核态&lt;/code&gt;的开销以及系统调用&lt;code&gt;返回&lt;/code&gt;时从&lt;code&gt;内核态&lt;/code&gt;转为&lt;code&gt;用户态&lt;/code&gt;的开销。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网络数据从&lt;code&gt;内核空间&lt;/code&gt;通过&lt;code&gt;CPU拷贝&lt;/code&gt;到&lt;code&gt;用户空间&lt;/code&gt;的开销。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内核线程&lt;code&gt;ksoftirqd&lt;/code&gt;响应&lt;code&gt;软中断&lt;/code&gt;的开销。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;CPU&lt;/code&gt;响应&lt;code&gt;硬中断&lt;/code&gt;的开销。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;DMA拷贝&lt;/code&gt;网络数据包到&lt;code&gt;内存&lt;/code&gt;中的开销。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网络包发送流程&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.117741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEUK82351HYuWhJCicKvej94Cico9gLw6PJFPQBzmSibCplZAJXLoTz9O7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;网络包发送过程.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当我们在应用程序中调用&lt;code&gt;send&lt;/code&gt;系统调用发送数据时，由于是系统调用所以线程会发生一次用户态到内核态的转换，在内核中首先根据&lt;code&gt;fd&lt;/code&gt;将真正的Socket找出，这个Socket对象中记录着各种协议栈的函数地址，然后构造&lt;code&gt;struct msghdr&lt;/code&gt;对象，将用户需要发送的数据全部封装在这个&lt;code&gt;struct msghdr&lt;/code&gt;结构体中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;调用内核协议栈函数&lt;code&gt;inet_sendmsg&lt;/code&gt;，发送流程进入内核协议栈处理。在进入到内核协议栈之后，内核会找到Socket上的具体协议的发送函数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如：我们使用的是&lt;code&gt;TCP协议&lt;/code&gt;，对应的&lt;code&gt;TCP协议&lt;/code&gt;发送函数是&lt;code&gt;tcp_sendmsg&lt;/code&gt;，如果是&lt;code&gt;UDP协议&lt;/code&gt;的话，对应的发送函数为&lt;code&gt;udp_sendmsg&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;TCP协议&lt;/code&gt;的发送函数&lt;code&gt;tcp_sendmsg&lt;/code&gt;中，创建内核数据结构&lt;code&gt;sk_buffer&lt;/code&gt;,将&lt;code&gt;struct msghdr&lt;/code&gt;结构体中的发送数据&lt;code&gt;拷贝&lt;/code&gt;到&lt;code&gt;sk_buffer&lt;/code&gt;中。调用&lt;code&gt;tcp_write_queue_tail&lt;/code&gt;函数获取&lt;code&gt;Socket&lt;/code&gt;发送队列中的队尾元素，将新创建的&lt;code&gt;sk_buffer&lt;/code&gt;添加到&lt;code&gt;Socket&lt;/code&gt;发送队列的尾部。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;Socket&lt;/code&gt;的发送队列是由&lt;code&gt;sk_buffer&lt;/code&gt;组成的一个&lt;code&gt;双向链表&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;发送流程走到这里，用户要发送的数据总算是从&lt;code&gt;用户空间&lt;/code&gt;拷贝到了&lt;code&gt;内核&lt;/code&gt;中，这时虽然发送数据已经&lt;code&gt;拷贝&lt;/code&gt;到了内核&lt;code&gt;Socket&lt;/code&gt;中的&lt;code&gt;发送队列&lt;/code&gt;中，但并不代表内核会开始发送，因为&lt;code&gt;TCP协议&lt;/code&gt;的&lt;code&gt;流量控制&lt;/code&gt;和&lt;code&gt;拥塞控制&lt;/code&gt;，用户要发送的数据包&lt;code&gt;并不一定&lt;/code&gt;会立马被发送出去，需要符合&lt;code&gt;TCP协议&lt;/code&gt;的发送条件。如果&lt;code&gt;没有达到发送条件&lt;/code&gt;，那么本次&lt;code&gt;send&lt;/code&gt;系统调用就会直接返回。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果符合发送条件，则开始调用&lt;code&gt;tcp_write_xmit&lt;/code&gt;内核函数。在这个函数中，会循环获取&lt;code&gt;Socket&lt;/code&gt;发送队列中待发送的&lt;code&gt;sk_buffer&lt;/code&gt;，然后进行&lt;code&gt;拥塞控制&lt;/code&gt;以及&lt;code&gt;滑动窗口的管理&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将从&lt;code&gt;Socket&lt;/code&gt;发送队列中获取到的&lt;code&gt;sk_buffer&lt;/code&gt;重新&lt;code&gt;拷贝一份&lt;/code&gt;，设置&lt;code&gt;sk_buffer副本&lt;/code&gt;中的&lt;code&gt;TCP HEADER&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;sk_buffer&lt;/code&gt; 内部其实包含了网络协议中所有的 &lt;code&gt;header&lt;/code&gt;。在设置 &lt;code&gt;TCP HEADER&lt;/code&gt;的时候，只是把指针指向 &lt;code&gt;sk_buffer&lt;/code&gt;的合适位置。后面再设置 &lt;code&gt;IP HEADER&lt;/code&gt;的时候，在把指针移动一下就行，避免频繁的内存申请和拷贝，效率很高。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4112903225806452&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEpYMIdLl6Jch1BmZ4hwRpDHIXJIhmKibfPeEib9Y8SDx2YzXibkVWkic3Yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;sk_buffer.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么不直接使用&lt;code&gt;Socket&lt;/code&gt;发送队列中的&lt;code&gt;sk_buffer&lt;/code&gt;而是需要拷贝一份呢？&lt;/strong&gt;因为&lt;code&gt;TCP协议&lt;/code&gt;是支持&lt;code&gt;丢包重传&lt;/code&gt;的，在没有收到对端的&lt;code&gt;ACK&lt;/code&gt;之前，这个&lt;code&gt;sk_buffer&lt;/code&gt;是不能删除的。内核每次调用网卡发送数据的时候，实际上传递的是&lt;code&gt;sk_buffer&lt;/code&gt;的&lt;code&gt;拷贝副本&lt;/code&gt;，当网卡把数据发送出去后，&lt;code&gt;sk_buffer&lt;/code&gt;拷贝副本会被释放。当收到对端的&lt;code&gt;ACK&lt;/code&gt;之后，&lt;code&gt;Socket&lt;/code&gt;发送队列中的&lt;code&gt;sk_buffer&lt;/code&gt;才会被真正删除。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当设置完&lt;code&gt;TCP头&lt;/code&gt;后，内核协议栈&lt;code&gt;传输层&lt;/code&gt;的事情就做完了，下面通过调用&lt;code&gt;ip_queue_xmit&lt;/code&gt;内核函数，正式来到内核协议栈&lt;code&gt;网络层&lt;/code&gt;的处理。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;通过&lt;code&gt;route&lt;/code&gt;命令可以查看本机路由配置。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;如果你使用 &lt;code&gt;iptables&lt;/code&gt;配置了一些规则，那么这里将检测&lt;code&gt;是否命中&lt;/code&gt;规则。如果你设置了非常&lt;code&gt;复杂的 netfilter 规则&lt;/code&gt;，在这个函数里将会导致你的线程 &lt;code&gt;CPU 开销&lt;/code&gt;会&lt;code&gt;极大增加&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将&lt;code&gt;sk_buffer&lt;/code&gt;中的指针移动到&lt;code&gt;IP头&lt;/code&gt;位置上，设置&lt;code&gt;IP头&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;执行&lt;code&gt;netfilters&lt;/code&gt;过滤。过滤通过之后，如果数据大于 &lt;code&gt;MTU&lt;/code&gt;的话，则执行分片。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;检查&lt;code&gt;Socket&lt;/code&gt;中是否有缓存路由表，如果没有的话，则查找路由项，并缓存到&lt;code&gt;Socket&lt;/code&gt;中。接着在把路由表设置到&lt;code&gt;sk_buffer&lt;/code&gt;中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内核协议栈&lt;code&gt;网络层&lt;/code&gt;的事情处理完后，现在发送流程进入了到了&lt;code&gt;邻居子系统&lt;/code&gt;，&lt;code&gt;邻居子系统&lt;/code&gt;位于内核协议栈中的&lt;code&gt;网络层&lt;/code&gt;和&lt;code&gt;网络接口层&lt;/code&gt;之间，用于发送&lt;code&gt;ARP请求&lt;/code&gt;获取&lt;code&gt;MAC地址&lt;/code&gt;，然后将&lt;code&gt;sk_buffer&lt;/code&gt;中的指针移动到&lt;code&gt;MAC头&lt;/code&gt;位置，填充&lt;code&gt;MAC头&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;经过&lt;code&gt;邻居子系统&lt;/code&gt;的处理，现在&lt;code&gt;sk_buffer&lt;/code&gt;中已经封装了一个完整的&lt;code&gt;数据帧&lt;/code&gt;，随后内核将&lt;code&gt;sk_buffer&lt;/code&gt;交给&lt;code&gt;网络设备子系统&lt;/code&gt;进行处理。&lt;code&gt;网络设备子系统&lt;/code&gt;主要做以下几项事情：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;选择发送队列（&lt;code&gt;RingBuffer&lt;/code&gt;）。因为网卡拥有多个发送队列，所以在发送前需要选择一个发送队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将&lt;code&gt;sk_buffer&lt;/code&gt;添加到发送队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;循环从发送队列（&lt;code&gt;RingBuffer&lt;/code&gt;）中取出&lt;code&gt;sk_buffer&lt;/code&gt;，调用内核函数&lt;code&gt;sch_direct_xmit&lt;/code&gt;发送数据，其中会调用&lt;code&gt;网卡驱动程序&lt;/code&gt;来发送数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;以上过程全部是用户线程的内核态在执行，占用的CPU时间是系统态时间(&lt;code&gt;sy&lt;/code&gt;)，当分配给用户线程的&lt;code&gt;CPU quota&lt;/code&gt;用完的时候，会触发&lt;code&gt;NET_TX_SOFTIRQ&lt;/code&gt;类型的软中断，内核线程&lt;code&gt;ksoftirqd&lt;/code&gt;会响应这个软中断，并执行&lt;code&gt;NET_TX_SOFTIRQ&lt;/code&gt;类型的软中断注册的回调函数&lt;code&gt;net_tx_action&lt;/code&gt;，在回调函数中会执行到驱动程序函数 &lt;code&gt;dev_hard_start_xmit&lt;/code&gt;来发送数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意：当触发&lt;code&gt;NET_TX_SOFTIRQ&lt;/code&gt;软中断来发送数据时，后边消耗的 CPU 就都显示在 &lt;code&gt;si&lt;/code&gt;这里了，不会消耗用户进程的系统态时间（&lt;code&gt;sy&lt;/code&gt;）了。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从这里可以看到网络包的发送过程和接受过程是不同的，在介绍网络包的接受过程时，我们提到是通过触发&lt;code&gt;NET_RX_SOFTIRQ&lt;/code&gt;类型的软中断在内核线程&lt;code&gt;ksoftirqd&lt;/code&gt;中执行&lt;code&gt;内核网络协议栈&lt;/code&gt;接受数据。而在网络数据包的发送过程中是&lt;code&gt;用户线程的内核态&lt;/code&gt;在执行&lt;code&gt;内核网络协议栈&lt;/code&gt;，只有当线程的&lt;code&gt;CPU quota&lt;/code&gt;用尽时，才触发&lt;code&gt;NET_TX_SOFTIRQ&lt;/code&gt;软中断来发送数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在整个网络包的发送和接受过程中，&lt;code&gt;NET_TX_SOFTIRQ&lt;/code&gt;类型的软中断只会在发送网络包时并且当用户线程的&lt;code&gt;CPU quota&lt;/code&gt;用尽时，才会触发。剩下的接受过程中触发的软中断类型以及发送完数据触发的软中断类型均为&lt;code&gt;NET_RX_SOFTIRQ&lt;/code&gt;。所以这就是你在服务器上查看 &lt;code&gt;/proc/softirqs&lt;/code&gt;，一般 &lt;code&gt;NET_RX&lt;/code&gt;都要比 &lt;code&gt;NET_TX&lt;/code&gt;大很多的的原因。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;现在发送流程终于到了网卡真实发送数据的阶段，前边我们讲到无论是用户线程的内核态还是触发&lt;code&gt;NET_TX_SOFTIRQ&lt;/code&gt;类型的软中断在发送数据的时候最终会调用到网卡的驱动程序函数&lt;code&gt;dev_hard_start_xmit&lt;/code&gt;来发送数据。在网卡驱动程序函数&lt;code&gt;dev_hard_start_xmit&lt;/code&gt;中会将&lt;code&gt;sk_buffer&lt;/code&gt;映射到网卡可访问的&lt;code&gt;内存 DMA 区域&lt;/code&gt;，最终网卡驱动程序通过&lt;code&gt;DMA&lt;/code&gt;的方式将&lt;code&gt;数据帧&lt;/code&gt;通过物理网卡发送出去。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当数据发送完毕后，还有最后一项重要的工作，就是清理工作。数据发送完毕后，网卡设备会向&lt;code&gt;CPU&lt;/code&gt;发送一个硬中断，&lt;code&gt;CPU&lt;/code&gt;调用网卡驱动程序注册的&lt;code&gt;硬中断响应程序&lt;/code&gt;，在硬中断响应中触发&lt;code&gt;NET_RX_SOFTIRQ&lt;/code&gt;类型的软中断，在软中断的回调函数&lt;code&gt;igb_poll&lt;/code&gt;中清理释放 &lt;code&gt;sk_buffer&lt;/code&gt;，清理&lt;code&gt;网卡&lt;/code&gt;发送队列（&lt;code&gt;RingBuffer&lt;/code&gt;），解除 DMA 映射。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;无论&lt;code&gt;硬中断&lt;/code&gt;是因为&lt;code&gt;有数据要接收&lt;/code&gt;，还是说&lt;code&gt;发送完成通知&lt;/code&gt;，从硬中断触发的软中断都是 &lt;code&gt;NET_RX_SOFTIRQ&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里释放清理的只是&lt;code&gt;sk_buffer&lt;/code&gt;的副本，真正的&lt;code&gt;sk_buffer&lt;/code&gt;现在还是存放在&lt;code&gt;Socket&lt;/code&gt;的发送队列中。前面在&lt;code&gt;传输层&lt;/code&gt;处理的时候我们提到过，因为传输层需要&lt;code&gt;保证可靠性&lt;/code&gt;，所以 &lt;code&gt;sk_buffer&lt;/code&gt;其实还没有删除。它得等收到对方的 ACK 之后才会真正删除。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;性能开销&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们提到了在网络包接收过程中涉及到的性能开销，现在介绍完了网络包的发送过程，我们来看下在数据包发送过程中的性能开销：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;和接收数据一样，应用程序在调用&lt;code&gt;系统调用send&lt;/code&gt;的时候会从&lt;code&gt;用户态&lt;/code&gt;转为&lt;code&gt;内核态&lt;/code&gt;以及发送完数据后，&lt;code&gt;系统调用&lt;/code&gt;返回时从&lt;code&gt;内核态&lt;/code&gt;转为&lt;code&gt;用户态&lt;/code&gt;的开销。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户线程内核态&lt;code&gt;CPU quota&lt;/code&gt;用尽时触发&lt;code&gt;NET_TX_SOFTIRQ&lt;/code&gt;类型软中断，内核响应软中断的开销。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;网卡发送完数据，向&lt;code&gt;CPU&lt;/code&gt;发送硬中断，&lt;code&gt;CPU&lt;/code&gt;响应硬中断的开销。以及在硬中断中发送&lt;code&gt;NET_RX_SOFTIRQ&lt;/code&gt;软中断执行具体的内存清理动作。内核响应软中断的开销。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内存拷贝的开销。我们来回顾下在数据包发送的过程中都发生了哪些内存拷贝：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在内核协议栈的传输层中，&lt;code&gt;TCP协议&lt;/code&gt;对应的发送函数&lt;code&gt;tcp_sendmsg&lt;/code&gt;会申请&lt;code&gt;sk_buffer&lt;/code&gt;，将用户要发送的数据&lt;code&gt;拷贝&lt;/code&gt;到&lt;code&gt;sk_buffer&lt;/code&gt;中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在发送流程从传输层到网络层的时候，会&lt;code&gt;拷贝&lt;/code&gt;一个&lt;code&gt;sk_buffer副本&lt;/code&gt;出来，将这个&lt;code&gt;sk_buffer副本&lt;/code&gt;向下传递。原始&lt;code&gt;sk_buffer&lt;/code&gt;保留在&lt;code&gt;Socket&lt;/code&gt;发送队列中，等待网络对端&lt;code&gt;ACK&lt;/code&gt;，对端&lt;code&gt;ACK&lt;/code&gt;后删除&lt;code&gt;Socket&lt;/code&gt;发送队列中的&lt;code&gt;sk_buffer&lt;/code&gt;。对端没有发送&lt;code&gt;ACK&lt;/code&gt;，则重新从&lt;code&gt;Socket&lt;/code&gt;发送队列中发送，实现&lt;code&gt;TCP协议&lt;/code&gt;的可靠传输。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在网络层，如果发现要发送的数据大于&lt;code&gt;MTU&lt;/code&gt;，则会进行分片操作，申请额外的&lt;code&gt;sk_buffer&lt;/code&gt;，并将原来的sk_buffer&lt;code&gt;拷贝&lt;/code&gt;到多个小的sk_buffer中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;再谈(阻塞，非阻塞)与(同步，异步)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们聊完网络数据的接收和发送过程后，我们来谈下IO中特别容易混淆的概念：&lt;code&gt;阻塞与同步&lt;/code&gt;，&lt;code&gt;非阻塞与异步&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网上各种博文还有各种书籍中有大量的关于这两个概念的解释，但是笔者觉得还是不够形象化，只是对概念的生硬解释，如果硬套概念的话，其实感觉&lt;code&gt;阻塞与同步&lt;/code&gt;，&lt;code&gt;非阻塞与异步&lt;/code&gt;还是没啥区别，时间长了，还是比较模糊容易混淆。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以笔者在这里尝试换一种更加形象化，更加容易理解记忆的方式来清晰地解释下什么是&lt;code&gt;阻塞与非阻塞&lt;/code&gt;，什么是&lt;code&gt;同步与异步&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过前边对网络数据包接收流程的介绍，在这里我们可以将整个流程总结为两个阶段：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7629032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEgwcdMwZya6aIFeslTuyUGGUtLgBnkQhrP9GhxRPMxNvG3TmKxFG5bQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;数据接收阶段.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;数据准备阶段：&lt;/strong&gt; 在这个阶段，网络数据包到达网卡，通过&lt;code&gt;DMA&lt;/code&gt;的方式将数据包拷贝到内存中，然后经过硬中断，软中断，接着通过内核线程&lt;code&gt;ksoftirqd&lt;/code&gt;经过内核协议栈的处理，最终将数据发送到&lt;code&gt;内核Socket&lt;/code&gt;的接收缓冲区中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;数据拷贝阶段：&lt;/strong&gt; 当数据到达&lt;code&gt;内核Socket&lt;/code&gt;的接收缓冲区中时，此时数据存在于&lt;code&gt;内核空间&lt;/code&gt;中，需要将数据&lt;code&gt;拷贝&lt;/code&gt;到&lt;code&gt;用户空间&lt;/code&gt;中，才能够被应用程序读取。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;阻塞与非阻塞&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阻塞与非阻塞的区别主要发生在第一阶段：&lt;code&gt;数据准备阶段&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当应用程序发起&lt;code&gt;系统调用read&lt;/code&gt;时，线程从用户态转为内核态，读取内核&lt;code&gt;Socket&lt;/code&gt;的接收缓冲区中的网络数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;阻塞&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这时内核&lt;code&gt;Socket&lt;/code&gt;的接收缓冲区没有数据，那么线程就会一直&lt;code&gt;等待&lt;/code&gt;，直到&lt;code&gt;Socket&lt;/code&gt;接收缓冲区有数据为止。随后将数据从内核空间拷贝到用户空间，&lt;code&gt;系统调用read&lt;/code&gt;返回。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6959677419354838&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcE59KUqV0jGMaO1RzueavdIWFn5lpNicVTss7vF5OvdChgR3zjtbGcgzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;阻塞IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看出：&lt;strong&gt;阻塞&lt;/strong&gt;的特点是在第一阶段和第二阶段&lt;code&gt;都会等待&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;非阻塞&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;阻塞&lt;/code&gt;和&lt;code&gt;非阻塞&lt;/code&gt;主要的区分是在第一阶段：&lt;code&gt;数据准备阶段&lt;/code&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在第一阶段，当&lt;code&gt;Socket&lt;/code&gt;的接收缓冲区中没有数据的时候，&lt;code&gt;阻塞模式下&lt;/code&gt;应用线程会一直等待。&lt;code&gt;非阻塞模式下&lt;/code&gt;应用线程不会等待，&lt;code&gt;系统调用&lt;/code&gt;直接返回错误标志&lt;code&gt;EWOULDBLOCK&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当&lt;code&gt;Socket&lt;/code&gt;的接收缓冲区中有数据的时候，&lt;code&gt;阻塞&lt;/code&gt;和&lt;code&gt;非阻塞&lt;/code&gt;的表现是一样的，都会进入第二阶段&lt;code&gt;等待&lt;/code&gt;数据从&lt;code&gt;内核空间&lt;/code&gt;拷贝到&lt;code&gt;用户空间&lt;/code&gt;，然后&lt;code&gt;系统调用返回&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7483870967741936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcERxuxKJvM0hOVl9fGVF4uP3b5iasjyBg7AQPjwbc9O3w5MjtiaRYM9URQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;非阻塞IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图中，我们可以看出：&lt;strong&gt;非阻塞&lt;/strong&gt;的特点是第一阶段&lt;code&gt;不会等待&lt;/code&gt;，但是在第二阶段还是会&lt;code&gt;等待&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;同步与异步&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;同步&lt;/code&gt;与&lt;code&gt;异步&lt;/code&gt;主要的区别发生在第二阶段：&lt;code&gt;数据拷贝阶段&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们提到在&lt;code&gt;数据拷贝阶段&lt;/code&gt;主要是将数据从&lt;code&gt;内核空间&lt;/code&gt;拷贝到&lt;code&gt;用户空间&lt;/code&gt;。然后应用程序才可以读取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当内核&lt;code&gt;Socket&lt;/code&gt;的接收缓冲区有数据到达时，进入第二阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;同步&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;同步模式&lt;/code&gt;在数据准备好后，是由&lt;code&gt;用户线程&lt;/code&gt;的&lt;code&gt;内核态&lt;/code&gt;来执行&lt;code&gt;第二阶段&lt;/code&gt;。所以应用程序会在第二阶段发生&lt;code&gt;阻塞&lt;/code&gt;，直到数据从&lt;code&gt;内核空间&lt;/code&gt;拷贝到&lt;code&gt;用户空间&lt;/code&gt;，系统调用才会返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux下的 &lt;code&gt;epoll&lt;/code&gt;和Mac 下的 &lt;code&gt;kqueue&lt;/code&gt;都属于&lt;code&gt;同步 IO&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7532258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEjEQDIAtT2cuNI4aaW1NtREspTEhdh4opJ4bqvamfRm0PAVMC8TjKuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;同步IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;异步&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;异步模式&lt;/code&gt;下是由&lt;code&gt;内核&lt;/code&gt;来执行第二阶段的数据拷贝操作，当&lt;code&gt;内核&lt;/code&gt;执行完第二阶段，会通知用户线程IO操作已经完成，并将数据回调给用户线程。所以在&lt;code&gt;异步模式&lt;/code&gt;下 &lt;code&gt;数据准备阶段&lt;/code&gt;和&lt;code&gt;数据拷贝阶段&lt;/code&gt;均是由&lt;code&gt;内核&lt;/code&gt;来完成，不会对应用程序造成任何阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上特征，我们可以看到&lt;code&gt;异步模式&lt;/code&gt;需要内核的支持，比较依赖操作系统底层的支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在目前流行的操作系统中，只有Windows 中的 &lt;code&gt;IOCP&lt;/code&gt;才真正属于异步 IO，实现的也非常成熟。但Windows很少用来作为服务器使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而常用来作为服务器使用的Linux，&lt;code&gt;异步IO机制&lt;/code&gt;实现的不够成熟，与NIO相比性能提升的也不够明显。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但Linux kernel 在5.1版本由Facebook的大神Jens Axboe引入了新的异步IO库&lt;code&gt;io_uring&lt;/code&gt; 改善了原来Linux native AIO的一些性能问题。性能相比&lt;code&gt;Epoll&lt;/code&gt;以及之前原生的&lt;code&gt;AIO&lt;/code&gt;提高了不少，值得关注。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7532258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEgH4TCcSV12UCRFeMUEunGcgFdUG9nZLq2AQ9QjnuQpzpJuKHMTus8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;异步IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;IO模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进行网络IO操作时，用什么样的IO模型来读写数据将在很大程度上决定了网络框架的IO性能。所以IO模型的选择是构建一个高性能网络框架的基础。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在《UNIX 网络编程》一书中介绍了五种IO模型：&lt;code&gt;阻塞IO&lt;/code&gt;,&lt;code&gt;非阻塞IO&lt;/code&gt;,&lt;code&gt;IO多路复用&lt;/code&gt;,&lt;code&gt;信号驱动IO&lt;/code&gt;,&lt;code&gt;异步IO&lt;/code&gt;，每一种IO模型的出现都是对前一种的升级优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就来分别介绍下这五种IO模型各自都解决了什么问题，适用于哪些场景，各自的优缺点是什么？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;阻塞IO（BIO）&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6959677419354838&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcE59KUqV0jGMaO1RzueavdIWFn5lpNicVTss7vF5OvdChgR3zjtbGcgzg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;阻塞IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过前一小节对&lt;code&gt;阻塞&lt;/code&gt;这个概念的介绍，相信大家可以很容易理解&lt;code&gt;阻塞IO&lt;/code&gt;的概念和过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然这小节我们谈的是&lt;code&gt;IO&lt;/code&gt;，那么下边我们来看下在&lt;code&gt;阻塞IO&lt;/code&gt;模型下，网络数据的读写过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;阻塞读&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户线程发起&lt;code&gt;read&lt;/code&gt;系统调用，用户线程从用户态切换到内核态，在内核中去查看&lt;code&gt;Socket&lt;/code&gt;接收缓冲区是否有数据到来。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Socket&lt;/code&gt;接收缓冲区中&lt;code&gt;有数据&lt;/code&gt;，则用户线程在内核态将内核空间中的数据拷贝到用户空间，系统IO调用返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Socket&lt;/code&gt;接收缓冲区中&lt;code&gt;无数据&lt;/code&gt;，则用户线程让出CPU，进入&lt;code&gt;阻塞状态&lt;/code&gt;。当数据到达&lt;code&gt;Socket&lt;/code&gt;接收缓冲区后，内核唤醒&lt;code&gt;阻塞状态&lt;/code&gt;中的用户线程进入&lt;code&gt;就绪状态&lt;/code&gt;，随后经过CPU的调度获取到&lt;code&gt;CPU quota&lt;/code&gt;进入&lt;code&gt;运行状态&lt;/code&gt;，将内核空间的数据拷贝到用户空间，随后系统调用返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;阻塞写&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户线程发起&lt;code&gt;send&lt;/code&gt;系统调用时，用户线程从用户态切换到内核态，将发送数据从用户空间拷贝到内核空间中的&lt;code&gt;Socket&lt;/code&gt;发送缓冲区中。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当&lt;code&gt;Socket&lt;/code&gt;发送缓冲区能够容纳下发送数据时，用户线程会将全部的发送数据写入&lt;code&gt;Socket&lt;/code&gt;缓冲区，然后执行在《网络包发送流程》这小节介绍的后续流程，然后返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当&lt;code&gt;Socket&lt;/code&gt;发送缓冲区空间不够，无法容纳下全部发送数据时，用户线程让出CPU,进入&lt;code&gt;阻塞状态&lt;/code&gt;，直到&lt;code&gt;Socket&lt;/code&gt;发送缓冲区能够容纳下全部发送数据时，内核唤醒用户线程，执行后续发送流程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;阻塞IO&lt;/code&gt;模型下的写操作做事风格比较硬刚，非得要把全部的发送数据写入发送缓冲区才肯善罢甘休。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;阻塞IO模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5524193548387096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcE15CGWNAUIdAvTbLVsusiaasD4rxcL0k8FShwAj1DguCc5cF8dPzfexA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;阻塞IO模型.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;code&gt;阻塞IO&lt;/code&gt;的读写特点，所以导致在&lt;code&gt;阻塞IO&lt;/code&gt;模型下，每个请求都需要被一个独立的线程处理。一个线程在同一时刻只能与一个连接绑定。来一个请求，服务端就需要创建一个线程用来处理请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当客户端请求的并发量突然增大时，服务端在一瞬间就会创建出大量的线程，而创建线程是需要系统资源开销的，这样一来就会一瞬间占用大量的系统资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果客户端创建好连接后，但是一直不发数据，通常大部分情况下，网络连接也&lt;code&gt;并不&lt;/code&gt;总是有数据可读，那么在空闲的这段时间内，服务端线程就会一直处于&lt;code&gt;阻塞状态&lt;/code&gt;，无法干其他的事情。CPU也&lt;code&gt;无法得到充分的发挥&lt;/code&gt;，同时还会&lt;code&gt;导致大量线程切换的开销&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;适用场景&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上&lt;code&gt;阻塞IO模型&lt;/code&gt;的特点，该模型只适用于&lt;code&gt;连接数少&lt;/code&gt;，&lt;code&gt;并发度低&lt;/code&gt;的业务场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如公司内部的一些管理系统，通常请求数在100个左右，使用&lt;code&gt;阻塞IO模型&lt;/code&gt;还是非常适合的。而且性能还不输NIO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该模型在C10K之前，是普遍被采用的一种IO模型。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;非阻塞IO（NIO）&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;阻塞IO模型&lt;/code&gt;最大的问题就是一个线程只能处理一个连接，如果这个连接上没有数据的话，那么这个线程就只能阻塞在系统IO调用上，不能干其他的事情。这对系统资源来说，是一种极大的浪费。同时大量的线程上下文切换，也是一个巨大的系统开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以为了解决这个问题，&lt;strong&gt;我们就需要用尽可能少的线程去处理更多的连接。&lt;/strong&gt;，&lt;code&gt;网络IO模型的演变&lt;/code&gt;也是根据这个需求来一步一步演进的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于这个需求，第一种解决方案&lt;code&gt;非阻塞IO&lt;/code&gt;就出现了。我们在上一小节中介绍了&lt;code&gt;非阻塞&lt;/code&gt;的概念，现在我们来看下网络读写操作在&lt;code&gt;非阻塞IO&lt;/code&gt;下的特点：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7483870967741936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcERxuxKJvM0hOVl9fGVF4uP3b5iasjyBg7AQPjwbc9O3w5MjtiaRYM9URQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;非阻塞IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;非阻塞读&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户线程发起非阻塞&lt;code&gt;read&lt;/code&gt;系统调用时，用户线程从&lt;code&gt;用户态&lt;/code&gt;转为&lt;code&gt;内核态&lt;/code&gt;，在内核中去查看&lt;code&gt;Socket&lt;/code&gt;接收缓冲区是否有数据到来。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Socket&lt;/code&gt;接收缓冲区中&lt;code&gt;无数据&lt;/code&gt;，系统调用立马返回，并带有一个 &lt;code&gt;EWOULDBLOCK&lt;/code&gt; 或 &lt;code&gt;EAGAIN&lt;/code&gt;错误，这个阶段用户线程&lt;code&gt;不会阻塞&lt;/code&gt;，也&lt;code&gt;不会让出CPU&lt;/code&gt;，而是会继续&lt;code&gt;轮训&lt;/code&gt;直到&lt;code&gt;Socket&lt;/code&gt;接收缓冲区中有数据为止。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Socket&lt;/code&gt;接收缓冲区中&lt;code&gt;有数据&lt;/code&gt;，用户线程在&lt;code&gt;内核态&lt;/code&gt;会将&lt;code&gt;内核空间&lt;/code&gt;中的数据拷贝到&lt;code&gt;用户空间&lt;/code&gt;，&lt;strong&gt;注意&lt;/strong&gt;这个数据拷贝阶段，应用程序是&lt;code&gt;阻塞的&lt;/code&gt;，当数据拷贝完成，系统调用返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;非阻塞写&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们在介绍&lt;code&gt;阻塞写&lt;/code&gt;的时候提到&lt;code&gt;阻塞写&lt;/code&gt;的风格特别的硬朗，头比较铁非要把全部发送数据一次性都写到&lt;code&gt;Socket&lt;/code&gt;的发送缓冲区中才返回，如果发送缓冲区中没有足够的空间容纳，那么就一直阻塞死等，特别的刚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比较而言&lt;code&gt;非阻塞写&lt;/code&gt;的特点就比较佛系，当发送缓冲区中没有足够的空间容纳全部发送数据时，&lt;code&gt;非阻塞写&lt;/code&gt;的特点是&lt;code&gt;能写多少写多少&lt;/code&gt;，写不下了，就立即返回。并将写入到发送缓冲区的字节数返回给应用程序，方便用户线程不断的&lt;code&gt;轮训&lt;/code&gt;尝试将&lt;code&gt;剩下的数据&lt;/code&gt;写入发送缓冲区中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;非阻塞IO模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37338709677419357&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEZHypSu2HK3FeqU10jRnAwDEkrVZA7kbl0MWpPonZrdOWfXzcngzlvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;非阻塞IO模型.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上&lt;code&gt;非阻塞IO&lt;/code&gt;的特点，我们就不必像&lt;code&gt;阻塞IO&lt;/code&gt;那样为每个请求分配一个线程去处理连接上的读写了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以利用&lt;strong&gt;一个线程或者很少的线程&lt;/strong&gt;，去&lt;code&gt;不断地轮询&lt;/code&gt;每个&lt;code&gt;Socket&lt;/code&gt;的接收缓冲区是否有数据到达，如果没有数据，&lt;code&gt;不必阻塞&lt;/code&gt;线程，而是接着去&lt;code&gt;轮询&lt;/code&gt;下一个&lt;code&gt;Socket&lt;/code&gt;接收缓冲区，直到轮询到数据后，处理连接上的读写，或者交给业务线程池去处理，轮询线程则&lt;code&gt;继续轮询&lt;/code&gt;其他的&lt;code&gt;Socket&lt;/code&gt;接收缓冲区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一个&lt;code&gt;非阻塞IO模型&lt;/code&gt;就实现了我们在本小节开始提出的需求：&lt;strong&gt;我们需要用尽可能少的线程去处理更多的连接&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;适用场景&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然&lt;code&gt;非阻塞IO模型&lt;/code&gt;与&lt;code&gt;阻塞IO模型&lt;/code&gt;相比，减少了很大一部分的资源消耗和系统开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是它仍然有很大的性能问题，因为在&lt;code&gt;非阻塞IO模型&lt;/code&gt;下，需要用户线程去&lt;code&gt;不断地&lt;/code&gt;发起&lt;code&gt;系统调用&lt;/code&gt;去轮训&lt;code&gt;Socket&lt;/code&gt;接收缓冲区，这就需要用户线程不断地从&lt;code&gt;用户态&lt;/code&gt;切换到&lt;code&gt;内核态&lt;/code&gt;，&lt;code&gt;内核态&lt;/code&gt;切换到&lt;code&gt;用户态&lt;/code&gt;。随着并发量的增大，这个上下文切换的开销也是巨大的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以单纯的&lt;code&gt;非阻塞IO&lt;/code&gt;模型还是无法适用于高并发的场景。只能适用于&lt;code&gt;C10K&lt;/code&gt;以下的场景。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;IO多路复用&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;非阻塞IO&lt;/code&gt;这一小节的开头，我们提到&lt;code&gt;网络IO模型&lt;/code&gt;的演变都是围绕着---&lt;strong&gt;如何用尽可能少的线程去处理更多的连接&lt;/strong&gt;这个核心需求开始展开的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节我们来谈谈&lt;code&gt;IO多路复用模型&lt;/code&gt;，那么什么是&lt;code&gt;多路&lt;/code&gt;？，什么又是&lt;code&gt;复用&lt;/code&gt;呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以这个核心需求来对这两个概念展开阐述：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;多路&lt;/strong&gt;：我们的核心需求是要用尽可能少的线程来处理尽可能多的连接，这里的&lt;code&gt;多路&lt;/code&gt;指的就是我们需要处理的众多连接。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;复用&lt;/strong&gt;：核心需求要求我们使用&lt;code&gt;尽可能少的线程&lt;/code&gt;，&lt;code&gt;尽可能少的系统开销&lt;/code&gt;去处理&lt;code&gt;尽可能多&lt;/code&gt;的连接（&lt;code&gt;多路&lt;/code&gt;），那么这里的&lt;code&gt;复用&lt;/code&gt;指的就是用&lt;code&gt;有限的资源&lt;/code&gt;，比如用一个线程或者固定数量的线程去处理众多连接上的读写事件。换句话说，在&lt;code&gt;阻塞IO模型&lt;/code&gt;中一个连接就需要分配一个独立的线程去专门处理这个连接上的读写，到了&lt;code&gt;IO多路复用模型&lt;/code&gt;中，多个连接可以&lt;code&gt;复用&lt;/code&gt;这一个独立的线程去处理这多个连接上的读写。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，&lt;code&gt;IO多路复用模型&lt;/code&gt;的概念解释清楚了，那么&lt;strong&gt;问题的关键&lt;/strong&gt;是我们如何去实现这个&lt;code&gt;复用&lt;/code&gt;，也就是如何让一个独立的线程去处理众多连接上的读写事件呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题其实在&lt;code&gt;非阻塞IO模型&lt;/code&gt;中已经给出了它的答案，在&lt;code&gt;非阻塞IO模型&lt;/code&gt;中，利用&lt;code&gt;非阻塞&lt;/code&gt;的系统IO调用去不断的轮询众多连接的&lt;code&gt;Socket&lt;/code&gt;接收缓冲区看是否有数据到来，如果有则处理，如果没有则继续轮询下一个&lt;code&gt;Socket&lt;/code&gt;。这样就达到了用一个线程去处理众多连接上的读写事件了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;但是&lt;/strong&gt;&lt;code&gt;非阻塞IO模型&lt;/code&gt;最大的问题就是需要不断的发起&lt;code&gt;系统调用&lt;/code&gt;去轮询各个&lt;code&gt;Socket&lt;/code&gt;中的接收缓冲区是否有数据到来，&lt;code&gt;频繁&lt;/code&gt;的&lt;code&gt;系统调用&lt;/code&gt;随之带来了大量的上下文切换开销。随着并发量的提升，这样也会导致非常严重的性能问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么如何避免频繁的系统调用同时又可以实现我们的核心需求呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就需要操作系统的内核来支持这样的操作，我们可以把频繁的轮询操作交给操作系统内核来替我们完成，这样就避免了在&lt;code&gt;用户空间&lt;/code&gt;频繁的去使用系统调用来轮询所带来的性能开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如我们所想，操作系统内核也确实为我们提供了这样的功能实现，下面我们来一起看下操作系统对&lt;code&gt;IO多路复用模型&lt;/code&gt;的实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select&lt;/code&gt;是操作系统内核提供给我们使用的一个&lt;code&gt;系统调用&lt;/code&gt;，它解决了在&lt;code&gt;非阻塞IO模型&lt;/code&gt;中需要不断的发起&lt;code&gt;系统IO调用&lt;/code&gt;去轮询&lt;code&gt;各个连接上的Socket&lt;/code&gt;接收缓冲区所带来的&lt;code&gt;用户空间&lt;/code&gt;与&lt;code&gt;内核空间&lt;/code&gt;不断切换的&lt;code&gt;系统开销&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select&lt;/code&gt;系统调用将&lt;code&gt;轮询&lt;/code&gt;的操作交给了&lt;code&gt;内核&lt;/code&gt;来帮助我们完成，从而避免了在&lt;code&gt;用户空间&lt;/code&gt;不断的发起轮询所带来的的系统性能开销。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEjOYnCMt84RfZyS5JVtLyrr115wOiauU5b21IvrIsHx4ndVDryGSlfMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;select.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先用户线程在发起&lt;code&gt;select&lt;/code&gt;系统调用的时候会&lt;code&gt;阻塞&lt;/code&gt;在&lt;code&gt;select&lt;/code&gt;系统调用上。此时，用户线程从&lt;code&gt;用户态&lt;/code&gt;切换到了&lt;code&gt;内核态&lt;/code&gt;完成了一次&lt;code&gt;上下文切换&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户线程将需要监听的&lt;code&gt;Socket&lt;/code&gt;对应的文件描述符&lt;code&gt;fd&lt;/code&gt;数组通过&lt;code&gt;select&lt;/code&gt;系统调用传递给内核。此时，用户线程将&lt;code&gt;用户空间&lt;/code&gt;中的文件描述符&lt;code&gt;fd&lt;/code&gt;数组&lt;code&gt;拷贝&lt;/code&gt;到&lt;code&gt;内核空间&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的&lt;strong&gt;文件描述符数组&lt;/strong&gt;其实是一个&lt;code&gt;BitMap&lt;/code&gt;，&lt;code&gt;BitMap&lt;/code&gt;下标为&lt;code&gt;文件描述符fd&lt;/code&gt;，下标对应的值为：&lt;code&gt;1&lt;/code&gt;表示该&lt;code&gt;fd&lt;/code&gt;上有读写事件，&lt;code&gt;0&lt;/code&gt;表示该&lt;code&gt;fd&lt;/code&gt;上没有读写事件。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2709677419354839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcED7ATGgNE7Ou6uf2ef80pvzAfiaFI9EakX3FDd1icRiaiaMk5on3c0CrWdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;fd数组BitMap.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;文件描述符fd&lt;/strong&gt;其实就是一个&lt;code&gt;整数值&lt;/code&gt;，在Linux中一切皆文件，&lt;code&gt;Socket&lt;/code&gt;也是一个文件。描述进程所有信息的数据结构&lt;code&gt;task_struct&lt;/code&gt;中有一个属性&lt;code&gt;struct files_struct *files&lt;/code&gt;，它最终指向了一个数组，数组里存放了进程打开的所有文件列表，文件信息封装在&lt;code&gt;struct file&lt;/code&gt;结构体中，这个数组存放的类型就是&lt;code&gt;struct file&lt;/code&gt;结构体，&lt;code&gt;数组的下标&lt;/code&gt;则是我们常说的文件描述符&lt;code&gt;fd&lt;/code&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当用户线程调用完&lt;code&gt;select&lt;/code&gt;后开始进入&lt;code&gt;阻塞状态&lt;/code&gt;，&lt;code&gt;内核&lt;/code&gt;开始轮询遍历&lt;code&gt;fd&lt;/code&gt;数组，查看&lt;code&gt;fd&lt;/code&gt;对应的&lt;code&gt;Socket&lt;/code&gt;接收缓冲区中是否有数据到来。如果有数据到来，则将&lt;code&gt;fd&lt;/code&gt;对应&lt;code&gt;BitMap&lt;/code&gt;的值设置为&lt;code&gt;1&lt;/code&gt;。如果没有数据到来，则保持值为&lt;code&gt;0&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;这里内核会修改原始的&lt;code&gt;fd&lt;/code&gt;数组！！&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内核遍历一遍&lt;code&gt;fd&lt;/code&gt;数组后，如果发现有些&lt;code&gt;fd&lt;/code&gt;上有IO数据到来，则将修改后的&lt;code&gt;fd&lt;/code&gt;数组返回给用户线程。此时，会将&lt;code&gt;fd&lt;/code&gt;数组从&lt;code&gt;内核空间&lt;/code&gt;拷贝到&lt;code&gt;用户空间&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当内核将修改后的&lt;code&gt;fd&lt;/code&gt;数组返回给用户线程后，用户线程解除&lt;code&gt;阻塞&lt;/code&gt;，由用户线程开始遍历&lt;code&gt;fd&lt;/code&gt;数组然后找出&lt;code&gt;fd&lt;/code&gt;数组中值为&lt;code&gt;1&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;文件描述符。最后对这些&lt;code&gt;Socket&lt;/code&gt;发起系统调用读取数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;select&lt;/code&gt;不会告诉用户线程具体哪些&lt;code&gt;fd&lt;/code&gt;上有IO数据到来，只是在&lt;code&gt;IO活跃&lt;/code&gt;的&lt;code&gt;fd&lt;/code&gt;上打上标记，将打好标记的完整&lt;code&gt;fd&lt;/code&gt;数组返回给用户线程，所以用户线程还需要遍历&lt;code&gt;fd&lt;/code&gt;数组找出具体哪些&lt;code&gt;fd&lt;/code&gt;上有&lt;code&gt;IO数据&lt;/code&gt;到来。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由于内核在遍历的过程中已经修改了&lt;code&gt;fd&lt;/code&gt;数组，所以在用户线程遍历完&lt;code&gt;fd&lt;/code&gt;数组后获取到&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;后，就需要&lt;code&gt;重置&lt;/code&gt;fd数组，并重新调用&lt;code&gt;select&lt;/code&gt;传入重置后的&lt;code&gt;fd&lt;/code&gt;数组，让内核发起新的一轮遍历轮询。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;API介绍&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们熟悉了&lt;code&gt;select&lt;/code&gt;的原理后，就很容易理解内核给我们提供的&lt;code&gt;select API&lt;/code&gt;了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,&lt;span&gt;const&lt;/span&gt; struct timeval *timeout)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从&lt;code&gt;select API&lt;/code&gt;中我们可以看到，&lt;code&gt;select&lt;/code&gt;系统调用是在规定的&lt;code&gt;超时时间内&lt;/code&gt;，监听（&lt;code&gt;轮询&lt;/code&gt;）用户感兴趣的文件描述符集合上的&lt;code&gt;可读&lt;/code&gt;,&lt;code&gt;可写&lt;/code&gt;,&lt;code&gt;异常&lt;/code&gt;三类事件。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;maxfdp1 ：&lt;/code&gt; select传递给内核监听的文件描述符集合中数值最大的文件描述符&lt;code&gt;+1&lt;/code&gt;，目的是用于限定内核遍历范围。比如：&lt;code&gt;select&lt;/code&gt;监听的文件描述符集合为&lt;code&gt;{0,1,2,3,4}&lt;/code&gt;，那么&lt;code&gt;maxfdp1&lt;/code&gt;的值为&lt;code&gt;5&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;fd_set *readset：&lt;/code&gt; 对&lt;code&gt;可读事件&lt;/code&gt;感兴趣的文件描述符集合。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;fd_set *writeset：&lt;/code&gt; 对&lt;code&gt;可写事件&lt;/code&gt;感兴趣的文件描述符集合。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;fd_set *exceptset：&lt;/code&gt;对&lt;code&gt;可写事件&lt;/code&gt;感兴趣的文件描述符集合。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里的&lt;code&gt;fd_set&lt;/code&gt;就是我们前边提到的&lt;code&gt;文件描述符数组&lt;/code&gt;，是一个&lt;code&gt;BitMap&lt;/code&gt;结构。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;const struct timeval *timeout：&lt;/code&gt;select系统调用超时时间，在这段时间内，内核如果没有发现有&lt;code&gt;IO就绪&lt;/code&gt;的文件描述符，就直接返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上小节提到，在&lt;code&gt;内核&lt;/code&gt;遍历完&lt;code&gt;fd&lt;/code&gt;数组后，发现有&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;fd&lt;/code&gt;，则会将该&lt;code&gt;fd&lt;/code&gt;对应的&lt;code&gt;BitMap&lt;/code&gt;中的值设置为&lt;code&gt;1&lt;/code&gt;，并将修改后的&lt;code&gt;fd&lt;/code&gt;数组，返回给用户线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在用户线程中需要重新遍历&lt;code&gt;fd&lt;/code&gt;数组，找出&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;fd&lt;/code&gt;出来，然后发起真正的读写调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面介绍下在用户线程中重新遍历&lt;code&gt;fd&lt;/code&gt;数组的过程中，我们需要用到的&lt;code&gt;API&lt;/code&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;void FD_ZERO(fd_set *fdset)：&lt;/code&gt;清空指定的文件描述符集合，即让&lt;code&gt;fd_set&lt;/code&gt;中不在包含任何文件描述符。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;void FD_SET(int fd, fd_set *fdset)：&lt;/code&gt;将一个给定的文件描述符加入集合之中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;每次调用&lt;code&gt;select&lt;/code&gt;之前都要通过&lt;code&gt;FD_ZERO&lt;/code&gt;和&lt;code&gt;FD_SET&lt;/code&gt;重新设置文件描述符，因为文件描述符集合会在&lt;code&gt;内核&lt;/code&gt;中&lt;code&gt;被修改&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;int FD_ISSET(int fd, fd_set *fdset)：&lt;/code&gt;检查集合中指定的文件描述符是否可以读写。用户线程&lt;code&gt;遍历&lt;/code&gt;文件描述符集合,调用该方法检查相应的文件描述符是否&lt;code&gt;IO就绪&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;void FD_CLR(int fd, fd_set *fdset)：&lt;/code&gt;将一个给定的文件描述符从集合中删除&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;性能开销&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然&lt;code&gt;select&lt;/code&gt;解决了&lt;code&gt;非阻塞IO模型&lt;/code&gt;中频繁发起&lt;code&gt;系统调用&lt;/code&gt;的问题，但是在整个&lt;code&gt;select&lt;/code&gt;工作过程中，我们还是看出了&lt;code&gt;select&lt;/code&gt;有些不足的地方。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在发起&lt;code&gt;select&lt;/code&gt;系统调用以及返回时，用户线程各发生了一次&lt;code&gt;用户态&lt;/code&gt;到&lt;code&gt;内核态&lt;/code&gt;以及&lt;code&gt;内核态&lt;/code&gt;到&lt;code&gt;用户态&lt;/code&gt;的上下文切换开销。&lt;strong&gt;发生2次上下文&lt;code&gt;切换&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在发起&lt;code&gt;select&lt;/code&gt;系统调用以及返回时，用户线程在&lt;code&gt;内核态&lt;/code&gt;需要将&lt;code&gt;文件描述符集合&lt;/code&gt;从用户空间&lt;code&gt;拷贝&lt;/code&gt;到内核空间。以及在内核修改完&lt;code&gt;文件描述符集合&lt;/code&gt;后，又要将它从内核空间&lt;code&gt;拷贝&lt;/code&gt;到用户空间。&lt;strong&gt;发生2次文件描述符集合的&lt;code&gt;拷贝&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;虽然由原来在&lt;code&gt;用户空间&lt;/code&gt;发起轮询&lt;code&gt;优化成了&lt;/code&gt;在&lt;code&gt;内核空间&lt;/code&gt;发起轮询但&lt;code&gt;select&lt;/code&gt;不会告诉用户线程到底是哪些&lt;code&gt;Socket&lt;/code&gt;上发生了&lt;code&gt;IO就绪&lt;/code&gt;事件，只是对&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;作了标记，用户线程依然要&lt;code&gt;遍历&lt;/code&gt;文件描述符集合去查找具体&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;。时间复杂度依然为&lt;code&gt;O(n)&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大部分情况下，网络连接并不总是活跃的，如果&lt;code&gt;select&lt;/code&gt;监听了大量的客户端连接，只有少数的连接活跃，然而使用轮询的这种方式会随着连接数的增大，效率会越来越低。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;内核&lt;/code&gt;会对原始的&lt;code&gt;文件描述符集合&lt;/code&gt;进行修改。导致每次在用户空间重新发起&lt;code&gt;select&lt;/code&gt;调用时，都需要对&lt;code&gt;文件描述符集合&lt;/code&gt;进行&lt;code&gt;重置&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;BitMap&lt;/code&gt;结构的文件描述符集合，长度为固定的&lt;code&gt;1024&lt;/code&gt;,所以只能监听&lt;code&gt;0~1023&lt;/code&gt;的文件描述符。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;select&lt;/code&gt;系统调用 不是线程安全的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上&lt;code&gt;select&lt;/code&gt;的不足所产生的&lt;code&gt;性能开销&lt;/code&gt;都会随着并发量的增大而&lt;code&gt;线性增长&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显&lt;code&gt;select&lt;/code&gt;也不能解决&lt;code&gt;C10K&lt;/code&gt;问题，只适用于&lt;code&gt;1000&lt;/code&gt;个左右的并发连接场景。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;poll&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;poll&lt;/code&gt;相当于是改进版的&lt;code&gt;select&lt;/code&gt;，但是工作原理基本和&lt;code&gt;select&lt;/code&gt;没有本质的区别。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;poll&lt;/span&gt;&lt;span&gt;(struct pollfd *fds, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nfds, &lt;span&gt;int&lt;/span&gt; timeout)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;struct pollfd {&lt;br/&gt;    int   fd;         /* 文件描述符 */&lt;br/&gt;    short events;     /* 需要监听的事件 */&lt;br/&gt;    short revents;    /* 实际发生的事件 由内核修改设置 */&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select&lt;/code&gt;中使用的文件描述符集合是采用的固定长度为1024的&lt;code&gt;BitMap&lt;/code&gt;结构的&lt;code&gt;fd_set&lt;/code&gt;，而&lt;code&gt;poll&lt;/code&gt;换成了一个&lt;code&gt;pollfd&lt;/code&gt;结构没有固定长度的数组，这样就没有了最大描述符数量的限制（当然还会受到系统文件描述符限制）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;poll&lt;/code&gt;只是改进了&lt;code&gt;select&lt;/code&gt;只能监听&lt;code&gt;1024&lt;/code&gt;个文件描述符的数量限制，但是并没有在性能方面做出改进。和&lt;code&gt;select&lt;/code&gt;上本质并没有多大差别。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;同样需要在&lt;code&gt;内核空间&lt;/code&gt;和&lt;code&gt;用户空间&lt;/code&gt;中对文件描述符集合进行&lt;code&gt;轮询&lt;/code&gt;，查找出&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;的时间复杂度依然为&lt;code&gt;O(n)&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;同样需要将&lt;code&gt;包含大量文件描述符的集合&lt;/code&gt;整体在&lt;code&gt;用户空间&lt;/code&gt;和&lt;code&gt;内核空间&lt;/code&gt;之间&lt;code&gt;来回复制&lt;/code&gt;，&lt;strong&gt;无论这些文件描述符是否就绪&lt;/strong&gt;。他们的开销都会随着文件描述符数量的增加而线性增大。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;select，poll&lt;/code&gt;在每次新增，删除需要监听的socket时，都需要将整个新的&lt;code&gt;socket&lt;/code&gt;集合全量传至&lt;code&gt;内核&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;poll&lt;/code&gt;同样不适用高并发的场景。依然无法解决&lt;code&gt;C10K&lt;/code&gt;问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;epoll&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上边对&lt;code&gt;select,poll&lt;/code&gt;核心原理的介绍，我们看到&lt;code&gt;select,poll&lt;/code&gt;的性能瓶颈主要体现在下面三个地方：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;因为内核不会保存我们要监听的&lt;code&gt;socket&lt;/code&gt;集合，所以在每次调用&lt;code&gt;select,poll&lt;/code&gt;的时候都需要传入，传出全量的&lt;code&gt;socket&lt;/code&gt;文件描述符集合。这导致了大量的文件描述符在&lt;code&gt;用户空间&lt;/code&gt;和&lt;code&gt;内核空间&lt;/code&gt;频繁的来回复制。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由于内核不会通知具体&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;socket&lt;/code&gt;，只是在这些&lt;code&gt;IO就绪&lt;/code&gt;的socket上打好标记，所以当&lt;code&gt;select&lt;/code&gt;系统调用返回时，在&lt;code&gt;用户空间&lt;/code&gt;还是需要&lt;code&gt;完整遍历&lt;/code&gt;一遍&lt;code&gt;socket&lt;/code&gt;文件描述符集合来获取具体&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;socket&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在&lt;code&gt;内核空间&lt;/code&gt;中也是通过遍历的方式来得到&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;socket&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看下&lt;code&gt;epoll&lt;/code&gt;是如何解决这些问题的。在介绍&lt;code&gt;epoll&lt;/code&gt;的核心原理之前，我们需要介绍下理解&lt;code&gt;epoll&lt;/code&gt;工作过程所需要的一些核心基础知识。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Socket的创建&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端线程调用&lt;code&gt;accept&lt;/code&gt;系统调用后开始&lt;code&gt;阻塞&lt;/code&gt;，当有客户端连接上来并完成&lt;code&gt;TCP三次握手&lt;/code&gt;后，&lt;code&gt;内核&lt;/code&gt;会创建一个对应的&lt;code&gt;Socket&lt;/code&gt;作为服务端与客户端通信的&lt;code&gt;内核&lt;/code&gt;接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Linux内核的角度看来，一切皆是文件，&lt;code&gt;Socket&lt;/code&gt;也不例外，当内核创建出&lt;code&gt;Socket&lt;/code&gt;之后，会将这个&lt;code&gt;Socket&lt;/code&gt;放到当前进程所打开的文件列表中管理起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看下进程管理这些打开的文件列表相关的内核数据结构是什么样的？在了解完这些数据结构后，我们会更加清晰的理解&lt;code&gt;Socket&lt;/code&gt;在内核中所发挥的作用。并且对后面我们理解&lt;code&gt;epoll&lt;/code&gt;的创建过程有很大的帮助。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;进程中管理文件列表结构&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48629032258064514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEDCWo05bLDqtgBwGwAPGHKNGsXCEk7O6LB3ksNKFiaU4qgPouZwQDrFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;进程中管理文件列表结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;struct tast_struct&lt;/code&gt;是内核中用来表示进程的一个数据结构，它包含了进程的所有信息。本小节我们只列出和文件管理相关的属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中进程内打开的所有文件是通过一个数组&lt;code&gt;fd_array&lt;/code&gt;来进行组织管理，数组的下标即为我们常提到的&lt;code&gt;文件描述符&lt;/code&gt;，数组中存放的是对应的文件数据结构&lt;code&gt;struct file&lt;/code&gt;。每打开一个文件，内核都会创建一个&lt;code&gt;struct file&lt;/code&gt;与之对应，并在&lt;code&gt;fd_array&lt;/code&gt;中找到一个空闲位置分配给它，数组中对应的下标，就是我们在&lt;code&gt;用户空间&lt;/code&gt;用到的&lt;code&gt;文件描述符&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对于任何一个进程，默认情况下，文件描述符 &lt;code&gt;0&lt;/code&gt;表示 &lt;code&gt;stdin 标准输入&lt;/code&gt;，文件描述符 &lt;code&gt;1&lt;/code&gt;表示&lt;code&gt;stdout 标准输出&lt;/code&gt;，文件描述符&lt;code&gt;2&lt;/code&gt;表示&lt;code&gt;stderr 标准错误输出&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程中打开的文件列表&lt;code&gt;fd_array&lt;/code&gt;定义在内核数据结构&lt;code&gt;struct files_struct&lt;/code&gt;中，在&lt;code&gt;struct fdtable&lt;/code&gt;结构中有一个指针&lt;code&gt;struct fd **fd&lt;/code&gt;指向&lt;code&gt;fd_array&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;由于本小节讨论的是内核网络系统部分的数据结构&lt;/strong&gt;，所以这里拿&lt;code&gt;Socket&lt;/code&gt;文件类型来举例说明：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于封装文件元信息的内核数据结构&lt;code&gt;struct file&lt;/code&gt;中的&lt;code&gt;private_data&lt;/code&gt;指针指向具体的&lt;code&gt;Socket&lt;/code&gt;结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;struct file&lt;/code&gt;中的&lt;code&gt;file_operations&lt;/code&gt;属性定义了文件的操作函数，不同的文件类型，对应的&lt;code&gt;file_operations&lt;/code&gt;是不同的，针对&lt;code&gt;Socket&lt;/code&gt;文件类型，这里的&lt;code&gt;file_operations&lt;/code&gt;指向&lt;code&gt;socket_file_ops&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我们在&lt;code&gt;用户空间&lt;/code&gt;对&lt;code&gt;Socket&lt;/code&gt;发起的读写等系统调用，进入内核首先会调用的是&lt;code&gt;Socket&lt;/code&gt;对应的&lt;code&gt;struct file&lt;/code&gt;中指向的&lt;code&gt;socket_file_ops&lt;/code&gt;。&lt;strong&gt;比如&lt;/strong&gt;：对&lt;code&gt;Socket&lt;/code&gt;发起&lt;code&gt;write&lt;/code&gt;写操作，在内核中首先被调用的就是&lt;code&gt;socket_file_ops&lt;/code&gt;中定义的&lt;code&gt;sock_write_iter&lt;/code&gt;。&lt;code&gt;Socket&lt;/code&gt;发起&lt;code&gt;read&lt;/code&gt;读操作内核中对应的则是&lt;code&gt;sock_read_iter&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file_operations&lt;/span&gt; &lt;span&gt;socket_file_ops&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;  .owner =  THIS_MODULE,&lt;br/&gt;  .llseek =  no_llseek,&lt;br/&gt;  .read_iter =  sock_read_iter,&lt;br/&gt;  .write_iter =  sock_write_iter,&lt;br/&gt;  .poll =    sock_poll,&lt;br/&gt;  .unlocked_ioctl = sock_ioctl,&lt;br/&gt;  .mmap =    sock_mmap,&lt;br/&gt;  .release =  sock_close,&lt;br/&gt;  .fasync =  sock_fasync,&lt;br/&gt;  .sendpage =  sock_sendpage,&lt;br/&gt;  .splice_write = generic_splice_sendpage,&lt;br/&gt;  .splice_read =  sock_splice_read,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Socket内核结构&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6056451612903225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEV2mJ5ffNML0pVxP679iapicwtrNvRLjAuPJ9EOS0J2VFDtuMicX3Lw3cQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Socket内核结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们进行网络程序的编写时会首先创建一个&lt;code&gt;Socket&lt;/code&gt;，然后基于这个&lt;code&gt;Socket&lt;/code&gt;进行&lt;code&gt;bind&lt;/code&gt;，&lt;code&gt;listen&lt;/code&gt;，我们先将这个&lt;code&gt;Socket&lt;/code&gt;称作为&lt;code&gt;监听Socket&lt;/code&gt;。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当我们调用&lt;code&gt;accept&lt;/code&gt;后，内核会基于&lt;code&gt;监听Socket&lt;/code&gt;创建出来一个新的&lt;code&gt;Socket&lt;/code&gt;专门用于与客户端之间的网络通信。并将&lt;code&gt;监听Socket&lt;/code&gt;中的&lt;code&gt;Socket操作函数集合&lt;/code&gt;（&lt;code&gt;inet_stream_ops&lt;/code&gt;）&lt;code&gt;ops&lt;/code&gt;赋值到新的&lt;code&gt;Socket&lt;/code&gt;的&lt;code&gt;ops&lt;/code&gt;属性中。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;proto_ops&lt;/span&gt; &lt;span&gt;inet_stream_ops&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;  .bind = inet_bind,&lt;br/&gt;  .connect = inet_stream_connect,&lt;br/&gt;  .accept = inet_accept,&lt;br/&gt;  .poll = tcp_poll,&lt;br/&gt;  .listen = inet_listen,&lt;br/&gt;  .sendmsg = inet_sendmsg,&lt;br/&gt;  .recvmsg = inet_recvmsg,&lt;br/&gt;  ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里需要注意的是，&lt;code&gt;监听的 socket&lt;/code&gt;和真正用来网络通信的 &lt;code&gt;Socket&lt;/code&gt;，是两个 Socket，一个叫作&lt;code&gt;监听 Socket&lt;/code&gt;，一个叫作&lt;code&gt;已连接的Socket&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;接着内核会为&lt;code&gt;已连接的Socket&lt;/code&gt;创建&lt;code&gt;struct file&lt;/code&gt;并初始化，并把Socket文件操作函数集合（&lt;code&gt;socket_file_ops&lt;/code&gt;）赋值给&lt;code&gt;struct file&lt;/code&gt;中的&lt;code&gt;f_ops&lt;/code&gt;指针。然后将&lt;code&gt;struct socket&lt;/code&gt;中的&lt;code&gt;file&lt;/code&gt;指针指向这个新分配申请的&lt;code&gt;struct file&lt;/code&gt;结构体。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;内核会维护两个队列：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个是已经完成&lt;code&gt;TCP三次握手&lt;/code&gt;，连接状态处于&lt;code&gt;established&lt;/code&gt;的连接队列。内核中为&lt;code&gt;icsk_accept_queue&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个是还没有完成&lt;code&gt;TCP三次握手&lt;/code&gt;，连接状态处于&lt;code&gt;syn_rcvd&lt;/code&gt;的半连接队列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;然后调用&lt;code&gt;socket-&amp;gt;ops-&amp;gt;accept&lt;/code&gt;，从&lt;code&gt;Socket内核结构图&lt;/code&gt;中我们可以看到其实调用的是&lt;code&gt;inet_accept&lt;/code&gt;，该函数会在&lt;code&gt;icsk_accept_queue&lt;/code&gt;中查找是否有已经建立好的连接，如果有的话，直接从&lt;code&gt;icsk_accept_queue&lt;/code&gt;中获取已经创建好的&lt;code&gt;struct sock&lt;/code&gt;。并将这个&lt;code&gt;struct sock&lt;/code&gt;对象赋值给&lt;code&gt;struct socket&lt;/code&gt;中的&lt;code&gt;sock&lt;/code&gt;指针。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;struct sock&lt;/code&gt;在&lt;code&gt;struct socket&lt;/code&gt;中是一个非常核心的内核对象，正是在这里定义了我们在介绍&lt;code&gt;网络包的接收发送流程&lt;/code&gt;中提到的&lt;code&gt;接收队列&lt;/code&gt;，&lt;code&gt;发送队列&lt;/code&gt;，&lt;code&gt;等待队列&lt;/code&gt;，&lt;code&gt;数据就绪回调函数指针&lt;/code&gt;，&lt;code&gt;内核协议栈操作函数集合&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据创建&lt;code&gt;Socket&lt;/code&gt;时发起的系统调用&lt;code&gt;sock_create&lt;/code&gt;中的&lt;code&gt;protocol&lt;/code&gt;参数(对于&lt;code&gt;TCP协议&lt;/code&gt;这里的参数值为&lt;code&gt;SOCK_STREAM&lt;/code&gt;)查找到对于 tcp 定义的操作方法实现集合 &lt;code&gt;inet_stream_ops&lt;/code&gt; 和&lt;code&gt;tcp_prot&lt;/code&gt;。并把它们分别设置到&lt;code&gt;socket-&amp;gt;ops&lt;/code&gt;和&lt;code&gt;sock-&amp;gt;sk_prot&lt;/code&gt;上。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里可以回看下本小节开头的《Socket内核结构图》捋一下他们之间的关系。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;socket&lt;/code&gt;相关的操作接口定义在&lt;code&gt;inet_stream_ops&lt;/code&gt;函数集合中，负责对上给用户提供接口。而&lt;code&gt;socket&lt;/code&gt;与内核协议栈之间的操作接口定义在&lt;code&gt;struct sock&lt;/code&gt;中的&lt;code&gt;sk_prot&lt;/code&gt;指针上，这里指向&lt;code&gt;tcp_prot&lt;/code&gt;协议操作函数集合。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;proto&lt;/span&gt; &lt;span&gt;tcp_prot&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;  .name      = &lt;span&gt;&quot;TCP&quot;&lt;/span&gt;,&lt;br/&gt;  .owner      = THIS_MODULE,&lt;br/&gt;  .close      = tcp_close,&lt;br/&gt;  .connect    = tcp_v4_connect,&lt;br/&gt;  .disconnect    = tcp_disconnect,&lt;br/&gt;  .accept      = inet_csk_accept,&lt;br/&gt;  .keepalive    = tcp_set_keepalive,&lt;br/&gt;  .recvmsg    = tcp_recvmsg,&lt;br/&gt;  .sendmsg    = tcp_sendmsg,&lt;br/&gt;  .backlog_rcv    = tcp_v4_do_rcv,&lt;br/&gt;   ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;之前提到的对&lt;code&gt;Socket&lt;/code&gt;发起的系统IO调用，在内核中首先会调用&lt;code&gt;Socket&lt;/code&gt;的文件结构&lt;code&gt;struct file&lt;/code&gt;中的&lt;code&gt;file_operations&lt;/code&gt;文件操作集合，然后调用&lt;code&gt;struct socket&lt;/code&gt;中的&lt;code&gt;ops&lt;/code&gt;指向的&lt;code&gt;inet_stream_ops&lt;/code&gt;socket操作函数，最终调用到&lt;code&gt;struct sock&lt;/code&gt;中&lt;code&gt;sk_prot&lt;/code&gt;指针指向的&lt;code&gt;tcp_prot&lt;/code&gt;内核协议栈操作函数接口集合。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5620967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEulX0vLf43hBicEqX8FejWO7Z5ru4ZyWKVmQ5gRSoLruicozQOwotH6fQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;系统IO调用结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将&lt;code&gt;struct sock&lt;/code&gt; 对象中的&lt;code&gt;sk_data_ready&lt;/code&gt; 函数指针设置为 &lt;code&gt;sock_def_readable&lt;/code&gt;，在&lt;code&gt;Socket&lt;/code&gt;数据就绪的时候内核会回调该函数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;struct sock&lt;/code&gt;中的&lt;code&gt;等待队列&lt;/code&gt;中存放的是系统IO调用发生阻塞的&lt;code&gt;进程fd&lt;/code&gt;，以及相应的&lt;code&gt;回调函数&lt;/code&gt;。&lt;strong&gt;记住这个地方，后边介绍epoll的时候我们还会提到！&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当&lt;code&gt;struct file&lt;/code&gt;，&lt;code&gt;struct socket&lt;/code&gt;，&lt;code&gt;struct sock&lt;/code&gt;这些核心的内核对象创建好之后，最后就是把&lt;code&gt;socket&lt;/code&gt;对象对应的&lt;code&gt;struct file&lt;/code&gt;放到进程打开的文件列表&lt;code&gt;fd_array&lt;/code&gt;中。随后系统调用&lt;code&gt;accept&lt;/code&gt;返回&lt;code&gt;socket&lt;/code&gt;的文件描述符&lt;code&gt;fd&lt;/code&gt;给用户程序。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;阻塞IO中用户进程阻塞以及唤醒原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前边小节我们介绍&lt;code&gt;阻塞IO&lt;/code&gt;的时候提到，当用户进程发起系统IO调用时，这里我们拿&lt;code&gt;read&lt;/code&gt;举例，用户进程会在&lt;code&gt;内核态&lt;/code&gt;查看对应&lt;code&gt;Socket&lt;/code&gt;接收缓冲区是否有数据到来。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Socket&lt;/code&gt;接收缓冲区有数据，则拷贝数据到&lt;code&gt;用户空间&lt;/code&gt;，系统调用返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Socket&lt;/code&gt;接收缓冲区没有数据，则用户进程让出&lt;code&gt;CPU&lt;/code&gt;进入&lt;code&gt;阻塞状态&lt;/code&gt;，当数据到达接收缓冲区时，用户进程会被唤醒，从&lt;code&gt;阻塞状态&lt;/code&gt;进入&lt;code&gt;就绪状态&lt;/code&gt;，等待CPU调度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节我们就来看下用户进程是如何&lt;code&gt;阻塞&lt;/code&gt;在&lt;code&gt;Socket&lt;/code&gt;上，又是如何在&lt;code&gt;Socket&lt;/code&gt;上被唤醒的。&lt;strong&gt;理解这个过程很重要，对我们理解epoll的事件通知过程很有帮助&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先我们在用户进程中对&lt;code&gt;Socket&lt;/code&gt;进行&lt;code&gt;read&lt;/code&gt;系统调用时，用户进程会从&lt;code&gt;用户态&lt;/code&gt;转为&lt;code&gt;内核态&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在进程的&lt;code&gt;struct task_struct&lt;/code&gt;结构找到&lt;code&gt;fd_array&lt;/code&gt;，并根据&lt;code&gt;Socket&lt;/code&gt;的文件描述符&lt;code&gt;fd&lt;/code&gt;找到对应的&lt;code&gt;struct file&lt;/code&gt;，调用&lt;code&gt;struct file&lt;/code&gt;中的文件操作函数结合&lt;code&gt;file_operations&lt;/code&gt;，&lt;code&gt;read&lt;/code&gt;系统调用对应的是&lt;code&gt;sock_read_iter&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;sock_read_iter&lt;/code&gt;函数中找到&lt;code&gt;struct file&lt;/code&gt;指向的&lt;code&gt;struct socket&lt;/code&gt;，并调用&lt;code&gt;socket-&amp;gt;ops-&amp;gt;recvmsg&lt;/code&gt;，这里我们知道调用的是&lt;code&gt;inet_stream_ops&lt;/code&gt;集合中定义的&lt;code&gt;inet_recvmsg&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;inet_recvmsg&lt;/code&gt;中会找到&lt;code&gt;struct sock&lt;/code&gt;，并调用&lt;code&gt;sock-&amp;gt;skprot-&amp;gt;recvmsg&lt;/code&gt;,这里调用的是&lt;code&gt;tcp_prot&lt;/code&gt;集合中定义的&lt;code&gt;tcp_recvmsg&lt;/code&gt;函数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;整个调用过程可以参考上边的《系统IO调用结构图》&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;熟悉了内核函数调用栈后，我们来看下系统IO调用在&lt;code&gt;tcp_recvmsg&lt;/code&gt;内核函数中是如何将用户进程给阻塞掉的&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6217741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEmK3jYMPOt7rib3Q5g7XFoaibh594gLT4uFERshJOcs9TGdVajaRaVYkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;系统IO调用阻塞原理.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;tcp_recvmsg&lt;/span&gt;&lt;span&gt;(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; len, &lt;span&gt;int&lt;/span&gt; nonblock, &lt;span&gt;int&lt;/span&gt; flags, &lt;span&gt;int&lt;/span&gt; *addr_len)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    .................省略非核心代码...............&lt;br/&gt;   &lt;span&gt;//访问sock对象中定义的接收队列&lt;/span&gt;&lt;br/&gt;  skb_queue_walk(&amp;amp;sk-&amp;gt;sk_receive_queue, skb) {&lt;br/&gt;&lt;br/&gt;    .................省略非核心代码...............&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//没有收到足够数据，调用sk_wait_data 阻塞当前进程&lt;/span&gt;&lt;br/&gt;  sk_wait_data(sk, &amp;amp;timeo);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;sk_wait_data&lt;/span&gt;&lt;span&gt;(struct sock *sk, &lt;span&gt;long&lt;/span&gt; *timeo)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//创建struct sock中等待队列上的元素wait_queue_t&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//将进程描述符和回调函数autoremove_wake_function关联到wait_queue_t中&lt;/span&gt;&lt;br/&gt; DEFINE_WAIT(wait);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 调用 sk_sleep 获取 sock 对象下的等待队列的头指针wait_queue_head_t&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 调用prepare_to_wait将新创建的等待项wait_queue_t插入到等待队列中，并将进程状态设置为可打断 INTERRUPTIBLE&lt;/span&gt;&lt;br/&gt; prepare_to_wait(sk_sleep(sk), &amp;amp;wait, TASK_INTERRUPTIBLE);&lt;br/&gt; set_bit(SOCK_ASYNC_WAITDATA, &amp;amp;sk-&amp;gt;sk_socket-&amp;gt;flags);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 通过调用schedule_timeout让出CPU，然后进行睡眠，导致一次上下文切换&lt;/span&gt;&lt;br/&gt; rc = sk_wait_event(sk, timeo, !skb_queue_empty(&amp;amp;sk-&amp;gt;sk_receive_queue));&lt;br/&gt; ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先会在&lt;code&gt;DEFINE_WAIT&lt;/code&gt;中创建&lt;code&gt;struct sock&lt;/code&gt;中等待队列上的等待类型&lt;code&gt;wait_queue_t&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; DEFINE_WAIT_FUNC(name, function)    \&lt;br/&gt; wait_queue_t name = {      \&lt;br/&gt;  .private = current,    \&lt;br/&gt;  .func  = function,    \&lt;br/&gt;  .task_list = LIST_HEAD_INIT((name).task_list), \&lt;br/&gt; }&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等待类型&lt;code&gt;wait_queue_t&lt;/code&gt;中的&lt;code&gt;private&lt;/code&gt;用来关联&lt;code&gt;阻塞&lt;/code&gt;在当前&lt;code&gt;socket&lt;/code&gt;上的用户进程&lt;code&gt;fd&lt;/code&gt;。&lt;code&gt;func&lt;/code&gt;用来关联等待项上注册的回调函数。这里注册的是&lt;code&gt;autoremove_wake_function&lt;/code&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;调用&lt;code&gt;sk_sleep(sk)&lt;/code&gt;获取&lt;code&gt;struct sock&lt;/code&gt;对象中的等待队列头指针&lt;code&gt;wait_queue_head_t&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;调用&lt;code&gt;prepare_to_wait&lt;/code&gt;将新创建的等待项&lt;code&gt;wait_queue_t&lt;/code&gt;插入到等待队列中，并将进程设置为可打断 &lt;code&gt;INTERRUPTIBL&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;调用&lt;code&gt;sk_wait_event&lt;/code&gt;让出CPU，进程进入睡眠状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户进程的&lt;code&gt;阻塞过程&lt;/code&gt;我们就介绍完了，关键是要理解记住&lt;code&gt;struct sock&lt;/code&gt;中定义的等待队列上的等待类型&lt;code&gt;wait_queue_t&lt;/code&gt;的结构。后面&lt;code&gt;epoll&lt;/code&gt;的介绍中我们还会用到它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;下面我们接着介绍当数据就绪后，用户进程是如何被唤醒的&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文开始介绍《网络包接收过程》这一小节中我们提到：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当网络数据包到达网卡时，网卡通过&lt;code&gt;DMA&lt;/code&gt;的方式将数据放到&lt;code&gt;RingBuffer&lt;/code&gt;中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后向CPU发起硬中断，在硬中断响应程序中创建&lt;code&gt;sk_buffer&lt;/code&gt;，并将网络数据拷贝至&lt;code&gt;sk_buffer&lt;/code&gt;中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;随后发起软中断，内核线程&lt;code&gt;ksoftirqd&lt;/code&gt;响应软中断，调用&lt;code&gt;poll函数&lt;/code&gt;将&lt;code&gt;sk_buffer&lt;/code&gt;送往内核协议栈做层层协议处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在传输层&lt;code&gt;tcp_rcv 函数&lt;/code&gt;中，去掉TCP头，根据&lt;code&gt;四元组（源IP，源端口，目的IP，目的端口）&lt;/code&gt;查找对应的&lt;code&gt;Socket&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后将&lt;code&gt;sk_buffer&lt;/code&gt;放到&lt;code&gt;Socket&lt;/code&gt;中的接收队列里。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边这些过程是内核接收网络数据的完整过程，下边我们来看下，当数据包接收完毕后，用户进程是如何被唤醒的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5870967741935483&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcE9kTceMWn7KUGpgqK5Sq7nMgTBs4UkZwJ5Mor0WEibKZvLBxLeV0dJJg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;系统IO调用唤醒原理.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当软中断将&lt;code&gt;sk_buffer&lt;/code&gt;放到&lt;code&gt;Socket&lt;/code&gt;的接收队列上时，接着就会调用&lt;code&gt;数据就绪函数回调指针sk_data_ready&lt;/code&gt;，前边我们提到，这个函数指针在初始化的时候指向了&lt;code&gt;sock_def_readable&lt;/code&gt;函数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在&lt;code&gt;sock_def_readable&lt;/code&gt;函数中会去获取&lt;code&gt;socket-&amp;gt;sock-&amp;gt;sk_wq&lt;/code&gt;等待队列。在&lt;code&gt;wake_up_common&lt;/code&gt;函数中从等待队列&lt;code&gt;sk_wq&lt;/code&gt;中找出&lt;code&gt;一个&lt;/code&gt;等待项&lt;code&gt;wait_queue_t&lt;/code&gt;，回调注册在该等待项上的&lt;code&gt;func&lt;/code&gt;回调函数（&lt;code&gt;wait_queue_t-&amp;gt;func&lt;/code&gt;）,创建等待项&lt;code&gt;wait_queue_t&lt;/code&gt;是我们提到，这里注册的回调函数是&lt;code&gt;autoremove_wake_function&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;即使是有多个进程都阻塞在同一个 socket 上，也只唤醒 1 个进程。其作用是为了避免惊群。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;autoremove_wake_function&lt;/code&gt;函数中，根据等待项&lt;code&gt;wait_queue_t&lt;/code&gt;上的&lt;code&gt;private&lt;/code&gt;关联的&lt;code&gt;阻塞进程fd&lt;/code&gt;调用&lt;code&gt;try_to_wake_up&lt;/code&gt;唤醒阻塞在该&lt;code&gt;Socket&lt;/code&gt;上的进程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;记住&lt;code&gt;wait_queue_t&lt;/code&gt;中的&lt;code&gt;func&lt;/code&gt;函数指针，在&lt;code&gt;epoll&lt;/code&gt;中这里会注册&lt;code&gt;epoll&lt;/code&gt;的回调函数。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在理解&lt;code&gt;epoll&lt;/code&gt;所需要的基础知识我们就介绍完了，唠叨了这么多，下面终于正式进入本小节的主题&lt;code&gt;epoll&lt;/code&gt;了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;epoll_create创建epoll对象&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;epoll_create&lt;/code&gt;是内核提供给我们创建&lt;code&gt;epoll&lt;/code&gt;对象的一个系统调用，当我们在用户进程中调用&lt;code&gt;epoll_create&lt;/code&gt;时，内核会为我们创建一个&lt;code&gt;struct eventpoll&lt;/code&gt;对象，并且也有相应的&lt;code&gt;struct file&lt;/code&gt;与之关联，同样需要把这个&lt;code&gt;struct eventpoll&lt;/code&gt;对象所关联的&lt;code&gt;struct file&lt;/code&gt;放入进程打开的文件列表&lt;code&gt;fd_array&lt;/code&gt;中管理。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;熟悉了&lt;code&gt;Socket&lt;/code&gt;的创建逻辑，&lt;code&gt;epoll&lt;/code&gt;的创建逻辑也就不难理解了。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;struct eventpoll&lt;/code&gt;对象关联的&lt;code&gt;struct file&lt;/code&gt;中的&lt;code&gt;file_operations 指针&lt;/code&gt;指向的是&lt;code&gt;eventpoll_fops&lt;/code&gt;操作函数集合。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file_operations&lt;/span&gt; &lt;span&gt;eventpoll_fops&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;     .release = ep_eventpoll_release;&lt;br/&gt;     .poll = ep_eventpoll_poll,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6854838709677419&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEibKwPYGuZaNbHCJ6jeia6TBicsgdh0cicLaIaHaGgLomLzb9h2r3Wfd3Cw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;eopll在进程中的整体结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;eventpoll&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//等待队列，阻塞在epoll上的进程会放在这里&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;wait_queue_head_t&lt;/span&gt; wq;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//就绪队列，IO就绪的socket连接会放在这里&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;list_head&lt;/span&gt; &lt;span&gt;rdllist&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//红黑树用来管理所有监听的socket连接&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;rb_root&lt;/span&gt; &lt;span&gt;rbr&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;wait_queue_head_t wq：&lt;/code&gt;epoll中的等待队列，队列里存放的是&lt;code&gt;阻塞&lt;/code&gt;在&lt;code&gt;epoll&lt;/code&gt;上的用户进程。在&lt;code&gt;IO就绪&lt;/code&gt;的时候&lt;code&gt;epoll&lt;/code&gt;可以通过这个队列找到这些&lt;code&gt;阻塞&lt;/code&gt;的进程并唤醒它们，从而执行&lt;code&gt;IO调用&lt;/code&gt;读写&lt;code&gt;Socket&lt;/code&gt;上的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里注意与&lt;code&gt;Socket&lt;/code&gt;中的等待队列区分！！！&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;struct list_head rdllist：&lt;/code&gt;epoll中的就绪队列，队列里存放的是都是&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;，被唤醒的用户进程可以直接读取这个队列获取&lt;code&gt;IO活跃&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;。无需再次遍历整个&lt;code&gt;Socket&lt;/code&gt;集合。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里正是&lt;code&gt;epoll&lt;/code&gt;比&lt;code&gt;select ，poll&lt;/code&gt;高效之处，&lt;code&gt;select ，poll&lt;/code&gt;返回的是全部的&lt;code&gt;socket&lt;/code&gt;连接，我们需要在&lt;code&gt;用户空间&lt;/code&gt;再次遍历找出真正&lt;code&gt;IO活跃&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;连接。而&lt;code&gt;epoll&lt;/code&gt;只是返回&lt;code&gt;IO活跃&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;连接。用户进程可以直接进行IO操作。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;struct rb_root rbr :&lt;/code&gt; 由于红黑树在&lt;code&gt;查找&lt;/code&gt;，&lt;code&gt;插入&lt;/code&gt;，&lt;code&gt;删除&lt;/code&gt;等综合性能方面是最优的，所以epoll内部使用一颗红黑树来管理海量的&lt;code&gt;Socket&lt;/code&gt;连接。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;select&lt;/code&gt;用&lt;code&gt;数组&lt;/code&gt;管理连接，&lt;code&gt;poll&lt;/code&gt;用&lt;code&gt;链表&lt;/code&gt;管理连接。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;epoll_ctl向epoll对象中添加监听的Socket&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们调用&lt;code&gt;epoll_create&lt;/code&gt;在内核中创建出&lt;code&gt;epoll&lt;/code&gt;对象&lt;code&gt;struct eventpoll&lt;/code&gt;后，我们就可以利用&lt;code&gt;epoll_ctl&lt;/code&gt;向&lt;code&gt;epoll&lt;/code&gt;中添加我们需要管理的&lt;code&gt;Socket&lt;/code&gt;连接了。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先要在epoll内核中创建一个表示&lt;code&gt;Socket连接&lt;/code&gt;的数据结构&lt;code&gt;struct epitem&lt;/code&gt;，而在&lt;code&gt;epoll&lt;/code&gt;中为了综合性能的考虑，采用一颗红黑树来管理这些海量&lt;code&gt;socket连接&lt;/code&gt;。所以&lt;code&gt;struct epitem&lt;/code&gt;是一个红黑树节点。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.775&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEItBeLMXJPAJtcYN6yeNKBbIkH8pCgeic4CIpFTJqrBJ4IkAxJH6JaEg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;struct epitem.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;epitem&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;//指向所属epoll对象&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;eventpoll&lt;/span&gt; *&lt;span&gt;ep&lt;/span&gt;;&lt;/span&gt; &lt;br/&gt;      &lt;span&gt;//注册的感兴趣的事件,也就是用户空间的epoll_event     &lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;epoll_event&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;;&lt;/span&gt; &lt;br/&gt;      &lt;span&gt;//指向epoll对象中的就绪队列&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;list_head&lt;/span&gt; &lt;span&gt;rdllink&lt;/span&gt;;&lt;/span&gt;  &lt;br/&gt;      &lt;span&gt;//指向epoll中对应的红黑树节点&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;rb_node&lt;/span&gt; &lt;span&gt;rbn&lt;/span&gt;;&lt;/span&gt;     &lt;br/&gt;      &lt;span&gt;//指向epitem所表示的socket-&amp;gt;file结构以及对应的fd&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;epoll_filefd&lt;/span&gt; &lt;span&gt;ffd&lt;/span&gt;;&lt;/span&gt;                  &lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里重点记住&lt;code&gt;struct epitem&lt;/code&gt;结构中的&lt;code&gt;rdllink&lt;/code&gt;以及&lt;code&gt;epoll_filefd&lt;/code&gt;成员，后面我们会用到。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在内核中创建完表示&lt;code&gt;Socket连接&lt;/code&gt;的数据结构&lt;code&gt;struct epitem&lt;/code&gt;后，我们就需要在&lt;code&gt;Socket&lt;/code&gt;中的等待队列上创建等待项&lt;code&gt;wait_queue_t&lt;/code&gt;并且注册&lt;code&gt;epoll的回调函数ep_poll_callback&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;《阻塞IO中用户进程阻塞以及唤醒原理》&lt;/code&gt;小节的铺垫，我想大家已经猜到这一步的意义所在了吧！当时在等待项&lt;code&gt;wait_queue_t&lt;/code&gt;中注册的是&lt;code&gt;autoremove_wake_function&lt;/code&gt;回调函数。还记得吗？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;epoll的回调函数&lt;code&gt;ep_poll_callback&lt;/code&gt;正是&lt;code&gt;epoll&lt;/code&gt;同步IO事件通知机制的核心所在，也是区别于&lt;code&gt;select，poll&lt;/code&gt;采用内核轮询方式的根本性能差异所在。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5516129032258065&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEkerTL14uiakMoYWeslKZrAXfMibzAwSt2CE6LmTbHMI6yK1oolEvCqAQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;epitem创建等待项.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里又出现了一个新的数据结构&lt;code&gt;struct eppoll_entry&lt;/code&gt;，那它的作用是干什么的呢？大家可以结合上图先猜测下它的作用!&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道&lt;code&gt;socket-&amp;gt;sock-&amp;gt;sk_wq&lt;/code&gt;等待队列中的类型是&lt;code&gt;wait_queue_t&lt;/code&gt;，我们需要在&lt;code&gt;struct epitem&lt;/code&gt;所表示的&lt;code&gt;socket&lt;/code&gt;的等待队列上注册&lt;code&gt;epoll&lt;/code&gt;回调函数&lt;code&gt;ep_poll_callback&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样当数据到达&lt;code&gt;socket&lt;/code&gt;中的接收队列时，内核会回调&lt;code&gt;sk_data_ready&lt;/code&gt;，在&lt;code&gt;阻塞IO中用户进程阻塞以及唤醒原理&lt;/code&gt;这一小节中，我们知道这个&lt;code&gt;sk_data_ready&lt;/code&gt;函数指针会指向&lt;code&gt;sk_def_readable&lt;/code&gt;函数，在&lt;code&gt;sk_def_readable&lt;/code&gt;中会回调注册在等待队列里的等待项&lt;code&gt;wait_queue_t -&amp;gt; func&lt;/code&gt;回调函数&lt;code&gt;ep_poll_callback&lt;/code&gt;。&lt;strong&gt;在&lt;code&gt;ep_poll_callback&lt;/code&gt;中需要找到&lt;code&gt;epitem&lt;/code&gt;&lt;/strong&gt;，将&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;epitem&lt;/code&gt;放入&lt;code&gt;epoll&lt;/code&gt;中的就绪队列中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;socket&lt;/code&gt;等待队列中类型是&lt;code&gt;wait_queue_t&lt;/code&gt;无法关联到&lt;code&gt;epitem&lt;/code&gt;。所以就出现了&lt;code&gt;struct eppoll_entry&lt;/code&gt;结构体，它的作用就是关联&lt;code&gt;Socket&lt;/code&gt;等待队列中的等待项&lt;code&gt;wait_queue_t&lt;/code&gt;和&lt;code&gt;epitem&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;eppoll_entry&lt;/span&gt; {&lt;/span&gt; &lt;br/&gt;   &lt;span&gt;//指向关联的epitem&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;epitem&lt;/span&gt; *&lt;span&gt;base&lt;/span&gt;;&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 关联监听socket中等待队列中的等待项 (private = null  func = ep_poll_callback)&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;wait_queue_t&lt;/span&gt; wait;   &lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// 监听socket中等待队列头指针&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;wait_queue_head_t&lt;/span&gt; *whead; &lt;br/&gt;    .........&lt;br/&gt;  }; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在&lt;code&gt;ep_poll_callback&lt;/code&gt;回调函数中就可以根据&lt;code&gt;Socket&lt;/code&gt;等待队列中的等待项&lt;code&gt;wait&lt;/code&gt;，通过&lt;code&gt;container_of宏&lt;/code&gt;找到&lt;code&gt;eppoll_entry&lt;/code&gt;，继而找到&lt;code&gt;epitem&lt;/code&gt;了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;container_of&lt;/code&gt;在Linux内核中是一个常用的宏，用于从包含在某个结构中的指针获得结构本身的指针，通俗地讲就是通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里需要注意下这次等待项&lt;code&gt;wait_queue_t&lt;/code&gt;中的&lt;code&gt;private&lt;/code&gt;设置的是&lt;code&gt;null&lt;/code&gt;，因为这里&lt;code&gt;Socket&lt;/code&gt;是交给&lt;code&gt;epoll&lt;/code&gt;来管理的，阻塞在&lt;code&gt;Socket&lt;/code&gt;上的进程是也由&lt;code&gt;epoll&lt;/code&gt;来唤醒。在等待项&lt;code&gt;wait_queue_t&lt;/code&gt;注册的&lt;code&gt;func&lt;/code&gt;是&lt;code&gt;ep_poll_callback&lt;/code&gt;而不是&lt;code&gt;autoremove_wake_function&lt;/code&gt;，&lt;code&gt;阻塞进程&lt;/code&gt;并不需要&lt;code&gt;autoremove_wake_function&lt;/code&gt;来唤醒，所以这里设置&lt;code&gt;private&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当在&lt;code&gt;Socket&lt;/code&gt;的等待队列中创建好等待项&lt;code&gt;wait_queue_t&lt;/code&gt;并且注册了&lt;code&gt;epoll&lt;/code&gt;的回调函数&lt;code&gt;ep_poll_callback&lt;/code&gt;，然后又通过&lt;code&gt;eppoll_entry&lt;/code&gt;关联了&lt;code&gt;epitem&lt;/code&gt;后。剩下要做的就是将&lt;code&gt;epitem&lt;/code&gt;插入到&lt;code&gt;epoll&lt;/code&gt;中的红黑树&lt;code&gt;struct rb_root rbr&lt;/code&gt;中。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里可以看到&lt;code&gt;epoll&lt;/code&gt;另一个优化的地方，&lt;code&gt;epoll&lt;/code&gt;将所有的&lt;code&gt;socket&lt;/code&gt;连接通过内核中的红黑树来集中管理。每次添加或者删除&lt;code&gt;socket连接&lt;/code&gt;都是增量添加删除，而不是像&lt;code&gt;select，poll&lt;/code&gt;那样每次调用都是全量&lt;code&gt;socket连接&lt;/code&gt;集合传入内核。避免了&lt;code&gt;频繁大量&lt;/code&gt;的&lt;code&gt;内存拷贝&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;epoll_wait同步阻塞获取IO就绪的Socket&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户程序调用&lt;code&gt;epoll_wait&lt;/code&gt;后，内核首先会查找epoll中的就绪队列&lt;code&gt;eventpoll-&amp;gt;rdllist&lt;/code&gt;是否有&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;epitem&lt;/code&gt;。&lt;code&gt;epitem&lt;/code&gt;里封装了&lt;code&gt;socket&lt;/code&gt;的信息。如果就绪队列中有就绪的&lt;code&gt;epitem&lt;/code&gt;，就将&lt;code&gt;就绪的socket&lt;/code&gt;信息封装到&lt;code&gt;epoll_event&lt;/code&gt;返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果&lt;code&gt;eventpoll-&amp;gt;rdllist&lt;/code&gt;就绪队列中没有&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;epitem&lt;/code&gt;，则会创建等待项&lt;code&gt;wait_queue_t&lt;/code&gt;，将用户进程的&lt;code&gt;fd&lt;/code&gt;关联到&lt;code&gt;wait_queue_t-&amp;gt;private&lt;/code&gt;上，并在等待项&lt;code&gt;wait_queue_t-&amp;gt;func&lt;/code&gt;上注册回调函数&lt;code&gt;default_wake_function&lt;/code&gt;。最后将等待项添加到&lt;code&gt;epoll&lt;/code&gt;中的等待队列中。用户进程让出CPU，进入&lt;code&gt;阻塞状态&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5056451612903226&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEG5wWc27ZGXv7sBleibFeuPfEuyfibG9VolWJCiaHlp0DZoYoibpwb3MgNA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;epoll_wait同步获取数据.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里和&lt;code&gt;阻塞IO模型&lt;/code&gt;中的阻塞原理是一样的，只不过在&lt;code&gt;阻塞IO模型&lt;/code&gt;中注册到等待项&lt;code&gt;wait_queue_t-&amp;gt;func&lt;/code&gt;上的是&lt;code&gt;autoremove_wake_function&lt;/code&gt;，并将等待项添加到&lt;code&gt;socket&lt;/code&gt;中的等待队列中。这里注册的是&lt;code&gt;default_wake_function&lt;/code&gt;，将等待项添加到&lt;code&gt;epoll&lt;/code&gt;中的等待队列上。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4475806451612903&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEl2MECv0ibicDsbibN5ZJaql9ziaJMEFNtzEoxr5LcJuR9vaojRYZ5kyOfA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;数据到来epoll_wait流程.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;前边做了那么多的知识铺垫，下面终于到了&lt;code&gt;epoll&lt;/code&gt;的整个工作流程了：&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4967741935483871&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEgGR4zpAZARg0IVDCjFjwuukcBZsicw9tmJeO2CCda9x4EwMRZibXptWg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;epoll_wait处理过程.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当网络数据包在软中断中经过内核协议栈的处理到达&lt;code&gt;socket&lt;/code&gt;的接收缓冲区时，紧接着会调用socket的数据就绪回调指针&lt;code&gt;sk_data_ready&lt;/code&gt;，回调函数为&lt;code&gt;sock_def_readable&lt;/code&gt;。在&lt;code&gt;socket&lt;/code&gt;的等待队列中找出等待项，其中等待项中注册的回调函数为&lt;code&gt;ep_poll_callback&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在回调函数&lt;code&gt;ep_poll_callback&lt;/code&gt;中，根据&lt;code&gt;struct eppoll_entry&lt;/code&gt;中的&lt;code&gt;struct wait_queue_t wait&lt;/code&gt;通过&lt;code&gt;container_of宏&lt;/code&gt;找到&lt;code&gt;eppoll_entry&lt;/code&gt;对象并通过它的&lt;code&gt;base&lt;/code&gt;指针找到封装&lt;code&gt;socket&lt;/code&gt;的数据结构&lt;code&gt;struct epitem&lt;/code&gt;，并将它加入到&lt;code&gt;epoll&lt;/code&gt;中的就绪队列&lt;code&gt;rdllist&lt;/code&gt;中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;随后查看&lt;code&gt;epoll&lt;/code&gt;中的等待队列中是否有等待项，也就是说查看是否有进程阻塞在&lt;code&gt;epoll_wait&lt;/code&gt;上等待&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;socket&lt;/code&gt;。如果没有等待项，则软中断处理完成。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果有等待项，则回到注册在等待项中的回调函数&lt;code&gt;default_wake_function&lt;/code&gt;,在回调函数中唤醒&lt;code&gt;阻塞进程&lt;/code&gt;，并将就绪队列&lt;code&gt;rdllist&lt;/code&gt;中的&lt;code&gt;epitem&lt;/code&gt;的&lt;code&gt;IO就绪&lt;/code&gt;socket信息封装到&lt;code&gt;struct epoll_event&lt;/code&gt;中返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户进程拿到&lt;code&gt;epoll_event&lt;/code&gt;获取&lt;code&gt;IO就绪&lt;/code&gt;的socket，发起系统IO调用读取数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;再谈水平触发和边缘触发&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网上有大量的关于这两种模式的讲解，大部分讲的比较模糊，感觉只是强行从概念上进行描述，看完让人难以理解。所以在这里，笔者想结合上边&lt;code&gt;epoll&lt;/code&gt;的工作过程，再次对这两种模式做下自己的解读，力求清晰的解释出这两种工作模式的异同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上边对&lt;code&gt;epoll&lt;/code&gt;工作过程的详细解读，我们知道，当我们监听的&lt;code&gt;socket&lt;/code&gt;上有数据到来时，软中断会执行&lt;code&gt;epoll&lt;/code&gt;的回调函数&lt;code&gt;ep_poll_callback&lt;/code&gt;,在回调函数中会将&lt;code&gt;epoll&lt;/code&gt;中描述&lt;code&gt;socket信息&lt;/code&gt;的数据结构&lt;code&gt;epitem&lt;/code&gt;插入到&lt;code&gt;epoll&lt;/code&gt;中的就绪队列&lt;code&gt;rdllist&lt;/code&gt;中。随后用户进程从&lt;code&gt;epoll&lt;/code&gt;的等待队列中被唤醒，&lt;code&gt;epoll_wait&lt;/code&gt;将&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;socket&lt;/code&gt;返回给用户进程，随即&lt;code&gt;epoll_wait&lt;/code&gt;会清空&lt;code&gt;rdllist&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;水平触发&lt;/strong&gt;和&lt;strong&gt;边缘触发&lt;/strong&gt;最关键的&lt;strong&gt;区别&lt;/strong&gt;就在于当&lt;code&gt;socket&lt;/code&gt;中的接收缓冲区还有数据可读时。&lt;strong&gt;&lt;code&gt;epoll_wait&lt;/code&gt;是否会清空&lt;code&gt;rdllist&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;水平触发&lt;/strong&gt;：在这种模式下，用户线程调用&lt;code&gt;epoll_wait&lt;/code&gt;获取到&lt;code&gt;IO就绪&lt;/code&gt;的socket后，对&lt;code&gt;Socket&lt;/code&gt;进行系统IO调用读取数据，假设&lt;code&gt;socket&lt;/code&gt;中的数据只读了一部分没有全部读完，这时再次调用&lt;code&gt;epoll_wait&lt;/code&gt;，&lt;code&gt;epoll_wait&lt;/code&gt;会检查这些&lt;code&gt;Socket&lt;/code&gt;中的接收缓冲区是否还有数据可读，如果还有数据可读，就将&lt;code&gt;socket&lt;/code&gt;重新放回&lt;code&gt;rdllist&lt;/code&gt;。所以当&lt;code&gt;socket&lt;/code&gt;上的IO没有被处理完时，再次调用&lt;code&gt;epoll_wait&lt;/code&gt;依然可以获得这些&lt;code&gt;socket&lt;/code&gt;，用户进程可以接着处理&lt;code&gt;socket&lt;/code&gt;上的IO事件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;边缘触发：&lt;/strong&gt; 在这种模式下，&lt;code&gt;epoll_wait&lt;/code&gt;就会直接清空&lt;code&gt;rdllist&lt;/code&gt;，不管&lt;code&gt;socket&lt;/code&gt;上是否还有数据可读。所以在边缘触发模式下，当你没有来得及处理&lt;code&gt;socket&lt;/code&gt;接收缓冲区的剩下可读数据时，再次调用&lt;code&gt;epoll_wait&lt;/code&gt;，因为这时&lt;code&gt;rdlist&lt;/code&gt;已经被清空了，&lt;code&gt;socket&lt;/code&gt;不会再次从&lt;code&gt;epoll_wait&lt;/code&gt;中返回，所以用户进程就不会再次获得这个&lt;code&gt;socket&lt;/code&gt;了，也就无法在对它进行IO处理了。&lt;strong&gt;除非，这个&lt;code&gt;socket&lt;/code&gt;上有新的IO数据到达&lt;/strong&gt;，根据&lt;code&gt;epoll&lt;/code&gt;的工作过程，该&lt;code&gt;socket&lt;/code&gt;会被再次放入&lt;code&gt;rdllist&lt;/code&gt;中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果你在&lt;code&gt;边缘触发模式&lt;/code&gt;下，处理了部分&lt;code&gt;socket&lt;/code&gt;上的数据，那么想要处理剩下部分的数据，就只能等到这个&lt;code&gt;socket&lt;/code&gt;上再次有网络数据到达。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Netty&lt;/code&gt;中实现的&lt;code&gt;EpollSocketChannel&lt;/code&gt;默认的就是&lt;code&gt;边缘触发&lt;/code&gt;模式。&lt;code&gt;JDK&lt;/code&gt;的&lt;code&gt;NIO&lt;/code&gt;默认是&lt;code&gt;水平触发&lt;/code&gt;模式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;epoll对select，poll的优化总结&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;epoll&lt;/code&gt;在内核中通过&lt;code&gt;红黑树&lt;/code&gt;管理海量的连接，所以在调用&lt;code&gt;epoll_wait&lt;/code&gt;获取&lt;code&gt;IO就绪&lt;/code&gt;的socket时，不需要传入监听的socket文件描述符。从而避免了海量的文件描述符集合在&lt;code&gt;用户空间&lt;/code&gt;和&lt;code&gt;内核空间&lt;/code&gt;中来回复制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;select，poll&lt;/code&gt;每次调用时都需要传递全量的文件描述符集合，导致大量频繁的拷贝操作。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;epoll&lt;/code&gt;仅会通知&lt;code&gt;IO就绪&lt;/code&gt;的socket。避免了在用户空间遍历的开销。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;select，poll&lt;/code&gt;只会在&lt;code&gt;IO就绪&lt;/code&gt;的socket上打好标记，依然是全量返回，所以在用户空间还需要用户程序在一次遍历全量集合找出具体&lt;code&gt;IO就绪&lt;/code&gt;的socket。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;epoll&lt;/code&gt;通过在&lt;code&gt;socket&lt;/code&gt;的等待队列上注册回调函数&lt;code&gt;ep_poll_callback&lt;/code&gt;通知用户程序&lt;code&gt;IO就绪&lt;/code&gt;的socket。避免了在内核中轮询的开销。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大部分情况下&lt;code&gt;socket&lt;/code&gt;上并不总是&lt;code&gt;IO活跃&lt;/code&gt;的，在面对海量连接的情况下，&lt;code&gt;select，poll&lt;/code&gt;采用内核轮询的方式获取&lt;code&gt;IO活跃&lt;/code&gt;的socket，无疑是性能低下的核心原因。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据以上&lt;code&gt;epoll&lt;/code&gt;的性能优势，它是目前为止各大主流网络框架，以及反向代理中间件使用到的网络IO模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用&lt;code&gt;epoll&lt;/code&gt;多路复用IO模型可以轻松的解决&lt;code&gt;C10K&lt;/code&gt;问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;C100k&lt;/code&gt;的解决方案也还是基于&lt;code&gt;C10K&lt;/code&gt;的方案，通过&lt;code&gt;epoll&lt;/code&gt; 配合线程池，再加上 CPU、内存和网络接口的性能和容量提升。大部分情况下，&lt;code&gt;C100K&lt;/code&gt;很自然就可以达到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;甚至&lt;code&gt;C1000K&lt;/code&gt;的解决方法，本质上还是构建在 &lt;code&gt;epoll&lt;/code&gt; 的&lt;code&gt;多路复用 I/O 模型&lt;/code&gt;上。只不过，除了 I/O 模型之外，还需要从应用程序到 Linux 内核、再到 CPU、内存和网络等各个层次的深度优化，特别是需要借助硬件，来卸载那些原来通过软件处理的大量功能（&lt;code&gt;去掉大量的中断响应开销&lt;/code&gt;，&lt;code&gt;以及内核协议栈处理的开销&lt;/code&gt;）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;信号驱动IO&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.666&quot; data-type=&quot;png&quot; data-w=&quot;500&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEPmrUxCAPYRsmPqyGfq7icCaV1FP8bwKOTt0icvGO12ickvLv8Y80K7R5A/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;信号驱动IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家对这个装备肯定不会陌生，当我们去一些美食城吃饭的时候，点完餐付了钱，老板会给我们一个信号器。然后我们带着这个信号器可以去找餐桌，或者干些其他的事情。当信号器亮了的时候，这时代表饭餐已经做好，我们可以去窗口取餐了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个典型的生活场景和我们要介绍的&lt;code&gt;信号驱动IO模型&lt;/code&gt;就很像。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;信号驱动IO模型&lt;/code&gt;下，用户进程操作通过&lt;code&gt;系统调用 sigaction 函数&lt;/code&gt;发起一个 IO 请求，在对应的&lt;code&gt;socket&lt;/code&gt;注册一个&lt;code&gt;信号回调&lt;/code&gt;，此时&lt;code&gt;不阻塞&lt;/code&gt;用户进程，进程会继续工作。当内核数据就绪时，内核就为该进程生成一个 &lt;code&gt;SIGIO 信号&lt;/code&gt;，通过信号回调通知进程进行相关 IO 操作。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里需要注意的是：&lt;code&gt;信号驱动式 IO 模型&lt;/code&gt;依然是&lt;code&gt;同步IO&lt;/code&gt;，因为它虽然可以在等待数据的时候不被阻塞，也不会频繁的轮询，但是当数据就绪，内核信号通知后，用户进程依然要自己去读取数据，在&lt;code&gt;数据拷贝阶段&lt;/code&gt;发生阻塞。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;信号驱动 IO模型 相比于前三种 IO 模型，实现了在等待数据就绪时，进程不被阻塞，主循环可以继续工作，所以&lt;code&gt;理论上&lt;/code&gt;性能更佳。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是实际上，使用&lt;code&gt;TCP协议&lt;/code&gt;通信时，&lt;code&gt;信号驱动IO模型&lt;/code&gt;几乎&lt;code&gt;不会被采用&lt;/code&gt;。原因如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;信号IO 在大量 IO 操作时可能会因为信号队列溢出导致没法通知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SIGIO 信号&lt;/code&gt;是一种 Unix 信号，信号没有附加信息，如果一个信号源有多种产生信号的原因，信号接收者就无法确定究竟发生了什么。而 TCP socket 生产的信号事件有七种之多，这样应用程序收到 SIGIO，根本无从区分处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但&lt;code&gt;信号驱动IO模型&lt;/code&gt;可以用在 &lt;code&gt;UDP&lt;/code&gt;通信上，因为UDP 只有&lt;code&gt;一个数据请求事件&lt;/code&gt;，这也就意味着在正常情况下 UDP 进程只要捕获 SIGIO 信号，就调用 &lt;code&gt;read 系统调用&lt;/code&gt;读取到达的数据。如果出现异常，就返回一个异常错误。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里插句题外话，大家觉不觉得&lt;code&gt;阻塞IO模型&lt;/code&gt;在生活中的例子就像是我们在食堂排队打饭。你自己需要排队去打饭同时打饭师傅在配菜的过程中你需要等待。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.740909090909091&quot; data-type=&quot;png&quot; data-w=&quot;220&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEfnPgIKViaoGPghC3DGrmSn8YiaibhwQBrUiaFgticngwAwyqr6hh6exRocA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;阻塞IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;IO多路复用模型&lt;/code&gt;就像是我们在饭店门口排队等待叫号。叫号器就好比&lt;code&gt;select,poll,epoll&lt;/code&gt;可以统一管理全部顾客的&lt;code&gt;吃饭就绪&lt;/code&gt;事件，客户好比是&lt;code&gt;socket&lt;/code&gt;连接，谁可以去吃饭了，叫号器就通知谁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6232394366197183&quot; data-type=&quot;png&quot; data-w=&quot;284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEB28gaSs3gtCLlPLIlibib0kRf9XgKCEbuW8Tvx3dC20Bc8MylahYMbtg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;IO多路复用.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;##异步IO（AIO）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上介绍的四种&lt;code&gt;IO模型&lt;/code&gt;均为&lt;code&gt;同步IO&lt;/code&gt;，它们都会阻塞在第二阶段&lt;code&gt;数据拷贝阶段&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过在前边小节《同步与异步》中的介绍，相信大家很容易就会理解&lt;code&gt;异步IO模型&lt;/code&gt;，在&lt;code&gt;异步IO模型&lt;/code&gt;下，IO操作在&lt;code&gt;数据准备阶段&lt;/code&gt;和&lt;code&gt;数据拷贝阶段&lt;/code&gt;均是由内核来完成，不会对应用程序造成任何阻塞。应用进程只需要在&lt;code&gt;指定的数组&lt;/code&gt;中引用数据即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;异步 IO&lt;/code&gt; 与&lt;code&gt;信号驱动 IO&lt;/code&gt; 的主要区别在于：&lt;code&gt;信号驱动 IO&lt;/code&gt; 由内核通知何时可以&lt;code&gt;开始一个 IO 操作&lt;/code&gt;，而&lt;code&gt;异步 IO&lt;/code&gt;由内核通知 &lt;code&gt;IO 操作何时已经完成&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个生活中的例子：&lt;code&gt;异步IO模型&lt;/code&gt;就像我们去一个高档饭店里的包间吃饭，我们只需要坐在包间里面，点完餐（&lt;code&gt;类比异步IO调用&lt;/code&gt;）之后，我们就什么也不需要管，该喝酒喝酒，该聊天聊天，饭餐做好后服务员（&lt;code&gt;类比内核&lt;/code&gt;）会自己给我们送到包间（&lt;code&gt;类比用户空间&lt;/code&gt;）来。整个过程没有任何阻塞。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.358&quot; data-type=&quot;png&quot; data-w=&quot;500&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEfQXKapnOwAK72jTpaKrqfUicX38A8Z5TWopFUyZC0B04NMBRMdiapAFw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;异步IO.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;异步IO&lt;/code&gt;的系统调用需要操作系统内核来支持，目前只有&lt;code&gt;Window&lt;/code&gt;中的&lt;code&gt;IOCP&lt;/code&gt;实现了非常成熟的&lt;code&gt;异步IO机制&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;Linux&lt;/code&gt;系统对&lt;code&gt;异步IO机制&lt;/code&gt;实现的不够成熟，且与&lt;code&gt;NIO&lt;/code&gt;的性能相比提升也不明显。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;但Linux kernel 在5.1版本由Facebook的大神Jens Axboe引入了新的异步IO库&lt;code&gt;io_uring&lt;/code&gt; 改善了原来Linux native AIO的一些性能问题。性能相比&lt;code&gt;Epoll&lt;/code&gt;以及之前原生的&lt;code&gt;AIO&lt;/code&gt;提高了不少，值得关注。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再加上&lt;code&gt;信号驱动IO模型&lt;/code&gt;不适用&lt;code&gt;TCP协议&lt;/code&gt;，所以目前大部分采用的还是&lt;code&gt;IO多路复用模型&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;IO线程模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前边内容的介绍中，我们详述了网络数据包的接收和发送过程，并通过介绍5种&lt;code&gt;IO模型&lt;/code&gt;了解了内核是如何读取网络数据并通知给用户线程的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边的内容都是以&lt;code&gt;内核空间&lt;/code&gt;的视角来剖析网络数据的收发模型，本小节我们站在&lt;code&gt;用户空间&lt;/code&gt;的视角来看下如果对网络数据进行收发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对&lt;code&gt;内核&lt;/code&gt;来讲，&lt;code&gt;用户空间的IO线程模型&lt;/code&gt;相对就简单一些。这些&lt;code&gt;用户空间&lt;/code&gt;的&lt;code&gt;IO线程模型&lt;/code&gt;都是在讨论当多线程一起配合工作时谁负责接收连接，谁负责响应IO 读写、谁负责计算、谁负责发送和接收，仅仅是用户IO线程的不同分工模式罢了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Reactor&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Reactor&lt;/code&gt;是利用&lt;code&gt;NIO&lt;/code&gt;对&lt;code&gt;IO线程&lt;/code&gt;进行不同的分工：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用前边我们提到的&lt;code&gt;IO多路复用模型&lt;/code&gt;比如&lt;code&gt;select,poll,epoll,kqueue&lt;/code&gt;,进行IO事件的注册和监听。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将监听到&lt;code&gt;就绪的IO事件&lt;/code&gt;分发&lt;code&gt;dispatch&lt;/code&gt;到各个具体的处理&lt;code&gt;Handler&lt;/code&gt;中进行相应的&lt;code&gt;IO事件处理&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;IO多路复用技术&lt;/code&gt;就可以不断的监听&lt;code&gt;IO事件&lt;/code&gt;，不断的分发&lt;code&gt;dispatch&lt;/code&gt;，就像一个&lt;code&gt;反应堆&lt;/code&gt;一样，看起来像不断的产生&lt;code&gt;IO事件&lt;/code&gt;，因此我们称这种模式为&lt;code&gt;Reactor&lt;/code&gt;模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看下&lt;code&gt;Reactor模型&lt;/code&gt;的三种分类：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;单Reactor单线程&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39520333680917624&quot; data-type=&quot;png&quot; data-w=&quot;959&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEwlZPO0207A07smWv3l1Gq7rHOMAmRuqePPg2KdO7BPDbSQDrguxz6g/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;单Reactor单线程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Reactor模型&lt;/code&gt;是依赖&lt;code&gt;IO多路复用技术&lt;/code&gt;实现监听&lt;code&gt;IO事件&lt;/code&gt;，从而源源不断的产生&lt;code&gt;IO就绪事件&lt;/code&gt;，在Linux系统下我们使用&lt;code&gt;epoll&lt;/code&gt;来进行&lt;code&gt;IO多路复用&lt;/code&gt;，我们以Linux系统为例：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;单&lt;code&gt;Reactor&lt;/code&gt;意味着只有一个&lt;code&gt;epoll&lt;/code&gt;对象，用来监听所有的事件，比如&lt;code&gt;连接事件&lt;/code&gt;，&lt;code&gt;读写事件&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;单线程&lt;/code&gt;意味着只有一个线程来执行&lt;code&gt;epoll_wait&lt;/code&gt;获取&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;，然后对这些就绪的&lt;code&gt;Socket&lt;/code&gt;执行读写，以及后边的业务处理也依然是这个线程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;单Reactor单线程&lt;/code&gt;模型就好比我们开了一个很小很小的小饭馆，作为老板的我们需要一个人干所有的事情，包括：迎接顾客（&lt;code&gt;accept事件&lt;/code&gt;），为顾客介绍菜单等待顾客点菜(&lt;code&gt;IO请求&lt;/code&gt;)，做菜（&lt;code&gt;业务处理&lt;/code&gt;），上菜（&lt;code&gt;IO响应&lt;/code&gt;），送客（&lt;code&gt;断开连接&lt;/code&gt;）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;单Reactor多线程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着客人的增多（&lt;code&gt;并发请求&lt;/code&gt;），显然饭馆里的事情只有我们一个人干（&lt;code&gt;单线程&lt;/code&gt;）肯定是忙不过来的，这时候我们就需要多招聘一些员工（&lt;code&gt;多线程&lt;/code&gt;）来帮着一起干上述的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是就有了&lt;code&gt;单Reactor多线程&lt;/code&gt;模型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7006048387096774&quot; data-type=&quot;png&quot; data-w=&quot;992&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEo6zebSVIsdVBZIBDtOM5OEOwJxgZfMicrYkyfnz6hLIkiaK8MN4I5Kfw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;单Reactor多线程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这种模式下，也是只有一个&lt;code&gt;epoll&lt;/code&gt;对象来监听所有的&lt;code&gt;IO事件&lt;/code&gt;，一个线程来调用&lt;code&gt;epoll_wait&lt;/code&gt;获取&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Socket&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;但是当&lt;code&gt;IO就绪事件&lt;/code&gt;产生时，这些&lt;code&gt;IO事件&lt;/code&gt;对应处理的业务&lt;code&gt;Handler&lt;/code&gt;，我们是通过线程池来执行。这样相比&lt;code&gt;单Reactor单线程&lt;/code&gt;模型提高了执行效率，充分发挥了多核CPU的优势。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;主从Reactor多线程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做任何事情都要区分&lt;code&gt;事情的优先级&lt;/code&gt;，我们应该&lt;code&gt;优先高效&lt;/code&gt;的去做&lt;code&gt;优先级更高&lt;/code&gt;的事情，而不是一股脑不分优先级的全部去做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们的小饭馆客人越来越多（&lt;code&gt;并发量越来越大&lt;/code&gt;），我们就需要扩大饭店的规模，在这个过程中我们发现，&lt;code&gt;迎接客人&lt;/code&gt;是饭店最重要的工作，我们要先把客人迎接进来，不能让客人一看人多就走掉，只要客人进来了，哪怕菜做的慢一点也没关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，&lt;code&gt;主从Reactor多线程&lt;/code&gt;模型就产生了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6917670682730924&quot; data-type=&quot;png&quot; data-w=&quot;996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEubXjFtTT6Ac0xQxicxT4jwia2OOjiafa2FhzzYh1VGelwHmj8OBdKwukg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;主从Reactor多线程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我们由原来的&lt;code&gt;单Reactor&lt;/code&gt;变为了&lt;code&gt;多Reactor&lt;/code&gt;。&lt;code&gt;主Reactor&lt;/code&gt;用来优先&lt;code&gt;专门&lt;/code&gt;做优先级最高的事情，也就是迎接客人（&lt;code&gt;处理连接事件&lt;/code&gt;），对应的处理&lt;code&gt;Handler&lt;/code&gt;就是图中的&lt;code&gt;acceptor&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当创建好连接，建立好对应的&lt;code&gt;socket&lt;/code&gt;后，在&lt;code&gt;acceptor&lt;/code&gt;中将要监听的&lt;code&gt;read事件&lt;/code&gt;注册到&lt;code&gt;从Reactor&lt;/code&gt;中，由&lt;code&gt;从Reactor&lt;/code&gt;来监听&lt;code&gt;socket&lt;/code&gt;上的&lt;code&gt;读写&lt;/code&gt;事件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最终将读写的业务逻辑处理交给线程池处理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里向&lt;code&gt;从Reactor&lt;/code&gt;注册的只是&lt;code&gt;read事件&lt;/code&gt;，并没有注册&lt;code&gt;write事件&lt;/code&gt;，因为&lt;code&gt;read事件&lt;/code&gt;是由&lt;code&gt;epoll内核&lt;/code&gt;触发的，而&lt;code&gt;write事件&lt;/code&gt;则是由用户业务线程触发的（&lt;code&gt;什么时候发送数据是由具体业务线程决定的&lt;/code&gt;），所以&lt;code&gt;write事件&lt;/code&gt;理应是由&lt;code&gt;用户业务线程&lt;/code&gt;去注册。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;用户线程注册&lt;code&gt;write事件&lt;/code&gt;的时机是只有当用户发送的数据&lt;code&gt;无法一次性&lt;/code&gt;全部写入&lt;code&gt;buffer&lt;/code&gt;时，才会去注册&lt;code&gt;write事件&lt;/code&gt;，等待&lt;code&gt;buffer重新可写&lt;/code&gt;时，继续写入剩下的发送数据、如果用户线程可以一股脑的将发送数据全部写入&lt;code&gt;buffer&lt;/code&gt;，那么也就无需注册&lt;code&gt;write事件&lt;/code&gt;到&lt;code&gt;从Reactor&lt;/code&gt;中。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;主从Reactor多线程&lt;/code&gt;模型是现在大部分主流网络框架中采用的一种&lt;code&gt;IO线程模型&lt;/code&gt;。我们本系列的主题&lt;code&gt;Netty&lt;/code&gt;就是用的这种模型。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Proactor&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Proactor&lt;/code&gt;是基于&lt;code&gt;AIO&lt;/code&gt;对&lt;code&gt;IO线程&lt;/code&gt;进行分工的一种模型。前边我们介绍了&lt;code&gt;异步IO模型&lt;/code&gt;，它是操作系统内核支持的一种全异步编程模型，在&lt;code&gt;数据准备阶段&lt;/code&gt;和&lt;code&gt;数据拷贝阶段&lt;/code&gt;全程无阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ProactorIO线程模型&lt;/code&gt;将&lt;code&gt;IO事件的监听&lt;/code&gt;，&lt;code&gt;IO操作的执行&lt;/code&gt;，&lt;code&gt;IO结果的dispatch&lt;/code&gt;统统交给&lt;code&gt;内核&lt;/code&gt;来做。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4403225806451613&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEGKYKib71IWfbpGh4URSHfiaPhTiaWfQVZuJzfg4PwDXm7E6iacaMUrnsVg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;proactor.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;Proactor模型&lt;/code&gt;组件介绍：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;completion handler&lt;/code&gt; 为用户程序定义的异步IO操作回调函数，在异步IO操作完成时会被内核回调并通知IO结果。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Completion Event Queue&lt;/code&gt; 异步IO操作完成后，会产生对应的&lt;code&gt;IO完成事件&lt;/code&gt;，将&lt;code&gt;IO完成事件&lt;/code&gt;放入该队列中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Asynchronous Operation Processor&lt;/code&gt; 负责&lt;code&gt;异步IO&lt;/code&gt;的执行。执行完成后产生&lt;code&gt;IO完成事件&lt;/code&gt;放入&lt;code&gt;Completion Event Queue&lt;/code&gt; 队列中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Proactor&lt;/code&gt; 是一个事件循环派发器，负责从&lt;code&gt;Completion Event Queue&lt;/code&gt;中获取&lt;code&gt;IO完成事件&lt;/code&gt;，并回调与&lt;code&gt;IO完成事件&lt;/code&gt;关联的&lt;code&gt;completion handler&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Initiator&lt;/code&gt; 初始化异步操作（&lt;code&gt;asynchronous operation&lt;/code&gt;）并通过&lt;code&gt;Asynchronous Operation Processor&lt;/code&gt;将&lt;code&gt;completion handler&lt;/code&gt;和&lt;code&gt;proactor&lt;/code&gt;注册到内核。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;Proactor模型&lt;/code&gt;执行过程：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户线程发起&lt;code&gt;aio_read&lt;/code&gt;，并告诉&lt;code&gt;内核&lt;/code&gt;用户空间中的读缓冲区地址，以便&lt;code&gt;内核&lt;/code&gt;完成&lt;code&gt;IO操作&lt;/code&gt;将结果放入&lt;code&gt;用户空间&lt;/code&gt;的读缓冲区，用户线程直接可以读取结果（&lt;code&gt;无任何阻塞&lt;/code&gt;）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Initiator&lt;/code&gt; 初始化&lt;code&gt;aio_read&lt;/code&gt;异步读取操作（&lt;code&gt;asynchronous operation&lt;/code&gt;）,并将&lt;code&gt;completion handler&lt;/code&gt;注册到内核。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在&lt;code&gt;Proactor&lt;/code&gt;中我们关心的&lt;code&gt;IO完成事件&lt;/code&gt;：内核已经帮我们读好数据并放入我们指定的读缓冲区，用户线程可以直接读取。在&lt;code&gt;Reactor&lt;/code&gt;中我们关心的是&lt;code&gt;IO就绪事件&lt;/code&gt;：数据已经到来，但是需要用户线程自己去读取。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;此时用户线程就可以做其他事情了，无需等待IO结果。而内核与此同时开始异步执行IO操作。当&lt;code&gt;IO操作&lt;/code&gt;完成时会产生一个&lt;code&gt;completion event&lt;/code&gt;事件，将这个&lt;code&gt;IO完成事件&lt;/code&gt;放入&lt;code&gt;completion event queue&lt;/code&gt;中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Proactor&lt;/code&gt;从&lt;code&gt;completion event queue&lt;/code&gt;中取出&lt;code&gt;completion event&lt;/code&gt;，并回调与&lt;code&gt;IO完成事件&lt;/code&gt;关联的&lt;code&gt;completion handler&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在&lt;code&gt;completion handler&lt;/code&gt;中完成业务逻辑处理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Reactor与Proactor对比&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Reactor&lt;/code&gt;是基于&lt;code&gt;NIO&lt;/code&gt;实现的一种&lt;code&gt;IO线程模型&lt;/code&gt;，&lt;code&gt;Proactor&lt;/code&gt;是基于&lt;code&gt;AIO&lt;/code&gt;实现的&lt;code&gt;IO线程模型&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Reactor&lt;/code&gt;关心的是&lt;code&gt;IO就绪事件&lt;/code&gt;，&lt;code&gt;Proactor&lt;/code&gt;关心的是&lt;code&gt;IO完成事件&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在&lt;code&gt;Proactor&lt;/code&gt;中，用户程序需要向内核传递&lt;code&gt;用户空间的读缓冲区地址&lt;/code&gt;。&lt;code&gt;Reactor&lt;/code&gt;则不需要。这也就导致了在&lt;code&gt;Proactor&lt;/code&gt;中每个并发操作都要求有独立的缓存区，在内存上有一定的开销。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Proactor&lt;/code&gt; 的实现逻辑复杂，编码成本较 &lt;code&gt;Reactor&lt;/code&gt;要高很多。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Proactor&lt;/code&gt; 在处理&lt;code&gt;高耗时 IO&lt;/code&gt;时的性能要高于 &lt;code&gt;Reactor&lt;/code&gt;，但对于&lt;code&gt;低耗时 IO&lt;/code&gt;的执行效率提升&lt;code&gt;并不明显&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Netty的IO模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们介绍完&lt;code&gt;网络数据包在内核中的收发过程&lt;/code&gt;以及五种&lt;code&gt;IO模型&lt;/code&gt;和两种&lt;code&gt;IO线程模型&lt;/code&gt;后，现在我们来看下&lt;code&gt;netty&lt;/code&gt;中的IO模型是什么样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们介绍&lt;code&gt;Reactor IO线程模型&lt;/code&gt;的时候提到有三种&lt;code&gt;Reactor模型&lt;/code&gt;：&lt;code&gt;单Reactor单线程&lt;/code&gt;，&lt;code&gt;单Reactor多线程&lt;/code&gt;，&lt;code&gt;主从Reactor多线程&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三种&lt;code&gt;Reactor模型&lt;/code&gt;在&lt;code&gt;netty&lt;/code&gt;中都是支持的，但是我们常用的是&lt;code&gt;主从Reactor多线程模型&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们之前介绍的三种&lt;code&gt;Reactor&lt;/code&gt;只是一种模型，是一种设计思想。实际上各种网络框架在实现中并不是严格按照模型来实现的，会有一些小的不同，但大体设计思想上是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看下&lt;code&gt;netty&lt;/code&gt;中的&lt;code&gt;主从Reactor多线程模型&lt;/code&gt;是什么样子的？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.567741935483871&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUY4ypDTgZibnVV3K2XJZVLcEqBHAhkKJCkVgiaazsXibAeyzHXtCy8fB3JPwWlq0LL8kWQG6OVwFYDgA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;netty中的reactor.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Reactor&lt;/code&gt;在&lt;code&gt;netty&lt;/code&gt;中是以&lt;code&gt;group&lt;/code&gt;的形式出现的，&lt;code&gt;netty&lt;/code&gt;中将&lt;code&gt;Reactor&lt;/code&gt;分为两组，一组是&lt;code&gt;MainReactorGroup&lt;/code&gt;也就是我们在编码中常常看到的&lt;code&gt;EventLoopGroup bossGroup&lt;/code&gt;,另一组是&lt;code&gt;SubReactorGroup&lt;/code&gt;也就是我们在编码中常常看到的&lt;code&gt;EventLoopGroup workerGroup&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;MainReactorGroup&lt;/code&gt;中通常只有一个&lt;code&gt;Reactor&lt;/code&gt;，专门负责做最重要的事情，也就是监听连接&lt;code&gt;accept&lt;/code&gt;事件。当有连接事件产生时，在对应的处理&lt;code&gt;handler acceptor&lt;/code&gt;中创建初始化相应的&lt;code&gt;NioSocketChannel&lt;/code&gt;（代表一个&lt;code&gt;Socket连接&lt;/code&gt;）。然后以&lt;code&gt;负载均衡&lt;/code&gt;的方式在&lt;code&gt;SubReactorGroup&lt;/code&gt;中选取一个&lt;code&gt;Reactor&lt;/code&gt;，注册上去，监听&lt;code&gt;Read事件&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;MainReactorGroup&lt;/code&gt;中只有一个&lt;code&gt;Reactor&lt;/code&gt;的原因是，通常我们服务端程序只会&lt;code&gt;绑定监听&lt;/code&gt;一个端口，如果要&lt;code&gt;绑定监听&lt;/code&gt;多个端口，就会配置多个&lt;code&gt;Reactor&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;SubReactorGroup&lt;/code&gt;中有多个&lt;code&gt;Reactor&lt;/code&gt;，具体&lt;code&gt;Reactor&lt;/code&gt;的个数可以由系统参数 &lt;code&gt;-D io.netty.eventLoopThreads&lt;/code&gt;指定。默认的&lt;code&gt;Reactor&lt;/code&gt;的个数为&lt;code&gt;CPU核数 * 2&lt;/code&gt;。&lt;code&gt;SubReactorGroup&lt;/code&gt;中的&lt;code&gt;Reactor&lt;/code&gt;主要负责监听&lt;code&gt;读写事件&lt;/code&gt;，每一个&lt;code&gt;Reactor&lt;/code&gt;负责监听一组&lt;code&gt;socket连接&lt;/code&gt;。将全量的连接&lt;code&gt;分摊&lt;/code&gt;在多个&lt;code&gt;Reactor&lt;/code&gt;中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一个&lt;code&gt;Reactor&lt;/code&gt;分配一个&lt;code&gt;IO线程&lt;/code&gt;，这个&lt;code&gt;IO线程&lt;/code&gt;负责从&lt;code&gt;Reactor&lt;/code&gt;中获取&lt;code&gt;IO就绪事件&lt;/code&gt;，执行&lt;code&gt;IO调用获取IO数据&lt;/code&gt;，执行&lt;code&gt;PipeLine&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;Socket连接&lt;/code&gt;在创建后就被&lt;code&gt;固定的分配&lt;/code&gt;给一个&lt;code&gt;Reactor&lt;/code&gt;，所以一个&lt;code&gt;Socket连接&lt;/code&gt;也只会被一个固定的&lt;code&gt;IO线程&lt;/code&gt;执行，每个&lt;code&gt;Socket连接&lt;/code&gt;分配一个独立的&lt;code&gt;PipeLine&lt;/code&gt;实例，用来编排这个&lt;code&gt;Socket连接&lt;/code&gt;上的&lt;code&gt;IO处理逻辑&lt;/code&gt;。这种&lt;code&gt;无锁串行化&lt;/code&gt;的设计的目的是为了防止多线程并发执行同一个socket连接上的&lt;code&gt;IO逻辑处理&lt;/code&gt;，防止出现&lt;code&gt;线程安全问题&lt;/code&gt;。同时使系统吞吐量达到最大化&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;由于每个&lt;code&gt;Reactor&lt;/code&gt;中只有一个&lt;code&gt;IO线程&lt;/code&gt;，这个&lt;code&gt;IO线程&lt;/code&gt;既要执行&lt;code&gt;IO活跃Socket连接&lt;/code&gt;对应的&lt;code&gt;PipeLine&lt;/code&gt;中的&lt;code&gt;ChannelHandler&lt;/code&gt;，又要从&lt;code&gt;Reactor&lt;/code&gt;中获取&lt;code&gt;IO就绪事件&lt;/code&gt;，执行&lt;code&gt;IO调用&lt;/code&gt;。所以&lt;code&gt;PipeLine&lt;/code&gt;中&lt;code&gt;ChannelHandler&lt;/code&gt;中执行的逻辑不能耗时太长，尽量将耗时的业务逻辑处理放入单独的业务线程池中处理，否则会影响其他连接的&lt;code&gt;IO读写&lt;/code&gt;，从而近一步影响整个服务程序的&lt;code&gt;IO吞吐&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当&lt;code&gt;IO请求&lt;/code&gt;在业务线程中完成相应的业务逻辑处理后，在业务线程中利用持有的&lt;code&gt;ChannelHandlerContext&lt;/code&gt;引用将响应数据在&lt;code&gt;PipeLine&lt;/code&gt;中反向传播，最终写回给客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;netty&lt;/code&gt;中的&lt;code&gt;IO模型&lt;/code&gt;我们介绍完了，下面我们来简单介绍下在&lt;code&gt;netty&lt;/code&gt;中是如何支持前边提到的三种&lt;code&gt;Reactor模型&lt;/code&gt;的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;配置单Reactor单线程&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;EventLoopGroup eventGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;ServerBootstrap serverBootstrap = &lt;span&gt;new&lt;/span&gt; ServerBootstrap(); &lt;br/&gt;serverBootstrap.group(eventGroup);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;配置单Reactor多线程&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;EventLoopGroup eventGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup();&lt;br/&gt;ServerBootstrap serverBootstrap = &lt;span&gt;new&lt;/span&gt; ServerBootstrap(); &lt;br/&gt;serverBootstrap.group(eventGroup);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;配置主从Reactor多线程&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;EventLoopGroup bossGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup(&lt;span&gt;1&lt;/span&gt;); &lt;br/&gt;EventLoopGroup workerGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup();&lt;br/&gt;ServerBootstrap serverBootstrap = &lt;span&gt;new&lt;/span&gt; ServerBootstrap(); &lt;br/&gt;serverBootstrap.group(bossGroup, workerGroup);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文是一篇信息量比较大的文章，用了&lt;code&gt;25&lt;/code&gt;张图，&lt;code&gt;22336&lt;/code&gt;个字从内核如何处理网络数据包的收发过程开始展开，随后又在&lt;code&gt;内核角度&lt;/code&gt;介绍了经常容易混淆的&lt;code&gt;阻塞与非阻塞&lt;/code&gt;，&lt;code&gt;同步与异步&lt;/code&gt;的概念。以这个作为铺垫，我们通过一个&lt;code&gt;C10K&lt;/code&gt;的问题，引出了五种&lt;code&gt;IO模型&lt;/code&gt;，随后在&lt;code&gt;IO多路复用&lt;/code&gt;中以技术演进的形式介绍了&lt;code&gt;select,poll,epoll&lt;/code&gt;的原理和它们综合的对比。最后我们介绍了两种&lt;code&gt;IO线程模型&lt;/code&gt;以及&lt;code&gt;netty&lt;/code&gt;中的&lt;code&gt;Reactor模型&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508612&amp;amp;idx=1&amp;amp;sn=e12e0093ed5e06ca6eea1f63c6acc757&amp;amp;chksm=bd25a3fb8a522aed945e915b9277ab2a15797bb9a35782a0969f5281d4ede6c0e087a335c6e6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;18张图，图解SpringBoot解析yml全流程&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;18张图，图解SpringBoot解析yml全流程&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508544&amp;amp;idx=1&amp;amp;sn=ae0b6256fa3a1b579f646c1b2352d397&amp;amp;chksm=bd25a33f8a522a2914ec2d5b560a0e84aae571db8664edb9c09f8a3d824306055b203074c673&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;起飞，会了这4个 Intellij IDEA 调试魔法，阅读源码都简单了！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;起飞，会了这4个 Intellij IDEA 调试魔法，阅读源码都简单了！&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508541&amp;amp;idx=1&amp;amp;sn=551a5034a7f374d8ed3da25327bccca4&amp;amp;chksm=bd25a3428a522a5458b3148a80ec26ac3b454a563034bb88694839bed796d2d3212f105b82d1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;还在用策略模式解决 if-else？Map+函数式接口方法才是YYDS！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;还在用策略模式解决 if-else？Map+函数式接口方法才是YYDS！&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>