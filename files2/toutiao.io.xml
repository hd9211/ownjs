<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>703dc58c8cccdb8058412a512ed6e6c7</guid>
<title>[推荐] 10 分钟带你搞懂代理模式、静态代理、JDK + CGLIB 动态代理</title>
<link>https://toutiao.io/k/23m4ly1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;1. 代理模式&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2. 静态代理&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3. 动态代理&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4. 静态代理和动态代理的对比&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;5. 总结&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 代理模式&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代理模式是一种比较好的理解的设计模式。简单来说就是 &lt;strong&gt;我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子：你的找了一小红来帮你问话，小红就看作是代理我的代理对象，代理的行为（方法）是问话。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4869109947643979&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2Rp8GAOdFfChrA9r6P41kq1zB620oXMaJxAxl58RS5nBPMTcSzC4oiaicGv6TNyMKTwj2jnA26aDR8xuCoLsbgJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;764&quot;/&gt;&lt;figcaption&gt;Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://medium.com/@mithunsasidharan/understanding-the-proxy-design-pattern-5e63fe38052a&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 静态代理&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;静态代理中，我们对目标对象的每个方法的增强都是手动完成的（&lt;em&gt;后面会具体演示代码&lt;/em&gt;），非常不灵活（&lt;em&gt;比如接口一旦新增加方法，目标对象和代理对象都要进行修改&lt;/em&gt;）且麻烦(&lt;em&gt;需要对每个目标类都单独写一个代理类&lt;/em&gt;)。&lt;/strong&gt; 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， &lt;strong&gt;静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态代理实现步骤:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;定义一个接口及其实现类；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建一个代理类同样实现这个接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将目标对象注注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面通过代码展示！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.定义发送短信的接口&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;SmsService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;send&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.实现发送短信的接口&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SmsServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;SmsService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;send&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;send message:&quot;&lt;/span&gt; + message);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; message;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.创建代理类并同样实现发送短信的接口&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SmsProxy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;SmsService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SmsService smsService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;SmsProxy&lt;/span&gt;&lt;span&gt;(SmsService smsService)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.smsService = smsService;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;send&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//调用方法之前，我们可以添加自己的操作&lt;/span&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;before method send()&quot;&lt;/span&gt;);&lt;br/&gt;        smsService.send(message);&lt;br/&gt;        &lt;span&gt;//调用方法之后，我们同样可以添加自己的操作&lt;/span&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;after method send()&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4.实际使用&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SmsService smsService = &lt;span&gt;new&lt;/span&gt; SmsServiceImpl();&lt;br/&gt;        SmsProxy smsProxy = &lt;span&gt;new&lt;/span&gt; SmsProxy(smsService);&lt;br/&gt;        smsProxy.send(&lt;span&gt;&quot;java&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上述代码之后，控制台打印出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;before method send()&lt;br/&gt;send message:java&lt;br/&gt;after method send()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以输出结果看出，我们已经增加了 &lt;code&gt;SmsServiceImpl&lt;/code&gt; 的&lt;code&gt;send()&lt;/code&gt;方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 动态代理&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( &lt;em&gt;CGLIB 动态代理机制&lt;/em&gt;)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就 Java 来说，动态代理的实现方式有很多种，比如 &lt;strong&gt;JDK 动态代理&lt;/strong&gt;、&lt;strong&gt;CGLIB 动态代理&lt;/strong&gt;等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;guide-rpc-framework&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，虽然 &lt;span&gt;guide-rpc-framework&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 没有用到 &lt;strong&gt;CGLIB 动态代理 ，我们这里还是简单介绍一下其使用以及和&lt;/strong&gt;JDK 动态代理的对比。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1. JDK 动态代理机制&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.1. 介绍&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在 Java 动态代理机制中 &lt;code&gt;InvocationHandler&lt;/code&gt; 接口和 &lt;code&gt;Proxy&lt;/code&gt; 类是核心。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Proxy&lt;/code&gt; 类中使用频率最高的方法是：&lt;code&gt;newProxyInstance()&lt;/code&gt; ，这个方法主要用来生成一个代理对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object &lt;span&gt;newProxyInstance&lt;/span&gt;&lt;span&gt;(ClassLoader loader,&lt;br/&gt;                                          Class&amp;lt;?&amp;gt;[] interfaces,&lt;br/&gt;                                          InvocationHandler h)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; IllegalArgumentException&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        ......&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法一共有 3 个参数：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;loader&lt;/strong&gt; :类加载器，用于加载代理对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;interfaces&lt;/strong&gt; : 被代理类实现的一些接口；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;h&lt;/strong&gt; : 实现了 &lt;code&gt;InvocationHandler&lt;/code&gt; 接口的对象；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要实现动态代理的话，还必须需要实现&lt;code&gt;InvocationHandler&lt;/code&gt; 来自定义处理逻辑。当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现&lt;code&gt;InvocationHandler&lt;/code&gt; 接口类的 &lt;code&gt;invoke&lt;/code&gt; 方法来调用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;InvocationHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 当你使用代理对象调用方法的时候实际会调用到这个方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;invoke&lt;/span&gt;&lt;span&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; Throwable&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;invoke()&lt;/code&gt; 方法有下面三个参数：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;proxy&lt;/strong&gt; :动态生成的代理类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;method&lt;/strong&gt; : 与代理类对象调用的方法相对应&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;args&lt;/strong&gt; : 当前 method 方法的参数&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说：&lt;strong&gt;你通过&lt;code&gt;Proxy&lt;/code&gt; 类的 &lt;code&gt;newProxyInstance()&lt;/code&gt; 创建的代理对象在调用方法的时候，实际会调用到实现&lt;code&gt;InvocationHandler&lt;/code&gt; 接口的类的 &lt;code&gt;invoke()&lt;/code&gt;方法。&lt;/strong&gt; 你可以在 &lt;code&gt;invoke()&lt;/code&gt; 方法中自定义处理逻辑，比如在方法执行前后做什么事情。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.2. JDK 动态代理类使用步骤&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;定义一个接口及其实现类；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自定义 &lt;code&gt;InvocationHandler&lt;/code&gt; 并重写&lt;code&gt;invoke&lt;/code&gt;方法，在 &lt;code&gt;invoke&lt;/code&gt; 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;Proxy.newProxyInstance(ClassLoader loader,Class&amp;lt;?&amp;gt;[] interfaces,InvocationHandler h)&lt;/code&gt; 方法创建代理对象；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.3. 代码示例&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.定义发送短信的接口&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;SmsService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;send&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.实现发送短信的接口&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SmsServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;SmsService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;send&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;send message:&quot;&lt;/span&gt; + message);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; message;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.定义一个 JDK 动态代理类&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.lang.reflect.InvocationHandler;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.reflect.InvocationTargetException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.reflect.Method;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; shuang.kou&lt;br/&gt; * &lt;span&gt;@createTime&lt;/span&gt; 2020年05月11日 11:23:00&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DebugInvocationHandler&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InvocationHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 代理类中的真实对象&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object target;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;DebugInvocationHandler&lt;/span&gt;&lt;span&gt;(Object target)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.target = target;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;invoke&lt;/span&gt;&lt;span&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InvocationTargetException, IllegalAccessException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//调用方法之前，我们可以添加自己的操作&lt;/span&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;before method &quot;&lt;/span&gt; + method.getName());&lt;br/&gt;        Object result = method.invoke(target, args);&lt;br/&gt;        &lt;span&gt;//调用方法之后，我们同样可以添加自己的操作&lt;/span&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;after method &quot;&lt;/span&gt; + method.getName());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;invoke()&lt;/code&gt; 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 &lt;code&gt;invoke()&lt;/code&gt; 方法，然后 &lt;code&gt;invoke()&lt;/code&gt; 方法代替我们去调用了被代理对象的原生方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4.获取代理对象的工厂类&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JdkProxyFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object &lt;span&gt;getProxy&lt;/span&gt;&lt;span&gt;(Object target)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(&lt;br/&gt;                target.getClass().getClassLoader(), &lt;span&gt;// 目标类的类加载&lt;/span&gt;&lt;br/&gt;                target.getClass().getInterfaces(),  &lt;span&gt;// 代理需要实现的接口，可指定多个&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; DebugInvocationHandler(target)   &lt;span&gt;// 代理对象对应的自定义 InvocationHandler&lt;/span&gt;&lt;br/&gt;        );&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;getProxy()&lt;/code&gt; ：主要通过&lt;code&gt;Proxy.newProxyInstance（）&lt;/code&gt;方法获取某个类的代理对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5.实际使用&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SmsService smsService = (SmsService) JdkProxyFactory.getProxy(&lt;span&gt;new&lt;/span&gt; SmsServiceImpl());&lt;br/&gt;smsService.send(&lt;span&gt;&quot;java&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上述代码之后，控制台打印出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;before method send&lt;br/&gt;send message:java&lt;br/&gt;after method send&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2. CGLIB 动态代理机制&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.1. 介绍&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CGLIB&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;(&lt;em&gt;Code Generation Library&lt;/em&gt;)是一个基于&lt;span&gt;ASM&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了&lt;span&gt;CGLIB&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在 CGLIB 动态代理机制中 &lt;code&gt;MethodInterceptor&lt;/code&gt; 接口和 &lt;code&gt;Enhancer&lt;/code&gt; 类是核心。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你需要自定义 &lt;code&gt;MethodInterceptor&lt;/code&gt; 并重写 &lt;code&gt;intercept&lt;/code&gt; 方法，&lt;code&gt;intercept&lt;/code&gt; 用于拦截增强被代理类的方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;MethodInterceptor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Callback&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 拦截被代理类中的方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;intercept&lt;/span&gt;&lt;span&gt;(Object obj, java.lang.reflect.Method method, Object[] args,&lt;br/&gt;                               MethodProxy proxy)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;obj&lt;/strong&gt; :被代理的对象（需要增强的对象）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;method&lt;/strong&gt; :被拦截的方法（需要增强的方法）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;args&lt;/strong&gt; :方法入参&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;methodProxy&lt;/strong&gt; :用于调用原始方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以通过 &lt;code&gt;Enhancer&lt;/code&gt;类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 &lt;code&gt;MethodInterceptor&lt;/code&gt; 中的 &lt;code&gt;intercept&lt;/code&gt; 方法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.2. CGLIB 动态代理类使用步骤&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;定义一个类；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自定义 &lt;code&gt;MethodInterceptor&lt;/code&gt; 并重写 &lt;code&gt;intercept&lt;/code&gt; 方法，&lt;code&gt;intercept&lt;/code&gt; 用于拦截增强被代理类的方法，和 JDK 动态代理中的 &lt;code&gt;invoke&lt;/code&gt; 方法类似；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;Enhancer&lt;/code&gt; 类的 &lt;code&gt;create()&lt;/code&gt;创建代理类；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.3. 代码示例&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同于 JDK 动态代理不需要额外的依赖。&lt;span&gt;CGLIB&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;(&lt;em&gt;Code Generation Library&lt;/em&gt;) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;cglib&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;cglib&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.3.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.实现一个使用阿里云发送短信的类&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; github.javaguide.dynamicProxy.cglibDynamicProxy;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AliSmsService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;send&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;send message:&quot;&lt;/span&gt; + message);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; message;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.自定义 &lt;code&gt;MethodInterceptor&lt;/code&gt;（方法拦截器）&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; net.sf.cglib.proxy.MethodInterceptor;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; net.sf.cglib.proxy.MethodProxy;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.reflect.Method;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 自定义MethodInterceptor&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DebugMethodInterceptor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;MethodInterceptor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; o           被代理的对象（需要增强的对象）&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; method      被拦截的方法（需要增强的方法）&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; args        方法入参&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; methodProxy 用于调用原始方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;intercept&lt;/span&gt;&lt;span&gt;(Object o, Method method, Object[] args, MethodProxy methodProxy)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//调用方法之前，我们可以添加自己的操作&lt;/span&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;before method &quot;&lt;/span&gt; + method.getName());&lt;br/&gt;        Object object = methodProxy.invokeSuper(o, args);&lt;br/&gt;        &lt;span&gt;//调用方法之后，我们同样可以添加自己的操作&lt;/span&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;after method &quot;&lt;/span&gt; + method.getName());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; object;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.获取代理类&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; net.sf.cglib.proxy.Enhancer;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CglibProxyFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object &lt;span&gt;getProxy&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt; clazz)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 创建动态代理增强类&lt;/span&gt;&lt;br/&gt;        Enhancer enhancer = &lt;span&gt;new&lt;/span&gt; Enhancer();&lt;br/&gt;        &lt;span&gt;// 设置类加载器&lt;/span&gt;&lt;br/&gt;        enhancer.setClassLoader(clazz.getClassLoader());&lt;br/&gt;        &lt;span&gt;// 设置被代理类&lt;/span&gt;&lt;br/&gt;        enhancer.setSuperclass(clazz);&lt;br/&gt;        &lt;span&gt;// 设置方法拦截器&lt;/span&gt;&lt;br/&gt;        enhancer.setCallback(&lt;span&gt;new&lt;/span&gt; DebugMethodInterceptor());&lt;br/&gt;        &lt;span&gt;// 创建代理类&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; enhancer.create();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4.实际使用&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);&lt;br/&gt;aliSmsService.send(&lt;span&gt;&quot;java&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上述代码之后，控制台打印出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;before method send&lt;br/&gt;send message:java&lt;br/&gt;after method send&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3. JDK 动态代理和 CGLIB 动态代理对比&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;JDK 动态代理只能只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类。&lt;/strong&gt; 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 静态代理和动态代理的对比&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;灵活性&lt;/strong&gt; ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;JVM 层面&lt;/strong&gt; ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章中主要介绍了代理模式的两种实现：静态代理以及动态代理。涵盖了静态代理和动态代理实战、静态代理和动态代理的区别、JDK 动态代理和 Cglib 动态代理区别等内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中涉及到的所有源码，你可以在这里找到：&lt;span&gt;https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt; 。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;guide-rpc-framework: &lt;em&gt;https://github.com/Snailclimb/guide-rpc-framework&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;guide-rpc-framework: &lt;em&gt;https://github.com/Snailclimb/guide-rpc-framework&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;CGLIB: &lt;em&gt;https://github.com/cglib/cglib&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;ASM: &lt;em&gt;http://www.baeldung.com/java-asm&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;CGLIB: &lt;em&gt;https://github.com/cglib/cglib&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;CGLIB: &lt;em&gt;https://github.com/cglib/cglib&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy: &lt;em&gt;https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>94a9112ab8d66d1f262da1a2bea7c20d</guid>
<title>[推荐] 一个每秒超过 3 万请求的微服务开发经历</title>
<link>https://toutiao.io/k/s2yudly</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;导读：本文介绍的是一个国外的外卖平台 ifood 的微服务案例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ifood 是一家巴西外卖平台公司，平均每天送出 100 多万份订单，每年增长 110% 左右。作为一家外卖平台，访问峰值大多出现在午餐和晚餐前后，周末的时候会更高一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在一些特殊的日子里（比如由于营销活动），访问量曾打破记录，平台获得了历史最高峰值，去年 6 月 12 日。我们一个微服务达到了每分钟 20 0万请求的峰值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;故事背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我在公司平台部门的账号与身份团队工作了大约一年半的时间，这是一个相当长的旅程，由于公司的快速发展，我们时常会面临很多挑战。&lt;strong&gt;在设计新的解决方案时，我们总是要牢记这样一个想法：在几个月后，系统的使用量会增长 2 - 3 倍。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;今天要讲的故事就是上面案例的一种情况，这个系统是在 2018 年左右开发的，当时公司每个月的订单量是 1300 万。如今已经超过 3000 万了。在这个案例中，系统的使用量是随着公司用户的增长比例而增长的，当然后来增长速度更加迅猛。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在内部，我们把这个微服务称为账号元数据。尽管这是一个通用的名字，但它也解释了这个服务的目的：它处理账号的元数据。什么是账号元数据？主要是指那些非关键的用户信息。举个例子：如果用户喜欢通过短信或邮件收到通知，喜欢的食物类型（比如汉堡、意大利面、日本料理等），一些功能标志，为该用户做的订单数量等等。它就像一个通用的存储，把不同地方的数据汇总起来，方便地服务于客户端调用，同时也服务于其他微服务，这样他们只需要调用一个微服务，而不是 10 个微服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最早在 2018 年时，账号元数据的建立主要是为了放一些杂乱的（并不怎么用的）信息，说实话，没有其他地方可以放。我们需要一点结构和查询能力，而且很容易扩展，所以我们选择了 AWS 提供的 DynamoDB。在这里要说明一下，我们明白系统可能会增长，当时公司也已经相当大了，平均负载是有挑战的。但是，我们还是没有预估到，我们会从每分钟 1 万个请求增长到 20 万，然后最终达到了 200万。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个微服务刚发布后，并没有多少人使用（与账号团队的其他微服务相比）。然而，几周后做出的一些新的架构调整，让这个系统变得非常重要，它将成为客户端获取用户所有信息的首批调用目标之一。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在此之后的几个月，其他团队开始把账号元数据看作是一个很好的功能，可以把分散存储在多个地方的信息都搬来这里，依赖多个服务毕竟很麻烦。另外，我们开始创建更多的聚合，让其他微服务的调用变得非常简单，也让其他团队更多的了解了它的知名度和重要性。现在，账号元数据除了用户每次打开应用的时候都会被调用，而且被很多团队在很多其他不同的场景下访问。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面就是一个非常简单的总结，介绍了从 2018 年到现在发生的事情，系统为何变得如此重要。在这期间，团队（我加上八个非常优秀的同事，非常幸运地与他们一起工作）积极地进行了工作，但工作并未停止，我们仍然在为我们负责的其他十个微服务进行优化、开发以及维护。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们做了一大堆的改动，如果要展开我们经历的所有场景，会花费太多时间，所以我只把当前要说的这个架构描述清楚，我们需要能够稳定地每分钟处理 200万个请求。是时候深入到技术部分了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;深入技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;正如前面所说，这个微服务存储了账号的元数据。在数据库中，我们将这些元数据分割成不同的上下文（在代码中称之为 namespace 命名空间）。一个客户（customer_id 作为分区键）可以有 1 到 N 个 namespace（作为排序键），而且每个 namespace 都有一个固定的、强制性的 schema，插入前通过  jsonschema 来定义和检查。有了它，我们就可以确保无论如何将数据插入到哪个 namespace 中（后面会有更多的细节），都会遵从它的模式和正确的用法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们使用这种方法，是因为这个系统中，读和写是由不同的团队来完成的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;插入工作是由数据科学团队完成的，他们每天都会从内部工具中导出数百万条记录到这个微服务中，并通过 API 将这数百万条记录分割成每次 500 条进行批量调用。所以，一天中的某个特定时间，这个微服务会收到数百万次的调用（间隔 10 到 20 分钟），将数据插入到 DynamoDB 中。如果接收 API 直接将数据写入数据库，就会碰到 Dynamo 扩展的一些问题，而且响应时间过慢也是个问题。解决这个瓶颈的方法是数据团队直接将数据写入数据库，但是，我们必须检查这些记录是否符合命名对应空间的 jsonschema，这是此微服务的责任。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以解决方案是，API 接收这批记录，并将它们发布在 SNS/SQS 消息队列上，而 SNS/SQS 将被另外一个模块来消费，然后验证这些记录，如果没问题，就保存在 Dynamo 上。通过这种方式，接收到这批记录的接口可以非常快速地响应，我们不依赖 HTTP 连接进行写入（这一点相当重要，因为与 Dynamo 的通信可能会失败，再次尝试可能会使 HTTP 响应时间变得非常慢）。另一个好处是，我们可以通过调整队列消费程序，来控制从 SQS 读取数据以及在 Dynamo 上写入数据的快慢。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这个流程之外，账号元数据也会被另一个服务调用，每当平台收到一个新订单就会调用它，并更新这个订单的一些信息。鉴于 ifood 每天订单量超过 100 多万，微服务也会接受到这个数量的调用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;虽然上面提到有一个非常繁重的写的过程，但是这个服务 95% 的负载来自于 API 调用读取的请求。前面也提到，读写数据是由公司不同的团队完成的，读的调用牵涉到非常多的团队，包括客户端的调用。比较幸运的是，这个微服务读请求要比写请求多得多，因此它的扩展就更容易一些。因为任何一个大量读取数据的系统都需要一个缓存，这个也是如此，AWS 没有使用 Redis 之类的东西，而是提供了 DAX 作为 DynamoDB 的 &quot;内置&quot; 缓存。要使用它，你只需要让客户端理解不同查询操作中可能存在有复制延迟。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这样的调用量下，出现一些异常的情况也是很正常的。在我们的案例中，我们看到 Dynamo 中的一些查询耗时超过 2 - 3 秒，而 99.99% 的调用都在 17ms 以下。尽管这些慢查询每天只有几千次，但我们希望为团队提供更好的 SLA。所以我们决定如果碰到 Dynamo 超时就进行重试。也相关团队也讨论过，让他们在调用我们的 API 时配置一个低超时。他们大多数 HTTP 客户端的默认时间是 2s，所以我们改成了大约 100ms。如果他们碰到超时（比方说微服务对 dynamo 做了重试，但又失败了），他们可以重试，并且很可能会马上得到响应。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了部署它，我们使用 k8s（达到 70 个左右的 pod），并随着每秒请求的增长而进行扩展。DynamoDB 被设置为供应（provision）而非按需。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一个重要的步骤是确保系统能够在真正高吞吐量的情况下健康地工作，我们每天对它进行负载/压力测试，以确保新版本部署没有降低性能。通过这个负载测试的结果，我们可以跟踪一个接口是随着时间的推移和它的发展而变好还是变坏。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着时间的推移，这个微服务变得越来越重要，如果由于某些原因出现故障，那就是一个不可承受的问题。为了解决这个问题，我们要求团队通过 Kong（我们的 API 网关）来调用微服务，并在那里配置了一个 fallback。如果微服务宕机或返回 500，Kong 会激活回调，客户端会得到一个默认结果。在这种情况下，fallback 目前指向一个 S3 bucket，里面有系统会提供的数据副本。它可能是一些过时数据，但这总比不返回任何数据要好。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后总结一下，本文简单描述了一个高性能微服务工作方式。虽然微服务还包括一些其他的工作流程，跟主题无关就不展开赘述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;再谈下微服务接下来的工作，尽管目前还不是完全清晰。微服务的使用量可能会更多，我们可能会达到一个点，开始变得越来越难让它 scale。一个替代方案可能是将其拆分成不同的微服务（甚至可能使用不同的数据库），或者聚合更多的数据以更好地服务于他们。不管如何，我们还是会不断地测试，找到瓶颈，并持续优化它们。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;英文原文：&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://medium.com/swlh/developing-a-microservice-to-handle-over-30k-requests-per-second-at-ifood-3e2d7b822b0e&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;参考阅读：&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文由高可用架构翻译，技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;高可用架构&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;改变互联网的构建方式&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;img data-w=&quot;200&quot; data-type=&quot;jpeg&quot; data-s=&quot;300,640&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOPOK9rQud9XibGhPOPsA3gA8Wr4CEnzmhfZQzSGu0Q09GOuk18S9icZtuVnQewvyqZtOWyDnJPBDn1A/640?wx_fmt=jpeg&quot;/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;长按二维码 关注「高可用架构」公众号&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>98fe28c2683d82e0fd6a02b2f952c8f4</guid>
<title>[推荐] CPU 飙高，系统性能问题如何排查？</title>
<link>https://toutiao.io/k/h1mu8e9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLqLGSRLxM4Z2QKpUVWyztuKkVz6qy2UISPOun8iau5GjXBzLmzJJ9RdPvbI4jWU08IpfibRLQ9deAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;p&gt;&lt;span&gt;阿里妹导读：&lt;/span&gt;&lt;span&gt;压测时或多或少都收到过CPU或者Load高的告警，如果是单机偶发性的，经常会认为是“宿主机抢占导致的”，那事实是否真是如此呢？是什么引起了这些指标的飙高？网络、磁盘还是高并发？有什么工具可以定位？TOP、PS还是vmstat？CPU高&amp;amp;Load高和CPU低&amp;amp;Load高，不同的表征又代表着什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文末福利：&lt;span&gt;免费下载&lt;/span&gt;《ECS运维指南之Linux系统诊断&lt;span&gt;》电子书&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6076146076146076&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13Xt6rh8gdsx0AnzhRjVq2OkzxjxVtXvBLQvzozfYA4WSykPJ51QVuFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1287&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一  背景知识&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LINUX进程状态&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LINUX 2.6以后的内核中，进程一般存在7种基础状态：D-不可中断睡眠、R-可执行、S-可中断睡眠、T-暂停态、t-跟踪态、X-死亡态、Z-僵尸态，这几种状态在PS命令中有对应解释。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1806853582554517&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13UqwyJDBg37hT8swox1Cln6BYWH2LWfA3P9VPEq6E3dbcBxys1cZmWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1284&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Load Average &amp;amp; CPU使用率&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;谈到系统性能，Load和CPU使用率是最直观的两个指标，那么这两个指标是怎么被计算出来的呢？是否能互相等价呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Load Average&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不少人都认为，Load代表正在CPU上运行&amp;amp;等待运行的进程数，即&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.09817671809256662&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13OldyMmZCBicJAfEnL1NHOzqOs1iaiaeCoHLpkjk6FemialiaGDxWwAHDYww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但Linux系统中，这种描述并不完全准确。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下为Linux内核源码中Load Average计算方法，可以看出来，因此除了可执行态进程，不可中断睡眠态进程也会被一起纳入计算，即：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.05236907730673317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13p6Hniaw9aBVgDiaTCtqgu7Rr6pKicfR3SOniaaDA9FVSic1vAgAYOaC98jQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1203&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;602staticunsignedlongcount_active_tasks(void)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;603&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;604structtask_struct*p;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;605unsignedlongnr&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;0;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;606607read_lock(&amp;amp;tasklist_lock);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;608for_each_task(p)&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;609if&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;((p-&amp;gt;state==TASK_RUNNING610 (p-&amp;gt;state&amp;amp;TASK_UNINTERRUPTIBLE)))&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;611nr+&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;FIXED_1;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;612&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;613read_unlock(&amp;amp;tasklist_lock);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;614returnnr;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;615&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;......&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;625staticinlinevoidcalc_load(unsignedlongticks)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;626&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;627unsignedlongactive_tasks;&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;/* fixed-point */628staticintcount=LOAD_FREQ;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;629630count-&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;ticks;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;631if&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;(count&amp;lt;0) {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;632count+&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;LOAD_FREQ;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;633active_tasks&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;count_active_tasks();&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;634CALC_LOAD(avenrun[0],&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;EXP_1, active_tasks);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;635CALC_LOAD(avenrun[1],&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;EXP_5, active_tasks);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;636CALC_LOAD(avenrun[2],&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;EXP_15, active_tasks);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;637&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;638&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在前文 Linux进程状态 中有提到过，不可中断睡眠态的进程(TASK_UNINTERRUTED)一般都在进行I/O等待，比如磁盘、网络或者其他外设等待。由此我们可以看出，Load Average在Linux中体现的是整体系统负载，即CPU负载 + Disk负载 + 网络负载 + 其余外设负载，并不能完全等同于CPU使用率(这种情况只出现在Linux中，其余系统比如Unix，Load还是只代表CPU负载)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU使用率&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CPU的时间分片一般可分为4大类：用户进程运行时间 - User Time, 系统内核运行时间 - System Time, 空闲时间 - Idle Time, 被抢占时间 - Steal Time。除了Idle Time外，其余时间CPU都处于工作运行状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8610526315789474&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13NkGgIGfVJdeM86ibhXy8wklbRAS9oPoEw3JzXw3EkOIInWichAEXQGQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;950&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常而言，我们泛指的整体CPU使用率为User Time 和 Systime占比之和(例如tsar中CPU util)，即：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.13093525179856116&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13xsnAXZlZNwDNzxd39WtKr02SOqoaC7xwBfsgPR2km18or5lemBDH9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;695&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了便于定位问题，大多数性能统计工具都将这4类时间片进一步细化成了8类，如下为TOP对CPU时间片的分类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.14093428345209819&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs134JwQO9X9fvRnbtiaksKXdQCfljEGYyt77fm3HWvtZ7iaCZeWhicwQtn3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1263&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这8类分片中，除wa和id外，其余分片CPU都处于工作态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二  资源&amp;amp;瓶颈分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上文我们了解到，Load Average和CPU使用率可被细分为不同的子域指标，指向不同的资源瓶颈。总体来说，指标与资源瓶颈的对应关系基本如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6057319907048799&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13ka70PfcOPtzMkwt17mbEicabmxnT8b91nvIPXPUot4CENjO2RGRibHuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1291&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Load高 &amp;amp; CPU高&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是我们最常遇到的一类情况，即load上涨是CPU负载上升导致。根据CPU具体资源分配表现，可分为以下几类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU sys高&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况CPU主要开销在于系统内核，可进一步查看上下文切换情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU si高&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况CPU大量消耗在软中断，可进一步查看软中断类型。一般而言，网络I/O或者线程调度引起软中断最为常见：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU us高&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况说明资源主要消耗在应用进程，可能引发的原因有以下几类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Load高 &amp;amp; CPU低&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况出现的根本原因在于不可中断睡眠态(TASK_UNINTERRUPTIBLE)进程数较多，即CPU负载不高，但I/O负载较高。可进一步定位是磁盘I/O还是网络I/O导致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三  排查策略&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用现有常用的工具，我们常用的排查策略基本如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6327467482785004&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13jMZeGFd94Twb8icTwibADmSehCDqGrCymSR5myUEic5WN09ribH90nJnCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1307&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从问题发现到最终定位，基本可分为四个阶段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;资源瓶颈定位&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一阶段通过全局性能检测工具，初步定位资源消耗异常位点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常用的工具有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;热点进程定位&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定位到资源瓶颈后，可进一步分析具体进程资源消耗情况，找到热点进程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常用工具有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上下文切换：pidstat -w&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CPU&lt;span&gt;：&lt;/span&gt;pidstat -u&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;I/O&lt;span&gt;：&lt;/span&gt;iotop、pidstat -d&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;僵尸进程&lt;span&gt;：&lt;/span&gt;ps&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程&amp;amp;进程内部资源定位&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;找到具体进程后，可细化分析进程内部资源开销情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常用工具有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;热点事件&amp;amp;方法分析&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;获取到热点线程后，我们可用trace或者dump工具，将线程反向关联，将问题范围定位到具体方法&amp;amp;堆栈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常用的工具有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;相关阅读&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1]Linux Load Averages: Solving the Mystery&lt;br/&gt;http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2]What exactly is a load average?&lt;br/&gt;http://linuxtechsupport.blogspot.com/2008/10/what-exactly-is-load-average.html&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;电子书免费下载&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《ECS运维指南 之 Linux系统诊断》&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.4143490528012899&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13mFxuOHQUtPOc74R27jQmckLEMKEcsuBxoGo7qAVxDuD1IMNbKAiayzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2481&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本书以浅显易懂的案例带领您进入Linux的世界，由浅入深，由表及里，层层推进，从运维工作的实际需求出发，全面讲解相关的技术、经典案例，以及常见问题的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;点击“阅读原文”&lt;/span&gt;，立即下载吧！  &lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot; data-s=&quot;300,640&quot; data-copyright=&quot;0&quot; data-cropsely2=&quot;182&quot; data-cropsely1=&quot;0&quot; data-cropselx2=&quot;180&quot; data-cropselx1=&quot;0&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naKjYl1NicXGw20r286y3CF1Jc5iafxBBXzN9GyerB7AMQAPeGCGZA57Ha7w75vickdc4aFAsBNicyVfgg/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;关注&lt;/span&gt;&lt;span&gt;「阿里技术」&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;把握前沿技术脉搏&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z6bicxIx5naLWBBEcl44aIic1Mthe1nZiaramW5s4e8WwyCYYbTzu6uPBpgI6sxNXNymEnOYKpJpcrItUia7lS64mA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;戳我，下载电子书。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b5dd0d68223cb7bd00b570701d211744</guid>
<title>[推荐] Spring Boot 启动原理</title>
<link>https://toutiao.io/k/itvkvui</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1&amp;gt; 大家都知道SpringBoot是通过main函数启动的，这里面跟踪代码到处都没有找到while(true)，为什么启动后可以一直跑？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2&amp;gt; SpringBoot默认使用tomcat作为web容器。大家也可以通过在pom文件中exclusion掉tomcat，denpendency jetty 的方法来使用jetty。那SpringBoot是怎么做到在不同web容器之间切换的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2&amp;gt; 传统的web容器比如jetty本质上是直接通过java start.jar 来启动，之后来加载spring上下文的，SpringBoot通过main函数是怎么来启动web容器的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本文就这三个问题展开论述。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题1分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;问题1很简单，启动后一直跑是因为启动了线程池。原理就是有非deamon的线程在跑。Java虚拟机规范定义要等所有用户线程都运行完才会退出。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以这个原理就和下面启动线程池一样&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7517875383043923&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icyeBluAHR6lFIGx0XRCZRSN9qZHnjYnyWXHHmEqJQM44G4tnaUX5kJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;979&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;程序员修炼之道教我们：不要假定，要证明。虽然jetty使用线程池是常识，我们也来跟踪下源码，看看线程池是在哪里初始化的：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;org.springframework.boot.web.embedded.jetty.JettyServletWebServerFactory类里，创建Server的使用使用线程池作为初始化参数。然后创建了socket连接来监听端口。（对于socket连接有之前没接触过的，可以自己查一下。建议动手实践。&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485101&amp;amp;idx=1&amp;amp;sn=c95f1a3fa03af199c78d59bb29ea411c&amp;amp;chksm=fafdec03cd8a6515f61cf42d3ce94ee7bc465f445cb61d4644d259c55a661cce4ab1a6dc4738&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《Java异常处理总结》&lt;/a&gt;这篇文章里有不错的简单小例子可以实操下。）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5701219512195121&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icUaFAlvSC5f8P9NuvBj7ajGvHDMvdibH7sC16YIjOoCzP2GvkqlGecSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;到这里，大家应该都明白了为什么启动后一直不停。但是又有疑问了：JettyServletWebServerFactory是个什么东东？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题2分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;关于问题2，我们写个最简单的类来debug一下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.17950963222416813&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icQzRDtiaYapYwGiaPzTLeq7cCbVIqxmfWMwdPb2wCUTJEFYWWJV0Yc0vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;进入SpringAppication.run的源码可以看到，里面创建了一个context，默认是AnnotationConfigServletWebServerApplicationContext。一初始化，在Bean定义里就加载了spring开天辟地的5个Bean。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7903494176372712&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icfmBmUbAmFZyZrV8JVjuQA5z8BsuaDOIAg6pVgJ11Fk3020D6icxvVtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;继续向下执行走到AbstractApplicationContext的refresh方法，执行到onRefresh时，你进入方法里发现实际上执行的是&lt;/p&gt;&lt;p&gt;ServletWebServerApplicationContext的onFresh&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6649746192893401&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icz6Zic8dlFIeYHLPPNI8f8STg0mXPZn9iaXSx768bbLdGmHEP4EHE40XA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;985&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里面实际只做了一件事：创建web服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.31267345050878814&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icNH46T5npWwQhQJqSPDg4tib60Q4yB24LhetuDxfdngLdQia3m6WgdRPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1081&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;进入这个方法，debug到getWebServerFactory&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.504225352112676&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icqn8LnMmFPCYFJGoAYm3cz1KokTpXabOWVKYzoaTLRM6vBia9zK5RJhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1065&quot;/&gt;&lt;/p&gt;&lt;p&gt;来看一下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4768480909829407&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicZABgRrbBAG33MvWnr6W1icibjRmZN3tCG5Fib5lVUH9xbGtVE19evG0R58z6Jolib9mMhuYicpJpHqNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1231&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;获取的正式JettyServletWebServerFactory。为啥不是TomcatServlet呢？ServletWebServerFactoryAutoConfiguration的源码很好的说明了这个问题。源码的大意是当tomcat依赖存在就用tomcat，不然就按顺序找jetty存不存在，不存在再找Undertow存不存在。找到了就返回这个bean作为Servlet的工厂类。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;@Configuration&lt;br/&gt;@AutoConfigureOrder(-&lt;span&gt;2147483648&lt;/span&gt;)&lt;br/&gt;@ConditionalOnClass({ServletRequest.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@ConditionalOnWebApplication(&lt;br/&gt;    type = Type.SERVLET&lt;br/&gt;)&lt;br/&gt;@EnableConfigurationProperties({ServerProperties.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@Import({ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.&lt;span&gt;class, &lt;/span&gt;EmbeddedTomcat.&lt;span&gt;class, &lt;/span&gt;EmbeddedJetty.&lt;span&gt;class, &lt;/span&gt;EmbeddedUndertow.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;&lt;span&gt;public class &lt;/span&gt;ServletWebServerFactoryAutoConfiguration {&lt;br/&gt;    &lt;span&gt;public &lt;/span&gt;ServletWebServerFactoryAutoConfiguration() {&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Bean&lt;br/&gt;    &lt;span&gt;public &lt;/span&gt;ServletWebServerFactoryCustomizer servletWebServerFactoryCustomizer(ServerProperties serverProperties) {&lt;br/&gt;        &lt;span&gt;return new &lt;/span&gt;ServletWebServerFactoryCustomizer(serverProperties)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;    @Bean&lt;br/&gt;    @ConditionalOnClass(&lt;br/&gt;        name = {&lt;span&gt;&quot;org.apache.catalina.startup.Tomcat&quot;&lt;/span&gt;}&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;public &lt;/span&gt;TomcatServletWebServerFactoryCustomizer tomcatServletWebServerFactoryCustomizer(ServerProperties serverProperties) {&lt;br/&gt;        &lt;span&gt;return new &lt;/span&gt;TomcatServletWebServerFactoryCustomizer(serverProperties)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public static class &lt;/span&gt;BeanPostProcessorsRegistrar &lt;span&gt;implements &lt;/span&gt;ImportBeanDefinitionRegistrar&lt;span&gt;, &lt;/span&gt;BeanFactoryAware {&lt;br/&gt;        &lt;span&gt;private &lt;/span&gt;ConfigurableListableBeanFactory beanFactory&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        public &lt;/span&gt;BeanPostProcessorsRegistrar() {&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;public void &lt;/span&gt;setBeanFactory(BeanFactory beanFactory) &lt;span&gt;throws &lt;/span&gt;BeansException {&lt;br/&gt;            &lt;span&gt;if &lt;/span&gt;(beanFactory &lt;span&gt;instanceof &lt;/span&gt;ConfigurableListableBeanFactory) {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.beanFactory = (ConfigurableListableBeanFactory)beanFactory&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;public void &lt;/span&gt;registerBeanDefinitions(AnnotationMetadata importingClassMetadata&lt;span&gt;, &lt;/span&gt;BeanDefinitionRegistry registry) {&lt;br/&gt;            &lt;span&gt;if &lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.beanFactory != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.registerSyntheticBeanIfMissing(registry&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;webServerFactoryCustomizerBeanPostProcessor&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;WebServerFactoryCustomizerBeanPostProcessor.&lt;span&gt;class&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                this&lt;/span&gt;.registerSyntheticBeanIfMissing(registry&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;errorPageRegistrarBeanPostProcessor&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;ErrorPageRegistrarBeanPostProcessor.&lt;span&gt;class&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;private void &lt;/span&gt;registerSyntheticBeanIfMissing(BeanDefinitionRegistry registry&lt;span&gt;, &lt;/span&gt;String name&lt;span&gt;, &lt;/span&gt;Class&amp;lt;?&amp;gt; beanClass) {&lt;br/&gt;            &lt;span&gt;if &lt;/span&gt;(ObjectUtils.isEmpty(&lt;span&gt;this&lt;/span&gt;.beanFactory.getBeanNamesForType(beanClass&lt;span&gt;, true, false&lt;/span&gt;))) {&lt;br/&gt;                RootBeanDefinition beanDefinition = &lt;span&gt;new &lt;/span&gt;RootBeanDefinition(beanClass)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;beanDefinition.setSynthetic(&lt;span&gt;true&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;registry.registerBeanDefinition(name&lt;span&gt;, &lt;/span&gt;beanDefinition)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;至此第二个问题也真相大白。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题3分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第三个问题是传统的web容器比如jetty本质上是直接通过java start.jar 来启动，之后来加载spring上下文的，SpringBoot通过main函数是怎么来启动web容器。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个问题在前面问题分析过程中也给了很多线索。我们来回顾下：SpringApplication.run里会创建Spring的应用上下文，默认是AnnotationConfigServletWebServerApplicationContext。首先会加载Spring开天辟地的5个Bean。然后它初始化各种Bean工厂。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;SpringBoot在ServletWebServerApplicationContext中重载了onRefresh方法，除了以前Spring默认的onRefresh方法外还增加了createWebServer方法，在这个方法中对Web容器进行了初始化工作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;version&amp;gt;&lt;/span&gt;${spring.boot.version}&lt;span&gt;&amp;lt;/version&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;exclusions&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-logging&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;/exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-tomcat&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;/exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;groupId&amp;gt;&lt;/span&gt;com.fasterxml.jackson.core&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;artifactId&amp;gt;&lt;/span&gt;jackson-databind&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;/exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;/exclusions&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-jetty&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;version&amp;gt;&lt;/span&gt;${spring.boot.version}&lt;span&gt;&amp;lt;/version&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;exclusions&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;groupId&amp;gt;&lt;/span&gt;org.eclipse.jetty.aggregate&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &amp;lt;artifactId&amp;gt;&lt;/span&gt;jetty-all&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &amp;lt;/exclusion&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &amp;lt;/exclusions&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为选择servlet容器是类似于使用基于条件的注解方式。因为当exclusion掉tomcat后，只有jetty满足条件，所以会加载JettyServletWebServerFactory。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过getWebServer方法会new一个WebServer对象，new对象的方法会调用initialize方法，在这个方法中会对容器进行初始化并启动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而容器启动的基本原理就是创建个线程池和网络套接字。用线程去处理套接字读写的内容。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;文本用带有少许说明的三个问题开场展开论述，实际是使用了麦肯锡大法中的SCQA架构。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;SCQA架构是金字塔模型里面突出的一个论述方法，即“情境（Situation）、冲突（Complication）、问题（Question）、答案（Answer）”。可以帮助我们在陈述事实时条理更为清晰、有效。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;SCQA其实只是麦肯锡做了总结。这个方法李清照都在用：&lt;/p&gt;&lt;p&gt;昨夜雨疏风骤，浓睡不消残酒 （情境）&lt;/p&gt;&lt;p&gt;试问卷帘人，渠道海棠依旧（冲突）&lt;/p&gt;&lt;p&gt;知否，知否（问题）&lt;/p&gt;&lt;p&gt;应是绿肥红瘦（答案）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;文章正文看似一步步回答问题，实际上在讲述怎样去看spring源码，了解spring原理的一个过程。即：带着问题去看，debug跟踪源码验证 的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cf234f3b7b9c84f459013622b73435d6</guid>
<title>[推荐] 30 个 Go 语言常用文件操作汇总，总有一个你会用的到</title>
<link>https://toutiao.io/k/kps7o16</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go官方提供的文件操作标准库分散在&lt;code&gt;os&lt;/code&gt;、&lt;code&gt;ioutil&lt;/code&gt;等多个包中，里面有非常多的方法涵盖了文件操作的所有场景，不过因为我平时开发过程中需要直接操作文件的场景其实并不多，在加上Go标准库的文档太难搜索，每次遇到要使用文件函数时都是直接Google查对应的函数。偶然查到国外一个人在2015年写的博客，他&lt;strong&gt;用常用的文件函数汇总了30个文件操作场景&lt;/strong&gt;，包括四大类：&lt;strong&gt;基本操作、读写操作、文件压缩、其他操作&lt;/strong&gt;。每一个文件操作都给了代码示例。写的非常好，强烈推荐你阅读一下，浏览一下它的目录，然后放到收藏夹里吃灰&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f7Tw3INC9Rd88gnNnkkS2vFC7zpghkgHo1G2iaQZ1NN7H1iaJW3mgT3icjQomPM8V3Z9ibQk6gDvuFsDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f7Tw3INC9Rd88gnNnkkS2vFVPPjOOrNGypc1mEiciao4zQZhpwhfibBibUhxlpQMxONWu0eZ2RuNV8D6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;，万一哪天用到了还能拿来参考一下。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://www.devdungeon.com/content/working-files-go&lt;/p&gt;&lt;p&gt;作者：&lt;strong&gt;NanoDano&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;作者主页：https://www.devdungeon.com/users/nanodano&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;介绍&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一切皆文件&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UNIX 的一个基础设计就是&quot;万物皆文件&quot;(everything is a file)。我们不必知道操作系统的设备驱动把什么映射给了一个文件描述符，操作系统为设备提供了文件格式的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go语言中的reader和writer接口也类似。我们只需简单的读写字节，不必知道reader的数据来自哪里，也不必知道writer将数据发送到哪里。你可以在&lt;code&gt;/dev&lt;/code&gt;下查看可用的设备，有些可能需要较高的权限才能访问。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文件基本操作&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建空文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;var (&lt;br/&gt;    newFile *os.File&lt;br/&gt;    err     error&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    newFile, err = os.Create(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Println(newFile)&lt;br/&gt;    newFile.Close()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Truncate裁剪文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 裁剪一个文件到100个字节。&lt;br/&gt;    // 如果文件本来就少于100个字节，则文件中原始内容得以保留，剩余的字节以null字节填充。&lt;br/&gt;    // 如果文件本来超过100个字节，则超过的字节会被抛弃。&lt;br/&gt;    // 这样我们总是得到精确的100个字节的文件。&lt;br/&gt;    // 传入0则会清空文件。&lt;br/&gt;&lt;br/&gt;    err := os.Truncate(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, 100)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;获取文件信息&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;var (&lt;br/&gt;    fileInfo os.FileInfo&lt;br/&gt;    err      error&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 如果文件不存在，则返回错误&lt;br/&gt;    fileInfo, err = os.Stat(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;File name:&quot;&lt;/span&gt;, fileInfo.Name())&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Size in bytes:&quot;&lt;/span&gt;, fileInfo.Size())&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Permissions:&quot;&lt;/span&gt;, fileInfo.Mode())&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Last modified:&quot;&lt;/span&gt;, fileInfo.ModTime())&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Is Directory: &quot;&lt;/span&gt;, fileInfo.IsDir())&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;System interface type: %T\n&quot;&lt;/span&gt;, fileInfo.Sys())&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;System info: %+v\n\n&quot;&lt;/span&gt;, fileInfo.Sys())&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重命名和移动&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    originalPath := &lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;&lt;br/&gt;    newPath := &lt;span&gt;&quot;test2.txt&quot;&lt;/span&gt;&lt;br/&gt;    err := os.Rename(originalPath, newPath)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;删除文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    err := os.Remove(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;打开和关闭文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 简单地以只读的方式打开。下面的例子会介绍读写的例子。&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    file.Close()&lt;br/&gt;&lt;br/&gt;    // OpenFile提供更多的选项。&lt;br/&gt;    // 最后一个参数是权限模式permission mode&lt;br/&gt;    // 第二个是打开时的属性    &lt;br/&gt;    file, err = os.OpenFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, os.O_APPEND, 0666)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    file.Close()&lt;br/&gt;&lt;br/&gt;    // 下面的属性可以单独使用，也可以组合使用。&lt;br/&gt;    // 组合使用时可以使用 OR 操作设置 OpenFile的第二个参数，例如：&lt;br/&gt;    // os.O_CREATE|os.O_APPEND&lt;br/&gt;    // 或者 os.O_CREATE|os.O_TRUNC|os.O_WRONLY&lt;br/&gt;&lt;br/&gt;    // os.O_RDONLY // 只读&lt;br/&gt;    // os.O_WRONLY // 只写&lt;br/&gt;    // os.O_RDWR // 读写&lt;br/&gt;    // os.O_APPEND // 往文件中添建（Append）&lt;br/&gt;    // os.O_CREATE // 如果文件不存在则先创建&lt;br/&gt;    // os.O_TRUNC // 文件打开时裁剪文件&lt;br/&gt;    // os.O_EXCL // 和O_CREATE一起使用，文件不能存在&lt;br/&gt;    // os.O_SYNC // 以同步I/O的方式打开&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;检查文件是否存在&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;var (&lt;br/&gt;    fileInfo *os.FileInfo&lt;br/&gt;    err      error&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 文件不存在则返回error&lt;br/&gt;    fileInfo, err := os.Stat(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; os.IsNotExist(err) {&lt;br/&gt;            log.Fatal(&lt;span&gt;&quot;File does not exist.&quot;&lt;/span&gt;)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    log.Println(&lt;span&gt;&quot;File does exist. File information:&quot;&lt;/span&gt;)&lt;br/&gt;    log.Println(fileInfo)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;检查读写权限&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 这个例子测试写权限，如果没有写权限则返回error。&lt;br/&gt;    // 注意文件不存在也会返回error，需要检查error的信息来获取到底是哪个错误导致。&lt;br/&gt;    file, err := os.OpenFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, os.O_WRONLY, 0666)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; os.IsPermission(err) {&lt;br/&gt;            log.Println(&lt;span&gt;&quot;Error: Write permission denied.&quot;&lt;/span&gt;)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    file.Close()&lt;br/&gt;&lt;br/&gt;    // 测试读权限&lt;br/&gt;    file, err = os.OpenFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, os.O_RDONLY, 0666)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; os.IsPermission(err) {&lt;br/&gt;            log.Println(&lt;span&gt;&quot;Error: Read permission denied.&quot;&lt;/span&gt;)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    file.Close()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;改变权限、拥有者、时间戳&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 使用Linux风格改变文件权限&lt;br/&gt;    err := os.Chmod(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, 0777)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Println(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 改变文件所有者&lt;br/&gt;    err = os.Chown(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, os.Getuid(), os.Getgid())&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Println(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 改变时间戳&lt;br/&gt;    twoDaysFromNow := time.Now().Add(48 * time.Hour)&lt;br/&gt;    lastAccessTime := twoDaysFromNow&lt;br/&gt;    lastModifyTime := twoDaysFromNow&lt;br/&gt;    err = os.Chtimes(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, lastAccessTime, lastModifyTime)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Println(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建硬链接和软链接&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个普通的文件是一个指向硬盘的inode的地方。硬链接创建一个新的指针指向同一个地方。只有所有的链接被删除后文件才会被删除。硬链接只在相同的文件系统中才工作。你可以认为一个硬链接是一个正常的链接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;symbolic link，又叫软连接，和硬链接有点不一样，它不直接指向硬盘中的相同的地方，而是通过名字引用其它文件。他们可以指向不同的文件系统中的不同文件。并不是所有的操作系统都支持软链接。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 创建一个硬链接。&lt;br/&gt;    // 创建后同一个文件内容会有两个文件名，改变一个文件的内容会影响另一个。&lt;br/&gt;    // 删除和重命名不会影响另一个。&lt;br/&gt;    err := os.Link(&lt;span&gt;&quot;original.txt&quot;&lt;/span&gt;, &lt;span&gt;&quot;original_also.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;creating sym&quot;&lt;/span&gt;)&lt;br/&gt;    // Create a symlink&lt;br/&gt;    err = os.Symlink(&lt;span&gt;&quot;original.txt&quot;&lt;/span&gt;, &lt;span&gt;&quot;original_sym.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // Lstat返回一个文件的信息，但是当文件是一个软链接时，它返回软链接的信息，而不是引用的文件的信息。&lt;br/&gt;    // Symlink在Windows中不工作。&lt;br/&gt;    fileInfo, err := os.Lstat(&lt;span&gt;&quot;original_sym.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Link info: %+v&quot;&lt;/span&gt;, fileInfo)&lt;br/&gt;&lt;br/&gt;    //改变软链接的拥有者不会影响原始文件。&lt;br/&gt;    err = os.Lchown(&lt;span&gt;&quot;original_sym.txt&quot;&lt;/span&gt;, os.Getuid(), os.Getgid())&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文件读写&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;复制文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开原始文件&lt;br/&gt;    originalFile, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer originalFile.Close()&lt;br/&gt;&lt;br/&gt;    // 创建新的文件作为目标文件&lt;br/&gt;    newFile, err := os.Create(&lt;span&gt;&quot;test_copy.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer newFile.Close()&lt;br/&gt;&lt;br/&gt;    // 从源中复制字节到目标文件&lt;br/&gt;    bytesWritten, err := io.Copy(newFile, originalFile)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Copied %d bytes.&quot;&lt;/span&gt;, bytesWritten)&lt;br/&gt;&lt;br/&gt;    // 将文件内容flush到硬盘中&lt;br/&gt;    err = newFile.Sync()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;跳转到文件指定位置(Seek)&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    file, _ := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    defer file.Close()&lt;br/&gt;&lt;br/&gt;    // 偏离位置，可以是正数也可以是负数&lt;br/&gt;    var offset int64 = 5&lt;br/&gt;&lt;br/&gt;    // 用来计算offset的初始位置&lt;br/&gt;    // 0 = 文件开始位置&lt;br/&gt;    // 1 = 当前位置&lt;br/&gt;    // 2 = 文件结尾处&lt;br/&gt;    var &lt;span&gt;whence&lt;/span&gt; int = 0&lt;br/&gt;    newPosition, err := file.Seek(offset, &lt;span&gt;whence&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Just moved to 5:&quot;&lt;/span&gt;, newPosition)&lt;br/&gt;&lt;br/&gt;    // 从当前位置回退两个字节&lt;br/&gt;    newPosition, err = file.Seek(-2, 1)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Just moved back two:&quot;&lt;/span&gt;, newPosition)&lt;br/&gt;&lt;br/&gt;    // 使用下面的技巧得到当前的位置&lt;br/&gt;    currentPosition, err := file.Seek(0, 1)&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Current position:&quot;&lt;/span&gt;, currentPosition)&lt;br/&gt;&lt;br/&gt;    // 转到文件开始处&lt;br/&gt;    newPosition, err = file.Seek(0, 0)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Position after seeking 0,0:&quot;&lt;/span&gt;, newPosition)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;写文件&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;code&gt;os&lt;/code&gt;包写入一个打开的文件。因为Go可执行包是静态链接的可执行文件，你import的每一个包都会增加你的可执行文件的大小。其它的包如&lt;code&gt;io&lt;/code&gt;、｀ioutil｀、｀bufio｀提供了一些方法，但是它们不是必须的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 可写方式打开文件&lt;br/&gt;    file, err := os.OpenFile(&lt;br/&gt;        &lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;,&lt;br/&gt;        os.O_WRONLY|os.O_TRUNC|os.O_CREATE,&lt;br/&gt;        0666,&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer file.Close()&lt;br/&gt;&lt;br/&gt;    // 写字节到文件中&lt;br/&gt;    byteSlice := []byte(&lt;span&gt;&quot;Bytes!\n&quot;&lt;/span&gt;)&lt;br/&gt;    bytesWritten, err := file.Write(byteSlice)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Wrote %d bytes.\n&quot;&lt;/span&gt;, bytesWritten)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;快写文件&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ioutil&lt;/code&gt;包有一个非常有用的方法&lt;code&gt;WriteFile()&lt;/code&gt;可以处理创建或者打开文件、写入字节切片和关闭文件一系列的操作。如果你需要简洁快速地写字节切片到文件中，你可以使用它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    err := ioutil.WriteFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, []byte(&lt;span&gt;&quot;Hi\n&quot;&lt;/span&gt;), 0666)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用缓存写&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;bufio&lt;/code&gt;包提供了带缓存功能的writer，所以你可以在写字节到硬盘前使用内存缓存。当你处理很多的数据很有用，因为它可以节省操作硬盘I/O的时间。在其它一些情况下它也很有用，比如你每次写一个字节，把它们攒在内存缓存中，然后一次写入到硬盘中，减少硬盘的磨损以及提升性能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;bufio&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开文件，只写&lt;br/&gt;    file, err := os.OpenFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, os.O_WRONLY, 0666)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer file.Close()&lt;br/&gt;&lt;br/&gt;    // 为这个文件创建buffered writer&lt;br/&gt;    bufferedWriter := bufio.NewWriter(file)&lt;br/&gt;&lt;br/&gt;    // 写字节到buffer&lt;br/&gt;    bytesWritten, err := bufferedWriter.Write(&lt;br/&gt;        []byte{65, 66, 67},&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Bytes written: %d\n&quot;&lt;/span&gt;, bytesWritten)&lt;br/&gt;&lt;br/&gt;    // 写字符串到buffer&lt;br/&gt;    // 也可以使用 WriteRune() 和 WriteByte()   &lt;br/&gt;    bytesWritten, err = bufferedWriter.WriteString(&lt;br/&gt;        &lt;span&gt;&quot;Buffered string\n&quot;&lt;/span&gt;,&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Bytes written: %d\n&quot;&lt;/span&gt;, bytesWritten)&lt;br/&gt;&lt;br/&gt;    // 检查缓存中的字节数&lt;br/&gt;    unflushedBufferSize := bufferedWriter.Buffered()&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Bytes buffered: %d\n&quot;&lt;/span&gt;, unflushedBufferSize)&lt;br/&gt;&lt;br/&gt;    // 还有多少字节可用（未使用的缓存大小）&lt;br/&gt;    bytesAvailable := bufferedWriter.Available()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Available buffer: %d\n&quot;&lt;/span&gt;, bytesAvailable)&lt;br/&gt;&lt;br/&gt;    // 写内存buffer到硬盘&lt;br/&gt;    bufferedWriter.Flush()&lt;br/&gt;&lt;br/&gt;    // 丢弃还没有flush的缓存的内容，清除错误并把它的输出传给参数中的writer&lt;br/&gt;    // 当你想将缓存传给另外一个writer时有用&lt;br/&gt;    bufferedWriter.Reset(bufferedWriter)&lt;br/&gt;&lt;br/&gt;    bytesAvailable = bufferedWriter.Available()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Available buffer: %d\n&quot;&lt;/span&gt;, bytesAvailable)&lt;br/&gt;&lt;br/&gt;    // 重新设置缓存的大小。&lt;br/&gt;    // 第一个参数是缓存应该输出到哪里，这个例子中我们使用相同的writer。&lt;br/&gt;    // 如果我们设置的新的大小小于第一个参数writer的缓存大小， 比如10，我们不会得到一个10字节大小的缓存，&lt;br/&gt;    // 而是writer的原始大小的缓存，默认是4096。&lt;br/&gt;    // 它的功能主要还是为了扩容。&lt;br/&gt;    bufferedWriter = bufio.NewWriterSize(&lt;br/&gt;        bufferedWriter,&lt;br/&gt;        8000,&lt;br/&gt;    )&lt;br/&gt;&lt;br/&gt;    // resize后检查缓存的大小&lt;br/&gt;    bytesAvailable = bufferedWriter.Available()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Available buffer: %d\n&quot;&lt;/span&gt;, bytesAvailable)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;读取最多N个字节&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;os.File&lt;/code&gt;提供了文件操作的基本功能， 而&lt;code&gt;io&lt;/code&gt;、&lt;code&gt;ioutil&lt;/code&gt;、&lt;code&gt;bufio&lt;/code&gt;提供了额外的辅助函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开文件，只读&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer file.Close()&lt;br/&gt;&lt;br/&gt;    // 从文件中读取len(b)字节的文件。&lt;br/&gt;    // 返回0字节意味着读取到文件尾了&lt;br/&gt;    // 读取到文件会返回io.EOF的error&lt;br/&gt;    byteSlice := make([]byte, 16)&lt;br/&gt;    bytesRead, err := file.Read(byteSlice)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Number of bytes read: %d\n&quot;&lt;/span&gt;, bytesRead)&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Data read: %s\n&quot;&lt;/span&gt;, byteSlice)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;读取正好N个字节&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // Open file &lt;span&gt;for&lt;/span&gt; reading&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // file.Read()可以读取一个小文件到大的byte slice中，&lt;br/&gt;    // 但是io.ReadFull()在文件的字节数小于byte slice字节数的时候会返回错误&lt;br/&gt;    byteSlice := make([]byte, 2)&lt;br/&gt;    numBytesRead, err := io.ReadFull(file, byteSlice)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Number of bytes read: %d\n&quot;&lt;/span&gt;, numBytesRead)&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Data read: %s\n&quot;&lt;/span&gt;, byteSlice)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;读取至少N个字节&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开文件，只读&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    byteSlice := make([]byte, 512)&lt;br/&gt;    minBytes := 8&lt;br/&gt;    // io.ReadAtLeast()在不能得到最小的字节的时候会返回错误，但会把已读的文件保留&lt;br/&gt;    numBytesRead, err := io.ReadAtLeast(file, byteSlice, minBytes)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Number of bytes read: %d\n&quot;&lt;/span&gt;, numBytesRead)&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Data read: %s\n&quot;&lt;/span&gt;, byteSlice)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;读取全部字节&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // os.File.Read(), io.ReadFull() 和&lt;br/&gt;    // io.ReadAtLeast() 在读取之前都需要一个固定大小的byte slice。&lt;br/&gt;    // 但ioutil.ReadAll()会读取reader(这个例子中是file)的每一个字节，然后把字节slice返回。&lt;br/&gt;    data, err := ioutil.ReadAll(file)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Data as hex: %x\n&quot;&lt;/span&gt;, data)&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Data as string: %s\n&quot;&lt;/span&gt;, data)&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;Number of bytes read:&quot;&lt;/span&gt;, len(data))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;快读到内存&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 读取文件到byte slice中&lt;br/&gt;    data, err := ioutil.ReadFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    log.Printf(&lt;span&gt;&quot;Data read: %s\n&quot;&lt;/span&gt;, data)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用缓存读&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有缓存写也有缓存读。缓存reader会把一些内容缓存在内存中。它会提供比&lt;code&gt;os.File&lt;/code&gt;和&lt;code&gt;io.Reader&lt;/code&gt;更多的函数,缺省的缓存大小是4096，最小缓存是16。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;bufio&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开文件，创建buffered reader&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    bufferedReader := bufio.NewReader(file)&lt;br/&gt;&lt;br/&gt;    // 得到字节，当前指针不变&lt;br/&gt;    byteSlice := make([]byte, 5)&lt;br/&gt;    byteSlice, err = bufferedReader.Peek(5)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Peeked at 5 bytes: %s\n&quot;&lt;/span&gt;, byteSlice)&lt;br/&gt;&lt;br/&gt;    // 读取，指针同时移动&lt;br/&gt;    numBytesRead, err := bufferedReader.Read(byteSlice)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Read %d bytes: %s\n&quot;&lt;/span&gt;, numBytesRead, byteSlice)&lt;br/&gt;&lt;br/&gt;    // 读取一个字节, 如果读取不成功会返回Error&lt;br/&gt;    myByte, err := bufferedReader.ReadByte()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Read 1 byte: %c\n&quot;&lt;/span&gt;, myByte)     &lt;br/&gt;&lt;br/&gt;    // 读取到分隔符，包含分隔符，返回byte slice&lt;br/&gt;    dataBytes, err := bufferedReader.ReadBytes(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Read bytes: %s\n&quot;&lt;/span&gt;, dataBytes)           &lt;br/&gt;&lt;br/&gt;    // 读取到分隔符，包含分隔符，返回字符串&lt;br/&gt;    dataString, err := bufferedReader.ReadString(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Read string: %s\n&quot;&lt;/span&gt;, dataString)     &lt;br/&gt;&lt;br/&gt;    //这个例子读取了很多行，所以test.txt应该包含多行文本才不至于出错&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用 scanner&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Scanner&lt;/code&gt;是&lt;code&gt;bufio&lt;/code&gt;包下的类型,在处理文件中以分隔符分隔的文本时很有用。通常我们使用换行符作为分隔符将文件内容分成多行。在CSV文件中，逗号一般作为分隔符。&lt;code&gt;os.File&lt;/code&gt;文件可以被包装成&lt;code&gt;bufio.Scanner&lt;/code&gt;，它就像一个缓存reader。我们会调用&lt;code&gt;Scan()&lt;/code&gt;方法去读取下一个分隔符，使用&lt;code&gt;Text()&lt;/code&gt;或者&lt;code&gt;Bytes()&lt;/code&gt;获取读取的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分隔符可以不是一个简单的字节或者字符，有一个特殊的方法可以实现分隔符的功能，以及将指针移动多少，返回什么数据。如果没有定制的&lt;code&gt;SplitFunc&lt;/code&gt;提供，缺省的&lt;code&gt;ScanLines&lt;/code&gt;会使用&lt;code&gt;newline&lt;/code&gt;字符作为分隔符，其它的分隔函数还包括&lt;code&gt;ScanRunes&lt;/code&gt;和&lt;code&gt;ScanWords&lt;/code&gt;,皆在&lt;code&gt;bufio&lt;/code&gt;包中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// To define your own split &lt;span&gt;function&lt;/span&gt;, match this fingerprint&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)&lt;br/&gt;&lt;br/&gt;// Returning (0, nil, nil) will tell the scanner&lt;br/&gt;// to scan again, but with a bigger buffer because&lt;br/&gt;// it wasn&lt;span&gt;&#x27;t enough data to reach the delimiter&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的例子中，为一个文件创建了&lt;code&gt;bufio.Scanner&lt;/code&gt;，并按照单词逐个读取：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;bufio&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    scanner := bufio.NewScanner(file)&lt;br/&gt;&lt;br/&gt;    // 缺省的分隔函数是bufio.ScanLines,我们这里使用ScanWords。&lt;br/&gt;    // 也可以定制一个SplitFunc类型的分隔函数&lt;br/&gt;    scanner.Split(bufio.ScanWords)&lt;br/&gt;&lt;br/&gt;    // scan下一个token.&lt;br/&gt;    success := scanner.Scan()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; success == &lt;span&gt;false&lt;/span&gt; {&lt;br/&gt;        // 出现错误或者EOF是返回Error&lt;br/&gt;        err = scanner.Err()&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err == nil {&lt;br/&gt;            log.Println(&lt;span&gt;&quot;Scan completed and reached EOF&quot;&lt;/span&gt;)&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            log.Fatal(err)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 得到数据，Bytes() 或者 Text()&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;First word found:&quot;&lt;/span&gt;, scanner.Text())&lt;br/&gt;&lt;br/&gt;    // 再次调用scanner.Scan()发现下一个token&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文件压缩&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;打包(zip) 文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// This example uses zip but standard library&lt;br/&gt;// also supports tar archives&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;archive/zip&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 创建一个打包文件&lt;br/&gt;    outFile, err := os.Create(&lt;span&gt;&quot;test.zip&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer outFile.Close()&lt;br/&gt;&lt;br/&gt;    // 创建zip writer&lt;br/&gt;    zipWriter := zip.NewWriter(outFile)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    // 往打包文件中写文件。&lt;br/&gt;    // 这里我们使用硬编码的内容，你可以遍历一个文件夹，把文件夹下的文件以及它们的内容写入到这个打包文件中。&lt;br/&gt;    var filesToArchive = []struct {&lt;br/&gt;        Name, Body string&lt;br/&gt;    } {&lt;br/&gt;        {&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;, &lt;span&gt;&quot;String contents of file&quot;&lt;/span&gt;},&lt;br/&gt;        {&lt;span&gt;&quot;test2.txt&quot;&lt;/span&gt;, &lt;span&gt;&quot;\x61\x62\x63\n&quot;&lt;/span&gt;},&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 下面将要打包的内容写入到打包文件中，依次写入。&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, file := range filesToArchive {&lt;br/&gt;            fileWriter, err := zipWriter.Create(file.Name)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;                    log.Fatal(err)&lt;br/&gt;            }&lt;br/&gt;            _, err = fileWriter.Write([]byte(file.Body))&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;                    log.Fatal(err)&lt;br/&gt;            }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 清理&lt;br/&gt;    err = zipWriter.Close()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;            log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;抽取(unzip) 文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// This example uses zip but standard library&lt;br/&gt;// also supports tar archives&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;archive/zip&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;path/filepath&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    zipReader, err := zip.OpenReader(&lt;span&gt;&quot;test.zip&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer zipReader.Close()&lt;br/&gt;&lt;br/&gt;    // 遍历打包文件中的每一文件/文件夹&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, file := range zipReader.Reader.File {&lt;br/&gt;        // 打包文件中的文件就像普通的一个文件对象一样&lt;br/&gt;        zippedFile, err := file.Open()&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;            log.Fatal(err)&lt;br/&gt;        }&lt;br/&gt;        defer zippedFile.Close()&lt;br/&gt;&lt;br/&gt;        // 指定抽取的文件名。&lt;br/&gt;        // 你可以指定全路径名或者一个前缀，这样可以把它们放在不同的文件夹中。&lt;br/&gt;        // 我们这个例子使用打包文件中相同的文件名。&lt;br/&gt;        targetDir := &lt;span&gt;&quot;./&quot;&lt;/span&gt;&lt;br/&gt;        extractedFilePath := filepath.Join(&lt;br/&gt;            targetDir,&lt;br/&gt;            file.Name,&lt;br/&gt;        )&lt;br/&gt;&lt;br/&gt;        // 抽取项目或者创建文件夹&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; file.FileInfo().&lt;span&gt;&lt;span&gt;IsDir&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            // 创建文件夹并设置同样的权限&lt;br/&gt;            log.Println(&lt;span&gt;&quot;Creating directory:&quot;&lt;/span&gt;, extractedFilePath)&lt;br/&gt;            os.MkdirAll(extractedFilePath, file.Mode())&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            //抽取正常的文件&lt;br/&gt;            log.Println(&lt;span&gt;&quot;Extracting file:&quot;&lt;/span&gt;, file.Name)&lt;br/&gt;&lt;br/&gt;            outputFile, err := os.OpenFile(&lt;br/&gt;                extractedFilePath,&lt;br/&gt;                os.O_WRONLY|os.O_CREATE|os.O_TRUNC,&lt;br/&gt;                file.Mode(),&lt;br/&gt;            )&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;                log.Fatal(err)&lt;br/&gt;            }&lt;br/&gt;            defer outputFile.Close()&lt;br/&gt;&lt;br/&gt;            // 通过io.Copy简洁地复制文件内容&lt;br/&gt;            _, err = io.Copy(outputFile, zippedFile)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;                log.Fatal(err)&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;压缩文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;compress/gzip&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    outputFile, err := os.Create(&lt;span&gt;&quot;test.txt.gz&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    gzipWriter := gzip.NewWriter(outputFile)&lt;br/&gt;    defer gzipWriter.Close()&lt;br/&gt;&lt;br/&gt;    // 当我们写如到gizp writer数据时，它会依次压缩数据并写入到底层的文件中。&lt;br/&gt;    // 我们不必关心它是如何压缩的，还是像普通的writer一样操作即可。&lt;br/&gt;    _, err = gzipWriter.Write([]byte(&lt;span&gt;&quot;Gophers rule!\n&quot;&lt;/span&gt;))&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    log.Println(&lt;span&gt;&quot;Compressed data written to file.&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解压缩文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;compress/gzip&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 打开一个gzip文件。&lt;br/&gt;    // 文件是一个reader,但是我们可以使用各种数据源，比如web服务器返回的gzipped内容，&lt;br/&gt;    // 它的内容不是一个文件，而是一个内存流&lt;br/&gt;    gzipFile, err := os.Open(&lt;span&gt;&quot;test.txt.gz&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    gzipReader, err := gzip.NewReader(gzipFile)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer gzipReader.Close()&lt;br/&gt;&lt;br/&gt;    // 解压缩到一个writer,它是一个file writer&lt;br/&gt;    outfileWriter, err := os.Create(&lt;span&gt;&quot;unzipped.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer outfileWriter.Close()&lt;br/&gt;&lt;br/&gt;    // 复制内容&lt;br/&gt;    _, err = io.Copy(outfileWriter, gzipReader)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文件其它操作&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;临时文件和目录&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ioutil&lt;/code&gt;提供了两个函数: &lt;code&gt;TempDir()&lt;/code&gt; 和 &lt;code&gt;TempFile()&lt;/code&gt;。使用完毕后，调用者负责删除这些临时文件和文件夹。有一点好处就是当你传递一个空字符串作为文件夹名的时候，它会在操作系统的临时文件夹中创建这些项目（/tmp on Linux）。&lt;code&gt;os.TempDir()&lt;/code&gt;返回当前操作系统的临时文件夹。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;     &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;     // 在系统临时文件夹中创建一个临时文件夹&lt;br/&gt;     tempDirPath, err := ioutil.TempDir(&lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;myTempDir&quot;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;          log.Fatal(err)&lt;br/&gt;     }&lt;br/&gt;     fmt.Println(&lt;span&gt;&quot;Temp dir created:&quot;&lt;/span&gt;, tempDirPath)&lt;br/&gt;&lt;br/&gt;     // 在临时文件夹中创建临时文件&lt;br/&gt;     tempFile, err := ioutil.TempFile(tempDirPath, &lt;span&gt;&quot;myTempFile.txt&quot;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;          log.Fatal(err)&lt;br/&gt;     }&lt;br/&gt;     fmt.Println(&lt;span&gt;&quot;Temp file created:&quot;&lt;/span&gt;, tempFile.Name())&lt;br/&gt;&lt;br/&gt;     // ... 做一些操作 ...&lt;br/&gt;&lt;br/&gt;     // 关闭文件&lt;br/&gt;     err = tempFile.Close()&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 删除我们创建的资源&lt;br/&gt;     err = os.Remove(tempFile.Name())&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;     err = os.Remove(tempDirPath)&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通过HTTP下载文件&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;     &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;     newFile, err := os.Create(&lt;span&gt;&quot;devdungeon.html&quot;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;          log.Fatal(err)&lt;br/&gt;     }&lt;br/&gt;     defer newFile.Close()&lt;br/&gt;&lt;br/&gt;     url := &lt;span&gt;&quot;http://www.devdungeon.com/archive&quot;&lt;/span&gt;&lt;br/&gt;     response, err := http.Get(url)&lt;br/&gt;     defer response.Body.Close()&lt;br/&gt;&lt;br/&gt;     // 将HTTP response Body中的内容写入到文件&lt;br/&gt;     // Body满足reader接口，因此我们可以使用ioutil.Copy&lt;br/&gt;     numBytesWritten, err := io.Copy(newFile, response.Body)&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;          log.Fatal(err)&lt;br/&gt;     }&lt;br/&gt;     log.Printf(&lt;span&gt;&quot;Downloaded %d byte file.\n&quot;&lt;/span&gt;, numBytesWritten)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;哈希和摘要&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;crypto/md5&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;crypto/sha1&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;crypto/sha256&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;crypto/sha512&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // 得到文件内容&lt;br/&gt;    data, err := ioutil.ReadFile(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 计算Hash&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Md5: %x\n\n&quot;&lt;/span&gt;, md5.Sum(data))&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Sha1: %x\n\n&quot;&lt;/span&gt;, sha1.Sum(data))&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Sha256: %x\n\n&quot;&lt;/span&gt;, sha256.Sum256(data))&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Sha512: %x\n\n&quot;&lt;/span&gt;, sha512.Sum512(data))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子复制整个文件内容到内存中，传递给hash函数。另一个方式是创建一个hash writer, 使用&lt;code&gt;Write&lt;/code&gt;、&lt;code&gt;WriteString&lt;/code&gt;、&lt;code&gt;Copy&lt;/code&gt;将数据传给它。下面的例子使用 md5 hash,但你可以使用其它的Writer。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;    &lt;span&gt;&quot;crypto/md5&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    file, err := os.Open(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    defer file.Close()&lt;br/&gt;&lt;br/&gt;    //创建一个新的hasher,满足writer接口&lt;br/&gt;    hasher := md5.New()&lt;br/&gt;    _, err = io.Copy(hasher, file)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 计算&lt;span&gt;hash&lt;/span&gt;并打印结果。&lt;br/&gt;    // 传递 nil 作为参数，因为我们不通参数传递数据，而是通过writer接口。&lt;br/&gt;    sum := hasher.Sum(nil)&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;Md5 checksum: %x\n&quot;&lt;/span&gt;, sum)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注公众号，获取更多精选技术原创文章&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0188679245283019&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4icJbGAQ8RjXUUVdUZsGADuMBVWePgn7tfrWjjHyc6b8kXTQ7Sdkp0QQFFK4mel5tniczqooMna1CA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>