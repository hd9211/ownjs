<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>dc05c13cb0614d6cdcae7b43cb9c5e2c</guid>
<title>文末送福利｜十一长假干嘛呢？快来吧！</title>
<link>https://toutiao.io/k/8pbs9cx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6h6x4EnYInRLic6PibFNWw4zSv28rAxcJu9dumVJF03PwHGOWxOzeJKIsydVa7UJuTo4jOjrct9NZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>922be80cfadaca882f5ffb005c2f570b</guid>
<title>一篇讲透自研的前端错误监控</title>
<link>https://toutiao.io/k/j137z5n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;138771404668583936&quot; data-gallerysupplier=&quot;5&quot; data-ratio=&quot;0.55078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aDoYvepE5x0D8raJJQbVFOicG2HYYXNhUjrdsSfem4qK6ytGaJiakvMmryVKKMyXpeibeOZAHlgCUqRibGQhMcJfBQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;span&gt;一、背景&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;痛点&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;某⼀天产品：xxx⼴告主反馈我们的⻚⾯注册不了！⼜⼀天运营：这个活动在xxx媒体上挂掉了！&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在我司线上运行的是近亿级别的广告页面，这样线上如果裸奔，出现了什么问题不知道，后置在业务端发现，被业务方询问，这种场景很尴尬。&lt;/p&gt;&lt;h2&gt;选择&lt;/h2&gt;&lt;p&gt;公司存在四个事业部，而每个事业部不下于3个项目，这里至少12个项目，这里作为伏笔，业务线多。&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们是选择自己做呢，还是选第三方的呢。我们比较一&lt;/span&gt;下&lt;span&gt;几款常见第三方。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Fundebug：付费版 159元/月起，数据存在第三方，而数据自我保存需要 30 万/年。还是很贵的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FrontJS，FrontJS 高级版 899/月，专业版是 2999/月。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Sentry，80 美金/月。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以Sentry为计费，对这12个项目计算一下。12个项目一年将近10万。而大致估算过需要2人1.5月即90人日，能完成MVP版本，按每人1.5万工资/月计算，总共花费4.5万，而且是一劳永逸的。&lt;/p&gt;&lt;p&gt;因此从成本角度我们会选择自研，但除了成本外，还有其他原因。例如我们会基于这套系统做一些自定义功能，与公司权限用户系统打通，再针对用户进行Todo管理，对用户进行错误排行等。&lt;/p&gt;&lt;p&gt;还有基于业务数据的安全，我们希望自我搭建一个系统。&lt;/p&gt;&lt;p&gt;所以从成本、安全、扩展性角度，我们选择了自己研发。&lt;/p&gt;&lt;h1&gt;二、产品设计&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;我们要什么样的一个产品呢，根据第一性原理，解决关键问题“怎么定位问题”。通过5W1H法我们来分析，我们想要知道些什么信息呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;错误信息&lt;/h2&gt;&lt;p&gt;其实错误监控说简单就一句话可以描述，搜集页面错误，进行上报，然后对症分析。&lt;/p&gt;&lt;p&gt;按照5W1H法则进行分析这句话，可以发现有几项需要我们关注。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;What，发⽣了什么错误：逻辑错误、数据错误、⽹络错误、语法错误等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;When，出现的时间段，如时间戳。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Who，影响了多少用户，包括报错事件数、IP、设备信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Where，出现的页面是哪些，包括页面、广告位（我司）、媒体（我司）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Why，错误的原因是为什么，包括错误堆栈、⾏列、SourceMap。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;How，怎么定位解决问题，我们还需要收集系统等信息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;架构层次&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;首先我们需要梳理下，我们需要一些哪些功能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;那我们怎么得到上面的信息进行最终错误的定位呢。&lt;/p&gt;&lt;p&gt;首先我们肯定需要对错误进行搜集，然后用户设备页面端的错误我们怎么才能感知到呢，这就需要进行上报。那么第一层就展现出来了，我们需要一个搜集上报端。&lt;/p&gt;&lt;p&gt;那怎么才能进行上报呢，和后端协作那么久，肯定知道的吧🙃 ，你需要一个接口。那就需要一个服务器来进行对于上报的错误进行采集，对于错误进行筛选聚合。那么第二层也知道了啊，我们需要一个采集聚合端。&lt;/p&gt;&lt;p&gt;我们搜集到了我们足够的物料信息了，那接下来要怎么用起来呢，我们需要把它们按照我们的规则进行整理。如果每次又是通过写类SQL进行整理查询效率会很低，因此我们需要一个可视化的平台进行展示。因此有了第三层，可视化分析端。&lt;/p&gt;&lt;p&gt;感觉好像做完啦，想必大家都这么想，一个错误监控平台做完了，🙅 。如果是这样你会发现一个现象，每次上线和上线后一段时间，开发同学都一直盯着屏幕看，这是在干嘛，人形眼动观察者模式吗。因此我们需要通过代码去解决，自然而然，第四层，监控告警端应运而生。&lt;/p&gt;&lt;p&gt;所以请大声说出来我们需要什么🙈 ，搜集上报端，采集聚合端，可视分析端，监控告警端。&lt;/p&gt;&lt;h1&gt;三、系统设计&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;如函数一样，定义好每个环节的输入和输出，且核心需要处理的功能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;下面我们看看上述所说的四个端怎么去实现呢。&lt;/p&gt;&lt;h2&gt;搜集上报端（SDK）&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;这个环节主要输入是所有错误，输出是捕获上报错误。核心是处理不同类型错误的搜集工作。其他是一些非核心但必要的工作。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;错误类型&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;先看看我们需要处理哪些错误类型。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;常见JS执行错误&lt;/strong&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SyntaxError&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;解析时发生语法错误&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// 控制台运行&lt;br/&gt;const xx, &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;window.onerror捕获不到SyntxError，一般SyntaxError在构建阶段，甚至本地开发阶段就会被发现。&lt;/p&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;TypeError&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;值不是所期待的类型&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// 控制台运行&lt;br/&gt;const person = void 0&lt;br/&gt;person.name &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ReferenceError&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;引用未声明的变量&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// 控制台运行&lt;br/&gt;nodefined &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RangeError&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;当一个值不在其所允许的范围或者集合中&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;(&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;/span&gt; ( ) { fn() })() &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;网络错误&lt;/strong&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ResourceError&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;资源加载错误&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;new Image().src = &lt;span&gt;&#x27;/remote/image/notdeinfed.png&#x27;&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HttpError&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;Http请求错误&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// 控制台运行&lt;br/&gt;fetch(&lt;span&gt;&#x27;/remote/notdefined&#x27;&lt;/span&gt;, {}) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;搜集错误&lt;/h3&gt;&lt;p&gt;所有起因来源于错误，那我们如何进行错误捕获。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;try/catch&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;能捕获常规运行时错误，语法错误和异步错误不行&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// 常规运行时错误，可以捕获 ✅&lt;br/&gt;try {&lt;br/&gt;  console.log(notdefined);&lt;br/&gt;} catch(e) {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;, e);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 语法错误，不能捕获 ❌&lt;br/&gt;try {&lt;br/&gt;  const notdefined,&lt;br/&gt;} catch(e) {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;, e);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 异步错误，不能捕获 ❌&lt;br/&gt;try {&lt;br/&gt;  setTimeout(() =&amp;gt; {&lt;br/&gt;    console.log(notdefined);&lt;br/&gt;  }, 0)&lt;br/&gt;} catch(e) {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;,e);&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;try/catch有它细致处理的优势，但缺点也比较明显。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;window.onerror&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;pure js错误收集，window.onerror，当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;/**&lt;br/&gt;* @param {String} message    错误信息&lt;br/&gt;* @param {String} &lt;span&gt;source&lt;/span&gt;    出错文件&lt;br/&gt;* @param {Number} lineno    行号&lt;br/&gt;* @param {Number} colno    列号&lt;br/&gt;* @param {Object} error  Error对象&lt;br/&gt;*/&lt;br/&gt;&lt;br/&gt;window.onerror = &lt;span&gt;function&lt;/span&gt;(message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error) {&lt;br/&gt;   console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;, {message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error});&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先验证下几个错误是否可以捕获。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 常规运行时错误，可以捕获 ✅&lt;br/&gt;&lt;br/&gt;window.onerror = &lt;span&gt;function&lt;/span&gt;(message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error) {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;,{message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error});&lt;br/&gt;}&lt;br/&gt;console.log(notdefined);&lt;br/&gt;&lt;br/&gt;// 语法错误，不能捕获 ❌&lt;br/&gt;window.onerror = &lt;span&gt;function&lt;/span&gt;(message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error) {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;,{message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error});&lt;br/&gt;}&lt;br/&gt;const notdefined,&lt;br/&gt;      &lt;br/&gt;// 异步错误，可以捕获 ✅&lt;br/&gt;window.onerror = &lt;span&gt;function&lt;/span&gt;(message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error) {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;,{message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error});&lt;br/&gt;}&lt;br/&gt;setTimeout(() =&amp;gt; {&lt;br/&gt;  console.log(notdefined);&lt;br/&gt;}, 0)&lt;br/&gt;&lt;br/&gt;// 资源错误，不能捕获 ❌&lt;br/&gt;&amp;lt;script&amp;gt;&lt;br/&gt;  window.onerror = &lt;span&gt;function&lt;/span&gt;(message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error) {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;,{message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error});&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;img src=&lt;span&gt;&quot;https://yun.tuia.cn/image/kkk.png&quot;&lt;/span&gt;&amp;gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;window.onerror 不能捕获资源错误怎么办？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;window.addEventListener&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，这些 error 事件不会向上冒泡到 window，但能被捕获。而window.onerror不能监测捕获。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// 图片、script、css加载错误，都能被捕获 ✅&lt;br/&gt;&amp;lt;script&amp;gt; window.addEventListener(&lt;span&gt;&#x27;error&#x27;&lt;/span&gt;, (error) =&amp;gt; {&lt;br/&gt;   console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;, error);&lt;br/&gt; }, &lt;span&gt;true&lt;/span&gt;) &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;img src=&lt;span&gt;&quot;https://yun.tuia.cn/image/kkk.png&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;script src=&lt;span&gt;&quot;https://yun.tuia.cn/foundnull.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;link href=&lt;span&gt;&quot;https://yun.tuia.cn/foundnull.css&quot;&lt;/span&gt; rel=&lt;span&gt;&quot;stylesheet&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;  &lt;br/&gt;// new Image错误，不能捕获 ❌&lt;br/&gt;&amp;lt;script&amp;gt; window.addEventListener(&lt;span&gt;&#x27;error&#x27;&lt;/span&gt;, (error) =&amp;gt; {&lt;br/&gt;    console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;, error);&lt;br/&gt;  }, &lt;span&gt;true&lt;/span&gt;) &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;script&amp;gt; new Image().src = &lt;span&gt;&#x27;https://yun.tuia.cn/image/lll.png&#x27;&lt;/span&gt; &amp;lt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;// fetch错误，不能捕获 ❌&lt;br/&gt;&amp;lt;script&amp;gt; window.addEventListener(&lt;span&gt;&#x27;error&#x27;&lt;/span&gt;, (error) =&amp;gt; {&lt;br/&gt;    console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;, error);&lt;br/&gt;  }, &lt;span&gt;true&lt;/span&gt;) &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;script&amp;gt; fetch(&lt;span&gt;&#x27;https://tuia.cn/test&#x27;&lt;/span&gt;) &amp;lt;/script&amp;gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;new Image运用的比较少，可以单独自己处理自己的错误。&lt;/p&gt;&lt;p&gt;但通用的fetch怎么办呢，fetch返回Promise，但Promise的错误不能被捕获，怎么办呢？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Promise错误&lt;/strong&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;普通Promise错误&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;try/catch不能捕获Promise中的错误&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// try/catch 不能处理 JSON.parse 的错误，因为它在 Promise 中&lt;br/&gt;try {&lt;br/&gt;  new Promise((resolve,reject) =&amp;gt; { &lt;br/&gt;    JSON.parse(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;)&lt;br/&gt;    resolve();&lt;br/&gt;  })&lt;br/&gt;} catch(err) {&lt;br/&gt;  console.error(&lt;span&gt;&#x27;in try catch&#x27;&lt;/span&gt;, err)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 需要使用catch方法&lt;br/&gt;new Promise((resolve,reject) =&amp;gt; { &lt;br/&gt;  JSON.parse(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;)&lt;br/&gt;  resolve();&lt;br/&gt;}).catch(err =&amp;gt; {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;in catch fn&#x27;&lt;/span&gt;, err)&lt;br/&gt;}) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;async错误&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;try/catch不能捕获async包裹的错误&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;const getJSON = async () =&amp;gt; {&lt;br/&gt;  throw new Error(&lt;span&gt;&#x27;inner error&#x27;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 通过try/catch处理&lt;br/&gt;const makeRequest = async () =&amp;gt; {&lt;br/&gt;    try {&lt;br/&gt;        // 捕获不到&lt;br/&gt;        JSON.parse(getJSON());&lt;br/&gt;    } catch (err) {&lt;br/&gt;        console.log(&lt;span&gt;&#x27;outer&#x27;&lt;/span&gt;, err);&lt;br/&gt;    }&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;try {&lt;br/&gt;    // try/catch不到&lt;br/&gt;    makeRequest()&lt;br/&gt;} catch(err) {&lt;br/&gt;    console.error(&lt;span&gt;&#x27;in try catch&#x27;&lt;/span&gt;, err)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;try {&lt;br/&gt;    // 需要await，才能捕获到&lt;br/&gt;    await makeRequest()&lt;br/&gt;} catch(err) {&lt;br/&gt;    console.error(&lt;span&gt;&#x27;in try catch&#x27;&lt;/span&gt;, err)&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;import chunk错误&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;import其实返回的也是一个promise，因此使用如下两种方式捕获错误&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// Promise catch方法&lt;br/&gt;import(/* webpackChunkName: &lt;span&gt;&quot;incentive&quot;&lt;/span&gt; */&lt;span&gt;&#x27;./index&#x27;&lt;/span&gt;).&lt;span&gt;then&lt;/span&gt;(module =&amp;gt; {&lt;br/&gt;    module.default()&lt;br/&gt;}).catch((err) =&amp;gt; {&lt;br/&gt;    console.error(&lt;span&gt;&#x27;in catch fn&#x27;&lt;/span&gt;, err)&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;// await 方法，try catch&lt;br/&gt;try {&lt;br/&gt;    const module = await import(/* webpackChunkName: &lt;span&gt;&quot;incentive&quot;&lt;/span&gt; */&lt;span&gt;&#x27;./index&#x27;&lt;/span&gt;);&lt;br/&gt;    module.default()&lt;br/&gt;} catch(err) {&lt;br/&gt;    console.error(&lt;span&gt;&#x27;in try catch&#x27;&lt;/span&gt;, err)&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;小结：全局捕获Promise中的错误&lt;/p&gt;&lt;p&gt;以上三种其实归结为Promise类型错误，可以通过unhandledrejection捕获&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 全局统一处理Promise&lt;br/&gt;window.addEventListener(&lt;span&gt;&quot;unhandledrejection&quot;&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;(e){&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;, e);&lt;br/&gt;});&lt;br/&gt;fetch(&lt;span&gt;&#x27;https://tuia.cn/test&#x27;&lt;/span&gt;) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了防止有漏掉的 Promise 异常，可通过unhandledrejection用来全局监听Uncaught Promise Error。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Vue错误&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;由于Vue会捕获所有Vue单文件组件或者Vue.extend继承的代码，所以在Vue里面出现的错误，并不会直接被window.onerror捕获，而是会抛给Vue.config.errorHandler。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;/**&lt;br/&gt; * 全局捕获Vue错误，直接扔出给onerror处理&lt;br/&gt; */&lt;br/&gt;Vue.config.errorHandler = &lt;span&gt;function&lt;/span&gt; (err) {&lt;br/&gt;  setTimeout(() =&amp;gt; {&lt;br/&gt;    throw err&lt;br/&gt;  })&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;React错误&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;react 通过componentDidCatch，声明一个错误边界的组件&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;class ErrorBoundary extends React.Component {&lt;br/&gt;  constructor(props) {&lt;br/&gt;    super(props);&lt;br/&gt;    this.state = { hasError: &lt;span&gt;false&lt;/span&gt; };&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  static getDerivedStateFromError(error) {&lt;br/&gt;    // 更新 state 使下一次渲染能够显示降级后的 UI&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; { hasError: &lt;span&gt;true&lt;/span&gt; };&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  componentDidCatch(error, errorInfo) {&lt;br/&gt;    // 你同样可以将错误日志上报给服务器&lt;br/&gt;    logErrorToMyService(error, errorInfo);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;render&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (this.state.hasError) {&lt;br/&gt;      // 你可以自定义降级后的 UI 并渲染&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &amp;lt;h1&amp;gt;Something went wrong.&amp;lt;/h1&amp;gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; this.props.children; &lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;class App extends React.Component {&lt;br/&gt;   &lt;br/&gt;  &lt;span&gt;&lt;span&gt;render&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;ErrorBoundary&amp;gt;&lt;br/&gt;      &amp;lt;MyWidget /&amp;gt;&lt;br/&gt;    &amp;lt;/ErrorBoundary&amp;gt;  &lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但error boundaries并不会捕捉以下错误：React事件处理，异步代码，error boundaries自己抛出的错误。&lt;/p&gt;&lt;h3&gt;跨域问题&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;如果当前投放页面和云端JS所在不同域名，如果云端JS出现错误，window.onerror会出现Script Error。通过以下两种方法能给予解决。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;后端配置Access-Control-Allow-Origin、前端script加crossorigin。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&lt;span&gt;&quot;http://yun.tuia.cn/test.js&quot;&lt;/span&gt; crossorigin&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;const script = document.createElement(&lt;span&gt;&#x27;script&#x27;&lt;/span&gt;);&lt;br/&gt;script.crossOrigin = &lt;span&gt;&#x27;anonymous&#x27;&lt;/span&gt;;&lt;br/&gt;script.src = &lt;span&gt;&#x27;http://yun.tuia.cn/test.js&#x27;&lt;/span&gt;;&lt;br/&gt;document.body.appendChild(script); &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果不能修改服务端的请求头，可以考虑通过使用 try/catch 绕过，将错误抛出。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;&lt;br/&gt;&amp;lt;html&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;  &amp;lt;title&amp;gt;Test page &lt;span&gt;in&lt;/span&gt; http://test.com&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;  &amp;lt;script src=&lt;span&gt;&quot;https://yun.dui88.com/tuia/cdn/remote/testerror.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;  &amp;lt;script&amp;gt; window.onerror = &lt;span&gt;function&lt;/span&gt; (message, url, line, column, error) {&lt;br/&gt;    console.log(message, url, line, column, error);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  try {&lt;br/&gt;    foo(); // 调用testerror.js中定义的foo方法&lt;br/&gt;  } catch (e) {&lt;br/&gt;    throw e;&lt;br/&gt;  } &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会发现如果不加try catch，console.log就会打印script error。加上try catch就能捕获到。&lt;/p&gt;&lt;p&gt;我们捋一下场景，一般调用远端js，有下列三种常见情况。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用远端JS的方法出错&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;远端JS内部的事件出问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;要么在setTimeout等回调内出错&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;调用方法场景&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;可以通过封装一个函数，能装饰原方法，使得其能被try/catch。&lt;/p&gt;&lt;pre&gt;&lt;code&gt; &amp;lt;!doctype html&amp;gt;&lt;br/&gt;&amp;lt;html&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;  &amp;lt;title&amp;gt;Test page &lt;span&gt;in&lt;/span&gt; http://test.com&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;  &amp;lt;script src=&lt;span&gt;&quot;https://yun.dui88.com/tuia/cdn/remote/testerror.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;  &amp;lt;script&amp;gt; window.onerror = &lt;span&gt;function&lt;/span&gt; (message, url, line, column, error) {&lt;br/&gt;    console.log(message, url, line, column, error);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;function&lt;/span&gt; wrapErrors(fn) {&lt;br/&gt;    // don&lt;span&gt;&#x27;t wrap function more than once&lt;br/&gt;    if (!fn.__wrapped__) {&lt;br/&gt;      fn.__wrapped__ = function () {&lt;br/&gt;        try {&lt;br/&gt;          return fn.apply(this, arguments);&lt;br/&gt;        } catch (e) {&lt;br/&gt;          throw e; // re-throw the error&lt;br/&gt;        }&lt;br/&gt;      };&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    return fn.__wrapped__;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  wrapErrors(foo)() &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;大家可以尝试去掉wrapErrors感受下。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;事件场景&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;可以劫持原生方法。&lt;/p&gt;&lt;pre&gt;&lt;code&gt; &amp;lt;!doctype html&amp;gt;&lt;br/&gt;&amp;lt;html&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;  &amp;lt;title&amp;gt;Test page &lt;span&gt;in&lt;/span&gt; http://test.com&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;  &amp;lt;script&amp;gt; const originAddEventListener = EventTarget.prototype.addEventListener;&lt;br/&gt;    EventTarget.prototype.addEventListener = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;type&lt;/span&gt;, listener, options) {&lt;br/&gt;      const wrappedListener = &lt;span&gt;function&lt;/span&gt; (...args) {&lt;br/&gt;        try {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; listener.apply(this, args);&lt;br/&gt;        }&lt;br/&gt;        catch (err) {&lt;br/&gt;          throw err;&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; originAddEventListener.call(this, &lt;span&gt;type&lt;/span&gt;, wrappedListener, options);&lt;br/&gt;    } &amp;lt;/script&amp;gt;&lt;br/&gt;  &amp;lt;div style=&lt;span&gt;&quot;height: 9999px;&quot;&lt;/span&gt;&amp;gt;http://test.com&amp;lt;/div&amp;gt;&lt;br/&gt;  &amp;lt;script src=&lt;span&gt;&quot;https://yun.dui88.com/tuia/cdn/remote/error_scroll.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;  &amp;lt;script&amp;gt; window.onerror = &lt;span&gt;function&lt;/span&gt; (message, url, line, column, error) {&lt;br/&gt;    console.log(message, url, line, column, error);&lt;br/&gt;  } &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;大家可以尝试去掉封装EventTarget.prototype.addEventListener的那段代码，感受下。&lt;/p&gt;&lt;h3&gt;上报接口&lt;/h3&gt;&lt;p&gt;为什么不能直接用GET/POST/HEAD请求接口进行上报？&lt;/p&gt;&lt;p&gt;这个比较容易想到原因。一般而言，打点域名都不是当前域名，所以所有的接口请求都会构成跨域。&lt;/p&gt;&lt;p&gt;为什么不能用请求其他的文件资源（js/css/ttf）的方式进行上报？&lt;/p&gt;&lt;p&gt;创建资源节点后只有将对象注入到浏览器DOM树后，浏览器才会实际发送资源请求。而且载入js/css资源还会阻塞页面渲染，影响用户体验。&lt;/p&gt;&lt;p&gt;构造图片打点不仅不用插入DOM，只要在js中new出Image对象就能发起请求，而且还没有阻塞问题，在没有js的浏览器环境中也能通过img标签正常打点。&lt;/p&gt;&lt;p&gt;使用new Image进行接口上报。最后一个问题，同样都是图片，上报时选用了1x1的透明GIF，而不是其他的PNG/JEPG/BMP文件。&lt;/p&gt;&lt;p&gt;首先，1x1像素是最小的合法图片。而且，因为是通过图片打点，所以图片最好是透明的，这样一来不会影响页面本身展示效果，二者表示图片透明只要使用一个二进制位标记图片是透明色即可，不用存储色彩空间数据，可以节约体积。因为需要透明色，所以可以直接排除JEPG。&lt;/p&gt;&lt;p&gt;同样的响应，GIF可以比BMP节约41%的流量，比PNG节约35%的流量。GIF才是最佳选择。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以进行跨域&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不会携带cookie&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不需要等待服务器返回数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;使用1\*1的gif&lt;/span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;非阻塞加载&lt;/h3&gt;&lt;p&gt;尽量避免SDK的js资源加载影响。&lt;/p&gt;&lt;p&gt;通过先把window.onerror的错误记录进行缓存，然后异步进行SDK的加载，再在SDK里面处理错误上报。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html lang=&lt;span&gt;&quot;en&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;    &amp;lt;script&amp;gt; (&lt;span&gt;function&lt;/span&gt;(w) {&lt;br/&gt;            w._error_storage_ = [];&lt;br/&gt;            &lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;errorhandler&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;                // 用于记录当前的错误 &lt;br/&gt;                w._error_storage_&amp;amp;&amp;amp;w._error_storage_.push([].slice.call(arguments));&lt;br/&gt;            } &lt;br/&gt;            w.addEventListener &amp;amp;&amp;amp; w.addEventListener(&lt;span&gt;&quot;error&quot;&lt;/span&gt;, errorhandler, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;            var &lt;span&gt;times&lt;/span&gt; = 3,&lt;br/&gt;            appendScript = &lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;appendScript&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                var sc = document.createElement(&lt;span&gt;&quot;script&quot;&lt;/span&gt;);&lt;br/&gt;                sc.async = !0,&lt;br/&gt;                sc.src = &lt;span&gt;&#x27;./build/skyeye.js&#x27;&lt;/span&gt;,  // 取决于你存放的位置&lt;br/&gt;                sc.crossOrigin = &lt;span&gt;&quot;anonymous&quot;&lt;/span&gt;,&lt;br/&gt;                sc.onerror = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                    &lt;span&gt;times&lt;/span&gt;--,&lt;br/&gt;                    &lt;span&gt;times&lt;/span&gt; &amp;gt; 0 &amp;amp;&amp;amp; setTimeout(appendScript, 1500)&lt;br/&gt;                },&lt;br/&gt;                document.head &amp;amp;&amp;amp; document.head.appendChild(sc);&lt;br/&gt;            };&lt;br/&gt;            setTimeout(appendScript, 1500);&lt;br/&gt;        })(window); &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;    &amp;lt;h1&amp;gt;这是一个测试页面(new)&amp;lt;/h1&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;采集聚合端（日志服务器）&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;这个环节，输入是接口接收到的错误记录，输出是有效的数据入库。核心功能需要对数据进行清洗，顺带解决了过多的服务压力。另一个核心功能是对数据进行入库。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;总体流程可以看为错误标识 -&amp;gt; 错误过滤 -&amp;gt; 错误接收 -&amp;gt; 错误存储。&lt;/p&gt;&lt;h3&gt;错误标识（SDK配合）&lt;/h3&gt;&lt;p&gt;聚合之前，我们需要有不同维度标识错误的能力，可以理解为定位单个错误条目，单个错误事件的能力。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;单个错误条目&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;通过date和随机值生成一条对应的错误条目id。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;const errorKey = `&lt;span&gt;${+new Date()}&lt;/span&gt;@&lt;span&gt;${randomString(8)}&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; randomString(len) {  &lt;br/&gt;    len = len || 32;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; chars = &lt;span&gt;&#x27;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&#x27;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; maxPos = chars.length;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; &lt;span&gt;pwd&lt;/span&gt; = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;  &lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = 0; i &amp;lt; len; i++) {    &lt;br/&gt;        &lt;span&gt;pwd&lt;/span&gt; += chars.charAt(Math.floor(Math.random() * maxPos));  &lt;br/&gt;    }  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;pwd&lt;/span&gt;;&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;单个错误事件&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;首先需要有定位同个错误事件（不同用户，发生相同错误类型、错误信息）的能力。&lt;/p&gt;&lt;p&gt;通过message、colno与lineno进行相加计算阿斯克码值，可以生成错误的errorKey。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;const eventKey = compressString(String(e.message), String(e.colno) + String(e.lineno))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; compressString(str, key) {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; chars = &lt;span&gt;&#x27;ABCDEFGHJKMNPQRSTWXYZ&#x27;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!str || !key) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;null&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; n = 0,&lt;br/&gt;        m = 0;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = 0; i &amp;lt; str.length; i++) {&lt;br/&gt;        n += str[i].charCodeAt();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = 0; j &amp;lt; key.length; j++) {&lt;br/&gt;        m += key[j].charCodeAt();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; num = n + &lt;span&gt;&#x27;&#x27;&lt;/span&gt; + key[key.length - 1].charCodeAt() + m + str[str.length - 1].charCodeAt();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(num) {&lt;br/&gt;        num = num + chars[num[num.length - 1]];&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; num;&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如下图，一个错误事件（事件列表），下属每条即为实际的错误条目。&lt;img data-ratio=&quot;0.5581146223888591&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewG2psnYt8uD6PcvpGSicOWZEs02DRT85KuMcOMXg02jvVD2vh9oiccKK2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1867&quot;/&gt;&lt;/p&gt;&lt;h3&gt;错误过滤（SDK配合）&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;域名过滤&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;过滤本页面script error，可能被webview插入其他js。 &lt;/p&gt;&lt;p&gt;我们只关心自己的远端JS问题，因此做了根据本公司域名进行过滤。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 伪代码&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(!e.filename || !e.filename.match(/^(http|https):\/\/yun./)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;重复上报&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;怎么避免重复的数据上报？根据errorKey来进行缓存，重复的错误避免上报的次数超过阈值。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 伪代码&lt;br/&gt;&lt;br/&gt;const localStorage = window.localStorage;&lt;br/&gt;const TIMES = 6; // 缓存条数&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; setItem(key, repeat) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!key) {&lt;br/&gt;        key = &lt;span&gt;&#x27;unknow&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (has(key)) {&lt;br/&gt;        const value = getItem(key);&lt;br/&gt;        &lt;br/&gt;       // 核心代码，超过条数，跳出&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (value &amp;gt;= repeat) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        storeStorage[key] = {&lt;br/&gt;            value: value + 1,&lt;br/&gt;            time: Date.now()&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        storeStorage[key] = {&lt;br/&gt;            value: 1,&lt;br/&gt;            time: Date.now()&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;错误接收&lt;/h3&gt;&lt;p&gt;在处理接收接口的时候，注意流量的控制，这也是后端开发需要投入最多精力的地方，处理高并发的流量。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;错误记录&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;接收端使用Koa，简单的实现了接收及打印到磁盘。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 伪代码&lt;br/&gt;&lt;br/&gt;module.exports = async ctx =&amp;gt; {&lt;br/&gt;  const { query } = ctx.request;&lt;br/&gt;  &lt;br/&gt;  // 对于字段进行简单check &lt;br/&gt;  check([ &lt;span&gt;&#x27;mobile&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;network&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;ip&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;system&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;ua&#x27;&lt;/span&gt;, ......], query);&lt;br/&gt;&lt;br/&gt;  ctx.type = &lt;span&gt;&#x27;application/json&#x27;&lt;/span&gt;;&lt;br/&gt;  ctx.body = { code: &lt;span&gt;&#x27;1&#x27;&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据上报成功&#x27;&lt;/span&gt; };&lt;br/&gt;&lt;br/&gt;  // 进行日志记录到磁盘的代码，根据自己的日志库选择&lt;br/&gt;}; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;削峰机制&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;比如每秒设置2000的阈值，然后根据请求量减少上限，定时重置上限。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 伪代码&lt;br/&gt;&lt;br/&gt;// 1000ms&lt;br/&gt;const TICK = 1000;&lt;br/&gt;// 1秒上限为2000&lt;br/&gt;const MAX_LIMIT = 2000;&lt;br/&gt;// 每台服务器请求上限值&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; maxLimit = MAX_LIMIT;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * 启动重置函数&lt;br/&gt; */&lt;br/&gt;const task = () =&amp;gt; {&lt;br/&gt;  setTimeout(() =&amp;gt; {&lt;br/&gt;    maxLimit = MAX_LIMIT;&lt;br/&gt;    task();&lt;br/&gt;  }, TICK);&lt;br/&gt;};&lt;br/&gt;task();&lt;br/&gt;&lt;br/&gt;const check = () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (maxLimit &amp;lt;= 0) {&lt;br/&gt;    throw new Error(&lt;span&gt;&#x27;超过上报次数&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  maxLimit--;&lt;br/&gt;  // 执行业务代码。。。&lt;br/&gt;}; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;采样处理&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;超过阈值，还可以进行采样收集。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 只采集 20%&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(Math.random() &amp;lt; 0.2) {&lt;br/&gt;  collect(data)      // 记录错误信息&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;错误存储&lt;/h3&gt;&lt;p&gt;对于打印在了磁盘的日志，我们怎么样才能对于其进行聚合呢，这里得考虑使用存储方案。&lt;/p&gt;&lt;p&gt;一般选择了存储方案后，设置好配置，存储方案就可以通过磁盘定时周期性的获取数据。因此我们需要选择一款存储方案。&lt;/p&gt;&lt;p&gt;对于存储方案，我们对比了日常常见方案，阿里云日志服务 - Log Service（SLS）、ELK（Elastic、Logstash、Kibana）、Hadoop/Hive（将数据存储在 Hadoop，利用 Hive 进行查询） 类方案的对比。&lt;/p&gt;&lt;p&gt;从以下方面进行了对比，最终选择了Log Service，主要考虑为无需搭建，成本低，查询功能满足。&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;功能项&lt;/th&gt;&lt;th&gt;ELK 类系统&lt;/th&gt;&lt;th&gt;Hadoop + Hive&lt;/th&gt;&lt;th&gt;日志服务&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;日志延时&lt;/td&gt;&lt;td&gt;1~60 秒&lt;/td&gt;&lt;td&gt;几分钟~数小时&lt;/td&gt;&lt;td&gt;实时&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;查询延时&lt;/td&gt;&lt;td&gt;小于 1 秒&lt;/td&gt;&lt;td&gt;分钟级&lt;/td&gt;&lt;td&gt;小于 1 秒&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;查询能力&lt;/td&gt;&lt;td&gt;好&lt;/td&gt;&lt;td&gt;好&lt;/td&gt;&lt;td&gt;好&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;扩展性&lt;/td&gt;&lt;td&gt;提前预备机器&lt;/td&gt;&lt;td&gt;提前预备机器&lt;/td&gt;&lt;td&gt;秒级 10 倍扩容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;成本&lt;/td&gt;&lt;td&gt;较高&lt;/td&gt;&lt;td&gt;较低&lt;/td&gt;&lt;td&gt;很低&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;日志延时：日志产生后，多久可查询。查询延时：单位时间扫描数据量。查询能力：关键词查询、条件组合查询、模糊查询、数值比较、上下文查询。扩展性：快速应对百倍流量上涨。成本：每 GB 费用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;具体API使用，可查看&lt;span&gt;日志服务&lt;/span&gt;&lt;span&gt;[2]&lt;/span&gt;。&lt;/p&gt;&lt;h2&gt;可视分析端（可视化平台）&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;这个环节，输入是接口接收到的错误记录，输出是有效的数据入库。核心功能需要对数据进行清洗，顺带解决了过多的服务压力。另一个核心功能是对数据进行入库。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;主功能&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;这部分主要是产品功能的合理设计，做到小而美，具体的怎么聚合，参考阿里云SLS就可以。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首页图表，可选1天、4小时、1小时等等，聚合错误数，根据1天切分24份来聚合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;首页列表，聚合选中时间内的数据，展示错误文件、错误key、事件数、错误类型、时间、错误信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;错误详情，事件列表、基本信息、设备信息、设备占比图表（见上面事件列表的图）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.563731170336037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewGspIzwO4Yt0ekS7Dm6yNnibnzzZqesEN9KianBjofjPvzicAUVwPKj33Sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1726&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;排行榜&lt;/h3&gt;&lt;p&gt;刚开始做了待处理错误列表、我的错误列表、已解决列表，错误与人没有绑定关系，过于依赖人为主动，需要每个人主动到平台上处理，效果不佳。&lt;/p&gt;&lt;p&gt;后面通过错误作者排行榜，通过钉钉日报来提醒对应人员处理。紧急错误，通过实时告警来责任到人，后面告警会说。&lt;/p&gt;&lt;p&gt;具体原理：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;webpack打包通过git命令把作者和作者邮箱、时间打包在头部。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在可视化服务中，去请求对应的报错url匹配到对应作者，返回给展示端。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5437710437710438&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewGKSUT8vR4ZicjoAAZpIibWN1U2dsvlMsg2w56OqicyOiauv34r3EESf274Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1782&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;SourceMap&lt;/h3&gt;&lt;p&gt;利用webpack的hidden-source-map构建。与 source-map 相比少了末尾的注释，但 output 目录下的 index.js.map 没有少。线上环境避免source-map泄露。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;webpackJsonp([1],[&lt;br/&gt;  &lt;span&gt;function&lt;/span&gt;(e,t,i){...},&lt;br/&gt;  &lt;span&gt;function&lt;/span&gt;(e,t,i){...},&lt;br/&gt;  &lt;span&gt;function&lt;/span&gt;(e,t,i){...},&lt;br/&gt;  &lt;span&gt;function&lt;/span&gt;(e,t,i){...},&lt;br/&gt;  ...&lt;br/&gt;])&lt;br/&gt;// 这里没有生成&lt;span&gt;source&lt;/span&gt;-map的链接地址 &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据报错文件的url，根据团队内部约定好的目录和规则，定位之前打包上传的sourceMap地址。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;const sourcemapUrl = (&lt;span&gt;&#x27;xxxfolder/&#x27;&lt;/span&gt; + url + &lt;span&gt;&#x27;xxxHash&#x27;&lt;/span&gt; +&lt;span&gt;&#x27;.map&#x27;&lt;/span&gt;) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;获取上报的line、column、source，利用第三方库sourceMap进行定位。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;const sourceMap = require(&lt;span&gt;&#x27;source-map&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;// 根据行数获取源文件行数&lt;br/&gt;const getPosition = async(map, rolno, colno) =&amp;gt; {&lt;br/&gt;  const consumer = await new sourceMap.SourceMapConsumer(map)&lt;br/&gt;&lt;br/&gt;  const position = consumer.originalPositionFor({&lt;br/&gt;    line: rolno,&lt;br/&gt;    column: colno&lt;br/&gt;  })&lt;br/&gt;&lt;br/&gt;  position.content = consumer.sourceContentFor(position.source)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; position&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7139588100686499&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewGtV0zpl7qJ1gr84NzzSlfiazASx3ialltRd9v3cVAHrq26GZgQwWQ5P9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;874&quot;/&gt;感兴趣SourceMap原理的，可以继续深入，&lt;span&gt;SourceMap 与前端异常监控&lt;/span&gt;&lt;span&gt;[3]&lt;/span&gt;。&lt;/p&gt;&lt;h2&gt;错误报警&lt;/h2&gt;&lt;h3&gt;报警设置&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每条业务线设置自己的阈值、错误时间跨度，报警轮询间隔&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过钉钉hook报警到对应的群&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过日报形式报出错误作者排行榜&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8761904761904762&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewGWY7fJVmdwk2YicIO4ZbK4xzpicSbuywLeSacianoYbQCSbALjRxa1V0dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1680&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1&gt;四、扩展&lt;/h1&gt;&lt;h2&gt;行为搜集&lt;/h2&gt;&lt;p&gt;通过搜集用户的操作，可以明显发现错误为什么产生。&lt;img data-ratio=&quot;0.43997485857950974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewGakav3qsnpfbh12mBwdk2WT71VYjXQoe8TvkDLkekV0pkN1lFlUTJMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3182&quot;/&gt;&lt;/p&gt;&lt;h3&gt;分类&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;UI行为：点击、滚动、聚焦/失焦、长按&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;浏览器行为：请求、前进/后退、跳转、新开页面、关闭&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;控制台行为：log、warn、error&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;搜集方式&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;点击行为&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;使用addEventListener监听全局上的click事件，将事件和DOM元素名字收集。与错误信息一起上报。&lt;/p&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;发送请求&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;监听XMLHttpRequest的onreadystatechange回调函数&lt;/p&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;页面跳转&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;监听window.onpopstate，页面进行跳转时会触发。&lt;/p&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;控制台行为&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;重写console对象的info等方法。&lt;/p&gt;&lt;p&gt;有兴趣可以参考&lt;span&gt;行为监控&lt;/span&gt;&lt;span&gt;[4]&lt;/span&gt;。&lt;/p&gt;&lt;h2&gt;遇到的问题&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;由于涉及到一些隐私，下述会做脱敏处理。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;空日志问题&lt;/h3&gt;&lt;p&gt;上线灰度运行后，我们发现SLS日志存在一些空日志😢 ，🦢，这是发生了啥？&lt;/p&gt;&lt;p&gt;首先我们回忆下这个链路上有哪些环节可能存在问题。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.1370757180156658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewGrXMjXjXFrKCib0ibGFb2ibyss2A6icFVnrAOHianEmuovYt2flBC9WNpFvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;766&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;排查链路，SLS采集环节之前有磁盘日志收集，服务端接收，SDK上报，那我们依次排查。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3598183881952327&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewGfQSuT12cJ8GdBiaPqGq7WgGeCMjZR3UHkd6pPBmAyVNibTDFpoxqjWgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1762&quot;/&gt;往前一步，发现磁盘日志就已经存在空日志，那剩下就得看一下接收端、SDK端。&lt;/p&gt;&lt;p&gt;开始利用控制变量法，先在SDK端进行空判断，防止空日志上报。结果：发现无效😅。&lt;/p&gt;&lt;p&gt;再继续对Node接收端处理，对接收到的数据进行判空，如果为空不进行日志打印，结果：依然无效😳。&lt;/p&gt;&lt;p&gt;所以开始定位是不是日志打印本身出了什么问题？研究了下日志第三方日志库的API，进行了各种尝试，发现依旧没用，我脸黑了🌚。&lt;/p&gt;&lt;p&gt;什么情况，“遇事不决”看源码。排查下日志库源码存在什么问题。对于源码的主调用流程走了一遍，并没有发现什么问题，一头雾水🙃。&lt;/p&gt;&lt;p&gt;整个代码逻辑很正常，这让我们开始怀疑难道是数据的问题，于是开始缩减上报的字段，最终定义为了一个字段。发现上线后没有问题了😢。&lt;/p&gt;&lt;p&gt;难道是有些字段存储的数据过长导致的？但从代码逻辑、流程日志中并没有反应这个错误的可能性。&lt;/p&gt;&lt;p&gt;因此我们利用二分法，二分地增加字段，最终定位到了某个字段。如果存在某个字段上报就会出现问题。这很出乎人的意料。&lt;/p&gt;&lt;p&gt;我们再想了下链路，除了日志库，其他代码基本都是我们自己的逻辑，所以对日志库进行了排查，怀疑其对某个字段做了什么处理。&lt;/p&gt;&lt;p&gt;于是通过搜索，定位到了日志库在仆从模式（可以了解下Node的主从模式）下会使用某个字段来表意，导致和我们上报的字段冲突，因此丢失了🤪。&lt;/p&gt;&lt;h3&gt;日志丢失问题&lt;/h3&gt;&lt;p&gt;解决了上个问题，开心了，一股成就感涌上心头。但马上就被当头一棒，我发现我高兴的太早了🤮。&lt;/p&gt;&lt;p&gt;团队的某同学在本地测试的时候，由于玩的很开心，一直去刷新页面去上报当前页面的错误。但他发现本地上报的条数和实际日志服务里的条数对不上，日志服务里的少了很多。&lt;/p&gt;&lt;p&gt;由于之前自身刚毕业时候做过2年多后端开发，对于IO操作丢失数据还是有点敏感。直觉上就感觉可能是多进程方向的问题。怀疑是多进程导致的文件死锁问题。&lt;/p&gt;&lt;p&gt;那我们去掉多线程，通过单线程，我们去重复原先复现问题的步骤。发现没有遗漏🤭。&lt;/p&gt;&lt;p&gt;我们发现能进行配置Cluster（主从模式）的地方有两处，日志库和部署工具。&lt;/p&gt;&lt;p&gt;观察日志库默认使用的主从进程模式，而部署工具没有主从模式的概念，势必会导致写入IO的死锁问题，导致日志丢失。于是在想社区有没有可以有解决此问题的第三方支持。&lt;/p&gt;&lt;p&gt;然后通过谷歌搜索，很快就找到了对应的第三方库，它能提供主人进程和仆从进程之间的消息沟通。原理是主人进程负责所有消息写入log，而仆从进程通过消息传递给主人进程。&lt;/p&gt;&lt;h1&gt;五、推荐阅读及引用&lt;/h1&gt;&lt;p&gt;处理异常&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;如何优雅处理前端异常？&lt;/span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;source-map&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;SourceMap 与前端异常监控&lt;/span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;React错误&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;React，优雅的捕获异常&lt;/span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Script Error&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;Capture and report JavaScript errors with window.onerror | Product Blog • Sentry&lt;/span&gt;&lt;span&gt;[8]&lt;/span&gt; &lt;span&gt;What the heck is &quot;Script error&quot;? | Product Blog • Sentry&lt;/span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;整体&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;前端搞监控|Allan - 如何实现一套多端错误监控平台&lt;/span&gt;&lt;span&gt;[10]&lt;/span&gt; &lt;span&gt;一步一步搭建前端监控系统：JS错误监控篇&lt;/span&gt;&lt;span&gt;[11]&lt;/span&gt; &lt;span&gt;撸一个前端监控系统&lt;/span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NDAzMjE5NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/aDoYvepE5x2LRUFlGccgWM7pibyfHFibKOp7r5ecialTR0hwcUdfXhYAPibUbYJ0VibnZS27BolMNukPspZx3ibUDiblg/0?wx_fmt=png&quot; data-nickname=&quot;code秘密花园&quot; data-alias=&quot;code_mmhy&quot; data-signature=&quot;一个优质的前端号，基础、框架、算法、项目、面试...   总有你想要的。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4edd105da48af8b04a08aaa517c1664d</guid>
<title>数据中台架构解析及未来展望</title>
<link>https://toutiao.io/k/q6nbcxg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f19fb9c52e682cd6cf687ac4dc5f10d6</guid>
<title>Sync Once：不是吧，不到 20 行源码居然来回改了这么多次</title>
<link>https://toutiao.io/k/5r2hzz8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;大家好，我是好久不见的薯条，上篇文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxODcxMTIzNQ==&amp;amp;mid=2247485491&amp;amp;idx=1&amp;amp;sn=8653f8b792a3ea1c56556e6a3e7f80e4&amp;amp;chksm=97e71d9fa0909489781e70e7e38595d627f48dc6a935cf1565b8de9c3874ee7c4c861485ff0b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt; 编写一个配置化的Kafka Proxy，让你分钟级别接入Kafka&lt;/a&gt; &lt;span&gt;的阅读量很惨淡，搞得我那段时间有点丧，可能大家还是更喜欢Golang方面的文章，也可能是那篇写的有点搓... 这几天北京降温又下雨，我久违的感冒了，秋高气爽，读者朋友们要注意多加衣服啊，感冒还是很难受的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这&lt;span&gt;篇once的文章前前后后看了好多参考，改了好几遍，最终出来这么个鸟样子，个人感觉并发编程这块水很深，因为这块不仅涉及Golang源码，还涉及到汇编、操作系统、甚至是硬件的知识，真是学无止境，有兴趣的朋友可以查一下&lt;/span&gt;&lt;code&gt;Read Acquire&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;Write Release&lt;/code&gt;&lt;span&gt;和Golang官方的&lt;/span&gt;Memory Model&lt;span&gt;一文。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;以下是正文：&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2709424083769634&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvNEWS3picxkvMn0ne0dST09lVClJehKGdRMZdAia7OzsMxm3DVA3uzJm3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1528&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2327469553450609&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvNjPOAuYQs9ibgFRRMnhiasaOOkKu0hlnHttOKESNP5h17Rib0usBqWr0mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1478&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6263048016701461&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IHqbOgDqW4Qy4nel34ydzSYW1jWETXKHeIAB4FzUakibxZUD9eNZTjxW4GRsbBxAPtxG2fIiaPicJpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;479&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3110181311018131&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvN7zQnz1RxCicbDtUCDu8W2uSWFwjMSO12P4bibunCyXicibvdSEebXWExsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1434&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Resource &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; addr &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; Res *Resource&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; once sync.Once&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;GetResourceOnce&lt;/span&gt;&lt;span&gt;(add &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;Resource&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt; once.Do(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  Res = &amp;amp;Resource{addr: add}&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; Res&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(GetResource(&lt;span&gt;&quot;beijing&quot;&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// output：{beijing}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.30985915492957744&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvNTNVquQjkibyOj5cTCRd1erTf1MQtQElpOXtiaTOicLLxK8y6QSVoeBKbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1278&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.29523809523809524&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvN3xn2Ynt6iaGEsTNFaeUyoL4wCoxSavD34GJy1eXWmXEcKg4icOtxVsvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1470&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2373134328358209&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvNgDic9NZ7KDjE2jefHcHFHXiafJmIRphmpGU7HFQwJko9ZnE4UAPeYKEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1340&quot;/&gt;&lt;/p&gt;&lt;p&gt;例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var Resp *Resource&lt;br/&gt;var mut sync.Mutex&lt;br/&gt;&lt;br/&gt;func GetResourceMutex(add string) *Resource {&lt;br/&gt; mut.Lock()&lt;br/&gt; defer mut.Unlock()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; Resp != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Resp&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; Resp = &amp;amp;Resource{addr: add}&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; Resp&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2533136966126657&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvNAuaZibtS5fzH7XB08h39ibbI2Ym1kiblvVicYvJE5PlA85GsscaBbjdP6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1358&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.28592814371257486&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvNpeAWz4YKYsbzwAzNR3X4WNIq6R3QbpliagWHRnHxEwvaOoIzf7ZEchA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1336&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1. 为啥源码引入Mutex而不是CAS操作&lt;br/&gt;3. 为啥要有fast path, slow path&lt;br/&gt;4. 加锁之后为啥要有&lt;span&gt;done&lt;/span&gt;==0，为啥有double check，为啥这里不是原子读&lt;br/&gt;4.store为啥要加defer&lt;br/&gt;5.为啥是atomic.store，不是直接赋值1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.27474150664697194&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvNQCFKycbppcOjWedRtvQ0nC3Vw303RNKNKia3vvwAibrzc8zcWETJG2Og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1354&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.6774193548387096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wKQGAXOpIazhxElBDtHJPoPzBnSw3ZFoPzicm3qK9T3l9kIrooz6yQ6Dprr6uts1QJqFiakE3tfumQ6fqRchvqwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;62&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;Once开始的地方&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Once struct {&lt;br/&gt; m    Mutex&lt;br/&gt; &lt;span&gt;done&lt;/span&gt; bool&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (o *Once) Do(f func()) {&lt;br/&gt; o.m.Lock()&lt;br/&gt; defer o.m.Unlock()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !o.done {&lt;br/&gt;  o.done = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  f()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这段2010年8月15日提交的代码中，作者借助&lt;code&gt;Mutex&lt;/code&gt;实现Once语义，执行的时候先加一把互斥锁，保证只有一个协程可以操作&lt;code&gt;done&lt;/code&gt;变量，等&lt;code&gt;f&lt;/code&gt;函数执行完解锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的代码相当于mvp版本，管用，但是略显粗糙，一个最显而易见的缺点：每次都要执行Mutex加锁操作，对于Once这种语义有必要吗，是否可以先判断一下done的value是否为true，然后再进行加锁操作呢？&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;第一次进化&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.0740740740740742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/65kKfpfiaHYJb5Dich6GdMtnZre8jhjTibGVwwOgApImzZWplXUib7CrRLG0ZlcicwWM9spLF5qwfdicWeLtwabw5VWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;54&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是Once开始了第一次进化，这次优化改进了上面提到的问题：若Once已经初始化，那么Do内部将不会执行抢锁操作。做这份代码改动的哥们经过测试发现这样改在不同核的benchmark中有92%-99%的耗时提升。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Once struct {&lt;br/&gt; m    Mutex&lt;br/&gt; &lt;span&gt;done&lt;/span&gt; int32&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (o *Once) Do(f func()) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; atomic.AddInt32(&amp;amp;o.done, 0) == 1 {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; // Slow-path.&lt;br/&gt; o.m.Lock()&lt;br/&gt; defer o.m.Unlock()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; o.done == 0 {&lt;br/&gt;  f()&lt;br/&gt;  atomic.CompareAndSwapInt32(&amp;amp;o.done, 0, 1)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这段代码中，在slow-path加锁后，要继续判断done值是否为0，确认done为0后才要执行&lt;code&gt;f()&lt;/code&gt;函数，这是因为在多协程环境下仅仅通过一次&lt;code&gt;atomic.AddInt32&lt;/code&gt;判断并不能保证原子性，比如俩协程g1、g2，g2在g1刚刚执行完&lt;code&gt;atomic.CompareAndSwapInt32(&amp;amp;o.done, 0, 1)&lt;/code&gt;进入了slow path，如果不进行double check，那g2又会执行一次&lt;code&gt;f()&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这次改动中，作者用一个int32变量&lt;code&gt;done&lt;/code&gt;表示once的对象是否已执行完，有两个地方使用到了&lt;code&gt;atomic&lt;/code&gt;包里的方法对&lt;code&gt;o.done&lt;/code&gt;进行判断，分别是，用&lt;code&gt;AddInt32&lt;/code&gt;函数根据&lt;code&gt;o.done&lt;/code&gt;的值是否为1判断once是否已执行过，若执行过直接返回；&lt;code&gt;f()&lt;/code&gt;函数执行完后，对&lt;code&gt;o.done&lt;/code&gt;通过cas操作进行赋值1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两处地方的存在有一定的争议性，在源码cr的过程中就被问到&lt;code&gt;atomic.CompareAndSwapInt32(&amp;amp;o.done, 0, 1)&lt;/code&gt;可否被&lt;code&gt;o.done == 1&lt;/code&gt;替换，
答案是不可以。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的CPU一般拥有多个核心，而CPU的处理速度快于从内存读取变量的速度，为了弥补这俩速度的差异，现在CPU每个核心都有自己的L1、L2、L3级高速缓存，CPU可以直接从高速缓存中读取数据，但是这样一来内存中的一份数据就在缓存中有多份副本，在同一时间下这些副本中的可能会不一样，为了保持缓存一致性，Intel CPU使用了MESI协议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;AddInt32&lt;/code&gt;方法和&lt;code&gt;CompareAndSwapInt32&lt;/code&gt;方法(均为amd64平台 runtime/internal/atomic/atomic_amd64.s)底层都是在汇编层面调用了&lt;code&gt;LOCK&lt;/code&gt;指令，&lt;code&gt;LOCK&lt;/code&gt;指令通过总线锁或MESI协议保证原子性（具体措施与CPU的版本有关），提供了强一致性的缓存读写保证，保证&lt;code&gt;LOCK&lt;/code&gt;之后的指令在带&lt;code&gt;LOCK&lt;/code&gt;前缀的指令执行之后才执行，从而保证读到最新的&lt;code&gt;o.done&lt;/code&gt;值。&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.6774193548387096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wKQGAXOpIazhxElBDtHJPoPzBnSw3ZFoPzicm3qK9T3l9kIrooz6yQ6Dprr6uts1QJqFiakE3tfumQ6fqRchvqwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;62&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;第二次进化&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此Once的代码已经成型了，后面来列举一些小优化的集合：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小优化一&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4044943820224719&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvN6TxWQAObUmHPylm0t9xCY5JqFW8h6E2dTbiblySyqNwiaJo3T68R0ibqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2314&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个小优化把done的类型由&lt;code&gt;int32&lt;/code&gt;替换为&lt;code&gt;uint32&lt;/code&gt;,用&lt;code&gt;CompareAndSwapUint32&lt;/code&gt;替换了&lt;code&gt;CompareAndSwapInt32&lt;/code&gt;, 用&lt;code&gt;LoadUint32&lt;/code&gt;替换了&lt;code&gt;AddInt32&lt;/code&gt;方法，&lt;code&gt;LoadUint32&lt;/code&gt;底层并没有&lt;code&gt;LOCK&lt;/code&gt;指令用于加锁，我觉得能这么写的主要原因是进入slow path之后会继续用Mutex加锁并判断&lt;code&gt;o.done&lt;/code&gt;的值，且后面的&lt;code&gt;CAS&lt;/code&gt;操作是加锁的，所以可以这么改。这次优化经过benchmark测试性能&lt;span&gt;在&lt;/span&gt;&lt;span&gt;不同核心上有&lt;/span&gt;45%-94%的提升。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小优化二&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvNuAmbRGovNjufp7Aglk4ZOQdShb8RWXm3KCnpKAZxBKfnLvacP31srg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1750&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次小优化用&lt;code&gt;StoreUint32&lt;/code&gt;替换了&lt;code&gt;CompareAndSwapUint32&lt;/code&gt;操作，CAS操作在这里确实有点多余，因为这行代码最主要的功能是原子性的&lt;code&gt;done = 1&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Store命令的底层是，其中关键的指令是&lt;code&gt;XCHG&lt;/code&gt;，有的同学可能要问了，这源码里没有&lt;code&gt;LOCK&lt;/code&gt;指令啊，怎么保证happen before呢，Intel手册有这样的描述: &lt;code&gt;The LOCK prefix is automatically assumed for XCHG instruction.&lt;/code&gt;，这个指令默认带&lt;code&gt;LOCK&lt;/code&gt;前缀，能保证Happen Before语义。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;TEXT runtime∕internal∕atomic·Store(SB), NOSPLIT, &lt;span&gt;$0&lt;/span&gt;-12&lt;br/&gt; MOVQ ptr+0(FP), BX&lt;br/&gt; MOVL val+8(FP), AX&lt;br/&gt; XCHGL AX, 0(BX)&lt;br/&gt; RET&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小优化三&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17681895093062605&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvNVXoKNkA5OEjQ8TTwyKozvOeeI4nicz3j8RhZibsmwOwHaWL0bpuly5uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2364&quot;/&gt;这次的优化在&lt;code&gt;StoreUint32&lt;/code&gt;前增加defer前缀，增加defer是保证 即使&lt;code&gt;f()&lt;/code&gt;在执行过程中出现panic，Once仍然保证&lt;code&gt;f()&lt;/code&gt;只执行一次，这样符合严格的Once语义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了预防panic，defer还能解决指令重排的问题：现在CPU为了执行效率，源码在真正执行时的顺序和代码的顺序可能并不一样，比如这段代码中a不一定打印&quot;hello, world&quot;，也可能打印空字符串。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var a string&lt;br/&gt;var &lt;span&gt;done&lt;/span&gt; bool&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;setup&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; a = &lt;span&gt;&quot;hello, world&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;done&lt;/span&gt; = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; go setup()&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; !&lt;span&gt;done&lt;/span&gt; {&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;print&lt;/span&gt;(a)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而增加了defer前缀，能保证，即使出现指令重排，&lt;code&gt;done&lt;/code&gt;变量也能在&lt;code&gt;f()&lt;/code&gt;函数执行完后才进行store操作。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小优化四&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22493681550126368&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvNlA9cm8KtTJhpeLwpspI0RdolpuTSRuzibbHylTAMuph9Dw40zgEWARQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2374&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次优化主要是用函数区分开了fast path和slow path，对fast path做了内联优化。这样进一步降低了使用Once的开销，因为fast path会被内联到使用once的函数调用中，每次调用的时候如果只走到fast path那么连函数调用的开销都省去了，这次优化在不同核的环境下又有&lt;code&gt;54%-67%&lt;/code&gt;的提升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3179271708683473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvNtIOvH9AsjhqpXtKZYibYyQKYOM1icCdhcZVRPbXFktoodYmuqicVtExcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1428&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2586705202312139&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvNsibz4Mg0eOy2QnukY2jS8fkjdVDZxVmf6kcAFIJwOibEIBpCfQSSa6ZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2812920592193809&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvNlllBRicAVKfecaAiag8Mdwnl8u7vRiawsx2OicRcEjiaReBkiajkwHsKGHIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1486&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23705722070844687&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvNnENJmZAG714mBa0iacBCwWAAM8FGaG8N2bYY4gZib6jolKia59kibx2vyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1468&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; St struct {&lt;br/&gt; ponce *sync.Once&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (st *St) &lt;span&gt;&lt;span&gt;Reset&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; st.ponce = new(sync.Once)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; s := &amp;amp;St{}&lt;br/&gt;&lt;br/&gt; f1 := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;hello, world&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; s.Reset()&lt;br/&gt; s.ponce.Do(f1)&lt;br/&gt; s.Reset()&lt;br/&gt; s.ponce.Do(f1)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4728132387706856&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9IiaLmN4MmbKbVtyLsUYTTvNW0h5dlVB8xKQOnPyEnfKiaQQwoaIw5EMc56cgAeP9BmLjPdY2Gq79pQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;846&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，给自己打个广告&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎加入 &lt;strong&gt;随波逐流的薯条&lt;/strong&gt; 微信群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;薯条目前有草帽群、木叶群、琦玉群，群交流内容不限于技术、投资、趣闻分享等话题。欢迎感兴趣的同学入群交流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入群请加薯条的个人微信：709834997。并备注：加入薯条微信群。&lt;/p&gt;&lt;p&gt;欢迎关注我的公众号~&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIxODcxMTIzNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/YdZzofiato9J9Zggib9T7Iibq78c1TUWq8JjURtqFSKYxps1Qur347zl04U3ERmjBgv9B7MUC4fzNyjorW2y0SsvA/0?wx_fmt=png&quot; data-nickname=&quot;薯条的编程修养&quot; data-alias=&quot;yigfuutc&quot; data-signature=&quot;互联网公司一线开发，日常扯扯淡，分享 Golang、数据库、经验总结、系统设计等方面的技术文章&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d001abde810a843deefdbcb50171e434</guid>
<title>t-io 的生态结构，可以大致看到 t-io 的性能</title>
<link>https://toutiao.io/k/m1bcnml</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;blockquote&gt;
&lt;p&gt;tio-utils是笔者在项目开发中积累的部分工具类
里面有少部分代码是在开源许可范围内摘自第三方开源项目代码的，还有部分代码是其它开源作者提供的，譬如hutool的作者路神就提供了许多类，这么做，仅仅是因为广大用户强力要求tio减少第三方依赖
当然笔者更愿意使第三方工具类，譬如hutool
在tio-utils中目前t-io用得最多的Cache
首先这个Cache是个门面——把市面上的各路Cache统一成了ICache，操作方法统一了
其次它内置了一级cache，两级cache，并且性能极好、操作省心、稳定性也在大量项目中得到了考验
其实就是想挑战J2cache，不过tio-utils也把J2cache门面化了&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>