<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7bc4d3f0b84ef3d61e1b43565fc93ed5</guid>
<title>上新了 Spring，全新一代类型转换机制</title>
<link>https://toutiao.io/k/b04brot</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKLLXbx6ciciaw2Z7AwC5oAyBqRgicGZnrPKlZPP8tnwvdHTQ9vfOI6XfJfBkKlNMZze9ibYBtazkc4jhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍前言&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是YourBatman。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247490866&amp;amp;idx=1&amp;amp;sn=9f9dafce23d861dc93dc5600852ab017&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;上篇文章&lt;/a&gt; 介绍完了Spring类型转换早期使用的PropertyEditor详细介绍，关于PropertyEditor现存的资料其实还蛮少的，希望这几篇文章能弥补这块空白，贡献一份微薄之力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你也吐槽过PropertyEditor不好用，那么本文将对会有帮助。Spring自&lt;strong&gt;3.0版本&lt;/strong&gt;开始自建了一套全新类型转换接口，这就是本文的主要内容，接下来逐步展开。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：Spring自3.0后笑傲群雄，进入大一统。Java从此步入Spring的时代&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;版本约定&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Spring Framework：5.3.1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Boot：2.4.0&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5807200929152149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKLLXbx6ciciaw2Z7AwC5oAyBqdqKrF5SGs4mianXm7g31wsic9UP9HLPzc1ZYc72SZuWBtbicVhMtm0RBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍正文&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解新一代的转换接口之前，先思考一个问题：&lt;strong&gt;Spring为何要自己造一套轮子呢？&lt;/strong&gt;  一向秉承不重复造轮子原则的Spring，不是迫不得已的话是不会去动他人奶酪的，毕竟互利共生才能长久。类型转换，作为Spring框架的基石，扮演着异常重要的角色，因此对其可扩展性、可维护性、高效性均有很高要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于此，我们先来了解下PropertyEditor设计上到底有哪些缺陷/不足（不能满足现代化需求），让Spring“被迫”走上了自建道路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;PropertyEditor设计缺陷&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前提说明：本文指出它的设计缺陷，只讨论把它当做类型转换器在转换场景下存在的一些缺陷。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;职责不单一：该接口有非常多的方法，但只用到2个而已&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类型不安全：setValue()方法入参是Object，getValue()返回值是Object，依赖于约定好的类型&lt;strong&gt;强转&lt;/strong&gt;，不安全&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程不安全：依赖于setValue()后getValue()，实例是线程不安全的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语义不清晰：从语义上根本不能知道它是用于类型转换的组件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;只能用于String类型&lt;/strong&gt;：它只能进行&lt;strong&gt;String &amp;lt;-&amp;gt; 其它类型&lt;/strong&gt;的转换，而非更灵活的&lt;strong&gt;Object &amp;lt;-&amp;gt; Object&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PropertyEditor存在这五宗“罪”，让Spring决定自己设计一套全新API用于专门服务于类型转换，这就是本文标题所述：新一代类型转换Converter、ConverterFactory、GenericConverter。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;关于PropertyEditor在Spring中的详情介绍，请参见文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;amp;mid=2247490866&amp;amp;idx=1&amp;amp;sn=9f9dafce23d861dc93dc5600852ab017&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;3. 搞定收工，PropertyEditor就到这&lt;/a&gt;&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;新一代类型转换&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决PropertyEditor作为类型转换方式的设计缺陷，Spring 3.0版本重新设计了一套类型转换接口，有3个核心接口：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Converter&amp;lt;S, T&amp;gt;&lt;/code&gt;：Source -&amp;gt; Target类型转换接口，适用于1:1转换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ConverterFactory&amp;lt;S, R&amp;gt;&lt;/code&gt;：Source -&amp;gt; R类型转换接口，适用于1:N转换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;GenericConverter&lt;/code&gt;：更为通用的类型转换接口，适用于N:N转换&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;注意：就它没有泛型约束，因为是通用&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，还有一个条件接口&lt;code&gt;ConditionalConverter&lt;/code&gt;，可跟上面3个接口搭配组合使用，提供前置条件判断验证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这套接口，解决了PropertyEditor做类型转换存在的&lt;strong&gt;所有缺陷&lt;/strong&gt;，且具有非常高的灵活性和可扩展性。下面进入详细了解。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Converter&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将源类型S转换为目标类型T。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@FunctionalInterface&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Converter&lt;/span&gt;&amp;lt;&lt;span&gt;S&lt;/span&gt;, &lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;T &lt;span&gt;convert&lt;/span&gt;&lt;span&gt;(S source)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是个函数式接口，接口定义非常简单。适合1:1转换场景：可以将任意类型 转换为 任意类型。它的实现类非常多，部分截图如下：&lt;img data-ratio=&quot;0.6566523605150214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKLLXbx6ciciaw2Z7AwC5oAyBqFGPicXc9haFjAic18EAlarm7keKud1BA6pP00vjWLxQxljT0oKdBf0yA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;466&quot;/&gt;值得注意的是：几乎所有实现类的访问权限都是&lt;code&gt;default/private&lt;/code&gt;，只有少数几个是public公开的，下面我用代码示例来“近距离”感受一下。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;代码示例&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * Converter：1:1&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;----------------StringToBooleanConverter---------------&quot;&lt;/span&gt;);&lt;br/&gt;    Converter&amp;lt;String, Boolean&amp;gt; converter = &lt;span&gt;new&lt;/span&gt; StringToBooleanConverter();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// trueValues.add(&quot;true&quot;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// trueValues.add(&quot;on&quot;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// trueValues.add(&quot;yes&quot;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// trueValues.add(&quot;1&quot;);&lt;/span&gt;&lt;br/&gt;    System.out.println(converter.convert(&lt;span&gt;&quot;true&quot;&lt;/span&gt;));&lt;br/&gt;    System.out.println(converter.convert(&lt;span&gt;&quot;1&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// falseValues.add(&quot;false&quot;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// falseValues.add(&quot;off&quot;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// falseValues.add(&quot;no&quot;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// falseValues.add(&quot;0&quot;);&lt;/span&gt;&lt;br/&gt;    System.out.println(converter.convert(&lt;span&gt;&quot;FalSe&quot;&lt;/span&gt;));&lt;br/&gt;    System.out.println(converter.convert(&lt;span&gt;&quot;off&quot;&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;// 注意：空串返回的是null&lt;/span&gt;&lt;br/&gt;    System.out.println(converter.convert(&lt;span&gt;&quot;&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;----------------StringToCharsetConverter---------------&quot;&lt;/span&gt;);&lt;br/&gt;    Converter&amp;lt;String, Charset&amp;gt; converter2 = &lt;span&gt;new&lt;/span&gt; StringToCharsetConverter();&lt;br/&gt;    &lt;span&gt;// 中间横杠非必须，但强烈建议写上   不区分大小写&lt;/span&gt;&lt;br/&gt;    System.out.println(converter2.convert(&lt;span&gt;&quot;uTf-8&quot;&lt;/span&gt;));&lt;br/&gt;    System.out.println(converter2.convert(&lt;span&gt;&quot;utF8&quot;&lt;/span&gt;));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，正常输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;----------------StringToBooleanConverter---------------&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;----------------StringToCharsetConverter---------------&lt;br/&gt;UTF-&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;UTF-&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明：StringToBooleanConverter/StringToCharsetConverter访问权限都是default，外部不可直接使用。此处为了做示例用到一个小技巧 -&amp;gt; &lt;strong&gt;将Demo的报名调整为和转换器的一样，这样就可以直接访问&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注点：true/on/yes/1都能被正确转换为&lt;code&gt;true&lt;/code&gt;的，且对于英文字母来说一般都不区分大小写，增加了容错性（包括Charset的转换）。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;不足&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Converter用于解决1:1的任意类型转换，因此它必然存在一个不足：解决1:N转换问题需要写N遍，造成重复冗余代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;譬如：输入是字符串，它可以转为任意数字类型，包括byte、short、int、long、double等等，如果用Converter来转换的话每个类型都得写个转换器，想想都麻烦有木有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring早早就考虑到了该场景，提供了相应的接口来处理，它就是&lt;code&gt;ConverterFactory&amp;lt;S, R&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;ConverterFactory&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从名称上看它代表一个转换工厂：可以将对象S转换为R的所有&lt;strong&gt;子类型&lt;/strong&gt;，从而形成1:N的关系。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;该接口描述为xxxFactory是非常合适的，很好的表达了1:N的关系&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ConverterFactory&lt;/span&gt;&amp;lt;&lt;span&gt;S&lt;/span&gt;, &lt;span&gt;R&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt; &amp;lt;T extends R&amp;gt; &lt;span&gt;Converter&amp;lt;S, T&amp;gt; &lt;span&gt;getConverter&lt;/span&gt;&lt;span&gt;(Class&amp;lt;T&amp;gt; targetType)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它同样也是个函数式接口。该接口的实现类并不多，Spring Framework共提供了5个内建实现（访问权限全部为default）：&lt;img data-ratio=&quot;0.2555746140651801&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKLLXbx6ciciaw2Z7AwC5oAyBq7uvVOxvjHQHOVj9YVnbMp9rdZDxJ97s6JmvBy8Ul3fHQyM6WBUa3hQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;583&quot;/&gt;以StringToNumberConverterFactory为例看看实现的套路：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StringToNumberConverterFactory&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ConverterFactory&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Number&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt; &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T extends Number&amp;gt; &lt;span&gt;Converter&amp;lt;String, T&amp;gt; &lt;span&gt;getConverter&lt;/span&gt;&lt;span&gt;(Class&amp;lt;T&amp;gt; targetType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; StringToNumber&amp;lt;T&amp;gt;(targetType);&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 私有内部类：实现Converter接口。用泛型边界约束一类类型&lt;/span&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StringToNumber&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Number&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Converter&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt; targetType;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;StringToNumber&lt;/span&gt;&lt;span&gt;(Class&amp;lt;T&amp;gt; targetType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;.targetType = targetType;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;convert&lt;/span&gt;&lt;span&gt;(String source)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (source.isEmpty()) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; NumberUtils.parseNumber(source, &lt;span&gt;this&lt;/span&gt;.targetType);&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由点知面，ConverterFactory作为Converter的工厂，对Converter进行包装，从而达到屏蔽内部实现的目的，对使用者友好，这不正是工厂模式的优点么，符合xxxFactory的语义。但你需要清除的是，工厂内部实现其实也是通过众多if else之类的去完成的，本质上并无差异。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;代码示例&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * ConverterFactory：1:N&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;----------------StringToNumberConverterFactory---------------&quot;&lt;/span&gt;);&lt;br/&gt;    ConverterFactory&amp;lt;String, Number&amp;gt; converterFactory = &lt;span&gt;new&lt;/span&gt; StringToNumberConverterFactory();&lt;br/&gt;    &lt;span&gt;// 注意：这里不能写基本数据类型。如int.class将抛错&lt;/span&gt;&lt;br/&gt;    System.out.println(converterFactory.getConverter(Integer&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;convert&lt;/span&gt;(&quot;1&quot;).&lt;span&gt;getClass&lt;/span&gt;())&lt;/span&gt;;&lt;br/&gt;    System.out.println(converterFactory.getConverter(Double&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;convert&lt;/span&gt;(&quot;1.1&quot;).&lt;span&gt;getClass&lt;/span&gt;())&lt;/span&gt;;&lt;br/&gt;    System.out.println(converterFactory.getConverter(Byte&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;convert&lt;/span&gt;(&quot;0&lt;span&gt;x11&lt;/span&gt;&quot;).&lt;span&gt;getClass&lt;/span&gt;())&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，正常输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;----------------StringToNumberConverterFactory---------------&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;.&lt;span&gt;lang&lt;/span&gt;.&lt;span&gt;Integer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;.&lt;span&gt;lang&lt;/span&gt;.&lt;span&gt;Double&lt;/span&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;.&lt;span&gt;lang&lt;/span&gt;.&lt;span&gt;Byte&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注点：数字类型的字符串，是可以被转换为任意Java中的数字类型的，&lt;code&gt;String(1) -&amp;gt; Number(N)&lt;/code&gt;。这便就是ConverterFactory的功劳，它能处理这一类转换问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;不足&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然有了1:1、1:N，自然就有N:N。比如集合转换、数组转换、Map到Map的转换等等，这些N:N的场景，就需要借助下一个接口GenericConverter来实现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;GenericConverter&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是一个&lt;strong&gt;通用的&lt;/strong&gt;转换接口，用于在两个或多个类型之间进行转换。相较于前两个，这是&lt;strong&gt;最灵活&lt;/strong&gt;的SPI转换器接口，但也是&lt;strong&gt;最复杂&lt;/strong&gt;的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;GenericConverter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt; &lt;span&gt;Set&amp;lt;ConvertiblePair&amp;gt; &lt;span&gt;getConvertibleTypes&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;Object &lt;span&gt;convert&lt;/span&gt;&lt;span&gt;(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt; &lt;br/&gt; &lt;span&gt;// 普通POJO&lt;/span&gt;&lt;br/&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConvertiblePair&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt; sourceType;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt; targetType;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该接口并非函数式接口，虽然方法不多但稍显复杂。现对出现的几个类型做简单介绍：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ConvertiblePair&lt;/code&gt;：维护sourceType和targetType的POJO&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;getConvertibleTypes()方法返回此Pair的&lt;strong&gt;Set集合&lt;/strong&gt;。由此也能看出该转换器是可以支持N:N的（大多数情况下只写一对值而已，也有写多对的）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;TypeDescriptor&lt;/code&gt;：类型描述。该类专用于Spring的类型转换场景，用于描述from or to的类型&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;比单独的Type类型强大，内部借助了ResolvableType来解决泛型议题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GenericConverter的内置实现也比较多，部分截图如下：&lt;img data-ratio=&quot;0.6823308270676691&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKLLXbx6ciciaw2Z7AwC5oAyBqW7MoTAIE74V28lUEsXHrr3X5LwzOibfCnBv2N8C6Alrqcfq60BxLDjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;532&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;&lt;code&gt;ConditionalGenericConverter&lt;/code&gt;是GenericConverter和条件接口ConditionalConverter的组合，作用是在执行GenericConverter转换时增加一个&lt;strong&gt;前置条件判断&lt;/strong&gt;方法。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;转换器&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;th&gt;示例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;ArrayToArrayConverter&lt;/td&gt;&lt;td&gt;数组转数组Object[] -&amp;gt; Object[]&lt;/td&gt;&lt;td&gt;[&quot;1&quot;,&quot;2&quot;] -&amp;gt; [1,2]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ArrayToCollectionConverter&lt;/td&gt;&lt;td&gt;数组转集合 Object[] -&amp;gt; Collection&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CollectionToCollectionConverter&lt;/td&gt;&lt;td&gt;数组转集合 Collection -&amp;gt; Collection&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;StringToCollectionConverter&lt;/td&gt;&lt;td&gt;字符串转集合String -&amp;gt; Collection&lt;/td&gt;&lt;td&gt;1,2 -&amp;gt; [1,2]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;StringToArrayConverter&lt;/td&gt;&lt;td&gt;字符串转数组String -&amp;gt; Array&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MapToMapConverter&lt;/td&gt;&lt;td&gt;Map -&amp;gt; Map(需特别注意：key和value都支持转换才行)&lt;/td&gt;&lt;td&gt;略&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CollectionToStringConverter&lt;/td&gt;&lt;td&gt;集合转字符串Collection -&amp;gt; String&lt;/td&gt;&lt;td&gt;[1,2] -&amp;gt; 1,2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ArrayToStringConverter&lt;/td&gt;&lt;td&gt;委托给CollectionToStringConverter完成&lt;/td&gt;&lt;td&gt;同上&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;「StreamConverter」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;集合/数组 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; Stream互转&lt;/td&gt;&lt;td&gt;集合/数组类型 -&amp;gt; Stream类型&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;「IdToEntityConverter」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;ID-&amp;gt;Entity的转换&lt;/td&gt;&lt;td&gt;传入任意类型ID -&amp;gt; 一个Entity实例&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;「ObjectToObjectConverter」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;很复杂的对象转换，任意对象之间&lt;/td&gt;&lt;td&gt;obj -&amp;gt; obj&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;「FallbackObjectToStringConverter」&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;上个转换器的兜底，调用Obj.toString()转换&lt;/td&gt;&lt;td&gt;obj -&amp;gt; String&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;说明：分割线下面的4个转换器比较特殊，字面上不好理解其实际作用，比较“高级”。它们如果能被运用在日常工作中可以&lt;strong&gt;事半功弎&lt;/strong&gt;，因此放在在下篇文章专门给你介绍&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面以CollectionToCollectionConverter为例分析此转换器的“复杂”之处：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CollectionToCollectionConverter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ConditionalGenericConverter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConversionService conversionService;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CollectionToCollectionConverter&lt;/span&gt;&lt;span&gt;(ConversionService conversionService)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.conversionService = conversionService;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;br/&gt; &lt;span&gt;// 集合转集合：如String集合转为Integer集合&lt;/span&gt;&lt;br/&gt; &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;ConvertiblePair&amp;gt; &lt;span&gt;getConvertibleTypes&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Collections.singleton(&lt;span&gt;new&lt;/span&gt; ConvertiblePair(Collection&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;Collection&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是唯一构造器，必须传入ConversionService：元素与元素之间的转换是依赖于conversionService转换服务去完成的，最终完成集合到集合的转换。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CollectionToCollectionConverter：&lt;br/&gt;&lt;br/&gt; &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;matches&lt;/span&gt;&lt;span&gt;(TypeDescriptor sourceType, TypeDescriptor targetType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ConversionUtils.canConvertElements(sourceType.getElementTypeDescriptor(), targetType.getElementTypeDescriptor(), &lt;span&gt;this&lt;/span&gt;.conversionService);&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判断能否转换的依据：集合里的&lt;strong&gt;元素与元素之间&lt;/strong&gt;是否能够转换，底层依赖于&lt;code&gt;ConversionService#canConvert()&lt;/code&gt;这个API去完成判断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来再看&lt;strong&gt;最复杂&lt;/strong&gt;的转换方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CollectionToCollectionConverter：&lt;br/&gt;&lt;br/&gt; &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;convert&lt;/span&gt;&lt;span&gt;(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (source == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  Collection&amp;lt;?&amp;gt; sourceCollection = (Collection&amp;lt;?&amp;gt;) source;&lt;br/&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// 判断：这些情况下，将不用执行后续转换动作了，直接返回即可&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;boolean&lt;/span&gt; copyRequired = !targetType.getType().isInstance(source);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!copyRequired &amp;amp;&amp;amp; sourceCollection.isEmpty()) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; source;&lt;br/&gt;  }&lt;br/&gt;  TypeDescriptor elementDesc = targetType.getElementTypeDescriptor();&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (elementDesc == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !copyRequired) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; source;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  Collection&amp;lt;Object&amp;gt; target = CollectionFactory.createCollection(targetType.getType(),&lt;br/&gt;    (elementDesc != &lt;span&gt;null&lt;/span&gt; ? elementDesc.getType() : &lt;span&gt;null&lt;/span&gt;), sourceCollection.size());&lt;br/&gt;  &lt;span&gt;// 若目标类型没有指定泛型（没指定就是Object），不用遍历直接添加全部即可&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (elementDesc == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   target.addAll(sourceCollection);&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// 遍历：一个一个元素的转，时间复杂度还是蛮高的&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// 元素转元素委托给conversionService去完成&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; (Object sourceElement : sourceCollection) {&lt;br/&gt;    Object targetElement = &lt;span&gt;this&lt;/span&gt;.conversionService.convert(sourceElement,&lt;br/&gt;      sourceType.elementTypeDescriptor(sourceElement), elementDesc);&lt;br/&gt;    target.add(targetElement);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (sourceElement != targetElement) {&lt;br/&gt;     copyRequired = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (copyRequired ? target : source);&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该转换步骤稍微有点复杂，我帮你屡清楚后有这几个关键步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;快速返回：对于特殊情况，做快速返回处理&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;源集合为空，还转换个啥&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;目标集合没指定泛型，那就是Object，因此可以接纳一切，还转换个啥&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若目标元素类型是&lt;strong&gt;源&lt;/strong&gt;元素类型的子类型（或相同），就没有转换的必要了（copyRequired = false）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若源集合为空，或者目标集合&lt;strong&gt;没指定泛型&lt;/strong&gt;，也不需要做转换动作&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;若没有触发快速返回。给目标创建一个&lt;strong&gt;新集合&lt;/strong&gt;，然后把source的元素&lt;strong&gt;一个一个的&lt;/strong&gt;放进新集合里去，这里又分为两种处理case&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若新集合（目标集合）没有指定泛型类型（那就是Object），就直接putAll即可，并不需要做类型转换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若新集合（目标集合指定了泛型类型），就&lt;strong&gt;遍历&lt;/strong&gt;源集合委托&lt;code&gt;conversionService.convert()&lt;/code&gt;对元素一个一个的转&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;代码示例&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以CollectionToCollectionConverter做示范：&lt;code&gt;List&amp;lt;String&amp;gt; -&amp;gt; Set&amp;lt;Integer&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;----------------CollectionToCollectionConverter---------------&quot;&lt;/span&gt;);&lt;br/&gt;    ConditionalGenericConverter conditionalGenericConverter = &lt;span&gt;new&lt;/span&gt; CollectionToCollectionConverter(&lt;span&gt;new&lt;/span&gt; DefaultConversionService());&lt;br/&gt;    &lt;span&gt;// 将Collection转为Collection（注意：没有指定泛型类型哦）&lt;/span&gt;&lt;br/&gt;    System.out.println(conditionalGenericConverter.getConvertibleTypes());&lt;br/&gt;&lt;br/&gt;    List&amp;lt;String&amp;gt; sourceList = Arrays.asList(&lt;span&gt;&quot;1&quot;&lt;/span&gt;, &lt;span&gt;&quot;2&quot;&lt;/span&gt;, &lt;span&gt;&quot;2&quot;&lt;/span&gt;, &lt;span&gt;&quot;3&quot;&lt;/span&gt;, &lt;span&gt;&quot;4&quot;&lt;/span&gt;);&lt;br/&gt;    TypeDescriptor sourceTypeDesp = TypeDescriptor.collection(List&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;TypeDescriptor&lt;/span&gt;.&lt;span&gt;valueOf&lt;/span&gt;(&lt;span&gt;String&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;    TypeDescriptor targetTypeDesp = TypeDescriptor.collection(Set&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;TypeDescriptor&lt;/span&gt;.&lt;span&gt;valueOf&lt;/span&gt;(&lt;span&gt;Integer&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    System.out.println(conditionalGenericConverter.matches(sourceTypeDesp, targetTypeDesp));&lt;br/&gt;    Object convert = conditionalGenericConverter.convert(sourceList, sourceTypeDesp, targetTypeDesp);&lt;br/&gt;    System.out.println(convert.getClass());&lt;br/&gt;    System.out.println(convert);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，正常输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[java.util.Collection -&amp;gt; java.util.Collection]&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;.&lt;span&gt;util&lt;/span&gt;.&lt;span&gt;LinkedHashSet&lt;/span&gt;&lt;br/&gt;[1, 2, 3, 4]&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注点：target最终使用的是LinkedHashSet来存储，这结果和&lt;code&gt;CollectionFactory#createCollection&lt;/code&gt;该API的实现逻辑是相关（Set类型默认创建的是LinkedHashSet实例）。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;不足&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说它的优点是功能强大，能够处理复杂类型的转换（PropertyEditor和前2个接口都只能转换&lt;strong&gt;单元素&lt;/strong&gt;类型），那么缺点就是使用、自定义实现起来比较复杂。这不&lt;strong&gt;官方&lt;/strong&gt;也给出了使用指导意见：在Converter/ConverterFactory接口能够满足条件的情况下，可不使用此接口就不使用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;ConditionalConverter&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;条件接口，@since 3.2。它可以为Converter、GenericConverter、ConverterFactory转换增加一个&lt;strong&gt;前置判断条件&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ConditionalConverter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;matches&lt;/span&gt;&lt;span&gt;(TypeDescriptor sourceType, TypeDescriptor targetType)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该接口的实现，截图如下：&lt;img data-ratio=&quot;1.022887323943662&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/crPesQVeyKLLXbx6ciciaw2Z7AwC5oAyBqCYs4Ov0l3LER2OiazHmhJc53GTeJuqjJGTBxP2lgGRjf9hIamA2g2zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;可以看到，只有通用转换器GenericConverter和它进行了&lt;strong&gt;合体&lt;/strong&gt;。这也很容易理解，作为通用的转换器，加个前置判断将更加严谨和更安全。对于专用的转换器如Converter，它已明确规定了转换的类型，自然就不需要做前置判断喽。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;✍总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文详细介绍了Spring新一代的类型转换接口，类型转换作为Spring的基石，其重要性可见一斑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PropertyEditor作为Spring早期使用“转换器”，因存在众多设计缺陷自Spring 3.0起被新一代转换接口所取代，主要有：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Converter&amp;lt;S, T&amp;gt;&lt;/code&gt;：Source -&amp;gt; Target类型转换接口，适用于1:1转换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ConverterFactory&amp;lt;S, R&amp;gt;&lt;/code&gt;：Source -&amp;gt; R类型转换接口，适用于1:N转换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;GenericConverter&lt;/code&gt;：更为通用的类型转换接口，适用于N:N转换&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下篇文章将针对于GenericConverter的几个特殊实现撰专文为你讲解，你也知道做难事必有所得，做难事才有可能破局、破圈，欢迎保持关注。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;✔✔✔推荐阅读✔✔✔&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【Spring类型转换】系列：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【Jackson】系列：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【数据校验Bean Validation】系列：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【新特性】系列：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【程序人生】系列：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有诸如【Spring配置类】【Spring-static】【Spring数据绑定】【Spring Cloud Netflix】【Feign】【Ribbon】【Hystrix】...更多原创专栏，关注&lt;code&gt;BAT的乌托邦&lt;/code&gt;回复&lt;code&gt;专栏&lt;/code&gt;二字即可全部获取，分享、成长，拒绝浅藏辄止。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;有些专栏&lt;strong&gt;已完结&lt;/strong&gt;，有些正在&lt;strong&gt;连载中&lt;/strong&gt;，期待你的关注、共同进步&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b637af25d24ff623d32f475ec5c9ff3a</guid>
<title>Vite 使 Vue CLI 过时了吗？</title>
<link>https://toutiao.io/k/pczpcvm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.535&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0AMTMSp1sIj8sicIM61P0rOvv6uG5AZemHU8Wn0QIS7mIZZkANbuTwYvuWdSGvhVp11PwWy3yUBUzRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;文末福利资源更新&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Vue生态系统中有一个名为Vite的新构建工具，它的开发服务器比Vue CLI快10-100倍。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是否意味着Vue CLI已经过时了?在本文中，我将比较这两种构建工具，并说明它们的优缺点，以便你可以决定哪一种适合你的下一个项目。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Vue CLI概述&lt;/h2&gt;&lt;section&gt;&lt;span&gt;大多数Vue开发人员都知道，Vue CLI是使用标准构建工具和最佳实践配置快速建立基于Vue的项目的不可或缺的工具。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其主要功能包括：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;工程脚手架&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;带热模块重载的开发服务器&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;插件系统&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户界面&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;在本讨论中需要注意的是，Vue CLI是构建在Webpack之上的，因此开发服务器和构建功能和性能都将是Webpack的超集。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Vite概述&lt;/h2&gt;&lt;section&gt;&lt;span&gt;与Vue CLI类似，Vite也是一个提供基本项目脚手架和开发服务器的构建工具。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然而，Vite并不是基于Webpack的，它有自己的开发服务器，利用浏览器中的原生ES模块。这种架构使得Vite比Webpack的开发服务器快了好几个数量级。Vite采用Rollup进行构建，速度也更快。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Vite目前还处于测试阶段，看来Vite项目的目的并不是像Vue CLI那样的一体化工具，而是专注于提供一个快速的开发服务器和基本的构建工具。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Vite怎么这么快？&lt;/h2&gt;&lt;section&gt;&lt;span&gt;Vite开发服务器至少会比Webpack快10倍左右。对于一个基本的项目来说，与2.5秒相比，开发构建/重新构建的时间相差250ms。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在一个较大的项目中，这种差异会变得更加明显。Webpack开发服务器在构建/重新构建时可能会慢到25-30秒，有时甚至更慢。与此同时，Vite开发服务器可能会以恒定的250ms的速度为同一个项目提供服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这显然是开发经验和游戏规则改变的差异，Vite是如何做到这一点的？&lt;/span&gt;&lt;/section&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1607878348470&quot; data-category_id_list=&quot;48|26|49|1|55|8|47|5|7|24|37|11|50|54|53|42|29|43|16|51|36&quot; data-id=&quot;1607878348470&quot;/&gt;&lt;section&gt;&lt;span&gt;Webpack开发服务器架构&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Webpack的工作方式是，它通过解析应用程序中的每一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;require&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，将整个应用程序构建成一个基于JavaScript的捆绑包，并在运行时转换文件（例如Sass、TypeScript、SFC）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这都是在服务器端完成的，依赖的数量和改变后构建/重新构建的时间之间有一个大致的线性关系。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Vite开发服务器架构&lt;/h2&gt;&lt;section&gt;&lt;span&gt;Vite不捆绑应用服务器端。相反，它依赖于浏览器对JavaScript模块的原生支持（也就是ES模块，是一个比较新的功能）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;浏览器将在需要时通过HTTP请求任何JS模块，并在运行时进行处理。Vite开发服务器将按需转换任何文件（如Sass、TypeScript、SFC）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种架构避免了服务器端对整个应用的捆绑，并利用浏览器高效的模块处理，提供了一个明显更快的开发服务器。&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;提示：当你对应用程序进行code-split和tree-shake动时，Vite的速度会更快，因为它只加载它需要的模块，即使是在开发阶段。这与Webpack不同，在Webpack中，代码拆分只对生产包有利。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Vite的缺点&lt;/h2&gt;&lt;section&gt;&lt;span&gt;你可能已经明白了，Vite的主要特点是它的开发服务器快得离谱。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果没有这个功能，可能就不会再讨论了，因为与Vue CLI相比，它确实没有其他的功能，而且确实有一些缺点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于Vite使用了JavaScript模块，所以最好让依赖关系也使用JavaScript模块。虽然大多数现代JS包都提供了这一点，但一些老的包可能只提供CommonJS模块。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Vite可以将CommonJS转换为JavaSript模块，但在一些边缘情况下它可能无法做到。当然，它还需要支持JavaScript模块的浏览器。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;与Webpack/Vue CLI不同，Vite无法创建针对旧版浏览器、web components等的捆绑包。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而且，与Vue CLI不同，开发服务器和构建工具是不同的系统，导致在生产与开发中可能出现不一致的行为。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Vue CLI vs Vite总结&lt;/h2&gt;&lt;table data-tool=&quot;mdnice编辑器&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;Vue CLI 优点&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Vue CLI 缺点&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;经历过战斗考验，可靠&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;开发服务器速度与依赖数量成反比&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;与Vue 2兼容&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;可以捆绑任何类型的依赖关系&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;插件生态系统&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;可以针对不同的目标进行构建&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table data-tool=&quot;mdnice编辑器&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;Vite 优点&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Vite 缺点&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;开发服务器比Webpack快10-100倍&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;只能针对现代浏览器（ES2015+）&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;将code-splitting作为优先事项&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;与CommonJS模块不完全兼容&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;处于测试阶段，仅支持Vue 3&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;最小的脚手架不包括Vuex、路由器等&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;不同的开发服务器与构建工具&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;span&gt;那么判决结果是什么？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于有经验的Vue开发来说，Vite是一个很好的选择，因为它的开发服务器速度快得离谱，让Webpack看起来像史前时代。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，对于喜欢一些手把手的Vue新开发人员来说，或者，对于使用遗留模块和需要复杂构建的大型项目来说，Vue CLI很可能在目前仍然是必不可少的。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Vite的未来&lt;/h2&gt;&lt;section&gt;&lt;span&gt;虽然上面的比较主要集中在Vite和Vue CLI的现状上，但仍有几点需要考虑：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;仅当浏览器中的JavaScript模块支持得到改善时，Vite才会有所改善。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;随着JS生态系统的追赶，更多的软件包将支持JavaScript模块，减少Vite无法处理的边缘情况。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Vite仍处于测试阶段--功能可能会有变化。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有可能Vue CLI最终会结合Vite，这样你就不用再使用其中一个了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;值得注意的是，Vite并不是唯一一个利用浏览器中JavaScript模块的开发服务器项目。还有更著名的 &lt;strong&gt;Snowpack&lt;/strong&gt; 甚至可能会挤掉Vite的发展。时间会证明这一点&lt;br/&gt;Snowpack：https://www.snowpack.dev/&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原文：https://vuejsdevelopers.com/2020/12/07/vite-vue-cli/&lt;br/&gt;作者：Anthony Gore&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;粉丝福利&lt;/h4&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;144期留言+在看幸运用户：暂无&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;临走前留下，&lt;span&gt;今天的福利&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;福利1：&lt;/span&gt;&lt;span&gt;&lt;span&gt;《教你玩转手机摄影，随手拍出好照片》&lt;/span&gt;&lt;span&gt;获取资源请在公众号对话框中回复关键字：&lt;/span&gt;&lt;span&gt;FL04，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;如果没有关注请扫下面的二维码&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;福利2：&lt;/span&gt;&lt;span&gt;在看+留言&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;我随机抽取一位认真留言的小伙伴，给他发一个红包奖励&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;最近文章&lt;/h4&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;点赞 + 在看 + 留言，下一个幸运儿就是你！&lt;br/&gt;走心的分享更容易被抽中~&lt;/span&gt;&lt;br/&gt;&lt;span&gt;开奖时间 下期文末&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5555555555555556&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0APOE4dXIpvXLgmGfqHMfYFFGudrHkx4trR7YbXKKmNCd3fJRlY56qIUibCibq00k2kky5DdPxrJCyWA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-type=&quot;gif&quot; data-ratio=&quot;0.1732283464566929&quot; data-w=&quot;635&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/aVp1YC8UV0fXSy8oK0h6qL36nlWgib6lHDTj0Ykkiab2FufBJIumwMrDEBZ1wHteh6pzsQiaP4007ox4ichic8pNw3Q/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b64bf80481fe3bc166db8cd2eb43cbc8</guid>
<title>互联网已经干得很好的事情，不应该是区块链干的</title>
<link>https://toutiao.io/k/gm708zx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;万向区块链&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;gh_1b8639a25429&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;2015年, 中国万向控股开始在区块链技术领域布局，成立了中国首个非营利性区块链研究机构“万向区块链实验室”。2017年，在进一步整合资源的基础上，上海万向区块链股份公司正式成立。&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bc833fec544aefcb4a5319e0500a2d29</guid>
<title>真的理解 Go interface 了吗？</title>
<link>https://toutiao.io/k/0nfqg7g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我想，对于各位使用面向对象编程的程序员来说，&quot;接口&quot;这个名词一定不陌生，比如java中的接口以及c++中的虚基类都是接口的实现。但是&lt;code&gt;golang&lt;/code&gt;中的接口概念与其他语言不同，有它自己的特点，下面我们就来一起解密。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;定义&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言中的接口是一组方法的签名，它是 Go 语言的重要组成部分。简单的说，interface是一组method签名的组合，我们通过interface来定义对象的一组行为。&lt;strong&gt;interface 是一种类型&lt;/strong&gt;，定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Person &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt;    Eat(food &lt;span&gt;string&lt;/span&gt;) &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的定义可以看出来用了 type 关键字，更准确的说 interface 是一种&lt;strong&gt;具有一组方法的类型&lt;/strong&gt;，这些方法定义了 interface 的行为。&lt;code&gt;golang&lt;/code&gt;接口定义不能包含变量，但是允许不带任何方法，这种类型的接口叫&lt;code&gt;empty interface&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果一个类型实现了一个&lt;code&gt;interface&lt;/code&gt;中所有方法，我们就可以说该类型实现了该&lt;code&gt;interface&lt;/code&gt;，所以我们我们的所有类型都实现了&lt;code&gt;empty interface&lt;/code&gt;，因为任何一种类型至少实现了0个方法。并且&lt;code&gt;go&lt;/code&gt;中并不像&lt;code&gt;java&lt;/code&gt;中那样需要显式关键字来实现&lt;code&gt;interface&lt;/code&gt;，只需要实现&lt;code&gt;interface&lt;/code&gt;包含的方法即可。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里先拿&lt;code&gt;java&lt;/code&gt;语言来举例，在&lt;code&gt;java&lt;/code&gt;中，我们要实现一个&lt;code&gt;interface&lt;/code&gt;需要这样声明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyWriter&lt;/span&gt; &lt;span&gt;implments&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;Writer&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就意味着对于接口的实现都需要显示声明，在代码编写方面有依赖限制，同时需要处理包的依赖，而在&lt;code&gt;Go&lt;/code&gt;语言中实现接口就是隐式的，举例说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; error &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Error() &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; RPCError &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Code    &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt; Message &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(e *RPCError)&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; fmt.Sprintf(&lt;span&gt;&quot;%s, code=%d&quot;&lt;/span&gt;, e.Message, e.Code)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码，并没有&lt;code&gt;error&lt;/code&gt;接口的影子，我们只需要实现&lt;code&gt;Error() string&lt;/code&gt;方法就实现了&lt;code&gt;error&lt;/code&gt;接口。在&lt;code&gt;Go&lt;/code&gt;中，实现接口的所有方法就隐式地实现了接口。我们使用上述 &lt;code&gt;RPCError&lt;/code&gt; 结构体时并不关心它实现了哪些接口，Go 语言只会在传递参数、返回参数以及变量赋值时才会对某个类型是否实现接口进行检查。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Go&lt;/code&gt;语言的这种写法很方便，不用引入包依赖。但是&lt;code&gt;interface&lt;/code&gt;底层实现的时候会动态检测也会引入一些问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;性能下降。使用interface作为函数参数，runtime 的时候会动态的确定行为。使用具体类型则会在编译期就确定类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不能清楚的看出struct实现了哪些接口，需要借助ide或其它工具。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;两种接口&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里大多数刚入门的同学肯定会有疑问，怎么会有两种接口，因为&lt;code&gt;Go&lt;/code&gt;语言中接口会有两种表现形式，使用&lt;code&gt;runtime.iface&lt;/code&gt;表示第一种接口，也就是我们上面实现的这种，接口中定义方法；使用&lt;code&gt;runtime.eface&lt;/code&gt;表示第二种不包含任何方法的接口，第二种在我们日常开发中经常使用到，所以在实现时使用了特殊的类型。从编译角度来看，golang并不支持泛型编程。但还是可以用&lt;code&gt;interface{}&lt;/code&gt;  来替换参数，而实现泛型。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;interface内部结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言根据接口类型是否包含一组方法将接口类型分成了两类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;runtime.iface&lt;/code&gt; 结构体表示包含方法的接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;runtime.eface&lt;/code&gt; 结构体表示不包含任何方法的 &lt;code&gt;interface{}&lt;/code&gt; 类型；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;runtime.iface&lt;/code&gt;结构体在&lt;code&gt;Go&lt;/code&gt;语言中的定义是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; eface &lt;span&gt;struct&lt;/span&gt; { &lt;span&gt;// 16 字节&lt;/span&gt;&lt;br/&gt; _type *_type&lt;br/&gt; data  unsafe.Pointer&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里只包含指向底层数据和类型的两个指针，从这个&lt;code&gt;type&lt;/code&gt;我们也可以推断出Go语言的任意类型都可以转换成&lt;code&gt;interface&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个用于表示接口的结构体是 &lt;code&gt;runtime.iface&lt;/code&gt;，这个结构体中有指向原始数据的指针 &lt;code&gt;data&lt;/code&gt;，不过更重要的是 &lt;code&gt;runtime.itab&lt;/code&gt; 类型的 &lt;code&gt;tab&lt;/code&gt; 字段。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; iface &lt;span&gt;struct&lt;/span&gt; { &lt;span&gt;// 16 字节&lt;/span&gt;&lt;br/&gt; tab  *itab&lt;br/&gt; data unsafe.Pointer&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们一起看看&lt;code&gt;interface&lt;/code&gt;中这两个类型：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;runtime_type&lt;/code&gt;是 Go 语言类型的运行时表示。下面是运行时包中的结构体，其中包含了很多类型的元信息，例如：类型的大小、哈希、对齐以及种类等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; _type &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; size       &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt; ptrdata    &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt; hash       &lt;span&gt;uint32&lt;/span&gt;&lt;br/&gt; tflag      tflag&lt;br/&gt; align      &lt;span&gt;uint8&lt;/span&gt;&lt;br/&gt; fieldAlign &lt;span&gt;uint8&lt;/span&gt;&lt;br/&gt; kind       &lt;span&gt;uint8&lt;/span&gt;&lt;br/&gt; equal      &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(unsafe.Pointer, unsafe.Pointer)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; gcdata     *&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt; str        nameOff&lt;br/&gt; ptrToThis  typeOff&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我只对几个比较重要的字段进行讲解：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;size&lt;/code&gt; 字段存储了类型占用的内存空间，为内存空间的分配提供信息；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;hash&lt;/code&gt; 字段能够帮助我们快速确定类型是否相等；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;equal&lt;/code&gt; 字段用于判断当前类型的多个对象是否相等，该字段是为了减少 Go 语言二进制包大小从 &lt;code&gt;typeAlg&lt;/code&gt; 结构体中迁移过来的)；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;runtime_itab&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;runtime.itab&lt;/code&gt;结构体是接口类型的核心组成部分，每一个 &lt;code&gt;runtime.itab&lt;/code&gt; 都占 32 字节，我们可以将其看成接口类型和具体类型的组合，它们分别用 &lt;code&gt;inter&lt;/code&gt; 和 &lt;code&gt;_type&lt;/code&gt; 两个字段表示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; itab &lt;span&gt;struct&lt;/span&gt; { &lt;span&gt;// 32 字节&lt;/span&gt;&lt;br/&gt; inter *interfacetype&lt;br/&gt; _type *_type&lt;br/&gt; hash  &lt;span&gt;uint32&lt;/span&gt;&lt;br/&gt; _     [&lt;span&gt;4&lt;/span&gt;]&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt; fun   [&lt;span&gt;1&lt;/span&gt;]&lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;inter&lt;/code&gt;和&lt;code&gt;_type&lt;/code&gt;是用于表示类型的字段，&lt;code&gt;hash&lt;/code&gt;是对&lt;code&gt;_type.hash&lt;/code&gt;的拷贝，当我们想将 &lt;code&gt;interface&lt;/code&gt; 类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型 &lt;code&gt;runtime._type&lt;/code&gt;是否一致，&lt;code&gt;fun&lt;/code&gt;是一个动态大小的数组，它是一个用于动态派发的虚函数表，存储了一组函数指针。虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以 &lt;code&gt;fun&lt;/code&gt; 数组中保存的元素数量是不确定的；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内部结构就做一个简单介绍吧，有兴趣的同学可以自行深入学习。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;空的interface（&lt;code&gt;runtime.eface&lt;/code&gt;）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前文已经介绍了什么是空的&lt;code&gt;interface&lt;/code&gt;，下面我们来看一看空的&lt;code&gt;interface&lt;/code&gt;如何使用。定义函数入参如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doSomething&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt;{    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个函数的入参是&lt;code&gt;interface&lt;/code&gt;类型，要注意的是，&lt;code&gt;interface&lt;/code&gt;类型不是任意类型，他与C语言中的&lt;code&gt;void *&lt;/code&gt;不同，如果我们将类型转换成了 &lt;code&gt;interface{}&lt;/code&gt; 类型，变量在运行期间的类型也会发生变化，获取变量类型时会得到 &lt;code&gt;interface{}&lt;/code&gt;，之所以函数可以接受任何类型是在 go 执行时传递到函数的任何类型都被自动转换成 &lt;code&gt;interface{}&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们可以才来一个猜想，既然空的 interface 可以接受任何类型的参数，那么一个 &lt;code&gt;interface{}&lt;/code&gt;类型的 slice 是不是就可以接受任何类型的 slice ？下面我们就来尝试一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;printStr&lt;/span&gt;&lt;span&gt;(str []&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, val := &lt;span&gt;range&lt;/span&gt; str {&lt;br/&gt;  fmt.Println(val)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt; names := []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;stanley&quot;&lt;/span&gt;, &lt;span&gt;&quot;david&quot;&lt;/span&gt;, &lt;span&gt;&quot;oscar&quot;&lt;/span&gt;}&lt;br/&gt; printStr(names)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面代码，会出现如下错误：&lt;code&gt;./main.go:15:10: cannot use names (type []string) as type []interface {} in argument to printStr&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我也是很疑惑，为什么&lt;code&gt;Go&lt;/code&gt;没有帮助我们自动把&lt;code&gt;slice&lt;/code&gt;转换成&lt;code&gt;interface&lt;/code&gt;类型的&lt;code&gt;slice&lt;/code&gt;，之前做项目就想这么用，结果失败了。后来我终于找到了答案，有兴趣的可以看看原文，这里简单总结一下：&lt;code&gt;interface&lt;/code&gt;会占用两个字长的存储空间，一个是自身的 methods 数据，一个是指向其存储值的指针，也就是 interface 变量存储的值，因而 slice []interface{} 其长度是固定的&lt;code&gt;N*2&lt;/code&gt;，但是 []T 的长度是&lt;code&gt;N*sizeof(T)&lt;/code&gt;，两种 slice 实际存储值的大小是有区别的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然这种方法行不通，那可以怎样解决呢？我们可以直接使用元素类型是interface的切片。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; dataSlice []&lt;span&gt;int&lt;/span&gt; = foo()&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; interfaceSlice []&lt;span&gt;interface&lt;/span&gt;{} = &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;interface&lt;/span&gt;{}, &lt;span&gt;len&lt;/span&gt;(dataSlice))&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i, d := &lt;span&gt;range&lt;/span&gt; dataSlice {&lt;br/&gt; interfaceSlice[i] = d&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;非空&lt;code&gt;interface&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Go&lt;/code&gt;语言实现接口时，既可以结构体类型的方法也可以是使用指针类型的方法。&lt;code&gt;Go&lt;/code&gt;语言中并没有严格规定实现者的方法是值类型还是指针，那我们猜想一下，如果同时使用值类型和指针类型方法实现接口，会有什么问题吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看这样一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Person &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; GetAge () &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; SetAge (&lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Man &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; Age &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(s Man)&lt;/span&gt; &lt;span&gt;GetAge&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; s.Age&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(s *Man)&lt;/span&gt; &lt;span&gt;SetAge&lt;/span&gt;&lt;span&gt;(age &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s.Age = age&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(p Person)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt; p.SetAge(&lt;span&gt;10&lt;/span&gt;)&lt;br/&gt; fmt.Println(p.GetAge())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; p := Man{}&lt;br/&gt; f(&amp;amp;p) &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上面的代码，大家对&lt;code&gt;f(&amp;amp;p)&lt;/code&gt;这里的入参是否会有疑问呢？如果不取地址，直接传过去会怎么样？试了一下，编译错误如下：&lt;code&gt;./main.go:34:3: cannot use p (type Man) as type Person in argument to f: Man does not implement Person (SetAge method has pointer receiver)&lt;/code&gt;。透过注释我们可以看到，因为&lt;code&gt;SetAge&lt;/code&gt;方法的&lt;code&gt;receiver&lt;/code&gt;是指针类型，那么传递给&lt;code&gt;f&lt;/code&gt;的是&lt;code&gt;P&lt;/code&gt;的一份拷贝，在进行&lt;code&gt;p&lt;/code&gt;的拷贝到&lt;code&gt;person&lt;/code&gt;的转换时，&lt;code&gt;p&lt;/code&gt;的拷贝是不满足&lt;code&gt;SetAge&lt;/code&gt;方法的&lt;code&gt;receiver&lt;/code&gt;是个指针类型，这也正说明一个问题&lt;strong&gt;go中函数都是按值传递&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子是因为发生了值传递才会导致出现这个问题。实际上不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Animal &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Walk()&lt;br/&gt; Eat()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Dog &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(d *Dog)&lt;/span&gt;&lt;span&gt;Walk&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;go&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(d *Dog)&lt;/span&gt;&lt;span&gt;Eat&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;eat shit&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d Animal = &amp;amp;Dog{&lt;span&gt;&quot;nene&quot;&lt;/span&gt;}&lt;br/&gt; d.Eat()&lt;br/&gt; d.Walk()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面定义了一个接口&lt;code&gt;Animal&lt;/code&gt;，接口定义了两个函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Walk()&lt;br/&gt;Eat()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着定义了一个结构体&lt;code&gt;Dog&lt;/code&gt;，他实现了两个方法，一个是值接受者，一个是指针接收者。我们通过接口类型的变量调用了定义的两个函数是没有问题的，如果我们改成这样呢：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d Animal = Dog{&lt;span&gt;&quot;nene&quot;&lt;/span&gt;}&lt;br/&gt; d.Eat()&lt;br/&gt; d.Walk()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样直接就会报错，我们只改了一部分，第一次将&lt;code&gt;&amp;amp;Dog{&quot;nene&quot;}&lt;/code&gt;赋值给了&lt;code&gt;d&lt;/code&gt;；第二次则将&lt;code&gt;Dog{&quot;nene&quot;}&lt;/code&gt;赋值给了&lt;code&gt;d&lt;/code&gt;。第二次报错是因为，&lt;code&gt;d&lt;/code&gt;没有实现&lt;code&gt;Animal&lt;/code&gt;。这正解释了上面的结论，所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一句话就是：&lt;strong&gt;如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类型断言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个&lt;code&gt;interface&lt;/code&gt;被多种类型实现时，有时候我们需要区分&lt;code&gt;interface&lt;/code&gt;的变量究竟存储哪种类型的值，&lt;code&gt;go&lt;/code&gt;可以使用&lt;code&gt;comma,ok&lt;/code&gt;的形式做区分 &lt;code&gt;value, ok := em.(T)&lt;/code&gt;：&lt;strong&gt;em 是 interface 类型的变量，T代表要断言的类型，value 是 interface 变量存储的值，ok 是 bool 类型表示是否为该断言的类型 T&lt;/strong&gt;。总结出来语法如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;目标类型的值&amp;gt;，&amp;lt;布尔参数&amp;gt; := &amp;lt;表达式&amp;gt;.( 目标类型 ) &lt;span&gt;// 安全类型断言&lt;/span&gt;&lt;br/&gt;&amp;lt;目标类型的值&amp;gt; := &amp;lt;表达式&amp;gt;.( 目标类型 )  &lt;span&gt;//非安全类型断言&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看个简单的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Dog &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d &lt;span&gt;interface&lt;/span&gt;{} = &lt;span&gt;new&lt;/span&gt;(Dog)&lt;br/&gt; d1,ok := d.(Dog)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !ok{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; fmt.Println(d1)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种就属于安全类型断言，更适合在线上代码使用，如果使用非安全类型断言会怎么样呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Dog &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d &lt;span&gt;interface&lt;/span&gt;{} = &lt;span&gt;new&lt;/span&gt;(Dog)&lt;br/&gt; d1 := d.(Dog)&lt;br/&gt; fmt.Println(d1)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就会发生错误如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;panic&lt;/span&gt;: &lt;span&gt;interface&lt;/span&gt; conversion: &lt;span&gt;interface&lt;/span&gt; {} is *main.Dog, not main.Dog&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断言失败。这里直接发生了 &lt;code&gt;panic&lt;/code&gt;，所以不建议线上代码使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看过&lt;code&gt;fmt&lt;/code&gt;源码包的同学应该知道，&lt;code&gt;fmt.println&lt;/code&gt;内部就是使用到了类型断言，有兴趣的同学可以自行学习。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面介绍了&lt;code&gt;interface&lt;/code&gt;的基本使用方法及可能会遇到的一些问题，下面出三个题，看看你们真的掌握了吗？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题一&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面代码，哪一行存在编译错误？（多选）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Student &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;&lt;span&gt;(x &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(x *&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := Student{}&lt;br/&gt; p := &amp;amp;s&lt;br/&gt; &lt;span&gt;// A B C D&lt;/span&gt;&lt;br/&gt; Set(s)&lt;br/&gt; Get(s)&lt;br/&gt; Set(p)&lt;br/&gt; Get(p)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：B、D；解析：我们上文提到过，&lt;code&gt;interface&lt;/code&gt;是所有&lt;code&gt;go&lt;/code&gt;类型的父类，所以&lt;code&gt;Get&lt;/code&gt;方法只能接口&lt;code&gt;*interface{}&lt;/code&gt;类型的参数，其他任何类型都不可以。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题二&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的运行结果是什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;PrintInterface&lt;/span&gt;&lt;span&gt;(val &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; val == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;this is empty interface&quot;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;this is non-empty interface&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; pointer *&lt;span&gt;string&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; PrintInterface(pointer)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：&lt;code&gt;this is non-empty interface&lt;/code&gt;。解析：这里的&lt;code&gt;interface{}&lt;/code&gt;是空接口类型，他的结构如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; eface &lt;span&gt;struct&lt;/span&gt; { &lt;span&gt;// 16 字节&lt;/span&gt;&lt;br/&gt; _type *_type&lt;br/&gt; data  unsafe.Pointer&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在调用函数&lt;code&gt;PrintInterface&lt;/code&gt;时发生了&lt;strong&gt;隐式的类型转换&lt;/strong&gt;，除了向方法传入参数之外，变量的赋值也会触发隐式类型转换。在类型转换时，&lt;code&gt;*string&lt;/code&gt;类型会转换成&lt;code&gt;interface&lt;/code&gt;类型，发生值拷贝，所以&lt;code&gt;eface struct{}&lt;/code&gt;是不为&lt;code&gt;nil&lt;/code&gt;，不过&lt;code&gt;data&lt;/code&gt;指针指向的&lt;code&gt;poniter&lt;/code&gt;为&lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题三&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的运行结果是什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Animal &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Walk()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Dog &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(d *Dog)&lt;/span&gt; &lt;span&gt;Walk&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;walk&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewAnimal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d *Dog&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; NewAnimal() == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;this is empty interface&quot;&lt;/span&gt;)&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;this is non-empty interface&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：&lt;code&gt;this is non-empty interface&lt;/code&gt;. 解析：这里的&lt;code&gt;interface&lt;/code&gt;是非空接口&lt;code&gt;iface&lt;/code&gt;，他的结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; iface &lt;span&gt;struct&lt;/span&gt; { &lt;span&gt;// 16 字节&lt;/span&gt;&lt;br/&gt; tab  *itab&lt;br/&gt; data unsafe.Pointer&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;d&lt;/code&gt;是一个指向nil的空指针，但是最后&lt;code&gt;return d&lt;/code&gt; 会触发&lt;code&gt;匿名变量 Animal = p&lt;/code&gt;值拷贝动作，所以最后&lt;code&gt;NewAnimal()&lt;/code&gt;返回给上层的是一个&lt;code&gt;Animal interface{}&lt;/code&gt;类型，也就是一个&lt;code&gt;iface struct{}&lt;/code&gt;类型。&lt;code&gt;p&lt;/code&gt;为nil，只是&lt;code&gt;iface&lt;/code&gt;中的data 为nil而已。但是&lt;code&gt;iface struct{}&lt;/code&gt;本身并不为nil.&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;interface&lt;/code&gt;在我们日常开发中使用还是比较多，所以学好它还是很必要，希望这篇文章能让你对&lt;code&gt;Go&lt;/code&gt;语言的接口有一个新的认识，这一篇到这里结束啦，我们下期见～～～。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;建了一个Golang交流群，欢迎大家的加入，第一时间观看优质文章，不容错过哦（公众号获取）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;翻译了一份Machinery中文文档，会定期进行维护，有需要的小伙伴们后台回复[machinery]即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是asong，一名普普通通的程序猿，让gi我一起慢慢变强吧。我自己建了一个&lt;code&gt;golang&lt;/code&gt;交流群，有需要的小伙伴加我&lt;code&gt;vx&lt;/code&gt;,我拉你入群。欢迎各位的关注，我们下期见~~~&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/k5430ljpYPOmuIQZOVTBeKxpAj6UrBVNg9sYvXGwKkGS7YlMsW06Khia74N8U6J8VRaBd9WNIUCthcPH85fPnnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐往期文章：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>00104a4e5ba7ead9af036ccb841613d1</guid>
<title>DataVisor 创始人谢映莲：智能生意应坚守数据道德，性别偏见存在但可以克服</title>
<link>https://toutiao.io/k/3pou4xw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;恐惧于一眼到底的人生&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;放弃教职加入微软&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;2005年，谢映莲完成卡内基梅隆计算机专业的博士学位，开始纠结于未来选择。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;卡内基梅隆位于美国匹兹堡，是计算机工业最初的推动者之一，计算机专业排名高居全美第二。有别于硅谷“技术创新+商业模式+金融资本”构成的自由氛围，匹兹堡的空气中弥漫着Old-School的保守醇香，“留在学界获得教职是更被尊敬的选择，不能留在学校的人才会考虑进入工业界。谷歌最早期的员工中有一位就是我导师带过的学生，他在商业领域取得了巨大成就，但导师一直很遗憾没能留住他任教”。在这样的氛围熏陶之下，谢映莲也拿到了一些大学的教职录取资格，但她迟迟没有下定决心：“一方面，我希望做学术研究，学院体系内部有着优良的学术环境；可另一方面，教职这条路一眼看得到头，做研究、发paper、拿到终身教职、做一辈子研究、发一辈子paper……一毕业就能看到自己退休的样子，这让我有些害怕。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最终，谢映莲做出了一个相对折衷的选择：在众多邀请中选择加入位于硅谷的微软研究院，“做学术研究、技术研究的同时，也能近距离观察工业界的运转模式。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“稳定”与“可能性”，每个人成长过程中都要面临的选择题，谢映莲选择了后者。这份发自心底的自信与好奇心，注定她日后会走上创业之路。但在当年走进微软研究院的她，对自己的定位还是一位学术研究者，在那里，她的30多位同事无一不是计算机某一领域内的顶级大牛，仅图灵奖得主就有三人。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;让人意想不到的是，大牛、巨佬环伺之下，这位被同事视作初丁的年轻人，迅速折腾出了一份巨大的声浪。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;遇见世界上另一个自己&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;微软经历奠定创业坚实基础&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;谢映莲对微软研究院有两个深刻的第一印象，“一是拿着螺丝刀给你装机器的人，是整个团队的director；二是他不负责指派工作，要自力更生，每个人都要找到自己感兴趣的项目去做”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进入微软的第一个月，谢映莲先是尝试与团队的多位前辈大牛进行沟通，发现他们正在进行的项目并非自己志趣所在。也正是在这段时间里，她意外收获了自己的灵魂伴侣、至交好友，也是日后的创业搭档，同样来自江苏的俞舫。二人兴趣、背景接近，略一商议，决定合作创立一个网络信息安全项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一决定最初并不被团队内的前辈与同事看好，大家很友善地提醒她们，团队里有很多位资历极深、地位极高的巨咖，可以学习一下再考虑独立，但谢俞二人心意已决，项目旋即启动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;出乎众人意料，仅仅半年之后，她们合作的论文便以极高的初审分数、“没有经过激烈的辩论讨论”便被全球顶级会议SIGCOMM收录，谢俞搭档在短短时间内取得了显著成绩令同事们刮目相看，“对于新加入的同事，大家本能地会观察一段时间，但只要你能展现出足够的能力，大家便会发自内心的祝贺并尊重你”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来7年，谢俞团队将大数据与大规模并行计算算法相结合，围绕“新的并行计算算法为安全反欺诈领域带来的革新”这一命题发表了大量论文，逐渐打造出了一套兼具技术核心竞争力和应用场景价值的数据智能体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了在学术领域不断精进，在这7年时间里，谢映莲和俞舫还锻炼出了相当不俗的沟通、推广等能力，“项目做大了，要寻找能够解决实际问题、有意义的课题，需要跟微软内部不同产品部门的同事打交道，要自己招实习生、创建和高校的合作……微软每年还有一个展会，研究院的各个项目组要向微软的工业体系介绍自己的项目，本质上是一次市场推广。现在想起来，在微软研究院这7年中培养了自己多方面的能力，比如沟通能力、合作能力、技术与商业价值场景结合的思维能力等等。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;强劲地向上成长，同时也不断刺激着内在自我认知的觉醒，谢映莲越来越清楚地意识到，研究领域与工业领域在很多地方存在明显脱节，她的兴趣逐渐从学术项目转向思考科技如何为工业界产生价值，怎样才能缩短工业界落地产品与最顶尖科技之间的距离、让技术落地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;显然，实现这一愿景不能只靠发论文、做项目，谢映莲不得不正视一个事实：微软研究院体系已经无法承载自己的梦想。在研究院的最后两年中，一面是难以施展抱负的委屈，一面是外界不断抛来的橄榄枝，许多公司找到谢俞团队——包括Yelp，询问“把数据给你们，希望你们帮助分析”的可能性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“继续从事科研，无非是一年再发几篇paper，这对我们的吸引力已经没有那么强了，我相信我们可以做更大的事情，这种想法，促使我们彻底迈出创业这一步。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2013年感恩节，谢映莲、俞舫告别微软研究院。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;没有投资、没有产品、没有团队，甚至没有一份成型的商业计划书——彻底到不能再彻底的裸辞。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;创业第一个冬天&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;被跳闸暖气冻伤的热情&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;2013年，DataVisor创建，次年成为陌陌的网络安全服务商。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2015年9月，DataVisor完成一轮来自金沙江创投和恩颐投资（NEA）的融资。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2016年，滴滴投资人彭志坚决定投资&lt;span&gt;DataVisor&lt;/span&gt;，谢映莲第一反应“我们不需要融钱”……随后被说服，并决定正式进军中国市场。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2016年底，DataVisor分公司在北京成立，不到一年时间内先后与平安银行、京东、财付通、大众点评、阿里巴巴、陌陌等企业达成服务协议。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2018年，华尔街评选全球25家最具潜力初创，DataVisor 赫然在列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2019年，DataVisor在2019网络安全卓越大奖斩获六项大奖，谢映莲被评为网络安全北美“年度女性”金奖。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看着这条大跨步向前的发展时间线，让人难免好奇：2013年的那个冬天究竟发生了什么事，让DataVisor能够从没钱、没人、没产品的三无状态迅速启动？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大洋彼岸的爽快笑声自听筒传来：“其实我们那个冬天过得并不容易，创业是一件严肃的事情，创业起步还是非常艰苦的一个过程。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;谢俞二人的创业构想之简单，可以用“天真”来形容：“找一个能静下心思考事情的办公室，偏一点也好。不着急招很大的团队，先找客户，有客户明确意向买单了再考虑融资和下一步。虽然对创业没有特别具体的构想，但就是想做这件事情，之前也有一些表达过意向的客户，还有口头打招呼想投资的朋友，让我们对这件事情多少有些信心。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2013年冬天，旧金山多雨。在研究院那些年里，谢俞出差常去西雅图，对通往旧金山的道路并不熟悉，偶尔出行也以火车为交通工具。可独立创业之后，为了尽量多的面见客户，二人不得不一次次顶风冒雨驱车前往，“把我们累得够呛。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;遗憾的是，客户反馈与她们的期待落差甚大，“即便之前表示过兴趣，可一看你们就两个人、什么都没有，大家难免会担心，其实可以理解。那时算是真正体会到了，事业起步阶段客户这一关真的不容易过。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“在见客户的同时，有一位在一家大企业供职的朋友说比较看好我们的东西，没准他的公司可以把我们收购了。我和俞舫一核计，两个人从微软研究院出来是为了做一番事业，不是为了马上再去另一个大公司，这条路我们不考虑。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;屋漏偏逢连夜雨，便宜租来的办公室也跟着添乱，暖气、电脑一起用一定跳闸，要工作就不能开暖气，要暖和就得关电脑……两位习惯了微软研究院舒适环境的IT巾帼豪杰，面对创业之初的艰苦与挫折，坚定推进着梦想。在旧金山冬雨的午后，她们搓着手、哈着气写下代码、构建模式，微笑着彼此鼓励，乐观拥抱一切的不顺遂、不尽意，不为外界的干扰所动摇。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;生活总是奖励自信的强者。2014年初，旧金山一家咖啡店，谢映莲俞舫见到了陌陌创始人唐岩夫妇。对于这次见面她起初并没有抱太大希望，可唐岩夫妇却展示出了莫大的诚意与热情。彼时的陌陌已经出现成规模的欺诈现象，用户的迅猛增长使陌陌变成了被违法份子攻击的优选对象，而陌陌技术团队的注意力聚焦应对产品迅猛增长之上，没有余力解决安全问题。DataVisor利用无监督学习技术识别用户行为、预防欺诈等有害行为发生的技术方案，恰好与陌陌的需求完美契合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;客户到位的同时，融资与团队招募也取得了重大进展。谢俞二人的声名与学术成就吸引来了不少投资商， 同时随着数位技术大牛加盟团队，DataVisor突破了初创阶段，进入发展快车道。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DataVisor的工作并非微软期间研究的延续，但“推动科技进步”的使命感与创新精神一脉相承，这种创新精神七年间持续鼓舞谢、俞二人在研究领域实现重大突破，并被她们带入到DataVisor，持续推动团队保持科技前沿水平。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;持续创新的同时，DataVisor也非常重视工业界影响力，注重培养将新技术工业化并带向市场的转化能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“DataVisor团队的使命就是要把最前沿的科技带到工业界，这也是DataVisor和其他公司的区别之处——持续创新。比如特斯拉，也是在创新的同时又实实在在为工业界作出价值”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;合伙默契·性别偏见·数据道德&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在采访最后，《科创人》问到了三个相对敏感的问题。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;科创人：创业领域有一句俚语，“不要跟你的朋友合伙创业”，虽然有些极端但确实出现过友情与商业关系的冲突，您与俞舫的合作创业是否产生过类似的问题？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;谢映莲：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;业务技术层面肯定有过意见不一致、想法不同的情况，但通过长时间的合作，我们能够沟通和讨论来一起决定下一步。感情上也是非常要好的朋友，我们是技术上的同行、生活上的朋友，甚至老家都离得很近，性格也比较互补，我偏激进、性格相对外向，俞舫总是说“如果你面试的时候没有跳起来，那这个人一定不是你满意的”。她相对偏保守一些，我们搭档起来感觉很棒（笑）。其实最初我们考虑过，女性创业可能会遇到一些问题，所以我们也试着找了一些男性合伙人，不巧的是没有找到太合适的，我们看好的人对DataVisor兴趣不大，对DataVisor有兴趣的人我们又觉得方向不匹配。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;科创人：在IT领域女性从业者占比明显偏低，您如何看待这个现象？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;谢映莲：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;我认为性别偏见确实在一些情况下客观存在，这种偏见未必一定是恶意的，可总归会影响人们对一些事情的判断和看法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我自己的经历告诉我，要正视这些偏见的存在，偏见的严重性因人而异，无法对其严重性作出评价。我的想法是正视这些偏见的存在，但不要让偏见阻止你想做的事。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;科创人：DataVisor同时发力于中美两国市场，客观地说，两个市场对于数据安全的道德标准要求有差异，有人觉得数据应当更自由被使用，来产生更多价值，也有人说要更强力的保护好数据。DataVisor是否会在不同的市场中进行不同标准的操作？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;谢映莲：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;创建DataVisor的初心，是维护互联网信息安全，数据安全显然在此范围之内，所以我们一定不会跨过数据道德的边界，试探都不会，这是非黑即白的事情，是企业存在的底线。无论在全球任何一个市场，我们的行为原则都是一致的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>