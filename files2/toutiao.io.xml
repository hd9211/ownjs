<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>4ac48de0b9c9963a279123cf15380dbe</guid>
<title>我把这个软件，推荐给了总监</title>
<link>https://toutiao.io/k/9yex08q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是 yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天要来安利一款神器！「&lt;span&gt;uTools&lt;/span&gt;」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于我个人而言，它的用处在于：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;快速翻译&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;备忘录快贴&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;快速查找和打开文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Json 解析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;时间戳转换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;todo记录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等等等等，还有太多太多了，它有 100 多个插件！&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，这些功能别的软件或者网站也能提供，但是它一个就全有了！而且它简单、高效、跨平台！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26713947990543735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUoicIRQYBUQib245Ocmv2PX6VVbup3TAibNFmwnSnguYJK7CTibFa0LOScA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;846&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装了之后，通过 「&lt;span&gt;alt+空格&lt;/span&gt;」就可以唤出它，然后可以往输入框内粘贴文本、图片、截图、文件、文件夹等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我想打开 Chrome，直接alt+空格唤出，再输入 chrome 即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.13216957605985039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUFBZriavxPJwxJOYOq8TdXuRbc0mdhO4icLnUf6UiaCiciaZqx54RoqBug7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想听歌，那就网易云~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.13216957605985039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUZEKmfEfOpicPlu0qHKu4bHpupH4iaGorIqk9nuUhGMDVQe9FFoSnzO2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我现在截了个图，可以直接复制输入，然后可以查看 base64编码、另存为图片、也可以把这个图记录下来！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2518703241895262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUfsRiaMSAYT0c13RiaOJNSzf84AqxBwcQfMGP1OTo4FaPFQiboc7ruhLew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设今天看了 yes 的技术文章，里面有一段话说的很好，我就截图，然后点击添加到「备忘快贴」，图片还能备注（图中的yes6666就是备注），这样就临时记录下来了！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7506234413965087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUCzGUoCibM97IibzUOMIQhPxgWXjShMLzr7HseQRWYWlGYb1aA66O2ZibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后等晚上回去再整理成笔记就 OK 了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再比如我现在看英文 pdf，我想翻译一下，那非常简单，我&lt;span&gt;划词长按鼠标右键&lt;/span&gt;(默认是鼠标中键)就好了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7343234323432343&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUDiamEwOFZPPxLtBzZMLN7HnoHViaMh1C6Fl60aZxeswoYLhJduBemYyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;606&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以点出上图的&lt;span&gt;翻译&lt;/span&gt;，这样可以看多个网站的翻译结果！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5859375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUkpoSuxgAtJm6GXTorVJShic0633DJTrgNfqsgSf3y3CkfDJq0PFz7XA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;太方便了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要记录 todo 的事情，也很简单！直接 &lt;code&gt;alt+空格&lt;/code&gt; 唤出再输入 &lt;code&gt;todo&lt;/code&gt; 敲个回车即可！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7506234413965087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaURPvXKBabibPUq0mOukOMgO9Y6WILU42vPnTvkW4ZrDa7nnRDVib7GpXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再比如现在要对接一个接口，接口返回了一个 Json 字符串，那直接复制然后 &lt;code&gt;alt+空格&lt;/code&gt; 唤出，此时的界面就是这样的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3117206982543641&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUxUUQmHCLk9oxCxMcsAecgShJ6gFyDQQHWPUz8MkBqdOiaH8tKUaNNibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后敲个回车，就搞定啦！就是这么 easy！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7506234413965087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUT3zqMbjj3gPasHc9p8gCnLx8iaGYYTt4ic31HhNibypnYCbSCickyFeFjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再比如现在从数据库拿到了个时间戳，想看看到底是什么时候，那么直接复制然后 &lt;code&gt;alt+空格&lt;/code&gt; 唤出。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.371571072319202&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUviaKGydrEVgfKa7WyeXmWIfdUqCJzSNMibGy4M0FoKNIDXAeL7oh7bFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再敲个回车！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7506234413965087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUVyfmCa5IGajqXguJp3LwBuWBPlFnCn1hRSCia758pg4efN7DmBeh6KA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想从现在一个时间倒推一下时间戳，那也简单，&lt;span&gt;直接输入时间&lt;/span&gt;就行：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7506234413965087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaU7lZrsBzIwdBgibNBkN4SeXe1dBXvdIMNPgpF1jUL8q0zxYPM6zskrvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后它有很多插件，可以直接输入插件(拼音也ok)来搜：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19201995012468828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUR5xpztrYCbB8UFw6HNQdiaTKtRkI5850gjMLPycPENCOkUZkZBibxbHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7506234413965087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUVTzRjtGObtMfJPibwnztz8iaTvWqsXMWNghibWEWRydddHLuISKUpWJ8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一些文档插件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3929712460063898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUhFtkRUcJBhWibmAWu7M3O4IcWCuQ6IVoCdDrA0OtqOrZakLh0zVTTXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我要查 Linux 的 ps 命令：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7905236907730673&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUVA21wtUIG8U4ibfrJ3zyqzicJayxJUWe5ZesdjNqq3xubEb275OmUgxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么说，这波是不是很完美！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有&lt;span&gt;渣男语录&lt;/span&gt;，啧啧好骚啊！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6708229426433915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUAPChPEtVzicnjyibEfCLlzcF3r4sHQr5QmgJIKtsiaejSziakHlc9yApPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我还看到了啥&lt;/span&gt;？？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7506234413965087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUd8X20ODD700icIULUIUW50UeDf01TNT2BAabsOL9OlPJrCacFO6ib3Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像我这么正直的人，我是不会下载的！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9816849816849816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF6UIhGEVSf14dXaoibPG4iaUwtibObnscf80AJYXibDN8zrSgnOzDazMObDP6dkz9vewBWvDE1x2mYNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;273&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是我总监......&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插件太多了，你们就自己看吧！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官网：https://u.tools/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我也打包好了，windows、mac都有，后台直接回复「&lt;span&gt;uTools&lt;/span&gt;」即可下载！&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是yes，我们下篇见~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3ef3eb82d42795ef2acf59e8d3d7eb5c</guid>
<title>用 Go 实现配置中心（一）</title>
<link>https://toutiao.io/k/5ga4hr7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot;&gt;
&lt;h1 id=&quot;引言&quot;&gt;引言&lt;/h1&gt;
&lt;p&gt;源码见 &lt;a href=&quot;https://github.com/GotaX/go-config-server/tree/v0.1.0&quot;&gt;https://github.com/GotaX/go-config-server/tree/v0.1.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;只要接触过微服务的同学都知道, 配置管理不好, 运维真的压力山大. 过去呢, 我一直都首选 &lt;code&gt;spring-cloud-config-server&lt;/code&gt; 做配置服务器, 主要是因为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遗留了不少 Java 服务, 改造起来很费事&lt;/li&gt;
&lt;li&gt;它提供了 HTTP API, 不需要 SDK 也能接入其他服务&lt;/li&gt;
&lt;li&gt;自带多 Profile 组合的功能&lt;/li&gt;
&lt;li&gt;可以使用 Git 做存储, 方便版本管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过随着配置文件越写越多, 还是逐渐暴露出不少问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对 YAML 文件的解析有 &lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-config/issues/935&quot;&gt;BUG&lt;/a&gt;, 写 Kubernetes 配置的时候很头疼&lt;/li&gt;
&lt;li&gt;包含不少 spring 约定俗成的用法, 比如 &lt;code&gt;application.yml&lt;/code&gt; 下的配置会被全部导入, 无法只导入部分&lt;/li&gt;
&lt;li&gt;写 YAML 时, 字符串和数字有时无法很好区分. 写 JSON 时又太冗长.&lt;/li&gt;
&lt;li&gt;Java 服务的启动时间和内存占用都偏高 (相较于 Go).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之后也有持续关注这方面, 有几个人气较高的项目:&lt;/p&gt;

&lt;p&gt;这三个配置中心都是由大厂开发, 质量肯定有保证, 功能也很强大. 不过对于小团队来说还是太重量级了, 用起来会有不少运维压力.&lt;/p&gt;
&lt;p&gt;长期观望无果, 所以最终还是决定自己实现一个. 先总结一下最核心的需求点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置一定要有版本管理, 能追溯历史 (Git)&lt;/li&gt;
&lt;li&gt;分布式存储, 避免单点故障 (Git)&lt;/li&gt;
&lt;li&gt;能很方便地复用公共配置 (比如数据库 DataSource)&lt;/li&gt;
&lt;li&gt;简洁的配置语法, 适当的校验 (JSON 太冗长, YAML 容易出错)&lt;/li&gt;
&lt;li&gt;多环境支持 (生产/测试环境)&lt;/li&gt;
&lt;li&gt;轻量级 (最小化运维压力)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1~2 条由于 Git 本身就是一个分布式版本管理工具, 所以就不用自己实现了.&lt;/p&gt;
&lt;p&gt;3~5 条自己从头搞有点麻烦, 不过我很幸运地找到一个配置专用语言 &lt;a href=&quot;https://jsonnet.org/&quot;&gt;Jsonnet&lt;/a&gt;, 所以就直接拿来用咯.&lt;/p&gt;
&lt;p&gt;好了, 背景介绍完毕, 下面正式开始吧.&lt;/p&gt;
&lt;h1 id=&quot;接口定义&quot;&gt;接口定义&lt;/h1&gt;
&lt;p&gt;首先我们来定义 HTTP API, 这里采用和 &lt;code&gt;spring-cloud-config-server&lt;/code&gt;差不多的格式.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;GET /:namespace/:filepath&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;namespace&lt;/td&gt;
&lt;td&gt;命名空间, Git 中就是分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;filepath&lt;/td&gt;
&lt;td&gt;配置文件路径, 相对于 Git 仓库根目录. 后缀代表返回内容格式, 比如 (&lt;code&gt;.json&lt;/code&gt; 和 &lt;code&gt;.yaml&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;接着我们来梳理下最小工作流程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从底层存储读取读取配置文件模板&lt;/li&gt;
&lt;li&gt;将配置文件模板渲染为目标格式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从上面的流程中我们可以抽象出两个接口:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/storage/storage.go
&lt;/span&gt;&lt;span&gt;// 底层存储接口
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Storage&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
    &lt;span&gt;// 切换命名空间, 类似于 MySQL 中的 use
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;Use&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;namespace&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) (&lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;)
    &lt;span&gt;// 读取文件内容
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;Read&lt;/span&gt;(&lt;span&gt;path&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) (&lt;span&gt;content&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;)
}

&lt;span&gt;// pkg/storage/render.go
&lt;/span&gt;&lt;span&gt;// 模板渲染接口
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Renderer&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
    &lt;span&gt;// 执行渲染, entry 为入口文件, outputType 为目标格式
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;Render&lt;/span&gt;(&lt;span&gt;entry&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;outputType&lt;/span&gt; &lt;span&gt;ContentType&lt;/span&gt;) (&lt;span&gt;doc&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;)
}

&lt;span&gt;// ContentType 的定义
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;ContentType&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; (
&lt;span&gt;Unknown&lt;/span&gt; &lt;span&gt;ContentType&lt;/span&gt; = &lt;span&gt;iota&lt;/span&gt;
&lt;span&gt;JSON&lt;/span&gt;
&lt;span&gt;YAML&lt;/span&gt;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不过第一版是最小可用版本, 我们先把多格式输出放一边, 一律输出为 JSON. 下面来逐个实现这两个接口吧.&lt;/p&gt;
&lt;h1 id=&quot;接口实现&quot;&gt;接口实现&lt;/h1&gt;
&lt;h2 id=&quot;jsonnet-渲染器&quot;&gt;Jsonnet 渲染器&lt;/h2&gt;
&lt;p&gt;先简单介绍下 Jsonnet. 上面之所以称其为配置语言, 是因为它并不是一个简单的静态配置, 而是一个实打实的函数式语言. 并且它是 JSON 的超集, 所以任何合法的 JSON 都是合法的 Jsonnet.&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;下面摘录一段&lt;a href=&quot;https://jsonnet.org/ref/language.html&quot;&gt;官网介绍&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Jsonnet 被设计用于处理复杂系统的配置. 标准用例是用于集成多个相互独立的服务. 独立的编写每个配置将会导致大量的重复, 并且极有可能变得难以维护. Jsonnet 使您可以根据自己的条件指定配置, 并以编程的方式配置所有独立的服务.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再看一个示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsonnet&quot; data-lang=&quot;jsonnet&quot;&gt;// Edit me!
{
  person1: {
    name: &quot;Alice&quot;,
    welcome: &quot;Hello &quot; + self.name + &quot;!&quot;,
  },
  person2: self.person1 { name: &quot;Bob&quot; },
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面配置可以渲染为如下 JSON:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;{
  &lt;span&gt;&quot;person1&quot;&lt;/span&gt;: {
    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;Alice&quot;&lt;/span&gt;,
    &lt;span&gt;&quot;welcome&quot;&lt;/span&gt;: &lt;span&gt;&quot;Hello Alice!&quot;&lt;/span&gt;
  },
  &lt;span&gt;&quot;person2&quot;&lt;/span&gt;: {
    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;Bob&quot;&lt;/span&gt;,
    &lt;span&gt;&quot;welcome&quot;&lt;/span&gt;: &lt;span&gt;&quot;Hello Bob!&quot;&lt;/span&gt;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们已经对 Jsonnet 有了基本的认知, 就不继续深入了. 如果想详细了解, 可以看官网教程, 或者等我之后再写一些介绍文章.&lt;/p&gt;
&lt;p&gt;下面开始动手写实现, 这里我们使用 &lt;a href=&quot;https://github.com/google/go-jsonnet&quot;&gt;go-jsonnet&lt;/a&gt; 这个库来运行 Jsonnet 代码.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/render/jsonnet.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;import&lt;/span&gt; (
. &lt;span&gt;&quot;github.com/google/go-jsonnet&quot;&lt;/span&gt;
)

&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Jsonnet&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
&lt;span&gt;Importer&lt;/span&gt; &lt;span&gt;Importer&lt;/span&gt;
}

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;r&lt;/span&gt; &lt;span&gt;Jsonnet&lt;/span&gt;) &lt;span&gt;Render&lt;/span&gt;(&lt;span&gt;entry&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;outputType&lt;/span&gt; &lt;span&gt;ContentType&lt;/span&gt;) (&lt;span&gt;doc&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) {
&lt;span&gt;vm&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;MakeVM&lt;/span&gt;()          &lt;span&gt;// 新建虚拟机
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;vm&lt;/span&gt;.&lt;span&gt;Importer&lt;/span&gt;(&lt;span&gt;r&lt;/span&gt;.&lt;span&gt;Importer&lt;/span&gt;) &lt;span&gt;// 替换默认的文件存储, 之后会把 Git 挂载进来
&lt;/span&gt;&lt;span/&gt;
&lt;span&gt;doc&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;vm&lt;/span&gt;.&lt;span&gt;EvaluateFile&lt;/span&gt;(&lt;span&gt;entry&lt;/span&gt;) &lt;span&gt;// 指定入口文件, 执行渲染
&lt;/span&gt;&lt;span/&gt;    
    &lt;span&gt;// TODO: 之后在这里实现多格式输出
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;return&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;大部分的事情都由 &lt;code&gt;go-jsonnet&lt;/code&gt; 替我们做了, 所以代码很简洁. 后面支持多格式输出的时候会再增加一些代码.&lt;/p&gt;
&lt;p&gt;接着写个测试来验证下. 先定义测试用例.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/render/render_test.go
&lt;/span&gt;&lt;span&gt;// ...
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;TestCase&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
&lt;span&gt;Entry&lt;/span&gt;      &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;Files&lt;/span&gt;      &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;
&lt;span&gt;OutputType&lt;/span&gt; &lt;span&gt;ContentType&lt;/span&gt;
&lt;span&gt;OutputDoc&lt;/span&gt;  &lt;span&gt;string&lt;/span&gt;
}

&lt;span&gt;var&lt;/span&gt; &lt;span&gt;cases&lt;/span&gt; = []&lt;span&gt;TestCase&lt;/span&gt;{
{
&lt;span&gt;OutputType&lt;/span&gt;: &lt;span&gt;JSON&lt;/span&gt;,
&lt;span&gt;Entry&lt;/span&gt;:      &lt;span&gt;&quot;example1.jsonnet&quot;&lt;/span&gt;,
&lt;span&gt;OutputDoc&lt;/span&gt;:  &lt;span&gt;`{&quot;person1&quot;:{&quot;name&quot;:&quot;Alice&quot;,&quot;welcome&quot;:&quot;Hello Alice!&quot;},&quot;person2&quot;:{&quot;name&quot;:&quot;Bob&quot;,&quot;welcome&quot;:&quot;Hello Bob!&quot;}}`&lt;/span&gt;,
&lt;span&gt;Files&lt;/span&gt;:      &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;example1.jsonnet&quot;&lt;/span&gt;: &lt;span&gt;`/* Edit me! */ {person1:{name:&quot;Alice&quot;,welcome:&quot;Hello &quot;+self.name+&quot;!&quot;,},person2:self.person1{name:&quot;Bob&quot;},}`&lt;/span&gt;},
},
}
&lt;span&gt;// ...
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;定义两个工具函数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/render/render_test.go
&lt;/span&gt;&lt;span&gt;// ...
&lt;/span&gt;&lt;span/&gt;
&lt;span&gt;// 用 map[string]string 模拟文件存储, key 为文件名, value 为文件内容
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;makeImporter&lt;/span&gt;(&lt;span&gt;files&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;) &lt;span&gt;jsonnet&lt;/span&gt;.&lt;span&gt;Importer&lt;/span&gt; {
&lt;span&gt;data&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; make(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;jsonnet&lt;/span&gt;.&lt;span&gt;Contents&lt;/span&gt;, len(&lt;span&gt;files&lt;/span&gt;))
&lt;span&gt;for&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;, &lt;span&gt;content&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; &lt;span&gt;files&lt;/span&gt; {
&lt;span&gt;data&lt;/span&gt;[&lt;span&gt;name&lt;/span&gt;] = &lt;span&gt;jsonnet&lt;/span&gt;.&lt;span&gt;MakeContents&lt;/span&gt;(&lt;span&gt;content&lt;/span&gt;)
}
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;jsonnet&lt;/span&gt;.&lt;span&gt;MemoryImporter&lt;/span&gt;{&lt;span&gt;Data&lt;/span&gt;: &lt;span&gt;data&lt;/span&gt;}
}

&lt;span&gt;// 将默认输出的多行 JSON 格式化为单行 JSON
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;compactJson&lt;/span&gt;(&lt;span&gt;input&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) &lt;span&gt;string&lt;/span&gt; {
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;buf&lt;/span&gt; &lt;span&gt;bytes&lt;/span&gt;.&lt;span&gt;Buffer&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;json&lt;/span&gt;.&lt;span&gt;Compact&lt;/span&gt;(&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;buf&lt;/span&gt;, []byte(&lt;span&gt;input&lt;/span&gt;)); &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
panic(&lt;span&gt;err&lt;/span&gt;)
}
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;buf&lt;/span&gt;.&lt;span&gt;String&lt;/span&gt;()
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;定义测试&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/render/render_test.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;render&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt; (
&lt;span&gt;&quot;bytes&quot;&lt;/span&gt;
&lt;span&gt;&quot;encoding/json&quot;&lt;/span&gt;
&lt;span&gt;&quot;testing&quot;&lt;/span&gt;

&lt;span&gt;&quot;github.com/google/go-jsonnet&quot;&lt;/span&gt;
&lt;span&gt;&quot;github.com/stretchr/testify/assert&quot;&lt;/span&gt;
)

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestJsonnet&lt;/span&gt;(&lt;span&gt;t&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;testing&lt;/span&gt;.&lt;span&gt;T&lt;/span&gt;) {
&lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;, &lt;span&gt;c&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; &lt;span&gt;cases&lt;/span&gt; {
&lt;span&gt;r&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;Jsonnet&lt;/span&gt;{&lt;span&gt;Importer&lt;/span&gt;: &lt;span&gt;makeImporter&lt;/span&gt;(&lt;span&gt;c&lt;/span&gt;.&lt;span&gt;Files&lt;/span&gt;)}
&lt;span&gt;doc&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;r&lt;/span&gt;.&lt;span&gt;Render&lt;/span&gt;(&lt;span&gt;c&lt;/span&gt;.&lt;span&gt;Entry&lt;/span&gt;, &lt;span&gt;c&lt;/span&gt;.&lt;span&gt;OutputType&lt;/span&gt;)
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;assert&lt;/span&gt;.&lt;span&gt;NoError&lt;/span&gt;(&lt;span&gt;t&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;) {
&lt;span&gt;assert&lt;/span&gt;.&lt;span&gt;Equal&lt;/span&gt;(&lt;span&gt;t&lt;/span&gt;, &lt;span&gt;c&lt;/span&gt;.&lt;span&gt;OutputDoc&lt;/span&gt;, &lt;span&gt;compactJson&lt;/span&gt;(&lt;span&gt;doc&lt;/span&gt;))
}
}
}
&lt;span&gt;// ...
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行下&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ go test github.com/GotaX/go-config-server/pkg/render
&lt;span&gt;# ok      github.com/GotaX/go-config-server/pkg/render    0.205s&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看起来没问题, 渲染器已经 OK 了.&lt;/p&gt;
&lt;h2 id=&quot;git-存储&quot;&gt;Git 存储&lt;/h2&gt;
&lt;p&gt;因为要操作 Git 仓库, 这里我们使用 &lt;a href=&quot;https://github.com/go-git/go-git/&quot;&gt;go-git&lt;/a&gt; 作为 Git 客户端. 首先定义结构体.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/storage/git.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Git&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
&lt;span&gt;URL&lt;/span&gt;  &lt;span&gt;string&lt;/span&gt;                &lt;span&gt;// 存配置的源码仓库地址, 先支持 HTTPS 端点
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;Auth&lt;/span&gt; &lt;span&gt;transport&lt;/span&gt;.&lt;span&gt;AuthMethod&lt;/span&gt;  &lt;span&gt;// 身份认证信息, 公开仓库该字段为 nil
&lt;/span&gt;&lt;span/&gt;
&lt;span&gt;namespace&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;           &lt;span&gt;// 记录当前的命名空间, 第一次访问前该字段为空
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;repo&lt;/span&gt;      &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Repository&lt;/span&gt;      &lt;span&gt;// 记录当前的仓库对象, 第一次访问前该字段为空
&lt;/span&gt;&lt;span/&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接着实现 Use 函数, 第一版先不支持分支切换, 在检出时只检出当前命名空间的分支.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/storage/git.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;g&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Git&lt;/span&gt;) &lt;span&gt;Use&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;namespace&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) (&lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) {
    &lt;span&gt;// 第一次访问时 clone 当前命名空间对应的分支
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;g&lt;/span&gt;.&lt;span&gt;namespace&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt; {
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;g&lt;/span&gt;.&lt;span&gt;repo&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;g&lt;/span&gt;.&lt;span&gt;clone&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt;, &lt;span&gt;namespace&lt;/span&gt;); &lt;span&gt;err&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;span&gt;g&lt;/span&gt;.&lt;span&gt;namespace&lt;/span&gt; = &lt;span&gt;namespace&lt;/span&gt;
}
&lt;span&gt;return&lt;/span&gt;
}
    
    &lt;span&gt;// TODO: 之后在这里实现分支切换, 从而支持多命名空间
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;return&lt;/span&gt;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;还有 Read 函数.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/storage/git.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;g&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Git&lt;/span&gt;) &lt;span&gt;Read&lt;/span&gt;(&lt;span&gt;path&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) (&lt;span&gt;content&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) {
&lt;span&gt;var&lt;/span&gt; (
&lt;span&gt;wt&lt;/span&gt;   &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Worktree&lt;/span&gt;
&lt;span&gt;fd&lt;/span&gt;   &lt;span&gt;billy&lt;/span&gt;.&lt;span&gt;File&lt;/span&gt;
&lt;span&gt;data&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;
)
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;wt&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;g&lt;/span&gt;.&lt;span&gt;repo&lt;/span&gt;.&lt;span&gt;Worktree&lt;/span&gt;(); &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;span&gt;return&lt;/span&gt;
}
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;fd&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;wt&lt;/span&gt;.&lt;span&gt;Filesystem&lt;/span&gt;.&lt;span&gt;Open&lt;/span&gt;(&lt;span&gt;path&lt;/span&gt;); &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;span&gt;return&lt;/span&gt;
}
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;data&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;ioutil&lt;/span&gt;.&lt;span&gt;ReadAll&lt;/span&gt;(&lt;span&gt;fd&lt;/span&gt;); &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;span&gt;return&lt;/span&gt;
}
&lt;span&gt;return&lt;/span&gt; string(&lt;span&gt;data&lt;/span&gt;), &lt;span&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面用到的两个工具函数:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/storage/git.go
&lt;/span&gt;&lt;span&gt;// git clone 函数, 使用内存文件系统, 所以不会在硬盘上留下文件.
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;g&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Git&lt;/span&gt;) &lt;span&gt;clone&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;namespace&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) (&lt;span&gt;repo&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Repository&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) {
&lt;span&gt;opts&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;CloneOptions&lt;/span&gt;{
&lt;span&gt;URL&lt;/span&gt;:          &lt;span&gt;g&lt;/span&gt;.&lt;span&gt;URL&lt;/span&gt;,
&lt;span&gt;Auth&lt;/span&gt;:         &lt;span&gt;g&lt;/span&gt;.&lt;span&gt;Auth&lt;/span&gt;,
&lt;span&gt;SingleBranch&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,
&lt;span&gt;Depth&lt;/span&gt;:        &lt;span&gt;1&lt;/span&gt;,
&lt;span&gt;Progress&lt;/span&gt;:     &lt;span&gt;os&lt;/span&gt;.&lt;span&gt;Stdout&lt;/span&gt;,
}
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;opts&lt;/span&gt;.&lt;span&gt;ReferenceName&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;g&lt;/span&gt;.&lt;span&gt;branchRef&lt;/span&gt;(&lt;span&gt;namespace&lt;/span&gt;); &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;span&gt;return&lt;/span&gt;
}

&lt;span&gt;return&lt;/span&gt; &lt;span&gt;CloneContext&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt;, &lt;span&gt;memory&lt;/span&gt;.&lt;span&gt;NewStorage&lt;/span&gt;(), &lt;span&gt;memfs&lt;/span&gt;.&lt;span&gt;New&lt;/span&gt;(), &lt;span&gt;opts&lt;/span&gt;)
}

&lt;span&gt;// 根据传入的命名空间返回对应的分支引用名称, 并且命名空间不能为空
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;g&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Git&lt;/span&gt;) &lt;span&gt;branchRef&lt;/span&gt;(&lt;span&gt;namespace&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) (&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;plumbing&lt;/span&gt;.&lt;span&gt;ReferenceName&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) {
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt; {
&lt;span&gt;err&lt;/span&gt; = &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Errorf&lt;/span&gt;(&lt;span&gt;&quot;namespace is required&quot;&lt;/span&gt;)
&lt;span&gt;return&lt;/span&gt;
}

&lt;span&gt;ref&lt;/span&gt; = &lt;span&gt;plumbing&lt;/span&gt;.&lt;span&gt;ReferenceName&lt;/span&gt;(&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Sprintf&lt;/span&gt;(&lt;span&gt;&quot;refs/heads/%s&quot;&lt;/span&gt;, &lt;span&gt;namespace&lt;/span&gt;))
&lt;span&gt;return&lt;/span&gt;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后写个测试验证一下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/storage/storage_test.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;storage&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt; (
&lt;span&gt;&quot;context&quot;&lt;/span&gt;
&lt;span&gt;&quot;path/filepath&quot;&lt;/span&gt;
&lt;span&gt;&quot;runtime&quot;&lt;/span&gt;
&lt;span&gt;&quot;testing&quot;&lt;/span&gt;

&lt;span&gt;&quot;github.com/stretchr/testify/assert&quot;&lt;/span&gt;
)

&lt;span&gt;// 如果可以正常读取 go.mod 内容则实现有效
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestGit&lt;/span&gt;(&lt;span&gt;t&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;testing&lt;/span&gt;.&lt;span&gt;T&lt;/span&gt;) {
&lt;span&gt;g&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;Git&lt;/span&gt;{&lt;span&gt;URL&lt;/span&gt;: &lt;span&gt;localRepo&lt;/span&gt;()}

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;g&lt;/span&gt;.&lt;span&gt;Use&lt;/span&gt;(&lt;span&gt;context&lt;/span&gt;.&lt;span&gt;TODO&lt;/span&gt;(), &lt;span&gt;&quot;master&quot;&lt;/span&gt;); !&lt;span&gt;assert&lt;/span&gt;.&lt;span&gt;NoError&lt;/span&gt;(&lt;span&gt;t&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;) {
&lt;span&gt;return&lt;/span&gt;
}

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;content&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;g&lt;/span&gt;.&lt;span&gt;Read&lt;/span&gt;(&lt;span&gt;&quot;go.mod&quot;&lt;/span&gt;); &lt;span&gt;assert&lt;/span&gt;.&lt;span&gt;NoError&lt;/span&gt;(&lt;span&gt;t&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;) {
&lt;span&gt;assert&lt;/span&gt;.&lt;span&gt;NotEmpty&lt;/span&gt;(&lt;span&gt;t&lt;/span&gt;, &lt;span&gt;content&lt;/span&gt;)
}
}

&lt;span&gt;// 用当前的项目作为测试库
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;localRepo&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt; {
&lt;span&gt;_&lt;/span&gt;, &lt;span&gt;filename&lt;/span&gt;, &lt;span&gt;_&lt;/span&gt;, &lt;span&gt;_&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;runtime&lt;/span&gt;.&lt;span&gt;Caller&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;)
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;filepath&lt;/span&gt;.&lt;span&gt;Join&lt;/span&gt;(&lt;span&gt;filename&lt;/span&gt;, &lt;span&gt;&quot;../../..&quot;&lt;/span&gt;)
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行…&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ go test github.com/GotaX/go-config-server/pkg/storage
&lt;span&gt;# ok      github.com/GotaX/go-config-server/pkg/storage   0.390s&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;OK 完全没有问题.&lt;/p&gt;
&lt;h2 id=&quot;组装-app&quot;&gt;组装 App&lt;/h2&gt;
&lt;p&gt;接下来, 我们在 app 中将上面两个组件组装起来.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/handler/app.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;handler&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt; (
&lt;span&gt;&quot;context&quot;&lt;/span&gt;

&lt;span&gt;&quot;github.com/GotaX/go-config-server/pkg/render&quot;&lt;/span&gt;
&lt;span&gt;&quot;github.com/GotaX/go-config-server/pkg/storage&quot;&lt;/span&gt;
)

&lt;span&gt;type&lt;/span&gt; &lt;span&gt;App&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
&lt;span&gt;Storage&lt;/span&gt;  &lt;span&gt;storage&lt;/span&gt;.&lt;span&gt;Storage&lt;/span&gt;
&lt;span&gt;Renderer&lt;/span&gt; &lt;span&gt;render&lt;/span&gt;.&lt;span&gt;Renderer&lt;/span&gt;
}

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;a&lt;/span&gt; &lt;span&gt;App&lt;/span&gt;) &lt;span&gt;Handle&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;namespace&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) (&lt;span&gt;doc&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) {
    &lt;span&gt;// 切换到指定命名空间
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;a&lt;/span&gt;.&lt;span&gt;Storage&lt;/span&gt;.&lt;span&gt;Use&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt;, &lt;span&gt;namespace&lt;/span&gt;); &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;span&gt;return&lt;/span&gt;
}
    &lt;span&gt;// 执行渲染
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;.&lt;span&gt;Renderer&lt;/span&gt;.&lt;span&gt;Render&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;, &lt;span&gt;render&lt;/span&gt;.&lt;span&gt;JSON&lt;/span&gt;)
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;测试可不能少.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/handler/handler_test.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;handler&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt; (
&lt;span&gt;&quot;context&quot;&lt;/span&gt;
&lt;span&gt;&quot;testing&quot;&lt;/span&gt;

&lt;span&gt;&quot;github.com/GotaX/go-config-server/pkg/render&quot;&lt;/span&gt;
&lt;span&gt;&quot;github.com/stretchr/testify/assert&quot;&lt;/span&gt;
)

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestApp&lt;/span&gt;(&lt;span&gt;t&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;testing&lt;/span&gt;.&lt;span&gt;T&lt;/span&gt;) {
&lt;span&gt;s&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;MockStorage&lt;/span&gt;{}
&lt;span&gt;r&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;MockRender&lt;/span&gt;{}
&lt;span&gt;app&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;App&lt;/span&gt;{&lt;span&gt;Storage&lt;/span&gt;: &lt;span&gt;s&lt;/span&gt;, &lt;span&gt;Renderer&lt;/span&gt;: &lt;span&gt;r&lt;/span&gt;}

&lt;span&gt;_&lt;/span&gt;, &lt;span&gt;_&lt;/span&gt; = &lt;span&gt;app&lt;/span&gt;.&lt;span&gt;Handle&lt;/span&gt;(&lt;span&gt;context&lt;/span&gt;.&lt;span&gt;TODO&lt;/span&gt;(), &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;)
    
    &lt;span&gt;// 确保 Storage.Use 和 Renderer.Render 有被调用到
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;assert&lt;/span&gt;.&lt;span&gt;True&lt;/span&gt;(&lt;span&gt;t&lt;/span&gt;, &lt;span&gt;s&lt;/span&gt;.&lt;span&gt;useInvoked&lt;/span&gt;)
&lt;span&gt;assert&lt;/span&gt;.&lt;span&gt;True&lt;/span&gt;(&lt;span&gt;t&lt;/span&gt;, &lt;span&gt;r&lt;/span&gt;.&lt;span&gt;renderInvoked&lt;/span&gt;)
}

&lt;span&gt;type&lt;/span&gt; &lt;span&gt;MockStorage&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; { &lt;span&gt;useInvoked&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; }
&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;m&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;MockStorage&lt;/span&gt;) &lt;span&gt;Use&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;namespace&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) (&lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) { &lt;span&gt;m&lt;/span&gt;.&lt;span&gt;useInvoked&lt;/span&gt; = &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;return&lt;/span&gt; }
&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;m&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;MockStorage&lt;/span&gt;) &lt;span&gt;Read&lt;/span&gt;(&lt;span&gt;path&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) (&lt;span&gt;content&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) { &lt;span&gt;return&lt;/span&gt; }

&lt;span&gt;type&lt;/span&gt; &lt;span&gt;MockRender&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; { &lt;span&gt;renderInvoked&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; }
&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;m&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;MockRender&lt;/span&gt;) &lt;span&gt;Render&lt;/span&gt;(&lt;span&gt;entry&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;outputType&lt;/span&gt; &lt;span&gt;render&lt;/span&gt;.&lt;span&gt;ContentType&lt;/span&gt;) (&lt;span&gt;doc&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) { &lt;span&gt;m&lt;/span&gt;.&lt;span&gt;renderInvoked&lt;/span&gt; = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;return&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行一下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ go test github.com/GotaX/go-config-server/pkg/handler
&lt;span&gt;# ok      github.com/GotaX/go-config-server/pkg/handler   0.191s&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;好, 到目前为止所有的核心组件就都实现完了. 是不是很轻松呀? 下面就是一些与 API 相关的外围工作了.&lt;/p&gt;
&lt;h1 id=&quot;用户接口适配&quot;&gt;用户接口适配&lt;/h1&gt;
&lt;p&gt;稍微偷下懒, 外围接口就不写测试了 😝.&lt;/p&gt;
&lt;h2 id=&quot;服务器&quot;&gt;服务器&lt;/h2&gt;
&lt;p&gt;这里我们使用 &lt;a href=&quot;https://github.com/gofiber/fiber&quot;&gt;Fiber&lt;/a&gt; 做应用服务器, 如果要追求极致性能也可以选用 &lt;a href=&quot;https://github.com/valyala/fasthttp&quot;&gt;Fasthttp&lt;/a&gt;, 不过区别其实很小很小, 为了轻松实现功能, 我就用 Fiber 了.&lt;/p&gt;
&lt;p&gt;先定义一下启动参数.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/service/service.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Options&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
    &lt;span&gt;HttpAddr&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;  &lt;span&gt;// HTTP 监听地址, 默认为 :8080
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;URL&lt;/span&gt;      &lt;span&gt;string&lt;/span&gt;  &lt;span&gt;// Git 仓库地址, 目前仅支持 HTTPS
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;Username&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;  &lt;span&gt;// Git 用户名, 访问公共仓库留空, 使用 AccessToken 访问随便填一个
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;Password&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;  &lt;span&gt;// Git 密码, 访问公共仓库留空, 使用 AccessToken 访问填 AccessToken
&lt;/span&gt;&lt;span/&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;初始化 Service 对象&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/service/service.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Service&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
&lt;span&gt;httpAddr&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;app&lt;/span&gt;      &lt;span&gt;handler&lt;/span&gt;.&lt;span&gt;App&lt;/span&gt;
}

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;New&lt;/span&gt;(&lt;span&gt;opts&lt;/span&gt; &lt;span&gt;Options&lt;/span&gt;) &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Service&lt;/span&gt; {
&lt;span&gt;store&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;storage&lt;/span&gt;.&lt;span&gt;Git&lt;/span&gt;{
&lt;span&gt;URL&lt;/span&gt;: &lt;span&gt;opts&lt;/span&gt;.&lt;span&gt;URL&lt;/span&gt;,
}
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;opts&lt;/span&gt;.&lt;span&gt;Username&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt; {
&lt;span&gt;store&lt;/span&gt;.&lt;span&gt;Auth&lt;/span&gt; = &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;.&lt;span&gt;BasicAuth&lt;/span&gt;{
&lt;span&gt;Username&lt;/span&gt;: &lt;span&gt;opts&lt;/span&gt;.&lt;span&gt;Username&lt;/span&gt;,
&lt;span&gt;Password&lt;/span&gt;: &lt;span&gt;opts&lt;/span&gt;.&lt;span&gt;Password&lt;/span&gt;,
}
}
&lt;span&gt;renderer&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;render&lt;/span&gt;.&lt;span&gt;Jsonnet&lt;/span&gt;{
         &lt;span&gt;// 见下面说明
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;Importer&lt;/span&gt;: &lt;span&gt;render&lt;/span&gt;.&lt;span&gt;StorageImporter&lt;/span&gt;{
&lt;span&gt;Storage&lt;/span&gt;: &lt;span&gt;store&lt;/span&gt;,
},
}
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;Service&lt;/span&gt;{
&lt;span&gt;httpAddr&lt;/span&gt;: &lt;span&gt;opts&lt;/span&gt;.&lt;span&gt;HttpAddr&lt;/span&gt;,
&lt;span&gt;app&lt;/span&gt;: &lt;span&gt;handler&lt;/span&gt;.&lt;span&gt;App&lt;/span&gt;{
&lt;span&gt;Storage&lt;/span&gt;:  &lt;span&gt;store&lt;/span&gt;,
&lt;span&gt;Renderer&lt;/span&gt;: &lt;span&gt;renderer&lt;/span&gt;,
},
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里解释下 &lt;code&gt;render.StorageImporter &lt;/code&gt; , Importer 是 Jsonnet VM 使用的接口, 和我们的 Storage 接口有一点差异, 所以定义了这个适配器.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/render/jsonnet.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;StorageImporter&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {
&lt;span&gt;Storage&lt;/span&gt; &lt;span&gt;storage&lt;/span&gt;.&lt;span&gt;Storage&lt;/span&gt;
}

&lt;span&gt;// importFrom 为使用 import 的源文件, 绝对路径
&lt;/span&gt;&lt;span&gt;// importedPath 为 import 的目标文件, 相对路径, 相对于源文件
&lt;/span&gt;&lt;span&gt;// contents 为文件内容
&lt;/span&gt;&lt;span&gt;// foundAt 为 import 目标文件的绝对路径
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;s&lt;/span&gt; &lt;span&gt;StorageImporter&lt;/span&gt;) &lt;span&gt;Import&lt;/span&gt;(&lt;span&gt;importedFrom&lt;/span&gt;, &lt;span&gt;importedPath&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) (&lt;span&gt;contents&lt;/span&gt; &lt;span&gt;Contents&lt;/span&gt;, &lt;span&gt;foundAt&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) {
&lt;span&gt;dir&lt;/span&gt;, &lt;span&gt;_&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;filepath&lt;/span&gt;.&lt;span&gt;Split&lt;/span&gt;(&lt;span&gt;importedFrom&lt;/span&gt;)
&lt;span&gt;path&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;filepath&lt;/span&gt;.&lt;span&gt;Join&lt;/span&gt;(&lt;span&gt;dir&lt;/span&gt;, &lt;span&gt;importedPath&lt;/span&gt;)
&lt;span&gt;data&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;s&lt;/span&gt;.&lt;span&gt;Storage&lt;/span&gt;.&lt;span&gt;Read&lt;/span&gt;(&lt;span&gt;path&lt;/span&gt;)

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;span&gt;contents&lt;/span&gt; = &lt;span&gt;MakeContents&lt;/span&gt;(&lt;span&gt;data&lt;/span&gt;)
&lt;span&gt;foundAt&lt;/span&gt; = &lt;span&gt;path&lt;/span&gt;
}
&lt;span&gt;return&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接着继续定义路由的 Handler:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/service/service.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;srv&lt;/span&gt; &lt;span&gt;Service&lt;/span&gt;) &lt;span&gt;Handle&lt;/span&gt;(&lt;span&gt;c&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;fiber&lt;/span&gt;.&lt;span&gt;Ctx&lt;/span&gt;) (&lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) {
&lt;span&gt;var&lt;/span&gt; (
&lt;span&gt;ctx&lt;/span&gt;       = &lt;span&gt;c&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;()
&lt;span&gt;name&lt;/span&gt;      = &lt;span&gt;c&lt;/span&gt;.&lt;span&gt;Params&lt;/span&gt;(&lt;span&gt;&quot;+&quot;&lt;/span&gt;)          &lt;span&gt;// fiber 的 wildcard 语法, 等下解释
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;namespace&lt;/span&gt; = &lt;span&gt;c&lt;/span&gt;.&lt;span&gt;Params&lt;/span&gt;(&lt;span&gt;&quot;namespace&quot;&lt;/span&gt;)
)
&lt;span&gt;doc&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;srv&lt;/span&gt;.&lt;span&gt;app&lt;/span&gt;.&lt;span&gt;Handle&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt;, &lt;span&gt;namespace&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt;)
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;span&gt;return&lt;/span&gt;
}

&lt;span&gt;c&lt;/span&gt;.&lt;span&gt;Set&lt;/span&gt;(&lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;, &lt;span&gt;&quot;application/json&quot;&lt;/span&gt;)
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;.&lt;span&gt;SendString&lt;/span&gt;(&lt;span&gt;doc&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;继续定义路由:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/service/service.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;const&lt;/span&gt; (
&lt;span&gt;readTimeout&lt;/span&gt;    = &lt;span&gt;10&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Second&lt;/span&gt;  &lt;span&gt;// 读请求超时时间
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;writeTimeout&lt;/span&gt;   = &lt;span&gt;10&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Second&lt;/span&gt;  &lt;span&gt;// 写响应超时时间
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;endpointHealth&lt;/span&gt; = &lt;span&gt;&quot;/healthz&quot;&lt;/span&gt;        &lt;span&gt;// 健康检查端点
&lt;/span&gt;&lt;span/&gt;)

&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;srv&lt;/span&gt; &lt;span&gt;Service&lt;/span&gt;) &lt;span&gt;Run&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;) (&lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) {
&lt;span&gt;server&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;fiber&lt;/span&gt;.&lt;span&gt;New&lt;/span&gt;(&lt;span&gt;fiber&lt;/span&gt;.&lt;span&gt;Config&lt;/span&gt;{
&lt;span&gt;ReadTimeout&lt;/span&gt;:  &lt;span&gt;readTimeout&lt;/span&gt;,
&lt;span&gt;WriteTimeout&lt;/span&gt;: &lt;span&gt;writeTimeout&lt;/span&gt;,
})

&lt;span&gt;registerAccessLogger&lt;/span&gt;(&lt;span&gt;server&lt;/span&gt;)    &lt;span&gt;// 访问日志中间件
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;registerHealthHandler&lt;/span&gt;(&lt;span&gt;server&lt;/span&gt;)   &lt;span&gt;// 健康检查中间件
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;srv&lt;/span&gt;.&lt;span&gt;registerAppHandler&lt;/span&gt;(&lt;span&gt;server&lt;/span&gt;)  &lt;span&gt;// 注册路由
&lt;/span&gt;&lt;span/&gt;
&lt;span&gt;chErr&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; make(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;)

&lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;() {
        &lt;span&gt;// 开始监听端口
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;server&lt;/span&gt;.&lt;span&gt;Listen&lt;/span&gt;(&lt;span&gt;srv&lt;/span&gt;.&lt;span&gt;httpAddr&lt;/span&gt;); &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;span&gt;chErr&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;err&lt;/span&gt;
}
}()

    &lt;span&gt;// 实现 Graceful shutdown, 进程结束前会先取消掉 Context
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;select&lt;/span&gt; {
&lt;span&gt;case&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; = &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;chErr&lt;/span&gt;:
&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;ctx&lt;/span&gt;.&lt;span&gt;Done&lt;/span&gt;():
&lt;span&gt;err&lt;/span&gt; = &lt;span&gt;server&lt;/span&gt;.&lt;span&gt;Shutdown&lt;/span&gt;()
}
&lt;span&gt;return&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面用到的几个工具函数:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// pkg/service/service.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;srv&lt;/span&gt; &lt;span&gt;Service&lt;/span&gt;) &lt;span&gt;registerAppHandler&lt;/span&gt;(&lt;span&gt;server&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;fiber&lt;/span&gt;.&lt;span&gt;App&lt;/span&gt;) {
    &lt;span&gt;// 定义 path params, namespace 为第一个参数, 后面所有字符包括 &#x27;/&#x27; 为第二个参数
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;// 例如: /master/example/arith.jsonnet
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;// 参数一: namespace = master
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;// 参数二: + = example/arith.jsonnet
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;server&lt;/span&gt;.&lt;span&gt;Get&lt;/span&gt;(&lt;span&gt;&quot;/:namespace/+&quot;&lt;/span&gt;, &lt;span&gt;srv&lt;/span&gt;.&lt;span&gt;Handle&lt;/span&gt;)
}

&lt;span&gt;// 访问日志
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;registerAccessLogger&lt;/span&gt;(&lt;span&gt;server&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;fiber&lt;/span&gt;.&lt;span&gt;App&lt;/span&gt;) {
&lt;span&gt;server&lt;/span&gt;.&lt;span&gt;Use&lt;/span&gt;(&lt;span&gt;logger&lt;/span&gt;.&lt;span&gt;New&lt;/span&gt;(&lt;span&gt;logger&lt;/span&gt;.&lt;span&gt;Config&lt;/span&gt;{
&lt;span&gt;Next&lt;/span&gt;: &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;c&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;fiber&lt;/span&gt;.&lt;span&gt;Ctx&lt;/span&gt;) &lt;span&gt;bool&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;.&lt;span&gt;Path&lt;/span&gt;() &lt;span&gt;==&lt;/span&gt; &lt;span&gt;endpointHealth&lt;/span&gt; },
}))
}

&lt;span&gt;// 健康检查
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;registerHealthHandler&lt;/span&gt;(&lt;span&gt;server&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;fiber&lt;/span&gt;.&lt;span&gt;App&lt;/span&gt;) {
&lt;span&gt;server&lt;/span&gt;.&lt;span&gt;All&lt;/span&gt;(&lt;span&gt;endpointHealth&lt;/span&gt;, &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;fiber&lt;/span&gt;.&lt;span&gt;Ctx&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; {
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;ctx&lt;/span&gt;.&lt;span&gt;SendStatus&lt;/span&gt;(&lt;span&gt;fiber&lt;/span&gt;.&lt;span&gt;StatusOK&lt;/span&gt;)
})
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;命令行&quot;&gt;命令行&lt;/h2&gt;
&lt;p&gt;最后我们来做启动程序的命令行界面, 顺便解释一下优雅退出怎么实现.&lt;/p&gt;
&lt;p&gt;这里我们使用 &lt;a href=&quot;urfave/cli&quot;&gt;urfave/cli&lt;/a&gt; 这个库. 首先, 定义一些命令行参数, 环境变量等之后做 Docker 镜像的时候再支持.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// internal/web.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt; (
&lt;span&gt;&quot;github.com/GotaX/go-config-server/pkg/service&quot;&lt;/span&gt;
. &lt;span&gt;&quot;github.com/urfave/cli/v2&quot;&lt;/span&gt;
)

&lt;span&gt;const&lt;/span&gt; (
&lt;span&gt;flagHttp&lt;/span&gt;       = &lt;span&gt;&quot;http&quot;&lt;/span&gt;        &lt;span&gt;// HTTP 监听地址, 默认为 :8080
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;flagRepository&lt;/span&gt; = &lt;span&gt;&quot;repository&quot;&lt;/span&gt;  &lt;span&gt;// Git 仓库地址, 目前仅支持 HTTPS
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;flagUsername&lt;/span&gt;   = &lt;span&gt;&quot;username&quot;&lt;/span&gt;    &lt;span&gt;// Git 用户名, 访问公共仓库留空, 使用 AccessToken 访问随便填一个
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;flagPassword&lt;/span&gt;   = &lt;span&gt;&quot;password&quot;&lt;/span&gt;    &lt;span&gt;// Git 密码, 访问公共仓库留空, 使用 AccessToken 访问填 AccessToken
&lt;/span&gt;&lt;span/&gt;)

&lt;span&gt;var&lt;/span&gt; &lt;span&gt;CmdWeb&lt;/span&gt; = &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;{
&lt;span&gt;Name&lt;/span&gt;:   &lt;span&gt;&quot;web&quot;&lt;/span&gt;,
&lt;span&gt;Usage&lt;/span&gt;:  &lt;span&gt;&quot;Start config server&quot;&lt;/span&gt;,
&lt;span&gt;Action&lt;/span&gt;: &lt;span&gt;runWeb&lt;/span&gt;,
&lt;span&gt;Flags&lt;/span&gt;: []&lt;span&gt;Flag&lt;/span&gt;{
&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;StringFlag&lt;/span&gt;{
&lt;span&gt;Name&lt;/span&gt;:  &lt;span&gt;flagHttp&lt;/span&gt;,
&lt;span&gt;Value&lt;/span&gt;: &lt;span&gt;&quot;:8080&quot;&lt;/span&gt;,
},
&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;StringFlag&lt;/span&gt;{
&lt;span&gt;Name&lt;/span&gt;:     &lt;span&gt;flagRepository&lt;/span&gt;,
&lt;span&gt;Required&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,
&lt;span&gt;Aliases&lt;/span&gt;:  []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;repo&quot;&lt;/span&gt;},
},
&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;StringFlag&lt;/span&gt;{
&lt;span&gt;Name&lt;/span&gt;:    &lt;span&gt;flagUsername&lt;/span&gt;,
&lt;span&gt;Aliases&lt;/span&gt;: []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;user&quot;&lt;/span&gt;},
},
&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;StringFlag&lt;/span&gt;{
&lt;span&gt;Name&lt;/span&gt;:    &lt;span&gt;flagPassword&lt;/span&gt;,
&lt;span&gt;Aliases&lt;/span&gt;: []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;pass&quot;&lt;/span&gt;},
},
},
}

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;runWeb&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Context&lt;/span&gt;) (&lt;span&gt;err&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) {
&lt;span&gt;srv&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;service&lt;/span&gt;.&lt;span&gt;New&lt;/span&gt;(&lt;span&gt;service&lt;/span&gt;.&lt;span&gt;Options&lt;/span&gt;{
&lt;span&gt;HttpAddr&lt;/span&gt;: &lt;span&gt;ctx&lt;/span&gt;.&lt;span&gt;String&lt;/span&gt;(&lt;span&gt;flagHttp&lt;/span&gt;),
&lt;span&gt;URL&lt;/span&gt;:      &lt;span&gt;ctx&lt;/span&gt;.&lt;span&gt;String&lt;/span&gt;(&lt;span&gt;flagRepository&lt;/span&gt;),
&lt;span&gt;Username&lt;/span&gt;: &lt;span&gt;ctx&lt;/span&gt;.&lt;span&gt;String&lt;/span&gt;(&lt;span&gt;flagUsername&lt;/span&gt;),
&lt;span&gt;Password&lt;/span&gt;: &lt;span&gt;ctx&lt;/span&gt;.&lt;span&gt;String&lt;/span&gt;(&lt;span&gt;flagPassword&lt;/span&gt;),
})
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;srv&lt;/span&gt;.&lt;span&gt;Run&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;)
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;定义用于优雅退出的 Context:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// internal/context.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt; (
&lt;span&gt;&quot;context&quot;&lt;/span&gt;
&lt;span&gt;&quot;fmt&quot;&lt;/span&gt;
&lt;span&gt;&quot;os&quot;&lt;/span&gt;
&lt;span&gt;&quot;os/signal&quot;&lt;/span&gt;
&lt;span&gt;&quot;syscall&quot;&lt;/span&gt;
)

&lt;span&gt;// 该函数返回的 context 会在第一次收到 SIGINT 或者 SIGTERM 信号时取消,
&lt;/span&gt;&lt;span&gt;// 如果在关闭过程中再次收到信号, 则会强制结束进程
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewAppContext&lt;/span&gt;() (&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;cancel&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;()) {
&lt;span&gt;ctx&lt;/span&gt;, &lt;span&gt;cancel&lt;/span&gt; = &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;WithCancel&lt;/span&gt;(&lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Background&lt;/span&gt;())

&lt;span&gt;c&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; make(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;os&lt;/span&gt;.&lt;span&gt;Signal&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;)
&lt;span&gt;signal&lt;/span&gt;.&lt;span&gt;Notify&lt;/span&gt;(&lt;span&gt;c&lt;/span&gt;, &lt;span&gt;syscall&lt;/span&gt;.&lt;span&gt;SIGINT&lt;/span&gt;, &lt;span&gt;syscall&lt;/span&gt;.&lt;span&gt;SIGTERM&lt;/span&gt;)
&lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;() {
&lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;
&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;Try exit...&quot;&lt;/span&gt;)
&lt;span&gt;cancel&lt;/span&gt;()

&lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;
&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;Force exit&quot;&lt;/span&gt;)
&lt;span&gt;os&lt;/span&gt;.&lt;span&gt;Exit&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;)
}()
&lt;span&gt;return&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;main&quot;&gt;Main&lt;/h2&gt;
&lt;p&gt;终于到了最后, 写 main 函数的时候尽量保持简洁就行了:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// main.go
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt; (
&lt;span&gt;&quot;log&quot;&lt;/span&gt;
&lt;span&gt;&quot;os&quot;&lt;/span&gt;

&lt;span&gt;&quot;github.com/GotaX/go-config-server/internal&quot;&lt;/span&gt;
&lt;span&gt;&quot;github.com/urfave/cli/v2&quot;&lt;/span&gt;
)

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {
&lt;span&gt;ctx&lt;/span&gt;, &lt;span&gt;cancel&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt;.&lt;span&gt;NewAppContext&lt;/span&gt;()
&lt;span&gt;defer&lt;/span&gt; &lt;span&gt;cancel&lt;/span&gt;()

&lt;span&gt;app&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;cli&lt;/span&gt;.&lt;span&gt;App&lt;/span&gt;{
&lt;span&gt;Name&lt;/span&gt;:     &lt;span&gt;&quot;config-server&quot;&lt;/span&gt;,
&lt;span&gt;Commands&lt;/span&gt;: []&lt;span&gt;*&lt;/span&gt;&lt;span&gt;cli&lt;/span&gt;.&lt;span&gt;Command&lt;/span&gt;{&lt;span&gt;internal&lt;/span&gt;.&lt;span&gt;CmdWeb&lt;/span&gt;},
}

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;app&lt;/span&gt;.&lt;span&gt;RunContext&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt;, &lt;span&gt;os&lt;/span&gt;.&lt;span&gt;Args&lt;/span&gt;); &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;span&gt;log&lt;/span&gt;.&lt;span&gt;Fatal&lt;/span&gt;(&lt;span&gt;&quot;Error: &quot;&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;.&lt;span&gt;Error&lt;/span&gt;())
}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&quot;实际运行&quot;&gt;实际运行&lt;/h1&gt;
&lt;p&gt;最小可用的实现完成啦! 来实际运行下吧. 就用 Jsonnet 库中的例子来看看效果.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;# 在第一个命令行中启动服务器&lt;/span&gt;
$ go build main.go &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; main web -repo&lt;span&gt;=&lt;/span&gt;https://github.com/google/jsonnet.git 

&lt;span&gt;# 在第二个命令行中查配置, 由于要访问 GitHub 第一次可能很慢&lt;/span&gt;
$ curl http://localhost:8080/master/examples/arith.jsonnet

&lt;span&gt;# 查询到的结果&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;&quot;concat_array&quot;&lt;/span&gt;: &lt;span&gt;[&lt;/span&gt;
      1,
      2,
      3,
      &lt;span&gt;4&lt;/span&gt;
   &lt;span&gt;]&lt;/span&gt;,
   &lt;span&gt;&quot;concat_string&quot;&lt;/span&gt;: &lt;span&gt;&quot;1234&quot;&lt;/span&gt;,
   &lt;span&gt;&quot;equality1&quot;&lt;/span&gt;: false,
   &lt;span&gt;&quot;equality2&quot;&lt;/span&gt;: true,
   &lt;span&gt;&quot;ex1&quot;&lt;/span&gt;: 1.6666666666666665,
   &lt;span&gt;&quot;ex2&quot;&lt;/span&gt;: 3,
   &lt;span&gt;&quot;ex3&quot;&lt;/span&gt;: 1.6666666666666665,
   &lt;span&gt;&quot;ex4&quot;&lt;/span&gt;: true,
   &lt;span&gt;&quot;obj&quot;&lt;/span&gt;: &lt;span&gt;{&lt;/span&gt;
      &lt;span&gt;&quot;a&quot;&lt;/span&gt;: 1,
      &lt;span&gt;&quot;b&quot;&lt;/span&gt;: 3,
      &lt;span&gt;&quot;c&quot;&lt;/span&gt;: &lt;span&gt;4&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;,
   &lt;span&gt;&quot;obj_member&quot;&lt;/span&gt;: true,
   &lt;span&gt;&quot;str1&quot;&lt;/span&gt;: &lt;span&gt;&quot;The value of self.ex2 is 3.&quot;&lt;/span&gt;,
   &lt;span&gt;&quot;str2&quot;&lt;/span&gt;: &lt;span&gt;&quot;The value of self.ex2 is 3.&quot;&lt;/span&gt;,
   &lt;span&gt;&quot;str3&quot;&lt;/span&gt;: &lt;span&gt;&quot;ex1=1.67, ex2=3.00&quot;&lt;/span&gt;,
   &lt;span&gt;&quot;str4&quot;&lt;/span&gt;: &lt;span&gt;&quot;ex1=1.67, ex2=3.00&quot;&lt;/span&gt;,
   &lt;span&gt;&quot;str5&quot;&lt;/span&gt;: &lt;span&gt;&quot;ex1=1.67\nex2=3.00\n&quot;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&quot;接下来&quot;&gt;接下来&lt;/h1&gt;
&lt;p&gt;以上就是第一部分的内容了.&lt;/p&gt;
&lt;p&gt;我们已经实现了一个最小可用的配置中心, 没有任何外部依赖, 只要一个命令就能启动, 看起来还是不错的.&lt;/p&gt;
&lt;p&gt;不过这个实现其实比较粗糙, 还要不少改善才能用于生产环境. 简单列举一下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持多分支切换&lt;/li&gt;
&lt;li&gt;支持多格式输出&lt;/li&gt;
&lt;li&gt;并发访问安全&lt;/li&gt;
&lt;li&gt;打包 Docker 镜像&lt;/li&gt;
&lt;li&gt;环境变量支持&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些就等后面的文章里实现咯, 毕竟篇幅已经很长了.&lt;/p&gt;
&lt;p&gt;最后, 谢谢阅读! 觉得有收获欢迎点赞!&lt;/p&gt;
&lt;p&gt;源码仓库地址写在开头了, 觉得有疑问可以在文章下面留言.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>75a79b43b7df26ef193c2a40341238e1</guid>
<title>实现无限缓存的 channel</title>
<link>https://toutiao.io/k/jggpayh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;article-entry&quot; itemprop=&quot;articleBody&quot;&gt;
      
      
      
      &lt;p&gt;Go语言的channel又两种类型，一种是无缓存的channel，一种是有缓存的buffer，这两种类型的channel大家都比较熟悉了，但是对于有缓存的channel,它的缓存长度在创建channel的时候就已经确定了，中间不能扩缩容，这导致在一些场景下使用有问题，或者说不太适合特定的场景。&lt;/p&gt;
&lt;a id=&quot;more&quot;/&gt;
&lt;p&gt;我为什么突然谈起这个无限缓存的channel呢？第一，它是对我的极客专栏&lt;a href=&quot;https://time.geekbang.org/column/intro/355&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Go并发编程实战课&lt;/a&gt;的补充，另外主要是我最近在review公司一位同事的代码时，我的某种设计思路出现了一个问题，如果使用无限缓存的channel的话，这个问题就会迎刃而解了。&lt;/p&gt;
&lt;p&gt;这位同事的设计大概是这样子的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个dispatcher包含一个channel, 里面存放待处理的url&lt;/li&gt;
&lt;li&gt;一堆worker从channel中读取任务，下载解析网页，并提取其中链接，再把链接放入到dispatcher.channel中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这位同时使用了比较复杂的sync.Mutex和sync.Cond，并且定义了一堆并发的方法处理逻辑，这里我们不谈论这位同事的设计，只谈谈我的错误想法。&lt;/p&gt;
&lt;p&gt;我review这段代码的时候想，如果每个 worker启动一个goroutine,处理url，然后把链接再放入到channel中即可，不用复杂的 Mutex+Cond等，但是我犯了一个错误，那就是如果当前channel已经满了，那么这些worker都不能把解析的结果放入到channel中，都被&quot;阻塞&quot;住了，并且也没有可用的worker从channel中消费url。&lt;/p&gt;
&lt;p&gt;当然，你可以说可以创建一个buffer非常大的channel，避免被塞满，但是,第一,buffer非常大的channel占用的内存也非常大，第二，多大合适？关键你不能保证channel不会满。&lt;/p&gt;
&lt;p&gt;如果有一个无限缓存长度的buffer就好了。&lt;/p&gt;
&lt;p&gt;2017年，有同学像Go官方提出这么一个需求(&lt;a href=&quot;https://github.com/golang/go/issues/20352&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#20352&lt;/a&gt;),希望能够提供一个无限容量的buffer，经过冗长的讨论，Go不会为这个&quot;稀有&quot;的场景提供一种实现，并且建议大家实现这样的一个库，通过第三库的方式处理这种场景，而且Griesemer提供了一个思路，通过ringbuffer实现缓存来实现这样的channel。&lt;/p&gt;
&lt;p&gt;往网上有两种实现&lt;a href=&quot;https://stackoverflow.com/questions/41906146/why-go-channels-limit-the-buffer-size&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Why Go channels limit the buffer size&lt;/a&gt;和&lt;a href=&quot;https://medium.com/capital-one-tech/building-an-unbounded-channel-in-go-789e175cd2cd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Building an Unbounded Channel in Go&lt;/a&gt;,这两种实现也比较类似，我在第一种实现的基础上，封装了一个库: &lt;a href=&quot;https://github.com/smallnest/chanx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;chanx&lt;/a&gt;,来提供通用的无限缓存的channel。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/smallnest/chanx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;chanx&lt;/a&gt;, 你可以star这个库，放入到你的代码库中，说不定哪一天它就可能帮你解燃眉之急。并且我已经准备好了泛型的设计，一旦Go泛型可用，我就会把它改成泛型的实现。&lt;/p&gt;
&lt;p&gt;缓存无限的channel拥有下面的特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;不会阻塞write&lt;/strong&gt;。 它总是能处理write的数据，或者放入到待读取的channel中，或者放入到缓存中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无数据时read会被阻塞&lt;/strong&gt;。当没有可读的数据时，从channel中读取的goroutine会被阻塞&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读写都是通过channel操作&lt;/strong&gt;。 内部的缓存不会暴露出来&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;能够查询当前待读取的数据数量&lt;/strong&gt;。因为缓存中可能也有待处理的数据，所以需要返回len(buffer)+len(chan)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关闭channel后，还未读取的channel还是能够被读取，读取完之后才能发现channel已经完毕&lt;/strong&gt;。这和正常的channel的逻辑是一样的，这种情况叫&quot;drain&quot;未读的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为我们不能修改内部的channel结构，也不能重载 chan &amp;lt;- 和 &amp;lt;- chan 操作符,所以我们只能通过两个channel的方式封装一个数据结构,来提供读写。&lt;/p&gt;
&lt;p&gt;这个数据结构为:&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;4&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;5&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; UnboundedChan &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;In     &lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt;&amp;lt;- T &lt;span class=&quot;comment&quot;&gt;// channel for write&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;Out    &amp;lt;-&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; T &lt;span class=&quot;comment&quot;&gt;// channel for read&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;buffer []T      &lt;span class=&quot;comment&quot;&gt;// buffer&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;其中&lt;code&gt;In&lt;/code&gt;这个channel用来写入数据，而&lt;code&gt;Out&lt;/code&gt;这个channel用来读取数据。你可以close In这个channel,等所有的数据都读取完后，Out channel也会被自动关闭。 用户是不能自己关闭&lt;code&gt;Out&lt;/code&gt;这个channel的，你也关闭不了，因为它是&lt;code&gt;&amp;lt;-chan&lt;/code&gt;类型的。&lt;/p&gt;
&lt;p&gt;你可以通过&lt;code&gt;Len&lt;/code&gt;方法得到所有待读取的数据的长度，也可以通过&lt;code&gt;BufLen&lt;/code&gt;只获取缓存中的数据的长度，不包含外发&lt;code&gt;Out&lt;/code&gt; channel中数据的长度。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;4&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;5&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;6&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;7&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;8&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;9&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Len returns len of Out plus len of buffer.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (c UnboundedChan) Len() &lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(c.buffer) + &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(c.Out)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// BufLen returns len of the buffer.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (c UnboundedChan) BufLen() &lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(c.buffer)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;那么重点来了，主要的逻辑的实现如下，我在代码中加了注释，通过注释和代码你就可以很好的理解整个的实现逻辑:&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;4&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;5&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;6&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;7&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;8&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;9&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;10&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;11&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;12&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;13&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;14&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;15&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;16&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;17&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;18&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;19&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;20&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;21&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;22&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;23&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;24&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;25&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;26&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;27&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;28&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;29&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;30&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;31&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;32&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;33&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;34&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;35&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;36&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;37&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;38&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;39&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;40&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;41&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;42&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;43&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;44&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;45&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;46&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;47&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;48&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;49&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;50&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;51&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;52&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;53&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;54&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;55&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;56&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;57&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; NewUnboundedChan(initCapacity &lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt;) UnboundedChan {&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建三个字段和无限缓存的chan类型&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;in := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; T, initCapacity)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;out := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; T, initCapacity)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;ch := UnboundedChan{In: in, Out: out, buffer: &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]T,&lt;span class=&quot;number&quot;&gt; 0&lt;/span&gt;, initCapacity)}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 通过一个goroutine,不断地从in中读取出来数据，放入到out或者buffer中&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;() {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;close&lt;/span&gt;(out) &lt;span class=&quot;comment&quot;&gt;// in关闭，数据读取完后也把out关闭&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;loop:&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;val, ok := &amp;lt;-in &lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !ok { &lt;span class=&quot;comment&quot;&gt;// 如果in已经被closed, 退出loop&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt; loop&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 否则尝试把从in中读取出来的数据放入到out中&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; out &amp;lt;- val: &lt;span class=&quot;comment&quot;&gt;//放入成功，说明out刚才还没有满，buffer中也没有额外的数据待处理，所以回到loop开始&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果out已经满了，需要把数据放入到缓存中&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;ch.buffer = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(ch.buffer, val)&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 处理缓存，一直尝试把缓存中的数据放入到out,直到缓存中没有数据了,&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 为了避免阻塞住in channel,还要尝试从in中读取数据，因为这个时候out是满的，所以就直接把数据放入到缓存中&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(ch.buffer) &amp;gt;&lt;span class=&quot;number&quot;&gt; 0&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; val, ok := &amp;lt;-in: &lt;span class=&quot;comment&quot;&gt;// 从in读取数据，放入到缓存中，如果in被closed, 退出loop&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !ok { &lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt; loop&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;ch.buffer = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(ch.buffer, val)&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; out &amp;lt;- ch.buffer&lt;span class=&quot;number&quot;&gt;[0&lt;/span&gt;]: &lt;span class=&quot;comment&quot;&gt;// 把缓存中最老的数据放入到out中，并移出第一个元素&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;ch.buffer = ch.buffer&lt;span class=&quot;number&quot;&gt;[1&lt;/span&gt;:]&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(ch.buffer) ==&lt;span class=&quot;number&quot;&gt; 0&lt;/span&gt; { &lt;span class=&quot;comment&quot;&gt;// 避免内存泄露. 如果缓存处理完了，恢复成原始的状态&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;ch.buffer = &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]T,&lt;span class=&quot;number&quot;&gt; 0&lt;/span&gt;, initCapacity)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// in被关闭，退出loop后，buffer中可能还有未处理的数据，需要把它们塞入到out中&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 这个逻辑叫做&quot;drain&quot;。&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 这一段逻辑处理完后，就可以把out关闭掉了&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(ch.buffer) &amp;gt;&lt;span class=&quot;number&quot;&gt; 0&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;out &amp;lt;- ch.buffer&lt;span class=&quot;number&quot;&gt;[0&lt;/span&gt;]&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;ch.buffer = ch.buffer&lt;span class=&quot;number&quot;&gt;[1&lt;/span&gt;:]&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}()&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ch&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这一段的逻辑还是很清晰的，就是细节需要注意，它也是学习channel使用的一个很好的素材。&lt;/p&gt;
&lt;h2 id=&quot;5月13日更新&quot;&gt;5月13日更新&lt;/h2&gt;
&lt;p&gt;今天正好出差，在高铁上漫长的5个多小时没有事情做，所以我拿起笔记本干了两件事情，其中之一就是对这个无限缓存的channel做了优化。&lt;/p&gt;
&lt;p&gt;本身这个无限缓存的channel的设计非常简洁，唯一有一点我不太满意的是它的buffer不能重用, 这和&lt;code&gt;ch.buffer = ch.buffer[1:]&lt;/code&gt;的处理有关系,有时候明明底层的数组很大，但是还不得不重新生成新的数据，导致堆分配频次比较多。&lt;/p&gt;
&lt;p&gt;依照Go三巨头之一的设计，底层buffer最好采用ringbuffer的实现方式，如果buffer满了应该能&lt;a href=&quot;https://github.com/golang/go/issues/20352#issuecomment-365494616&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;自动扩容&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Such a library should do well in cases of very fast, &quot;bursty&quot; messages. A large enough buffered channel should be able to absorb bursts while a fast dedicated goroutine drains the channel into a ring buffer from which the messages are delivered at a slower pace to the final consumer of the messages. That ring buffer will need to be efficiently implemented, and will need to be able to grow efficiently (irrespective of size) and that will require some careful engineering. Better to leave that code to a library that can be tuned as needed than baking it into the runtime (and then possibly being at the mercy of release cycles).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我又实现了一个&lt;a href=&quot;https://github.com/smallnest/chanx/blob/main/ringbuffer.go&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ringbuffer&lt;/a&gt;,这个ringbuffer比较简单，原因在这里我们不需要考虑并发的问题，这个ringbuffer只会在一个goroutine使用，所以它的实现就非常的简单了，需要注意&quot;读追上写&quot;，以及&quot;写满&quot;这两个边界问题就好了。通过使用ringbuffer，上面的实现就可以更改为下面的代码，可以进一步减少写爆发(burst)的时候分配过多的问题：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;4&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;5&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;6&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;7&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;8&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;9&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;10&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;11&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;12&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;13&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;14&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;15&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;16&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;17&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;18&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;19&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;20&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;21&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;22&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;23&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;24&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;25&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;26&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;27&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;28&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;29&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;30&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;31&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;32&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;33&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;34&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;35&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;36&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;37&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;38&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;39&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;40&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;41&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;42&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;43&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;44&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;45&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;46&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;47&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;48&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;49&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;50&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; NewUnboundedChan(initCapacity &lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt;) UnboundedChan {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;in := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; T, initCapacity)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;out := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; T, initCapacity)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;ch := UnboundedChan{In: in, Out: out, buffer: NewRingBuffer(initCapacity)}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;() {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;close&lt;/span&gt;(out)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;loop:&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;val, ok := &amp;lt;-in&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !ok { &lt;span class=&quot;comment&quot;&gt;// in is closed&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt; loop&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// out is not full&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; out &amp;lt;- val:&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// out is full&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;ch.buffer.Write(val)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; !ch.buffer.IsEmpty() {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; val, ok := &amp;lt;-in:&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !ok { &lt;span class=&quot;comment&quot;&gt;// in is closed&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt; loop&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;ch.buffer.Write(val)&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; out &amp;lt;- ch.buffer.Peek():&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;ch.buffer.Pop()&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ch.buffer.IsEmpty() &amp;amp;&amp;amp; ch.buffer.size &amp;gt; ch.buffer.initialSize { &lt;span class=&quot;comment&quot;&gt;// after burst&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;ch.buffer.Reset()&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// drain&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; !ch.buffer.IsEmpty() {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;out &amp;lt;- ch.buffer.Pop()&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;ch.buffer.Reset()&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}()&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ch&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


      
    &lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d75f4e2f6b86b5fdce1014bb8da15898</guid>
<title>Java 并发工具篇</title>
<link>https://toutiao.io/k/8ee5tsg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;作者：汤圆&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;个人博客：&lt;/span&gt;javalover.cc&lt;/p&gt;&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;随着天气的逐渐变热，整个人也开始浮躁不安&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然这里说的不是我，因为我是一个比较安静的人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;讲的是隔壁的老大哥，在训斥年幼的孩子&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一通吼叫过后，男人安静了下来，孩子也哭个不停&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;h2&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;前面我们介绍了 JUC 中的并发容器，它相当于一个同步容器的升级版，很大程度上提高了并发的性能&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天我们来介绍 JUC 中的并发工具，&lt;/span&gt;&lt;strong&gt;它主要是通过改变自身的状态来控制线程的执行流程&lt;/strong&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常见的有如下几种：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;CountDownLatch&lt;/strong&gt;&lt;span&gt;：倒计时器（属于闭锁的一种实现），用来阻塞线程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;CyclicBarrier&lt;/strong&gt;&lt;span&gt;：循环栅栏，类似倒计时器，但是比他更高级，也是用来阻塞线程（只不过阻塞的方式不同，下面会具体介绍）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Semaphore&lt;/strong&gt;&lt;span&gt;：信号量，用来控制多个线程同时访问指定的资源，比如我们常用的数据库连接池&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下面让我们开始吧&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;文章如果有问题，欢迎大家批评指正，在此谢过啦&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/h2&gt;&lt;ol start=&quot;&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;什么是并发工具&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;倒计数器 CountDownLatch&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;倒计数器升级版 CyclicBarrier【循环栅栏】&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;倒计数器 CountDownLatch 和循环栅栏 CyclicBarrier、信号量Semaphore 的区别&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;信号量 Semaphore&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;1. 什么是并发工具&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;并发工具是一组工具类，主要是用来控制线程的执行流程，比如阻塞某个线程，以等待其他线程&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2. 倒计数器 CountDownLatch&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;从字面意思来看，就是一个倒计数门闩（shuan，打了半天zha就是打不出来)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通俗一点来说，就是倒计数，时间一到，门闩就打开&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;注：一旦打开，就不能再合上，即这个 CountDownLatch 的状态改变是永久不可恢复的（记住这个点，后面会有对比）&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;比较官方的说法：倒计数器用来阻塞某个（某些）线程，以等待其他多个线程的任务执行完成（以这个说法为准，上面的可以用来对比参考）&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;下面列出 CountDownLatch 的几个方法：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;构造方法&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;code&gt;public CountDownLatch(int count)&lt;/code&gt;&lt;span&gt;，其中count就是我们所说的内部状态（当count=0时，表示到达终止状态，此时会恢复被阻塞的线程）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;修改状态&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;code&gt;public void countDown()&lt;/code&gt;&lt;span&gt;，该方法会递减上面的count状态，每执行一次，就-1；（当count=0时，表示到达终止状态，此时会恢复被阻塞的线程）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;等待&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;code&gt;public void await()&lt;/code&gt;&lt;span&gt;，该方法会阻塞当前线程，直到count状态变为0，才会恢复执行（除非中断，此时会抛出中断异常）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;超时等待&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;code&gt;public boolean await(long timeout, TimeUnit unit)&lt;/code&gt;&lt;span&gt;，类似上面的await,只不过可以设置超时时间，等过了超时时间，还在阻塞，则直接恢复&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;获取状态值 count&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;code&gt;public long getCount()&lt;/code&gt;&lt;span&gt;，获取count的数值，以查看还可以递减多少次（多用来调试）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;模拟场景的话，这里先列举三个，肯定还有其他的&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我们以第三个场景为例，写个例子：多人游戏加载画面&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot;&gt;&lt;div lang=&quot;java&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;CountDownLatchDemo&lt;/span&gt; {&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;(&lt;span&gt;String&lt;/span&gt;[] &lt;span&gt;args&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt; &lt;span&gt;InterruptedException&lt;/span&gt; {&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;// 1. 构造一个倒计数器，给定一个状态值10&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;CountDownLatch&lt;/span&gt; &lt;span&gt;latch&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;CountDownLatch&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.&lt;span&gt;println&lt;/span&gt;(&lt;span&gt;&quot;准备加载&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;      &lt;span role=&quot;presentation&quot; cm-text=&quot;&quot;&gt;  &lt;/span&gt;&lt;span&gt;// 这里我们创建10个线程，模拟 5V5 游戏的10个玩家&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; &lt;span&gt;i&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;i&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;; &lt;span&gt;i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;) {&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt;(()&lt;span&gt;-&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;// 这里我们给点延时，模拟网络延时&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                    &lt;span&gt;Thread&lt;/span&gt;.&lt;span&gt;sleep&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                } &lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;InterruptedException&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;) {&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                    &lt;span&gt;e&lt;/span&gt;.&lt;span&gt;printStackTrace&lt;/span&gt;();&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                }&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.&lt;span&gt;println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;.&lt;span&gt;currentThread&lt;/span&gt;().&lt;span&gt;getName&lt;/span&gt;()&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;加载100%&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;// 2. 这里的countDown就是用来改变倒计数器的内部状态，每次-1&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;latch&lt;/span&gt;.&lt;span&gt;countDown&lt;/span&gt;(); &lt;span&gt;//这里不会阻塞当前线程，执行完后就立马返回了&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;            }).&lt;span&gt;start&lt;/span&gt;();&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        }&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;// 3. 这里阻塞等待状态的完成，即10变为0;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;latch&lt;/span&gt;.&lt;span&gt;await&lt;/span&gt;();&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.&lt;span&gt;println&lt;/span&gt;(&lt;span&gt;&quot;所有人加载完成，开始游戏&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;/&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;输出如下：&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot;&gt;&lt;div lang=&quot;java&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;准备加载&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;加载100&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;加载100&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;加载100&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;加载100&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;加载100&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;加载100&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;加载100&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;加载100&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;加载100&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;加载100&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;所有人加载完成，开始游戏&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;这里倒计数器的作用就是阻塞主线程，以等待其他10个子线程，等到都准备好，再恢复主线程&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的特点就是：一次性使用，达到终止状态后不能再改变&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3. 倒计时器升级版 CyclicBarrier【循环栅栏】&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;循环栅栏，类似倒计数器，也是用来阻塞线程，不过它的重点在于&lt;/span&gt;&lt;strong&gt;循环&lt;/strong&gt;&lt;span&gt;使用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而倒计数器只能用一次（这属于他们之间最明显的一个区别）&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;PS：猜测之所以叫循环栅栏，而不是循环门闩，可能是因为栅栏的作用比门闩更强大，所以叫栅栏更适合吧&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;官方说法：循环栅栏一般用来表示多个线程之间的相互等待（阻塞）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如有10个线程，都要await等待；那要等到最后一个线程await时，栅栏才会打开&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果有定义栅栏动作，那么当栅栏打开时，会执行栅栏动作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;栅栏动作就是：栅栏打开后需执行的动作，通过构造函数的Runnable参数指定，可选参数&lt;/strong&gt;&lt;span&gt;，下面会介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个属于循环栅栏和倒计数器的&lt;/span&gt;&lt;strong&gt;第二个区别&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我们看几个循环栅栏 CyclicBarrier 内部的方法：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;构造方法&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;code&gt;public CyclicBarrier(int parties, Runnable barrierAction)&lt;/code&gt;&lt;span&gt;，第一个表示需等待（阻塞）的线程数，第二个barrierAction就是上面我们说的栅栏动作，即当最后一个线程也被阻塞时，就会触发这个栅栏动作（这个参数可选，如果没有，则不执行任何动作）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;等待&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;code&gt;public int await()&lt;/code&gt;&lt;span&gt;，阻塞当前线程，直到最后一个线程被阻塞，才会恢复&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;超时等待&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;code&gt;public boolean await(long timeout, TimeUnit unit)&lt;/code&gt;&lt;span&gt;，类似上面的await,只不过可以设置超时时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;获取当前等待的线程数&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;code&gt;public int getNumberWaiting()&lt;/code&gt;&lt;span&gt;，即调用了await方法的线程数量&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;场景：&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;下面看下例子：多人游戏团战画面&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot;&gt;&lt;div lang=&quot;java&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;CyclicBarrierDemo&lt;/span&gt; {&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;(&lt;span&gt;String&lt;/span&gt;[] &lt;span&gt;args&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt; &lt;span&gt;InterruptedException&lt;/span&gt; {&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;/&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;// 1. 创建一个循环栅栏，给定等待线程数10和栅栏动作&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;CyclicBarrier&lt;/span&gt; &lt;span&gt;barrier&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;CyclicBarrier&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;,()&lt;span&gt;-&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;// 栅栏动作，等到所有线程都await，就会触发&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.&lt;span&gt;println&lt;/span&gt;(&lt;span&gt;&quot;=== 人齐了，开始团吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;Thread&lt;/span&gt;.&lt;span&gt;sleep&lt;/span&gt;(&lt;span&gt;2000&lt;/span&gt;);&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;            } &lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;InterruptedException&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;) {&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;e&lt;/span&gt;.&lt;span&gt;printStackTrace&lt;/span&gt;();&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;            }&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        });&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.&lt;span&gt;println&lt;/span&gt;(&lt;span&gt;&quot;=== 准备第一波团战 ===&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;// 2. 创建10个线程，模拟10个玩家&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; &lt;span&gt;i&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;i&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;; &lt;span&gt;i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;) {&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt;(()&lt;span&gt;-&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                    &lt;span&gt;// 玩家到场&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                    &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.&lt;span&gt;println&lt;/span&gt;(&lt;span&gt;Thread&lt;/span&gt;.&lt;span&gt;currentThread&lt;/span&gt;().&lt;span&gt;getName&lt;/span&gt;()&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;=&amp;gt;第一波团，我准备好了&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                    &lt;span&gt;// 等待其他人，等人齐就可以团了（人齐了会执行栅栏动作，此时这边也会恢复执行）&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                    &lt;span&gt;barrier&lt;/span&gt;.&lt;span&gt;await&lt;/span&gt;();&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                } &lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;InterruptedException&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;) {&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                    &lt;span&gt;e&lt;/span&gt;.&lt;span&gt;printStackTrace&lt;/span&gt;();&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                } &lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;BrokenBarrierException&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;) {&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                    &lt;span&gt;e&lt;/span&gt;.&lt;span&gt;printStackTrace&lt;/span&gt;();&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;                }&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;            }).&lt;span&gt;start&lt;/span&gt;();&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        }&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;// 3. 查询当前等待都线程数量，如果不为0，则主线程继续等待&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;barrier&lt;/span&gt;.&lt;span&gt;getNumberWaiting&lt;/span&gt;()&lt;span&gt;!=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;){&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;            &lt;span&gt;Thread&lt;/span&gt;.&lt;span&gt;sleep&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        }&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.&lt;span&gt;println&lt;/span&gt;(&lt;span&gt;&quot;=== 第一波团战结束 ===&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;span&gt;// 4. 此时还可以进行第二波第三波团战。。。（循环栅栏可循环触发，倒计数器只能触发一次）&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;        &lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;    }&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;输出如下：&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot;&gt;&lt;div lang=&quot;java&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;准备第一波团战&lt;/span&gt; &lt;span&gt;===&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;第一波团，我准备好了&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;第一波团，我准备好了&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;第一波团，我准备好了&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;第一波团，我准备好了&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;第一波团，我准备好了&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;第一波团，我准备好了&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;第一波团，我准备好了&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;第一波团，我准备好了&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;第一波团，我准备好了&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;第一波团，我准备好了&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;人齐了，开始团吧&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre role=&quot;presentation&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;第一波团战结束&lt;/span&gt; &lt;span&gt;===&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;4. 信号量 Semaphore&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;信号量主要是用来控制多个线程同时访问指定资源，比如数据库连接池，超过指定数量，就阻塞等待&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我们介绍下信号量的几个关键方法：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;构造方法：&lt;/span&gt;&lt;code&gt;public Semaphore(int permits, boolean fair)&lt;/code&gt;&lt;span&gt;,第一个参数为许可数，即允许同时访问的的线程数，第二个参数为公平还是非公平模式（默认非公平）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;获取许可：&lt;/span&gt;&lt;code&gt;public void acquire()&lt;/code&gt;&lt;span&gt;，如果有许可，则直接返回，并将许可数递减1；如果没可用的许可，就阻塞等待，或者被中断&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;尝试获取许可：&lt;/span&gt;&lt;code&gt;public boolean tryAcquire()&lt;/code&gt;&lt;span&gt;，类似上面的acquire，但是不会被阻塞和中断，因为如果没有可用的许可，则直接返回false&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;释放许可：&lt;/span&gt;&lt;code&gt;public void release()&lt;/code&gt;&lt;span&gt;，释放一个许可，并将许可数递增1&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;获取可用的许可数量：&lt;/span&gt;&lt;code&gt;public int availablePermits()&lt;/code&gt;&lt;span&gt;，这个方法一般用来调试&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;场景：数据库连接池&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;信号量的特点就是可重复使用许可，所以像数据库连接池这种场景就很适合了&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;这里就不举例子了，就是多个线程acquire和release，获取许可时，如果没有就阻塞，如果有就立即返回&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;5 区别&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;用表格看比较方便点&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;区别&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;CyclicBarrier&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Semaphore&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;可使用次数&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;单次&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;多次（循环使用）&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;多次（循环使用）&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;线程的阻塞&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;阻塞单个（多个）线程，以等待其他线程的执行&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;多个线程之间的相互阻塞&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;超过许可数，会阻塞&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;场景&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1. 计数器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 统计任务执行时长&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. 多人对战游戏的开局等待&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1. 大事化小，再合并&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 多人对战游戏的团战&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1. 数据库连接池&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;可以看到，倒计数器主要是用来表示单个线程等待多个线程，而循环栅栏主要是用来表示多个线程之间的相互等待&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;h2&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;ol start=&quot;&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;什么是并发工具：并发工具是一组工具类，主要是用来控制线程的执行流程，比如阻塞某个线程，以等待其他线程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;倒计数器 CountDownLatch：用来表示阻塞某个（某些）线程，以等待其他多个线程的任务执行完成&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;循环栅栏 CyclicBarrier：用来表示多个线程之间的相互等待协作（阻塞）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;信号量 Semaphore：用来表示允许同时访问指定资源的许可数（线程数）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;区别：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;区别&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;CyclicBarrier&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Semaphore&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;可使用次数&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;单次&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;多次（循环使用）&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;多次（循环使用）&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;线程的阻塞&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;阻塞单个（多个）线程，以等待其他线程的执行&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;多个线程之间的相互阻塞&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;超过许可数，会阻塞&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;场景&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1. 计数器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 统计任务执行时长&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. 多人对战游戏的开局等待&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1. 大事化小，再合并&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 多人对战游戏的团战&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;1. 数据库连接池&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;参考内容：&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;学习之路，真够长，共勉之&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;写在最后：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;愿你的意中人亦是中意你之人&lt;/strong&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b53247c33e1bb6bc12e10f48ca2431fa</guid>
<title>2021 Java 后端实习春招面试题整理（含答案）</title>
<link>https://toutiao.io/k/o9vzo5r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-topic-des nc-post-content&quot;&gt;
&lt;h1&gt;Java面试题整理&lt;/h1&gt; 
&lt;h2&gt;Java基础&lt;/h2&gt; 
&lt;h3&gt;Java是解释性还是编译性语言？&lt;/h3&gt; 
&lt;p&gt;既是编译性语言（需要由编译器编译为.class字节码文件），又是解释性语言（需要由JVM读一行执行一行，由解释器解释为操作系统能执行的命令）&lt;/p&gt; 
&lt;p&gt;Java的编译器是javac.exe，解释器是java.exe&lt;/p&gt; 
&lt;h3&gt;为什么引入Hash？好处是什么？&lt;/h3&gt; 
&lt;p&gt;&lt;span&gt;简称散列&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;，是将一个大文件映射成一个小串字符。与指纹一样，就是以较短的信息来保证文件的唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;好处：&lt;/p&gt; 
&lt;p&gt;1） 在庞大的数据库中，由于哈希值更为短小，被找到更为容易，因此，哈希使数据的存储与查询速度更快。&lt;/p&gt; 
&lt;p&gt;2） 哈希能对信息进行加密处理，使得数据传播更为安全。&lt;/p&gt; 
&lt;h3&gt;什么是动态代理？&lt;/h3&gt; 
&lt;p&gt;动态代理就是，在&lt;strong&gt;程序运行期&lt;/strong&gt;，创建目标对象的代理对象，并&lt;strong&gt;对目标对象中的方法进行功能性增强&lt;/strong&gt;的一种技术。在生成代理对象的过程中，目标对象不变，代理对象中的方法是目标对象方法的增强方法。可以理解为&lt;strong&gt;运行期间，对象中方法的动态拦截，在拦截方法的前后执行功能操作&lt;/strong&gt;。&lt;/p&gt; 
&lt;h3&gt;什么是java的反射机制？&lt;/h3&gt; 
&lt;p&gt;反射是&lt;strong&gt;动态获取信息&lt;/strong&gt;以及&lt;strong&gt;动态调用对象方法&lt;/strong&gt;的一种机制。&lt;/p&gt; 
&lt;p&gt;Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。而这也是Java被视为动态语言的一个关键性质。&lt;/p&gt; 
&lt;p&gt;Java反射的功能是在运行时判断任意一个对象所属的类，在运行时构造任意一个类的对象，在运行时判断任意一个类所具有的成员变量和方法，在运行时调用任意一个对象的方法，生成动态代理。&lt;/p&gt; 
&lt;h3 id=&quot;final&quot;&gt;final&lt;/h3&gt; 
&lt;p&gt;一、final修饰类&lt;/p&gt; 
&lt;p&gt;final修饰一个类的时候，这个类&lt;strong&gt;不能被继承&lt;/strong&gt;，final类中的方法都会被隐式的指定为final方法，JDK中被设计为final类的有String、System等。&lt;/p&gt; 
&lt;p&gt;二、final修饰方法&lt;/p&gt; 
&lt;p&gt;被final修饰的方法&lt;strong&gt;不能被重写&lt;/strong&gt;，&lt;strong&gt;可以被重载&lt;/strong&gt;，一个类的private方***隐式的被指定为final方法。&lt;/p&gt; 
&lt;p&gt;三、final修饰成员变量&lt;/p&gt; 
&lt;p&gt;被final修饰的成员变量必须要赋初始值，而且只能初始化一次，可以直接赋值或在构造方法中赋初值。如果final修饰的成员变量是&lt;strong&gt;基本类型&lt;/strong&gt;，则表示这个变量的&lt;strong&gt;值不能改变&lt;/strong&gt;，如果修饰的成员变量是一个&lt;strong&gt;引用类型&lt;/strong&gt;，则引用的&lt;strong&gt;地址不能改变&lt;/strong&gt;，但是这个引用所指向的&lt;strong&gt;对象里面的内容可以改变&lt;/strong&gt;。&lt;/p&gt; 
&lt;h3&gt;static修饰的方法可以被重写吗？重载呢？&lt;/h3&gt; 
&lt;p&gt;不可以重写。&lt;/p&gt; 
&lt;p&gt;当我们在子类中改变方法体时，子类的该方法只是将父类的方法进行了&lt;strong&gt;隐藏&lt;/strong&gt;，而非重写，&lt;strong&gt;这两个方法没有关系&lt;/strong&gt;。父类引用指向子类对象时，只会调用父类的静态方法，所以&lt;strong&gt;不具有多态性&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;可以重载。&lt;/p&gt; 
&lt;h3&gt;Java的异常体系及异常的捕获和处理？&lt;/h3&gt; 
&lt;p&gt;一、Java的异常体系&lt;/p&gt; 
&lt;p&gt;Throwable（表示可抛出）是所有异常和错误的超类，两个直接子类为Error和Exception，分别表示错误和异常。异常又可分为运行时异常（不检查异常）和非运行时异常（检查异常）。&lt;/p&gt; 
&lt;p&gt;1、Error和Exception：&lt;/p&gt; 
&lt;p&gt;Error是程序&lt;strong&gt;无法处理&lt;/strong&gt;的错误，是由JVM产生和抛出的，比如OutOfMemoryError、ThreadDeath等。Error发生时JVM会选择&lt;strong&gt;线程终止&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;Exception是程序可以处理的异常，程序中应当尽可能去处理这些异常。&lt;/p&gt; 
&lt;p&gt;2、运行时异常和非运行时异常：&lt;/p&gt; 
&lt;p&gt;运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中&lt;strong&gt;可以选择捕获处理，也可以不处理&lt;/strong&gt;。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。&lt;/p&gt; 
&lt;p&gt;非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，&lt;strong&gt;如果不处理，程序就不能编译通过&lt;/strong&gt;。如IOException、SQLException等以及用户自定义的Exception异常。&lt;/p&gt; 
&lt;p&gt;二、异常的捕获和处理&lt;/p&gt; 
&lt;p&gt;1、try catch finally&lt;/p&gt; 
&lt;p&gt;1）可以组成try...catch...finally、try...catch、try...finally三种结构，&lt;strong&gt;catch可以有一个或多个&lt;/strong&gt;，&lt;strong&gt;finally最多一个&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;2）try、catch、finally三个代码块中&lt;strong&gt;变量的作用域为代码块内部&lt;/strong&gt;，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。&lt;/p&gt; 
&lt;p&gt;3）多个catch块时候，&lt;strong&gt;最多只会匹配其中一个异常类且只会执行该catch块代码&lt;/strong&gt;，而不会再执行其它的catch块，且匹配catch语句的顺序为从上到下，也可能所有的catch都没执行&lt;/p&gt; 
&lt;p&gt;2、throw和throws&lt;/p&gt; 
&lt;p&gt;throw关键字用于&lt;strong&gt;方法体内部&lt;/strong&gt;，用来抛出一个Throwable类型的异常。如果&lt;strong&gt;抛出了检查异常，则应该在方法头部声明方法可能抛出的异常类型&lt;/strong&gt;，该方法的调用者必须处理或继续抛出异常。如果&lt;strong&gt;所有方法都层层上抛获取的异常，最终JVM会进行处理&lt;/strong&gt;，处理方式就是打印异常消息和堆栈信息。&lt;/p&gt; 
&lt;p&gt; throws关键字用于&lt;strong&gt;方法体外部的方法声明部分&lt;/strong&gt;，用来声明方法可能会抛出某些异常。仅当抛出了检查异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出。&lt;/p&gt; 
&lt;h3&gt;Java的方法分派？&lt;/h3&gt; 
&lt;p&gt;方法分派指的是虚拟机如何确定应该执行哪个方法。&lt;/p&gt; 
&lt;p&gt;静态分派（方法重载）：编译器确定，根据调用者的声明类型和方法参数类型。&lt;/p&gt; 
&lt;p&gt;动态分派（方法重写）：运行时确定，根据调用者的实际类型分派。&lt;/p&gt; 
&lt;h3&gt;Serializable接口中serialVersionUID的作用？&lt;/h3&gt; 
&lt;p&gt;在序列化的时候系统将serialVersionUID写入到序列化的文件中去，当反序列化的时候系统会先去检测文件中的serialVersionUID是否跟当前类的serialVersionUID是否一致，如果一致则反序列化成功，否则就说明当前类跟序列化后的类发生了变化，比如是成员变量的数量或者是类型发生了变化，那么在反序列化时就会发生crash，并且报错。&lt;/p&gt; 
&lt;h2 id=&quot;jvm&quot;&gt;JVM&lt;/h2&gt; 
&lt;h3&gt;引用的几种方式？&lt;/h3&gt; 
&lt;ol&gt; 
 &lt;li&gt;强引用：强引用是在程序代码之中普遍存在的引用赋值，类似&lt;code&gt;Object o = new Object()&lt;/code&gt;这种引用关系。无论任何情况下，只要强引用关系还在，垃圾收集器就&lt;strong&gt;永远不会回收&lt;/strong&gt;掉被引用的对象。 &lt;/li&gt;
 &lt;li&gt;软引用：用来描述一些还&lt;strong&gt;有用但非必须&lt;/strong&gt;的对象。只被软引用关联的对象，在系统要&lt;strong&gt;发生内存溢出异常前，会把这些对象列进回收范围之中进行二次回收&lt;/strong&gt;，如果这次回收还是没有足够的内存，才会抛出溢出异常。&lt;br/&gt;应用场景：做缓存（浏览器的后退按钮） &lt;/li&gt;
 &lt;li&gt;弱引用：也是用来描述那些&lt;strong&gt;非必须&lt;/strong&gt;对象，但它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作时，&lt;strong&gt;无论当前内存是否足够，都会回收掉只被弱引用关联的对象&lt;/strong&gt;。 &lt;/li&gt;
 &lt;li&gt;虚引用：最弱的一种引用关系，一个对象是否有虚引用的存在，&lt;strong&gt;完全不会对其生存时间构成影响&lt;/strong&gt;，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的只是为了在这个对象被收集器回收时收到一个系统通知。 &lt;/li&gt;
&lt;/ol&gt; 
&lt;h3&gt;minorGC和MajorGC分别发生在什么时候？&lt;/h3&gt; 
&lt;p&gt;minorGC:&lt;/p&gt; 
&lt;p&gt;1）Eden区满了 2）新创建对象的大小大于Eden所剩余空间&lt;/p&gt; 
&lt;p&gt;majorGC:&lt;/p&gt; 
&lt;p&gt;1）每次晋升到老年代的对象平均大小超过了老年代剩余空间&lt;/p&gt; 
&lt;p&gt;2）minorGC后存活的对象超过了老年代剩余空间&lt;/p&gt; 
&lt;h3&gt;minor GC和major GC的过程？&lt;/h3&gt; 
&lt;p&gt;&lt;span&gt;minor GC：在GC开始的时候，对象只会存在于Eden区和名为“From”的Sur&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=vivo&quot; target=&quot;_blank&quot;&gt;vivo&lt;/a&gt;r区，Sur&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=vivo&quot; target=&quot;_blank&quot;&gt;vivo&lt;/a&gt;r区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Sur&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=vivo&quot; target=&quot;_blank&quot;&gt;vivo&lt;/a&gt;r区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;major GC：参考CMS的工作过程。&lt;/p&gt; 
&lt;h3&gt;&lt;span&gt;垃圾收集&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;及各自的优缺点？&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span&gt;1、标记-清除&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;“标记-清除”&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;是最基础的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;，分为“标记”和“清除”两个阶段：&lt;/span&gt;&lt;strong&gt;首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。&lt;/strong&gt;&lt;br/&gt;缺点：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;执行效率不稳定；标记和清除两个过程的执行效率随对象数量增长而降低。 &lt;/li&gt;
 &lt;li&gt;内存空间的碎片化问题；标记、清除之后会产生大量不连续的内存碎片，导致当需要分配较大对象时无法找到足够的连续空间而不得不提前触发另一次垃圾收集动作。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;span&gt;2、标记-复制&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;（针对新生代）&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;标记-复制&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;将可用内存按容量划分为大小相等的两块，每次使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。&lt;/span&gt;&lt;br/&gt;优点：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;分配内存时不用考虑空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;缺点：&lt;/p&gt; 
 
&lt;p&gt;&lt;span&gt;3、标记-整理&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;（针对老年代）&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;复制&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;在对象存活率较高时就需要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用复制&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;根据老年代的特点提出了“标记-整理”&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;，标记过程仍然与“标记-清除”&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向空间一端移动，然后直接清理掉边界以外的内存。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;标记-清除&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;与标记-整理&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;的本质差异在于前者是一种非移动式的回收&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;，而后者是移动式的&lt;/span&gt;&lt;/strong&gt;。是否移动对象都存在弊端，移动对象操作必须全程暂停用户应用程序才能进行(&quot;Stop The World&quot;)，不移动对象会影响应用程序的吞吐量。&lt;/p&gt; 
&lt;h3&gt;CMS收集器是怎样的？&lt;/h3&gt; 
&lt;p&gt;CMS（Concurrent Mark Sweep）收集器是一种&lt;strong&gt;以获取最短回收停顿时间为目标的收集器&lt;/strong&gt;，基于&lt;strong&gt;标记-清除&lt;/strong&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;实现，是一款&lt;/span&gt;&lt;strong&gt;老年代收集器&lt;/strong&gt;，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。&lt;br/&gt;整个工作流程包括四个步骤：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;strong&gt;初始标记&lt;/strong&gt;：仅仅标记GC Roots能直接关联到的对象，速度很快，需要&lt;strong&gt;“Stop The World”&lt;/strong&gt;。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;并发标记&lt;/strong&gt;：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长但不需要停顿用户线程，可以与垃圾收集线程一起并发运行。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;重新标记&lt;/strong&gt;：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要&lt;strong&gt;“Stop The World”&lt;/strong&gt;。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;并发清除&lt;/strong&gt;：清理删除标记阶段判断的已经死亡的对象，不需要移动存活对象，可以与用户线程同时并发。 &lt;/li&gt;
&lt;/ol&gt; 
&lt;p&gt;由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。&lt;/p&gt; 
&lt;p&gt;优点：并发收集、停顿低&lt;/p&gt; 
&lt;p&gt;缺点：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;对CPU资源敏感，总吞吐量会降低 &lt;/li&gt;
 &lt;li&gt;无法处理浮动垃圾 &lt;/li&gt;
 &lt;li&gt;&lt;span&gt;标记-清除&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;导致空间碎片 &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt; 
&lt;h3&gt;什么情况下会出现OOM？&lt;/h3&gt; 
&lt;p&gt;OOM--OutOfMemoryError，当JVM因为没有足够的内存来为对象分配空间，并且垃圾回收器也已经没有空间可回收时，就会抛出这个error。&lt;/p&gt; 
&lt;p&gt;一、原因：&lt;/p&gt; 
&lt;p&gt;1、为虚拟机分配的内存太少&lt;/p&gt; 
&lt;p&gt;2、应用用的太多，并且用完没释放，此时就会造成内存泄露或者内存溢出&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;内存泄露：申请的内存在被使用完后没有释放，导致虚拟机不能再次使用该内存 &lt;/li&gt;
 &lt;li&gt;内存溢出：申请的内存超出了JVM能提供的内存大小 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;大量的内存泄露可能会导致内存溢出。&lt;/p&gt; 
&lt;p&gt;二、出现OOM时的分析方法&lt;/p&gt; 
&lt;p&gt;Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况，要解决这个区域的异常，一般的手段是先通过&lt;strong&gt;内存映像分析工具&lt;/strong&gt;（如Eclipse Memory Analyzer）对Dump出来的&lt;strong&gt;堆转储快照&lt;/strong&gt;进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清除到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。&lt;/p&gt; 
&lt;p&gt;三、OOM的解决方法&lt;/p&gt; 
&lt;p&gt;1、如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的&lt;strong&gt;引用链&lt;/strong&gt;。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收他们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确的定位出泄漏代码的位置。&lt;br/&gt;2、如果不存在泄漏，换句话说，就是内存中的对象确实还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。&lt;/p&gt; 
&lt;h3&gt;Java类加载机制&lt;/h3&gt; 
&lt;p&gt;一、类加载的时机&lt;/p&gt; 
&lt;p&gt;1、隐式加载：new创建类的实例&lt;/p&gt; 
&lt;p&gt;2、显示加载：loaderClass、forName&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;forName和loaderClass区别？&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt;Class.forName()得到的class是已经初始化完成的 &lt;/li&gt;
  &lt;li&gt;ClassLoader.loadClass()得到的class是还没有链接的 &lt;/li&gt;
 &lt;/ul&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;3、访问类的静态变量，或者为静态变量赋值&lt;/p&gt; 
&lt;p&gt;4、调用类的静态方法&lt;/p&gt; 
&lt;p&gt;5、使用反射创建某个类或者接口的Class对象&lt;/p&gt; 
&lt;p&gt;6、初始化某个类的子类&lt;/p&gt; 
&lt;p&gt;7、直接使用java.exe命令来运行某个类&lt;/p&gt; 
&lt;p&gt;二、类加载的过程&lt;/p&gt; 
&lt;p&gt;当需要某个类的时候，jvm会加载.class文件，并创建对应的class对象，将class文件加载到虚拟机的内存，这个过程被称为类的加载。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;加载：ClassLoader通过全类名查找类的字节码文件并创建一个class对象 &lt;/li&gt;
 &lt;li&gt;链接
  &lt;ul&gt; 
   &lt;li&gt;验证 &lt;/li&gt;
   &lt;li&gt;准备：为类变量（static修饰）分配内存并赋初始值
    &lt;ul&gt; 
     &lt;li&gt;static int i = 5这里只是将i赋值为0，初始化的阶段再把i赋值为5 &lt;/li&gt;
     &lt;li&gt;不包含final修饰的static，因为final在编译的时候就已经分配了 &lt;/li&gt;
    &lt;/ul&gt; &lt;/li&gt;
   &lt;li&gt;解析 &lt;/li&gt;
  &lt;/ul&gt; &lt;/li&gt;
 &lt;li&gt;初始化：如果该类有父类就对父类进行初始化 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;三、双亲委派模式&lt;/p&gt; 
&lt;p&gt;1、原理：&lt;/p&gt; 
&lt;p&gt;双亲委派模式要求除了顶层的启动类加载器之外，其余的&lt;strong&gt;类加载器都应该有自己的父类加载器&lt;/strong&gt;，但是在双亲委派模式中父子关系采取的并不是继承的关系而是组合来复用父类加载器的相关代码。&lt;/p&gt; 
&lt;p&gt;如果一个类收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行，如果父类加载器还有父类加载器，则进一步向上委托，依次递归，请求最后到达顶层的启动类加载器，如果父类能够完成类的加载任务，就会成功返回，如果父类加载器无法完成任务，子类加载器才会尝试自己去加载。&lt;/p&gt; 
&lt;p&gt;通俗理解：每个儿子都很懒，遇到类加载的活都给爸爸干，直到爸爸说我也做不来的时候，儿子才会想办法自己去加载。&lt;/p&gt; 
&lt;p&gt;2、优点：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;避免类的重复加载：父类加载器已经加载该类后子类加载器就没必要再加载一次 &lt;/li&gt;
 &lt;li&gt;安全性：防止核心API库被篡改 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;四、如何破坏双亲委派机制？&lt;/p&gt; 
&lt;p&gt;自定义的类加载器重写loadClass()方法，如果不想破坏双亲委派，那么重写findClass()方法。&lt;/p&gt; 
&lt;p&gt;五、NoClassDefFoundError 和 ClassNotFoundException 有什么区别？&lt;/p&gt; 
&lt;p&gt;1、ClassNotFoundException：当应用程序运行的过程中尝试使用&lt;strong&gt;类加载器去加载Class文件的时候，如果没有在classpath中查找到指定的类&lt;/strong&gt;，就会抛出ClassNotFoundException。一般情况下，当我们使用Class.forName()或者ClassLoader.loadClass()以及使用ClassLoader.findSystemClass()在运行时加载类的时候，如果类没有被找到，那么就会导致JVM抛出ClassNotFoundException。&lt;/p&gt; 
&lt;p&gt;2、NoClassDefFoundError：当JVM在加载一个类的时候，如果这个&lt;strong&gt;类在编译时是可用的，但是在运行时找不到这个类的定义&lt;/strong&gt;的时候，JVM就会抛出一个NoClassDefFoundError错误。比如当我们在new一个类的实例的时候，如果在运行时类找不到，则会抛出一个NoClassDefFoundError的错误。&lt;/p&gt; 
&lt;h3&gt;Java对象的创建过程&lt;/h3&gt; 
&lt;p&gt;1、分配内存&lt;/p&gt; 
&lt;p&gt;2、初始化&lt;/p&gt; 
 
&lt;h3&gt;Java内存分区？&lt;/h3&gt; 
&lt;p&gt;1、程序计数器：执行字节码的行号指示器，线程私有，没有OOM&lt;/p&gt; 
&lt;p&gt;2、Java虚拟机栈：存局部变量表、栈帧，线程私有&lt;/p&gt; 
&lt;p&gt;3、本地方法栈&lt;/p&gt; 
&lt;p&gt;4、Java堆：GC堆，存放对象实例，所有线程共享&lt;/p&gt; 
&lt;p&gt;5、方法区：常量池存在方法区，所有线程共享&lt;/p&gt; 
&lt;h2&gt;&lt;span&gt;数据结构与&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;h3&gt;LinkedList和ArrayList的区别？&lt;/h3&gt; 
&lt;p&gt;1、数据结构不同&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;ArrayList是基于数组的数据结构，LinkedList是基于&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;的数据结构&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;2、效率不同&lt;/p&gt; 
&lt;p&gt;当随机访问List（get和set操作）时，ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。&lt;/p&gt; 
&lt;p&gt;当对数据进行增加和删除的操作(add和remove操作)时，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。&lt;/p&gt; 
&lt;p&gt;3、自由性不同&lt;/p&gt; 
&lt;p&gt;ArrayList自由性较低，因为它需要手动的设置固定大小的容量（默认初始容量为10），但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；&lt;/p&gt; 
&lt;p&gt;LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。&lt;/p&gt; 
&lt;p&gt;4、主要控件开销不同&lt;/p&gt; 
&lt;p&gt;ArrayList主要控件开销在于需要在List列表预留一定空间；&lt;/p&gt; 
&lt;p&gt;LinkList主要控件开销在于需要存储结点信息以及结点指针信息。&lt;/p&gt; 
&lt;h3&gt;HashMap和Hashtable的区别？&lt;/h3&gt; 
&lt;p&gt;1、Hashtable出现的时间早（JDK1.0），HashMap出现的时间晚（JDK1.2）&lt;/p&gt; 
&lt;p&gt;2、Hashtable继承Dictionary类（已废弃），HashMap实现Map接口&lt;/p&gt; 
&lt;p&gt;3、Hashtable线程安全但效率低，HashMap非线程安全但效率高&lt;/p&gt; 
&lt;p&gt;4、&lt;strong&gt;HashMap可以存储null键和null值，Hashtable不可以存储null键和null值&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;B树和B+树的区别？&lt;/h3&gt; 
&lt;p&gt;1、B树的每个结点都存储了key和data，B+树的data存储在叶子节点上，节点不存储data，这样一个节点就可以存储更多的key。可以使得树更矮，所以IO操作次数更少。&lt;/p&gt; 
&lt;p&gt;2、B+树的所有叶结点构成一个&lt;strong&gt;&lt;span&gt;有序&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，可以按照关键码&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;的次序遍历全部记录，由于数据顺序排列并且相连，所以&lt;/span&gt;&lt;strong&gt;便于区间查找和搜索&lt;/strong&gt;。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。&lt;/p&gt; 
&lt;h3&gt;JDK1.8中HashMap的get()和put()方法如何实现的？&lt;/h3&gt; 
&lt;p&gt;put方法：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;判断当前桶是否为空，为空则需要初始化（resize可以初始化桶数组或者进行扩容） &lt;/li&gt;
 &lt;li&gt;根据当前key的hashcode定位到具体的桶中并判断是否为空，为空表明没有Hash冲突就直接在当前位置创建一个桶即可 &lt;/li&gt;
 &lt;li&gt;如果当前桶有值(Hash冲突)，那么就要比较当前桶中的key、key的hashcode与写入的key是否相等，相等就赋值给e，之后会统一进行赋值及返回 &lt;/li&gt;
 &lt;li&gt;&lt;span&gt;如果当前桶为&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;，那就按照&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;的方式写入数据 &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;&lt;span&gt;如果是&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;，就需要将当前的key、value封装成一个新节点写入到当前桶的后面(形成&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;) &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;&lt;span&gt;接着判断当前&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;的大小是否大于阈值，大于时要转换为&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt; &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;如果在遍历过程中找到key和hashcode均相同时直接退出遍历 &lt;/li&gt;
 &lt;li&gt;如果e不为空则存在相同的key和hashcode，就需要将值覆盖 &lt;/li&gt;
 &lt;li&gt;最后判断是否需要进行扩容 &lt;/li&gt;
&lt;/ol&gt; 
&lt;p&gt;get方法：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;将key hash之后取得所定位的桶 &lt;/li&gt;
 &lt;li&gt;如果桶为空则直接返回null &lt;/li&gt;
 &lt;li&gt;&lt;span&gt;否则判断桶的第一个位置(可能是&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;或&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;)的key和hashcode是不是要查找的，如果是返回该node &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;&lt;span&gt;如果第一个node不匹配，则判断它的下一个是&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;还是&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt; &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;就按照树的查找方式返回值 &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;&lt;span&gt;否则就按照&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;的方式遍历匹配返回值 &lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt; 
&lt;h3&gt;HashMap为什么非线程安全？&lt;/h3&gt; 
&lt;p&gt;HashMap在多线程情况下，在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，就是rehash，这个会重新将原数组的内容&lt;strong&gt;重新hash到新的扩容数组&lt;/strong&gt;&lt;span&gt;中，在多线程的环境下，同时存在其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;表示，造成&lt;/span&gt;&lt;strong&gt;闭环&lt;/strong&gt;，导致在get时会出现&lt;strong&gt;死循环&lt;/strong&gt;，所以HashMap是线程不安全的&lt;/p&gt; 
&lt;h3&gt;&lt;span&gt;JDK1.8对hash&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;和寻址&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;进行了哪些优化？&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span&gt;1、hash&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;：JDK1.7中通过key.hashcode()得到关键字的hash值，JDK1.8将hash值的&lt;/span&gt;&lt;strong&gt;高16位与低16位进行异或运算&lt;/strong&gt;，使得hash值的低16位同时保留高16位和低16位的特征，对于两个hash值低16位相等，高16位不等的情况，&lt;strong&gt;减少hash冲突&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;2、寻址&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;：JDK1.7位hash值对数组长度进行取模运算，JDK1.8变为&lt;/span&gt;&lt;strong&gt;hash&amp;amp;(n-1)&lt;/strong&gt;，n为数组长度。当数组长度是&lt;strong&gt;2的幂次&lt;/strong&gt;时，hash值对数组长度取模和hash&amp;amp;(n-1)的效果是一样的，但是&lt;strong&gt;与运算的性能更高&lt;/strong&gt;。&lt;/p&gt; 
 
&lt;p&gt;满足以下规则的二叉搜索树：&lt;/p&gt; 
&lt;p&gt;1、每个节点不是红色就是黑色&lt;/p&gt; 
&lt;p&gt;2、根节点为黑色&lt;/p&gt; 
&lt;p&gt;3、如果节点为红色，其子节点必须为黑色&lt;/p&gt; 
&lt;p&gt;4、任意一个节点到到NULL（树尾端）的任何路径，所含之黑色节点数必须相同&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;是接***衡的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span&gt;Dijkstra&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;和Floyd&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;对比&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span&gt;Dijkstra&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;与Floyd&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;都是&lt;/span&gt;&lt;strong&gt;广度优先搜索&lt;/strong&gt;&lt;span&gt;的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;。Dijkstra计算的是&lt;/span&gt;&lt;strong&gt;单源最短路径&lt;/strong&gt;，Floyd计算的是&lt;strong&gt;多源最短路径&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;Dijkstra&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;本质上是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;贪心&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;，下一条路径都是由当前更短的路径派生出来的更长的路径。不存在回溯的过程,&lt;strong&gt;不适用于有负数权值&lt;/strong&gt;的场景。&lt;strong&gt;时间复杂度为O(n2)，用堆优化为O((m+n)logn)&lt;/strong&gt;，其中m为边的个数，n为节点的个数。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;Floyd&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;实际上是一个&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&quot; target=&quot;_blank&quot;&gt;动态规划&lt;/a&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。每一个点对u和v之间的最短路径，可能会经过N个点，这些中间点记为k。假定u到k之间的最短路径已经找好，k到v之间的最短路径已经找好，那么求u到v之间的最短路径，就是遍历各个可能的k点，然后求(u,k)+(k,v)之间的最小值。所以这实际上将大规模的问题自顶向下划分为了小规模的问题，这就是&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&quot; target=&quot;_blank&quot;&gt;动态规划&lt;/a&gt;思想。实现使用三层循环，第一层循环设置中间点k，第二层循环设置起始点i，第三层循环设置结束点j。Floyd&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;&lt;/span&gt;&lt;strong&gt;支持负权值&lt;/strong&gt;但不支持负权环。&lt;strong&gt;时间复杂度为O(n3)&lt;/strong&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span&gt;问：为什么弗洛伊德&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;支持负权值？&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;答：因为路径更新是根据新值和旧值比较获得的，最终的结果都是在最后一次迭代过程中对全局进行更新而得到的，中间的每次迭代只是一次局部调整而非最终结果。而不像迪杰斯特拉采用的贪心策略，每一次迭代都确定出一条最短路径，负权的出现使得不能保证每次迭代都是最优解。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;&lt;span&gt;各种&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;及其适用场景？&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;img alt=&quot;img&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210513/77530848_1620871941963/20210408130104795.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;稳定的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;：冒泡、插入、归并&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;不稳定的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;：选择、快排、堆&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;1、冒泡&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;：数据量不大，对稳定性有要求，数据基本有序的情况下&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;2、选择&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;：数据量不大，对稳定性没有要求&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;3、插入&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;：数据量不大，对稳定性有要求，且数据局部或者整体有序的情况&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span&gt;堆&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;的过程？&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;参考博客：&lt;a href=&quot;https://blog.csdn.net/u010452388/article/details/81283998&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://blog.csdn.net/u010452388/article/details/81283998&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;1、将无序数组构造成一个大根堆：新插入的数据与其父节点比较，如果插入的数比父节点大，则与父节点交换，直到小于等于父节点或者来到顶端。这一步骤涉及到&lt;strong&gt;元素上升&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;2、固定一个最大值，将剩余的数重新构造成一个大根堆，重复此过程。这一步骤涉及到&lt;strong&gt;元素下降&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;堆&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;的时间复杂度O(N&lt;/span&gt;&lt;em&gt;logN),额外空间复杂度O(1)，是一个*&lt;/em&gt;&lt;span&gt;不稳定性**的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span&gt;KMP字符串匹配&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;？&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;参考博客：&lt;a href=&quot;https://www.cnblogs.com/dusf/p/kmp.html&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;https://www.cnblogs.com/dusf/p/kmp.html&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;提取加速匹配的信息，通过消除主串指针的回溯来提高匹配的效率，也就是&lt;strong&gt;利用已经部分匹配这个有效信息，保持i指针不回溯&lt;/strong&gt;，通过修改j指针，让模式串尽量的移动到有效的位置。维护一个next数组，next[j]=k，&lt;strong&gt;表示当T[i] != P[j]时，j指针的下一个位置&lt;/strong&gt;。另一个恒等的定义为：&lt;strong&gt;k值是j位前的子串的最大重复子串的长度&lt;/strong&gt;&lt;span&gt;。KMP&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;的&lt;/span&gt;&lt;strong&gt;时间复杂度为O(m+n)&lt;/strong&gt;&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-java&quot; from-niu=&quot;default&quot;&gt;public static int[] getNext(String ps) {
    char[] p = ps.toCharArray();
    int[] next = new int[p.length];
    next[0] = -1;
    int j = 0;
    int k = -1;
    while (j &amp;lt; p.length - 1) {
        if (k == -1 || p[j] == p[k]) {
            if (p[++j] == p[++k]) { // 当两个字符相等时要跳过
                next[j] = next[k];
            } else {
                next[j] = k;
            }
        } else {
            k = next[k];
        }
    }
    return next;
}&lt;/pre&gt; 
&lt;h2&gt;框架&lt;/h2&gt; 
&lt;h3&gt;Listener,Filter,Servlet执行顺序和生命周期？&lt;/h3&gt; 
&lt;p&gt;一、执行顺序&lt;/p&gt; 
&lt;p&gt;理(Listener)发(Filter)师(servlet)&lt;/p&gt; 
&lt;p&gt;二、生命周期&lt;/p&gt; 
&lt;p&gt;1、Listener生命周期：一直从程序启动到程序停止运行。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;p&gt;ServletRequestListener：每次访问一个Request资源前，都会执行requestInitialized()方法，方法访问完毕，都会执行requestDestroyed()方法。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;HttpSessionListener：每次调用request.getSession()，都会执行sessionCreated()方法，执行session.invalidate()方法，都会执行sessionDestroyed()方法。&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;ServletRequestAttributeListener：每次调用request.setAttribute()都会执行attributeAdded()方法，如果set的key在request里面存在，就会执行attributeReplaced()方法，调用request.removeAttribute()方法，都会执行attributeRemoved()方法。&lt;/p&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;2、Filter生命周期：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;程序启动调用Filter的init()方法(只调用一次) &lt;/li&gt;
 &lt;li&gt;程序停止调用Filter的destroy()方法(只调用一次) &lt;/li&gt;
 &lt;li&gt;每次的访问请求如果符合拦截条件都会调用doFilter()方法
  &lt;ul&gt; 
   &lt;li&gt;程序第一次运行，会在servlet调用init()方法以后调用 &lt;/li&gt;
   &lt;li&gt;不管第几次，都在调用doGet(),doPost()方法之前 &lt;/li&gt;
  &lt;/ul&gt; &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;3、Servlet生命周期：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;程序第一次访问，会调用servlet的init()方法初始化(只调用一次) &lt;/li&gt;
 &lt;li&gt;每次程序执行都会根据请求调用doGet()或者doPost()方法 &lt;/li&gt;
 &lt;li&gt;程序停止调用destory()方法(只调用一次) &lt;/li&gt;
&lt;/ul&gt; 
&lt;h3&gt;spring的IOC/DI是什么？&lt;/h3&gt; 
&lt;p&gt;控制翻转（和依赖注入是一回事），一种设计思想，将设计好的对象交给容器控制。&lt;/p&gt; 
&lt;p&gt;IOC容器就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需在代码中new相关的对象，应用程序由IOC容器进行组装。&lt;/p&gt; 
&lt;h3&gt;spring如何实现依赖注入？&lt;/h3&gt; 
&lt;p&gt;spring实现依赖注入有两种方式：构造函数注入和setter注入&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th align=&quot;left&quot;&gt;构造函数注入&lt;/th&gt; 
   &lt;th align=&quot;left&quot;&gt;setter 注入&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt;
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;没有部分注入&lt;/td&gt; 
   &lt;td align=&quot;left&quot;&gt;有部分注入&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;不会覆盖 setter 属性&lt;/td&gt; 
   &lt;td align=&quot;left&quot;&gt;会覆盖 setter 属性&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;任意修改都会创建一个新实例&lt;/td&gt; 
   &lt;td align=&quot;left&quot;&gt;任意修改不会创建一个新实例&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;适用于设置很多属性&lt;/td&gt; 
   &lt;td align=&quot;left&quot;&gt;适用于设置少量属性&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt;
&lt;/table&gt; 
&lt;p&gt;setter 注入使用的更多&lt;/p&gt; 
&lt;h3&gt;spring如何解决循环依赖？&lt;/h3&gt; 
&lt;p&gt;spring的三级缓存：&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th align=&quot;left&quot;&gt;缓存&lt;/th&gt; 
   &lt;th align=&quot;left&quot;&gt;用途&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt;
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;singletonObjects&lt;/td&gt; 
   &lt;td align=&quot;left&quot;&gt;用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;earlySingletonObjects&lt;/td&gt; 
   &lt;td align=&quot;left&quot;&gt;存放原始的 bean 对象（尚未填充属性），用于解决循环依赖&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align=&quot;left&quot;&gt;singletonFactories&lt;/td&gt; 
   &lt;td align=&quot;left&quot;&gt;存放 bean 工厂对象，用于解决循环依赖&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt;
&lt;/table&gt; 
&lt;p&gt; Spring 解决循环依赖的过程：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;首先 A 完成初始化第一步并将自己提前曝光出来（通过 ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建出来 &lt;/li&gt;
 &lt;li&gt;然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖A，于是尝试 get(A)，这个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 &lt;code&gt;singletonFactories&lt;/code&gt; ），通过 ObjectFactory 提前曝光，所以可以通过 &lt;code&gt;ObjectFactory.getObject()&lt;/code&gt; 方法来拿到 A 对象，B拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中 &lt;/li&gt;
 &lt;li&gt;回到 A，A 也可以拿到 B 对象，完成初始化，到这里整个链路就已经完成了初始化过程了。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h3&gt;spring中bean的生命周期？作用域？&lt;/h3&gt; 
&lt;p&gt;一、生命周期&lt;/p&gt; 
&lt;p&gt;实例化--&amp;gt;属性赋值--&amp;gt;初始化--&amp;gt;销毁&lt;/p&gt; 
&lt;p&gt;影响多个Bean的接口：BeanPostProcessor，与自动注入以及AOP的实现有关&lt;/p&gt; 
&lt;p&gt;只调用一次的接口：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Aware类型的接口：从spring容器中拿到一些资源 &lt;/li&gt;
 &lt;li&gt;生命周期的接口：让我们自己实现初始化和销毁 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;二、作用域&lt;/p&gt; 
&lt;p&gt;在spring配置文件定义Bean时，通过声明scope配置项，可以定义Bean的作用域，一共有五种：&lt;/p&gt; 
&lt;p&gt;1、singleton：IOC容器&lt;strong&gt;仅创建一个&lt;/strong&gt;Bean实例，IOC容器&lt;strong&gt;每次返回的是同一个Bean实例&lt;/strong&gt;。（&lt;strong&gt;默认的作用域&lt;/strong&gt;）&lt;/p&gt; 
&lt;p&gt;2、prototype：IOC容器&lt;strong&gt;可以创建多个&lt;/strong&gt;Bean实例，&lt;strong&gt;每次返回的都是一个新的实例&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;3、request：该属性仅对HTTP请求产生作用，使用该属性定义Bean时，每次HTTP请求都会创建一个新的Bean，适用于WebApplicationContext环境。&lt;/p&gt; 
&lt;p&gt;4、 session：该属性仅用于HTTP Session，同一个Session共享一个Bean实例。不同Session使用不同的实例。&lt;/p&gt; 
&lt;p&gt;5、global-session：该属性仅用于HTTP Session，同session作用域不同的是，所有的Session共享一个Bean实例。&lt;/p&gt; 
&lt;h3&gt;@Autowired和@Resource比较&lt;/h3&gt; 
&lt;p&gt;相同点：作用相同，都可以标注在字段或属性的setter方法上&lt;/p&gt; 
&lt;p&gt;不同点：@Autowired默认按照类型装配，@Resource默认按照名称装配&lt;/p&gt; 
&lt;h3&gt;spring的AOP是什么？实现原理？&lt;/h3&gt; 
&lt;p&gt;面向切面编程，将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。&lt;/p&gt; 
&lt;p&gt;关于 AOP 的原理，概括来说就是&lt;strong&gt;通过代理模式为目标对象生产代理对象，并将横切逻辑插入到目标方法执行的前后。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。&lt;/p&gt; 
&lt;h3&gt;spring事务中的传播行为？&lt;/h3&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;&lt;strong&gt;事务行为&lt;/strong&gt;&lt;/th&gt; 
   &lt;th&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt;
  &lt;tr&gt; 
   &lt;td&gt;PROPAGATION_REQUIRED&lt;/td&gt; 
   &lt;td&gt;支持当前事务，假设当前没有事务，就新建一个事务&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;PROPAGATION_SUPPORTS&lt;/td&gt; 
   &lt;td&gt;支持当前事务，假设当前没有事务，就以非事务方式运行&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;PROPAGATION_MANDATORY&lt;/td&gt; 
   &lt;td&gt;支持当前事务，假设当前没有事务，就抛出异常&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;PROPAGATION_REQUIRES_NEW&lt;/td&gt; 
   &lt;td&gt;新建事务，假设当前存在事务，把当前事务挂起&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;PROPAGATION_NOT_SUPPORTED&lt;/td&gt; 
   &lt;td&gt;以非事务方式运行操作。假设当前存在事务，就把当前事务挂起&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;PROPAGATION_NEVER&lt;/td&gt; 
   &lt;td&gt;以非事务方式运行，假设当前存在事务，则抛出异常&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;PROPAGATION_NESTED&lt;/td&gt; 
   &lt;td&gt;如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt;
&lt;/table&gt; 
&lt;p&gt;spring中默认的事务传播行为是PROPAGATION_REQUIRED，ServiceA.methodA调用ServiceB.methodB，有一条sql执行失败了，ServiceA.methodA要回滚，无论ServiceB.methodB的事务是否被提交。&lt;/p&gt; 
&lt;h3&gt;Mybatis的映射配置文件中，动态传递参数有两种方式：#{}和${}，它们有什么区别？&lt;/h3&gt; 
&lt;p&gt;1、#{}为参数占位符?即sql预编译，${}为字符串替换，即sql拼接&lt;/p&gt; 
&lt;p&gt;2、变量替换后，#{} 对应的变量自动加上单引号，${} 对应的变量不会加上单引号&lt;/p&gt; 
&lt;p&gt;3、#{}能防止sql注入，${}不能防止sql注入&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;什么是sql注入？&lt;/p&gt; 
 &lt;p&gt;在实现定义好的查询语句的结尾添加额外的sql语句，欺骗数据库服务器进行非授权的任意查询，盗取数据库数据。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;在Mybatis中尽量使用#{}&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;Mybatis如何根据映射器(mapper.xml文件)生成sql语句？&lt;/h3&gt; 
&lt;p&gt;1、&lt;strong&gt;XMLConfigBuilder&lt;/strong&gt;解析映射器xml文件时，会将每一个sql语句和其配置的内容保存起来&lt;/p&gt; 
&lt;p&gt;2、mybatis中一条SQL与它相关的配置信息是由&lt;strong&gt;MappedStatement&lt;/strong&gt;、&lt;strong&gt;SqlSource&lt;/strong&gt;和&lt;strong&gt;BoundSql&lt;/strong&gt;三个部分组成&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;MappedStatement的作用是保存一个映射器节点（select|insert|delete|update）的内容，它是一个&lt;strong&gt;类&lt;/strong&gt;，包括许多我们配置的SQL、SQL的id、resultMap等&lt;strong&gt;重要配置内容&lt;/strong&gt;，同时还有一个重要的属性sqlSource。mybatis通过读取MappedStatement来获得某条SQL配置的所有信息。 &lt;/li&gt;
 &lt;li&gt;SqlSource是&lt;strong&gt;提供BoundSql对象&lt;/strong&gt;的地方，&lt;strong&gt;它是一个接口&lt;/strong&gt;，使用它就可以得到一个BoundSql对象。 &lt;/li&gt;
 &lt;li&gt;BoundSql是一个&lt;strong&gt;结果对象&lt;/strong&gt;，是&lt;strong&gt;建立SQL&lt;/strong&gt;和参数的地方。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h3&gt;Mybatis一级缓存和二级缓存的区别&lt;/h3&gt; 
&lt;p&gt;1、一级缓存：&lt;strong&gt;SqlSession范围&lt;/strong&gt;的缓存，默认开启，在同一个SqlSession中，执行相同的SQL查询时，第一次会去查询数据库，并写在缓存中，第二次会直接从缓存中取。Mybatis的内部缓存使用一个HashMap，key为hashcode+statementId+sql语句，value为查询出来的结果集映射成的Java对象，&lt;strong&gt;两次查询sql中间如果有增删改操作会清空缓存&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;2、二级缓存：&lt;strong&gt;Mapper级别的缓存，跨SqlSession&lt;/strong&gt;，默认没有开启，SqlSession1第一次调用Mapper下的SQL进行查询后会将结果存放在Mapper对应的二级缓存区域，SqlSession2再调用Mapper中相同的SQL查询时，会去对应的二级缓存内取结果。&lt;strong&gt;如果SqlSession3执行commit提交，将会清空该Mapper映射下的二级缓存区域的数据。&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;SpringBoot的启动加载过程和自动配置流程？&lt;/h3&gt; 
&lt;p&gt;一、自动配置：@SpringBootApplication&lt;/p&gt; 
&lt;p&gt;@SpringBootApplication中有三个注解：@Configuration、@EnableAutoConfiguration和@ComponentScan&lt;/p&gt; 
&lt;p&gt;1、@Configuration：启动类标注了@Configuration后相当于一个IOC容器的配置类，会在spring的XML配置文件applicationContent.xml中装配所有bean事务，提供一个spring的上下文环境&lt;/p&gt; 
&lt;p&gt;2、@EnableAutoConfiguration：帮助SpringBoot将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器&lt;/p&gt; 
&lt;p&gt;3、@ComponentScan：组件扫描，可自动发现和装配Bean&lt;/p&gt; 
&lt;p&gt;二、启动加载：application.run()&lt;/p&gt; 
&lt;p&gt;主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean&lt;/p&gt; 
&lt;h2&gt;并发编程&lt;/h2&gt; 
&lt;h3&gt;synchronized锁的底层原理？&lt;/h3&gt; 
&lt;p&gt;JVM中对象是分成三部分存在的：对象头、实例数据、对其填充。（&lt;strong&gt;实例数据&lt;/strong&gt;存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐；&lt;strong&gt;对其填充&lt;/strong&gt;不是必须部分，由于虚拟机要求对象起始地址必须是8字节的整数倍，对齐填充仅仅是为了使字节对齐。）&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;对象头&lt;/strong&gt;是synchronized实现锁的基础，因为synchronized申请锁、上锁、释放锁都与对象头有关。对象头主要结构是由&lt;code&gt;Mark Word&lt;/code&gt; 和 &lt;code&gt;Class Metadata Address&lt;/code&gt;组成，&lt;strong&gt;其中&lt;/strong&gt;&lt;code&gt;Mark Word&lt;/code&gt;&lt;strong&gt;存储对象的hashCode、锁信息或分代年龄或GC标志等信息&lt;/strong&gt;，&lt;code&gt;Class Metadata Address&lt;/code&gt;&lt;strong&gt;是类型指针指向对象的类元数据，JVM通过该指针确定该对象是哪个类的实例&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;JDK6后锁有四种状态，&lt;strong&gt;无锁状态、偏向锁、轻量级锁、重量级锁&lt;/strong&gt;，其中无锁就是一种状态了。锁的类型和状态在对象头&lt;code&gt;Mark Word&lt;/code&gt;中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的&lt;code&gt;Mark Word&lt;/code&gt;数据。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;每一个锁都对应一个monitor对象，在HotSpot虚拟机中它是由ObjectMonitor实现的（C++实现），当一个monitor被某个线程持有后，它便处于锁定状态。&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;Java中对象锁的四种状态及锁升级的过程？&lt;/h3&gt; 
&lt;p&gt;一、对象锁的四种状态&lt;/p&gt; 
&lt;p&gt;1、无锁&lt;/p&gt; 
&lt;p&gt;2、偏向锁&lt;/p&gt; 
&lt;p&gt;多数情况下，锁不仅不存在竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁&lt;/p&gt; 
&lt;p&gt;3、轻量级锁&lt;/p&gt; 
&lt;p&gt;如果明显存在其他线程申请锁，那么偏向锁将很快升级为轻量级锁&lt;/p&gt; 
&lt;p&gt;4、重量级锁&lt;/p&gt; 
&lt;p&gt;指的是原始的Synchronized的实现，其他线程试图获取锁时，都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程&lt;/p&gt; 
&lt;p&gt;二、锁升级的场景&lt;/p&gt; 
&lt;p&gt;1、经常只有一个线程来加锁，使用偏向锁，偏向锁的执行流程如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;线程首先检查该对象头的线程ID是否为当前线程
  &lt;ul&gt; 
   &lt;li&gt;如果对象头的线程ID和当前线程ID一直，则直接执行代码 &lt;/li&gt;
   &lt;li&gt;如果不是当前线程ID则使用CAS方式替换对象头中的线程ID
    &lt;ul&gt; 
     &lt;li&gt;如果使用CAS替换不成功则说明有线程正在执行，存在锁的竞争，这时需要撤销偏向锁，&lt;strong&gt;升级为轻量级锁&lt;/strong&gt; &lt;/li&gt;
     &lt;li&gt;如果CAS替换成功，则把对象头的线程ID改为自己的线程ID，然后执行代码 &lt;/li&gt;
    &lt;/ul&gt; &lt;/li&gt;
  &lt;/ul&gt; &lt;/li&gt;
 &lt;li&gt;执行代码完成之后释放锁，把对象头的线程ID修改为空 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;2、有线程来参与锁的竞争，但是获取锁的冲突时间很短&lt;/p&gt; 
&lt;p&gt;当开始有锁的冲突了，那么偏向锁就会升级到轻量级锁；线程获取锁出现冲突时，线程必须做出决定是继续在这里等，还是回家等别人打电话通知，而轻量级锁就是采用继续在这里等的方式，当发现有锁冲突，线程首先会使用自旋的方式循环在这里获取锁，因为使用自旋的方式非常消耗CPU，&lt;strong&gt;当一定时间内通过自旋的方式无法获取到锁的话，那么锁就开始升级为重量级锁了。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;3、有大量的线程参与锁的竞争，冲突性很高&lt;/p&gt; 
&lt;p&gt;当获取锁冲突多，时间长的时候，线程无法继续死等，只好先休息，然后等前面获取锁的线程释放了锁之后再开启下一轮的锁竞争，而这种形式就是重量级锁。&lt;/p&gt; 
&lt;h3&gt;乐观锁和悲观锁&lt;/h3&gt; 
&lt;p&gt;一、概念&lt;/p&gt; 
&lt;p&gt;乐观锁：所谓的乐观锁，指的是在操作数据的时候非常乐观，乐观地&lt;strong&gt;认为别人不会同时修改数据&lt;/strong&gt;，因此乐观锁不会上锁，只有在&lt;strong&gt;执行更新的时候才会去判断在此期间别人是否修改了数据&lt;/strong&gt;，如果别人修改了数据则放弃操作，否则执行操作。&lt;/p&gt; 
&lt;p&gt;悲观锁：所谓的悲观锁，指的是在操作数据的时候比较悲观，悲观地&lt;strong&gt;认为别人一定会同时修改数据&lt;/strong&gt;，因此悲观锁在操作数据时是&lt;strong&gt;直接把数据上锁&lt;/strong&gt;，直到操作完成之后才会释放锁，在&lt;strong&gt;上锁期间其他人不能操作数据&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;二、实现方式&lt;/p&gt; 
&lt;p&gt;乐观锁：&lt;/p&gt; 
&lt;p&gt;1、CAS：比较并交换，如果等于预期值则更新，否则不进行操作。许多CAS操作都是自旋的，意思就是，如果操作不成功，就会一直重试，直到操作成功为止。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;CAS的缺点？&lt;/p&gt; 
 &lt;p&gt;1）ABA问题：其他线程将数据从A修改到B再改回A，由于数据与开始时一致，当前线程并不知道数据被修改过。&lt;/p&gt; 
 &lt;p&gt;2）高竞争下的开销问题：CAS如果失败会一致重试，造成CPU开销大，可以引入退出机制，重试次数超过阈值就强制失败退出。&lt;/p&gt; 
 &lt;p&gt;3）自身功能受限：只能保证单个变量操作的原子性。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;2、版本号机制：版本号机制的基本思路，是在数据中增加一个&lt;strong&gt;version字段用来表示该数据的版本号&lt;/strong&gt;，每当&lt;strong&gt;数据被修改版本号就会加1&lt;/strong&gt;。当某个线程查询数据的时候，会将该数据的版本号一起读取出来，之后在该线程需要更新该数据的时候，就将&lt;strong&gt;之前读取的版本号与当前版本号进行比较&lt;/strong&gt;，如果一致，则执行操作，如果不一致，则放弃操作。&lt;/p&gt; 
&lt;p&gt;悲观锁：&lt;/p&gt; 
&lt;p&gt;悲观锁的实现方式也就是加锁，加锁既可以在代码层面（比如Java中的&lt;code&gt;synchronized&lt;/code&gt;关键字），也可以在数据库层面（比如MySQL中的排他锁）。&lt;/p&gt; 
&lt;p&gt;三、适用场景&lt;/p&gt; 
&lt;p&gt;在竞争不激烈（出现并发冲突的概率比较小）的场景中，乐观锁更有优势。因为悲观锁会锁住代码块或数据，其他的线程无法同时访问，必须等待上一个线程释放锁才能进入操作，会影响并发的响应速度。另外，加锁和释放锁都需要消耗额外的系统资源，也会影响并发的处理速度。&lt;/p&gt; 
&lt;p&gt;在竞争激烈（出现并发冲突的概率较大）的场景中，悲观锁则更有优势。因为乐观锁在执行更新的时候，可能会因为数据被反复修改而更新失败，进而不断重试，造成CPU资源的浪费。&lt;/p&gt; 
&lt;h3&gt;Synchronized 和 Lock 区别&lt;/h3&gt; 
&lt;p&gt;1、Synchronized 内置的Java关键字， Lock 是一个Java类&lt;/p&gt; 
&lt;p&gt;2、Synchronized 无法判断获取锁的状态，Lock 可以判断是否获取到了锁&lt;/p&gt; 
&lt;p&gt;3、Synchronized 会自动释放锁，lock 必须要手动释放锁！如果不释放锁，死锁&lt;/p&gt; 
&lt;p&gt;4、Synchronized 线程 1（获得锁，阻塞）、线程2（等待，傻傻的等）；Lock锁就不一定会等待下去；&lt;/p&gt; 
&lt;p&gt;5、Synchronized 可重入锁，不可以中断的，非公平；Lock ，可重入锁，可以 判断锁，非公平（可以自己设置）；&lt;/p&gt; 
&lt;p&gt;6、Synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码！&lt;/p&gt; 
&lt;h3&gt;AQS的实现原理？&lt;/h3&gt; 
&lt;p&gt;AbstractQueuedSynchronizer(AQS --简称同步器)是用来构建锁及其他同步组件的基础框架，它的实现主要是依赖一个&lt;strong&gt;int状态变量&lt;/strong&gt;以及通过一个&lt;strong&gt;FIFO队列&lt;/strong&gt;共同构成&lt;strong&gt;同步队列&lt;/strong&gt;。当多个线程竞争共享资源时，一个线程竞争到共享资源后，其他请求资源的线程会被阻塞，进入同步队列，也就是说同步队列中存放的被阻塞的线程，这些线程等待cpu调度再次竞争共享资源。int状态的更新使用CAS，同步器既支持独占锁，也支持共享锁。AQS的设计使用模板方法设计模式，它将一些方法开放给子类进行重写。&lt;/p&gt; 
&lt;h3&gt;wait和sleep的区别？&lt;/h3&gt; 
&lt;p&gt;1、来自不同的类：wait-&amp;gt;Object，sleep-&amp;gt;Thread&lt;/p&gt; 
&lt;p&gt;2、关于锁的释放：wait 会释放锁，sleep 睡觉了，抱着锁睡觉，不会释放！&lt;/p&gt; 
&lt;p&gt;3、使用的范围不同：wait必须在同步代码块中，sleep可以在任何地方睡&lt;/p&gt; 
&lt;p&gt;4、是否需要捕获异常：wait不需要捕获异常，sleep必须捕获异常&lt;/p&gt; 
&lt;h3&gt;Java如何实现多线程？&lt;/h3&gt; 
&lt;p&gt;1、继承Thread类，重写run()方法，使用start()开启多线程&lt;/p&gt; 
&lt;p&gt;2、实现Runnable接口，Runnable 没有返回值、效率比Callable 相对较低&lt;/p&gt; 
&lt;p&gt;3、实现Callable接口（JUC下的）&lt;/p&gt; 
&lt;h3 id=&quot;volatile&quot;&gt;&lt;strong&gt;volatile&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;一、volatile的作用？&lt;/p&gt; 
&lt;p&gt;1、保证可见性&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;如何保证可见性？&lt;/p&gt; 
 &lt;p&gt;当写一个volatile变量时，JMM会把该线程对应的&lt;strong&gt;本地内存中的共享变量值立刻刷新到主内存中&lt;/strong&gt;。&lt;/p&gt; 
 &lt;p&gt;当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，&lt;strong&gt;直接从主内存读取共享变量&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;2、不保证原子性&lt;/p&gt; 
&lt;p&gt;3、可以避免指令重排（内存屏障的存在）&lt;/p&gt; 
&lt;p&gt;volatile是线程安全的吗？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;volatile不是线程安全的，&lt;/strong&gt;volatile是一种弱的同步机制，保护的是变量安全，想要强线程安全需要用synchronized或lock锁。&lt;/p&gt; 
&lt;h3 id=&quot;threadlocal&quot;&gt;ThreadLocal&lt;/h3&gt; 
&lt;p&gt;一、ThreadLocal的原理？&lt;/p&gt; 
&lt;p&gt;ThreadLocal是线程本地存储，在每个线程中都创建了一个&lt;strong&gt;静态的ThreadLocalMap对象&lt;/strong&gt;（key是当前线程的句柄，value是需要保持的值），每个线程可以访问自己内部ThreadLocalMap对象内的value。&lt;/p&gt; 
&lt;p&gt;ThreadLocal的作用是提供一种&lt;strong&gt;线程隔离&lt;/strong&gt;，将&lt;strong&gt;变量与线程相绑定&lt;/strong&gt;，保证线程安全。&lt;/p&gt; 
&lt;p&gt;二、ThreadLocal的缺点？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;内存泄露&lt;/strong&gt;。原因是ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除（remove()方法）对应key就会导致内存泄露。&lt;/p&gt; 
&lt;p&gt;三、ThreadLocalMap的key使用哪种引用？为什么？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;弱引用&lt;/strong&gt;，在使用完ThreadLocal，当前Thread依然运行的情况下，就算忘记调用remove方法，弱引用比强引用多一层保障：弱引用的ThreadLocal会被回收，对应的value在下一次ThreadLocalMap调用set/get/remove中的任一方法的时候会被清除，从而避免内存泄露。&lt;/p&gt; 
&lt;h3&gt;Java线程池&lt;/h3&gt; 
&lt;p&gt;一、线程池的实现原理&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210513/77530848_1620871941777/20190724203521927.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;Java线程池的实现原理就是一个线程集合workerset和一个阻塞队列workqueue，当用户向线程池提交一个任务时，线程池会先将任务放入workqueue中，workerSet中的线程会不断的从workQueue中获取线程然后执行。当workQueue中没有任务的时候，worker就会阻塞直到队列中有任务了就取出来继续执行。&lt;/p&gt; 
&lt;p&gt;二、七大参数&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片说明&quot; src=&quot;https://uploadfiles.nowcoder.com/images/20210513/77530848_1620873396349/81A686FD501190913C64D2C01AA04987&quot; title=&quot;图片标题&quot;/&gt; &lt;/p&gt; 
&lt;p&gt;三、submit一个task以后进行什么操作？&lt;/p&gt; 
&lt;p&gt;1、判断当前运行的worker数量是否超过corePoolSize，如果不超过corePoolSize就创建一个worker直接执行该任务（线程池最开始没有worker在运行）&lt;/p&gt; 
&lt;p&gt;2、如果正在运行的worker数量大于等于corePoolSize，那么就将该任务加入到workQueue中去&lt;/p&gt; 
&lt;p&gt;3、如果workQueue满了就检查当前运行的worker数量是否小于maximumPoolSize，如果小于就创建一个worker执行该任务&lt;/p&gt; 
&lt;p&gt;4、如果当前运行的worker数量大于等于maximumPoolSize，那么就执行拒绝策略&lt;/p&gt; 
&lt;p&gt;四、线程池的作用？&lt;/p&gt; 
&lt;p&gt;线程复用、控制最大并发数、管理线程&lt;/p&gt; 
&lt;h3&gt;Thread中interrupt()interrupted()和isInterrupted()的区别&lt;/h3&gt; 
&lt;p&gt;1、interrupt()：非静态方法，作用范围&lt;strong&gt;线程实例&lt;/strong&gt;，由线程实例对象调用，其作用是&lt;strong&gt;中断此线程实例&lt;/strong&gt;(注：不一定是当前线程)，但实际上只是给线程设置一个中断标志，线程仍会继续运行。&lt;/p&gt; 
&lt;p&gt;2、interrupted()：静态方法，作用范围&lt;strong&gt;当前线程&lt;/strong&gt;，作用是测试&lt;strong&gt;当前线程是否被中断&lt;/strong&gt;（检查中断标志），返回一个boolean并清除中断状态，第二次再调用时中断状态已经被清除，将返回一个false(换句话说，复位线程状态，如果已经复位，再次复位则返回false)。&lt;/p&gt; 
&lt;p&gt;3、isInterrupted()：非静态方法，作用范围&lt;strong&gt;线程实例&lt;/strong&gt;，由线程实例对象调用，其作用是只测试此线程是否被中断 ，不清除中断状态。&lt;/p&gt; 
&lt;h2&gt;数据库&lt;/h2&gt; 
&lt;h3&gt;索引&lt;/h3&gt; 
&lt;h4&gt;索引使用哪种数据结构？区别？Mysql使用哪种？&lt;/h4&gt; 
&lt;p&gt;一、常见的索引有Hash索引和B+树索引，Mysql使用的是InnoDB引擎，默认是B+树索引。。&lt;/p&gt; 
&lt;p&gt;二、Hash索引和B+树索引的区别：&lt;/p&gt; 
 
&lt;p&gt;三、聚簇索引和非聚簇索引？&lt;/p&gt; 
&lt;p&gt;1、B+树的叶子节点存储了&lt;strong&gt;整行数据&lt;/strong&gt;的是&lt;strong&gt;主键索引&lt;/strong&gt;，也叫&lt;strong&gt;聚簇索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;2、B+树的叶子节点&lt;strong&gt;存储了主键的值&lt;/strong&gt;的是&lt;strong&gt;非主键索引&lt;/strong&gt;，也叫&lt;strong&gt;非聚簇索引&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;二者查询数据时的区别：&lt;/p&gt; 
&lt;p&gt;聚簇索引（主键索引）查询会更快，因为主键索引树的叶子节点就是要查询的数据，而非主键索引的叶子节点是主键的值，还需要进行&lt;strong&gt;回表&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;非主键索引一定会回表查询多次吗？&lt;/p&gt; 
&lt;p&gt;不是，通过&lt;strong&gt;覆盖索引&lt;/strong&gt;也可以只查询一次。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;覆盖索引：一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;什么时候需要建索引？什么时候没必要建索引？&lt;/h4&gt; 
&lt;p&gt;索引方便了查找的效率，但是会导致增删改的速率变慢（因为与主键绑定）。&lt;/p&gt; 
&lt;p&gt;一、需要建立索引的情况&lt;/p&gt; 
&lt;p&gt;1、主键自动建立唯一索引&lt;/p&gt; 
&lt;p&gt;2、频繁进行查询的字段应该创建索引&lt;/p&gt; 
&lt;p&gt;3、与其他表进行联合查询的字段，外键关系建立索引&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;主键和外键？&lt;/p&gt; 
 &lt;p&gt;主键是能确定一条记录的唯一标识&lt;/p&gt; 
 &lt;p&gt;外键用于与另一张表的关联，是能确定另一张表记录的字段，用于保持数据一致性&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;span&gt;4、&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;或分组要用到的字段&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;二、不需要创建索引的情况&lt;/p&gt; 
&lt;p&gt;1、表记录太少&lt;/p&gt; 
&lt;p&gt;2、字段经常进行增删改的操作&lt;/p&gt; 
&lt;p&gt;3、where条件用不到的字段&lt;/p&gt; 
&lt;h4&gt;索引失效的七种情况？&lt;/h4&gt; 
&lt;p&gt;1、条件中有or必须每个列都加上索引&lt;/p&gt; 
&lt;p&gt;2、复合索引未用左列字段&lt;/p&gt; 
&lt;p&gt;3、like以%开头&lt;/p&gt; 
&lt;p&gt;4、需要类型转换&lt;/p&gt; 
&lt;p&gt;5、where中索引列有运算&lt;/p&gt; 
&lt;p&gt;6、where中索引列使用了函数&lt;/p&gt; 
&lt;p&gt;7、如果mysql觉得全表扫描更快时（数据少）&lt;/p&gt; 
&lt;h4&gt;Mysql5.6对于索引的优化？&lt;/h4&gt; 
&lt;p&gt;引入了&lt;strong&gt;索引下推优化&lt;/strong&gt;，可以在有like条件查询的情况下，减少回表次数。&lt;/p&gt; 
&lt;h4&gt;通过什么方法来判断有没有走索引查询？&lt;/h4&gt; 
&lt;p&gt;可以通过&lt;strong&gt;explain&lt;/strong&gt;查看sql语句的执行计划，通过执行计划来分析索引使用情况。&lt;/p&gt; 
&lt;h3&gt;如何用explain来分析一条sql的执行计划？&lt;/h3&gt; 
&lt;p&gt;explain语句的各项输出如下：&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;&lt;strong&gt;&lt;code&gt;列名&lt;/code&gt;&lt;/strong&gt;&lt;/th&gt; 
   &lt;th&gt;&lt;strong&gt;&lt;code&gt;用途&lt;/code&gt;&lt;/strong&gt;&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt;
  &lt;tr&gt; 
   &lt;td&gt;id&lt;/td&gt; 
   &lt;td&gt;每一个SELECT关键字查询语句都对应一个唯一id&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;select_type&lt;/td&gt; 
   &lt;td&gt;SELECT关键字对应的查询类型&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;table&lt;/td&gt; 
   &lt;td&gt;表名&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;partitions&lt;/td&gt; 
   &lt;td&gt;匹配的分区信息&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;&lt;strong&gt;type&lt;/strong&gt;&lt;/td&gt; 
   &lt;td&gt;单表的访问方法&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;possible_keys&lt;/td&gt; 
   &lt;td&gt;可能用到的索引&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;&lt;strong&gt;key&lt;/strong&gt;&lt;/td&gt; 
   &lt;td&gt;实际使用到的索引&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;key_len&lt;/td&gt; 
   &lt;td&gt;实际使用到的索引长度&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;ref&lt;/td&gt; 
   &lt;td&gt;当使用索引列等值查询时，与索引列进行等值匹配的对象信息&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;rows&lt;/td&gt; 
   &lt;td&gt;预估需要读取的记录条数&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;filtered&lt;/td&gt; 
   &lt;td&gt;某个表经过条件过滤后剩余的记录条数百分比&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;&lt;strong&gt;Extra&lt;/strong&gt;&lt;/td&gt; 
   &lt;td&gt;额外的一些信息&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt;
&lt;/table&gt; 
&lt;p&gt;重点说一下&lt;code&gt;type&lt;/code&gt;字段：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片说明&quot; src=&quot;https://uploadfiles.nowcoder.com/images/20210513/77530848_1620873575754/B40C3727BF05CE9ACBEF38659040FE58&quot; title=&quot;图片标题&quot;/&gt; &lt;/p&gt; 
&lt;p&gt;最优到最差分别为：system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; range &amp;gt; index &amp;gt; ALL&lt;/p&gt; 
&lt;p&gt;一般来说，得保证查询&lt;strong&gt;至少达到range级别&lt;/strong&gt;，最好能达到ref。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;code&gt;system,const&lt;/code&gt;：MySQL 能对查询的某部分进行优化并将其转化成一个常量。&lt;strong&gt;用于主键或唯一二级索引列与常数比较时，所以表最多有一个匹配行&lt;/strong&gt;，读取1次，速度比较快。&lt;code&gt;system&lt;/code&gt;是 &lt;code&gt;const&lt;/code&gt; 的特例，表里只有一条记录匹配时为 &lt;code&gt;system&lt;/code&gt;。 &lt;/li&gt;
 &lt;li&gt;&lt;code&gt;eq_ref&lt;/code&gt;：在&lt;strong&gt;连接查询&lt;/strong&gt;时，如果被驱动表是&lt;strong&gt;通过主键或者唯一二级索引列等值匹配的方式&lt;/strong&gt;进行访问的，则对该被驱动表的访问方法就是 &lt;code&gt;eq_ref&lt;/code&gt;。这可能是在 const 之外最好的联接类型了。 &lt;/li&gt;
 &lt;li&gt;&lt;code&gt;ref&lt;/code&gt;：相比 eq_ref，不使用唯一索引，而是&lt;strong&gt;使用普通索引或者唯一性索引的部分前缀&lt;/strong&gt;，索引要和某个值相比较，可能会找到多个符合条件的行。 &lt;/li&gt;
 &lt;li&gt;&lt;code&gt;range&lt;/code&gt;：使用索引获取&lt;strong&gt;范围区间&lt;/strong&gt;的记录，通常出现在 &lt;code&gt;in, between ,&amp;gt; ,&amp;lt;, &amp;gt;=&lt;/code&gt; 等操作中。 &lt;/li&gt;
 &lt;li&gt;&lt;code&gt;index&lt;/code&gt;：&lt;strong&gt;扫描全表索引&lt;/strong&gt;，这通常比ALL快一些。&lt;strong&gt;（&lt;code&gt;index&lt;/code&gt;是从索引中读取的，而 &lt;code&gt;ALL&lt;/code&gt; 是从硬盘中读取）&lt;/strong&gt;。 &lt;/li&gt;
 &lt;li&gt;&lt;code&gt;ALL&lt;/code&gt;：即&lt;strong&gt;全表扫描&lt;/strong&gt;，MySQL 需要从头到尾去查找表中所需要的行。通常情况下这需要增加索引来进行优化了。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;再来说一下&lt;code&gt;extra&lt;/code&gt;字段：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;code&gt;Using index&lt;/code&gt;：表示相应的select操作中使用了&lt;strong&gt;覆盖索引&lt;/strong&gt;，&lt;strong&gt;查询的列被索引覆盖&lt;/strong&gt;，&lt;strong&gt;不需要回表查询&lt;/strong&gt;。 &lt;/li&gt;
 &lt;li&gt;&lt;code&gt;Using temporary&lt;/code&gt;：MySQL 中需要创建一张内部临时表来处理查询。 &lt;/li&gt;
 &lt;li&gt;&lt;code&gt;Using filesort&lt;/code&gt;&lt;span&gt;：&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;无法使用索引来&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;。 &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;当发现&lt;code&gt;Extra&lt;/code&gt;提示为 &lt;code&gt;Using filesort&lt;/code&gt;、&lt;code&gt;Using temporary&lt;/code&gt; 时就需要格外注意了，考虑索引优化。&lt;/p&gt; 
&lt;h3&gt;数据库引擎有哪几种？该如何选型？&lt;/h3&gt; 
&lt;p&gt;主要有InnoDB和MyISAM。&lt;/p&gt; 
&lt;p&gt;如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率，&lt;strong&gt;不支持外键&lt;/strong&gt;，&lt;strong&gt;不支持事务&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;如果要提供提交、回滚、崩溃恢复能力的事物安全（&lt;strong&gt;ACID&lt;/strong&gt;兼容）能力，并要求实现&lt;strong&gt;并发控制&lt;/strong&gt;，InnoDB是一个好的选择，支持外键和事务。&lt;/p&gt; 
&lt;p&gt;为什么MyISAM读比InnoDB快？&lt;/p&gt; 
&lt;p&gt;1、索引和数据分开存储2、不支持事务&lt;/p&gt; 
&lt;p&gt;为什么InnoDB写比MyISAM快？&lt;/p&gt; 
&lt;p&gt;InnoDB默认行锁，而MyISAM只有表锁&lt;/p&gt; 
&lt;h3&gt;并发事务&lt;/h3&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;p&gt;事务的并发问题是如何发生的？&lt;/p&gt; &lt;p&gt;多个事务同时操作同一个数据库的相同数据&lt;/p&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;并发问题有哪些？&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;脏读：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据 &lt;/li&gt;
   &lt;li&gt;不可重复读：一个事务多次读取，结果不一样 &lt;/li&gt;
   &lt;li&gt;幻读：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“插入”的数据 &lt;/li&gt;
  &lt;/ul&gt; &lt;/li&gt;
 &lt;li&gt;&lt;p&gt;如何解决并发问题？&lt;/p&gt; &lt;p&gt;设置隔离级别&lt;/p&gt; &lt;/li&gt;
&lt;/ol&gt; 
&lt;h3&gt;事务的隔离级别有哪些？分别解决了什么问题？&lt;/h3&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th align=&quot;center&quot;&gt;脏读&lt;/th&gt; 
   &lt;th align=&quot;center&quot;&gt;不可重复读&lt;/th&gt; 
   &lt;th align=&quot;center&quot;&gt;幻读&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt;
  &lt;tr&gt; 
   &lt;td&gt;read uncommitted（读未提交）&lt;/td&gt; 
   &lt;td align=&quot;center&quot;&gt;√&lt;/td&gt; 
   &lt;td align=&quot;center&quot;&gt;√&lt;/td&gt; 
   &lt;td align=&quot;center&quot;&gt;√&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;read committed（读已提交）&lt;/td&gt; 
   &lt;td align=&quot;center&quot;&gt;×&lt;/td&gt; 
   &lt;td align=&quot;center&quot;&gt;√&lt;/td&gt; 
   &lt;td align=&quot;center&quot;&gt;√&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;repeatable read（可重复读）&lt;/td&gt; 
   &lt;td align=&quot;center&quot;&gt;×&lt;/td&gt; 
   &lt;td align=&quot;center&quot;&gt;×&lt;/td&gt; 
   &lt;td align=&quot;center&quot;&gt;√&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;serializable（串行化）&lt;/td&gt; 
   &lt;td align=&quot;center&quot;&gt;×&lt;/td&gt; 
   &lt;td align=&quot;center&quot;&gt;×&lt;/td&gt; 
   &lt;td align=&quot;center&quot;&gt;×&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt;
&lt;/table&gt; 
&lt;p&gt;mysql的默认隔离级别是可重复读。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;mysql可重复读的实现原理？&lt;/p&gt; 
 &lt;p&gt;使用一种叫MVCC的控制方式 ，即Mutil-Version Concurrency Control，多版本并发控制，类似于乐观锁的一种实现方式，为每行数据存储一个版本号，&lt;strong&gt;当数据被修改时，版本号加1&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;数据库的分库分表？&lt;/h3&gt; 
&lt;p&gt;一、数据库瓶颈&lt;/p&gt; 
&lt;p&gt;数据库到达瓶颈时会导致数据库的活跃连接数增加，逼近数据库可承载活跃连接数的阈值，业务层来看就是&lt;strong&gt;数据库连接少甚至无连接可用&lt;/strong&gt;，会导致并发量、吞吐量、数据库崩溃等问题&lt;/p&gt; 
&lt;p&gt;1、IO瓶颈&lt;/p&gt; 
&lt;p&gt;1）磁盘读IO瓶颈：热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度&lt;/p&gt; 
&lt;p&gt;​ 解决方法：分库和垂直分表&lt;/p&gt; 
&lt;p&gt;2）网络IO瓶颈，请求的数据太多，网络带宽不够&lt;/p&gt; 
&lt;p&gt;​ 解决方法：分库&lt;/p&gt; 
&lt;p&gt;2、CPU瓶颈&lt;/p&gt; 
&lt;p&gt;1）SQL问题：如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作&lt;/p&gt; 
&lt;p&gt;​ 解决方法：SQL优化，简历合适的索引&lt;/p&gt; 
&lt;p&gt;2）单表数据量太大，查询是扫描的行太多，SQL效率低，CPU率先出现瓶颈&lt;/p&gt; 
&lt;p&gt;​ 解决方法：水平分表&lt;/p&gt; 
&lt;p&gt;二、分库分表&lt;/p&gt; 
&lt;p&gt;1、水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。&lt;/p&gt; 
&lt;p&gt;结果：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;每个库的结构都一样； &lt;/li&gt;
 &lt;li&gt;每个库的数据都不一样，没有交集； &lt;/li&gt;
 &lt;li&gt;所有库的并集是全量数据； &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;场景：&lt;strong&gt;系统绝对并发量上来了&lt;/strong&gt;，分表难以根本上解决问题，并且还&lt;strong&gt;没有明显的业务归属来垂直分库&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;分析：库多了，io和cpu的压力自然可以成倍缓解。&lt;/p&gt; 
&lt;p&gt;2、水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。&lt;/p&gt; 
&lt;p&gt;结果：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;每个表的结构都一样； &lt;/li&gt;
 &lt;li&gt;每个表的数据都不一样，没有交集； &lt;/li&gt;
 &lt;li&gt;所有表的并集是全量数据； &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;场景：&lt;strong&gt;系统绝对并发量并没有上来&lt;/strong&gt;，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。&lt;/p&gt; 
&lt;p&gt;分析：表的数据量少了，单次SQL执行效率高，自然减轻了CPU的负担。&lt;/p&gt; 
&lt;p&gt;3、垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。&lt;/p&gt; 
&lt;p&gt;结果：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;每个库的结构都不一样； &lt;/li&gt;
 &lt;li&gt;每个库的数据也不一样，没有交集； &lt;/li&gt;
 &lt;li&gt;所有库的并集是全量数据； &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;场景：&lt;strong&gt;系统绝对并发量上来了&lt;/strong&gt;，并且可以抽象出单独的业务模块。&lt;/p&gt; 
&lt;p&gt;分析：将相关的表拆到单独的库中，可以服务化。&lt;/p&gt; 
&lt;p&gt;4、垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。&lt;/p&gt; 
&lt;p&gt;结果：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;每个表的结构都不一样； &lt;/li&gt;
 &lt;li&gt;每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据； &lt;/li&gt;
 &lt;li&gt;所有表的并集是全量数据； &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;场景：&lt;strong&gt;系统绝对并发量并没有上来&lt;/strong&gt;，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。&lt;/p&gt; 
&lt;p&gt;分析：垂直分表的拆分原则是将热点数据放在一起作为主表，非热点数据放在一起作为扩展表。这样更多的热点数据就能被缓存下来，进而减少了随机读IO。拆了之后，要想获得全部数据就需要关联两个表来取数据。但记住，千万别用join，因为join不仅会增加CPU负担并且会讲两个表耦合在一起（必须在一个数据库实例上）。关联数据，应该在业务Service层做文章，分别获取主表和扩展表数据然后用关联字段关联得到全部数据。&lt;/p&gt; 
&lt;p&gt;三、分库分表步骤&lt;/p&gt; 
&lt;p&gt;根据容量（当前容量和增长量）评估分库或分表个数 -&amp;gt; 选key（均匀）-&amp;gt; 分表规则（hash或range等）-&amp;gt; 执行（一般双写）-&amp;gt; 扩容问题（尽量减少数据的移动）&lt;/p&gt; 
&lt;h3&gt;MySQL中的锁？什么情况下行锁会变成表锁？&lt;/h3&gt; 
&lt;p&gt;行锁+表锁&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;没有索引或者索引失效时，InnoDB 的行锁变表锁&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;原因：Mysql 的行锁是通过索引实现的&lt;/p&gt; 
&lt;h2&gt;操作系统&lt;/h2&gt; 
&lt;h3&gt;死锁&lt;/h3&gt; 
&lt;p&gt;一、什么是线程死锁？&lt;/p&gt; 
&lt;p&gt;首先明确：进程死锁和线程死锁的区别就是死锁的基本单位不同。&lt;/p&gt; 
&lt;p&gt;线程死锁是当多个线程互相持有对方所需要的资源时，会互相等待对方释放资源，如果线程都不主动释放所占有的资源，将产生死锁。&lt;/p&gt; 
&lt;p&gt;二、死锁产生的四个条件？&lt;/p&gt; 
&lt;p&gt;1、互斥：一个资源只能被一个进程使用&lt;/p&gt; 
&lt;p&gt;2、不剥夺：进程已经获得的资源在使用完以前不能强行剥夺&lt;/p&gt; 
&lt;p&gt;3、请求和保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放&lt;/p&gt; 
&lt;p&gt;4、循环等待：多个进程之间形成一种互相循环等待资源的关系&lt;/p&gt; 
&lt;p&gt;三、如何避免线程死锁？&lt;/p&gt; 
&lt;p&gt;1、控制加锁顺序（常用）&lt;/p&gt; 
&lt;p&gt;所有的线程都按照相同的顺序获得锁，需要事先知道所有可能会用到的锁&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;2、银行家&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;进程运行之前先&lt;strong&gt;声明&lt;/strong&gt;对各种资源的&lt;strong&gt;最大需求量&lt;/strong&gt;，当进程在执行中继续申请资源时，先测试进程已占用的资源数与本次申请的资源数之和是否&lt;strong&gt;超过&lt;/strong&gt;该进程声明的最大需求量，若超过则拒绝分配资源，若未超过则再测试系统现存的资源能否满足该进城所需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。&lt;/p&gt; 
&lt;p&gt;四、怎么定位程序哪里发生了死锁？&lt;/p&gt; 
&lt;p&gt;1、使用 jps -l 定位进程号&lt;/p&gt; 
&lt;p&gt;2、使用 jstack 进程号 找到死锁问题&lt;/p&gt; 
&lt;p&gt;五、死锁接触的方法？&lt;/p&gt; 
&lt;p&gt;1、资源剥夺法：挂起某些死锁并抢夺它的资源，以便让其他进程继续推进&lt;/p&gt; 
&lt;p&gt;2、撤销进程法：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源&lt;/p&gt; 
&lt;p&gt;3、进程回退法：让一个或多个进程回退到足以回避死锁的地步&lt;/p&gt; 
&lt;h3&gt;堆和栈的区别？&lt;/h3&gt; 
&lt;p&gt;1）栈由系统自动分配，而堆是人为申请开辟；&lt;/p&gt; 
&lt;p&gt;2）栈获得的空间较小，而堆获得的空间较大；&lt;/p&gt; 
&lt;p&gt;3）栈由系统自动分配，速度较快，而堆一般速度比较慢；&lt;/p&gt; 
&lt;p&gt;4）栈是连续的空间，而堆是不连续的空间。&lt;/p&gt; 
&lt;h3&gt;进程和线程的区别？&lt;/h3&gt; 
&lt;p&gt;1、进程是一段程序，是资源分配的最小单元，线程是CPU调度的最小单元，一个进程中可以包含有多个线程&lt;/p&gt; 
&lt;p&gt;2、进程有独立的内存空间，多个线程共享相同的内存空间；线程有独立的栈，没有独立的堆，堆通常与进程相关，每一个线程有自己的栈，访问共同的堆&lt;/p&gt; 
&lt;p&gt;3、通信方式不同&lt;/p&gt; 
&lt;h3&gt;进程间的通信方式及适用场景？&lt;/h3&gt; 
&lt;p&gt;一、共享内存通信&lt;/p&gt; 
&lt;p&gt;共享内存是指&lt;strong&gt;多个进程共享一块内存&lt;/strong&gt;，是专门用来解决不同进程之间的通信问题的，由于是直接对内存进行数据传输操作，所以是&lt;strong&gt;速度最快&lt;/strong&gt;的IPC（inter-process communication）方式，因为是共享内存，所以需要&lt;strong&gt;配合信号量&lt;/strong&gt;机制实现同步。&lt;/p&gt; 
&lt;p&gt;二、管道通信&lt;/p&gt; 
&lt;p&gt;1、无名管道&lt;/p&gt; 
&lt;p&gt;半双工，只能在具&lt;strong&gt;有亲缘关系&lt;/strong&gt;的进程间使用。（进程的亲缘关系通常是指父子进程关系）&lt;/p&gt; 
&lt;p&gt;2、具名管道&lt;/p&gt; 
&lt;p&gt;半双工，允许&lt;strong&gt;无亲缘关系&lt;/strong&gt;进程间的通信。&lt;/p&gt; 
&lt;p&gt;三、消息队列&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;消息队列是消息的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;，克服了信号传递消息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;四、套接字通信&lt;/p&gt; 
&lt;p&gt;可用于不同机器间的进程通信。&lt;/p&gt; 
&lt;h3&gt;什么是协程？&lt;/h3&gt; 
&lt;p&gt;协程是一种比线程更加轻量级的存在，&lt;strong&gt;一个线程可以拥有多个协程&lt;/strong&gt;。协程不是被操作系统内核所管理，而是完全&lt;strong&gt;由程序所控制&lt;/strong&gt;（也就是在用户态执行），好处是&lt;strong&gt;性能得到了很大提升&lt;/strong&gt;，不会像线程切换那样消耗资源。&lt;/p&gt; 
&lt;h3&gt;JDK1.8后锁的几种状态？&lt;/h3&gt; 
&lt;p&gt;无锁状态、偏向锁、轻量级锁、重量级锁&lt;/p&gt; 
&lt;h2&gt;计算机网络&lt;/h2&gt; 
&lt;h3&gt;&lt;strong&gt;BIO、NIO、AIO的区别？&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;img alt=&quot;img&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210513/77530848_1620871941745/v2-287adf33d7dd43cb745de0a88f7d10ff_720w.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;BIO：同步阻塞IO，一个请求对应一个线程，上下文切换占用的资源很重，无用的请求也会占用一个线程，没有数据到达也会阻塞。&lt;/p&gt; 
&lt;p&gt;改进：线程池机制&lt;/p&gt; 
&lt;p&gt;NIO：同步非阻塞IO，利用多路复用技术（select，poll，epoll），多个socket通道对应一个线程&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;AIO：一个有效请求一个线程，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;的 I/O 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;浏览器输入一个网址后发生了什么？&lt;/h3&gt; 
&lt;p&gt;1、DNS解析：&lt;/p&gt; 
&lt;p&gt;浏览器会根据输入的URL去查找对应的IP，寻找的过程遵循就近原则，依次是：浏览器缓存 --&amp;gt; 操作系统缓存 --&amp;gt; 路由器缓存--&amp;gt;本地（ISP）域名服务器缓存 --&amp;gt; 根域名服务器&lt;/p&gt; 
&lt;p&gt;2、进行TCP连接&lt;/p&gt; 
&lt;p&gt;浏览器得到IP以后，向服务器发送TCP连接，TCP连接经过三次握手&lt;/p&gt; 
&lt;p&gt;3、浏览器发送HTTP请求&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;HTTP的请求方式为get，这个get请求包含了主机（Host）、用户代理(User-Agent)，用户代理就是自己的浏览器，它是你的&quot;代理人&quot;，Connection（连接属性）中的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=keep&quot; target=&quot;_blank&quot;&gt;keep&lt;/a&gt;-alive表示浏览器告诉对方服务器在传输完现在请求的内容后不要断开连接，不断开的话下次继续连接速度就很快了。可能还会有Cookies，Cookies保存了用户的登陆信息，一般保存的是用户的JSESSIONID，在每次向服务器发送请求的时候会重复发送给服务器，服务器就知道是哪个浏览器。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;4、服务器处理请求&lt;/p&gt; 
&lt;p&gt;服务器传回来响应头（包含状态码）和具体的要请求的页面内容&lt;/p&gt; 
&lt;p&gt;5、浏览器解析渲染页面&lt;/p&gt; 
&lt;p&gt;6、关闭TCP连接（四次挥手）&lt;/p&gt; 
&lt;h3&gt;TCP三次握手&lt;/h3&gt; 
&lt;p&gt;一、三次握手的过程？&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片说明&quot; src=&quot;https://uploadfiles.nowcoder.com/images/20210513/77530848_1620873869790/9E782FC31C7963C2803A5569FCDA9142&quot; title=&quot;图片标题&quot;/&gt; &lt;/p&gt; 
&lt;p&gt;&lt;span&gt;1、&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;向服务端发送1个连接请求的报文段（SYN=1、seq=x）（&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;变成SYN-SENT）&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;什么是syn？&lt;/p&gt; 
 &lt;p&gt;&lt;span&gt;syn是TCP/IP建立连接时使用的握手信号，在&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;和服务端建立TCP网络连接时，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;首先发送一个syn消息，服务端使用syn-ack应答表示接收到了这个消息，最后&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;再以ack消息响应，这样再&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;和服务器之间才能建立起可靠的TCP连接，数据才可以在&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;和服务器之间传递。 &lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;span&gt;2、服务端收到请求连接报文段后，若同意建立连接，则向&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;发回连接确认的报文段（SYN=1、ACK=1、seq=y、ack=x+1）（服务器变成SYN-RECEIVED）&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;为什么要回传syn？&lt;/p&gt; 
 &lt;p&gt;接收端传回发送端发送的syn是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。&lt;/p&gt; 
 &lt;p&gt;传了syn为啥还要传ack？&lt;/p&gt; 
 &lt;p&gt;传了syn证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ack信号来进行验证。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;span&gt;3、&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;收到确认报文段后，向服务器再次发出连接确认报文段（ACK=1、seq=x+1、ack=y+1）（&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;和服务器变成ESTABLISHED）&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;二、为什么需要三次握手？&lt;/p&gt; 
&lt;p&gt;为了信息对等和防止出现请求超时导致脏连接。&lt;/p&gt; 
&lt;p&gt;1、信息对等就是确保两台机器都具备发报和收报的能力，也就是确保发送端到接收端和接收端到发送端的通道都没有问题。&lt;/p&gt; 
&lt;p&gt;2、为什么会出现脏连接？&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片说明&quot; src=&quot;https://uploadfiles.nowcoder.com/images/20210513/77530848_1620873921995/53EDCBCE62A1B0F3161B8EEA874AF4E0&quot; title=&quot;图片标题&quot;/&gt; &lt;/p&gt; 
&lt;p&gt;网络报文的TTL往往都会超过TCP请求超时时间，如果两次握手就可以创建连接，那么传输数据并释放连接后，第一个超时的连接请求才到达B机器的话，B机器会以为是A创建新连接的请求，然后确认同意创建连接，引文A机器的状态不是SYN_SENT，所以直接丢弃了B的确认数据，以致最后只是B机器单方面创建连接完毕。三次握手就可以解决这个问题，因为需要A机器确认以后才真正建立了连接。&lt;/p&gt; 
&lt;h3&gt;TCP四次挥手&lt;/h3&gt; 
&lt;p&gt;一、四次挥手的过程？&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片说明&quot; src=&quot;https://uploadfiles.nowcoder.com/images/20210513/77530848_1620873949127/51BBE3A17F354C178F959C9FE8830E55&quot; title=&quot;图片标题&quot;/&gt; &lt;/p&gt; 
&lt;p&gt;&lt;span&gt;1、&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;向服务器发送1个连接释放的报文段&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;2、服务器收到连接释放报文段后，向&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;返回连接释放确认报文段&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;3、若服务器已无要向&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;发送的数据，则发出释放连接的报文段&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;4、&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;收到连接释放报文段后，向服务器发回连接释放确认报文段&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;二、为什么需要四次挥手？&lt;/p&gt; 
&lt;p&gt;由于&lt;strong&gt;TCP的半关闭&lt;/strong&gt;造成的，半关闭就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;第二次挥手后服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;到服务端的连接释放，此时&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;已无数据发送，而服务端还可以向&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;发送数据，所以第二次挥手不能发送FIN报文，只有当服务端也没有数据要发送了，才在第三次挥手时发送FIN报文，告诉&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;不再发送数据了。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;三、为什么&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;关闭连接前要等待2MSL时间？&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;MSL(Maximum Segment Lifetime)，为“报文最大生存时间”，是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;span&gt;1、保证&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;发送的最后一个ACK报文段能够到达服务端&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;这个ACK报文段有可能丢失，使服务端收不到确认，服务端超时重传FIN+ACK报文段，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;能在2MSL时间内收到这个报文段，接着&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;重传一次确认，重新启动2MSL计时器，最后&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;和服务端都进入到CLOSED状态。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;2、防止已失效的连接请求报文段出现在本连接中&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;在发送完最后一个ACK报文段后，在经过2MSL就可以使本连接持续时间内所产生的所有报文段都从网络中 消失，使下一个新的连接中不会出现这种旧的连接请求报文段。&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;TCP和UDP的区别和应用场景&lt;/h3&gt; 
&lt;p&gt;一、对比&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;UDP&lt;/th&gt; 
   &lt;th&gt;TCP&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt;
  &lt;tr&gt; 
   &lt;td&gt;是否连接&lt;/td&gt; 
   &lt;td&gt;无连接&lt;/td&gt; 
   &lt;td&gt;面向连接&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;是否可靠&lt;/td&gt; 
   &lt;td&gt;不可靠传输&lt;/td&gt; 
   &lt;td&gt;可靠传输&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;流量控制&lt;/td&gt; 
   &lt;td&gt;无&lt;/td&gt; 
   &lt;td&gt;有（滑动窗口）&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;拥塞控制&lt;/td&gt; 
   &lt;td&gt;无&lt;/td&gt; 
   &lt;td&gt;有（慢开始 拥塞避免 快重传 快恢复）&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;连接对象个数&lt;/td&gt; 
   &lt;td&gt;支持一对一，一对多，多对一和多对多交互通信&lt;/td&gt; 
   &lt;td&gt;只能是一对一通信（全双工）&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;传输方式&lt;/td&gt; 
   &lt;td&gt;面向报文&lt;/td&gt; 
   &lt;td&gt;面向字节流&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;首部开销&lt;/td&gt; 
   &lt;td&gt;首部开销小，仅8字节&lt;/td&gt; 
   &lt;td&gt;首部最小20字节，最大60字节&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;适用场景&lt;/td&gt; 
   &lt;td&gt;适用于实时应用（IP电话、视频会议、直播等）&lt;/td&gt; 
   &lt;td&gt;适用于要求可靠传输的应用，例如文件传输&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt;
&lt;/table&gt; 
&lt;p&gt;二、总结&lt;/p&gt; 
&lt;p&gt;1、TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。&lt;/p&gt; 
&lt;p&gt;2、虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为&lt;/p&gt; 
&lt;p&gt;3、对数据准确性要求高，速度可以相对较慢的，可以选用TCP&lt;/p&gt; 
&lt;h3&gt;TCP怎么保证数据传输的可靠性？&lt;/h3&gt; 
&lt;p&gt;1、校验和：将发送的数据段都当作一个16位的整数，相加，进位不丢弃补在后面，最后取反得到校验和&lt;/p&gt; 
&lt;p&gt;2、确认应答与序列号：TCP传输时对每个字节的数据都进行了编号，每次接收方收到数据后，都会对传输方进行确认应答(ACK)，其中带有对应的确认序列号，告诉发送方接收到了哪些数据，下一次的数据从哪里发&lt;/p&gt; 
&lt;p&gt;3、超时重传：时间到达没有收到ACK进行超时重传&lt;/p&gt; 
&lt;p&gt;4、连接管理：三四握手+四次挥手&lt;/p&gt; 
&lt;p&gt;5、流量控制：滑动窗口&lt;/p&gt; 
&lt;p&gt;6、拥塞控制：慢开始、拥塞避免、快重传、快恢复&lt;/p&gt; 
&lt;h3&gt;拥塞控制和流量控制的区别？TCP怎么实现拥塞控制的？&lt;/h3&gt; 
&lt;p&gt;一、什么是拥塞？对资源的需求&amp;gt;可用资源时网络性能变坏。&lt;/p&gt; 
&lt;p&gt;二、拥塞控制和流量控制的区别？&lt;/p&gt; 
&lt;p&gt;拥塞控制：&lt;strong&gt;全局性过程&lt;/strong&gt;，防止过多的数据注入网络中，使得网络中路由器或链路不过载。&lt;/p&gt; 
&lt;p&gt;流量控制：&amp;lt;stron&amp;gt;，抑制发送端发送数据的速率，便于接收端来得及接收。&amp;lt;/stron&amp;gt;&lt;/p&gt; 
&lt;p&gt;三、拥塞控制方法：&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;主要有四种&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;：&lt;/span&gt;&lt;strong&gt;慢开始、拥塞避免、快重传、快恢复&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;在这里插入图片描述&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210513/77530848_1620871941718/20190731184935595.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;发送方维护一个&lt;strong&gt;拥塞窗口&lt;/strong&gt;，先进行&lt;strong&gt;&lt;span&gt;慢开始&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;，一开始发送方发送一个字节，在收到接收方的确认，然后发送的字节数量增大一倍，按照&lt;strong&gt;指数逐步增大窗口大小&lt;/strong&gt;，直到达到&lt;strong&gt;慢开始门限&lt;/strong&gt;，然后使用&lt;strong&gt;&lt;span&gt;拥塞控制&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;，增长速率变为线性增长，直到出现&lt;strong&gt;超时&lt;/strong&gt;，重新将窗口大小调整为&lt;strong&gt;1个字节&lt;/strong&gt;&lt;span&gt;，使用慢开始&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;，同时慢开始门限调整为超时点的一半，达到门限后继续执行拥塞避免方法，如果收到&lt;/span&gt;&lt;strong&gt;3-ACK&lt;/strong&gt;，可能是&lt;strong&gt;报文丢失&lt;/strong&gt;，使用&lt;strong&gt;快重传&lt;/strong&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;发送缺失的报文段，同时执行&lt;/span&gt;&lt;strong&gt;快恢复&lt;/strong&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;将门限调整为此时&lt;/span&gt;&lt;strong&gt;窗口的一半&lt;/strong&gt;，并执行&lt;strong&gt;&lt;span&gt;拥塞避免&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt; 
&lt;h3&gt;TCP的滑动窗口解决了什么问题？滑动机制是什么？&lt;/h3&gt; 
&lt;p&gt;滑动窗口解决的是&lt;strong&gt;流量控制&lt;/strong&gt;的的问题，就是如果接收端和发送端对数据包的处理速度不同，如何让双方达成一致。接收端的缓存传输数据给应用层，但这个过程不一定是即时的，如果发送速度太快，会出现接收端数据overflow，流量控制解决的是这个问题。&lt;/p&gt; 
&lt;p&gt;TCP会话的双方都各自维护一个&lt;code&gt;发送窗口&lt;/code&gt;和一个&lt;code&gt;接收窗口&lt;/code&gt;。发送窗口只有收到发送窗口内字节的ACK确认，才会移动发送窗口的左边界。接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。发送方发的window size = 8192;就是接收端最多发送8192字节，这个8192一般就是发送方接收缓存的大小。&lt;/p&gt; 
&lt;h3&gt;TCP和HTTP的队头阻塞？&lt;/h3&gt; 
&lt;p&gt;一、TCP的队头阻塞&lt;/p&gt; 
&lt;p&gt;1、产生原因：一个TCP分节丢失，导致其后续分节不按序到达接收端的时候。该后续分节将被接收端一直保持直到丢失的第一个分节被发送端重传并到达接收端为止&lt;/p&gt; 
&lt;p&gt;2、解决方法：舍弃TCP协议&lt;/p&gt; 
&lt;p&gt;二、HTTP的队头阻塞&lt;/p&gt; 
&lt;p&gt;1、产生原因：HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达&lt;/p&gt; 
&lt;p&gt;2、解决方法：HTTP2实现了完全多路复用，只需一个连接即可实现并行&lt;/p&gt; 
&lt;h3&gt;TCP的粘包问题及解决方法？&lt;/h3&gt; 
&lt;p&gt;TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾&lt;/p&gt; 
&lt;p&gt;一、粘包问题产生的原因&lt;/p&gt; 
&lt;p&gt;1、当连续发送数据时，由于tcp协议的nagle算***将较小的内容拼接成大的内容，一次性发送到服务器端，因此造成粘包&lt;/p&gt; 
&lt;p&gt;2、当发送内容较大时，由于服务器端的recv(buffer_size)方法中的buffer_size较小，不能一次性完全接收全部内容，因此在下一次请求到达时，接收的内容依然是上一次没有完全接收完的内容，因此造成粘包现象&lt;/p&gt; 
&lt;p&gt;二、解决方法&lt;/p&gt; 
&lt;p&gt;1、对于第一种粘包产生方式可以在两次send()直接使用recv()阻止连续发送的情况发生&lt;/p&gt; 
&lt;p&gt;2、由于产生粘包的原因是接收方的无边界接收，因此发送端可以在发送数据之前向接收端告知发送内容的大小即可&lt;/p&gt; 
&lt;h3&gt;DNS域名解析用的是什么协议？&lt;/h3&gt; 
&lt;p&gt;同时使用TCP和UDP协议。&lt;/p&gt; 
&lt;p&gt;DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。&lt;/p&gt; 
&lt;p&gt;一、&lt;strong&gt;DNS区域传输的时候使用TCP协议：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;DNS规范规定了两种DNS服务器：主DNS服务器和辅助DNS服务器，辅助域名服务器会定时向主域名服务器进行查询以便了解数据是否有变动，如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。而TCP是一种可靠连接，保证了数据的准确性。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;二、域名解析时使用UDP协议：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可，不用经过三次握手，这样DNS服务器负载更低。&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span&gt;什么是socket？&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;和服务端的socket通信过程？&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;socket是传输层和应用层之间的一个抽象层，socket是一种&lt;strong&gt;打开--读/写--关闭模式&lt;/strong&gt;&lt;span&gt;的实现，服务器和&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;各自维护一个”文件“（Unix一切皆文件），在建立连接打开后，可以向文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;socket通信过程：&lt;br/&gt;&lt;span&gt;socket保证了不同计算机之间的通信，也就是网络通信。对于网站，通信模型是服务器与&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;之间的通信。两端都建立了一个Socket对象，然后通过Socket对象对数据进行传输。通常服务器处于一个无限循环，等待&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;的连接。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片说明&quot; src=&quot;https://uploadfiles.nowcoder.com/images/20210513/77530848_1620874031009/DE6CEC309B1D365010BB39E9657BA789&quot; title=&quot;图片标题&quot;/&gt; &lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;过程：&lt;/span&gt;&lt;br/&gt;创建socket，连接服务器，将socket与远程主机连接，发送数据，读取响应数据，直到数据交换完毕，关闭连接，结束TCP对话&lt;/p&gt; 
&lt;p&gt;服务端过程：&lt;/p&gt; 
&lt;p&gt;创建socket，与本机地址及端口进行&lt;strong&gt;绑定&lt;/strong&gt;，然后通知TCP准备好接收连接，调用accept()&lt;strong&gt;阻塞&lt;/strong&gt;&lt;span&gt;，等待来自&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;的连接。如果&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;与服务器建立了连接，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;发送数据请求，服务器接收请求并处理请求，然后把响应数据发送给&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;读取数据，直到数据交换完毕，最后关闭连接。&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;HTTP和HTTPS的区别？&lt;/h3&gt; 
&lt;p&gt;1、最重要的区别是安全性，HTTP明文传输，不对数据进行加密安全性较差，HTTPS(HTTP+SSL/TLS)的数据传输过程是加密的，安全性较好&lt;/p&gt; 
&lt;p&gt;2、HTTP响应速度比HTTPS快，因为HTTPS多了一层安全层&lt;/p&gt; 
&lt;p&gt;3、HTTPS端口号443，HTTP端口号80&lt;/p&gt; 
&lt;p&gt;HTTPS的缺点：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;相同环境下HTTPS的响应时间和需要的资源相比HTTP都大幅上升 &lt;/li&gt;
 &lt;li&gt;HTTPS的安全范围有限，在黑客攻击和服务器劫持等情况几乎起不到作用 &lt;/li&gt;
&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;SSL/TLS怎么加密？&lt;/p&gt; 
 &lt;p&gt;&lt;span&gt;（1） &lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;向服务器端索要并验证公钥。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;（2） 双方协商生成&quot;对话密钥&quot;。&lt;/p&gt; 
 &lt;p&gt;（3） 双方采用&quot;对话密钥&quot;进行加密通信。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;HTTP1.0、1.1、2.0的区别？&lt;/h3&gt; 
&lt;p&gt;HTTP1.X：线程阻塞，同一时间同一域名的请求有一定数量限制，超过限制数目的请求会被阻塞&lt;/p&gt; 
&lt;p&gt;HTTP1.0和HTTP1.1主要区别：HTTP1.0默认使用短连接，HTTP1.1默认使用长连接&lt;/p&gt; 
&lt;p&gt;HTTP2.0：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;采用二进制格式而非文本格式 &lt;/li&gt;
 &lt;li&gt;完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行 &lt;/li&gt;
 &lt;li&gt;使用报头压缩，降低开销 &lt;/li&gt;
 &lt;li&gt;服务器推送 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h3&gt;GET、POST的区别？&lt;/h3&gt; 
&lt;p&gt;从幂等性、安全性、传参方式、URL长度限制等方面回答。&lt;/p&gt; 
&lt;p&gt;1、幂等性：GET用于无副作用（不改变服务器资源）、幂等的场景，POST用于副作用、不幂等的场景&lt;/p&gt; 
&lt;p&gt;2、传参方式：GET请求对应的参数放在URL中，而POST请求对应的参数放在请求体中&lt;/p&gt; 
&lt;p&gt;3、长度限制：浏览器会对URL最大字符长度做限制，导致GET请求的参数数量是有限的&lt;/p&gt; 
&lt;p&gt;4、安全性：GET请求的参数暴露在URL中，安全性没有POST高&lt;/p&gt; 
&lt;h3&gt;Session、Cookie的区别？&lt;/h3&gt; 
&lt;p&gt;Session是在&lt;strong&gt;服务端保存&lt;/strong&gt;的一个数据结构，用来跟踪用户的状态&lt;/p&gt; 
&lt;p&gt;Cookie是在&lt;strong&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;保存&lt;/span&gt;&lt;/strong&gt;用户信息的一种机制，也是实现Session的一种方式，&lt;/p&gt; 
&lt;h3&gt;ping命令的原理？&lt;/h3&gt; 
&lt;p&gt;&lt;span&gt;PING是用于测试网络连接质量的程序。Ping发送一个ICMP(Internet Control Messages &lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=Proto&quot; target=&quot;_blank&quot;&gt;Proto&lt;/a&gt;col）即网络信报控制协议；&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;原理：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。&lt;/p&gt; 
&lt;h3&gt;&lt;span&gt;如何实现负载均衡？有哪些&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;？&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;一、实现负载均衡的几种技术&lt;/p&gt; 
&lt;p&gt;1、HTTP重定向协议实现负载均衡：根据用户的http请求计算出一个真实的web服务器地址，并将该web服务器地址写入http重定向响应中返回给浏览器，由浏览器重新进行访问。&lt;/p&gt; 
&lt;p&gt;2、DNS域名解析负载均衡：原理：在DNS服务器上配置多个域名对应IP的记录。例如一个域名&lt;a href=&quot;http://www.baidu.com%E5%AF%B9%E5%BA%94%E4%B8%80%E7%BB%84web%E6%9C%8D%E5%8A%A1%E5%99%A8IP%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%97%B6%E7%BB%8F%E8%BF%87DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%AE%97%E6%B3%95%E5%B0%86%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D%E8%AF%B7%E6%B1%82%E5%88%86%E9%85%8D%E5%88%B0%E5%90%88%E9%80%82%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E3%80%82&quot; target=&quot;_blank&quot; from-niu=&quot;default&quot;&gt;www.baidu.com对应一组web服务器IP地址，域名解析时经过DNS服务器的算法将一个域名请求分配到合适的真实服务器上。&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;3、反向代理负载均衡：反向代理处于web服务器这边，反向代理服务器提供负载均衡的功能，同时管理一组web服务器，它根据负载均衡&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;将请求的浏览器访问转发到不同的web服务器处理，处理结果经过反向服务器返回给浏览器。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;4、IP负载均衡：在网络层通过修改目标地址进行负载均衡。&lt;/p&gt; 
&lt;p&gt;5、数据链路层负载均衡：在数据链路层修改Mac地址进行负载均衡。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;二、常见的负载均衡&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;轮询法、随机法、加权轮询法、加权随机法&lt;/p&gt; 
&lt;h2 id=&quot;linux&quot;&gt;Linux&lt;/h2&gt; 
&lt;h3&gt;Linux的启动过程？&lt;/h3&gt; 
&lt;p&gt;1、内核引导：开机自检，加载BIOS&lt;/p&gt; 
&lt;p&gt;2、运行init：init进程是所有进程的起点，没有这个进程，系统中任何进程都不会启动。根据运行级别确定要运行哪些程序&lt;/p&gt; 
&lt;p&gt;3、系统初始化：激活交换分区，检查磁盘，加载硬件模块&lt;/p&gt; 
&lt;p&gt;4、建立终端，以便用户登录系统&lt;/p&gt; 
&lt;p&gt;5、用户登录系统：命令行/ssh/图形界面登录&lt;/p&gt; 
&lt;h3&gt;什么是僵尸进程？&lt;/h3&gt; 
&lt;p&gt;僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出，子进程被init接管，子进程推出后init会回收其占用的相关资源。&lt;/p&gt; 
&lt;h2&gt;设计模式&lt;/h2&gt; 
&lt;h3&gt;单例&lt;/h3&gt; 
&lt;p&gt;一个类在内存中只存在一个对象&lt;/p&gt; 
&lt;p&gt;步骤：1、构造函数私有化2、在类中创建一个本类对象3、提供一个方法可以获取到该对象&lt;/p&gt; 
&lt;pre class=&quot;prettyprint lang-java&quot; from-niu=&quot;default&quot;&gt;//饿汉式
class Single {
    private static final Single s = new Single();
    private Single() {}
    public static Single getInstance() {
        return s;
    }
}&lt;/pre&gt; 
&lt;pre class=&quot;prettyprint lang-java&quot; from-niu=&quot;default&quot;&gt;//懒汉式:延时加载
class Single {
    private static Single s = null;
    private Single() {}
    public static Single getInstance() {
        if (s == null) {
            //Synchronized解决多线程安全问题
            Synchronized(Single.class)
            {
                if (s == null) {
                    //双重判断解决效率问题
                    s = new Single();
                }
            }
        }
        return s;
    }
}&lt;/pre&gt; 
&lt;h2&gt;高级知识&lt;/h2&gt; 
&lt;h3 id=&quot;redis&quot;&gt;Redis&lt;/h3&gt; 
 
&lt;p&gt;&lt;span&gt;1、什么是&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;哨兵模式？&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;哨兵模式是&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;的高可用架构的一种方式，它的出现是为了解决主从模式下主节点挂了不能自动故障转移的问题，哨兵架构图如下：&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;img&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210513/77530848_1620872161245/20421881-933234852728c6da.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;2、哨兵实现原理？（三个定时任务）（心跳机制+投票裁决）&lt;/p&gt; 
&lt;p&gt;问题一：sentinel没有配置从节点信息如何知道从节点信息的？&lt;/p&gt; 
&lt;p&gt;每隔10秒，sentinel向主节点发送info命令，用于发现新的slave节点&lt;/p&gt; 
&lt;p&gt;问题二、如何加入新的sentinel？&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;每隔2秒，向&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;数据节点_ sentinel_:hello频道发送本sentinel节点的信息和对主节点的判断：这是进行对主节点进行客观下线和领导者选举的重要依据；也是发现新sentinel节点的重要依据&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;问题三：如何判断一个节点的需要主观下线的？&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;每隔1秒每个sentinel对其他的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;节点（master，slave，sentinel）执行ping操作，对于master来说，若超过down-after-milliseconds内没有回复，就对该节点进行主观下线并询问其他的Sentinel节点是否可以客观下线&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;3、哨兵的作用？&lt;/p&gt; 
&lt;p&gt;1）监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。&lt;br/&gt;2）提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。&lt;br/&gt;&lt;span&gt;3）自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;试图连接失效的主服务器时，集群也会向&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;4、主管下线和客观下线？&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;主观下线：每隔1秒每个sentinel对其他的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;节点（master，slave，sentinel）执行ping操作，若master超过down-after-milliseconds内没有回复，就对该节点进行主观下线，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;每个sentinel节点对&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;节点失败的“偏见”&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;客观下线：当sentinel主观下线的节点是主节点时，sentinel会通过命令sentinel is-master-down-by-addr来询问其sentinel对主节点的判断，如果超过quorum个数就认为主节点需要客观下线, &lt;strong&gt;&lt;span&gt;所有sentinel节点对&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;节点失败达成共识&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;5、如何选举sentinel的leader？&lt;/p&gt; 
&lt;p&gt;使用raft协议（解决分布式系统一致性问题的协议）&lt;/p&gt; 
&lt;p&gt;1）每个做主观下线的sentinel节点向其他sentinel节点发送命令，要求将自己设置为leader&lt;/p&gt; 
&lt;p&gt;2）收到的sentinel可以同意或拒绝&lt;/p&gt; 
&lt;p&gt;3）如果该sentinel节点发现自己的票数已经超过了半数并且超过了quorum那么当选leader&lt;/p&gt; 
&lt;p&gt;4）如果此过程选举出了多个leader，那么将等待一段时间重新进行选举&lt;/p&gt; 
&lt;p&gt;6、sentinel的leader如何选举从节点成为主节点？&lt;/p&gt; 
&lt;p&gt;1）过滤故障节点&lt;/p&gt; 
&lt;p&gt;2）根据slave-priority优先级进行选择&lt;/p&gt; 
&lt;p&gt;3）选择复制偏移量大的从节点为主节点&lt;/p&gt; 
&lt;p&gt;4）选择runid最小的从成为主（说明重启的时间靠前）&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;img&quot; src=&quot;https://uploadfiles.nowcoder.com/files/20210513/77530848_1620872161302/20421881-d899be3f8c1f89b2.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;7、&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;集群中的某个节点挂了怎么办？&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;自动故障迁移&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;8、什么是&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;的主从复制？&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;集群中的每个节点都有1-N个复制品，其中一个为主节点，其余的为从节点，如果主节点下线了，集群就会把这个主节点的一个从节点设置为新的主节点继续工作，这样集群就不会因为一个主节点的下线而无法正常工作&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;9、&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;主从复制的方式？&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;全量同步和增量同步&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;10、如何解决主从架构的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;分布式锁主节点宕机锁丢失的问题？&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;使用&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;son封装的redlock&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;实现的分布式锁用法。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;redlock&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;思想：不能只在一个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;实例上创建锁，应该是在多个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;实例上创建锁，必须在大多数&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;节点上都成功创建锁，才能算这个整体的RedLock加锁成功，避免仅仅在一个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;实例上加锁而带来的问题。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;关键在于set的value要具有唯一性，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;son怎样保持value的一致性？&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;UUID+threadId&lt;/p&gt; 
 
&lt;p&gt;1、&lt;strong&gt;速度快&lt;/strong&gt;，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)&lt;/p&gt; 
&lt;p&gt;2、支持&lt;strong&gt;丰富数据类型&lt;/strong&gt;，支持string，list，set，sorted set，hash&lt;/p&gt; 
&lt;p&gt;3、&lt;strong&gt;支持事务&lt;/strong&gt;，操作都是&lt;strong&gt;原子性&lt;/strong&gt;，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行&lt;/p&gt; 
&lt;p&gt;4、丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除&lt;/p&gt; 
 
&lt;p&gt;&lt;span&gt;1、&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;是&lt;/span&gt;&lt;strong&gt;纯内存数据库&lt;/strong&gt;，一般都是简单的存取操作，读取速度快&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;2、&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;使用&lt;/span&gt;&lt;strong&gt;非阻塞IO，IO多路复用&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;3、&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;采用&lt;/span&gt;&lt;strong&gt;单线程模型&lt;/strong&gt;，保证每个操作的原子性，减少了线程的上下文切换和竞争&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;4、&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;全程使用&lt;/span&gt;&lt;strong&gt;hash结构&lt;/strong&gt;，读取速度快，再比如有序集合使用的跳表&lt;/p&gt; 
&lt;h4&gt;&lt;span&gt;除了&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;还有什么分布式缓存数据库？&lt;/span&gt;&lt;/h4&gt; 
&lt;p&gt;Memcached&lt;/p&gt; 
&lt;p&gt;Memcached是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。Memcached通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;特点：哈希方式存储；全内存操作；简单文本协议进行数据通信；只操作字符型数据；集群由应用进行控制，采用&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;一致性哈希算法&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;限制性：数据保存在内存当中的，一旦机器重启，数据会全部丢失；只能操作字符型数据，数据类型贫乏；以root权限运行，而且Memcached本身没有任何权限管理和认证功能，安全性不足；能存储的数据长度有限，最大键长250个字符，储存数据不能超过1M。&lt;/p&gt; 
 
&lt;p&gt;1、类型上：&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;mysql是关系型数据库，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;是缓存数据库&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;2、作用上：&lt;/p&gt; 
&lt;p&gt;mysql用于持久化的存储数据到硬盘，功能强大，但是速度较慢&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;用于存储使用较为频繁的数据到缓存中，读取速度快&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;3、需求上：&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;mysql和&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;因为需求的不同，一般都是配合使用&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;补充：&lt;/p&gt; 
&lt;p&gt;1、mysql支持sql查询，可以实现一些关联的查询以及统计；&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;2、&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;对内存要求比较高，在有限的条件下不能把所有数据都放在&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;；&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;3、mysql偏向于存数据，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;偏向于快速取数据，但&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;查询复杂的表关系时不如mysql，所以可以把热门的数据放&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;，mysql存基本数据&lt;/span&gt;&lt;/p&gt; 
&lt;h4&gt;为什么用Redis不用Map？&lt;/h4&gt; 
&lt;p&gt;1、Redis可以实现分布式的缓存，Map只存在创建它的程序里&lt;/p&gt; 
&lt;p&gt;2、Redis可以分配很大的内存来做缓存，而Map受到JVM的限制&lt;/p&gt; 
&lt;p&gt;3、Redis的缓存可以持久化，Map存在于内存中，重启后丢失&lt;/p&gt; 
&lt;p&gt;4、Redis可以处理每秒百万级的并发，而Map只是普通对象&lt;/p&gt; 
&lt;p&gt;5、Redis缓存有过期机制，而Map无此功能&lt;/p&gt; 
&lt;p&gt;6、Redis有丰富的API，Map简单太多了&lt;/p&gt; 
&lt;h4&gt;Redis分布式锁的原理&lt;/h4&gt; 
&lt;p&gt;&lt;span&gt;1、加锁机制：某个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;要加锁，如果该&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;面对的是一个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt; cluster集群，首先会根据hash节点选择一台机器。紧接着，就会发送一段lua脚本到&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;上，保证这段复杂业务逻辑执行的&lt;/span&gt;&lt;strong&gt;原子性&lt;/strong&gt;&lt;span&gt;。lua脚本中包含的参数有加锁的key，key的默认生存时间，加锁的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;的ID。加锁的逻辑是SETNX，即不存在才加锁。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;2、锁互斥机制：&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;2来尝试加锁时会发现锁已存在并且&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;ID不是自己的，此时会进入一个while循环，不停的尝试加锁。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;3、watch dog自动延期机制：&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;1一旦加锁成功，就会启动一个watch dog看门狗，&lt;/span&gt;&lt;strong&gt;他是一个后台线程，会每隔10秒检查一下&lt;/strong&gt;&lt;span&gt;，如果&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;1还持有锁key，那么就会不断的延长锁key的生存时间。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;4、可重入加锁机制：如果&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;1已经持有锁了还进行可重入的加锁那么就会对&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;1的加锁次数累加1。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;5、释放锁机制：执行lock.unlock()就可以释放分布式锁，每次对加锁次数减1，当加锁次数为0时从&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;里删除这个key，然后另外的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;2就可以尝试完成加锁了。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;Redis分布式锁的缺点？&lt;/p&gt; 
 &lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt; cluster，或者是&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt; master-slave架构的&lt;/span&gt;&lt;strong&gt;主从异步复制&lt;/strong&gt;&lt;span&gt;导致的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;分布式锁的最大缺陷：在&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt; master实例宕机的时候，可能导致多个&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;同时完成加锁。&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
 
&lt;p&gt;&lt;span&gt;在面对&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;集群时需要选择一个节点进行缓存，普通的hash&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;是取模：hash(IP地址或文件名)%服务器数量，但这种方式在服务器数量变动的时候，所有缓存的位置都要发生改变。因此诞生了Hash一致性&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;，区别是&lt;/span&gt;&lt;strong&gt;对2^ 32-1取模&lt;/strong&gt;&lt;span&gt;，一致性Hash&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;将整个Hash值控件组织成一个&lt;/span&gt;&lt;strong&gt;虚拟的圆环&lt;/strong&gt;，将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。为解决数据倾斜问题还引入了虚拟节点机制，具有较好的容错性和可扩展性。&lt;/p&gt; 
&lt;h4&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;有序集合使用的跳表是什么？&lt;/span&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;有五种类型的对象：字符串、列表、哈希、集合、有序集合。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;中有序集合的底层采用跳表作为数据结构，有序&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;只能逐一查询，导致操作起来非常慢，跳表在此基础上增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;跳表的查找复杂度是O(logN)。&lt;/p&gt; 
&lt;h3 id=&quot;rabbitmq&quot;&gt;RabbitMQ&lt;/h3&gt; 
&lt;h4&gt;为什么选用RabbitMQ?&lt;/h4&gt; 
&lt;p&gt;1、基于AMQP协议2、高并发3、高性能4、高可用5、支持多语言&lt;/p&gt; 
&lt;h4&gt;Rabbit的相关概念及工作流程？&lt;/h4&gt; 
&lt;p&gt;一、工作流程&lt;/p&gt; 
&lt;p&gt;生产者和消费者收发消息都需要与RabbitMQ建立一条&lt;strong&gt;长连接&lt;/strong&gt;，所有的收发消息都在连接中&lt;strong&gt;开辟信道&lt;/strong&gt;进行收发，消息有&lt;strong&gt;消息头和消息体&lt;/strong&gt;，消息头是一些参数设置，消息体是真正的消息内容，最重要的一个消息头是&lt;strong&gt;路由键&lt;/strong&gt;，决定了消息要发给谁。消息首先来到&lt;strong&gt;消息代理&lt;/strong&gt;指定的&lt;strong&gt;虚拟主机&lt;/strong&gt;所指定的&lt;strong&gt;交换机&lt;/strong&gt;，交换机收到消息后根据消息的路由键通过交换机与其他队列的&lt;strong&gt;绑定关系&lt;/strong&gt;来决定将消息发给哪个队列，消费者会&lt;strong&gt;监听&lt;/strong&gt;这些队列并拿到消息。&lt;/p&gt; 
&lt;p&gt;二、交换机（Exchange）类型&lt;/p&gt; 
&lt;p&gt;direct、fanout（扇出）、topic、headers（几乎不用）&lt;/p&gt; 
&lt;p&gt;direct是点对点式、fanout和topic是发布订阅式&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;各种Exchange比较：&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt; 
 &lt;li&gt;direct实现路由键的精确匹配 &lt;/li&gt;
 &lt;li&gt;fanout采用广播的形式，不处理路由键，将消息发给所有绑定的队列 &lt;/li&gt;
 &lt;li&gt;topic实现路由键的模糊匹配，可以有通配符 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;三、RabbitMQ消息确认机制--可靠抵达&lt;/p&gt; 
&lt;p&gt;为保证消息不丢失，可靠抵达，可以使用事务消息，但性能下降250倍，为此引入确认机制&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片说明&quot; src=&quot;https://uploadfiles.nowcoder.com/images/20210513/77530848_1620872752805/01BFBDE806018EE3D9AF88C8E4B4112C&quot; title=&quot;图片标题&quot;/&gt; &lt;/p&gt; 
&lt;p&gt;发送端确认：&lt;/p&gt; 
&lt;p&gt;1、ConfirmCallback：消息只要被broker接收到就会执行ConfirmCallback&lt;/p&gt; 
&lt;p&gt;2、ReturnCallback：消息未能投递到目标queue里将调用ReturnCallback&lt;/p&gt; 
&lt;p&gt;消费端确认（保证每个消息被正确消费才可以在队列中删除）：&lt;/p&gt; 
&lt;p&gt;3、ack：分为自动（默认）和手动；&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;1）默认是自动确认的，只有消息接收到，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;会自动确认，服务端就会移除这个消息&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;问题：收到很多条消息，自动回复给服务器ack，但只有一个消息处理成功后就宕机了，发生消息丢失，因此要有手动模式&lt;/p&gt; 
&lt;p&gt;消费者手动确认模式：只要没有明确告诉MQ货物被签收（没有ack），消息就一直是unacked状态，即使consumer宕机，消息也不会丢失，会重新变为ready状态，待有新的consumer连接进来再发送&lt;/p&gt; 
&lt;p&gt;2）如何签收&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;basic.ack用于肯定确认，broker将移除此消息 &lt;/li&gt;
 &lt;li&gt;basic.nack用于否定确认，可以指定broker丢弃此消息或重新入队，可以批量 &lt;/li&gt;
 &lt;li&gt;basic.reject用于否定确认，同上，但不能批量 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h4&gt;死信队列是什么？作用？&lt;/h4&gt; 
&lt;p&gt;死信队列：DLX，Dead-Letter-Exchange，利用DLX，当消息在一个队列中变成死信（dead message，就是没有任何消费者消费）之后，他能被重新publish到另一个Exchange，这个Exchange就是DLX。&lt;/p&gt; 
&lt;p&gt;消息变为死信的几种情况：1）消息被拒绝同时不重回队列2）TTL过期3）队列达到最大长度&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;DLX也是一个正常的Exchange&lt;/strong&gt;，和一般的Exchange没有任何的区别，他能在任何的队列上被指定，实际上就是设置某个队列的属性。 当这个队列出现死信的时候，RabbitMQ就会自动将这条消息重新发布到Exchange上去，进而被路由到另一个队列，可以监听这个队列中的消息作相应的处理。&lt;/p&gt; 
&lt;h3&gt;用过RPC框架吗？&lt;/h3&gt; 
&lt;p&gt;用到了基于http的feign，SpringCloud对feign已经有了比较好的封装，还了解基于私有tcp协议的dubbo（阿里的）&lt;/p&gt; 
&lt;p&gt;如果不使用rpc框架，那么调用服务走http需要配置请求head、body，然后才能发起请求。获得响应体后，还需解析等操作，十分繁琐。Feign是一个http请求调用的轻量级框架，以Java接口注解的方式调用Http请求。Feign通过处理注解，将请求模板化，当实际调用的时候，传入参数，根据参数再应用到请求上，进而转化成真正的请求，封装了http调用流程。&lt;/p&gt; 
&lt;h3 id=&quot;docker&quot;&gt;docker&lt;/h3&gt; 
&lt;p&gt;一、docker是什么？&lt;/p&gt; 
&lt;p&gt;开源的应用容器引擎，让开发者打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何linux机器上，也可以实现虚拟化&lt;/p&gt; 
&lt;p&gt;关键：应用环境隔离；封装好的开发环境直接部署；集装箱思想&lt;/p&gt; 
&lt;p&gt;二、docker的进程隔离机制？&lt;/p&gt; 
&lt;p&gt;Linux &lt;strong&gt;Namespace&lt;/strong&gt; 是操作系统内核在不同进程间实现的一种「环境隔离机制」。&lt;/p&gt; 
&lt;p&gt;举例来说：现在有两个进程A，B。他们处于两个不同的 PID Namespace 下：ns1, ns2。在ns1下，A 进程的 PID 可以被设置为1，在 ns2 下，B 进程的 PID 也可以设置为1。但是它们两个并不会冲突，因为 Linux PID Namespace 对 PID 这个资源在进程 A，B 之间做了隔离。A 进程在 ns1下是不知道 B 进程在 ns2 下面的 PID 的。&lt;/p&gt; 
&lt;p&gt;Linux 一共构建了 6 种不同的 Namespace，用于不同场景下的隔离：&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;Namespace&lt;/th&gt; 
   &lt;th&gt;系统调用参数&lt;/th&gt; 
   &lt;th&gt;隔离内容&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt;
  &lt;tr&gt; 
   &lt;td&gt;UTS&lt;/td&gt; 
   &lt;td&gt;CLONE_NEWUTS&lt;/td&gt; 
   &lt;td&gt;主机名与域名&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;IPC&lt;/td&gt; 
   &lt;td&gt;CLONE_NEWIPC&lt;/td&gt; 
   &lt;td&gt;信号量、消息队列和共享内存&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;PID&lt;/td&gt; 
   &lt;td&gt;CLONE_NEWPID&lt;/td&gt; 
   &lt;td&gt;进程编号&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;Network&lt;/td&gt; 
   &lt;td&gt;CLONE_NEWNET&lt;/td&gt; 
   &lt;td&gt;网络设备、网络栈、端口等等&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;Mount&lt;/td&gt; 
   &lt;td&gt;CLONE_NEWNS&lt;/td&gt; 
   &lt;td&gt;挂载点（文件系统）&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;User&lt;/td&gt; 
   &lt;td&gt;CLONE_NEWUSER&lt;/td&gt; 
   &lt;td&gt;用户和用户组&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt;
&lt;/table&gt; 
&lt;p&gt;三、docker和虚拟机有什么区别？&lt;/p&gt; 
&lt;p&gt;docker是一种轻量级的虚拟机，比虚拟机更节省内存，启动更快。&lt;/p&gt; 
&lt;p&gt;Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，Docker可以节省大量的磁盘空间以及其他系统资源。&lt;/p&gt; 
&lt;p&gt;虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;Docker通常用于隔离不同的应用，例如&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%89%8D%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;前端&lt;/a&gt;，后端以及数据库。&lt;/span&gt;&lt;/p&gt; 
&lt;h3 id=&quot;git&quot;&gt;git&lt;/h3&gt; 
&lt;h4&gt;git产生冲突的情况及解决方法？&lt;/h4&gt; 
&lt;p&gt;一、产生冲突的情况&lt;/p&gt; 
&lt;p&gt;github上创建一个仓库，本地两个文件夹分别clone同一仓库，分别叫cangkuA、仓库B，在仓库A修改文件，提交到远端，在仓库B修改同一文件的同一行，同样保存修改后尝试提交到远端，会发生冲突。&lt;/p&gt; 
&lt;p&gt;二、解决方法（合并分支）&lt;/p&gt; 
&lt;p&gt;1、rebase：保留原分支上的每个commit&lt;/p&gt; 
&lt;p&gt;2、merge：只会生成一个commit&lt;/p&gt; 
&lt;h3 id=&quot;maven&quot;&gt;maven&lt;/h3&gt; 
&lt;h4&gt;maven的生命周期？&lt;/h4&gt; 
&lt;p&gt;&lt;span&gt;Maven的生命周期就是对所有的构建过程进行抽象和统一。包含了&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有的构建步骤。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;Maven的生命周期是抽象的，即生命周期不做任何实际的工作，实际任务由插件完成，类似于设计模式中的模板方法。&lt;/p&gt; 
&lt;p&gt;Maven有三套相互独立的生命周期，分别是clean、default和site。每个生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段。&lt;/p&gt; 
&lt;p&gt;1、&lt;strong&gt;Clean 生命周期&lt;/strong&gt;&lt;span&gt;：清理&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;，包含三个 phase ：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;pre-clean：执行清理前需要完成的工作。 &lt;/li&gt;
 &lt;li&gt;clean：清理上一次构建生成的文件。 &lt;/li&gt;
 &lt;li&gt;post-clean：执行清理后需要完成的工作 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;2、&lt;strong&gt;Default 生命周期&lt;/strong&gt;&lt;span&gt;：构建&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;，重要的 phase 如下：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;validate：验证工程是否正确，所有需要的资源是否可用。 &lt;/li&gt;
 &lt;li&gt;&lt;span&gt;compile：编译&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;的源代码。 &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。 &lt;/li&gt;
 &lt;li&gt;package：把已编译的代码打包成可发布的格式，比如 jar、war 等。 &lt;/li&gt;
 &lt;li&gt;integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。 &lt;/li&gt;
 &lt;li&gt;verify：运行所有检查，验证包是否有效且达到质量标准。 &lt;/li&gt;
 &lt;li&gt;install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用。 &lt;/li&gt;
 &lt;li&gt;deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;3、&lt;strong&gt;Site 生命周期&lt;/strong&gt;&lt;span&gt;：建立和发布&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;站点，phase 如下：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;pre-site：生成&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;站点之前需要完成的工作 &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;&lt;span&gt;site：生成&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;站点文档 &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;&lt;span&gt;post-site：生成&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;站点之后需要完成的工作 &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;&lt;span&gt;site-deploy：将&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;站点发布到服务器 &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt; 
&lt;h4&gt;maven的scope属性有哪些？&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;compile&lt;/strong&gt; &lt;strong&gt;（编译范围）&lt;/strong&gt;： compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath 中可用，同时它们也会被打包。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;provided&lt;/strong&gt; &lt;strong&gt;（已提供范围）&lt;/strong&gt;：类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;runtime&lt;/strong&gt; &lt;strong&gt;（运行时范围）&lt;/strong&gt;：只在运行时使用，如JDBC驱动，适用运行和测试阶段。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;test&lt;/strong&gt; &lt;strong&gt;（测试范围）&lt;/strong&gt;：test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。 &lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;system&lt;/strong&gt; &lt;strong&gt;（系统范围）&lt;/strong&gt;：（注意该范围是不推荐使用的）与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。 &lt;/li&gt;
&lt;/ul&gt; 
&lt;h2&gt;开放性问题&lt;/h2&gt; 
&lt;h3&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%BE%AE%E5%8D%9A&quot; target=&quot;_blank&quot;&gt;微博&lt;/a&gt;、朋友圈是怎么实现的？&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span&gt;这些产品都是Feed流类型产品，一般都是按照时间“从上往下流动”，Feed其实是一个信息单元，比如一条朋友圈状态、一条&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%BE%AE%E5%8D%9A&quot; target=&quot;_blank&quot;&gt;微博&lt;/a&gt;，只要关注某些发布者就能获取到源源不断的新鲜信息。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Feed流系统特点&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Feed流本质上是一个数据流，是将“N个发布者的信息单元”通过“关注关系”传送给“M个接收者”。&lt;/p&gt; 
&lt;p&gt;从数据层面看，数据分为三类，分别是：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;发布者的数据：&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%BE%AE%E5%8D%9A&quot; target=&quot;_blank&quot;&gt;微博&lt;/a&gt;的个人页面，朋友圈的个人相册 &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;&lt;span&gt;关注关系：&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%BE%AE%E5%8D%9A&quot; target=&quot;_blank&quot;&gt;微博&lt;/a&gt;中是关注，是单向流，朋友圈是好友，是双向流，但信息流动永远是单向 &lt;/span&gt;&lt;/li&gt;
 &lt;li&gt;接收者的数据：按某种顺序（一般是时间）组织在一起，越新的数据越要排在前面 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;设计Feed流系统时最核心的是确定清楚产品层面的定义，需要考虑的因素包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;产品用户规模：用户规模在十万、千万、十亿级时，设计难度和侧重点会不同 &lt;/li&gt;
 &lt;li&gt;关注关系（单向、双写）：如果是双向，那么就不会有大V，否则会有大V存在 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Feed流系统设计&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;1、产品定义：关注关系是单向还是双向，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;是时间还是推荐&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;2、存储：数据可靠不丢失，易于水平扩展，在数据规模很大时可以采用分布式的NoSQL（可靠性高于关系型数据库，数据天然分布在多台机器上）&lt;/p&gt; 
&lt;p&gt;3、同步：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;推模式（写扩散）：发送者发送了一个消息后立即将这个消息推送给接收者，但是接收者此时不一定在线，需要在同步库存储这个数据 &lt;/li&gt;
 &lt;li&gt;拉模式（读扩散）：发送者发送一条消息后将消息写入自己的发件箱，粉丝上i西安后再去自己关注着的发件箱里面去读取。 &lt;/li&gt;
 &lt;li&gt;推拉结合模式 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;4、元数据：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;用户详情和列表：分布式NoSQL或关系型数据库都可 &lt;/li&gt;
 &lt;li&gt;关注或好友关系：根据数据量来选择数据库类型 &lt;/li&gt;
 &lt;li&gt;推送session池：分布式NoSQL或关系型数据库都可 &lt;/li&gt;
&lt;/ul&gt; 
&lt;p&gt;5、评论、赞、搜索...&lt;/p&gt; 
&lt;h3&gt;电脑版微信登录的二维码包含什么信息？&lt;/h3&gt; 
&lt;p&gt;了解OAuth2.0原理，移动端微信已经登录，获得&lt;strong&gt;access_token&lt;/strong&gt;，&lt;/p&gt; 
&lt;p&gt;再与扫描的二维码中的字符串进行组合编码，发送给服务器，&lt;/p&gt; 
&lt;p&gt;服务器给浏览器网页的监听器发送消息，网页解析消息，并得到access_token，实现登录。&lt;/p&gt; 
&lt;p&gt;二维码只是充当一个掩码作用...&lt;/p&gt; 
&lt;h3&gt;如何计算两份代码的相似度？&lt;/h3&gt; 
&lt;p&gt;diff逐行/逐字比较&lt;/p&gt; 
&lt;h3&gt;重构代码时要考虑哪些方面？（面向对象角度）&lt;/h3&gt; 
&lt;p&gt;面向接口编程、单一职责：一个类只做一件事、高内聚低耦合&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>