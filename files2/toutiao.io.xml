<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>492648e91b5b0f73105be2abc7dbcc42</guid>
<title>2022 年升职加薪就靠它了！抓紧时间！</title>
<link>https://toutiao.io/k/fitvcz1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8e30f194680683ae32a6b2fa301a580a</guid>
<title>业务系统调研方法论</title>
<link>https://toutiao.io/k/i6ehcav</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;今早收到邀请写一篇业务系统调研方法论的文章，因为这个方法一直就在头脑中，一直在用。所以动笔直接写了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;业务系统调研，调研的内容有两个：&lt;/p&gt;&lt;p&gt;1、做成什么样&lt;/p&gt;&lt;p&gt;2、怎么做&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;把事情想清楚了，完成一份完整的调研报告，整个调研流程前后都需要做工作。所以完整的调研流程要分为5个步骤：&lt;/p&gt;&lt;p&gt;1、设立目标&lt;/p&gt;&lt;p&gt;2、梳理清楚现状&lt;/p&gt;&lt;p&gt;3、调研要做成什么样&lt;/p&gt;&lt;p&gt;4、调研怎么做&lt;/p&gt;&lt;p&gt;5、形成方案&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;设立目标和梳理清楚现状&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对业务系统的调研，需要在设立好目标和梳理清楚现状的前提下开展。几年前有次开会，评审一个技术方案。但是做方案的小伙做的调研：调研部分与实际需求相关度不高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;小伙是刚毕业的，觉得这个调研有难度，很难从业界找到相同问题的方案。但是领导给了一个中肯的建议：这个问题是个常规问题，如果没有找到相关度高的内容，那应该是你的搜索关键词不对。而关键词不对的根源就是没有梳理清楚要调研的问题及本质。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然，光梳理清楚目标和现状还不够。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;做成什么样&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一步：术语&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;术语是进入一个业务领域的有效抓手。我们举个例子来说明一下术语的价值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在我的认知当中，不管是组织架构、业务架构、技术架构。有一个原则就是先划分领域，清晰领域边界。各个领域之间的关系都是在领域层解决。而数据存储只是支撑。举个通俗点的例子：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlib4b8hIIMeFf4AKsDJWsLGGRoYX8sW0ic2lNQciaHYlNKHOlcKzuOJtQAibvfW0JhAn8UneCaibz8f98A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;一个好的设计好比一把凳子，领域是凳面，数据存储是凳子腿，它们之间靠领域联系在一起。数据存储是支撑，最好和其他部分解耦开。这种简约的风格易于维护和扩展。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是我们leader告诉我，数据存储自成体系。通过存储可以清楚掌握领域的全貌。就是说他心中的凳子大概是长这个样子：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlib4b8hIIMeFf4AKsDJWsLGG7MqKsFfh7gIn2tRibfq9P3oeyGegOpl1oTBOtLK7rbfLmyv6tfEkcsw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p&gt;我觉得这个观点的形成应该和领导工作时间长，从oracle数据库时代一路走来的历程有关。但是他心中的整个体系全貌我不清楚，我不清楚就没有发言权。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了走进他的世界，我围绕的是他口中的一个术语：三户模型。这是电信、银行、电商等领域常用的一个术语。三户是指用户、客户和账户。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;三户：&lt;/p&gt;&lt;p&gt;    用户：单个人&lt;/p&gt;&lt;p&gt;    客户：个人或集体就是服务的对象&lt;/p&gt;&lt;p&gt;    账户：客户使用服务的ID，一般指：护照，身份证或者其他账户&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;三户模型是根据营销模型转向“以客户为中心”理念而产生的结果，客户的需求成为支撑系统信息模型不断趋于完善的主要驱动力。与客户这个实体概念关联最为紧密的概念就是用户和帐户，这三者之间的关系应该是一个相互关联但又是独立的三个实体，这种关联只是一个归属和映射的关系，而三个实体本身是相互独立的，分别是体现完全不同的几个域的信息，客户是体现了社会域的信息，用户体现了业务域的信息，帐户体现的是资金域的信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三户模型是贯穿于整个业务运营支撑系统中的核心模型之一。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当我调研到上面红字的这句话，我突然明白：我们leader的整个上下文是围绕着运营和运维数据来展开的。数据有体系才能体系化运营。通过对这个术语的检查、学习和思考，我慢慢走进了另外一个领域。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二步：搜索&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;术语是入门，是确保搜索出自己想要信息的基础。有了这个基础，我们就可以看一个业务系统在业界是怎么做的。调研的首选是相关领域的头部机构，比如在电商领域，一般会调研亚马逊、阿里等的优秀实践。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是业务系统做成了什么样子和怎么做的，网上的资源非常有限。很多公司会特意派人去参加一些线下技术沙龙之类的。是不是想到了疫情前经常这个开发者大会、那个meeting up那些怀念的活动。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;不过大家不要对这种大会期望过高，也不要觉得参加了一天的沙龙感觉也没收获什么，是不是因为自己太菜。其实首先，从目的出发，这些上台演讲的专家都是带着目的来的，一般是品牌宣传或者做其他的推广。所以他们的重点是展示自己的实力，一般不会轻易吐露是怎么实现的。所以如果你恰好要做或者想过类似的产品，他们可以激发一些“做成什么样”的思路，不会给你怎么做的思路。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;怎么做&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面对怎么做提供两种调研方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;访谈法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;很多公司招聘人才是会从一些头部公司有比例的招人的。为什么嘞。因为这些聪明的公司要的不仅仅是这个人，还有这个人的人脉。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;公司的技术方案除了一些开源项目，其他不会对外公开。假设我们已经了解到了XX公司有一款产品做得不错，也很符合现在自身的需求，想了解怎么做的。怎么办呢？找找XX公司的同事打听打听，正式的说法叫做访谈。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不过大家也不要被我误导。访谈法有正规的访谈流程。&lt;span&gt;访谈法的一&lt;/span&gt;&lt;span&gt;般步骤是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;①设&lt;/span&gt;&lt;span&gt;计访谈&lt;/span&gt;&lt;span&gt;提纲。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②&lt;/span&gt;&lt;span&gt;.恰当进行提问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③准确捕捉信息，及时收集有关资料。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;④适当地作出回应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;⑤及时&lt;/span&gt;做&lt;span&gt;好访谈记录。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;登高类比法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486299&amp;amp;idx=1&amp;amp;sn=34ea00ad39901a51331bfd95dee0c641&amp;amp;chksm=fafde1f5cd8a68e31c7b8d5fa5b21fc70f5e49663f4cd6e6ea0a0639696556bc197b97ea241b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《应用程序怎样划分模块？》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;应用程序怎样划分模块？&lt;/span&gt;》&lt;/a&gt;和&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486507&amp;amp;idx=1&amp;amp;sn=2bd6916ba35babe2bd85da53800377a6&amp;amp;chksm=fafde685cd8a6f934c7cd38a8ee3fe010ed18f47e57ec658bb72ef423d4978f9c262b37c37dd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《Java无垃圾稳态设计》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;Java无垃圾&lt;/span&gt;&lt;span&gt;稳态设计&lt;/span&gt;&lt;span/&gt;》&lt;/a&gt;里都提到过登高类比法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;登高类比法是先检索最为相似的场景以得出结论。如果检索结果不够时再扩大范围直到足以得出结论。比如设计一个IP分配方法，检索时先检索IP分配，在网上比较权威的大概只有DHCP动态主机配置了。但是我们需要的不是动态，可以退而检索资源分配。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;完整的调研流程的最后一步是形成方案，也就是一个总结的过程。我去年很大一块工作就是在撰写一个公司级的调查研究报告。虽然写的不好，但是过程还是有很大收获的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好了，划重点：三户模型、访谈法、登高类比法。你学会了吗？&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0472d776aa394fbd8f16fce65f32eccb</guid>
<title>网易开源 Envoy 企业级自定义扩展框架 Hango Rider 简介</title>
<link>https://toutiao.io/k/4nqamzr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.30362116991643456&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/06ULcDvaIGnaRwT6XuR8ZWiaQWo1vZjGcFrQWsfQ8By4gOTZ7yyIlO5uymPjbdRtv8wx19icw0g3JVAMabibCE7gA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1077&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;王凯，网易数帆高级工程师，主要负责轻舟微服务、轻舟 API 网关等相关产品数据面研发、扩展增强等工作。&lt;/span&gt;&lt;span&gt;对于数据面 Envoy 扩展增强、实践落地具备丰富的经验。&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;可扩展性是网络代理软件最为关键的特性之一，灵活强大的可扩展性可以大大拓展网络代理软件的能力边界。作为新兴的开源高性能网络代理软件，Envoy 本身提供了相对丰富的可扩展能力，如基于 C++ 的原生扩展，基于 WASM/Lua 的动态扩展。但是 Envoy 现有可扩展能力都各自存在其局限性。在大规模落地实践 Envoy 网关 / 网格过程中，网易数帆为 Envoy 实现了一套基于 Lua 的企业级自定义扩展框架 - Rider，应用于轻舟微服务平台，满足业务方所需要的易开发、高性能、功能丰富等各项要求。目前，&lt;span&gt;Rider&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt; 扩展框架已经全面开源，并且被集成于开源 API 网关 &lt;span&gt;Hango&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt; 当中，为 Hango 网关提供了灵活、强大、易用的自定义扩展能力。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4025423728813559&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGk36pVxfEcN1uD5szEdTPlicOds1mFiaegRHtUxoj2ZwOdN9rlq9vFb6S5MJxxKT1aWsLzY7o9GYnKA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;708&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;1. Envoy 的可扩展性现状&lt;/h2&gt;&lt;p&gt;在互联网体系下，凡是需要对外暴露的系统几乎都需要网络代理：较早出现的 HAProxy、Nginx 至今仍在流行；进入微服务时代后，功能更丰富、管控能力更强的 API 网关又成为流量入口必备组件。Envoy 因为其优异的性能、可扩展性、可观察性等优势，成为大量 API 网关的数据面选型，并且除了流量代理所需的基本功能外，Envoy 原生已经实现了很多代理所需高级功能，如高级负载均衡、熔断、限流等。因此，基于 Envoy 构建的 API 网关本身已经具备较为丰富的功能，能满足大部分应用代理的需求。但是在 API 网关的实际使用场景中，某些应用或者业务会根据自己的需求扩展出新的功能，可能是对 HTTP 的某些 Header 做些简单的处理，也可能是对接自己的 APM 等，因此 API 网关必须具备可扩展的能力以支撑应用或者业务根据自己的需求扩展相应的功能，而这个能力 Envoy 依然可以胜任，可以说基于 Envoy 实现的 API 网关的可扩展性强依赖于 Envoy 提供的可扩展能力。那么接下来我们就看一下目前 Envoy 提供的扩展机制。&lt;/p&gt;&lt;h3&gt;1.1 原生 C++ 扩展&lt;/h3&gt;&lt;p&gt;Envoy 通过可插拔的过滤器机制实现了原生 C++ 插件扩展的能力，如下图所示，L4 过滤器负责扩展协议代理能力及 L4 流量治理能力，L7 过滤器实现对流量的丰富治理功能。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35800344234079173&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGk36pVxfEcN1uD5szEdTPlicf8m5kr92q0iawOoqDU8B9ppnXicTRL6TtW50pDo6iaCnVP9mzFQDTSsEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1162&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这种扩展方式由于是 Envoy 原生提供的能力，因此性能自然是最佳的，但同时面临两个主要的问题，一个是插件开发者需要具有 C++ 语言的开发能力，另外是插件开发完后需要重新编译 Envoy 二进制文件再升级部署，无法做到插件功能的动态加载。为了解决这两个问题，Envoy 社区陆续实现了基于 Lua 和 WASM 的扩展机制，我们先看社区 Lua 扩展的原理。&lt;/p&gt;&lt;h3&gt;1.2 社区 Lua 扩展&lt;/h3&gt;&lt;p&gt;要想使用 Lua 语言开发原本使用 C++ 语言实现的 Envoy 插件，直观来看需要考虑以下两点：一个是 Lua 脚本如何在 Envoy 进程中执行；另一个是 Lua 脚本如何获得 Envoy 的内部数据和功能，比如 Header、Body 的获取。从这两个角度出发可以比较清晰的看一下 Envoy 社区 Lua 扩展的实现（其实 WASM 和 Rider 也是从这两个角度出发）。&lt;/p&gt;&lt;p&gt;如下图，和上面介绍的原生 C++ 扩展方案不同的是在 Envoy 的七层插件中多了个 Lua 插件，而这个用 C++ 开发的 Lua 插件就是回答上面两个问题的关键。首先 Lua 脚本如何在 Envoy 进程中执行，答案是通过 Lua 插件，Envoy 的 Lua 插件本身依然是用 C++ 开发的，因此可以在 Lua 插件中加载并运行 Lua 脚本；其次是 Lua 脚本如何获得 Envoy 的内部数据和功能，答案是 Lua 插件会通过 Lua CAPI 的形式提供 Envoy 内部数据和功能给 Lua 脚本。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32323232323232326&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGk36pVxfEcN1uD5szEdTPlicCkSClUWZYcWN4fAfmALfacN68Q4Df5GicTicOln39kg88hJHeJIpBvSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1188&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;社区 Lua 扩展一方面提供给了用户基于 Lua 语言开发插件的能力，相比 C++ 要简单很多，另一方面支持 Envoy 动态加载 Lua 脚本，无需重新编译升级。但同时由于 C++ 和 Lua 虚拟机交互带来的开销，Lua 扩展的性能自然会比原生 C++ 扩展差，而且 Envoy 社区当前的 Lua CAPI 交互方式会进一步加剧性能问题。除了性能问题，社区的 Lua 扩展还有个更大的缺陷 —— 不支持插件配置，直接导致社区 Lua 扩展的实用性大大下降。相比之下，WASM 和 Rider 实现了插件的可配置化， 并且 Rider 针对 Lua 扩展的性能做了一定的优化，使得 Rider 的 Lua 扩展在性能和功能方面都能满足企业级扩展的需求。&lt;/p&gt;&lt;h3&gt;1.3 社区 WASM 扩展&lt;/h3&gt;&lt;p&gt;WASM 是源自前端的技术，是为了解决日益复杂的前端 Web 应用以及有限的 JS 脚本解释性能而诞生的技术。WASM 并不是一种语言，而是字节码标准。理论上任何一种语言，都可以被编译成 WASM 字节码，然后在 WASM 虚拟机中执行。&lt;/p&gt;&lt;p&gt;WASM 扩展的实现原理和 Lua 扩展本质上差不多，在 Envoy 自身的四层或者七层插件中会实现一个 WASM 插件，该插件会嵌入 WASM 虚拟机用于动态加载和运行可拔插的扩展代码（被编译为 WASM 字节码），并且也会通过 WASM 虚拟机暴露获取 Envoy 内部数据和功能的接口。其原理如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29549248747913187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGk36pVxfEcN1uD5szEdTPlicwyzBDQesb0niblicnMl0AyiaoGHkiaRsM0iceicumHlOADDRtuQU544FuXuQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3594&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;WASM 看上去似乎完美解决了 Envoy 可扩展性遇到的各种问题，它支持多语言，支持插件动态加载，同时支持插件配置，但是经过我们的测试，WASM 倒在了性能的血泊中，它基于 C++ 扩展的插件性能甚至都要比 Lua 扩展差，更不用说基于其他语言实现的插件（具体的性能对比结果会在第三部分）。&lt;/p&gt;&lt;h3&gt;1.4 总结&lt;/h3&gt;&lt;p&gt;如下表，我们总结了当前各种扩展性方案的特性：原生 C++ 扩展虽然性能最优，但是不支持插件的动态加载；社区 Lua 扩展支持了插件的动态加载，但是却不支持插件配置，几乎不可使用；社区 WASM 扩展既支持插件的动态加载，又支持插件配置，但是性能很差。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.27148703956343795&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/06ULcDvaIGk36pVxfEcN1uD5szEdTPlicb59fv1cvkLO3iblEuicKibicjOvjFMgeO9SvS6ZAh9PsmOjHL1Tic4BmPdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1466&quot;/&gt;&lt;/p&gt;&lt;p&gt;根据上述各种扩展性方案的优劣势，网易轻舟微服务设计并实现了自己的可扩展框架 Rider ，主要的设计目标如下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 支持 Lua 语言扩展&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 支持 Envoy 动态加载、更新、移除 Lua 插件&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 支持定义 Lua 插件配置&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 支持自定义 Lua 插件生效范围，网关级 / 项目级 / 路由级&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 性能优于 Envoy 社区 Lua 扩展和 WASM 扩展&lt;/span&gt;&lt;/p&gt;&lt;p&gt;接下来具体看一下 Rider 可扩展框架的设计、优化及实践。&lt;/p&gt;&lt;h2&gt;2. Rider 可扩展框架的设计、优化及实践&lt;/h2&gt;&lt;h3&gt;2.1 早期探索&lt;/h3&gt;&lt;p&gt;针对社区 Lua 扩展存在的性能差、不支持插件配置的问题， Rider 早期架构设计并实现了两个模块：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Rider Filter：Rider Filter 是 Envoy 的七层插件，用于初始化和调用 Lua 代码，并且将 Envoy 内部的数据和功能通过 Lua CAPI 或 FFI 接口的形式提供给 Lua SDK 调用。注意这里 Rider 利用 FFI 实现了大部分接口， 理论上性能优于基于 CAPI 实现的社区 Lua 扩展；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Lua SDK：Lua SDK 是一个 Lua 插件代码框架，用户可以通过调用 Lua SDK 提供的 API 实现请求处理。注意 Lua SDK 提供了获取全局以及路由级插件配置的 API，使得 Rider 的 Lua 扩展支持插件配置的获取，解决了社区 Lua 扩展的大难题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;下图是整体的架构图：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7855029585798816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGk36pVxfEcN1uD5szEdTPlic2FUC2HLBRJCQRj4zrfMHe2pGn9w8l6GvNP6WV3GI5vkWiaeVNkdAL7A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1352&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;尽管我们的早期架构基本满足了 Envoy 可扩展性的需求：支持多语言 Lua、支持 Lua 插件动态加载、支持 Lua 插件配置等。但是仍然存在以下几个问题：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Rider Filter 仍然存在部分接口没有使用 FFI ，性能可能略有不足；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Lua SDK 需要进一步完善以支持更多的插件功能开发；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 在解决第一个问题过程中发现的 Rider 巨大性能问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;针对这几个问题，我们进一步细化了 Rider 的架构，详细分析了 Rider 的性能，并衍生出了新的架构。&lt;/p&gt;&lt;h3&gt;2.2 实践优化&lt;/h3&gt;&lt;p&gt;Rider 新架构要解决的第一个问题就是试图将 FFI 进行到底，根据之前的调研，Lua 调用 C 有两种方式，一种是通过原生的 CAPI，每次调用时都会分配一个栈空间 (和 Stack Frame 不同，是向 Heap 申请的一块连续内存)，通过栈空间传递参数和返回值。另一种方式是通过 Luajit 提供的 FFI 调用。FFI 的好处是，可以直接在 Lua 中调用 C 函数，使用 C 数据结构，代码可以获得 Jit 优化的 Buff，性能较原生的 Lua 有比较大的提升。因此，我们想把 Rider 中使用 CAPI 实现的接口改造成 FFI。&lt;/p&gt;&lt;p&gt;改造的第一步便遇到了问题，早期的 Rider 架构貌似无法使用 FFI 实现 Envoy Body 相关接口的暴露，我们先看一下早期 Rider 不得不使用原生的 CAPI 暴露 Envoy Body 相关接口的原因。早期 Rider 的架构图中 Lua Code 有两个主要的函数：on_request 和 on_response，这两个函数是 Rider 架构规定的 Lua 代码中需要实现的函数，因为 Rider Filter 在执行 Lua Code 时，Rider Filter 只会尝试从 Lua 虚拟机中获取这两个函数，然后分别在 decodeHeaders 阶段和 encodeHeaders 阶段执行，那么如果在 on_request 或者 on_response 函数中有 Body 相关的接口调用，此时 Rider Filter 还没执行到 decodeData 或者 encodeData 阶段，Body 的数据还获取不到，只能将 Lua 协程先挂起，等到 Rider Filter 执行到 decodeData 或者 encodeData 阶段时再 Resume，而这种方式 FFI 实现不了，只能通过和 Lua 虚拟机交互的方式实现。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8962655601659751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGk36pVxfEcN1uD5szEdTPlicvJLNb6JkWZvVHrnK7zokX6ILXVR1zWblmdlf4ulicmzPv2ia4QLR5BmQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1205&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;基于上述问题，Rider 新架构在早期架构基础上进行了一些细化，如上图所示，整体架构的模块没有改变，改变的是 Rider 框架规定的 Lua 插件中需要实现的函数以及这些函数在 Rider Filter 中的执行时机。如上图所示，将原来 on_request 和 on_response 函数进一步拆分成 Header 和 Body 的阶段函数，并且在 Rider Filter 处理 Header 和 Body 阶段分别去调用，这样可以避免 Body 的处理需要挂起 Lua 协程（后来发现 WASM 的实现也是类似的细分）。因此新架构的请求处理流程如下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Rider 插件配置 (其中包含 Lua 插件配置) 作为 LDS 和 RDS 的一部分，通过 Pilot 下发；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Envoy 对每个 HTTP 请求构造一条七层 Filter Chain, 其中包含 Rider Filter。Rider Filter 初始化时，会将 Lua SDK 模块和相应的插件从文件系统加载到 Lua VM 中；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 在请求处理阶段，Rider Filter 会在 Decode 和 Encode 阶段分别调用 Lua 代码的 on_request_header、on_request_body 和 on_response_header、on_response_body 方法；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 在用户 Lua 代码执行过程中，通过 Lua SDK 调用 Rider Filter 封装的相应接口，如获取，修改请求、响应信息，调用外部服务等，打印日志等。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;2.2.1 性能优化&lt;/h4&gt;&lt;p&gt;新架构设计的初衷是性能的提升，因此我们在新架构开发完第一时间便进行了性能测试，测试场景：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 环境：本地容器环境&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 后端：Nginx 4 核&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Envoy：4 核&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Client：Wrk 4t 32c&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Lua 插件：调用 100 次 get_body 接口&lt;/span&gt;&lt;/p&gt;&lt;p&gt;对比实现方式：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;CAPI：Rider 的 CAPI 实现，原始的 Lua 和 C 的交互方式，通过栈空间传递参数和返回值；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;FFIOld：Rider 的早期 FFI 实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;测试结果如下图，经典负优化，而且负的很多（当然也是因为调用了 100 次的原因），FFIOld 相比 CAPI QPS 下降了 30%。第一想法是不是代码写的有问题，新架构引入了很多开销？所以又测试了一下 Rider 之前基于 FFIOld 实现的 Header API，性能和基于 FFIOld 实现的 Body API 差不多，那说明 FFIOld 出问题了，早期的 Rider FFI 实现的 API 可能性能都还不如 CAPI ！&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5617283950617284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGk36pVxfEcN1uD5szEdTPlicQlzjzlsT31ofUImw741BFkITMQIcUdVjlCz7kgiaLOiaUHQaiaf2JGtdw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1458&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;于是去了解了一下 FFI 的基本原理，FFI 是 Luajit 提供的特性，Luajit 是运行 Lua 的虚拟机，和 Java 虚拟机一样，Luajit 有两种运行模式：编译模式和解释模式（编译模式的性能比解释模式好，原因感兴趣可自行查找）。Luajit 默认运行在解释模式下，在运行过程中会记录可以编译的热点代码，在之后的运行中会尝试把热点代码直接翻译成机器码执行，性能会得到提升。&lt;/p&gt;&lt;p&gt;回到 Rider 中来，Rider 的 Lua 插件也是运行在 Luajit 虚拟机中，并且几万的 QPS 请求一定会使 Lua 插件代码成为热点代码，那么 Luajit 会尝试把 Lua 插件翻译成机器码，同时 FFI 定义的 C 函数也会被翻译成机器码被执行，这么看起来性能确实会提升，但实际不符合预期，原因在于 Luajit 会 &lt;strong&gt;尝试&lt;/strong&gt; 把热点代码翻译成机器码，尝试就可能不成功，不成功就会退化成解释模式，那么性能会大打折扣。Luajit 提供了确认程序是否运行在编译模式下的方法，在 Lua 代码的前面加上如下代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;local&lt;/span&gt;&lt;span&gt; verbo &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;require&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;jit.v&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;verbo&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;然后继续压测，发现 Luajit 输出如下内容：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17168949771689498&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGk36pVxfEcN1uD5szEdTPlic4PE8lboT75jwT3C0MBk8ic0hXmaJIsYpgS1do8Ns3MIdAcPXFibyALag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1095&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这张图可以看出两个关键信息，一个是如果 TRACE 输出 — ，那么说明 Luajit 退出了编译模式；另一个是退出编译模式的原因是 FFI 定义的 C 函数中的某个形参类型转换不支持。接着往下定位到这个参数：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;local&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; get_header_map_value&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;local&lt;/span&gt;&lt;span&gt; ctx &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; get_context_handle&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt; ctx &lt;/span&gt;&lt;span&gt;then&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        error&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;no context&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;~=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;string&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;then&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        error&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;header name must be a string&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;local&lt;/span&gt;&lt;span&gt; buffer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; ffi_new&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;envoy_lua_ffi_str_t[1]&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;local&lt;/span&gt;&lt;span&gt; rc &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; C&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;envoy_http_lua_ffi_get_header_map_value&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ctx&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; source&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;#key, buffer)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; rc &lt;/span&gt;&lt;span&gt;~=&lt;/span&gt;&lt;span&gt; FFI_OK &lt;/span&gt;&lt;span&gt;then&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ffi_str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;buffer&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; buffer&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;C.envoy_http_lua_ffi_get_header_map_value (ctx, source, key, #key, buffer) 中传入的 ctx 是 Lua 的 light userdata 类型，而 envoy_http_lua_ffi_get_header_map_value 函数声明的时候是某个类的指针类型，Luajit 在翻译的时候无法完成转换因此退出了编译模式。真相大白，接下来就是解决这个问题，具体的设计过于细节不在这里阐述，感兴趣可以移步我们的开源社区。接下来看一下优化后的效果。&lt;/p&gt;&lt;p&gt;首先还是接着上面的 get_body 性能测试，多加了一组 FFINew（优化后的 FFI 实现方式）的数据，如下图所示，FFINew 的性能比 FFIOld 的性能提升了 &lt;strong&gt;66%&lt;/strong&gt; ，相比 CAPI 的性能提升了 &lt;strong&gt;16%&lt;/strong&gt; ，FFI 的优势总算体现了出来。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5619438740588638&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGk36pVxfEcN1uD5szEdTPlicoAVpPxc7TEY22B7bqTUP0r4aSgJ08UalUpsFrYwmoK2Xaw4qibMSpVQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1461&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上面的性能提升可能只能作为参考，毕竟是调用了 100 次 get_body 接口，因此我们针对不同复杂度的插件分别进行了简单的性能测试：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;simple filter：调用 10 次 get_header；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;normal filter：调用 20 次 set_header，调用 10 次 get_header，最后再 remove 掉这 20 个 header；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;complex filter：normal filter + 调用 30 次 get_body；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;结果如下图所示，FFINew 的性能都优于 FFIOld 的性能，分别有 15% ， 22% ， 29% 的性能提升。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5589849108367627&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGk36pVxfEcN1uD5szEdTPlicN4jzoSyg67fWMSKzZorOTgdibyVI4frNhnshQSZve8KGDwPEiaZm4Giaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1458&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后我们进一步将 Rider 和社区 WASM 和 Lua 的性能进行了对比：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;RiderOld：Rider 早期架构的实现；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;RiderNew：当前 Rider 的实现；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;WASMC++：社区 1.17 版本的 WASM 实现；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;RawLua：社区 1.17 版本的 Lua 扩展实现；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;RawC++：Envoy 原生 C++ 扩展实现；&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5602739726027397&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGk36pVxfEcN1uD5szEdTPlictdYpsnEDttLtDFpr5UzleUuZkmfQTiaibPJxPgJfRugVEIcQrwzmicgSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1460&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如上图所示，Rider 的性能优于社区的 WASM 和 Lua，大概有 10% 左右的性能提升，且相比于 Envoy 原生 C++ 插件性能也只有 10% 左右的下降。这里 WASM 的插件是用 C++ SDK 实现的，而根据我们的内部测试，WASM 其他语言 SDK 实现的插件性能会更差。另外，Rider 性能只比社区 Lua 提升了不到 10%，个人感觉是因为性能测试的插件在 Lua 和 C++ 之间的数据交互比较简单，基本都是简单字符串的传递，体现不出 FFI 的优势。&lt;/p&gt;&lt;h4&gt;2.2.2 功能增强&lt;/h4&gt;&lt;p&gt;性能问题解决后，接下来就是功能的增强，也就是 Lua SDK 的丰富，这里总结了当前 Rider 支持的所有 Lua SDK ：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.req.get_header(name)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.req.get_header_size(name)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.req.get_header_index(name, index)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.req.get_headers()&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.req.get_body()&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.req.get_metadata(key, filter_name)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.req.get_dynamic_metadata(key, filter_name)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.req.get_query_parameters(max_args)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.req.set_header(name, value)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.req.set_headers(headers)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.req.clear_header(name)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.resp.get_header(name)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.resp.get_header_size(name)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.resp.get_header_index(name, index)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.resp.get_headers()&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.resp.get_body()&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.resp.set_header(name, value)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.resp.set_headers(headers)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.resp.clear_header(name)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.streaminfo.start_time()&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.streaminfo.current_time_milliseconds()&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.streaminfo.downstream_local_address()&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.streaminfo.downstream_remote_address()&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.streaminfo.upstream_cluster()&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.streaminfo.upstream_host()&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.logTrace(message)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.logDebug(message)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.logInfo(message)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.logWarn(message)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.logErr(message)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.filelog(msg)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.get_base_config()&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.get_route_config()&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.httpCall(cluster, headers, body, timeout)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;envoy.respond(headers, body)&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;2.3 Rider 的实践&lt;/h3&gt;&lt;p&gt;网易内部传媒业务已基于 Rider 开发并上线使用多个 Lua 插件，其中用于打印全链路追踪日志的 Trace 插件 2020 Q1 上线，目前已接入全部网关，处理数十万 QPS，运行稳定。&lt;/p&gt;&lt;h2&gt;3. Rider 可扩展框架的未来规划&lt;/h2&gt;&lt;p&gt;未来我们会在稳定性、性能、功能等方面持续进行 Rider 的维护和优化：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 稳定性：目前 Rider 已经在网易内外部多个业务方大规模落地，后续我们也会进一步提升并保障 Rider 稳定性；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 性能：尽管 Rider 的性能已经优于社区 Lua 和 WASM ，但后续我们会持续进行性能优化，进一步缩小和原生 C++ 扩展的性能差距；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; 功能：在 Rider API 方面和社区 Lua 以及 WASM 对齐，提供最全面的 API 能力。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;更多&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Hango Rider 项目地址：https://github.com/hango-io/rider&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Hango 网关项目地址：https://github.com/hango-io/hango-gateway&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; Rider: &lt;em&gt;https://github.com/hango-io/rider&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; Hango: &lt;em&gt;https://github.com/hango-io/hango-gateway&lt;/em&gt;&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934837&quot; data-style-type=&quot;&quot;&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section data-id=&quot;90196&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934821&quot; data-style-type=&quot;&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-xmtstyleindex=&quot;0&quot; data-xmt-x1=&quot;381.5&quot; data-xmt-y1=&quot;4647.640625&quot; data-xmt-x2=&quot;1058.5&quot; data-xmt-y2=&quot;5940.220625&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-style=&quot;margin-top: -10px; padding-right: 10px; padding-left: 10px; font-size: 16px; color: black; line-height: 1.6; letter-spacing: 0px; word-break: break-word; overflow-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif;&quot; data-xmt-x1=&quot;381.5&quot; data-xmt-y1=&quot;4647.640625&quot; data-xmt-x2=&quot;1038.5&quot; data-xmt-y2=&quot;5940.220625&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); font-family: 微软雅黑; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-role=&quot;paragraph&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94252&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot;&gt;&lt;h4&gt;关于云原生社区&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934837&quot; data-style-type=&quot;&quot;&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section data-id=&quot;90196&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934837&quot; data-style-type=&quot;&quot;&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section data-id=&quot;90196&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;云原生社区是国内最大的独立第三方云原生终端用户和泛开发者社区，由 CNCF 大使、开源意见领袖共同发起成立于 2020 年 5 月 12 日，提供云原生专业资讯，促进云原生产业发展。云原生社区基于成员兴趣创建了多个 SIG（特别兴趣小组），如 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649382008&amp;amp;idx=2&amp;amp;sn=8329de15872f67151e76e4dc2ece84eb&amp;amp;chksm=f224d617c5535f015e3d71a3d21c234bc333653792c85646c13b2a260a4ac2381e06fc0bf8f4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kubernetes&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Kubernetes&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384221&amp;amp;idx=2&amp;amp;sn=04c5062a448e9696e9296a02e82837c3&amp;amp;chksm=f224ef72c553666444b33121ae42dbf4e7609574c29e4c55b84f9f6e2cb5bae88a037f2248d2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Istio&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384308&amp;amp;idx=2&amp;amp;sn=6188dfb44c7a7313a252879a0044b406&amp;amp;chksm=f224ef1bc553660df3b77ff63bd969a4aec56fc5a64a5cf202fb56a507fa0b13588f56384b4e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Envoy&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384308&amp;amp;idx=3&amp;amp;sn=c144874967206a7d0abe0b66e36cc03f&amp;amp;chksm=f224ef1bc553660d9f32e206c5a9e1424a60f49ced76b3d5925d0bffa09eacbe14b1da8b512a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Dapr&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384269&amp;amp;idx=2&amp;amp;sn=baaa3c95835c663c7141406b8ac1293b&amp;amp;chksm=f224ef22c553663436fcbeab26d97abe166f82b8880fc5531d2157ab89b760457ba8664a1d39&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;OAM&lt;/a&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384175&amp;amp;idx=1&amp;amp;sn=ea9058418afd668967e28a3ba211d649&amp;amp;chksm=f224ee80c5536796af57f48c8ee7e242a2b1478645ce823d711be263587576362744eac8121d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;边缘计算&lt;/a&gt;&lt;span&gt;、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384137&amp;amp;idx=1&amp;amp;sn=d14055b1b5408a30db96d8e132a046ab&amp;amp;chksm=f224eea6c55367b0058a971ea579e9b1f7cb70e3d39eb4f36b64f9cab924a2b4c3fc845681f2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;机器学习&lt;/a&gt;&lt;span&gt;、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649383872&amp;amp;idx=1&amp;amp;sn=b6a3c43ce750ea923fed04592c5b7cfd&amp;amp;chksm=f224e9afc55360b912fd2e0d1a9ab4cc66a22deb81db8f07bc3a83146f370cb388ae53c44ef6&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;可观察性&lt;/a&gt;&lt;span&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384467&amp;amp;idx=3&amp;amp;sn=9a8fe5c24d9458d0113c59604b6ab5e8&amp;amp;chksm=f224ec7cc553656aa33f3304608cc24423d3aca7f0d64ae9e50da2850ce5c4df0d4ff9cc013f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;稳定性&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;稳定性&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649385565&amp;amp;idx=2&amp;amp;sn=e3a6a1adf84c3ac9e552ba0c2b18d162&amp;amp;chksm=f224e032c5536924c330945872154b83245b19f91c401e21eddd882791c64b914d68fd51a93e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;安全&lt;/a&gt;等&lt;/span&gt;&lt;span&gt;。&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649383149&amp;amp;idx=3&amp;amp;sn=6012d51c80d0b8f84db58e514448ad11&amp;amp;chksm=f224ea82c553639460af375bb1f172ba94502c5599eb2a4e4df52287f98db29e3858ae09373d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点击了解我们&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;点击了解我们&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI1NTE2NDE2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/06ULcDvaIGmqt5TicIcR8qFEjicfezMe4YuBlNbN8vl8Mh1fePHOrPibvlqJseGaG4ctibamAhKHMP3xOEW3ByibOjw/0?wx_fmt=png&quot; data-nickname=&quot;Cloud Native Community&quot; data-alias=&quot;CloudNativeCN&quot; data-signature=&quot;云原生社区是国内最大的独立第三方云原生终端用户和泛开发者社区，由 CNCF 大使、开源意见领袖共同发起成立于 2020 年 5 月 12 日，提供云原生专业资讯，促进云原生产业发展。社区官网 https://cloudnative.to&quot; data-from=&quot;1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;点击下方“阅读原文”查看更多&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1379b0963d5ab0413fdeba9349141b04</guid>
<title>使用 Kafka、Debezium 和 Kubernetes 实现应用现代化的模式</title>
<link>https://toutiao.io/k/ks1h7if</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfO440HzsVd3JBibXgx5N5M9jlZSfd2YXicBibB1golhFbap8Xmafica3N1s6F6EDdhMPvdSA8f4aibrfwA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/section&gt;&lt;section&gt;作者｜Bilgin Ibryam&lt;br/&gt;&lt;/section&gt;&lt;section&gt;
译者｜张卫滨&lt;/section&gt;&lt;section&gt;
策划｜辛晓亮&lt;/section&gt;&lt;p&gt;本文最初发表于 RedHat 的开发者站点，经原作者 Bilgin Ibryam 许可，由 InfoQ 中文站翻译分享。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;55&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;“我们建造计算机的方式与建造城市的方式是一样的，那就是随着时间的推移，依然毫无计划，并且要建造在废墟之上。”&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;Ellen Ullman 在 1998 年写下了这样一句话，但它今天依然适用于我们构建现代应用程序的方式，那就是，随着时间的推移，我们要在遗留的软件上构建应用，而且仅仅有短期的计划。在本文中，我将介绍一些模式和工具，我相信它们对于遗留应用的现代化以及构建现代事件驱动的系统非常有效。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;1&lt;/span&gt; 应用现代化概述&lt;/section&gt;&lt;p&gt;应用现代化（Application modernization）指的是对现有遗留应用的基础设施（内部架构）进行现代化的过程，以提高新特性的交付速度、改善性能和可扩展性以及为新的使用场景提供功能等等。对应用程序的现代化和迁移类型已经有了很好的分类，如图 1 所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6432748538011696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfO440HzsVd3JBibXgx5N5M9jTYptH2ReMp2LHgVjniat7yllQnFMjfic2vbpgfzISv1CBWAvvpe9IHMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;684&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 1：三种现代化类型以及可能用到的技术&lt;/span&gt;&lt;/p&gt;&lt;p&gt;根据你的需求以及对变化的渴望程度，有以下几个等级的现代化：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;保持原状（Retention）：我们可以做的最简单的事情是保留所拥有的东西，忽略应用程序的现代化需求。如果需求还不是很迫切的话，这么做是有道理的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;完全退出（Retirement）：我们可以做的另一件事是退出并彻底摆脱遗留的应用程序。如果发现该应用程序不再被使用的话，这么做是有可能的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重新托管（Rehosting）：我们可以做的下一种方案是重新托管应用程序，这通常意味着会将一个应用程序按原样托管在新的基础设施上，如云基础设施，甚至可以通过像 KubeVirt 这样的工具将应用托管在 Kubernetes 上。如果应用程序不能被容器化，但你仍然想重新使用 Kubernetes 的技能、最佳实践和基础设施来管理作为容器的虚拟机，这也不失为一种可选方案。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重新平台化（Replatforming）：如果改变基础设施不足以解决问题，而且你要在不改变架构的情况下对应用程序的边缘做一些改变时，重新平台化是一种可选方案。也许你正在改变应用程序的配置方式，以便将其容器化，或者从传统的 Java EE 运行时转移到一个开源运行时。在这种情况下，你可以使用像 windup 这样的工具来分析你的应用程序，并得出一份报告，该报告会说明需要做的事情。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重构（Refactoring）：今天，许多应用程序进行现代化的重点是将单体的、企业内部的应用迁移到支持更快速发布周期的云原生微服务架构。这涉及到重构和重新架构你的应用程序，这也是本文的重点。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在本文中，我们会假设正在处理一个单体的、内部部署的应用程序，这是进行应用现代化的一个常见起点。这里讨论的方法也可以适用于其他场景，如云迁移计划。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
迁移单体遗留应用的挑战&lt;/section&gt;&lt;p&gt;对于迁移单体的遗留程序来讲，部署频率是一个常见的挑战。另外一个挑战就是扩大开发规模，让更多的开发人员和团队能够在一个通用的代码库上工作，并且不会相互影响。还有一个问题就是以可靠的方式扩展应用以处理不断增加的负载。另一方面，对应用进行现代化的预期收益包括缩短上市时间、增加团队对代码库的自主权，以及动态扩展以便更有效地处理服务负载。这些收益中的每一项都能够弥补我们进行应用现代化所付出的成本。图 2 展示了为增加负载而扩展遗留应用基础设施的样例。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41237113402061853&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfO440HzsVd3JBibXgx5N5M9jTajqDpeIM01ScMrlogf0jQGjwu5njcU0DPFqa4adgvRtWZxoNo5g0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1552&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 2：将遗留应用重构为事件驱动的微服务&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
展望目标状态并衡量何为成功&lt;/section&gt;&lt;p&gt;对于我们的场景来说，目标状态是一种遵循微服务原则的架构风格，它会使用一些开源的技术，比如 Kubernetes、Apache Kafka 和 Debezium。我们希望最终能够形成围绕业务领域建模的可独立部署的服务。每个服务应该有自己的数据，发布自己的事件等等。&lt;/p&gt;&lt;p&gt;在规划应用现代化的时候，很重要的一件事就是考虑如何衡量我们努力产生的输出和结果。为此，我们可以使用一些指标，比如变更的准备时间、部署频率、恢复时间、并发用户等。&lt;/p&gt;&lt;p&gt;在接下来的章节中，我们将会介绍三种设计模式以及三项开源技术，即 Kubernetes、Apache Kafka 和 Debezium，我们可以使用它们将现有的系统迁移成全新的、现代化的、事件驱动的服务。我们首先从 Strangler 模式开始介绍。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;2&lt;/span&gt; Strangler 模式&lt;/section&gt;&lt;p&gt;在应用程序迁移方面，Strangler 是最流行的技术。Martin Fowler 以 Strangler Fig Application 的名称介绍并普及了这种模式，它的灵感来自于一种无花果（fig），这种植物能够在一棵树的上部枝条上播种，并逐渐围绕原来的树生长，最终将原来的树取而代之。与应用迁移同时要做的事情是，我们的新服务最初被设置为包裹现有系统。通过这种方式，新旧系统可以共存，从而给新系统以成长的时间，并试图逐渐取代旧的系统。图 3 展示了遗留应用程序迁移时 Strangler 模式的主要组件。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7592267135325131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfO440HzsVd3JBibXgx5N5M9jMNqarxxs8ZAb4OQMgl2lfPcpib0K9PTniamyNhDJFBTHGlccnU3NbH7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1138&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 3：遗留应用程序迁移中的 Strangler 模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Strangler 模式的主要好处在于，它允许我们以低风险、渐进式的方式从遗留系统迁移到新系统。接下来，我们看看这个模式所涉及的主要步骤。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
第一步：识别功能边界&lt;/section&gt;&lt;p&gt;第一个问题是从哪里开始进行迁移。在这方面，我们可以使用领域驱动设计帮助我们识别聚合和限界上下文，它们分别代表了一个潜在的分解单元和潜在的微服务边界。或者，我们也可以使用 Antonio Brandolini 创建的事件风暴（event storming）技术来获取对领域模型的共同理解。在这里，其他需要考虑的重要事项是这些模型如何与数据库进行交互，以及数据库分解都需要哪些工作。一旦我们有了这些因素的清单，下一步就是识别限界上下文之间的关系和依赖，以了解提取它们的相对难度。&lt;/p&gt;&lt;p&gt;掌握了这些信息之后，我们就可以着手处理下一个问题了：我们是想从依赖最少的服务开始，以便轻松看到效果，还是应该从系统中最困难的部分开始？一个好的折衷办法是挑选一个有代表性的服务，它可以帮助我们建立良好的技术基础。然后，这个基础可以作为估算和迁移其他模块的基准。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
第二步：迁移功能&lt;/section&gt;&lt;p&gt;为了使 Strangler 模式发挥作用，我们必须能够清晰地将入站调用映射到我们想要迁移的功能。我们还必须能够将这些调用重定向到新的服务，并在需要时将其返回。根据遗留应用的状态、客户端应用和其他限制因素，权衡这种拦截的可选方案有时候很简单直接，有时候则很难：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;最简单的方案就是修改客户端应用，将入站调用重定向到新的服务上。完工！&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果遗留应用程序使用 HTTP 的话，那我们就有了一个良好的开端。HTTP 对重定向非常有利，我们有大量的透明代理方案可供选择。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在实践中，我们的应用程序很可能不仅使用 REST API，还会有 SOAP、FTP、RPC 或某种传统的消息端点。在这种情况下，我们可能需要使用像 Apache Camel 这样的技术建立一个自定义的协议转换层。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;使用拦截的方式可能是一个危险的倾向：如果我们开始着手构建一个由多个服务共享的自定义协议转换层，那么就有可能为服务所依赖的共享代理添加太多的智能化。这会与“智能微服务，哑管道”的口号背道而驰。更好的方案是使用 Sidecar 模式，如图 4 所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48753462603878117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfO440HzsVd3JBibXgx5N5M9jEMV3kUyXAeHK8nKwwHP3OQraTCvSmJyyf7hxwSABa4fN27zyLjZjtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1444&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 4：Sidecar 模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;相对于将自定义代理逻辑放到共享层里，不如将其作为新服务的一部分。但是，我们不会在编译期将自定义代理嵌入到服务中，而是使用 Kubernetes sidecar 模式，使代理成为一个运行时的绑定活动。借助这种模式，遗留客户端使用协议转换的代理，而新的客户端则会使用新的服务 API。在代理内部，调用会被进行转换，并被转移到新的服务上。这样的话，在需要时，我们可以重用代理。更重要的是，当遗留客户端不再需要代理时，我们可以很容易地将其拆除，而对新服务的影响做到了最小。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
第三步：迁移数据库&lt;/section&gt;&lt;p&gt;我们确定了功能边界和拦截方法之后，就需要确定如何处理数据库的 Strangler 问题，也就是将我们的遗留数据库与应用服务分离开来。在这方面，我们有多个解决路径可供选择。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
数据库优先&lt;/section&gt;&lt;p&gt;在数据库优先的方式中，我们会首先分离模式，这可能会影响到遗留的应用程序。比如，一个 SELECT 可能需要从两个数据库中获取数据，并且一个 UPDATE 可能会导致需要分布式事务。这种方案需要对源应用程序进行修改，并且无法帮助我们在短期内展示迁移的进展。因此，这并不是我们要寻找的方案。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
代码优先&lt;/section&gt;&lt;p&gt;代码优先的方法可以让我们快速实现独立部署的服务，并且能够重用遗留的数据库，但它可能会在迁移进度方面给我们带来错误的印象。分离数据库可能会变成一种挑战，并隐藏未来可能出现的性能瓶颈。但这是一个正确的方向，可以帮助我们发现数据的所有者，以及后续分离数据库所需的工作内容。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
代码和数据库并行&lt;/section&gt;&lt;p&gt;代码和数据库并行的方式在一开始可能会比较困难，但这是我们最终想要达到的状态。无论我们采取什么方式，最终我们都希望有一个独立的服务和数据库，从这个方式出发，可以帮助我们避免后期的重构。&lt;/p&gt;&lt;p&gt;拥有一个独立的数据库需要进行数据的同步。和往常一样，在这方面我们可以从几种常见的技术方法中选择。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
触发器&lt;/section&gt;&lt;p&gt;大多数的数据库都允许我们在数据发生变化的时候执行自定义的行为。在有些情况下，甚至可以调用一个 web 服务并与另外的系统进行集成。但是，在不同的数据库之间，触发器的实现方式以及我们能用它们实现哪些功能都是不同的。这种方式还有一个严重的缺点，那就是使用触发器需要改变遗留的数据库，我们可能并不想这么做。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
查询&lt;/section&gt;&lt;p&gt;我们可以使用查询来定期检查源数据库的变化。这些变化通常是通过不同的实现策略检测出来的，比如源数据库中的时间戳、版本号，或者状态列变化。无论使用哪种实现策略，轮询总是会导致两难的困境，要么频繁轮询，这会在源数据库上产生开销，要么就会错过频繁进行的更新。虽然查询的初始安装和使用都很简单，但这种方法有很大的局限性。它不适合于有频繁数据库交互的任务关键型应用。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
日志读取器&lt;/section&gt;&lt;p&gt;日志读取器通过扫描数据库的事务日志文件来识别变化。日志文件的存在是为了数据库的备份和恢复，并提供了一种可靠的方式来捕获所有的变化，包括 DELETE 操作。使用日志读取器是破坏性最小的方案，因为它们不需要对源数据库进行修改，也没有查询负载。这种方法的主要缺点是，事务日志文件没有通用的标准，我们需要专门的工具来处理它们。这就是 Debezium 的用武之地。&lt;/p&gt;&lt;p&gt;在进入下一步之前，我们先看看使用 Debezium 与日志读取器的方式是如何运作的。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
使用 Debezium 进行变更数据捕获&lt;/section&gt;&lt;p&gt;当一个应用程序将数据写入到数据库时，变更会被记录在日志文件中，然后数据库的表才会被更新。对于 MySQL 来说，日志文件是 binlog；对于 PostgreSQL 来说，是 write-ahead-log；而对于 MongoDB 来说，是 op 日志。好消息是 Debezium 有针对不同数据库的连接器，所以它为我们完成了理解所有这些日志文件格式的艰巨工作。Debezium 可以读取日志文件，并产生一个通用的抽象事件到消息系统中，如 Apache Kafka，其中会包含数据的变化。图 5 显示了 Debezium 连接器是如何作为各种数据库的接口的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46934865900383144&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfO440HzsVd3JBibXgx5N5M9jpuqqn3icQxURQM2821JB1plCzAHIicfHX55t5SVq9otjmMnkW5icR6cxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 5：微服务架构中的 Debezium 连接器&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Debezium 是使用最广泛的开源变更数据捕获（change data capture，CDC）项目，其多种连接器和特性使它非常适合 Strangler 模式。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
为什么说 Debezium 很适用于 Strangler 模式？&lt;/section&gt;&lt;p&gt;考虑用 Strangler 模式来迁移单体遗留应用程序的最重要的原因之一就是减少风险以及能够回退到遗留应用程序之上。同样，Debezium 对遗留应用是完全透明的，它不需要对遗留的数据模型做任何改变。图 6 显示了 Debezium 在一个微服务架构中的示例。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5242214532871973&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfO440HzsVd3JBibXgx5N5M9jc43T0bvffz4qodiavLEcKekibibttE3L8yRdNL44cBIsHNQwUID3EpCKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1156&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 6：在混合云环境中部署 Debezium&lt;/span&gt;&lt;/p&gt;&lt;p&gt;通过对遗留数据库的一个最小化配置，我们就可以捕获所有需要的数据。因此，在任何时候，我们都可以移除 Debezium，并在需要时回退到传统的应用程序。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
支持遗留应用迁移的 Debezium 特性&lt;/section&gt;&lt;p&gt;如下是 Debezium 支持用 Strangler 模式迁移单体遗留应用程序的一些具体功能：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;快照&lt;/strong&gt;：Debezium 能够对源数据库当前的状态进行快照，我们可以使用这个功能进行批量数据的导入。快照生成之后，Debezium 将会以流的方式传输变化，以保证目标系统处于同步状态。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;过滤器&lt;/strong&gt;：Debezium 能够让我们选择为哪些数据库、表和列的数据传输变化。有了 Strangler 模式，我们并不需要转换整个应用程序。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;单一消息转换&lt;/strong&gt;（Single message transformation，SMT）：这个特性就像一个防腐层，能够保护我们的新数据模型不受遗留命名、数据格式的影响，甚至能够让我们过滤掉过时的数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;组合使用 Debezium 和模式注册表&lt;/strong&gt;：我们可以组合使用像 Apicurio 这样的模式注册表和 Debezium 来进行模式验证，并且在源数据库模型发生变化时能够使用它来执行版本兼容性检查。这可以防止源数据库的变化影响和破坏新的下游消息消费者。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;组合使用 Apache Kafka 和 Debezium&lt;/strong&gt;：有很多证据可以表明，在进行应用程序的迁移和现代化的过程中，Debezium 和 Apache Kafka 能够很好地进行协作。有很多具体的例子可以证明组合使用这些工具是很好的选择，比如保证数据库变化的顺序、消息压缩、根据需要多次重读变更的能力以及跟踪事务日志的偏移量。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt;
第四步：发布服务&lt;/section&gt;&lt;p&gt;结合对 Debezium 的快速描述，我们看一下在 Strangler 模式下的使用情况。假设，到目前为止，我们已经完成了如下的工作：&lt;/p&gt;&lt;section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;确定了功能边界。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;迁移了功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;迁移了数据库。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将服务部署到了 Kubernetes 环境中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用 Debezium 迁移数据，并保持 Debezium 一直运行以同步正在进行的变化。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;此时，还没有任何流量被路由到新服务上，但发布新服务的准备已经做好了。根据我们路由层的能力，我们可以使用诸如暗发布（dark launching）、并行运行和金丝雀发布等技术来减少或消除推出新服务的风险，如图 7 所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9254237288135593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfO440HzsVd3JBibXgx5N5M9jvpEeiciaIRE7QuAI1wOMQDuyFbDbOiaicdK4n0mibWibrSJ1T9IAXQrW6t9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 7：将读取流量引导到新的服务上&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们在这里还可以做的是，最初只把读取请求引导到新服务上，而继续把写入请求发送到遗留系统上。这样做是必要的，因为我们只会在单一方向上复制变化。&lt;/p&gt;&lt;p&gt;当我们看到读取操作没有问题时，就可以把写入流量也引导到新服务上。此时，如果我们由于某种原因仍然需要遗留应用运行的话，那么我们需要把新服务中的变化以流的方式同步到遗留应用的数据库中。接下来，我们要停止遗留模块中的任何数据写入或变更活动，并停止从它那里进行数据复制。图 8 说明了模式实现中的这一部分过程。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8921568627450981&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfO440HzsVd3JBibXgx5N5M9j0ewc7ibHJxCquTp4dtQdUvAR5a6yhd28wec809rTj0Vxhjv4vZVz0NA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 8：将读取和写入的流量引导到新服务上&lt;/span&gt;&lt;/p&gt;&lt;p&gt;由于我们仍然有遗留应用的读取操作，所以还要继续从新服务到遗留应用的复制过程。最终，我们将停止遗留模块中的所有操作，并停止数据复制。此时，我们就能够拆除被迁移的模块了。&lt;/p&gt;&lt;p&gt;我们已经大致了解了如何使用 Strangler 模式来迁移一个单体的遗留应用，但我们还没有彻底完成对基于微服务的新架构的现代化。接下来，我们考虑一下现代化过程中随后所面临的一些挑战，以及 Debezium、Apache Kafka 和 Kubernetes 如何帮助我们。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;3&lt;/span&gt; 迁移之后：应用现代化的挑战&lt;/section&gt;&lt;p&gt;考虑采用 Strangler 模式进行迁移的最重要原因是降低风险。这种模式可以稳定地提供价值，并允许我们通过频繁的发布来展示进展。但是，如果仅仅是迁移，没有任何功能增强或新的“商业价值”，是很难说服一些利益相关者的。在长期的现代化过程中，我们还希望能够增强现有的服务并增加新的服务。在进行应用现代化的最初设想中，我们通常也会有一项任务就是为构建后续的现代应用奠定基础和最佳实践。通过迁移越来越多的服务并增加新的服务，以及总体上向微服务架构过渡，新的挑战将会出现，包括：&lt;/p&gt;&lt;p&gt;这些挑战在传统的应用中可能并不存在。接下来，我们讨论一下，如何组合使用设计模式和技术来解决其中的一些问题。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
挑战一：运维大规模的事件驱动服务&lt;/section&gt;&lt;p&gt;我们会从传统的单体应用中剥离出越来越多的服务，同时为了满足新出现的业务需求会不断创建新的服务，此时对自动部署、回滚、应用放置、配置管理、升级、自我修复的需求会变得越来越明显。正是这些特性使得 Kubernetes 变成了运维大规模微服务的绝佳选择。图 9 说明了这一点。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5742793791574279&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfO440HzsVd3JBibXgx5N5M9jG6CzKmA4kEChU7VRjv5jIYNC4QwibXXTKa1OFSkJd8xEGwncvahEhPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 9：在 Kubernetes 之上的事件驱动架构的示例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在处理事件驱动的服务时，我们很快会发现需要自动化，并且要与事件驱动的基础设施集成，这就是 Apache Kafka 及其生态系统中其他项目的用武之地了。此外，我们可以使用 Kubernetes Operator 来帮助自动化管理 Kafka 和以下的支撑服务。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Apicurio Registry 提供了一个用于管理 Kubernetes 上的 Apicurio Schema Registry 的 Operator。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Strimzi 提供了用于在 Kubernetes 上声明式地管理 Kafka 和 Kafka Connect 集群的 Operator。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;KEDA（Kubernetes Event-Driven Autoscaling）提供了工作负载自动扩展器，用于扩展和收缩消费 Kafka 的服务。因此，如果消费者的延迟超过一个阈值，Operator 将启动更多的消费者，直至达到分区的数量，以赶上消息生产的速度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Knative Eventing 提供了由 Apache Kafka 作为支撑的事件驱动的抽象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注意：Kubernetes 不仅为应用程序的现代化提供了一个目标平台，而且还允许我们在同一基础上将应用程序发展成一个大规模的事件驱动架构。它通过用户工作负载、Kafka 工作负载的自动化以及 Kafka 生态系统的其他工具来做到这一点。也就是说，不是所有东西都必须在你的 Kubernetes 上运行。例如，我们可以使用 Red Hat 完全托管的 Apache Kafka 或模式注册服务，并使用 Kubernetes Operator 将其自动绑定到应用程序上。在 Red Hat OpenShift Streams for Apache Kafka 上创建一个多可用区（multi-AZ）的 Kafka 集群，只需不到一分钟，而且在试用期内完全免费。欢迎读者进行尝试，您的反馈将有助于我们将它变得更好。&lt;/p&gt;&lt;p&gt;现在，让我们看一下如何利用设计模式来应对另外两个应用程序现代化的挑战。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
挑战二：避免双重写入&lt;/section&gt;&lt;p&gt;我们一旦创建了多个微服务，很快就会意识到，最难的部分是数据。作为其业务逻辑的一部分，微服务经常要更新其本地的数据存储。同时，它们还需要通知其他服务所发生的变化。这个挑战在单体应用和传统分布式事务的领域中并不明显。我们如何才能以云原生的方式避免或解决这种问题呢？答案是只修改两个资源中的一个（数据库），然后以最终一致的方式驱动第二个资源的更新，比如 Apache Kafka。图 10 说明了这种方法。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.903448275862069&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfO440HzsVd3JBibXgx5N5M9j7PsFL5xM56icibo9F17DFLQ4F9pick4TjicpNchaVrvqLy2JTK4sctFDibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;870&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 10：Outbox 模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;使用 Debezium 实现的 Outbox 模式可以让服务以安全和一致的方式执行这两项任务。在更新数据库时，服务不会直接向 Kafka 发送消息，而是使用一个事务来执行正常的更新，并将消息插入到其数据库中一个特定的 outbox 表中。一旦事务被写入数据库的事务日志中，Debezium 就可以从那里获取 outbox 消息并将其发送到 Apache Kafka 中。这种方法给了我们非常好的属性。通过在单个事务中同步写入数据库，该服务能够受益于“读取自己写入”的语义，即对该服务的后续查询将返回新的持久化记录。同时，通过 Apache Kafka，我们能够以可靠、异步的方式传播给其他服务。Outbox 模式是一种成熟的方法，用于避免可扩展的事件驱动的微服务所面临的双重写入问题。它非常优雅地解决了服务间通信的难题，而不需要所有参与者都同时可用，包括 Kafka。我相信 Outbox 将成为设计可扩展事件驱动的微服务的基础模式之一。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
挑战三：长时间运行的事务&lt;/section&gt;&lt;p&gt;虽然 Outbox 模式解决了较简单的服务间通信问题，但它并不足以单独解决更复杂的长期运行的分布式业务事务的场景。后者需要跨多个微服务执行多个操作，并且要具备一致的全有或全无的语义。阐述这一需求的一个常见的例子就是预订旅行行程的场景，它由多个部分组成，其中航班和住宿必须要一起预订。在传统的应用程序中，或者在单体架构下，你可能不会注意到这个问题，因为模块之间的协调是在一个进程和一个事务性上下文中完成的。分布式领域需要一种不同的方法，如图 11 所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6783333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfO440HzsVd3JBibXgx5N5M9jJ5wLWp0sjV9FkF5RP57BzNotsmg0DXFNYIRalJ73NicjwQ4QepehymQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 11：用 Debezium 实现的 Saga 模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Saga 模式为该问题提供了一个解决方案，它将一个总体的业务事务分割成了一系列的多个本地数据库事务，分别由参与的服务来执行。一般来说，有两种方法来实现分布式 Saga：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;协同式（choreography）&lt;/strong&gt;：在这种方式下，参与其中的某个服务会在执行完自己的本地事务后，发送消息给下一个服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;编排式（orchestration）&lt;/strong&gt;：在这种方式中，会有一个中央协调服务负责协调并调用参与其中的服务。参与服务之间的通信可能是同步的，比如通过 HTTP 或 gRPC，也可能是异步的，比如通过像 Apache Kafka 这样的消息系统。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注：请参见 InfoQ 的译文“&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247517375&amp;amp;idx=2&amp;amp;sn=a0ccb953c6253d1d929ad2e965e68fa6&amp;amp;chksm=e8d47b7ddfa3f26bf692b292c6a7dc038b3002a1e8df0fb85b31429452e83ae2f0de543392e7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;微服务下分布式事务模式的详细对比&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;微服务下分布式事务模式的详细对比&lt;/a&gt;”。&lt;/p&gt;&lt;p&gt;这里最酷的是，我们可以使用 Debezium、Apache Kafka 和 Outbox 模式实现 Saga。有了这些工具，就可以利用编排式的方法，在一个地方管理 Saga 的流程，并检查 Saga 事务的总体状态。我们还可以将编排与异步通信相结合，将协调服务与参与服务的可用性，甚至与 Kafka 的可用性解耦。这给了我们两全其美的结果：编排式以及参与服务之间异步、非阻塞、并行的通信，没有时间上的耦合。&lt;/p&gt;&lt;p&gt;将 Outbox 模式与 Saga 模式结合起来，对于分布式服务领域中长时间运行的业务事务来说，是一个非常棒的、以事件为驱动的实施方案。详细描述请参见“如何使用发件箱模式实现微服务的 Saga 编排”（InfoQ）。同时可以在 GitHub 上看到这个模式的实现样例。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;4&lt;/span&gt; 结论&lt;/section&gt;&lt;p&gt;Strangler 模式、Outbox 模式和 Saga 模式可以帮助我们从遗留系统中迁移出来，同时它们也可以帮助我们建立全新的、现代的、事件驱动的服务，这些服务是面向未来的。&lt;/p&gt;&lt;p&gt;Kubernetes、Apache Kafka 和 Debezium 是开源项目，已经变成了各自领域中的事实标准。你可以用它们来创建标准化的解决方案，它们都有丰富的生态系统，包括支撑工具和最佳实践。&lt;/p&gt;&lt;p&gt;从这篇文章以及我在 2021 年 Red Hat 峰会上的演讲中得到的一个启发是，我意识到现代软件系统就像城市一样。它们随着时间的推移，会在遗留系统的基础上不断发展。使用成熟的模式、标准化的工具和开放的生态系统将帮助我们创建持久的系统，并且能够随着你的需求而成长和变化。&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://developers.redhat.com/articles/2021/06/14/application-modernization-patterns-apache-kafka-debezium-and-kubernetes&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt;
今日文章推荐：&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247519374&amp;amp;idx=1&amp;amp;sn=75ea4605df692e8de6ff03ea48cae8a9&amp;amp;chksm=e8d4734cdfa3fa5a58e162bba8c36b6208d5d9792dafdf5ab57485ac0caa94f526a7de2af924&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;重磅！CNCF 2021 年度调查报告出炉&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;重磅！CNCF 2021 年度调查报告出炉&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247519311&amp;amp;idx=1&amp;amp;sn=0dbe1ce8d1e135ff7089ca9fb70440a1&amp;amp;chksm=e8d4738ddfa3fa9bd0c9c399a4a0d3842e658e692b5cac99f8fb60fecabd89883a6f05f1bd5e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;60 年屹立不倒，COBOL 或将借助云重焕生机&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;60 年屹立不倒，COBOL 或将借助云重焕生机&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247519214&amp;amp;idx=1&amp;amp;sn=23c35d87d6e98294ccca440bbac15e09&amp;amp;chksm=e8d4742cdfa3fd3aee097bc000daefe8fcba3a54adbbc19d7f09b1b995d59f1150a74f73ac3e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;亚马逊工程师：我在职业生涯中学到的 8 个重要经验&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;亚马逊工程师：我在职业生涯中学到的 8 个重要经验&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247519187&amp;amp;idx=1&amp;amp;sn=6a2e72d992ee991c88a4aae51f2f4001&amp;amp;chksm=e8d47411dfa3fd07ca080c10f3606737b4e21816dc38b8bb88f8417b71714e7359229c0c471f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;GitHub 良心操作：推出仅供赞助者使用的存储库&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;GitHub 良心操作：推出仅供赞助者使用的存储库&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247519136&amp;amp;idx=1&amp;amp;sn=1f44b6c9907812e9ed196f4f21dc3662&amp;amp;chksm=e8d47462dfa3fd74a956d0b5ccfbb9454b97126e46461d1808bb3cff331677ca8a9678e143ec&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;大佬手把手带你复刻 Netflix&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;大佬手把手带你复刻 Netflix&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f5c8b08183245886a488a908256d7976</guid>
<title>Rust重头实现迷你Go语言</title>
<link>https://toutiao.io/k/xa9w1ne</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content&quot; class=&quot;content&quot;&gt;
                    &lt;main&gt;
                        
&lt;p&gt;在前一节我们通过最小编译器将一个整数编译为可以返回相同状态码的程序。现在我们尝试将加法和减法的表达式编译为同样的程序。&lt;/p&gt;
&lt;p&gt;比如有 &lt;code&gt;1+3-2&lt;/code&gt; 表达式，手工编写对应的LLVM汇编程序如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ll&quot;&gt;define i32 @main() {
; 1 + 3 - 2
%t0 = add i32 0, 1   ; t0 = 1
%t1 = add i32 %t0, 3 ; t1 = t0 + 3
%t2 = sub i32 %t1, 2 ; t2 = t1 - 2
ret i32 %t2
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果将输入的&lt;code&gt;1+3-2&lt;/code&gt;转化为&lt;code&gt;vec![&quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;-&quot;, &quot;2&quot;]&lt;/code&gt; 形式，我们则可以通过以下代码输出对应的汇编程序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust noplayground&quot;&gt;fn gen_asm(tokens: &amp;amp;[&amp;amp;str]) -&amp;gt; String {
    let mut result = String::new();

    result.push_str(&quot;define i32 @main() {\n&quot;);

    let mut idx = 0;
    for (i, tok) in tokens.iter().enumerate() {
        if i == 0 {
            result.push_str(&amp;amp;format!(&quot;\t%t{} = add i32 0, {}\n&quot;, idx, tok));
            continue;
        }
        match tok {
            &amp;amp;&quot;+&quot; =&amp;gt; {
                idx = idx + 1;
                result.push_str(&amp;amp;format!(
                    &quot;\t%t{} = add i32 %t{}, {}\n&quot;,
                    idx,
                    idx - 1,
                    tokens[i + 1]
                ));
            }
            &amp;amp;&quot;-&quot; =&amp;gt; {
                idx = idx + 1;
                result.push_str(&amp;amp;format!(
                    &quot;\t%t{} = sub i32 %t{}, {}\n&quot;,
                    idx,
                    idx - 1,
                    tokens[i + 1]
                ));
            }
            _ =&amp;gt; {}
        }
    }

    result.push_str(&amp;amp;format!(&quot;\tret i32 %t{}\n&quot;, idx));
    result.push_str(&quot;}\n&quot;);

    result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而如何将输入的字符串拆分为记号数组本质上属于词法分析的问题。我们先以最简单的方式实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust noplayground&quot;&gt;fn parse_tokens(code: &amp;amp;str) -&amp;gt; Vec&amp;lt;&amp;amp;str&amp;gt; {
    let mut tokens = Vec::new();
    let mut pos = 0;

    loop {
        if let Some(i) = code[pos..].find(&#x27;+&#x27;) {
            tokens.push(&amp;amp;code[pos..][..i]);
            tokens.push(&amp;amp;code[pos..][i..][..1]);
            pos = pos + i + 1;
            continue;
        }
        if let Some(i) = code[pos..].find(&#x27;-&#x27;) {
            tokens.push(&amp;amp;code[pos..][..i]);
            tokens.push(&amp;amp;code[pos..][i..][..1]);
            pos = pos + i + 1;
            continue;
        }

        tokens.push(&amp;amp;code[pos..]);
        return tokens;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基本思路是通过遍历输入字符串，然后根据 &lt;code&gt;+-&lt;/code&gt; 符号拆分，最终返回拆分后的词法列表。&lt;/p&gt;
&lt;p&gt;然后对上个版本的compile函数稍加改造以支持加法和减法的运算表达式编译：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust noplayground&quot;&gt;fn compile(code: &amp;amp;str) {
    let tokens = parse_tokens(code);
    let output = gen_asm(&amp;amp;tokens);

    std::fs::write(&quot;a.out.ll&quot;, output).unwrap();

    std::process::Command::new(&quot;clang&quot;)
        .arg(&quot;-Wno-override-module&quot;)
        .arg(&quot;-o&quot;)
        .arg(&quot;a.out&quot;)
        .arg(&quot;a.out.ll&quot;)
        .output()
        .unwrap();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了便于测试，我们再包装一个run函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust noplayground&quot;&gt;fn run(code: &amp;amp;str) -&amp;gt; i32 {
    compile(code);

    let status = std::process::Command::new(&quot;./a.out&quot;).status().unwrap();

    match status.code() {
        Some(code) =&amp;gt; code,
        None =&amp;gt; -1,
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;run函数将输入的表达式程序编译并运行、最后返回状态码。然后构造单元测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust noplayground&quot;&gt;#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn run_works() {
        assert_eq!(run(&quot;1&quot;), 1);
        assert_eq!(run(&quot;1+1&quot;), 2);
        assert_eq!(run(&quot;1 + 3 - 2&quot;), 2);
        assert_eq!(run(&quot;1+2+3+4&quot;), 10);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行&lt;code&gt;cargo test&lt;/code&gt;测试命令。确认单元测试没有问题后，更新main函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust noplayground&quot;&gt;fn main() {
    let mut buffer = String::new();
    std::io::stdin().read_line(&amp;amp;mut buffer).unwrap();

    println!(&quot;{}&quot;, run(buffer.as_ref()));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过以下命令执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo &quot;1+2+3&quot; | cargo run
6
&lt;/code&gt;&lt;/pre&gt;

                    &lt;/main&gt;

                    &lt;nav class=&quot;nav-wrapper&quot; aria-label=&quot;Page navigation&quot;&gt;
                        
                            &lt;a rel=&quot;prev&quot; href=&quot;../ch2-expr/index.html&quot; class=&quot;mobile-nav-chapters previous&quot; title=&quot;Previous chapter&quot; aria-label=&quot;Previous chapter&quot; aria-keyshortcuts=&quot;Left&quot;&gt;
                                &lt;i class=&quot;fa fa-angle-left&quot;/&gt;
                            &lt;/a&gt;
                            &lt;a rel=&quot;next&quot; href=&quot;../ch2-expr/ch2-02-mul-div.html&quot; class=&quot;mobile-nav-chapters next&quot; title=&quot;Next chapter&quot; aria-label=&quot;Next chapter&quot; aria-keyshortcuts=&quot;Right&quot;&gt;
                                &lt;i class=&quot;fa fa-angle-right&quot;/&gt;
                            &lt;/a&gt;
                        &lt;p/&gt;
                    &lt;/nav&gt;
                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>