<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>824247ed34815f4c3681a0bb985c9cad</guid>
<title>项目中怎样做技术选型？</title>
<link>https://toutiao.io/k/ftrvm6v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引出四个维度&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;工作快十五年了，从十年前开始经常会有新项目，需要从头开始做方案和设计。做技术选型很少成为我的难题。不是因为这方面我多有方法，而通常是很少有选择。在做技术选型的场景下基本有以下四个维度：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;维度一&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;从系统构成上有两种：&lt;/p&gt;&lt;p&gt;第一种，有之前的老系统，需要重构&lt;/p&gt;&lt;p&gt;第二种，从零开始建的服务&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;维度二&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从稳定性要求上有三种：&lt;/p&gt;&lt;p&gt;第一种，现在没有什么业务量，将来估计也不会有什么增长，甚至很可能不成&lt;/p&gt;&lt;p&gt;第二种，现在没有什么业务量，将来对稳定性要求很高&lt;/p&gt;&lt;p&gt;第三种，现在对有稳定性要求很高&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;维度三&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从环境上有三种：&lt;/p&gt;&lt;p&gt;第一种，公司有很多基础设施&lt;/p&gt;&lt;p&gt;第二种，公司有一些基础设施&lt;/p&gt;&lt;p&gt;第三种，公司基本没有基础设施&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;维度四&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从要求上有两种：&lt;/p&gt;&lt;p&gt;第一种，公司有标准化规范，需要用公司的统一组件&lt;/p&gt;&lt;p&gt;第二种，公司没有要求&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;各个维度组合的选项考虑&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;从零开始项目现在没有什么业务量，将来估计也不会有什么增长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;从目标上，遇到这种项目，工作的重心就不在于把项目做好做坏，而在于人员培养。&lt;/p&gt;&lt;p&gt;如果公司对组件上没有什么要求，那我的建议是大家想学什么，就用什么。直接拿学习的试验田来用，一举两得。&lt;/p&gt;&lt;p&gt;如果公司有标准化规范，需要用公司的统一组件。但是公司的组件一般也是开源进行二次开发的，也一样可以想学什么就用什么，弄不明白的，还可以找维护组件的人请教。也可以用公司自研的，但是在业界有一定知名度的产品。研究的好可以作为面试的一个亮点。&lt;/p&gt;&lt;p&gt;瞎举个例子哈：&lt;/p&gt;&lt;p&gt;一六年、一七年做P2P并且不合规的公司，眼看就不行了。有的团队用的kafka，就是为了学习这个东西；有的团队自己搭建redis集群也是为了学习。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;从零开始项目现在没有什么业务量，现在或者&lt;/strong&gt;&lt;strong&gt;将来对稳定性要求很高&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从目标上，这个是产生业绩的最佳项目，要精心规划。&lt;/p&gt;&lt;p&gt;做这种项目需要做好调研，包含业界调研和公司调研。业界的同类产品是怎么做的，有哪些缺点和优点。公司有没有同类或者可以登高类比(登高类比是指先找相似度最高的，找不到在逐渐扩大范围)的，那些项目遇到过哪些坑或者问题，是否和架构或者技术选项有关。&lt;/p&gt;&lt;p&gt;在做好调研基础上，如果公司对组件上没有什么要求，那就需要根据项目本身的特点综合比较。举例如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9288590604026845&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9CmJJia6SPKn3aiat9bnl33qdT7I2fW1QgJNGNoT5WSwMrNsJjuhG9O1iakIfozicuWhUUeeDhLOsteQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;745&quot;/&gt;&lt;/p&gt;&lt;p&gt;不考虑项目本身特性，使用技术通用的考察项主要有：优势、劣势、技术成熟度、社区活跃度、资料丰富程度、是否有大牌公司在持续维护。&lt;/p&gt;&lt;p&gt;可参考我之前的文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484754&amp;amp;idx=1&amp;amp;sn=06ef4e22d3d113f213171330cd5c132c&amp;amp;chksm=fafdeffccd8a66ea04c16e30f75bb09dfad34a1c4866cb14a5783a3450d84a02fe156b67464f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《SpringBoot整合web容器》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《SpringBoot整合web容器》&lt;/a&gt;里面有介绍我当初对tomcat还是jetty选择的考虑点。&lt;/p&gt;&lt;p&gt;如果公司有标准化规范，需要用公司的统一组件。&lt;/p&gt;&lt;p&gt;这时候，如果公司的组件可选性很多，比如之前美团的监控告警组件就有cat、digger、tracing、大白等。这时候一方面考虑各个组件的侧重点和自身是否切合，最重要的是要看其他团队都用什么。周围团队用的很少，咱们也不要用了。兄弟团队有福同享有难同当，如果大家都用这个，组件稳定性有问题了，影响的不止一个团队，也相互有个依靠。就自己用了还出事了，额，让我想起一句歌词：“多少秘密在其中 欲诉无人能懂”-----一帘幽梦。暴露年龄了。&lt;/p&gt;&lt;p&gt;如果公司的组件只有一个，也要看看兄弟团队有没有在用，还需要组件团队给提供相应的SLA，对于还在推广中的组件要谨慎。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重构老系统&lt;strong&gt;现&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;在&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;没有什么业&lt;/strong&gt;&lt;strong&gt;务量，将来估计也不会有什么增长&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;建议放弃重构！&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重构老系统&lt;strong&gt;现&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;在&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;没有什么业&lt;/strong&gt;&lt;strong&gt;务量，&lt;strong&gt;将来对稳定性要求很高&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;参考从零开始项目现在没有什么业务量，现在或者将来对稳定性要求很高的方法。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重构老系统&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;，现在&lt;strong&gt;对稳定性要求很高&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;建议选型尽量和之前保持一致，以便于和之前的逻辑尽量一致。避免踩到特殊需求导致的特殊逻辑等坑。&lt;/p&gt;&lt;p&gt;实在不能一致，比如十二年前我们有个“新鲜事”中间件，类似于网页版的发朋友圈吧。之前是用c++写的，后来c++的同事都离职了，要求我们改成java。这时候要考虑的主要是技术的成熟度。这个成熟度包含业界技术本身的成熟度和团队成员对技术的熟练度。&lt;/p&gt;&lt;p&gt;对于这种类型，还有几句忠告：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;不要特立独行，要合群！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用成熟的技术！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用成熟技术的成熟功能！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;最后对使用成熟技术的成熟功能做个解释说明：比如redis很成熟了，redis有很多高级特性，比如订阅转发，稳定性要求高的不要用。用更加成熟的常用做订阅转发的比如MQ!&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;往期推荐&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cf7a650e72453bd78df1397ca31de218</guid>
<title>脑洞：让页面白屏的 8 种方式和防御方法</title>
<link>https://toutiao.io/k/xsdoi2k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在页面上加些代码，让页面白屏幕，有哪些方式呢？如何防御呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍了 8 种让页面白屏的方法。在防御方法中，包含了一些你可能不知道的冷知识，如：判断元素是否被遮挡。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法1: 隐藏根节点&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;display&lt;/span&gt;:none &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择器用 &lt;code&gt;body&lt;/code&gt; 也能达到一样的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当页面是深色模式时，添加上面的代码页面后，页面是黑色的。需要取消深色模式：删除下面的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;meta&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;color-scheme&quot;&lt;/span&gt; &lt;span&gt;content&lt;/span&gt;=&lt;span&gt;&quot;dark&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法2: 让根节点不可见&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置可见性的属性：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;visibility&lt;/span&gt;: hidden &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者，设置透明度为完全透明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法3: 大小设为0，超出隐藏&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;body&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;overflow&lt;/span&gt;: hidden &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择器用 &lt;code&gt;html&lt;/code&gt; 没有效果。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法4: 偏移出屏幕&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 &lt;code&gt;fixed&lt;/code&gt; 定位：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: fixed;&lt;br/&gt;  &lt;span&gt;left&lt;/span&gt;: -&lt;span&gt;99999px&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者，用 &lt;code&gt;transform&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;translateX&lt;/span&gt;(-&lt;span&gt;99999px&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法5: 遮挡页面&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用全屏的白色元素遮挡页面。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;::before&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;content&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: fixed;&lt;br/&gt;  &lt;span&gt;z-index&lt;/span&gt;: &lt;span&gt;999999&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;top&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;100vw&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;100vh&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;background&lt;/span&gt;: &lt;span&gt;#fff&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法6: 缩小&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;0.0000000000001&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法7: 清空页面内容&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;document&lt;/span&gt;.documentElement.innerHTML = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法8: 页面跳转到一个空白页面&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;location.href = &lt;span&gt;&#x27;空白页面URL&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法有点皮~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;防御&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;检测白屏的样式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过轮训检查根节点上，是否有导致白屏的样式。如果有，则刷新页面。例如:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;setInterval(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(hasWhitePageStyle()) {&lt;br/&gt;        location.reload()&lt;br/&gt;    }&lt;br/&gt;},  &lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这种方式，可以防御方法 1 ~ 6。我们来看具体的检查方法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;根节点是否隐藏检查&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; root = &lt;span&gt;document&lt;/span&gt;.documentElement&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; body = &lt;span&gt;document&lt;/span&gt;.body&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;br/&gt;  getComputedStyle(root, &lt;span&gt;null&lt;/span&gt;).display === &lt;span&gt;&#x27;none&#x27;&lt;/span&gt; ||&lt;br/&gt;  getComputedStyle(body, &lt;span&gt;null&lt;/span&gt;).display === &lt;span&gt;&#x27;none&#x27;&lt;/span&gt;&lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 根节点被隐藏&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;根节点是否可见检查&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(&lt;br/&gt;  getComputedStyle(root, &lt;span&gt;null&lt;/span&gt;).visibility === &lt;span&gt;&#x27;hidden&#x27;&lt;/span&gt; ||&lt;br/&gt;  getComputedStyle(body, &lt;span&gt;null&lt;/span&gt;).visibility === &lt;span&gt;&#x27;hidden&#x27;&lt;/span&gt;&lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 不可见&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;br/&gt;  getComputedStyle(root, &lt;span&gt;null&lt;/span&gt;).opacity &amp;lt; &lt;span&gt;0.1&lt;/span&gt; || &lt;br/&gt;  getComputedStyle(body, &lt;span&gt;null&lt;/span&gt;).opacity &amp;lt; &lt;span&gt;0.1&lt;/span&gt; ||&lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 不可见&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大小为 0 检查&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; {width, height } = body.getBoundingClientRect()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(width === &lt;span&gt;0&lt;/span&gt; || height === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 大小为 0&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;偏移出屏幕检查&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; {left, right, top, bottom } = body.getBoundingClientRect()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;br/&gt;  left &amp;gt; &lt;span&gt;window&lt;/span&gt;.innerWidth || &lt;br/&gt;  right &amp;lt; &lt;span&gt;0&lt;/span&gt; || &lt;br/&gt;  top &amp;gt; &lt;span&gt;window&lt;/span&gt;.innerHeight || &lt;br/&gt;  bottom &amp;lt; &lt;span&gt;0&lt;/span&gt; &lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 偏移出屏幕&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;遮挡检查&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;document.elementFromPoint(x, y)&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 返回某个坐标点下最上层的元素。如果元素没有被遮挡，则在该 API 中传入元素的上下左右四个坐标点，返回的均为该元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设页面上有个 id 为 tar 的元素，如果该元素未被遮挡，则认为页面被遮挡。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; tarElem = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;tar&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; {left, right, top, bottom} = tarElem.getBoundingClientRect()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.elementFromPoint(left, top) === tar &amp;amp;&amp;amp;&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.elementFromPoint(left, bottom) === tar &amp;amp;&amp;amp;&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.elementFromPoint(right, top) === tar &amp;amp;&amp;amp;&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.elementFromPoint(right, bottom) === tar &amp;amp;&amp;amp;&lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;// 未被遮挡&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;防止修改 DOM&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MutationObserver API&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 可以监控 DOM 的变动。用该 API 可以防御页面内容被清空。代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 监控 属性，子节点和后代节点的变动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; config = { &lt;span&gt;attributes&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;childList&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;subtree&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; observer = &lt;span&gt;new&lt;/span&gt; MutationObserver(&lt;span&gt;(&lt;span&gt;mutationsList&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; mutation &lt;span&gt;of&lt;/span&gt; mutationsList) {&lt;span&gt;// 页面DOM变动&lt;/span&gt;&lt;br/&gt;    location.reload()&lt;br/&gt;  }&lt;br/&gt;})&lt;br/&gt;&lt;span&gt;window&lt;/span&gt;.addEventListener(&lt;span&gt;&#x27;DOMContentLoaded&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;  observer.observe(&lt;span&gt;document&lt;/span&gt;.documentElement, config);&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;防止页面跳转&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前没有找到防御的方法。尝试过以下方法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重置 window.location&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;window&lt;/span&gt; = {}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;window.location 仍然在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; location = &lt;span&gt;&#x27;&#x27;&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;location&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;都会报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;window.location = {} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;页面直接跳转了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;将 window.location 设置为只读&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做了如下尝试，均不行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;.freeze(&lt;span&gt;window&lt;/span&gt;) &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.freeze(&lt;span&gt;window&lt;/span&gt;.location) &lt;span&gt;// 无效&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.defineProperty(&lt;span&gt;window&lt;/span&gt;, &lt;span&gt;&quot;location&quot;&lt;/span&gt;, {&lt;span&gt;&quot;writable&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;})&lt;br/&gt;&lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.defineProperty(location, &lt;span&gt;&quot;false&quot;&lt;/span&gt;, {&lt;span&gt;&quot;writable&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最后&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还有其他让页面白屏的方法吗？公众号留言告诉我吧~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;document.elementFromPoint(x, y): &lt;em&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementFromPoint&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;MutationObserver API: &lt;em&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver&lt;/em&gt;&lt;span/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>940e34cc825342fe77f340069c1308fd</guid>
<title>[译] 在嵌入式系统中运行 eBPF</title>
<link>https://toutiao.io/k/rby5frf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;作者：Adrian Ratiu&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;译者：狄卫华&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;注：本文已取得作者本人的翻译授权！&lt;/p&gt;&lt;p&gt;原文链接：https://www.collabora.com/news-and-blog/blog/2019/05/06/an-ebpf-overview-part-4-working-with-embedded-systems/&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本系列的&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NTU0MzEyMg==&amp;amp;mid=2247493590&amp;amp;idx=1&amp;amp;sn=69f5272cc486fc0f72d84da01fabbe7d&amp;amp;chksm=cfa5fe6bf8d2777dfe1b208fa55e1603e28896878f84c5458df6281988985f8d081b823a7b15&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第 1 部分&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;第 1 部分&lt;/span&gt;&lt;/a&gt;和&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NTU0MzEyMg==&amp;amp;mid=2247493681&amp;amp;idx=1&amp;amp;sn=497f67295144231d9ba3d3c53260328d&amp;amp;chksm=cfa5f18cf8d2789a7188f2f83cca93ced881b6cc04cd3f9ad53de7775b726b79fa594af2817b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第 2 部分&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;第 2 部分&lt;/span&gt;&lt;/a&gt;，我们介绍了 eBPF 虚拟机内部工作原理，在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NTU0MzEyMg==&amp;amp;mid=2247494118&amp;amp;idx=1&amp;amp;sn=0f48c98e52834660e460c4040fd7148b&amp;amp;chksm=cfa5f05bf8d2794d78418cda5568c26a3e0dce8a9ca16c691acd0037e2f17dd35bc6c85ac7b8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第 3 部分&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;第 3 部分&lt;/span&gt;&lt;/a&gt;我们研究了基于底层虚拟机机制之上开发和使用 eBPF 程序的主流方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这一部分中，我们将从另外一个视角来分析项目，尝试解决嵌入式 Linux 系统所面临的一些独特的问题：如需要非常小的自定义操作系统镜像，不能容纳完整的 BCC LLVM 工具链/python 安装，或试图避免同时维护主机的交叉编译（本地）工具链和交叉编译的目标编译器工具链，以及其相关的构建逻辑，即使在使用像 OpenEmbedded/Yocto 这样的高级构建系统时也很重要。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 关于可移植性&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NTU0MzEyMg==&amp;amp;mid=2247494118&amp;amp;idx=1&amp;amp;sn=0f48c98e52834660e460c4040fd7148b&amp;amp;chksm=cfa5f05bf8d2794d78418cda5568c26a3e0dce8a9ca16c691acd0037e2f17dd35bc6c85ac7b8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第 3 部分&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;第 3 部分&lt;/span&gt;&lt;/a&gt;研究的运行 eBPF/BCC 程序的主流方式中，可移植性并不是像在嵌入式设备上面临的问题那么大：eBPF 程序是在被加载的同一台机器上编译的，使用已经运行的内核，而且头文件很容易通过发行包管理器获得。嵌入式系统通常运行不同的 Linux 发行版和不同的处理器架构，与开发人员的计算机相比，有时具有重度修改或上游分歧的内核，在构建配置上也有很大的差异，或还可能使用了只有二进制的模块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;eBPF 虚拟机的字节码是通用的（并未与特定机器相关），所以一旦编译好 eBPF 字节码，将其从 x86_64 移动到 ARM 设备上并不会引起太多问题。当字节码探测内核函数和数据结构时，问题就开始了，这些函数和数据结构可能与目标设备的内核不同或者会不存在，所以至少目标设备的内核头文件必须存在于构建 eBPF 程序字节码的主机上。新的功能或 eBPF 指令也可能被添加到以后的内核中，这可以使 eBPF 字节码向前兼容，但不能在内核版本之间向后兼容（参见&lt;span&gt;内核版本与 eBPF 功能&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;）。建议将 eBPF 程序附加到稳定的内核 ABI 上，如跟踪点（tracepoint），这可以缓解常见的可移植性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近一个重要的工作已经开始，通过在 LLVM 生成的 eBPF 对象代码中嵌入数据类型信息，通过增加 BTF（BTF 类型格式）数据，以增加 eBPF 程序的可移植性（CO-RE 一次编译，到处运行）。更多信息见这里的&lt;span&gt;补丁&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;和&lt;span&gt;文章&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;。这很重要，因为 BTF 涉及到 eBPF 软件技术栈的所有部分（内核虚拟机和验证器、clang/LLVM 编译器、BCC 等），但这种方式可带来很大的便利，允许重复使用现有的 BCC 工具，而不需要特别的 eBPF 交叉编译和在嵌入式设备上安装 LLVM 或运行 BPFd。截至目前，CO-RE BTF 工作仍处于早期开发阶段，还需要付出相当多的工作才能可用【译者注：当前在高版本内核已经可以使用或者编译内核时启用了 BTF 编译选项】。也许我们会在其完全可用后再发表一篇博文。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. BPFd&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;BPFd&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;（项目地址 &lt;span&gt;👉&lt;/span&gt;https://github.com/joelagnel/bpfd）更像是一个为 Android 设备开发的概念验证，后被放弃，转而通过 &lt;span&gt;adeb&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 包运行一个完整的设备上的 BCC 工具链【译者注：BCC 在 adeb 的编译文档参见&lt;span&gt;这里&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;】。如果一个设备足够强大，可以运行 Android 和 Java，那么它也可能可以安装 BCC/LLVM/python。尽管这个实现有些不完整（通信是通过 Android USB 调试桥或作为一个本地进程完成的，而不是通过一个通用的传输层），但这个设计很有趣，有足够时间和资源的人可以把它拿起来合并，继续搁置的 &lt;span&gt;PR 工作&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简而言之，BPFd 是一个运行在嵌入式设备上的守护程序，作为本地内核/libbpf 的一个远程过程调用（RPC）接口。Python 在主机上运行，调用 BCC 来编译/部署 eBPF 字节码，并通过 BPFd 创建/读取 map。BPFd 的主要优点是，所有的 BCC 基础设施和脚本都可以工作，而不需要在目标设备上安装 BCC、LLVM 或 python，BPFd 二进制文件只有 100kb 左右的大小，并依赖 libc。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;102&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.17647058823529413&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/u5Pibv7AcsEUeica6doRh2mEQA4DWhOruAsMHkxosSoickkhWfxHbuJGWhSjv9EUTIlBhemQBIHfh7pdcSOUiajA7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Ply&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ply&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt; 项目实现了一种与 BPFtrace 非常相似的高级领域特定语言（受到 AWK 和 C 的启发），其明确的目的是将运行时的依赖性降到最低。它只依赖于一个现代的 libc（不一定是 GNU 的 libc）和 shell（与 sh 兼容）。Ply 本身实现了一个 eBPF 编译器，需要根据目标设备的内核头文件进行构建，然后作为一个单一的二进制库和 shell 包装器部署到目标设备上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;104&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.18030690537084398&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/u5Pibv7AcsEUeica6doRh2mEQA4DWhOruAlyoU5JxUhiaziaGw4dqJoHu2Ltf5P1HcDRIYYIDCl0OPgQBVffy6RDnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好解释 ply，我们把第 3 部分中的 BPFtrace 例子和与 ply 实现进行对比：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;BPFtrace：要运行该例子，你需要数百 MB 的 LLVM/clang、libelf 和其他依赖项：&lt;/p&gt;&lt;p&gt;&lt;code&gt;bpftrace -e &#x27;tracepoint:raw_syscalls:sys_enter {@[pid, comm] = count();}&#x27;&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ply：你只需要一个 ~50kb 的二进制文件，它产生的结果是相同的，语法几乎相同：&lt;/p&gt;&lt;p&gt;&lt;code&gt;ply &#x27;tracepoint:raw_syscalls/sys_enter {@[pid, comm] = count();}&#x27;&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Ply 仍在大量开发中（最近的 v2.0 版本是完全重写的）【译者注：当前最新版本为 2.1.1，最近一次代码提交是 8 个月前，活跃度一般】，除了一些示例之外，该语言还不不稳定或缺乏文档，它不如完整的 BCC 强大，也没有 BPFtrace 丰富的功能特性，但它对于通过 ssh 或串行控制台快速调试远程嵌入式设备仍然非常有用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. Gobpf&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Gobpf&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt; 及其合并的子项目（goebpf, gobpf-elf-loader），是 IOVisor 项目的一部分，为 BCC 提供 Golang 语言绑定。eBPF 的内核逻辑仍然用 &quot;限制性 C&quot; 编写，并由 LLVM 编译，只有标准的 python/lua 用户空间脚本被 Go 取代。这个项目对嵌入式设备的意义在于它的 eBPF &lt;span&gt;elf 加载模块&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;，其可以被交叉编译并在嵌入式设备上独立运行，以加载 eBPF 程序至内核并与与之交互。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;121&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.20971867007672634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/u5Pibv7AcsEUeica6doRh2mEQA4DWhOruAtkAfY0QXls6cJpicLBYKOTkTmJia6b3rMpKibneJgyBm7qVTCBMqhUMEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，go 加载器可以被写成通用的（我们很快就会看到），因此它可以加载和运行任何 eBPF 字节码，并在本地重新用于多个不同的跟踪会话。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 gobpf 很痛苦的，主要是因为缺乏文档。目前最好的 &quot;文档&quot; 是 &lt;span&gt;tcptracer 源码&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;，它相当复杂（他们使用 kprobes 而不依赖于特定的内核版本！），但从它可以学到很多。Gobpf 本身也是一项正在进行的工作：虽然 elf 加载器相当完整，并支持加载带有套接字、(k|u)probes、tracepoints、perf 事件等加载的 eBPF ELF 对象，但 bcc go 绑定模块还不容易支持所有这些功能。例如，尽管你可以写一个 socket_ilter ebpf 程序，将其编译并加载到内核中，但你仍然不能像 BCC 的 python 那样从 go 用户空间轻松地与 eBPF 进行交互，BCC 的 API 更加成熟和用户友好。无论如何，gobpf 仍然比其他具有类似目标的项目处于更好的状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们研究一个简单的例子来说明 gobpf 如何工作的。首先，我们将在本地 x86_64 机器上运行它，然后交叉编译并在 32 位 ARMv7 板上运行它，比如流行的 Beaglebone 或 Raspberry Pi。我们的文件目录结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ find . -&lt;span&gt;type&lt;/span&gt; f&lt;br/&gt;./src/open-example.go&lt;br/&gt;./src/open-example.c&lt;br/&gt;./Makefile&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;open-example.go&lt;/strong&gt;：这是建立在 gobpf/elf 之上的 eBPF ELF 加载器。它把编译好的 &quot;限制性 C&quot; ELF 对象作为参数，加载到内核并运行，直到加载器进程被杀死，这时内核会自动卸载 eBPF 逻辑【译者注：通常情况是这样的，也有场景加载器退出，ebpf 程序继续运行的】。我们有意保持加载器的简单性和通用性（它加载在对象文件中发现的任何探针），因此加载器可以被重复使用。更复杂的逻辑可以通过使用 &lt;span&gt;gobpf 绑定&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt; 模块添加到这里。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os/signal&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;github.com/iovisor/gobpf/elf&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {mod := elf.NewModule(os.Args[&lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;&lt;br/&gt;    err := mod.Load(&lt;span&gt;nil&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {fmt.Fprintf(os.Stderr, &lt;span&gt;&quot;Error loading&#x27;%s&#x27;ebpf object: %v\n&quot;&lt;/span&gt;, os.Args[&lt;span&gt;1&lt;/span&gt;], err)os.Exit(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    err = mod.EnableKprobes(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {fmt.Fprintf(os.Stderr, &lt;span&gt;&quot;Error loading kprobes: %v\n&quot;&lt;/span&gt;, err)&lt;br/&gt;        os.Exit(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    sig := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; os.Signal, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    signal.Notify(sig, os.Interrupt, os.Kill)&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;open-example.c&lt;/strong&gt;：这是上述加载器加载至内核的 &quot;限制性 C&quot; 源代码。它挂载在 do_sys_open 函数，并根据 &lt;span&gt;ftrace format&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt; 将进程命令、PID、CPU、打开文件名和时间戳打印到跟踪环形缓冲区，（详见 &quot;输出格式&quot; 一节）。打开的文件名作为 &lt;span&gt;do_sys_open call&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt; 的第二个参数传递，可以从代表函数入口的 CPU 寄存器的上下文结构中访问。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;uapi/linux/bpf.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;uapi/linux/ptrace.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;bpf/bpf_helpers.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;SEC(&lt;span&gt;&quot;kprobe/do_sys_open&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;kprobe__do_sys_open&lt;/span&gt;&lt;span&gt;(struct pt_regs *ctx)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;span&gt;char&lt;/span&gt; file_name[&lt;span&gt;256&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;    bpf_probe_read(file_name, &lt;span&gt;sizeof&lt;/span&gt;(file_name), PT_REGS_PARM2(ctx));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; fmt[] = &lt;span&gt;&quot;file %s\n&quot;&lt;/span&gt;;&lt;br/&gt;    bpf_trace_printk(fmt, &lt;span&gt;sizeof&lt;/span&gt;(fmt), &amp;amp;file_name);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;char&lt;/span&gt; _license[] SEC(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) = &lt;span&gt;&quot;GPL&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;__u32 _version &lt;span&gt;SEC&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;version&quot;&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;= &lt;span&gt;0xFFFFFFFE&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的代码中，我们定义了特定的 &quot;SEC&quot; 区域，这样 gobpf 加载器就可获取到哪里查找或加载内容的信息。在我们的例子中，区域为 kprobe、license 和 version。特殊的 0xFFFFFFFE 值告诉加载器，这个 eBPF 程序与任何内核版本都是兼容的，因为打开系统调用而破坏用户空间的机会接近于 0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Makefile&lt;/strong&gt;：这是上述两个文件的构建逻辑。注意我们是如何在 include 路径中加入 &quot;arch/x86/...&quot; 的；在 ARM 上它将是 &quot;arch/arm/...&quot;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SHELL=/bin/bash -o pipefail&lt;br/&gt;LINUX_SRC_ROOT=&lt;span&gt;&quot;/home/adi/workspace/linux&quot;&lt;/span&gt;&lt;br/&gt;FILENAME=&lt;span&gt;&quot;open-example&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;ebpf-build: clean go-build&lt;/span&gt;&lt;br/&gt; clang \&lt;br/&gt; -D__KERNEL__ -fno-stack-protector -Wno-int-conversion \&lt;br/&gt; -O2 -emit-llvm -c &lt;span&gt;&quot;src/${FILENAME}.c&quot;&lt;/span&gt; \&lt;br/&gt; -I ${LINUX_SRC_ROOT}/&lt;span&gt;include&lt;/span&gt; \&lt;br/&gt; -I ${LINUX_SRC_ROOT}/tools/testing/selftests \&lt;br/&gt; -I ${LINUX_SRC_ROOT}/arch/x86/&lt;span&gt;include&lt;/span&gt; \&lt;br/&gt; -o - | llc -march=bpf -filetype=obj -o &lt;span&gt;&quot;${FILENAME}.o&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;go-build:&lt;/span&gt;&lt;br/&gt; go build -o ${FILENAME} src/${FILENAME}.go&lt;br/&gt;&lt;br/&gt;&lt;span&gt;clean:&lt;/span&gt;&lt;br/&gt; rm -f ${FILENAME}*&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上述 makefile 在当前目录下产生两个新文件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;open-example：这是编译后的 src/*.go 加载器。它只依赖于 libc 并且可以被复用来加载多个 eBPF ELF 文件运行多个跟踪。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;open-example.o：这是编译后的 eBPF 字节码，将在内核中加载。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“open-example&quot; 和 &quot;open-example.o&quot; ELF 二进制文件可以进一步合并成一个；加载器可以包括 eBPF 二进制文件作为资产，也可以像 &lt;span&gt;tcptracer&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt; 那样在其源代码中直接存储为字节数。然而，这超出了本文的范围。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行例子显示以下输出（见 [ftrace 文档](&amp;lt;(https://raw.githubusercontent.com/torvalds/linux/v4.20/Documentation/trace/ftrace.rst &quot;ftrace 文档&quot;)&amp;gt;) 中的 &quot;输出格式&quot; 部分）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# (./open-example open-example.o &amp;amp;) &amp;amp;&amp;amp; cat /sys/kernel/debug/tracing/trace_pipe&lt;/span&gt;&lt;br/&gt;electron-17494 [007] ...3 163158.937350: 0: file /proc/self/maps&lt;br/&gt;systemd-1      [005] ...3 163160.120796: 0: file /proc/29261/cgroup&lt;br/&gt;emacs-596      [006] ...3 163163.501746: 0: file /home/adi/&lt;br/&gt;(...)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;沿用我们在本系列的第 3 部分中定义的术语，我们的 eBPF 程序有以下部分组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;后端&lt;/strong&gt;：是 open-example.o ELF 对象。它将数据写入内核跟踪环形缓冲区。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;加载器&lt;/strong&gt;：这是编译过的 open-example 二进制文件，包含 gobpf/elf 加载器模块。只要它运行，数据就会被添加到跟踪缓冲区中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;前端&lt;/strong&gt;：这就是 &lt;code&gt;cat /sys/kernel/debug/tracing/trace_pipe&lt;/code&gt;。非常 UNIX 风格。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;数据结构&lt;/strong&gt;：内核跟踪环形缓冲区。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在将我们的例子交叉编译为 32 位 ARMv7。基于你的 ARM 设备运行的内核版本：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内核版本&amp;gt;=5.2：只需改变 makefile，就可以交叉编译与上述相同的源代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内核版本&amp;lt;5.2：除了使用新的 makefile 外，还需要将 PT_REGS_PARM* 宏从 &lt;span&gt;这个 patch&lt;/span&gt;&lt;sup&gt;[16]&lt;/sup&gt; 复制到 &quot;受限制 C&quot; 代码。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新的 makefile 告诉 LLVM/Clang，eBPF 字节码以 ARMv7 设备为目标，使用 32 位 eBPF 虚拟机子寄存器地址模式，以便虚拟机可以正确访问本地处理器提供的 32 位寻址内存（还记得第 2 部分中介绍的所有 eBPF 虚拟机寄存器默认为 64 位宽），设置适当的包含路径，然后指示 Go 编译器使用正确的交叉编译设置。在运行这个 makefile 之前，需要一个预先存在的交叉编译器工具链，它被指向 CC 变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SHELL=/bin/bash -o pipefail&lt;br/&gt;LINUX_SRC_ROOT=&lt;span&gt;&quot;/home/adi/workspace/linux&quot;&lt;/span&gt;&lt;br/&gt;FILENAME=&lt;span&gt;&quot;open-example&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;ebpf-build: clean go-build&lt;/span&gt;&lt;br/&gt; clang \&lt;br/&gt;  --target=armv7a-linux-gnueabihf \&lt;br/&gt;  -D__KERNEL__ -fno-stack-protector -Wno-int-conversion \&lt;br/&gt;  -O2 -emit-llvm -c &lt;span&gt;&quot;src/${FILENAME}.c&quot;&lt;/span&gt; \&lt;br/&gt;  -I ${LINUX_SRC_ROOT}/&lt;span&gt;include&lt;/span&gt; \&lt;br/&gt;  -I ${LINUX_SRC_ROOT}/tools/testing/selftests \&lt;br/&gt;  -I ${LINUX_SRC_ROOT}/arch/arm/&lt;span&gt;include&lt;/span&gt; \&lt;br/&gt;  -o - | llc -march=bpf -filetype=obj -o &lt;span&gt;&quot;${FILENAME}.o&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;go-build:&lt;/span&gt;&lt;br/&gt; GOOS=linux GOARCH=arm CGO_ENABLED=1 CC=arm-linux-gnueabihf-gcc \&lt;br/&gt; go build -o ${FILENAME} src/${FILENAME}.go&lt;br/&gt;&lt;br/&gt;&lt;span&gt;clean:&lt;/span&gt;&lt;br/&gt; rm -f ${FILENAME}*&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行新的 makefile，并验证产生的二进制文件已经被正确地交叉编译：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[adi@iwork]$ file open-example*&lt;br/&gt;open-example:   ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter (...), stripped&lt;br/&gt;open-example.o: ELF 64-bit LSB relocatable, *unknown arch 0xf7* version 1 (SYSV), not stripped&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后将加载器和字节码复制到设备上，与在 x86_64 主机上使用上述相同的命令来运行。记住，只要修改和重新编译 C eBPF 代码，加载器就可以重复使用，用于运行不同的跟踪。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@ionelpi adi]&lt;span&gt;# (./open-example open-example.o &amp;amp;) &amp;amp;&amp;amp; cat /sys/kernel/debug/tracing/trace_pipe&lt;/span&gt;&lt;br/&gt;ls-380     [001] d..2   203.410986: 0: file /etc/ld-musl-armhf.path&lt;br/&gt;ls-380     [001] d..2   203.411064: 0: file /usr/lib/libcap.so.2&lt;br/&gt;ls-380     [001] d..2   203.411922: 0: file /&lt;br/&gt;zcat-397   [002] d..2   432.676010: 0: file /etc/ld-musl-armhf.path&lt;br/&gt;zcat-397   [002] d..2   432.676237: 0: file /usr/lib/libtinfo.so.5&lt;br/&gt;zcat-397   [002] d..2   432.679431: 0: file /usr/bin/zcat&lt;br/&gt;gzip-397   [002] d..2   432.693428: 0: file /proc/&lt;br/&gt;gzip-397   [002] d..2   432.693633: 0: file config.gz&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于加载器和字节码加起来只有 2M 大小，这是一个在嵌入式设备上运行 eBPF 的相当好的方法，而不需要完全安装 BCC/LLVM。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本系列的第 4 部分，我们研究了可以用于在小型嵌入式设备上运行 eBPF 程序的相关项目。不幸的是，当前使用这些项目还是比较很困难的：它们有的被遗弃或缺乏人力，在早期开发时一切都在变化，或缺乏基本的文档，需要用户深入到源代码中并自己想办法解决。正如我们所看到的，gobpf 项目作为 BCC/python 的替代品是最有活力的，而 ply 也是一个有前途的 BPFtrace 替代品，其占用空间最小。随着更多的工作投入到这些项目中以降低使用者的门槛，eBPF 的强大功能可以用于资源受限的嵌入式设备，而无需移植/安装整个 BCC/LLVM/python/Hover 技术栈。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引用链接&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;内核版本与 eBPF 功能: &lt;em&gt;https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;补丁: &lt;em&gt;https://lwn.net/Articles/750695/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;文章: &lt;em&gt;https://lwn.net/Articles/773198/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;BPFd: &lt;em&gt;https://lwn.net/Articles/744522/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;adeb: &lt;em&gt;https://github.com/joelagnel/adeb&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;这里: &lt;em&gt;https://github.com/joelagnel/adeb/blob/master/BCC.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;PR 工作: &lt;em&gt;https://github.com/iovisor/bcc/pull/1675&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;ply: &lt;em&gt;https://wkz.github.io/ply/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Gobpf: &lt;em&gt;https://github.com/iovisor/gobpf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;elf 加载模块: &lt;em&gt;https://github.com/iovisor/gobpf/tree/master/elf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;tcptracer 源码: &lt;em&gt;https://github.com/weaveworks/tcptracer-bpf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;gobpf 绑定: &lt;em&gt;https://github.com/iovisor/gobpf/blob/master/bcc/module.go&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;ftrace format: &lt;em&gt;https://raw.githubusercontent.com/torvalds/linux/v4.20/Documentation/trace/ftrace.rst&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;do_sys_open call: &lt;em&gt;https://github.com/torvalds/linux/blob/v4.20/fs/open.c#L1048&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[15]&lt;/span&gt;&lt;p&gt;tcptracer: &lt;em&gt;https://github.com/weaveworks/tcptracer-bpf/blob/master/pkg/tracer/tcptracer-ebpf.go#L80&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[16]&lt;/span&gt;&lt;p&gt;这个 patch: &lt;em&gt;https://lore.kernel.org/bpf/20190304205019.15071-1-adrian.ratiu@collabora.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bc34029022719ec4a55af60d9585f6b6</guid>
<title>网易开源运维诊断框架 KubeDiag 技术解析</title>
<link>https://toutiao.io/k/mcc46wh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;KubeDiag 是基于 Kubernetes 云原生基础设施能力打造的开源框架，旨在解决云原生体系中运维诊断的自动化问题，帮助用户更加平滑地完成容器化落地。本文将为大家解读 KubeDiag 整体框架设计。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Kubernetes 是一个生产级的容器编排引擎，但是 Kubernetes 仍然存在系统复杂、故障诊断成本高等问题。&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MzM3MzkyMg==&amp;amp;mid=2247492500&amp;amp;idx=1&amp;amp;sn=b56a351eecba9949081079b24a194c33&amp;amp;chksm=eabe7699ddc9ff8f16dde16ab87456d2b61764ba5dc784c9209357942c260895a85648f2333a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;网易数帆近期开源的 KubeDiag&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;网易数帆近期开源的 KubeDiag&lt;/a&gt;，是基于 Kubernetes 云原生基础设施能力打造的框架，旨在解决云原生体系中故障诊断、运维恢复的自动化问题。主要包括以下几个维度：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.27890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaOz7l1bIBYA2ibCpPz4SSMpB7emIibZtQSxBJ9RuGZNX77RgHg75dFrLajD8OoLnOyhN9dI10FILvwIwfRTBEicXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;项目地址：https://github.com/kubediag/kubediag&lt;/p&gt;&lt;h2&gt;&lt;span&gt;设计目标&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;KubeDiag 的设计目标包括：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可移植性：&lt;/strong&gt;可以在部署 Kubernetes 的 Linux 标准环境下运行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可扩展性：&lt;/strong&gt;用户可以集成自定义的诊断功能。模块之间通过松耦合接口交互并且各功能模块均是可插拔式的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;自动化：&lt;/strong&gt;极大降低问题诊断的人力成本。用户可以通过声明式 API 定义诊断工作流并且在问题发生时自动运行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;易用性：&lt;/strong&gt;内置常见问题诊断逻辑以提供开箱即用的体验。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;架构设计&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;KubeDiag 由 Master 和 Agent 组成，并且从 APIServer 以及 Prometheus 等组件获取数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4435483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaOz7l1bIBYA2ibCpPz4SSMpB7emIibZtQSBL29NBljACY91ccb55PC5GAicG9Re4swibJWdFfUg6ibfRFLIGribssTXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1984&quot;/&gt;&lt;/p&gt;&lt;h3&gt;KubeDiag Master 设计&lt;/h3&gt;&lt;p&gt;KubeDiag Master 负责管理 Operation、OperationSet、Trigger 和 Diagnosis 对象。当 OperationSet 创建后，KubeDiag Master 会进行合法性检查并基于用户定义生成有向无环图，所有的诊断路径被更新至 OperationSet 的元数据中。如果 OperationSet 中某个 Operation 的前置依赖诊断操作不存在，则该 OperationSet 会被标记为异常。&lt;/p&gt;&lt;p&gt;KubeDiag Master 会校验 Diagnosis 的 PodReference 或 NodeName 是否存在，如果 Diagnosis 中只定义了 PodReference，则根据 PodReference 计算并更新 NodeName。KubeDiag Master 会查询被 Diagnosis 引用的 OperationSet 状态，如果被引用的 OperationSet 异常，则标记 Diagnosis 失败。Diagnosis 可以由用户直接手动创建，也可以通过配置 Prometheus 报警模板或 Kubernetes 事件模板自动创建。&lt;/p&gt;&lt;p&gt;KubeDiag Master 由下列部分组成：&lt;/p&gt;&lt;h4&gt;图构建器&lt;/h4&gt;&lt;p&gt;图构建器基于 OperationSet 对象生成诊断运行流程图。图构建器根据 OperationSet 中包含的边生成有向无环图并计算出所有的诊断路径。&lt;/p&gt;&lt;h4&gt;Prometheus 报警管理器&lt;/h4&gt;&lt;p&gt;Prometheus 报警管理器接收 Prometheus 报警并创建 Diagnosis 对象。Prometheus 报警管理器可以接收 Prometheus 报警并与 Trigger 中定义的模板进行匹配，如果匹配成功则根据 Trigger 的元数据创建 Diagnosis 对象。&lt;/p&gt;&lt;h4&gt;Kafka 消息管理器&lt;/h4&gt;&lt;p&gt;Kafka 消息管理器接收 Kafka 消息并创建 Diagnosis 对象。Kafka 消息的值必须是一个 JSON 对象并且包含创建 Diagnosis 所需的元信息。&lt;/p&gt;&lt;h4&gt;事件管理器&lt;/h4&gt;&lt;p&gt;事件管理器接收 Kubernetes 事件并创建 Diagnosis 对象。事件管理器可以接收 Kubernetes 事件并与 Trigger 中定义的模板进行匹配，如果匹配成功则根据 Trigger 的元数据创建 Diagnosis 对象。&lt;/p&gt;&lt;h3&gt;KubeDiag Agent 设计&lt;/h3&gt;&lt;p&gt;KubeDiag Agent 负责实际诊断工作的执行并内置多个常用诊断操作。当 Diagnosis 创建后，KubeDiag Agent 会根据 Diagnosis 引用的 OperationSet 执行诊断工作流，诊断工作流是包括多个诊断操作的集合。&lt;/p&gt;&lt;p&gt;KubeDiag Agent 组件由下列部分组成：&lt;/p&gt;&lt;h4&gt;执行器&lt;/h4&gt;&lt;p&gt;执行器负责执行诊断工作流。Diagnosis 引用的 OperationSet 元数据中包含表示诊断工作流的有向无环图和所有的诊断路径。诊断路径表示诊断过程中的排查路径，通过执行某个诊断路径中每个顶点的诊断操作可以对问题进行排查。如果某个诊断路径的所有诊断操作均执行成功，则该次诊断被标记为成功。如果所有诊断路径均执行失败，则该次诊断被标记为失败。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;实现细节&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;KubeDiag 通过实现 Operation、OperationSet、Trigger 和 Diagnosis 自定义资源对一次运维诊断的过程进行抽象。&lt;/p&gt;&lt;h3&gt;对于诊断的管理&lt;/h3&gt;&lt;p&gt;KubeDiag 通过支持下列功能来满足用户管理诊断的需求：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;指定诊断的目标 Node 或 Pod。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查看当前诊断的阶段。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过参数扩展诊断的状态。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;诊断成功时查看诊断的结果以及排查路径。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;诊断失败时查看失败的原因以及排查路径。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查看诊断过程中某个阶段的详细信息。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Diagnosis 对象&lt;/h4&gt;&lt;p&gt;Diagnosis 对象的数据结构如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// DiagnosisSpec 定义了 Diagnosis 的目标状态。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; DiagnosisSpec &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// OperationSet 是待执行诊断流水线的 OperationSet 名。&lt;/span&gt;&lt;br/&gt;    OperationSet &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;operationSet&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 必须指定 NodeName 或 PodReference 其中的一个字段。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// NodeName 是诊断执行的节点。&lt;/span&gt;&lt;br/&gt;    NodeName &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;nodeName,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// PodReference 包含目标 Pod 的详细信息。&lt;/span&gt;&lt;br/&gt;    PodReference *PodReference &lt;span&gt;`json:&quot;podReference,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Parameters 包含诊断过程中需要传入的参数。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 通常该字段的键为 OperationSet 中顶点的序号，值为执行该顶点诊断操作需要的参数。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Parameters 和 OperationResults 会被序列化为 JSON 对象并在运行诊断的过程中发送给故障处理器。&lt;/span&gt;&lt;br/&gt;    Parameters &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;parameters,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// PodReference 包含目标 Pod 的详细信息。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PodReference &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    NamespacedName &lt;span&gt;`json:&quot;,inline&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Container 是目标容器名。&lt;/span&gt;&lt;br/&gt;    Container &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;container,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// NamespacedName 表示 Kubernetes API 对象。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; NamespacedName &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Namespace 是 Kubernetes API 对象命名空间。&lt;/span&gt;&lt;br/&gt;    Namespace &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;namespace&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Namespace 是 Kubernetes API 对象名。&lt;/span&gt;&lt;br/&gt;    Name &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;name&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// DiagnosisStatus 定义了 Diagnosis 的实际状态。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; DiagnosisStatus &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Phase 是 Diagnosis 在其生命周期中所处位置的简单宏观概述。状况列表包含更多关于 Diagnosis 状态的信息。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 阶段可能存在五种不同的值：&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Pending：Diagnosis 已被系统接受，但诊断执行前的准备工作还未完成。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Running：Diagnosis 已经绑定到了某个节点，至少有一个诊断操作正处于运行状态。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Succeeded：诊断流水线中某个路径中的所有诊断操作均执行成功。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Failed：诊断流水线中的所有路径失败。也就是说，所有路径中最后一个执行的诊断操作返回码非 200。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Unknown：因为某些原因无法取得 Diagnosis 的状态。这种情况通常是因为与 Diagnosis 所在主机通信失败。&lt;/span&gt;&lt;br/&gt;    Phase DiagnosisPhase &lt;span&gt;`json:&quot;phase,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Conditions 包含 Diagnosis 当前的服务状态。&lt;/span&gt;&lt;br/&gt;    Conditions []DiagnosisCondition &lt;span&gt;`json:&quot;conditions,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// StartTime 是对象被系统接收的 RFC 3339 日期和时间。&lt;/span&gt;&lt;br/&gt;    StartTime metav1.Time &lt;span&gt;`json:&quot;startTime,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// FailedPaths 包含诊断流水线中所有运行失败的路径。路径的最后一个顶点是操作执行失败的顶点。&lt;/span&gt;&lt;br/&gt;    FailedPaths []Path &lt;span&gt;`json:&quot;failedPath,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// SucceededPath 是诊断流水线中运行成功的路径。&lt;/span&gt;&lt;br/&gt;    SucceededPath Path &lt;span&gt;`json:&quot;succeededPath,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// OperationResults 包含诊断运行过程中操作的结果。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Parameters 和 OperationResults 会被序列化为 JSON 对象并在运行诊断的过程中发送给故障处理器。&lt;/span&gt;&lt;br/&gt;    OperationResults &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;operationResults,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Checkpoint 是恢复未完成诊断的检查点。&lt;/span&gt;&lt;br/&gt;    Checkpoint *Checkpoint &lt;span&gt;`json:&quot;checkpoint,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// DiagnosisCondition 包含 Diagnosis 当前的服务状态。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; DiagnosisCondition &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Type 是状况的类型。&lt;/span&gt;&lt;br/&gt;    Type DiagnosisConditionType &lt;span&gt;`json:&quot;type&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Status 是状况的状态。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 可以是 True、False、Unknown。&lt;/span&gt;&lt;br/&gt;    Status corev1.ConditionStatus &lt;span&gt;`json:&quot;status&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// LastTransitionTime 描述了上一次从某个状况迁移到另一个状况的时间。&lt;/span&gt;&lt;br/&gt;    LastTransitionTime metav1.Time &lt;span&gt;`json:&quot;lastTransitionTime,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Reason 是对上一次状况迁移的描述，该原因描述是唯一的、只包含单个词语的、符合驼峰命名法的。&lt;/span&gt;&lt;br/&gt;    Reason &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;reason,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Message 是描述上一次状况迁移细节的信息。&lt;/span&gt;&lt;br/&gt;    Message &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;message,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Checkpoint 是恢复未完成诊断的检查点。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Checkpoint &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// PathIndex 是当前路径在 OperationSet 状态中的序号。&lt;/span&gt;&lt;br/&gt;    PathIndex &lt;span&gt;int&lt;/span&gt; &lt;span&gt;`json:&quot;pathIndex&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// NodeIndex 是当前顶点在路径中的序号。&lt;/span&gt;&lt;br/&gt;    NodeIndex &lt;span&gt;int&lt;/span&gt; &lt;span&gt;`json:&quot;nodeIndex&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// DiagnosisPhase 是描述当前 Diagnosis 状况的标签。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; DiagnosisPhase &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// DiagnosisConditionType 是 Diagnosis 状况类型的合法值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; DiagnosisConditionType &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Diagnosis 的 API 对象。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Diagnosis &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    metav1.TypeMeta   &lt;span&gt;`json:&quot;,inline&quot;`&lt;/span&gt;&lt;br/&gt;    metav1.ObjectMeta &lt;span&gt;`json:&quot;metadata,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    Spec   DiagnosisSpec   &lt;span&gt;`json:&quot;spec,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    Status DiagnosisStatus &lt;span&gt;`json:&quot;status,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;管理诊断状态的迁移&lt;/h4&gt;&lt;p&gt;诊断实际上是一个有状态的任务，在诊断的生命周期中其状态可能发生多次迁移，管理诊断状态迁移的能力在很多场景中是必不可少的。&lt;/p&gt;&lt;p&gt;某个操作可能依赖特定格式的输入。Diagnosis 中的 &lt;code&gt;.spec.parameters&lt;/code&gt; 字段用于指定诊断过程中需要传入的参数。该字段是一个键值对，键和值均必须为 String 类型。当执行的操作依赖特定格式的输入时，用户可以在该字段中定义操作执行时需要输入的参数，操作处理器在获取参数后执行诊断操作。&lt;/p&gt;&lt;p&gt;某个操作可能依赖某个之前操作的输出。Diagnosis 中的 &lt;code&gt;.status.operationResults&lt;/code&gt; 字段用于记录诊断运行过程中操作的结果。该字段是一个键值对，键和值均必须为 String 类型。当前操作执行的结果必须以 JSON 对象的形式返回，返回结果会被更新到该字段中，如果后续操作的执行依赖当前操作的输出，那么后续操作处理器可以从 &lt;code&gt;.status.operationResults&lt;/code&gt; 中获取当前操作的结果。值得注意的是，如果在排查路径中如果有两个相同的操作对同一个键进行了更新，那么后执行操作的结果会覆盖先执行操作的结果。&lt;/p&gt;&lt;p&gt;用户需要分析排查路径中某个操作的结果并进行优化。Diagnosis 中的 &lt;code&gt;.status.failedPath&lt;/code&gt; 字段和 &lt;code&gt;.status.succeededPath&lt;/code&gt; 字段分别记录了所有运行失败的路径和成功的路径。每条路径由一个数组表示，数组的元素中包含顶点的序号和操作名。通过遍历路径可以还原操作执行的顺序，每个操作结果的访问信息被记录在 Operation 中的 &lt;code&gt;.spec.storage&lt;/code&gt; 字段。&lt;/p&gt;&lt;h4&gt;Diagnosis 阶段&lt;/h4&gt;&lt;p&gt;Diagnosis 包含 &lt;code&gt;.status.phase&lt;/code&gt; 字段，该字段是 Diagnosis 在其生命周期中所处位置的简单宏观概述。该阶段并不是对 Diagnosis 状态的综合汇总，也不是为了成为完整的状态机。Diagnosis 阶段的数量和含义是严格定义的。除了本文档中列举的内容外，不应该再假定 Diagnosis 有其他的阶段值。&lt;/p&gt;&lt;p&gt;下面是 &lt;code&gt;.status.phase&lt;/code&gt; 可能的值：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Pending：Diagnosis 已被系统接受，但诊断执行前的准备工作还未完成。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Running：Diagnosis 已经绑定到了某个节点，至少有一个诊断操作正处于运行状态。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Succeeded：诊断流水线中某个路径中的所有诊断操作均执行成功。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Failed：诊断流水线中的所有路径失败。也就是说，所有路径中最后一个执行的诊断操作返回码非 200。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Unknown：因为某些原因无法取得 Diagnosis 的状态。这种情况通常是因为与 Diagnosis 所在主机通信失败。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;基于图的诊断流水线&lt;/h3&gt;&lt;p&gt;我们在设计基于图的诊断流水线时主要考虑了以下假设条件：&lt;/p&gt;&lt;p&gt;KubeDiag 通过引入下列 API 对象实现了基于图的诊断流水线：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Operation：描述如何在诊断流水线中加入处理顶点以及如何存储该处理顶点产生的结果。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;OperationSet：表示诊断过程状态机的有向无环图。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Trigger：描述如何通过 Prometheus 报警或 Kubernetes 事件触发一次诊断。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Operation 对象&lt;/h4&gt;&lt;p&gt;Operation 对象的数据结构如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// OperationSpec 定义了 Operation 的目标状态。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;OperationSpec&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Processor 描述了如何在 KubeDiag 中注册一个操作处理器。&lt;/span&gt;&lt;br/&gt;    Processor Processor `json:&lt;span&gt;&quot;processor&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Dependences 是所有被依赖且必须预先执行的诊断操作列表。&lt;/span&gt;&lt;br/&gt;    Dependences []string `json:&lt;span&gt;&quot;dependences,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Storage 表示操作处理结果的存储类型。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果该字段为空，那么操作处理结果不会被保存。&lt;/span&gt;&lt;br/&gt;    Storage *Storage `json:&lt;span&gt;&quot;storage,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Processor 描述了如何在 KubeDiag 中注册一个操作处理器。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Processor&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ExternalAddress 是操作处理器的监听地址。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果该字段为空，那么默认为 KubeDiag Agent 的地址。&lt;/span&gt;&lt;br/&gt;    ExternalAddress *string `json:&lt;span&gt;&quot;externalAddress,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// ExternalPort 是操作处理器的服务端口。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果该字段为空，那么默认为 KubeDiag Agent 的服务端口。&lt;/span&gt;&lt;br/&gt;    ExternalPort *int32 `json:&lt;span&gt;&quot;externalPort,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Path 是操作处理器服务的 HTTP 路径。&lt;/span&gt;&lt;br/&gt;    Path *string `json:&lt;span&gt;&quot;path,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Scheme 是操作处理器服务的协议。&lt;/span&gt;&lt;br/&gt;    Scheme *string `json:&lt;span&gt;&quot;scheme,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// 操作处理器超时的秒数。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 默认为 30 秒。最小值为 1。&lt;/span&gt;&lt;br/&gt;    TimeoutSeconds *int32 `json:&lt;span&gt;&quot;timeoutSeconds,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Storage 表示操作结果的存储类型。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Storage&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// HostPath 表示宿主机上的目录。&lt;/span&gt;&lt;br/&gt;    HostPath *HostPath `json:&lt;span&gt;&quot;hostPath,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// HostPath 表示宿主机上的目录。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;HostPath&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 宿主机上目录的路径。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果该字段为空，那么默认为 KubeDiag Agent 的数据根目录。&lt;/span&gt;&lt;br/&gt;    Path string `json:&lt;span&gt;&quot;path&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Operation 的 API 对象。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Operation&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    metav1.TypeMeta   `json:&lt;span&gt;&quot;,inline&quot;&lt;/span&gt;`&lt;br/&gt;    metav1.ObjectMeta `json:&lt;span&gt;&quot;metadata,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;    Spec OperationSpec `json:&lt;span&gt;&quot;spec,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;OperationSet 对象&lt;/h4&gt;&lt;p&gt;OperationSet 对象的数据结构如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// OperationSetSpec 定义了 OperationSet 的目标状态。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;OperationSetSpec&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// AdjacencyList 包含有向无环图中所有表示诊断操作的顶点。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 数组的第一个顶点表示诊断的开始而不是某个特定的诊断操作。&lt;/span&gt;&lt;br/&gt;    AdjacencyList []Node `json:&lt;span&gt;&quot;adjacencyList&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Node 是有向无环图中的一个顶点。它包含序号和操作名。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ID 是该顶点的唯一标识符。&lt;/span&gt;&lt;br/&gt;    ID int `json:&lt;span&gt;&quot;id&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// To 是从该顶点能够直接到达的顶点序号列表。&lt;/span&gt;&lt;br/&gt;    To NodeSet `json:&lt;span&gt;&quot;to,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Operation 是在该顶点运行的操作名。&lt;/span&gt;&lt;br/&gt;    Operation string `json:&lt;span&gt;&quot;operation&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Dependences 是所有被依赖且必须预先执行的诊断操作 ID 列表。&lt;/span&gt;&lt;br/&gt;    Dependences []int `json:&lt;span&gt;&quot;dependences,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// NodeSet 是一组顶点序号。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;NodeSet&lt;/span&gt;&lt;/span&gt; []int&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// OperationSetStatus 定义了 OperationSet 的实际状态。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;OperationSetStatus&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Paths 是有向无环图中所有诊断路径的集合。&lt;/span&gt;&lt;br/&gt;    Paths []Path `json:&lt;span&gt;&quot;paths,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// 表示定义中提供的顶点是否能生成合法的有向无环图。&lt;/span&gt;&lt;br/&gt;    Ready &lt;span&gt;bool&lt;/span&gt; `json:&lt;span&gt;&quot;ready,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Path 表示与所有边方向一致的顶点线性顺序。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Path&lt;/span&gt;&lt;/span&gt; []Node&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// OperationSet 的 API 对象。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;OperationSet&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    metav1.TypeMeta   `json:&lt;span&gt;&quot;,inline&quot;&lt;/span&gt;`&lt;br/&gt;    metav1.ObjectMeta `json:&lt;span&gt;&quot;metadata,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;    Spec OperationSetSpec `json:&lt;span&gt;&quot;spec,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    Status OperationSetStatus `json:&lt;span&gt;&quot;status,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;Trigger 对象&lt;/h4&gt;&lt;p&gt;Trigger 对象的数据结构如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// TriggerSpec 定义了 Trigger 的目标状态。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;TriggerSpec&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// OperationSet 是生成 Diagnosis 中引用的 OperationSet 名。&lt;/span&gt;&lt;br/&gt;    OperationSet string `json:&lt;span&gt;&quot;operationSet&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// SourceTemplate 是用于生成 Diagnosis 的模板源。&lt;/span&gt;&lt;br/&gt;    SourceTemplate SourceTemplate `json:&lt;span&gt;&quot;sourceTemplate&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// SourceTemplate 描述用于生成 Diagnosis 的信息。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;SourceTemplate&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 下列源中必须指定一个唯一的模板源。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// PrometheusAlertTemplate 声明基于 Prometheus 报警创建 Diagnosis 的模板。&lt;/span&gt;&lt;br/&gt;    PrometheusAlertTemplate *PrometheusAlertTemplate `json:&lt;span&gt;&quot;prometheusAlertTemplate,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// KubernetesEventTemplate 声明基于 Event 创建 Diagnosis 的模板。&lt;/span&gt;&lt;br/&gt;    KubernetesEventTemplate *KubernetesEventTemplate `json:&lt;span&gt;&quot;kubernetesEventTemplate,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// PrometheusAlertTemplate 声明基于 Prometheus 报警创建 Diagnosis 的模板。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;PrometheusAlertTemplate&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Regexp 是用于匹配 Prometheus 报警模板的正则表达式。&lt;/span&gt;&lt;br/&gt;    Regexp PrometheusAlertTemplateRegexp `json:&lt;span&gt;&quot;regexp&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// NodeNameReferenceLabel 指定用于设置 Diagnosis 的 &quot;.spec.nodeName&quot; 字段的标签键。&lt;/span&gt;&lt;br/&gt;    NodeNameReferenceLabel model.LabelName `json:&lt;span&gt;&quot;nodeNameReferenceLabel&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// PodNamespaceReferenceLabel 指定用于设置 Diagnosis 的 &quot;.spec.podReference.namespace&quot; 字段的标签键。&lt;/span&gt;&lt;br/&gt;    PodNamespaceReferenceLabel model.LabelName `json:&lt;span&gt;&quot;podNamespaceReferenceLabel,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// PodNameReferenceLabel 指定用于设置 Diagnosis 的 &quot;.spec.podReference.name&quot; 字段的标签键。&lt;/span&gt;&lt;br/&gt;    PodNameReferenceLabel model.LabelName `json:&lt;span&gt;&quot;podNameReferenceLabel,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// ContainerReferenceLabel 指定用于设置 Diagnosis 的 &quot;.spec.podReference.container&quot; 字段的标签键。&lt;/span&gt;&lt;br/&gt;    ContainerReferenceLabel model.LabelName `json:&lt;span&gt;&quot;containerReferenceLabel,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// ParameterInjectionLabels 指定需要注入到 &quot;.spec.parameters&quot; 字段的标签键列表。&lt;/span&gt;&lt;br/&gt;    ParameterInjectionLabels []model.LabelName `json:&lt;span&gt;&quot;parameterInjectionLabels,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// PrometheusAlertTemplateRegexp 是用于匹配 Prometheus 报警模板的正则表达式。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 所有的正则表达式必须遵循 RE2 规范，详情可参考 https://golang.org/s/re2syntax。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;PrometheusAlertTemplateRegexp&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// AlertName 是用于匹配 Prometheus 报警的 AlertName 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    AlertName string `json:&lt;span&gt;&quot;alertName,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Labels 是用于匹配 Prometheus 报警的 Labels 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 只有标签的值为正则表达式并且所有标签均与 Prometheus 报警一致时才可以成功匹配。&lt;/span&gt;&lt;br/&gt;    Labels model.LabelSet `json:&lt;span&gt;&quot;labels,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Annotations 是用于匹配 Prometheus 报警的 Annotations 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 只有注解的值为正则表达式并且所有注解均与 Prometheus 报警一致时才可以成功匹配。&lt;/span&gt;&lt;br/&gt;    Annotations model.LabelSet `json:&lt;span&gt;&quot;annotations,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// StartsAt 是用于匹配 Prometheus 报警的 StartsAt 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    StartsAt string `json:&lt;span&gt;&quot;startsAt,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// EndsAt 是用于匹配 Prometheus 报警的 EndsAt 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    EndsAt string `json:&lt;span&gt;&quot;endsAt,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// GeneratorURL 是用于匹配 Prometheus 报警的 GeneratorURL 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    GeneratorURL string `json:&lt;span&gt;&quot;generatorURL,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// KubernetesEventTemplate 声明基于 Event 创建 Diagnosis 的模板。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;KubernetesEventTemplate&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Regexp 是用于匹配 Event 模板的正则表达式。&lt;/span&gt;&lt;br/&gt;    Regexp KubernetesEventTemplateRegexp `json:&lt;span&gt;&quot;regexp&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// KubernetesEventTemplateRegexp 是用于匹配 Event 模板的正则表达式。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 所有的正则表达式必须遵循 RE2 规范，详情可参考 https://golang.org/s/re2syntax。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;KubernetesEventTemplateRegexp&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Name 是用于匹配 Event 的 Name 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    Name string `json:&lt;span&gt;&quot;name,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Namespace 是用于匹配 Event 的 Namespace 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    Namespace string `json:&lt;span&gt;&quot;namespace,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Reason 是用于匹配 Event 的 Reason 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    Reason string `json:&lt;span&gt;&quot;reason,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Message 是用于匹配 Event 的 Message 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    Message string `json:&lt;span&gt;&quot;message,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Source 是用于匹配 Event 的 Source 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 所有 Source 中的字段均为正则表达式。&lt;/span&gt;&lt;br/&gt;    Source corev1.EventSource `json:&lt;span&gt;&quot;source,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Trigger 的 API 对象。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Trigger&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    metav1.TypeMeta   `json:&lt;span&gt;&quot;,inline&quot;&lt;/span&gt;`&lt;br/&gt;    metav1.ObjectMeta `json:&lt;span&gt;&quot;metadata,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;    Spec TriggerSpec `json:&lt;span&gt;&quot;spec,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;注册诊断操作&lt;/h4&gt;&lt;p&gt;诊断操作表示在诊断流水线中运行的某个逻辑，是对诊断流水线管理的最小单元，例如获取节点信息、对日志中的关键字进行匹配、对进程进行性能剖析等。通过创建 Operation 对象可以注册诊断操作。诊断操作的后端是一个 HTTP 服务器。注册诊断操作时需要指定 HTTP 服务器监听的地址、路径、诊断结果的存储类型等。&lt;/p&gt;&lt;h4&gt;注册诊断流水线&lt;/h4&gt;&lt;p&gt;诊断流水线是多个诊断操作的集合，通常一次诊断可能有多个排查路径，所以一次诊断的状态机通过有向无环图进行抽象。通过创建 OperationSet 对象可以定义表示诊断状态机的有向无环图。诊断开始的状态为有向无环图的起点，有向无环图中的路径均为诊断过程中的排查路径，当某条路径可以成功运行到终点时则表示诊断运行成功。诊断流水线的生成逻辑如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;用户创建 OperationSet 资源并定义有向无环图中所有的边。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;根据 OperationSet 的定义构建有向无环图。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果无法构建合法的有向无环图，则将注册失败的状态和失败原因更新到 OperationSet 中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;枚举 OperationSet 中所有的诊断路径并更新到 OperationSet 中。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;表示诊断流水线的有向无环图必须只包含一个源顶点（Source Node），该顶点用于表示诊断的开始状态且不包含任何诊断操作。诊断路径是任何从源顶点到任意阱顶点（Sink Node）的路径。诊断路径不包括表示诊断的开始状态的源顶点。图构建器通过搜索出有向无环图中所有的诊断路径并更新至 OperationSet 的 &lt;code&gt;.status.paths&lt;/code&gt; 字段。&lt;/p&gt;&lt;h4&gt;触发诊断&lt;/h4&gt;&lt;p&gt;Diagnosis 对象的元数据中包含了需要执行的 OperationSet。触发诊断包括手动和自动两种方式。通过手动创建 Diagnosis 对象可以直接触发诊断。通过创建 Trigger 对象并配置 Prometheus 报警模板或 Event 模板可以基于 Prometheus 或 Event 自动生成 Diagnosis 以触发诊断流水线。&lt;/p&gt;&lt;h4&gt;运行诊断流水线&lt;/h4&gt;&lt;p&gt;Diagnosis 对象的元数据中记录了诊断流水线的运行状态。诊断流水线的运行逻辑如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;获取被 Diagnosis 引用的 OperationSet 中所有的诊断路径。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;按照诊断执行路径中 Operation 定义的诊断操作，将 Operation 运行的结果更新到 Diagnosis 中并持久化到 Operation 中相应的存储类型。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果路径中定义的某个诊断操作执行失败，则执行下一条诊断路径。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果路径中定义的所有诊断操作均执行成功，则该次诊断成功。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果所有路径均无法成功，则该次诊断失败。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3493975903614458&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaOz7l1bIBYA2ibCpPz4SSMpB7emIibZtQSJxhDBBypKiaKTcOibiaq8tkxeUS00Pk1SAcQ4ZaxsaUXjGFqvwbEEzZJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;&lt;p&gt;上列为一个表示诊断流水线的有向无环图，每个节点代表一个 Operation，该图的诊断路径表示多个可执行的排查路径：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;数据收集 1、数据分析 1、恢复 1&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据收集 1、数据分析 1、恢复 2&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据收集 2、数据分析 2、恢复 2&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据收集 3、数据收集 4&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;典型用例&lt;/h3&gt;&lt;p&gt;下列文件定义了一个用于处理 Docker 问题的 OperationSet：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;diagnosis.kubediag.org/v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;OperationSet&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;docker-debugger&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;adjacencyList:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;to:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;operation:&lt;/span&gt; &lt;span&gt;docker-info-collector&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;to:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;operation:&lt;/span&gt; &lt;span&gt;dockerd-goroutine-collector&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;to:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;operation:&lt;/span&gt; &lt;span&gt;containerd-goroutine-collector&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;to:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;operation:&lt;/span&gt; &lt;span&gt;node-cordon&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一次通过 KubeletPlegDurationHigh 报警触发 Docker 问题诊断的流程如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;用户成功创建处理 Docker 问题的 OperationSet。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户成功创建基于 KubeletPlegDurationHigh 报警触发诊断的 Trigger&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;KubeletPlegDurationHigh 报警被发送至 KubeDiag Master。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;KubeDiag Master 根据报警中的信息创建 Diagnosis。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Diagnosis 在触发报警的节点上执行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;诊断执行结束。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.638594802694899&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaOz7l1bIBYA2ibCpPz4SSMpB7emIibZtQSd97pOP0V8bFicY1ZEs7y6ibAQiaqO7wbtg4zpWQPE12eTeMZpcQic1rfpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;4156&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;欢迎加入 KubeDiag 社区&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;最后，KubeDiag 社区目前还在草创阶段，欢迎大家踊跃加入 KubeDiag 社区，共同提升 Kubernetes 的自动化程度，解决后容器时代的使用难题，推动云原生技术在全球落地应用。&lt;/p&gt;&lt;p&gt;&lt;span&gt;KubeDiag 项目主页：https://kubediag.org/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;KubeDiag 项目地址：https://github.com/kubediag/kubediag&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫码加入 KubeDiag 微信群：https://kubediag.nos-eastchina1.126.net/QR%20Code.jpeg&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网易数帆开源开源主页：https://sf.163.com/opensource&lt;/span&gt;&lt;/p&gt;&lt;p&gt;作者：黄久远，网易数帆云原生技术专家，KubeDiag Maintainer。&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934837&quot; data-style-type=&quot;&quot;&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section data-id=&quot;90196&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934821&quot; data-style-type=&quot;&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-xmtstyleindex=&quot;0&quot; data-xmt-x1=&quot;381.5&quot; data-xmt-y1=&quot;4647.640625&quot; data-xmt-x2=&quot;1058.5&quot; data-xmt-y2=&quot;5940.220625&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-style=&quot;margin-top: -10px; padding-right: 10px; padding-left: 10px; font-size: 16px; color: black; line-height: 1.6; letter-spacing: 0px; word-break: break-word; overflow-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif;&quot; data-xmt-x1=&quot;381.5&quot; data-xmt-y1=&quot;4647.640625&quot; data-xmt-x2=&quot;1038.5&quot; data-xmt-y2=&quot;5940.220625&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); font-family: 微软雅黑; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-role=&quot;paragraph&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94252&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot;&gt;&lt;h4&gt;关于云原生社区&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934837&quot; data-style-type=&quot;&quot;&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section data-id=&quot;90196&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934837&quot; data-style-type=&quot;&quot;&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section data-id=&quot;90196&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;云原生社区是国内最大的独立第三方云原生终端用户和泛开发者社区，由 CNCF 大使、开源意见领袖共同发起成立于 2020 年 5 月 12 日，提供云原生专业资讯，促进云原生产业发展。云原生社区基于成员兴趣创建了多个 SIG（特别兴趣小组），如 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649382008&amp;amp;idx=2&amp;amp;sn=8329de15872f67151e76e4dc2ece84eb&amp;amp;chksm=f224d617c5535f015e3d71a3d21c234bc333653792c85646c13b2a260a4ac2381e06fc0bf8f4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kubernetes&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Kubernetes&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384221&amp;amp;idx=2&amp;amp;sn=04c5062a448e9696e9296a02e82837c3&amp;amp;chksm=f224ef72c553666444b33121ae42dbf4e7609574c29e4c55b84f9f6e2cb5bae88a037f2248d2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Istio&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384308&amp;amp;idx=2&amp;amp;sn=6188dfb44c7a7313a252879a0044b406&amp;amp;chksm=f224ef1bc553660df3b77ff63bd969a4aec56fc5a64a5cf202fb56a507fa0b13588f56384b4e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Envoy&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384308&amp;amp;idx=3&amp;amp;sn=c144874967206a7d0abe0b66e36cc03f&amp;amp;chksm=f224ef1bc553660d9f32e206c5a9e1424a60f49ced76b3d5925d0bffa09eacbe14b1da8b512a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Dapr&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384269&amp;amp;idx=2&amp;amp;sn=baaa3c95835c663c7141406b8ac1293b&amp;amp;chksm=f224ef22c553663436fcbeab26d97abe166f82b8880fc5531d2157ab89b760457ba8664a1d39&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;OAM&lt;/a&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384175&amp;amp;idx=1&amp;amp;sn=ea9058418afd668967e28a3ba211d649&amp;amp;chksm=f224ee80c5536796af57f48c8ee7e242a2b1478645ce823d711be263587576362744eac8121d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;边缘计算&lt;/a&gt;&lt;span&gt;、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384137&amp;amp;idx=1&amp;amp;sn=d14055b1b5408a30db96d8e132a046ab&amp;amp;chksm=f224eea6c55367b0058a971ea579e9b1f7cb70e3d39eb4f36b64f9cab924a2b4c3fc845681f2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;机器学习&lt;/a&gt;&lt;span&gt;、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649383872&amp;amp;idx=1&amp;amp;sn=b6a3c43ce750ea923fed04592c5b7cfd&amp;amp;chksm=f224e9afc55360b912fd2e0d1a9ab4cc66a22deb81db8f07bc3a83146f370cb388ae53c44ef6&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;可观察性&lt;/a&gt;&lt;span&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384467&amp;amp;idx=3&amp;amp;sn=9a8fe5c24d9458d0113c59604b6ab5e8&amp;amp;chksm=f224ec7cc553656aa33f3304608cc24423d3aca7f0d64ae9e50da2850ce5c4df0d4ff9cc013f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;稳定性&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;稳定性&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649385565&amp;amp;idx=2&amp;amp;sn=e3a6a1adf84c3ac9e552ba0c2b18d162&amp;amp;chksm=f224e032c5536924c330945872154b83245b19f91c401e21eddd882791c64b914d68fd51a93e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;安全&lt;/a&gt;等&lt;/span&gt;&lt;span&gt;。&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649383149&amp;amp;idx=3&amp;amp;sn=6012d51c80d0b8f84db58e514448ad11&amp;amp;chksm=f224ea82c553639460af375bb1f172ba94502c5599eb2a4e4df52287f98db29e3858ae09373d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点击了解我们&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;点击了解我们&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI1NTE2NDE2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/06ULcDvaIGmqt5TicIcR8qFEjicfezMe4YuBlNbN8vl8Mh1fePHOrPibvlqJseGaG4ctibamAhKHMP3xOEW3ByibOjw/0?wx_fmt=png&quot; data-nickname=&quot;Cloud Native Community&quot; data-alias=&quot;CloudNativeCN&quot; data-signature=&quot;云原生社区是国内最大的独立第三方云原生终端用户和泛开发者社区，由 CNCF 大使、开源意见领袖共同发起成立于 2020 年 5 月 12 日，提供云原生专业资讯，促进云原生产业发展。社区官网 https://cloudnative.to&quot; data-from=&quot;1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;点击下方“阅读原文”查看更多&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>05a056aa65796ad709a50dcd3f7f0fe1</guid>
<title>反驳：Rust 是 Go 应该成为的样子？</title>
<link>https://toutiao.io/k/71t4gxq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;作为两门服务端的新&lt;/span&gt;&lt;span&gt;语言，这些年受到越来越多的关注。&lt;/span&gt;&lt;span&gt;有人调侃说，关注 Rust 的人中，很大一部分是从 Go 过来的。&lt;/span&gt;&lt;span&gt;经常有人因为 Go 的一些设计和特质而质疑它，同时，Rust 常被誉为解决 Go 问题的几乎完美设计的替代方案。&lt;/span&gt;&lt;span&gt;但实际上，这两门语言并不是直接竞争关系，不能直接互换，更多是互补。&lt;/span&gt;&lt;span&gt;本文就带着大家看看两者的不同。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一篇文章 《I want off Mr. Golang&#x27;s Wild Ride》：https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride，以及围绕它的激烈讨论，不止一次遇到过诸如“Rust 是 Go 应该成为的样子”之类的陈述。这些讨论中观点，显然是由那篇文章推动的，似乎反应出 Go 有太多有问题的特性，而另一方面，Rust 是一个精心设计的 Go 替代品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我看来，这篇文章的讨论揭示了对这两种语言、它们解决的问题以及它们所针对的软件开发范式的严重误解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;01 文章对 Go 的批评&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章主要批评 Go 的简单是一个谎言：标准库中的 API 向用户隐藏了复杂性，而没有真正解决它，这在极端情况下会产生完全错误的结果。以 Go 的&lt;code&gt;filepath.Ext&lt;/code&gt;函数为例：它在某些情况下会产生不准确的结果。作为反例，这篇文章提到了 Rust&lt;code&gt;std::path::extension&lt;/code&gt; 是产生完全正确结果的函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种对 Go 在边缘情况下不准确的不满似乎是可以理解的。我们都知道，在编程中，只有正确和不正确，没有其他结果。因此，由于 Rust 提供了正确的结果，它显然是更好的语言。但事情真的这么简单吗？难道谷歌不能聘请高手来解决这个问题吗？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;02 追根溯源&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 和 Rust 被频繁地比较，因为它们都被宣传为系统编程语言，而且它们都是现代的编程语言，发布时间接近。但是，一旦你内化了它们的来源以及它们的设计目的，你很快就会发现它们是两种完全不同的语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 是一个 Google 项目，主要设计用于后端和网络服务。这些服务在可预测的、同质的、Unix 等基础设施中运行。谷歌完全控制着他们的基础设施，潜在的性能瓶颈可以通过在问题上投入更多的服务器来解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一方面，Rust 是由 Mozilla 在非常不同的情况下启动的。Firefox 和 Servo 等项目是非常长寿的软件产品，必须在各种系统上运行。他们必须在不均匀、未知且可能充满恶意的环境中工作。因此，在每个系统上产生完全相同的结果对于这些应用程序至关重要。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;03 不同的问题，不同的语言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;谷歌和许多其他维护类似基础设施的公司通常必须应对以下挑战——虽然我对谷歌没有深入的了解，但其中一些可能被其庞大的规模放大了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;开发人员流动率高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;短迭代中的快节奏开发。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;快节奏的组织扩展。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高度动态的基础设施和环境。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;短期和可替换的服务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Google 需要一种完全针对这些挑战量身定制的语言，并且不可避免地会设计出与满足 Mozilla 需求的语言不同的语言。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;04 另一种范式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 和 Rust 不仅有不同的语言设计，它们还包含一种相反的软件开发方法。Rust 专注于高效率并为问题找到最漂亮的实现。为了实现这一点，与其他语言相比，它有着更陡峭的学习曲线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比之下——这就是大部分行业的现实——谷歌和许多其他公司不希望他们的开发人员在他们能够高效工作之前花 3 个月时间学习一门新语言。因此，Go 被有意设计为一种快速学习和使用的语言。它不一定是最有效或最漂亮的解决方案。它甚至不必在公司不使用的系统上工作。它只需要工作得足够好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么？因为运行动态基础设施需要高度的自动化、标准化、监控、可观察性、弹性、可扩展性和安全性。对于不在这样的环境中工作的开发人员来说，这听起来可能很奇怪，但在日常业务中，重点往往是这些高级需求而不是代码本身。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;05 底线&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管乍一看 Go 和 Rust 似乎为类似场景提供了类似的好处，但它们是针对不同问题而设计的专业工具。就像大多数其他工具一样，一个并非比另一个“更好”。在寻找适合自己需求的新语言时，Google 和 Mozilla 都没有采取有偏见的方法。他们只是努力寻找最适合他们的解决方案——你也应该如此。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://dominikbraun.io/blog/the-difference-between-go-and-rust/&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-fileid=&quot;503967151&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>