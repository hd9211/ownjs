<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3993bbe28ee4164e43abb808086c8393</guid>
<title>30 岁的程序员出路在哪里？| 码农周刊第 321 期</title>
<link>https://toutiao.io/k/qdeuemt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;30 岁的程序员出路在哪里？| 码农周刊第 321 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第321期（2020-10-15）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=321&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3210&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=321&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3210&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=321&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;最佳实践&lt;/p&gt;
        
        &lt;p&gt;偏好模型在贝壳的应用&lt;/p&gt;
        
        &lt;p&gt;实战经验&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;共包含 9 种英伟达开发的图像及视频合成方法&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;以 DDD 思想为基础，融合中台核心要素，赋能中台建设。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;开箱即用的中后台前端/设计解决方案&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;细致讲解&lt;/p&gt;
        
        &lt;p&gt;无废话&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;适合入门&lt;/p&gt;
        
        &lt;p&gt;多维度看问题&lt;/p&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://github.com/streamnative/mop&quot; target=&quot;_blank&quot;&gt;GitHub 地址&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;通俗易懂&lt;/p&gt;
        
        &lt;p&gt;适合新手&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;完备分析&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;通俗易懂&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;细致分析&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一线互联网工程师，分享Linux C++ Go Python等后端开发技术。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444675 即可&lt;/p&gt;
        
        &lt;p&gt;老年程序猿，工作15年以上。以前极其不擅长写作，最近决定对着弱点迎难而上，写写原创的经验、心得。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 426740 即可&lt;/p&gt;
        
        &lt;p&gt;分享一些在 ThinkJS 项目开发过程中总结的一些经验以及问题&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 253319 即可&lt;/p&gt;
        
        &lt;p&gt;专注互联网金融&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 26661 即可&lt;/p&gt;
        
        &lt;p&gt;主要是分享作为一个机器学习算法工程师的工作学习生活方面的内容，包括Python编程、机器学习和深度学习算法知识，偶尔可能分享一些计算机基础方面的知识，以及一些练习项目等&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 1584 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书介绍了 Kotlin 的基本语法、常用类型、面向对象编程以及一些高阶的知识。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;天无绝程序员之路&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验之谈&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cc9c3236829aef4ac1af5341c51ccbb5</guid>
<title>[译] 50+ 有用的 DevOps 工具（一）</title>
<link>https://toutiao.io/k/lo4v773</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;原文: https://dzone.com/articles/50-useful-devops-tools?edition=627291&amp;amp;utm_medium=email&amp;amp;utm_source=dzone&amp;amp;utm_content=50%2B%20useful%20DevOps%20tools&amp;amp;utm_campaign=&lt;/p&gt;&lt;p&gt;翻译: 时序(祝坤荣)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;什么是DevOps?&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;DevOps方法学，是由开发与运维定义的一种软件与团队管理方法，其最初提出是在2009年，之后在IT领域成为了流行的概念。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;DevOps对于使用的的每个人来说都意味着很多东西，它不只是定义好的标准，软件或流程，更是一种文化。Gartner对DevOps的定义是：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;DevOps代表IT文化的变化，通过对敏捷方法的适配并聚焦在快速的IT服务交付，在面向系统方法的情境中实践精益。DevOps鼓励人们(和文化)，寻求改进在运维与开发团队间协同的办法。DevOps实现工具技术 - 特别是可以在研发生命周期中增强编程与动态基础架构的自动化工具。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从以上定义看出，DevOps是软件生命周期(SDLC)的多面方法，它更主要的强项是通过技术与软件来提升SDLC的效率。所以通过使用正确的DevOps方法，尤其是适配其合作的哲学并实现正确的工具，你的业务相对传统方法可以增加大约30倍的部署频率，数据来自CapGemini(https://www.capgemini.com/de-de/wp-content/uploads/sites/5/2016/03/devops-the-future-of-application-lifecycle-automation.pdf)调查。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;工作使用的正确工具&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这份清单想尽可能全面。文档提供了对于DevOps新手的工具，也有最近才在市场上发布的工具- 两种都可对于你和你的业务有帮助。对于已经熟练使用DevOps的你们，我希望你们可以找到对于自己增长中的企业有帮助的内容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于这么多可选择的工具，用哪个是没有“正确的”答案的。没有一个工具可以覆盖你可以用到的各种开发与运维团队中需要用到的东西，让我们在选择会用到的工具前看看什么会有用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• 计划与协作：在你启动SDLC前，你需要对于哪些工具可以在你的团队中可以用于实现要有个统一思想。甚至有DevOps工具可以帮助你完成这一关键步骤。&lt;/p&gt;&lt;p&gt;• 构建：你需要一些工具来创建配置相同环境的工具。你最不想听到的是“但它在我的电脑是好的”&lt;/p&gt;&lt;p&gt;• 自动化：这就是DevOps能给你的，但自动化也能比手工方法更能快速增加生产力。&lt;/p&gt;&lt;p&gt;• 持续集成：工具需要能提供固定和快速的反馈，一天几次，但不是所有集成产品实现都是一样的，你选择的工具是否适合你的需要？&lt;/p&gt;&lt;p&gt;• 部署：部署需要是可预测，平滑，可靠并极小风险的，自动化在这个流程中可以大显身手。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;脑子里记着上面的内容，我希望选择的工具对你的业务有帮助并能扩展到DevOps生命周期。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;工具目录列表：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基础设置既代码&lt;/p&gt;&lt;p&gt;持续集成与交付&lt;/p&gt;&lt;p&gt;开发自动化&lt;/p&gt;&lt;p&gt;可用性测试&lt;/p&gt;&lt;p&gt;数据库与大数据&lt;/p&gt;&lt;p&gt;监控&lt;/p&gt;&lt;p&gt;测试&lt;/p&gt;&lt;p&gt;安全&lt;/p&gt;&lt;p&gt;有用的CLI工具&lt;/p&gt;&lt;p&gt;开发&lt;/p&gt;&lt;p&gt;可视化&lt;/p&gt;&lt;p&gt;&lt;strong&gt;基础设施即代码&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9712918660287081&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4Wy3wc85lBLW0nfFVBGbmOppZtssoBQO7JK8wJwqrwXzicPKadVL0icz5d9JgcEShOnhryhTONwYUthZI2SrUGicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;209&quot;/&gt;&lt;/p&gt;&lt;p&gt;1. AWS CloudFormation&lt;/p&gt;&lt;p&gt;如果你目前正在使用或计划使用AWS云，AWS CloudFormation是一个必选项。CloudFormation让你对你的AWS基础设施进行建模并可以平滑简单地配置所有你的AWS资源。所有东西都可以用JSON或YAML模板文件来实现自动化特性来保证你的部署是可预测，可靠与可管理。&lt;/p&gt;&lt;p&gt;链接：https://aws.amazon.com/cloudformation/&lt;/p&gt;&lt;p&gt;2. Azure Resource Manager&lt;/p&gt;&lt;p&gt;Azure Resource Manager(ARM)是微软对于IAC工具的回答。通过ARM模板，可描述的JSON文件，Azure Resource Manager可以提供你基础设施，处理依赖，声明不同的资源。&lt;/p&gt;&lt;p&gt;链接：https://azure.microsoft.com/en-us/features/resource-manager/&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8212765957446808&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4Wy3wc85lBLW0nfFVBGbmOppZtssoBQO99CENsYzAxU5nYznhVbPQwlqB68T9albV7nU8zZib8q55Hibk8ibQtgFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;235&quot;/&gt;&lt;/p&gt;&lt;p&gt;3. Google Cloud Deployment Manager&lt;/p&gt;&lt;p&gt;跟上面提到的工具类似，Google Cloud Deployment Manager是谷歌为Google云平台准备的IAC工具。这个工具使用YAML作为配置文件，使用JINJA2或PYTHON作为模板。一个关于部署的值得一提的特性是‘预览’，让你可以在提交前看到变更。&lt;/p&gt;&lt;p&gt;链接：https://cloud.google.com/deployment-manager/&lt;/p&gt;&lt;p&gt;4. Terraform&lt;/p&gt;&lt;p&gt;Terraform是HashiCorp(Vault和Nomad的提供者)提供给你的工具。Terraform与以上提到的工具有很大不同，它没有限制到一个具体的云平台，这提供处理复杂分布式应用的能力而不被绑定到一个平台。并且与谷歌云部署管理类似，Terraform也提供了预览功能：&lt;/p&gt;&lt;p&gt;链接：https://www.terraform.io/&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本文来自祝坤荣(时序)的微信公众号「麦芽面包，id「darkjune_think」&lt;/p&gt;&lt;p&gt;转载请注明。&lt;/p&gt;&lt;p&gt;&lt;span&gt;交流&lt;/span&gt;Email: zhukunrong@yeah.net&lt;/p&gt;&lt;p&gt;微博：祝坤荣&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d58b4940a91c6f48bfd61ed4963b975b</guid>
<title>微信研发体系下的分布式配置系统设计概要</title>
<link>https://toutiao.io/k/43s9snk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者：ypaapyyang，腾讯 WXG 后台开发工程师，个人公众号：码农课代表。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文旨在分析分布式配置系统的必要性、可行性，及其关键约束，并介绍一款基于该系列分析，在微信研发体系下的实践尝试。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对很多的业务开发同学而言，对运营素材的处理不是一件轻松的事，通常需要定制化的进行数据的清理、格式的转换、工具的开发。笔者就曾过这样一段不愉快的回忆，为了导入一次性的近十种类型的配置数据，就耗去了两天的时间。如果说这段经历有何价值的话，那就是促使我思考分布式配置系统，并且在工作中实践，使自己避免再次陷入如此槽糕的过程中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文正是旨在分析分布式配置系统的必要性、可行性，及其关键约束，并介绍一款基于该系列分析，在微信研发体系下的实践尝试。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置的定义&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们清楚软件建模的本质是对现实世界（人、事、物及规则）的映射，映射的产出物即包括编程系统和配置。配置为我们提供了&lt;strong&gt;动态修改程序运行时行为的能力&lt;/strong&gt;，即常说的“系统运行时飞行姿态的动态调整”，究其根源则是“我们人类无法掌控和预知一切，映射到软件领域上，我们总是需要对系统的某些功能特性预留出一些控制的线头，以便我们在未来需要的时候，可以人为的拨弄这些线头从而控制系统的行为特征。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，本文所指的配置特指内部运营人员产生的数据（广义的系统运营人员，包括产品、运营、研发等），并且作为输入参数而作用于编程系统（包括实时系统、批跑程序以及数据任务等）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;归纳而言，配置通常包含如下三种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a. 环境配置，定义了应用程序运行的环境相关参数，如 IP、Port 等；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;b. 应用配置，定义了应用程序自身相关的参数或者信息安全控制等，如初始内存分配大小、数据库连接池大小、日志级别、账号密码等；&lt;strong&gt;（密码、证书这类东西肯定不要放在配置系统中，而应当走统一加解密服务）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;c. 业务配置，定义了应用程序所执行的业务行为数据，比如最常见的&lt;strong&gt;功能开关&lt;/strong&gt;，参与活动的商户名单等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;系统约束&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据模型&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置最基本的数据单元是&lt;code&gt;key=value&lt;/code&gt;（即配置项），比如功能开关通常就是最简单的类型，用 boolean 型值来影响程序执行链路（不考虑灰度的情况）。然而只有 key-value 类型是不足的，比如 DB 的连接配置就包含了 ip、port、username、password 等字段，在 ini 文件的实现中即是不同配置项来组成，它们在逻辑上是属于同一个配置对象，因此基于面向对象的设计思路，&lt;code&gt;key=object&lt;/code&gt;才是更通用的配置模型，在物理实现中可以为 json 或者 xml，或者 protobuf message。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;object 类型的数据即可以是&lt;strong&gt;平坦的&lt;/strong&gt;，也可以是&lt;strong&gt;多层次（嵌套）的&lt;/strong&gt;。在实际的业务应用中，&lt;strong&gt;平坦&lt;/strong&gt;类型的数据有其特殊性，即其通常条目较多，最典型的数据是&lt;strong&gt;白名单&lt;/strong&gt;，可能多达上万条。线下，内部运营人员通过&lt;strong&gt;excel&lt;/strong&gt;进行这类数据的管理，如果我们只是粗暴的将其打包成一个对象，那么过大的数据可能会导致系统效率的下降（不是配置的写入效率下降，就是配置读出效率下降），因此我们会使用&lt;code&gt;array of plain object&lt;/code&gt;来表达，即&lt;code&gt;key=table&lt;/code&gt;类型的数据。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;访问模型&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相别于产品用户产生的数据，&lt;strong&gt;配置系统的数据流是单向的，离线系统与实时系统结合而读写分离（异步写、实时读）的&lt;/strong&gt;。最终我们要搭建的分布式配置系统，它的系统设计，也必然是建立在这类访问模型上的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35428571428571426&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlgDzXqicX6ZBiasNcltZ5saclia6dedQAN93IN6HVZUAf4WOJBvcSSh3TA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2100&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;系统约束&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，内部运营人员作为生产者，所有的&lt;strong&gt;配置肯定都是文本类型的（Readable）&lt;/strong&gt;，并且&lt;strong&gt;数据量少&lt;/strong&gt;(相对于用户、系统等生产数据而言），对存储空间需求少，&lt;strong&gt;更新频次低&lt;/strong&gt;。可以这么理解，在整个配置系统架构中，输入方就如同键盘相对于 CPU 而言是超慢速设备，他们对系统的&lt;strong&gt;易用性、易操作性、安全性&lt;/strong&gt;要求更高。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;em&gt;我们思考下用户画像系统，它部分满足配置系统的访问模型，即数据流是单向的，离线系统负责写入画像数据，而实时系统读数据。但是首先它的数据生产者通常是离线任务，而非运营人员；再次，它涉及到的数据量是巨大的，通常需要定制的存储引擎。配置系统与之相比，不可同日而语。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相较而言，配置系统的消费者则是&lt;strong&gt;高频&lt;/strong&gt;的读访问，对系统的&lt;strong&gt;吞吐量&lt;/strong&gt;、&lt;strong&gt;延时&lt;/strong&gt;、&lt;strong&gt;网络流量&lt;/strong&gt;、&lt;strong&gt;可用性、一致性、请求单调性&lt;/strong&gt;都有更高的要求。后续我们逐一展开深入的思考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置系统的设计应当充分考虑到上述的数据模型、访问模型以及系统约束。（比较奇怪的是，笔者在查阅相关配置系统实现时，鲜少看到有针对一致性、请求单调性的讨论。这也是促使笔者撰写本文的原因）&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;安全约束&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正因为配置可以轻易的调整系统运行期行为，因此配置的安全性至关重要。实现安全的必要条件是：&lt;strong&gt;让正确的人，以正确的方式，在正确的时机，发布正确的配置&lt;/strong&gt;。因此，配置系统不但要&lt;strong&gt;支持灰度发布&lt;/strong&gt;的基本能力，还要在&lt;strong&gt;权限管理、权限粒度管理、配置变更审核、审计、历史版本&lt;/strong&gt;等方面都要加强建设。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;系统的演进&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;单机配置文件&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单机系统时代，我们基本上都是使用配置文件来存储配置数据（比如 ini 文件、xml 文件等）。配置文件易于理解、便于实现、可用性高，因此进入分布式集群时代，仍在广泛使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而配置文件存在诸多的缺点，包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;易用性差&lt;/strong&gt;，主要体现为表达的数据类型单一，比如 ini 只能管理配置项，即 key=value 类型数据；而如果使用 xml 文件来管理 key=table 类型数据，那么文件内容的初始化效率低下，容易出错，难以维护；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;可操作性差&lt;/strong&gt;，配置文件基本只能由开发来进行修改并且发布，产品、运营的常规业务素材变更工作就不得不卷入开发执行，对业务的流程效率有严重的影响；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;正确性、安全性难以保障&lt;/strong&gt;，正因为配置文件的易于实现，导致很多团队疏忽了运营系统的建设，研发人员随意修改、恶意修改配置文件的情况无法杜绝，细粒度的权限管理、操作的审核、审计无从谈起；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;发布效率低下&lt;/strong&gt;，配置文件是单机部署的，在集群规模较大的情况下，配置文件的任意变更都需要经过漫长的灰度发布过程发布到全网，如果配置文件是静态加载的，还需要重启二进制，需要消耗研发、运维人员较多的精力；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;文件一致性难以保障&lt;/strong&gt;，在发布配置变更的过程中，如果集群中出现宕机情况，会导致不同机器间的配置出现差异，而没有自动校正的能力，依赖于人员或者运维系统的支持，从而导致业务进入未定义的行为。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24298621017593913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlkicukmCCP39ON0A94aVicxcAMqt5vvlMnQn2u2gibf4y3S4c3qXKTyROw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2103&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说易用性、可操作性、正确性、安全性可以通过搭建运营系统来进行改进，而发布效率低下、文件一致性难以保障则是单机配置文件的致命弱点，究其本质，是因为单机配置文件系统是被动的、离散的接受外界的变更，而没有主动的能力。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;集中式配置文件中心&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此，出现了集中式的配置文件系统，针对性的解决了上述的问题，开发人员将配置文件存储到独立的第三方服务（典型的由 ZooKeeper 进行管理，也有部分团队自行实现微服务管理），然后由 agent 周期性的将配置拉取到本地进行缓存（&lt;strong&gt;拉&lt;/strong&gt;），或者通过事件的订阅通知能力来将变更发布到相应集群（&lt;strong&gt;推&lt;/strong&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.31351094196003804&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlzyMMyKiadSc5IxPWqEjibzfdYpS06vanyEEHfhE2aT8Fw1HQ8QcQ0atQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2102&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集中式配置文件系统针对性的解决了发布变更效率问题以及配置文件一致性保障问题。然而在笔者所知的应用案例中，仍然存在如下的问题亟需解决：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;一致性粒度粗&lt;/strong&gt;，集中式配置文件只能确保分布式集群达到最终一致（时间取决于拉、推的频率及速率），却无法保证任一时刻，对任一配置，所有进程、线程、协程看到相同的数据，而这通常会导致出现不预期的业务失败；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;无法保证请求单调性&lt;/strong&gt;，在一次业务请求中，我们希望用户看到的配置内容是静态的，如果中间发生变更，可能带来业务失败，严重的导致用户数据状态错乱；而基于集中式配置文件系统的配置通常是动态加载的，配置的变更可能随时的反应到实时系统中，导致一次业务请求先后看到不同的数据状态；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;安全性仍无法彻底保障&lt;/strong&gt;，虽然集中式配置文件的修改可以控制权限，但是在消费者机器上，开发者仍然可以手动的修改本地配置文件 cache 来影响程序的运行行为；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;无法支持灰度能力&lt;/strong&gt;，配置文件变更的下发是全量的，如果要支持灰度发布的能力，就需要卷入业务方自行实现；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置文件系统，无论是单机配置文件，还是集中式配置文件，存在的问题，归根结底，是由于配置文件这个载体以及集中式配置文件系统的管道定位决定的，从而导致进行精细化管理的成本高：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;配置文件的可视可读能力对生产者而言是重要的，但对消费者却是无关紧要的，因此全链路都由配置文件作为载体反而可能导致&lt;strong&gt;加载效率低下&lt;/strong&gt;（比如应对千万级黑白名单，或者业务方实时请求链路动态加载）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置文件难以安全、便利管理元信息，为了实现一致性、单调性、安全性，配置需要一些元数据信息管理（下文展开详述），但是配置文件系统没有这种能力，除非业务方使用高成本自行实现；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置文件的数目与配置的数量息息相关，随着时间的发展，&lt;strong&gt;配置文件数目膨胀&lt;/strong&gt;，带来新的运营问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集中式配置文件系统通常只把自己定位成&lt;strong&gt;管道&lt;/strong&gt;（据笔者所知），即不理解也不维护配置文件的内容，agent 功能单一，业务消费方不与系统直接交互，而是只看到配置文件，虽然松耦合可以提高可用性，但也让业务方仍然投入不少的开发成本来处理配置文件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置文件只是配置的物理载体，上述缺点并非无法克服，只是在基于配置文件的配置系统下，实现上述能力的成本高，需要更多的使用约束，以及外围配套。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据库配置存储&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对结构复杂、类型较多的配置，业务研发同学通常也不会直接使用配置文件来承载，而是使用数据库（关系型或非关系型）库表来存储配置，然后再编写工具进行数据的导入。这种存储方案克服了配置文件的部分问题，对配置有更精细化的管理。但是也存在明显的不足，即高度的定制化，不可复用，重复开发高。因此，我们需要对此进行完善，将配置的存储、读、写、管理等过程提炼共性，通用化、平台化。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方案思考&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;物理模型&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然配置文件难以精细化管理，且具备易侵入的物理实体（本地文件），我们需要新的数据结构来承载配置。前文我们讨论过，配置有两种数据模型，分别是&lt;code&gt;key=object&lt;/code&gt;以及&lt;code&gt;key=table&lt;/code&gt;。对使用者而言，配置必须是可视、可读、易管理的。为了达成这目的，我们只需在内部运营人员与配置系统核心之间搭一套设计良好的&lt;strong&gt;运营系统&lt;/strong&gt;即可。那么在后端呢？对消费者而言，最注重传输、计算的效率，同时为了与微服务框架的对齐，&lt;strong&gt;protobuf message&lt;/strong&gt;无疑是最佳的形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而 protobuf 无法自解释，在没有 message 定义的情况下，我们即没办法将文本性的配置转换成 pb 二进制流，也没办法反序列化。因此必须将业务的 message 定义上提到运营系统，然而 protobuf 却对可视化编辑不太友好。因此一个可行的思路是基于&lt;strong&gt;JSON 数据&lt;/strong&gt;进行配置的定义、可视化操作、传输及存储。只有到达业务侧才进行数据类型的转换。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.14469300333174678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlPPCH15korB8frykYMU7VpxfDcicCuIMQ2KmEAMiaUXvbaicZmLSwoVdicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2101&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;安全管理&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搭建一套配置运营系统，让之成为运营人员管理配置的唯一入口，轻松就可以得到很高的回报。我们可以基于运营系统进行各种配置安全加固，如配置的变更必须具备相应的权限，而且只有通过审核才能应用到系统，所有的操作都要有审计的能力，配置的历史版本快速可查等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时灰度、回退等能力也需要基于运营系统进行操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2557142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlpq3KDhJSuzTWVXWic8R7sjnpoDvicndW25gK9rkQr2xnmhe4wj3icBvWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2100&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置系统 SDK&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文提及，集中式配置文件系统的管道定位，agent 只负责定期的拉取配置然后缓存到本地的文件系统。业务系统与配置系统松耦合。我们认为配置文件仍然具有较高的开发成本，对业务方而言，最佳的开发形式应当是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; GetConfig&amp;lt;Message&amp;gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;&amp;amp; key, ::google::protobuf::Message&amp;amp; msg);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而不需要再去理解文件内容、形式。那么我们就有必要为业务方提供一套配置系统的 SDK，将配置系统的细节、数据结构等信息都屏蔽起来，让业务只看到配置的 Protobuf Message 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 SDK 的基础上，消费者只需轻度介入（业务插件，见下），我们就可以完成协议转换、配置缓存、进程，线程，协程快速最终一致、请求单调、灰度发布的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;配置系统 SDK 是精细化管理的基础&lt;/strong&gt;，我们可以通过维护配置本身内容之外的&lt;strong&gt;配置元数据信息&lt;/strong&gt;来完成上述能力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21751546882436934&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlvjlpuupZ9SqXNAFzgwniciakY68sQrgwmGwWlyAthcEficnT2sIvpic90w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2101&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;异步化&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;异步化是配置 SDK 的关键&lt;/strong&gt;。很多本地缓存的更新是周期性的由实时链路请求负责，易于实现，但效率上存在问题，尤其考虑到我们还需要对配置进行配置业务逻辑的处理。因此，最佳方案应当是通过异步过程来进行配置的加载、初始化及其它逻辑处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步带来的问题是异步过程与实时请求的并发问题，即异步过程在进行配置变更过程中，应如何处理实时链路的读请求，这是一个工程问题，我们会另文讨论，一个可行的思路是&lt;strong&gt;多版本及引用计数技术&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37957244655581945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlI9OYbu8UfFJDBncIEzVBDnyfFwxDkF5qG9kFd56YbD9V4fvjiaqooCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2105&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;业务插件&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步为我们提供的另外一个好处是，业务可以在配置生效的时候进行一些初始化动作，比如进行进行&lt;strong&gt;配置正确性校验&lt;/strong&gt;，以及&lt;strong&gt;搭建业务适合的数据结构&lt;/strong&gt;。比如业务白名单在 pb 中只是一个数组，如果业务进行命中查找，代价比较高。业务最期望的方式肯定还是使用 map 来存储。因此配置 SDK 异步化，就为业务插件能力提供了基础。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27423954372623577&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlEe3UuNxQvicQYwGkGbAia0AsZWMInicmVNLdq8kMzhJzH0IdZJy33wSpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2104&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;推与拉&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们更倾向于配置 SDK 主动拉取配置的更新。推与拉的辩证在于效率和可用性。推比较高效，不存在无用的网络消耗。但是推又引入了新的系统依赖（即事件中心）。如无必要，勿增实体，基于这样的思想，我们倾向于由&lt;strong&gt;SDK 周期性主动拉取&lt;/strong&gt;。至于效率，完全可以通过各种工程的手段加以优化，达到可以接受的程度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这也取决于系统规模，如果我们要讨论的是公司机的配置系统，而不是部分中心级，那么我们也会认真的思考推或者推拉结合的模式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;快速最终一致&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是单机配置文件系统，还是集中配置文件系统，都存在严重的不一致问题。对一次配置变更，基本上都需要很长的时间才能达到最终一致（即所有并发看到相同的数据状态）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个可行的思路是&lt;strong&gt;多版本以及定时生效&lt;/strong&gt;。配置只有在未来的某个时间（该时间内 SDK 已经拉到了最新数据）才对外可见。至于如何确保所有 SDK 都拉到了数据，这涉及到可用性的问题，我们另文讨论。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23750594954783436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVl29mZXf7lWEf0pSYuHIcHD02NKhcuiavjcg6adFn2ia2WzIkeia5L0IibVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2101&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;请求单调&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定时生效没办法解决请求单调性的问题。&lt;strong&gt;请求单调性&lt;/strong&gt;是指，实时服务处理一次请求，在请求的调用栈过程中，读到的配置内容必须是静态、没有变动的，即使中间有待生效数据变成了生效数据。一个思路是我们可以通过&lt;strong&gt;线程私有变量&lt;/strong&gt;（协程私有变量）缓存配置版本即可。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;灰度发布&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在配置 SDK 多版本能力的基础上，实现灰度发布的能力也是轻而易举的。灰度发布的能力，不过就是选择生效配置版本的能力，如果本机、本角色、本请求业务 key（如用户、商户、订单）等命中灰度范围，则使用新版本，否则使用原版本。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.25131139723414403&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlAx8MviaG69BBgempD5xMRnAmvObETXCDT9gxow541qCiajNCKObiaFIeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2097&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;效率提升&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效率提升包括降低网络传输数据量、降低配置存储服务的压力，这些都是具体的工程手段，我们不在本理论篇内讨论。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可用性提升&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式系统的可用性提升是老生常谈的话题，为了聚焦于配置系统独特的能力，我们本篇不专门进行讨论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（However，尽量减少系统中的单点，是一个重要的原则。在前节”推与拉“中也有涉及。同时为了业务的可用性，第三方配置系统的运营能力、故障主动发现能力、故障通知能力、再现及定位能力也非常重要。也这是重复造轮子的一个不得已的重要原因，很多团队软件可能作的不错，但服务能力（主要指运营能力）却有点差强人意。）&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;加入我们&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;境外支付团队在不断追求卓越的路上寻找同路人，岗位需求：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://careers.tencent.com/m/jobdesc.html?postId=1298934958332583936&quot; data-linktype=&quot;2&quot;&gt;28605-微信支付境外支付前端开发工程师（深圳）&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10月24日，约你来腾讯滨海大厦&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;3.5164835164835164&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvathJtXibmj1iaEQC217HgGPiawibKQ8coQib2FW96OSmVdOOZrsbtP29pPEwqMLsUx30RI8K66pktzDhpw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;728&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10.16 世界粮食日&lt;/span&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们用AI技术助力了一场光盘行动&lt;/span&gt;&lt;/h4&gt;&lt;span&gt;‍&lt;/span&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAqH0WReF1EgAAAAstQy6ubaLX4KHWvLEZgBPEx6EwJkhHT6L5zNPgMItSRNKrAt6Gsw0ShaWLH3DR&quot; data-url=&quot;https://findermp.video.qq.com/251/20350/stodownload?encfilekey=jEXicia3muM3GjTlk1Z3kYCefzc4VU4EAS349rsIhicRvwqMY1rPNVs7Mr3Zw2uQVyb2m8ASiaPO2kP67BJ4uzUWPzmqibPJLc4rLesJ7PmbCL84RImw611wYdnksbbvLCM1nF2EFKiafW44PT54iabG7F4a1icG6qZ3ibHyODd6oY3kobK0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=a6dea7fde49f377219ff2eab5724d45f&amp;amp;token=x5Y29zUxcibA4jnHycsS44PCgdLMqKXOg3XBUx1pDrvFx4AKhCcF8tWzlsv1SPcqy&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xEecUymmic8cw4v7Y2zbnVDuo/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;拍照也能助力光盘行动？关于节约粮食，大家有什么妙招呢？  @腾讯公益  @微信派 #光盘行动#  #世界粮食日#  #节约粮食#  #技术公益# &quot; data-nonceid=&quot;4871113052233066306&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;‍&lt;/span&gt;欢迎关注视频号 腾讯程序员&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为你分享有趣、实用的腾讯产品&amp;amp;技术&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;&lt;span&gt;‍&lt;/span&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.729264475743349&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvatricjRxhpM1x45aB6doaVg7WMhINPwOiaqpskia1kH7hgibO0dicW2HLcW8HRGMzESQwehIcyckLXtwsA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a0f5eb0200d0df25df6328e2bbbd0cc3</guid>
<title>Docker 安装 RocketMQ 并结合 Spring Boot 使用实例</title>
<link>https://toutiao.io/k/t7olcqd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img data-ratio=&quot;0.42272727272727273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybyLicevGbyCCfD3YummObd5AlNKlmJQdtAHVicAyFvnpt5G1Fibiclrsk7ktCpicBibyHo1W8rH05aAsv3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1760&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;在之前的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484302&amp;amp;idx=1&amp;amp;sn=42f10b35ec595195697ce5b6aa3870b4&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《浅入浅出消息队列》&quot; data-linktype=&quot;2&quot;&gt;《浅入浅出消息队列》&lt;/a&gt;一文中，我们了解了消息队列的作用、优缺点和使用场景，相信你对消息队列已经有了一个大致的概念，文末给自己埋的坑说日后会写一篇实战教程，正好现在实习结束了，也许久没有写实战教程了，于是这就来填坑了。&lt;/p&gt;&lt;h2&gt;前置知识&lt;/h2&gt;&lt;p&gt;阅读本文前，建议有一些前置知识，包括且不限于：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;常见的 Linux 命令&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;消息队列的相关知识&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Docker 的基本使用&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;docker-compose 的基础知识&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;SpringBoot 的基本使用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;那废话不多说，我们就开始吧。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;本文的所涉及到的代码可在微信公众号「01 二进制」后台回复「rocketmq」获得。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;为什么要以 RocketMQ 为例？&lt;/h2&gt;&lt;p&gt;本文主要是为了通过实例的方式直观的了解消息队列。那么问题来了，消息队列那么多（ActiveMQ、RabbitMQ、Kafka），&lt;strong&gt;我&lt;/strong&gt;为什么要选择 RocketMQ 呢？这里我们不谈原理，只说说体验，&lt;strong&gt;仅是个人选择，不喜勿喷。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;背靠阿里，不看测评，纯粹看他经历过多次双十一的检验就已经知道其性能是处于第一批次的。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;作为一个 Java 程序员，如果选择一个纯 Java 编写的软件，后期阅读其源码难度也会小很多。（RabbitMQ 底层是 Erlang，kafka 底层是 Scala）&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;在阿里实习的时候一直都是使用 RocketMQ 的内部版本，于我而言，RocketMQ 更熟悉。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;初识 RocketMQ&lt;/h2&gt;&lt;p&gt;在使用消息队列前，我们要知道消息队列是什么，这一块内容参考之前的文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484302&amp;amp;idx=1&amp;amp;sn=42f10b35ec595195697ce5b6aa3870b4&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《浅入浅出消息队列》&quot; data-linktype=&quot;2&quot;&gt;《浅入浅出消息队列》&lt;/a&gt;，这里不再赘述。&lt;/p&gt;&lt;p&gt;本段节来讲解 RocketMQ 所涉及到的相关概念，我们先来简单看下官方给出的 RocketMQ 架构图&lt;img data-ratio=&quot;0.5702364394993046&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybyLicevGbyCCfD3YummObd5Akib2l5NU779cPPlPVRzbjR2nQ8NvIZzkXWAv4gxicd5YtGvvyUx8cvIg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1438&quot; title=&quot;null&quot;/&gt;从上图我们可以很直观的看出，一个完整的 RocketMQ 架构包含四个部分：&lt;strong&gt;NameServer、Broker、Producer 和 Consumer&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;NameServer：主要用作注册中心，用于管理 Topic 信息和路由信息的管理&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Broker：负责存储、消息 tag 过滤和转发。需将自身信息上报给注册中心 NameServer&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Producer：生产者&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Consumer：消费者&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;从寄信的角度理解&lt;/h3&gt;&lt;p&gt;上面的解释可能难以理解，我们从寄信这一实例来看以下四个部分所承担的责任。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Producer 和 Consumer 不必多说，消息的生产者和消费者，生产者负责投递消息，消费者负责接收消息，&lt;strong&gt;是我们要编写的应用程序&lt;/strong&gt;。可以理解为寄信人和收信人。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Broker 负责消息存储，以 Topic（主题）为维度，以队列的形式存储消息。可以理解为信箱，专门存储信件，收信人（Consumer）可以从这里获取信件。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;NameServer 负责对源数据进行管理，包括了对 Topic 和 Broker 的管理。可以理解为邮局，负责管理邮件的分发，维护信箱（Broker）的状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;由上各部分角色的功能可知，我们需要先安装启动 NameServer，再启动 Broker 即可搭建完 RocketMQ&lt;/p&gt;&lt;h2&gt;安装 RocketMQ&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;如果你的电脑上已经配置好了 rocketmq 的相关环境，可以跳过本章节。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;从上面的介绍我们可以得知，在生产和消费消息之前，我们需要安装好&lt;strong&gt;Broker 和 NameServer。&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;准备工作&lt;/h3&gt;&lt;p&gt;为了部署方便，我推荐使用 docker 搭建服务。此外，由于 rocketmq 需要分别部署 broker 与 nameserver ，考虑到分开部署比较麻烦，这里我将会使用 docker-compose。因此，你需要在你的宿主机中安装好 docker 和 docker-compose。&lt;/p&gt;&lt;p&gt;此外，我们还需要搭建一个 web 可视化控制台，用于监控 mq 服务状态，以及消息消费情况，这里使用 rocketmq-console，同样该程序也将使用 docker 安装。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果对 docker 不熟悉的话，可以先阅读菜鸟教程的 docker 教程学习 👉&lt;span&gt;Docker 教程&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;安装&lt;/h3&gt;&lt;h3&gt;安装 Docker&lt;/h3&gt;&lt;p&gt;Linux：&lt;/p&gt;&lt;p&gt;执行以下命令&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;Mac：&lt;/p&gt;&lt;p&gt;执行以下命令&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;brew cask install docker&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;Win:&lt;/p&gt;&lt;p&gt;下载对应的安装文件，然后双击运行安装。下载地址在：https://hub.docker.com/editions/community/docker-ce-desktop-windows&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;考虑到下载该文件需要科学上网，你可以在微信公众号「01 二进制」后台回复「docker」获取 docker 安装包的下载链接。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;如果你的 win10 系统可以使用 winget，那就执行以下命令。(win 终于也有自己的包管理工具了 🙏)&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;powershell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;winget install Docker.DockerDesktop&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。配置教程可参考 👉&lt;span&gt;Docker 镜像加速&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;安装 RocketMQ 镜像&lt;/h3&gt;&lt;p&gt;rocketmq 的 docker 镜像我们可以自己制作，官方文档中有详细介绍 👉&lt;span&gt;apache&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;/&lt;strong&gt;&lt;span&gt;rocketmq-docker&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;为了方便起见，这里我们直接使用别人已经制作好的镜像，镜像地址 👉 &lt;span&gt;foxiswho/rocketmq&lt;sup&gt;[5]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;新建一个目录用于存放相关脚本，然后在终端执行下面的命令 👇&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;git clone https://github.com/foxiswho/docker-rocketmq.git&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cd docker-rocketmq&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cd rmq&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;chmod +x  start.sh&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;./start.sh&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;在经过一段时间的等待后，我们通过浏览器访问&lt;code&gt;localhost:8180&lt;/code&gt;查看到以下页面则说明安装成功。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.57171581769437&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybyLicevGbyCCfD3YummObd5AOPaC40ZjtcamSE9nVrEibJJYrZia9fHDiciaEXbeMvKnunGpnMaDqpNqzA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1492&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;安装脚本解析&lt;/h3&gt;&lt;p&gt;通过脚本的方式一键安装确实很方便，但如果只是安装完成就万事大吉了自然是不行的，本着授人以渔的态度，我们来看看安装脚本里都有些啥：&lt;/p&gt;&lt;h3&gt;start.sh&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8173228346456692&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybyLicevGbyCCfD3YummObd5AICx6wycXKxT02GJaNlmiaIZD9myCbW95hlX6EHQYgicNt5uiaiaxLyf1XA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1270&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;4-7 行在创建目录，10-13 行在给刚才创建的目录设置权限，至于原因我们之后再说。&lt;/p&gt;&lt;p&gt;我们看到 16 行使用 docker-compose 命令启动了容器，并设置为了后台自动启动，因此我们来看一下这个 docker-compose.yml 文件。&lt;/p&gt;&lt;h3&gt;docker-compose.yml&lt;/h3&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;version: &quot;3.5&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;services:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  rmqnamesrv:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    image: foxiswho/rocketmq:4.7.0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    container_name: rmqnamesrv&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ports:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - 9876:9876&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    volumes:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - ./rmqs/logs:/opt/logs&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - ./rmqs/store:/opt/store&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    environment:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      JAVA_OPT_EXT: &quot;-Duser.home=/opt -Xms512M -Xmx512M -Xmn128m&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    command: [&quot;sh&quot;, &quot;mqnamesrv&quot;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    networks:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      rmq:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        aliases:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          - rmqnamesrv&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  rmqbroker:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    image: foxiswho/rocketmq:4.7.0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    container_name: rmqbroker&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ports:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - 10909:10909&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - 10911:10911&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    volumes:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - ./rmq/logs:/opt/logs&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - ./rmq/store:/opt/store&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - ./rmq/brokerconf/broker.conf:/etc/rocketmq/broker.conf&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    environment:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      JAVA_OPT_EXT: &quot;-Duser.home=/opt -Xms512M -Xmx512M -Xmn128m&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    command:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      [&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &quot;sh&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &quot;mqbroker&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &quot;-c&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &quot;/etc/rocketmq/broker.conf&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &quot;-n&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &quot;rmqnamesrv:9876&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &quot;autoCreateTopicEnable=true&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      ]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    depends_on:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - rmqnamesrv&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    networks:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      rmq:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        aliases:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          - rmqbroker&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  rmqconsole:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    image: styletang/rocketmq-console-ng&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    container_name: rmqconsole&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ports:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - 8180:8080&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    environment:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      JAVA_OPTS: &quot;-Drocketmq.namesrv.addr=rmqnamesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    depends_on:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - rmqnamesrv&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    networks:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      rmq:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        aliases:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          - rmqconsole&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;networks:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  rmq:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    name: rmq&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    driver: bridge&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;我们创建了三个服务，这三个服务的名字分别是 rmqnamesrv、rmqbroker 和 rmqconsole，分别对应我们之前所说的 nameserver、broker 和可视化控制台。并且对不同的服务做了不同的端口映射，同时将本地指定的文件目录挂载到 docker 容器中，并以网桥（bridge）的形式进行网络连接。&lt;/p&gt;&lt;p&gt;以&lt;code&gt;rmqnamesrv&lt;/code&gt;为例，其基础镜像为&lt;code&gt;foxiswho/rocketmq:4.7.0&lt;/code&gt;，创建的容器名为&lt;code&gt;rmqnamesrv&lt;/code&gt;，并将其内部的 9876 端口映射到宿主机的 9876 端口，并将本地的&lt;code&gt;./rmqs/logs&lt;/code&gt;文件挂载到 docker 容器的&lt;code&gt;/opt/logs&lt;/code&gt;目录中。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;rmqnamesrv:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  image: foxiswho/rocketmq:4.7.0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  container_name: rmqnamesrv&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ports:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    - 9876:9876&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  volumes:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    - ./rmqs/logs:/opt/logs&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    - ./rmqs/store:/opt/store&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;如果对于 docker-compose 不熟悉的读者，可以先参考相关的教程学习一下 👉&lt;span&gt;Docker Compose&lt;sup&gt;[6]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;SpringBoot 整合 RocketMQ 小实例&lt;/h2&gt;&lt;p&gt;在完成了相对复杂的安装、配置后，我们终于可以实现一个小的 demo 来打通整个流程了。&lt;/p&gt;&lt;h3&gt;创建消息主题和订阅组&lt;/h3&gt;&lt;p&gt;使用 RocketMQ 进行发消息时，&lt;strong&gt;必须要指定 topic&lt;/strong&gt;，对于 topic 的设置有一个开关&lt;code&gt;autoCreateTopicEnable&lt;/code&gt;，一般在&lt;strong&gt;开发测试&lt;/strong&gt;环境中会使用默认设置&lt;code&gt;autoCreateTopicEnable = true&lt;/code&gt;，但是这样就会导致 topic 的设置不容易规范管理，没有统一的审核等等，所以在正式环境中会在 Broker 启动时设置参数&lt;code&gt;autoCreateTopicEnable = false&lt;/code&gt;。这样当需要增加 topic 时就需要在 web 管理界面上添加即可。&lt;/p&gt;&lt;p&gt;在 web 界面添加 topic 的方式如下：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5067024128686327&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybyLicevGbyCCfD3YummObd5A7zlX7GyWM5H6GR5JNjGSnuiaQ23KwrxBVzdX3kTicad1CSAick24hAX3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1492&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;同理，在接受消息时，我们同样需要对消息订阅组进行配置，对于消息的订阅设置有一个开关&lt;code&gt;autoCreateSubscriptionGroup&lt;/code&gt;，通常情况下，在生产环境下，我们需要设置为&lt;code&gt;autoCreateSubscriptionGroup=false&lt;/code&gt;，这就要求了管理者必须去 web 管理界面上创建订阅组才可以收到消息。&lt;/p&gt;&lt;p&gt;在 web 界面添加订阅组的方式类似，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3914209115281501&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybyLicevGbyCCfD3YummObd5ACFJc9f3dUl9xBc5IvR3G3bL4JTibb7HJfib8m2VamEibpDFJ1ONyaibXGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1492&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果只是测试环境，我们可以在配置文件中将这两个开关打开，配置文件在 &lt;code&gt;rmq/rmq/brokerconf&lt;/code&gt; 目录下&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;编写代码&lt;/h3&gt;&lt;p&gt;apache 官方已经提供了 rocketmq 对应的 springboot starter，这极大的简化了我们所需要做的配置工作，因此我们要做的就是先新建一个 springboot 项目，然后按照下面的方式着手实现。&lt;/p&gt;&lt;h3&gt;导入依赖&lt;/h3&gt;&lt;p&gt;首先先在 pom.xml 中导入 apache 官方提供的 starter&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.apache.rocketmq/rocketmq-spring-boot-starter --&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;groupId&amp;gt;org.apache.rocketmq&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;artifactId&amp;gt;rocketmq-spring-boot-starter&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;version&amp;gt;2.1.0&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;配置 application.yml&lt;/h3&gt;&lt;p&gt;依赖导入后，我们需要在 application.yml 配置一个 name-server 地址，具体值看你的机器。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;rocketmq:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  name-server: localhost:9876&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  producer:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    group: myGroup&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;创建一个生产者类&lt;/h3&gt;&lt;p&gt;生产者发送消息：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@RestController&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class RocketController {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Autowired&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private RocketMQTemplate rocketMQTemplate;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 发送给Broker，默认会自动创建topic，topic和tag用冒号分隔&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @GetMapping(&quot;/rocket/send&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public String rocketSend() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        LocalDateTime currentTime = LocalDateTime.now();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        rocketMQTemplate.convertAndSend(&quot;rocket-topic-2&quot;, currentTime.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return currentTime.toString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 延时消息，RocketMQ支持这几个级别的延时消息，不能自定义时长&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @GetMapping(&quot;/rocket/delayMsg/send&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public String rocketDelayMsgSend() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        LocalDateTime currentTime = LocalDateTime.now();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        rocketMQTemplate.syncSend(&quot;rocket-topic-2:tag-2&quot;, MessageBuilder.withPayload(currentTime.toString()).build(), 2000, 3);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return currentTime.toString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;创建一个消费者&lt;/h3&gt;&lt;p&gt;消费者监听消息：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Component&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Slf4j&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class RokcetServiceListener {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Service&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @RocketMQMessageListener(consumerGroup = &quot;consumer-group-1&quot;, topic = &quot;rocket-topic-2&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public class Consumer1 implements RocketMQListener&amp;lt;String&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public void onMessage(String s) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            log.info(&quot;consumer1 rocket收到消息：{}&quot;, s);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // RocketMQ支持两种消费方式，集器消费和广播消费&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Service&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @RocketMQMessageListener(consumerGroup = &quot;consumer-group-2&quot;, topic = &quot;rocket-topic-2&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            selectorExpression = &quot;tag2&quot;, messageModel = MessageModel.BROADCASTING)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public class Consumer2 implements RocketMQListener&amp;lt;String&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public void onMessage(String s) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            log.info(&quot;consumer2 rocket收到消息：{}&quot;, s);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;测试&lt;/h3&gt;&lt;p&gt;我们在浏览器中访问&lt;code&gt;localhost:8080/rocket/send&lt;/code&gt;，即可看到返回的时间戳。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.20040214477211796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybyLicevGbyCCfD3YummObd5AmNRmxtOxCppQjB1NV55cficGp0z8ia1Tlja2W9iaPu6xrQTNkRHicaZ1eQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1492&quot; title=&quot;null&quot;/&gt;同时在控制台也可以看到消费者已经获取到这条信息了&lt;img data-ratio=&quot;0.24932975871313673&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybyLicevGbyCCfD3YummObd5AGktevyRHv8PAhyj4zU5kwzkULgd9DOUyiar0oFW0sn0SxtnmjxqcyicQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1492&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;同样的，我们也可以在可视化控制台查看到相应的消息&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.787746170678337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybyLicevGbyCCfD3YummObd5AZRR0dFDFeuHsWZCCjQBAu3B0f8Z1BmpZqQE3u7za5bL2PZVE2xcBNg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1371&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们同样可以在可视化控制台查看消费者和生产者对于消息的生产与消费的情况，这些就留给读者自己探索了。至此，一个完整的利用 Docker 安装 RocketMQ 并结合 SpringBoot 使用的实例就结束了。&lt;/p&gt;&lt;h2&gt;问题&lt;/h2&gt;&lt;h3&gt;问题 1：No route info of this topic: xxxxxx&lt;/h3&gt;&lt;p&gt;通过翻译我们可以知道，这个错误产生的原因是因为消息队列中并未产生相对应的&lt;strong&gt;topic&lt;/strong&gt;，所以我们要做的应该是去控制台新建一个 topic&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5067024128686327&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybyLicevGbyCCfD3YummObd5A7zlX7GyWM5H6GR5JNjGSnuiaQ23KwrxBVzdX3kTicad1CSAick24hAX3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1492&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;问题 2：连接异常&lt;/h3&gt;&lt;p&gt;如果出现类似下述这种连接异常的错误&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;com.alibaba.rocketmq.remoting.exception.RemotingConnectException: connect to &amp;lt;172.0.0.120:10909&amp;gt; failed&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;可能的原因是你并没有将项目放至 docker 容器中，因此你的项目代码不能直接与 rocketmq 容器访问，因此我们需要将&lt;code&gt;broker.conf&lt;/code&gt;中的 &lt;code&gt;#brokerIP1=xxxxx&lt;/code&gt; 前面&lt;code&gt;#&lt;/code&gt;号去掉，并且把后面的&lt;code&gt;IP地址&lt;/code&gt;改成你的&lt;code&gt;rocketmq&lt;/code&gt;容器宿主机&lt;code&gt;IP地址&lt;/code&gt;，配置文件在 &lt;code&gt;rmq/rmq/brokerconf&lt;/code&gt; 目录下。&lt;/p&gt;&lt;h2&gt;最后&lt;/h2&gt;&lt;p&gt;为了填坑，我选择了 rocketmq 作为实例讲解的对象，并在第一节阐述了我为什么要使用 RocketMQ 的原因，之后解释了 RocketMQ 中几个重要的概念，然后利用 docker 快速的部署安装了一个 rocketmq 的单机实例，并分析了安装脚本。最后我们通过 springboot 这一目前主流的 web 框架实现了一个生产者与消费者的实例，并说明了可能会遇到的问题及解决方案。&lt;/p&gt;&lt;p&gt;以上就是本文的全部内容了，如果你觉得对你有所帮助，不放关注点赞支持一波，你们的支持是我更新的最大动力。&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; Docker 教程: &lt;em&gt;https://www.runoob.com/docker/docker-tutorial.html&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; Docker 镜像加速: &lt;em&gt;https://www.runoob.com/docker/docker-mirror-acceleration.html&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; apache: &lt;em&gt;https://github.com/apache&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; rocketmq-docker: &lt;em&gt;https://github.com/apache/rocketmq-docker&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[5]&lt;/code&gt; foxiswho/rocketmq: &lt;em&gt;https://hub.docker.com/r/foxiswho/rocketmq&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[6]&lt;/code&gt; Docker Compose: &lt;em&gt;https://www.runoob.com/docker/docker-compose.html&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ed2d56fbf4bdde9226e52434b72e546b</guid>
<title>Paxos 是如何劝退大家去选择 Raft 的</title>
<link>https://toutiao.io/k/v937b74</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;分布式系统为了实现&lt;b&gt;多副本状态机（Replicated state machine）&lt;/b&gt;，常常需要一个多副本日志（Replicated log）系统，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这个原理受到简单的经验常识启发&lt;/a&gt;：如果日志的内容和顺序都相同，多个进程从同一状态开始，并且以相同的顺序获得相同的输入，那么这些进程将会生成相同的输出，并且结束在相同的状态。&lt;/p&gt;&lt;p&gt;Replicated log =&amp;gt; Replicated state machine&lt;/p&gt;&lt;p&gt;问题是：&lt;/p&gt;&lt;blockquote&gt;如何保证日志数据在每台机器上都一样？&lt;/blockquote&gt;&lt;p&gt;当然是一直在讨论的 Paxos。一次独立的 Paxos 代表日志中的一条记录，重复运行 Paxos 即可创建一个 Replicated log。&lt;/p&gt;&lt;p&gt;但是如果每一组提案值都通过一次 Paxos 算法实例来达成共识，每次都要两轮 RPC，会产生大量开销。所以需要对 Paxos 做一些调整解决更实际的问题，并提升性能。经过一系列优化后的 Paxos 我们称之为 Multi-Paxos。&lt;/p&gt;&lt;blockquote&gt;Multi-Paxos 的目标就是实现 Replicated log.&lt;/blockquote&gt;&lt;p&gt;Lamport 并没有在论文中详细描述 Multi-Paxos 的细节，本文的理解完全来自公开的论文、讲座和其它资料，我的理解难免有不对的地方，欢迎指正。&lt;/p&gt;&lt;p&gt;下面我们从第一个问题开始。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;如何确定是哪条日志记录？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先，Replicated log 类似一个数组，我们需要知道当次请求是在写日志的第几位。因此，Multi-Paxos 做的第一个调整就是要添加一个日志的 index 参数到 Prepare 和 Accept 阶段，表示这轮 Paxos 正在决策哪一条日志记录。&lt;/p&gt;&lt;p&gt;现在流程大致如下，当收到客户端带有提案值的请求时：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;找到第一个没有 chosen 的日志记录&lt;/li&gt;&lt;li&gt;运行 Basic Paxos，对这个 index 用客户端请求的提案值进行提案&lt;/li&gt;&lt;li&gt;Prepare 是否返回 acceptedValue？&lt;/li&gt;&lt;ol&gt;&lt;li&gt;是：用 acceptedValue 跑完这轮 Paxos，然后回到步骤 1 继续处理&lt;/li&gt;&lt;li&gt;否：chosen 客户端提案值&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p&gt;&lt;b&gt;举个例子&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e901bdf3c4da68f86f8253c2d69d703b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1191&quot; data-rawheight=&quot;394&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-e901bdf3c4da68f86f8253c2d69d703b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1191&quot; data-rawheight=&quot;394&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-e901bdf3c4da68f86f8253c2d69d703b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e901bdf3c4da68f86f8253c2d69d703b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如图所示，首先，服务器上的每条日志记录可能存在三种状态：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;已经保存并知道被 chosen 的日志记录，例如 S1 方框加粗的第 1、2、6 条记录（后面会介绍服务器如何知道这些记录已经被 chosen）&lt;/li&gt;&lt;li&gt;已经保存但不知道有没有被 chosen，例如 S1 第 3 条 cmp 命令。观察三台服务器上的日志，cmp 其实已经存在两台上达成了多数派，只是 S1 还不知道&lt;/li&gt;&lt;li&gt;空的记录，例如 S1 第 4、5 条记录，S1 在这个位置没有接受过值，但可能在其它服务器接受过：例如 S2 第 4 条接受了 sub，S3 第 5 条接受了 cmp&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们知道三台机可以容忍一台故障，为了更具体的分析，我们假设此时&lt;b&gt;是 S3 宕机的情况&lt;/b&gt;。同时，这里的提案值是一条具体的命令。当 S1 收到客户端的请求命令 jmp 时，：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;找到第一个没有 chosen 的日志记录：图示中是第 3 条 cmp 命令。&lt;/li&gt;&lt;li&gt;这时候 S1 会尝试让 jmp 作为第 3 条的 chosen 值，运行 Paxos。&lt;/li&gt;&lt;li&gt;因为 S1 的 Acceptor 已经接受了 cmp，所以在 Prepare 阶段会返回 cmp，接着用 cmp 作为提案值跑完这轮 Paxos，s2 也将接受 cmp 同时 S1 的 cmp 变为 chosen 状态，然后继续找下一个没有 chosen 的位置——也就是第 4 位。&lt;/li&gt;&lt;li&gt;S2 的第 4 个位置接受了 sub，所以在 Prepare 阶段会返回 sub，S1 的第 4 位会 chosen sub，接着往下找。&lt;/li&gt;&lt;li&gt;第 5 位 S1 和 S2 都为空，不会返回 acceptedValue，所以第 5 个位置就确定为 jmp 命令的位置，运行 Paxos，并返回请求。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;值得注意的是，这个系统是可以并行处理多个客户端请求，比如 S1 知道 3、4、5、7 这几个位置都是未 chosen 的，就直接把收到的 4 个命令并行尝试写到这四个位置。但是，如果是状态机要执行日志时，必须是按照日志顺序逐一输入，如果第 3 条没有被 chosen，即便第 4 条已经 chosen 了，状态机也不能执行第 4 条命令。&lt;/p&gt;&lt;p&gt;还记得我们之前文章里说的活锁。如果所有的 Proposer 都一起并行工作，因 Proposer 间大量的冲突而需要更多轮 RPC 才能达成共识的可能性就很大。另外，&lt;b&gt;每个提案最优情况下还是需要两轮 RPC&lt;/b&gt; ！&lt;/p&gt;&lt;p&gt;一般通过以下方式优化：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;选择一个Leader，任意时刻只有它一个 Proposer，这样可以避免冲突&lt;/li&gt;&lt;li&gt;减少大部分 Prepare 请求，只需要对整个日志进行一次 Prepare，后面大部分日志可以通过一次 Accept 被 chosen&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面谈谈这两个优化。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Leader 选举&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;有很多办法可以进行选举，Lamport 提出了一种简单的方式：让 server_id 最大的节点成为Leader（在上篇说到提案编号由自增 id 和 server_id 组成，就是这个 server_id）。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;既然每台服务器都有一个 server_id，我们就直接让 server_id 最大的服务器成为 Leader，这意味着每台服务器需要知道其它服务器的 server_id&lt;/li&gt;&lt;li&gt;为此，每个节点每隔 Tms 向其它服务器发送心跳&lt;/li&gt;&lt;li&gt;如果一个节点在 2Tms 时间内没有收到比自己 server_id 更大的心跳，那它自己就转为 Leader，意味着：&lt;/li&gt;&lt;ol&gt;&lt;li&gt;该节点处理客户端请求&lt;/li&gt;&lt;li&gt;该节点同时担任 Proposer 和 Acceptor&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;如果一个节点收到比自己 server_id 更大的服务器的心跳，那么它就不能成为 Leader，意味着：&lt;/li&gt;&lt;ol&gt;&lt;li&gt;该节点拒绝掉客户端请求，或者将请求重定向到 Leader&lt;/li&gt;&lt;li&gt;该节点只能担任 Acceptor&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p&gt;值得注意的是，这是非常简单的策略，这种方式系统中同时有两个 Leader 的概率是较小的。&lt;b&gt;即使是系统中有两个 Leader，Paxos 也是能正常工作的，只是冲突的概率就大了很多，效率也会降低。&lt;/b&gt; &lt;/p&gt;&lt;p&gt;有一些基于租约的策略显得更为稳定，也更复杂，在此不表。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;减少 Prepare 请求&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在讨论如何减少 Prepare 请求之前，先讨论下 Prepare 阶段的作用，需要 Prepare 有两个原因：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;屏蔽老的提案：但 Basic-Paxos 只作用在日志的一条记录&lt;/li&gt;&lt;li&gt;检查可能已经被 chosen 的 value 来代替原本的提案值：多个 Proposer 并发进行提案的时候，新的 Proposal 要确保提案的值相同&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们&lt;b&gt;依然是需要 Prepare 的&lt;/b&gt;。我们要做的是减少大部分 Prepare 请求，首先要搞定这两个功能。&lt;/p&gt;&lt;p&gt;对于 1，我们不再让提案编号只屏蔽一个 index 位置，而是让它变成全局的，即屏蔽整个日志。一旦 Prepare 成功，整个日志都会阻塞（值得注意的是，Accept 阶段还是只能写在对应的 index 位置上）。&lt;/p&gt;&lt;p&gt;对于2，需要拓展 Prepare 请求的返回信息，和之前一样，Prepare 还是会返回最大提案编号的 acceptedValue，除此之外，Acceptor 还会向后查看日志记录，如果要写的这个位置之后都是空的记录，没有接受过任何值，那么 Acceptor 就额外返回一个标志位 noMoreAccepted。&lt;/p&gt;&lt;p&gt;后续，如果 Leader 接收到超过半数的 Acceptor 回复了 noMoreAccepted，那 Leader 就不需要发送 Prepare 请求了，直接发送 Accept 请求即可。这样只需要一轮 RPC。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;副本的完整性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;目前为止，通过选主和减少 Prepare 请求之后的 Multi-Paxos 依然不够完整，还需要解决：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;之前的日志只需要被多数派接受，完整的日志记录需要复制到全部节点&lt;/li&gt;&lt;li&gt;只有 Proposer（也就是Leader） 知道哪些记录被 chosen 了，需要所有的服务器都知道哪些记录被 chosen&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;换句话说，我们需要每台机的日志都完整，这样状态机执行日志后才能达到一样的状态。&lt;/p&gt;&lt;p&gt;要做到这点，我们需要：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;为了让日志尽可能被复制到每台服务器：Leader 在收到多数派 Acceptor 回复后，可以继续做后面的处理，但同时在后台继续对未回复的 Acceptor 进行重试。这样不会影响客户端的响应时间，但这也不能确保完全复制了（例如，如果 Leader 在中途宕机了）&lt;/li&gt;&lt;li&gt;为了追踪哪些记录是被 chosen 的，我们增加一些内容：&lt;/li&gt;&lt;ol&gt;&lt;li&gt;acceptedProposal 代表日志的提案编号，如果第 i 条记录被 chosen，则 acceptedProposal[i] = 无穷大（这是因为，只有提案编号更大的提案才能被接受，无穷大则表示无法再被重写了）&lt;/li&gt;&lt;li&gt;每个节点都维护一个 firstUnChosenIndex，表示第一个没有被 chosen 的日志位置。（即第一个 acceptedProposal[i] != 无穷大的节点）&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p&gt;3. Leader 告诉 Acceptor 哪些日志被 chosen ：Leader 在向 Acceptor 发送 Accept 请求的时候带上 firstUnChosenIndex，这样 Acceptor 收到 Accept 请求的时候，如果第 i 条日志满足 i &amp;lt; request.firstUnchosenIndex &amp;amp;&amp;amp; acceptedProposal[i] == request.proposal，则标记 i 为 chosen（即设为无穷大） &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-148fa59f0b085ac1d277be6f9265d6d5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1125&quot; data-rawheight=&quot;270&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-148fa59f0b085ac1d277be6f9265d6d5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1125&quot; data-rawheight=&quot;270&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-148fa59f0b085ac1d277be6f9265d6d5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-148fa59f0b085ac1d277be6f9265d6d5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;用图示来说明一下，上图表示同一个 Acceptor 节点 Accept 请求前后的 ``。该 Acceptor 在 Accept 请求之前的第 6 位的提案编号为 3.4，这时它收到一个提案编号也为 3.4 的 Accept 请求，并且请求的 firstUnchosenIndex = 7，大于之前 3.4 所在的 6，所以&lt;b&gt;将选中第 6 位，同时因为该请求的 index = 8，acceptedProposal[8] == 3.4。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;4. 到了这里还需要考虑，Acceptor 的日志条目中仍然可能有一些前任 Leader 留下的提案记录，还没有完成提案的复制或者 chosen 时 Leader 宕机，换了一个 Leader 节点，这时候需要：&lt;/p&gt;&lt;ul&gt;&lt;ul&gt;&lt;li&gt;Acceptor 将其 firstUnchosenIndex 作为 Accept 请求的响应返回给 Proposer&lt;/li&gt;&lt;li&gt;Proposer 判断如果 Acceptor.firstUnChosenIndex &amp;lt; Proposer.firstUnChosenIndex，则在后台（异步）发送 Success(index, v) RPC&lt;/li&gt;&lt;li&gt;Acceptor 收到 Success RPC 后，更新已经被 chosen 的日志记录：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;acceptedValue[index] = v&lt;/li&gt;&lt;li&gt;acceptedProposal[index] = 无穷大&lt;/li&gt;&lt;li&gt;return firstUnchosenIndex&lt;/li&gt;&lt;li&gt;如果需要(可能存在多个不确定的状态)，Proposer 发送额外的 Success RPC&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;总结一下，通过 4 个步骤就可以确保所有的 Acceptor 都最终知道 chosen 的日志记录。在一般的情况，并不需要额外的第 4 步，只有在 Leader 切换时才可能需要第 4 步。&lt;/p&gt;&lt;p&gt;现在我们的日志已被完全复制了。因此，让我们转头看看与客户端的交互。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;客户端请求&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;接下来需要考虑客户端如何与系统交互。&lt;/p&gt;&lt;p&gt;首先，当客户端第一次请求时，并不知道谁是 Leader，它任意请求一台服务器，如果该服务器不是 Leader，重定向给 Leader。&lt;/p&gt;&lt;p&gt;Leader 直到日志记录被 chosen 并且被 Leader 的状态机执行才返回响应给客户端。&lt;/p&gt;&lt;p&gt;客户端会一直和 Leader 交互，直到无法再联系上它（例如请求超时）。在这种情况下，客户端会联系任何其它服务器，这些服务器又在重定向到实际的 Leader。&lt;/p&gt;&lt;p&gt;但这存在一个问题，如果请求提案被 chosen 后，Leader 在回复客户端之前宕机了。客户端会认为请求失败了，并重试请求。这相当于一个命令会被状态机执行两次，这是不可接受的。&lt;/p&gt;&lt;p&gt;解决办法是客户端为每个请求增加一个唯一 id，服务器将该 id 与命令一起保存到日志记录中。状态机在执行命令之前，会根据 id 检查该命令是否被执行过。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;集群管理（加入或减少节点）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;最后一个非常棘手的问题，因为集群中的节点是会变更的，包括：服务器的 id、网络地址变更和节点数量等。集群节点数量改变会影响多数派数量的判断，我们必须保证不会出现两个重叠的多数派。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1f21160c3016167833ef89ff32952fb7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1071&quot; data-rawheight=&quot;288&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f21160c3016167833ef89ff32952fb7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1071&quot; data-rawheight=&quot;288&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f21160c3016167833ef89ff32952fb7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1f21160c3016167833ef89ff32952fb7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Lamport 在 Paxos 论文中的建议解决方案是：使用日志来管理这些变更。当前的集群配置被当作一条日志记录存储起来，并与其它的日志记录一起被复制同步。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a15bd4dc1ce39652b89f27f5bfaf047d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;664&quot; data-rawheight=&quot;195&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-a15bd4dc1ce39652b89f27f5bfaf047d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;664&quot; data-rawheight=&quot;195&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-a15bd4dc1ce39652b89f27f5bfaf047d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a15bd4dc1ce39652b89f27f5bfaf047d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;这里看起来会比较奇怪，如图所示，第 1、3 个位置存储了两个不同的系统配置，其它位置的日志存储了状态机要执行的命令。增加一个系统参数   去控制当配置变更时什么时候去应用它，&lt;b&gt;  表示配置多少条记录后才能生效。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这里假设   = 3，意味着 C1 在 3 条记录内不生效，也就是 C1 在第 4 条才会生效， C2 在第 6 条开始生效。&lt;/p&gt;&lt;p&gt;  是在系统启动的时候就指定的参数。这个参数的大小会限制我们在系统可以同时 chosen 的日志条数：在 i 这个位置的值被 chosen 之前，我们不能 chosen i+α 这个位置的值——因为我们不知道中间是否有配置变更。&lt;/p&gt;&lt;p&gt;所以，如果 α 值很小，假设是 1，那整个系统就是串行工作了；如果 α = 3，意味着我们可以同时 chosen 3 个位置的值；如果 α 非常大， α = 1000，那事情就会变得复杂，如果我们要变更配置，可能要等配置所在的 1000 条记录都被 chosen 以后才会生效，那要等好一阵子。这时候为了让配置更快生效，我们可以写入一些 no-op 指令来填充日志，使得迅速达到需要的条数，而不用一直等待客户端请求进来。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;能看到这里，说明你和我一样喜欢分布式系统和 Paxos，又或者是你实在太无聊了（^-^）。&lt;/p&gt;&lt;p&gt;首先，文章描述了如何从 Basic-Paxos 到 Multi-Paxos，如何 chosen 某个具体位置的日志记录，接着是两个提高 Paxos 效率的办法：选定 Leader 和减少 Prepare 请求。还讲到了如何让所有的服务器都得到完整的日志，以及系统如何与客户端交互工作。最后，讲了通过 α 值来处理配置变更。&lt;/p&gt;&lt;p&gt;Basic Paxos 流程是比较容易理解的，但 Multi-Paxos 却非常棘手，尤其是实际使用的时候，需要一系列的优化，这一系列优化又是不那么容易理解和做到的，很多地方没有明确定义，需要每个实现者自己去一步步踩坑。这也是后来的分布式系统在共识算法上纷纷转投 Raft 的原因之一吧，&lt;b&gt;Paxos 的工程化实在令人头疼&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;但不得不说的是，大厂都有自己的 Paxos/Multi-Paxos 实现。Google 的论文 &quot;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cs.utexas.edu/users/lorenzo/corsi/cs380d/papers/paper2-1.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Paxos made live&lt;/a&gt;&quot; 介绍他们相关的工作，他们的 BigTable、chubby 都是基于文章描述的 Multi-Paxos；微信作为体量巨大的应用，也有开源的 paxos 实现：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Tencent/phxpaxos&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;phxpaxos&lt;/a&gt;；&lt;a href=&quot;https://www.zhihu.com/question/52337912&quot; class=&quot;internal&quot;&gt;阿里的 Oceanbase 也是使用 Paxos&lt;/a&gt;——Paxos 可谓分布式系统的皇冠。&lt;/p&gt;&lt;p&gt;下篇文章我们还会继续介绍 Paxos 的其它变体：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2005-112.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Fast-Paxos&lt;/a&gt;。&lt;b&gt;记得关注专栏和我的公众号！&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-da448478fa5e667e51823884ca3f3d3a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;394&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-da448478fa5e667e51823884ca3f3d3a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;394&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-da448478fa5e667e51823884ca3f3d3a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-da448478fa5e667e51823884ca3f3d3a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>