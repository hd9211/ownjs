<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1adc0ba121054fdc747a967b012b99ac</guid>
<title>开源｜基于 Vue 开发的可视化商城搭建平台</title>
<link>https://toutiao.io/k/48imbcu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断。&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;扫描下方二维码&lt;/span&gt;，即刻加入！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个基于 Vue 开发的可视化商城搭建平台，包括多页面可视化构建、JSON Schema 生成器（可视化搭建物料控制面板），实现组件流水线式标准接入平台。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最新版本使用 uni-app 重构物料、模板项目，支持生成 H5、小程序多端商城。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.0773333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavibCSiaxHO1EIWViadicfiaJfeFmJIiciaVjvXJTOBnLzoTSicibvJvQbXkcRgFIicia0JzeEgLH2mLIhZqhukMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f4e777e0f422683e248d61e5ca9fb9a0</guid>
<title>用 vscode 写 C/C++ 代码</title>
<link>https://toutiao.io/k/e3l7be3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/otHvoL6neeIxIugZwRtMH5VUj2nppdvm3sGbAq6eHwb2SOd1wlEibUiceiaAfPl39lhaZQ0TCHzHDwr2G8ERvzOiaw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;最近用上了 MacBookPro M1，使用 &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjMxNzQ0MQ==&amp;amp;mid=2651106013&amp;amp;idx=1&amp;amp;sn=77921f12bcea5baa71bc4489465d5484&amp;amp;chksm=813c4733b64bce252eec22f93038e1696568208be334549b1c2c77506e43a46ae40f8399e3f4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;dotfile&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;dotfile&lt;/a&gt;&lt;span&gt; 配置好基本环境后，发现我的 vscode 里 C/C++ 开发环境还没配置好。&lt;/span&gt;&lt;span&gt;一直以来，vscode 都是我的主力 C/C++ 开发环境，这其中离不开 cquery 插件。&lt;/span&gt;&lt;span&gt;2018 年我曾写过一篇文章&lt;/span&gt;&lt;span&gt;：《&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjMxNzQ0MQ==&amp;amp;mid=2651105907&amp;amp;idx=1&amp;amp;sn=e3f5009a5ea5049aebf590afe48078fe&amp;amp;chksm=813c479db64bce8babe5f45eda9eb20044072a4a2ce574d2b2007ac9c0a0e2aba6f7557111fc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;神器：VSCode 的 cquery 插件&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;神器：VSCode 的 cquery 插件&lt;/a&gt;&lt;span&gt;》&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;cquery 在头文件搜索，符号跳转，代码提示和补全等方面都令人满意。甚至在 V8 这样的大型仓库上，官方也有说明如何配合 cquery 进行开发 V8(https://v8.dev/docs/ide-setup#visual-studio-code-and-cquery)。&lt;/p&gt;&lt;p&gt;几年过去了，今天在 M1 上编译 cquery 时，才发现 cquery 已经很久不维护了，github 的 repo 已经 archived 很长一段时间了（应该是2018年就关了）。这就直接导致了在 Apple Silicon 上编译不了 cquery，也就无法使用 cquery 了。&lt;/p&gt;&lt;p&gt;于是，得寻找一套替代 cquery 的方案。一番寻找，两个替代方案出现了：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ccls&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;clangd&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;2018年 4月，一位中国的年轻小伙 &lt;span&gt;MaskRay&lt;/span&gt; 从 cquery fork 了一份代码出来，并且对原有代码进行了大刀阔斧的重构：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;在cquery的代码库上做了大量清理工作：删除第三方库、精简代码、删除过度的抽象、合并拆得过碎的文件，当然还有改名、删除waf构建系统、删除无用blob、……自己用得舒服了再推己及人，希望别人也能用上满足自己的虚荣心。其实说穿了就是和cquery/clangd抢夺用户。精简并不能改变用户习惯，带来用户。我很快瞄准了cquery用户的一个痛点：auto-index pipeline的稳定性。最大的问题是，保存文件后容易导致重复或丢失的references。如果.h和.cc没有放在同一个目录，更容易出问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;by MaskRay《C++ language server ccls一周年》&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;重构和优化后的 ccls 在社区里获得不错的评价。在 cquery 停止维护，clangd 还不成熟的时候，ccls 一度还是该领域的最佳选择。而我这种老旧派还一直固守着 cquery 这只已经不再前进的工具。cquery 的作者不再维护的原因之一，竟是期待 clangd 来取代自己。&lt;/p&gt;&lt;p&gt;这 clangd 从名字上看来就大有来头。它背后是著名的 llvm 官方团队。它基于 Clang C++ Compiler，默认集成到了 llvm 项目中。也就是说，只要你安装了 llvm，就默认带了 clangd，不需要像 cquery, ccls 一样额外安装。&lt;/p&gt;&lt;p&gt;但早期的 clangd 不够成熟，bug 不断，对使用的稳定性造成了不少影响。于是不少用户转向了 ccls，虽然是个人项目，但是功能稳定，在一些特性方面支持也很好。同时 clangd 也在不断的更新迭代，早期的各种问题也在逐步的解决掉，稳定性也在逐步的加强。&lt;/p&gt;&lt;p&gt;我很敬佩 ccls 作者所做的贡献。但是，2022年，我会先选 clangd，原因是它默认随 llvm 安装，以及它背后的 llvm 团队。简单试用后，感觉也非常的不错。待我再用长一段时间，再回过来评价，至少，还有另一个选择：ccls，在等着我。&lt;/p&gt;&lt;h5&gt;vscode + clangd 使用指南&lt;/h5&gt;&lt;p&gt;第一步：&lt;span&gt;安装 clangd，安装 llvm 即可：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; brew install llvm&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;第二步：vscode 安装 clangd 插件，搜索”clangd”安装即可&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.20333333333333334&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/otHvoL6neeIxIugZwRtMH5VUj2nppdvmzF8DESRj9eJrdjxhTLfqqcQ3KhKvVicXmXo0kbzvalt4TibhUSHtwyibQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第三步：vscode 官方的 C/C++ 插件还是需要的，因为我们调试等功能还需要用到。但是需要关闭它的智能提示功能：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;C_Cpp.intelliSenseEngine&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Disabled&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第四步：生成 compile_commands.json 文件，clangd 依赖它来分析所有的依赖关系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果使用 CMake 编译，编译时，添加参数：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; cmake .. -DCMAKE_EXPORT_COMPILE_COMMANDS=YES&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;或者在 CMakeLists.txt 里，指定生成：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;set(&lt;span class=&quot;code-snippet__built_in&quot;&gt;CMAKE_EXPORT_COMPILE_COMMANDS&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;YES&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;生成的 compile_commands.json 文件可能在 build 目录下，这时需要在项目主目录里创建一个该文件的软链：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; ln -s build/compile_commands.json .&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第五步：重启 vscode，或者 CMD+Shift+P 输入 Reload Window&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们以著名开源代码 libuv 为例，生成 compile_commands.json 后，打开工程， 所有头文件，符号都能正确的索引和跳转：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7775&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/otHvoL6neeIxIugZwRtMH5VUj2nppdvmk0pE8Tyw9icughHcypPT3MjpmJuJ6kiaTG5hwpL1DqXib10oW7SB3JKpQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;h5&gt;关于 Python 和 C++ 的一则趣闻&lt;/h5&gt;&lt;p&gt;Python 的作者 Guido van Rossum 的博客几年没更新了，最新更新了一篇文章，翻译过来就是：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;2005 年底，我加入了谷歌。采访花费了令人惊讶的长时间，这是另一个故事。今天我想讲一个故事，发生在我在谷歌园区的第一周。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在主楼有一个令人印象深刻的楼梯，通往二楼。靠近顶部的地方是一间宽敞的办公室。一位非常重要的工程师在那里工作。我看了看门上的名字，发现我认识他：他曾经是英国的一名研究生，90 年代初曾在阿姆斯特丹的数学和计算机科学研究学会（CWI）访问过我们的研究小组（Amoeba 项目）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很高兴找到一个我很久以前就认识的人，有一天我敲门自我介绍。是的，他也记得我，但我的喜悦很快就结束了。不仅 Python 是 Mike 在 Google 的痛苦之源（他讨厌所有非 C++ 的东西），而且他在阿姆斯特丹逗留期间，留下的一个突出的记忆是，大约有一次我带他骑车穿过城镇，坐在我的自行车后面：“这是我一生中最糟糕的骑行。”&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>44be451dbffce1c0002c8f7c9967eaaa</guid>
<title>杨尚昂：FlinkSQL在京东实时维度建模中的应用</title>
<link>https://toutiao.io/k/81ouxgp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-backh=&quot;161&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;161&quot; data-fileid=&quot;100072688&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh7SwtLWpnpAXTOWaOPZYslMYaP54YrW09u7JbzkuR03o15wm0Gbial1PGDXGAICxfN1urRfLwHTpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZUhyOUQrkiaMibYN5AjAqoK51wKKdjAobj3VdMUBLEmlDzz3X4iaWqJEFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: -10px; margin-left: -8px; max-width: 100%; width: 18px; height: 18px; border-top: 8px solid rgb(54, 65, 173); border-left: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-style=&quot;max-width: 100%; width: 543.333px; background: rgb(247, 247, 247); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;分享嘉宾&lt;/span&gt;&lt;span&gt;：杨尚昂 京东 BI工程师&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;编辑整理&lt;/span&gt;&lt;span&gt;：闵强 明略科技&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;出品平台：DataFunTalk&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; width: 18px; height: 18px; border-bottom: 8px solid rgb(54, 65, 173); border-right: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;今天给大家分享京东在实&lt;/span&gt;&lt;span&gt;时建模过程中使用Flink SQL的应用案例。&lt;/span&gt;&lt;span&gt;主要从问题、难点、方案和规划四个方面来介绍。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;问题&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在维度建模中有很多技术场景，本文挑选其中两个较难的场景来进行详细阐述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题一 实时多流全量关联的问题&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; A &lt;span class=&quot;code-snippet__keyword&quot;&gt;full&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;join&lt;/span&gt; B &lt;span class=&quot;code-snippet__keyword&quot;&gt;on&lt;/span&gt; A.name = B.name;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;此问题关联SQL比较简单，只有A流和B流两个实时流进行full join，但还可能涉及到其中有一流数据需要关联全量历史数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题二 实时流全量分组计算的问题&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;,&lt;span class=&quot;code-snippet__keyword&quot;&gt;name&lt;/span&gt;,val,row_number() &lt;span class=&quot;code-snippet__keyword&quot;&gt;over&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;partition&lt;/span&gt; byname &lt;span class=&quot;code-snippet__keyword&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt; val) &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; rn &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; A;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;name&lt;/span&gt;,&lt;span class=&quot;code-snippet__keyword&quot;&gt;min&lt;/span&gt;(val) &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; A &lt;span class=&quot;code-snippet__keyword&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt; k;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个问题是&lt;/span&gt;&lt;span&gt;实时流全量分组计算，涉及到分组排序值，或者分组求最小值等操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对以上两个问题，似乎使用SQL处理起来比较简单，甚至我们可以直接用Flink SQL去完成。而实际直接使用以上Flink SQL计算存在若干问题。第一个问题是在最初生产数据的时候，可能并没有接入实时数据流。在实际场景中，往往需要在过程中接入实时数据。比如接入binlog之类的数据，其实是从当前时刻到未来这一时间段。例如商品SPU信息，一般需要有历史数据。只有获取历史数据，在订单数据流关联的时候，才能关联上这个订单所对应的历史信息。如果商品信息都是从产生后一段时间才接入数据，即从当前时刻才有的，那就无法获取到历史信息。第二个问题是状态数据，在用Flink SQL进行计算时，需要维护若干状态数据放到内存中，这种操作比较消耗内存。对于商品几年的历史数据，如果将状态数据存放在rocksdb中，经测试性能无法得到保障。基于此，如果直接用Flink SQL肯定无法解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下分析怎么去解决此类问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先看第一个问题，即实时多流全量关联的问题。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;span&gt;第一部分就是从最初时刻到当前时刻的时间区间，可以认为是历史状态数据。此处分别是A表和B表的记录。然后我们按照对应的关联键，如分别按name进行关联。通过name字段把它拆成几个部分，右侧是关联出来的结果表。当有一个消息进入，这个消息体可能是一个变更的消息记录。此处略过较为简单的新增或者删除操作，重点分析更新操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZzJ426cjgB0Q09OgCGcu5BmZDDwpDcsDePDKt5rtMbCgicqibdWNSqw9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如下图中消息mid=1，将A表里边的id=1000001这条记录里面aaa的记录值改成了bbb。但这个name字段是关联键，所以这就导致它影响了两个分组下的关联键下的记录。最终在A里面，它与B关联上的，之前的这两条记录(name=aaa)，在它被修改之后就不存在了，所以我们需要给下游发删除记录。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZDLQffs2EKSpoUmoykMg7aY3g2VkyF2KsCS9qrvrxVJEACUZjq40QOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时在A表的分组中，即在name=bbb分组下，这个关联键下会新增一条插入的记录。所以需要向下游下发这条新增记录跟B表关联到的这两条宽表记录。如果再有一条消息体过来，那么同样存在插入和删除记录。以此类推，B表变更逻辑相类似。在此过程中，当一条变更的消息体来了之后，需要考虑在实时维度建模里面去做哪些操作。例如在这个建模过程中需要变更的可能不只是当前的那个记录状态，之前的状态也有关联。而在进行分布式去计算的时候，不同的关联键也会分发到不同的节点上去计算。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZADKmtcGyTnBRTl3tNCzCb0ldzuyJmAzdtNS5LCRAI5B7rCy1Wlkw7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZHRzQNRalVhuOJwbSUv8cW5NFp58MEpPUJJeGkP6SSbxjib7JlFHhR2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;再看第二个问题，全量分组计算问题。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类似地，当源端来了一个消息体，本来是一个原始状态值name=bbb，当它变更之后，现在变更成name=aaa，最终会影响分组排序的结果。原本是按照val=21,33,66 (name=aaa)依次排序，现在只有val=33,66 (name=bbb)，因为（id=100003）这条记录中的name值从bbb变成了aaa。所以在排序时row_number会发生变更，而下发的相关联的数据同样都会变更。当产生变更时，分组中最小值(min)是一样的，在涉及变更行为之后都需要更改。我们在进行计算时就需要考虑以上这些情况。因此每一次计算过程，都需要拿到A表的全量历史数据跟B表的全量历史数据去进行关联计算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZMC8KtwRAyyfEIicO27xD2iaibK6oRNTXM3QIIf2l4qavVHb54V1gmuTicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZKbxokKnDBFZQFiakWpejkn3nSaYsIjxxEposMQbGOmDic9hgMDlRxoiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然也可能存在A表发生变更，需要拿关联的B表的全量，这样可以把所有的数据都进行关联，包括之前这个状态将对应的B的全量取出来然后去做关联。以上这两类问题，通过画图和描述来看，似乎较为简单。但问题在于有数据流的变更，还需要还原出对应的状态表，然后由状态表关联结果，最终还原出对应的关联结果的流式变更记录，这类操作就涉及状态存储与读取的技术难点。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;难点&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以上两类问题，如果进行全量数据关联操作，很快就能得到关联出的所有全量结果，然后去做计算，在性能上似乎也不用考虑太多，但实际操作存在一定难度。&lt;/span&gt;&lt;span&gt;以下阐述了问题难点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先需要明确，问题难点准确来说是相对繁琐之处。实时维度建模有别于离线维度建模，需要考虑的地方很多，因此会增加实时维度建模的开发难度以及需要人为的干涉的地方。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;难点一，如何获取到历史数据。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果是使用Flink SQL来实现，需要保存全量的历史信息。既然我们无法保存状态，那就存到外设KV存储里面，存到外部的KV Storage。在这个过程中，需要考虑以什么结构去存储；如何去维护A、B、C三个表的数据，用这三个流表去做关联；这三个流表与各自对应的外设存储比如说A的HBase表跟B的HBase表跟C的HBase表或者与D的HBase表等等类似KV存储这种类型的；要对这几个表之间的关系进行组织；在组织关联出了结果之后，需要考虑在关联结果里面是否还存在时序问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上描述的关联结果里面存在三个消息，当三个消息体来了之后，对应的有一组下发流。如id=100001对应的键，它存在多条记录，如果时序发生混乱，最终可能导致宽表的结果还原错误。那怎么来保证时序的正确性，如果直接用Flink SQL进行计算，可能需要创建一个HBase table source（类似table function）的方式去做关联。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;难点二，如何提升性能。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果直接使用Flink SQL进行计算，需要考虑如何获取数据包括IO操作，且如何更高效地去实现这个过程。关于提升性能，最直接地有两种途径，一是降低IO的请求次数，二是增加并发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;降低IO请求，具体实现方法是做业务逻辑过滤或者根据业务逻辑做一定计算，或者做一些请求合并，或者用一些批量请求的方式去发请求。另外是设置缓存，通过设置一个合理的缓存值，能够做到缓存有一个较高的命中率。同时还需要考虑是设置被动缓存还是主动缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;增加并发，具体需要考虑是使用异步IO，还是使用增加并行度、引擎优化等等。因为以上两个较为繁琐支出，所以开发难度相对较高，需要考虑的细节问题较多。如果直接使用Flink SQL，其代价也许比写Flink程序去做维度建模工作更大。以上就是使用Flink SQL做维度建模工作遇到的若干难题。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;方案&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;那如何去解决以上问题？&lt;/span&gt;&lt;span&gt;首先考虑采用组件化的设计方式，把用户所需要的维度建模功能做成若干组件，用户可以直接通过组件化的配置，就能够完成维度建模的开发。&lt;/span&gt;&lt;span&gt;这样达到了降低代码开发成本的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZno36s2xnxsKibicKR4vfp3JYuyxhXFQOCFgMUNGw19eWDmyP7N45gwCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次是将计算逻辑使用Flink SQL来表达。因为SQL在数据开发过程中是一种通用性较强的方式，并且其学习成本或研发、维护等等成本相对较低。采用以上两种方式需要解决前文提到的难点，下面看具体方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里构建了一个产品RDM Building用来完成维度建模构建工作。它主要分为三层（Components Config、RDDM Component Builder、RDDM Component Parse），首先用户可以写组件配置，然后构建器会根据配置生成对应的一些组件对象，接着组件对象通过RDDM Component Parse就会将对应的组件转化Flink SQL算子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如使用A、B、C三个流进行关联计算，它们都是通过同样一组key关联，其关联键是相同的，最终关联生成一个结果表。这类操作可以使用His Rows Component组件进行处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它负责的过程是将A、B、C流分别对应的KV存储里面存储的历史数据取出，拿到对应的关联历史数据，比如A流数据过来就取到对应的关联的B表跟C表的历史数据。同样的针对B流，会将关联的A流跟C流的历史信息也都取出。对于C表也是如此。这样需要关联的所有历史数据，再组合成对应的A&#x27;、 B&#x27;、C&#x27;，其种A&#x27;不仅包含了A当前的数据，还包含了A要跟其它流关联的、相关的历史数据。所以在A&#x27;、 B&#x27;、C&#x27;里面，不仅有A、B、C流数据，而且包含了对应的历史数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照以上设计，实时流的历史数据可以一直保存，那就基本解决历史数据这个难点。还需要考虑的问题是cache随着时间增长存不下，或者因cache太大导致速度很慢。又或者使用rocksdb的方式发现性能较低，但同时缺乏rocksdb方面优化的专业能力。但可以相对较为成熟的KV存储，而且数据可能本身使用KV存储进行保存。那么直接使用KV存储就能解决历史数据问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图可以看到His Rows Component组件的详细执行过程，我们以这个组件为例来进行展开分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZ0G2OAPc9W15UescZl2OII4h0kTOr0XZZO9C1P0HjrQXdfbMetd0v4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，我们拿到A、B、C三个流表，拿到之后先根据其对应的组件去做keyBy操作，再去做窗口聚合。窗口聚合的功能是什么？在实际业务过程中，A表的业务数据在处理过程中可能存在事务操作。它的事务操作里面可能存在先签了一条记录，然后再把里面改了一下某一个值；也可能先删了一条记录，然后又插入了一条记录。这取决于业务系统的多样性操作，所以可能存在业务上只做了一次变动，但发了若干条消息对应的binlog。那就需要首先对其进行微批处理，来减少我们处理的记录数，然后处理生成A、B、C一一对应的三个流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着再把它们进行格式转换，转换成对应的tuple。比如相同的一个格式，可能是表名、分组键、主键以及转换成的统一的Bean结构。此处需要注意的问题是，对更新这种操作需要拆分。具体有两类，一类是插入的tuple，一类是删除的tuple，它会有对应两条记录，一条删除的一条新增的。在统一格式之后，再把它们union(合并)到同一个流，然后根据相同的关联键去做keyBy。这个过程中合流统一keyBy，是想用这种方式把所有的需要关联的流数据通过相同的键去做keyBy然后做分发，保证的结果是使相同存储键的记录分发到相同slot，以提升缓存利用率。从KV Storage获取数据，或者过程中使用的缓存的高命中率，包括缓存的有效性，以及缓存一致性，即最终同样的一个key一定会落到同一个slot上去计算。这样就能够保证不会存在多个slot上都存了同一个关联键的一些信息，从而可以避免不一致或先后问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;得到keyBy之后的结果，下一步经过flatmap算子，可以把历史数据从cache缓存、KV存储中加载进来。加载进来之后再比较它们的消息的id，如果是最新记录则就写入cache及KV存储并向下发送记录。当A流来了，关联的是B流历史跟C流历史；当B流来了，同样会关联A流历史和C流历史。同理C流也是如此。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下一步把从hisStreams流中分拆加载出来的数据流，合并得到包含历史数据的A_all、B_all、C_all 中，并用于下一步SQL计算。这个功能是将A、B、C流映射成了A_all、B_all、C_all，即所有的SQL逻辑就都可以直接写Flink SQL并用这三个流表(A_all、B_all、C_all)去计算，如此就包含短时间内的历史数据在进行计算。当然如果缓存中有数据的话，就不需要从KV中加载。而且同样的key会发到同一个slot上，它的缓存的命中率是很高的。另外以上都是按关联键去存的，如果同时有A、B、C等多条消息来了之后，都会命中同一条KV存储的key，也会提升缓存命中率。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;规划&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以上是具体实现的方案，下面是我们后续的规划。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前在用户使用以上组件时，还存在较高的学习成本。后续我们可能会增加一个前端页面，可以直接生成基于类似流程图面板以及点击、拖拉拽等形式生成对应不同类型的组件。采用这种配置方式可以降低用户的学习成本，增加使用的便捷性。另外我们还要扩展底层对多种实时计算引擎的支持。现在采用RDDM Component Parse会把对应的组件转成Flink算子(keyBy、flatMap等)，但可能在某些应用场景下还会使用SparkStreaming，或其它实时计算引擎。针对这种场景，我们可以将其独立出来，供用户自由地选择实时计算引擎。在KV存储方面，目前以内部使用为主，暂时只支持HBase、redis这两类KV存储，也需要把这部分信息彻底地独立。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;今天的分享就到这里，谢谢大家。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在文末分享、点赞、在看，给个3连击呗~&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享嘉宾：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;289&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZfFZG3uicFhXh6VGdvk98b08a1KJyRQHstzZY2Xicv09eCBYMX8KIibWVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;免费福利：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&amp;amp;mid=2247566213&amp;amp;idx=1&amp;amp;sn=69e814aa3b3e8e988cc209ec942ee791&amp;amp;chksm=fbd671e9cca1f8ff9638e1b4c102e96faeb63db648aab222741b047fe357dcc8a37b9e126e0c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;互联网核心应用算法宝藏书PPT电子版下载！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;互联网核心应用算法宝藏书PPT电子版下载！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&amp;amp;mid=2247566135&amp;amp;idx=1&amp;amp;sn=9010e14646fbd877ff7da4165e0b2353&amp;amp;chksm=fbd6715bcca1f84d26d9fd178144c3acd465369fe3f5fe923e707790583189315c2dec4dbc36&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;大数据典藏版合集PPT电子书下载！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;大数据典藏版合集PPT电子书下载！&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;活动推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;1776&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1741&quot; data-galleryid=&quot;&quot; data-ratio=&quot;3.0722222222222224&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm0N8I0SyMfKANGoTtHU8BN3T3k9wBMt80mI237XrFP6DdINrUKKWOXCfica9q96liaK11MLeFdnKEuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关于我们：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;DataFun：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;专注于大数据、人工智能技术应用的分享与交流。发起于2017年，在北京、上海、深圳、杭州等城市举办超过100+线下和100+线上沙龙、论坛及峰会，已邀请近1000位专家和学者参与分享。其公众号 DataFunTalk 累计生产原创文章500+，百万+阅读，13万+精准粉丝。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1NTMyOTI4Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh87SyjsEtoRFs9iaLyPXYh9ls0BcsiaPDnFkg72xgLsvku13ZRYibyq93DgRoCaTaTkbJj7Hia4dvI1w/0?wx_fmt=png&quot; data-nickname=&quot;DataFunTalk&quot; data-alias=&quot;datafuntalk&quot; data-signature=&quot;专注于大数据、人工智能技术应用的分享与交流。致力于成就百万数据科学家。定期组织技术分享直播，并整理大数据、推荐/搜索算法、广告算法、NLP 自然语言处理算法、智能风控、自动驾驶、机器学习/深度学习等技术应用文章。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;🧐&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;，给个&lt;strong&gt;3连击&lt;/strong&gt;呗！&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4cfff02c589197c823dfec5ab0913f91</guid>
<title>被通知一个月后离职，我改了重要项目里的代码注释</title>
<link>https://toutiao.io/k/tnvopep</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.15625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YriaiaJPb26VN5koUu22VNrAnuXDfGLRs8w4tRT63wErRVia5ic9J4ZyzWLDwcKT1Ldrzibn8lWIAnCQmkMCAVEtuIg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;section&gt;整理｜燕珊、核子可乐&lt;/section&gt;&lt;section&gt;
当冲突爆发且到了必须让程序员离开时……那让他们“及时离开”吧。&lt;/section&gt;&lt;p&gt;假如你已经对某个开发人员下发解雇通知，你还会让他深度参与重要项目甚至把项目做完再走吗？放在今天，这个答案往往是显而易见的：不会。但如果是几十年前，那就未必了。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;来自程序员的“报复”&lt;/span&gt;&lt;/section&gt;&lt;p&gt;近日 The Register 上有个热门帖子正好讨论了类似的话题。帖子背景是这样的：一位叫做“Thomas”的读者，用自己的亲身经历带大家梦回 70 年代。Thomas 当时在一家咨询公司供职，客户则是某国家医疗保健服务商。那时候一片岁月静好，如今这些“笨重”的工具库还远未出现。当时的开发思路非常明确：节约资源、优化代码。&lt;/p&gt;&lt;p&gt;Thomas 回忆道，当时所有代码都是用汇编语言写的，对于那些从未深入了解过的人来说，这就像是机器代码。“我们还得尽量为代码瘦身，这里头也涉及不少技巧。但现在大家已经不在乎了，充裕的资源让节约成了老古董。”&lt;/p&gt;&lt;p&gt;那时候 Thomas 才刚刚出道，从被他称为“二货”的前任手中接下来项目。Thomas 坦言，这位二货“其实很聪明，但又特别招人烦。”但看得出来，这并不是二货同学的本意，而是项目经理们不理解真实工作量、又把项目周期压得太紧。&lt;/p&gt;&lt;p&gt;尽管困难重重，二货同学还是坚持了下来。为了完成代码编写，他每周工作 100 个小时以上。Thomas 还记得，“他真的很想多加班、早点做完，但管理层却认为他只是想骗加班费。”&lt;/p&gt;&lt;p&gt;于是乎，二货跟管理层之间爆发了激烈冲突，最终他被解雇、上头还勒令他用一个月时间把项目做完。&lt;/p&gt;&lt;p&gt;一般人在这种状况下肯定要在项目里埋雷，但二货同学的报复方法却是另辟蹊径。你觉得 C 语言不好理解？那是还没跟汇编语言比较。要想理解汇编代码，良好的注释绝对必不可少。&lt;/p&gt;&lt;p&gt;所以二货更改了代码中的所有注释。乍看上去，这些注释还挺像那么回事，但实际内容跟代码功能已经没有任何关系了。&lt;/p&gt;&lt;p&gt;“接手工作之后，我的第一项任务就是为项目添加更多功能。这事当然做不成，因为我根本没法通过注释理解现有代码的作用。”情况被报了上去，但管理层压根不以为意，于是 Thomas 担心自己可能也会被解雇。为了保住工作，他又对代码进行了多次复核，结论是：注释完全是在胡说八道，没人能搞清这些代码到底在干什么。&lt;/p&gt;&lt;p&gt;“所以我最后只能删掉所有注释，再把二货同学的‘遗产’黑盒化。一年之后，我离开了项目组，但这些黑盒代码还是继续运行了五年，直到另外一家咨询公司全盘接管。”&lt;/p&gt;&lt;p&gt;但即使到今天，这些代码可能还是在某个隐秘的角落保持着运行。毕竟，黑盒代码就跟蟑螂一样顽强。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;别瞎冒险&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;显而易见，Thomas 这个故事告诉我们的是，如果你想解雇某人，就该马上请他离开且别再碰项目了。&lt;/p&gt;&lt;p&gt;一名叫 Dave K 的网友对此深以为然，他认为，只要决定解雇任何重要人物，就要马上撤销这个人的访问权限，最好能让其马上离开。这相当于是尽职工作，对劳资双方都是保护。&lt;/p&gt;&lt;p&gt;Dave K 举例他曾面临过的类似状况——但被解雇的不是他，而是其顶头上司。人力通知说公司已经确定要被收购，新的母公司认为没必要保留两位 IT 主管。于是他当场就禁用了领导的账户、更改了所有共享密码（管理员账户密码），确保上司再也没法访问任何系统。“听起来挺残忍的，但这就是职业性。”——不管你多信任对方，只要确定离职了、这些权限就必须收回。&lt;/p&gt;&lt;p&gt;的确，另一角度来看，这确实未尝不是对离职者的保护。网友 yetanotheraoc 表示，“如果有人在我们被解雇后不久破坏了系统，那已经交出所有权限的我们至少不会成为被怀疑的对象、自然也不会成为无辜的替罪羊。”&lt;/p&gt;&lt;p&gt;“别瞎冒险”尤其是指要避免一些比较极端的人和情况，需果断下决定。有网友分享说，曾接触过那种技术很强、但完全让人无法与之共事的家伙——他不给代码写注释、也不参加例会，因为他觉得自己很聪明，认定这些事情都是浪费时间。他还放出豪言，“如果他们蠢到理解不了我写的东西，那也不是我的问题。”最后，管理层做了早就该做的决定。那天是周五，例会对这位自负的人进行了 5 分钟的简短批判，会上还出现了让该网友至今记忆犹新的金句，“你一直觉得没有你我们就做不成事，但从下周一开始，我们打算试试。”&lt;/p&gt;&lt;p&gt;再比如有网友分享了个报复的例子，公司 CEO 在某次会上当着大家的面，解雇了一位态度傲慢的工程师。这人真的不讨喜，所以看着他离开大家并没什么感觉。然而，在动用了如此激烈的裁撤手段之后，公司居然还让他在办公桌前过完这一整天。当天下班之后，办公楼门禁瘫痪、账户被锁定，所有主要服务器都被重启、内容全部擦除。大家几乎都知道是他干的，但因为定时脚本已在重启后被擦除，所以人们找不到证据。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;摸鱼度过最后的在职时光&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;从裁员方的立场，别瞎冒险、当断则断是要义。而从离职者的角度，何尝不是如此。但若“被迫”必须得多待一段时间，心安理得地“摸鱼”未尝不是一个解决方案。&lt;/p&gt;&lt;p&gt;网友 Ken G 回忆道，在 1999 年 10 月下旬他接到部门发出的通告，第二年 1 月他就要离职了。其实他之前负责的项目根本不受千年虫问题的影响，项目文档已经更新完毕、交接工作也相当顺利，但项目经理还是希望他能“小心谨慎”。问题是，有什么可小心的？于是他只能嘴上回答“是是是”，另一边该休年假休年假。&lt;/p&gt;&lt;p&gt;休了 5 周年假之后，到了第二年的 1 月 4 号，Ken G 回到办公室。他日常就跟同事们聊天、泡茶，随便上上网。这样的日子他重复了一个月直到离职。&lt;/p&gt;&lt;p&gt;接着 Ken G 的回忆，也有留言给出了类似的经历，名为 DS999 的网友说：我被迫在企业里度过了 3 个月的“垃圾时间”，之前我以外包商的身份负责 SAP 项目中的 Unix 与存储工作，合同应该在当年 5 月就结束了。但因为那位全职员工一直在忙着无薪加班和夜间维护，公司决定把他升任成技术顾问，薪水一下涨了 3 倍。之前他已经帮工程部门的 Unix 团队培训过几位抽调过来的新人，但他们才刚刚接触项目、对很多问题还不熟悉。&lt;/p&gt;&lt;p&gt;“于是乎，我就成了唯一一位了解整套系统的人，公司意识到必须把外包合同再延长几个月。为了帮甲方度过难关，我接下了这份时薪 30 美元、为期三个月的延期职位。但接下来的情况属实出人意料：两位全职新人找上我，希望我别碰项目里的任何东西，只需要回答他们的问题。因为在他们看来，在我离开之后，所有工作就只能由他们接管了。所以他们宁愿问题出在当下、也别出在交接之后，免得让他们背锅。”所以，DS999 倒是成了真正意义上的顾问。整个夏天，他都在上网、发呆、鼓捣 Linux。刚开始他们每天还会提出几个问题，后来连着一个半月都没找过他。“这钱真的好赚，怀念。”&lt;/p&gt;&lt;p&gt;具体情况具体对待。也许，报复或不报复并不是关键。Steve Herseyren 认为 Thomas 故事里的深层寓意是这样的：“既然你都说了‘项目经理们不理解真实工作量、又把项目周期压得太紧’，那这家公司就是妥妥的垃圾场，任何自尊自爱的人都应该尽快离开、躲得越远越好。你的技能、时间和自我价值真的很宝贵，别再给雇主虐待你的机会了。赶紧跑，找个更靠谱的去处。当然，如果你特别需要这笔工资，那就明确规划一下还要忍耐多久、然后早点找机会离开。”&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考链接：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;https://www.theregister.com/2022/04/04/who_me/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;https://forums.theregister.com/forum/all/2022/04/04/who_me/&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;今日好文推荐&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651112018&amp;amp;idx=1&amp;amp;sn=5fab2464631c4b1f05ace6a67090478b&amp;amp;chksm=bdb93a018aceb317d37828549580f96cb5097d7fef261605ce8338e4142461255368d0121403&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;泛型会让你的 Go 代码运行变慢&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;泛型会让你的 Go 代码运行变慢&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651111956&amp;amp;idx=1&amp;amp;sn=e6be0c4f7b27cb7108049eaf5452294c&amp;amp;chksm=bdb93a478aceb351818a476fa714f326802383ce394f5b8529fe09e7e377bd0b3dbcf9a15a11&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;HTML5崛起之时，Java桌面时代就已经终结了&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;HTML5崛起之时，Java桌面时代就已经终结了&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651111905&amp;amp;idx=1&amp;amp;sn=07ea419d3211c76030ddf980671647c4&amp;amp;chksm=bdb939b28aceb0a4b455b11bbe577da64f11790f51fb3c97fbfe7c01e1fa13b67fe3c8d98745&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;互联网企业给被裁员工发“毕业须知”；孟晚舟担任华为轮值董事长；腾讯员工被曝偷看创业公司工作文档 | Q资讯&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;互联网企业给被裁员工发“毕业须知”；孟晚舟担任华为轮值董事长；腾讯员工被曝偷看创业公司工作文档 | Q资讯&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651111518&amp;amp;idx=1&amp;amp;sn=ffeb59fa91740f58805dc645b4514ef1&amp;amp;chksm=bdb9380d8aceb11b31fa55cb361ac2a78c643e98955eaed12e51b0abf1ddcde31f045c841c06&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;云端开发是个坑！4年后，我们又回到了本地环境&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;云端开发是个坑！4年后，我们又回到了本地环境&lt;/a&gt;&lt;span&gt;     
       &lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;活动推荐&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fc6ded4e6973937591fa01d39fa5160f</guid>
<title>面试必备：聊聊分布式锁的多种实现！</title>
<link>https://toutiao.io/k/kypk9q4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是&lt;strong&gt;捡田螺的小男孩&lt;/strong&gt;。今天跟大家探讨一下分布式锁的设计与实现。希望对大家有帮助，如果有不正确的地方，欢迎指出，一起学习，一起进步哈~&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;分布式锁概述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Zookeeper分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;三种分布式锁对比&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 分布式锁概述&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的系统都是分布式部署的，日常开发中，&lt;strong&gt;秒杀下单、抢购商品&lt;/strong&gt;等等业务场景，为了防⽌库存超卖，都需要用到&lt;strong&gt;分布式锁&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业界流行的分布式锁实现，一般有这3种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;基于数据库实现的分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于Redis实现的分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于Zookeeper实现的分布式锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 基于数据库的分布式锁&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 数据库悲观锁实现的分布式锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;code&gt;select ... for update &lt;/code&gt;来实现分布式锁。我们自己的项目，&lt;strong&gt;分布式定时任务&lt;/strong&gt;，就使用类似的实现方案，我给大家来展示个&lt;strong&gt;简单版的哈&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CREATE TABLE `t_resource_lock` (&lt;br/&gt;  `key_resource` varchar(45) COLLATE utf8_bin NOT NULL DEFAULT &lt;span&gt;&#x27;资源主键&#x27;&lt;/span&gt;,&lt;br/&gt;  `status` char(1) COLLATE utf8_bin NOT NULL DEFAULT &lt;span&gt;&#x27;&#x27;&lt;/span&gt; COMMENT &lt;span&gt;&#x27;S,F,P&#x27;&lt;/span&gt;,&lt;br/&gt;  `lock_flag` int(10) unsigned NOT NULL DEFAULT &lt;span&gt;&#x27;0&#x27;&lt;/span&gt; COMMENT &lt;span&gt;&#x27;1是已经锁 0是未锁&#x27;&lt;/span&gt;,&lt;br/&gt;  `begin_time` datetime DEFAULT NULL COMMENT &lt;span&gt;&#x27;开始时间&#x27;&lt;/span&gt;,&lt;br/&gt;  `end_time` datetime DEFAULT NULL COMMENT &lt;span&gt;&#x27;结束时间&#x27;&lt;/span&gt;,&lt;br/&gt;  `client_ip` varchar(45) COLLATE utf8_bin NOT NULL DEFAULT &lt;span&gt;&#x27;抢到锁的IP&#x27;&lt;/span&gt;,&lt;br/&gt;  `time` int(10) unsigned NOT NULL DEFAULT &lt;span&gt;&#x27;60&#x27;&lt;/span&gt; COMMENT &lt;span&gt;&#x27;方法生命周期内只允许一个结点获取一次锁，单位：分钟&#x27;&lt;/span&gt;,&lt;br/&gt;  PRIMARY KEY (`key_resource`) USING BTREE&lt;br/&gt;) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁&lt;code&gt;lock&lt;/code&gt;方法的伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Transcational //一定要加事务&lt;br/&gt;public boolean lock(String &lt;span&gt;keyRe&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;，int time){&lt;br/&gt;   resourceLock = &lt;span&gt;&#x27;select * from t_resource_lock where key_resource =&#x27;&lt;/span&gt;&lt;span&gt;#{keySource}&#x27; for update&#x27;;&lt;/span&gt;&lt;br/&gt;   &lt;br/&gt;   try{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(resourceLock==null){&lt;br/&gt;      //插入锁的数据&lt;br/&gt;      resourceLock = new ResourceLock();&lt;br/&gt;      resourceLock.setTime(time);&lt;br/&gt;      resourceLock.setLockFlag(1);  //上锁&lt;br/&gt;      resourceLock.setStatus(P); //处理中&lt;br/&gt;      resourceLock.setBeginTime(new Date());&lt;br/&gt;      int count = &lt;span&gt;&quot;insert into resourceLock&quot;&lt;/span&gt;; &lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(count==1){&lt;br/&gt;         //获取锁成功&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;   }&lt;br/&gt;   }catch(Exception x){&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;   }&lt;br/&gt;   &lt;br/&gt;   //没上锁并且锁已经超时，即可以获取锁成功&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(resourceLock.getLockFlag==&lt;span&gt;&#x27;0&#x27;&lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;&#x27;S&#x27;&lt;/span&gt;.equals(resourceLock.getstatus)&lt;br/&gt;    &amp;amp;&amp;amp; new Date()&amp;gt;=resourceLock.addDateTime(resourceLock.getBeginTime(,time)){&lt;br/&gt;      resourceLock.setLockFlag(1);  //上锁&lt;br/&gt;      resourceLock.setStatus(P); //处理中&lt;br/&gt;      resourceLock.setBeginTime(new Date());&lt;br/&gt;      //update resourceLock;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;   }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(new Date()&amp;gt;=resourceLock.addDateTime(resourceLock.getBeginTime(,time)){&lt;br/&gt;     //超时未正常执行结束,获取锁失败&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;   }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;   } &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解锁&lt;code&gt;unlock&lt;/code&gt;方法的伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public void unlock(String v，status){&lt;br/&gt;      resourceLock.setLockFlag(0);  //解锁&lt;br/&gt;      resourceLock.setStatus(status); S:表示成功，F表示失败&lt;br/&gt;      //update resourceLock;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体流程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;try{&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(lock(&lt;span&gt;keyRe&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;,time)){ //加锁&lt;br/&gt;   status = process();//你的业务逻辑处理。&lt;br/&gt; }&lt;br/&gt;} finally{&lt;br/&gt;    unlock(&lt;span&gt;&lt;span&gt;keyRe&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;/span&gt;,status); //释放锁&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这个悲观锁实现的分布式锁，整体的流程还是比较清晰的。就是先&lt;code&gt;select ... for update &lt;/code&gt;锁住主键&lt;code&gt;key_resource&lt;/code&gt;那个记录，如果为空，则可以插入一条记录，如果已有记录判断下&lt;strong&gt;状态和时间&lt;/strong&gt;，&lt;strong&gt;是否已经超时&lt;/strong&gt;。这里需要注意一下哈，必须要加&lt;strong&gt;事务&lt;/strong&gt;哈。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 数据库乐观锁实现的分布式锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了悲观锁，还可以用&lt;strong&gt;乐观锁实现分布式锁&lt;/strong&gt;。乐观锁，顾名思义，就是很乐观，每次更新操作，都觉得不会存在并发冲突，只有更新失败后，才重试。它是基于CAS思想实现的。我以前的公司，&lt;strong&gt;扣减余额&lt;/strong&gt;就是用这种方案。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;搞个version字段，每次更新修改，都会自增加一，然后去更新余额时，把查出来的那个版本号，带上条件去更新，如果是上次那个版本号，就更新，如果不是，表示别人并发修改过了，就继续重试。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;查询版本号和余额&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;select version,balance from account &lt;span&gt;where&lt;/span&gt; user_id =&lt;span&gt;&#x27;666&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设查到版本号是oldVersion=1.&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;逻辑处理，判断余额&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(balance&amp;lt;扣减金额){&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;；&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;left_balance = balance - 扣减金额;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;进行扣减余额&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;update account &lt;span&gt;set&lt;/span&gt; balance = &lt;span&gt;#{left_balance} ,version = version+1 where version &lt;/span&gt;&lt;br/&gt;= &lt;span&gt;#{oldVersion} and balance&amp;gt;= #{left_balance} and &lt;span&gt;use&lt;/span&gt;&lt;span&gt;r_id =&lt;/span&gt;&lt;span&gt;&#x27;666&#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以看下这个流程图哈：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2335600907029478&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WJsIDNsJ3NhVQicicLAd2B6pa8UczfIuLicF6R1yKphZ5TZ1N0pBZKP9aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;882&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种方式适合&lt;strong&gt;并发不高&lt;/strong&gt;的场景，一般需要设置一下重试的次数&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.基于Redis实现的分布式锁&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis分布式锁一般有以下这几种实现方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;setnx + expire&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;setnx + value值是过期时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;set的扩展命令（set ex px nx）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;set ex px nx + 校验唯一随机值,再删除&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redisson&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redisson + RedLock&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 setnx + expire&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聊到Redis分布式锁，很多小伙伴反手就是&lt;code&gt;setnx + expire&lt;/code&gt;，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;（jedis.setnx(key,lock_value) == 1）{ //setnx加锁&lt;br/&gt;    expire（key，100）; //设置过期时间&lt;br/&gt;    try {&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; something  //业务处理&lt;br/&gt;    }&lt;span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;    }&lt;br/&gt;  finally {&lt;br/&gt;       jedis.del(key); //释放锁&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码是可以加锁成功，但是你有没有发现问题，&lt;strong&gt;加锁操作和设置超时时间是分开的&lt;/strong&gt;。假设在执行完&lt;code&gt;setnx&lt;/code&gt;加锁后，正要执行&lt;code&gt;expire&lt;/code&gt;设置过期时间时，进程&lt;code&gt;crash&lt;/code&gt;掉或者要重启维护了，那这个锁就&lt;strong&gt;长生不老&lt;/strong&gt;了，别的线程永远获取不到锁啦，所以&lt;strong&gt;分布式锁不能这么实现&lt;/strong&gt;！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 setnx + value值是过期时间&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;long expires = System.currentTimeMillis() + expireTime; //系统时间+设置的过期时间&lt;br/&gt;String expiresStr = String.valueOf(expires);&lt;br/&gt;&lt;br/&gt;// 如果当前锁不存在，返回加锁成功&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (jedis.setnx(key, expiresStr) == 1) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;} &lt;br/&gt;// 如果锁已经存在，获取锁的过期时间&lt;br/&gt;String currentValueStr = jedis.get(key);&lt;br/&gt;&lt;br/&gt;// 如果获取到的过期时间，小于系统当前时间，表示已经过期&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (currentValueStr != null &amp;amp;&amp;amp; Long.parseLong(currentValueStr) &amp;lt; System.currentTimeMillis()) {&lt;br/&gt;&lt;br/&gt;     // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间（不了解redis的getSet命令的小伙伴，可以去官网看下哈）&lt;br/&gt;    String oldValueStr = jedis.getSet(key, expiresStr);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (oldValueStr != null &amp;amp;&amp;amp; oldValueStr.equals(currentValueStr)) {&lt;br/&gt;         // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;        &lt;br/&gt;//其他情况，均返回加锁失败&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常开发中，有些小伙伴就是这么实现分布式锁的，但是会有这些&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;过期时间是客户端自己生成的，分布式环境下，&lt;strong&gt;每个客户端的时间必须同步。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有保存持有者的唯一标识，&lt;strong&gt;可能被别的客户端释放/解锁&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;锁过期的时候，并发多个客户端同时请求过来，都执行了&lt;code&gt;jedis.getSet()&lt;/code&gt;，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，&lt;strong&gt;可能被别的客户端覆盖。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3  set的扩展命令(set ex px nx)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个命令的几个参数分别表示什么意思呢？跟大家复习一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SET key value [EX seconds] [PX milliseconds] [NX|XX]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;EX second ：设置键的过期时间为&lt;code&gt;second&lt;/code&gt;秒。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PX millisecond ：设置键的过期时间为&lt;code&gt;millisecond&lt;/code&gt;毫秒。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NX ：只在键不存在时，才对键进行设置操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;XX ：只在键已经存在时，才对键进行设置操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;（jedis.set(key, lock_value, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;EX&quot;&lt;/span&gt;, 100s) == 1）{ //加锁&lt;br/&gt;    try {&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; something  //业务处理&lt;br/&gt;    }&lt;span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;  }&lt;br/&gt;  finally {&lt;br/&gt;       jedis.del(key); //释放锁&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案可能存在这样的问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些伙伴可能会有个疑问，就是&lt;strong&gt;锁为什么会被别的线程误删&lt;/strong&gt;呢？假设并发多线程场景下，&lt;strong&gt;线程A获得了锁，但是它没释放锁的话，线程B是获取不到锁的&lt;/strong&gt;，所以按道理它是执行不到加锁下面的代码滴，怎么会导致锁被别的线程误删呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;假设线程A和B，都想用&lt;code&gt;key&lt;/code&gt;加锁，最后A抢到锁加锁成功，但是由于执行业务逻辑的耗时很长，超过了设置的超时时间&lt;code&gt;100s&lt;/code&gt;。这时候，Redis就自动释放了&lt;code&gt;key&lt;/code&gt;锁。这时候线程B就可以加锁成功了，接下啦，它也执行业务逻辑处理。假设碰巧这时候，A执行完自己的业务逻辑，它就去释放锁，但是它就把B的锁给释放了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4 set ex px nx + 校验唯一随机值,再删除&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决&lt;strong&gt;锁被别的线程误删&lt;/strong&gt;问题。可以在&lt;code&gt;set ex px nx&lt;/code&gt;的基础上，加上个校验的唯一随机值，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;（jedis.set(key, uni_request_id, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;EX&quot;&lt;/span&gt;, 100s) == 1）{ //加锁&lt;br/&gt;    try {&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; something  //业务处理&lt;br/&gt;    }&lt;span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;  }&lt;br/&gt;  finally {&lt;br/&gt;       //判断是不是当前线程加的锁,是才释放&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (uni_request_id.equals(jedis.get(key))) {&lt;br/&gt;          jedis.del(key); //释放锁&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里，判断当前线程加的锁和释放锁&lt;strong&gt;不是一个原子操作&lt;/strong&gt;。如果调用&lt;code&gt;jedis.del()&lt;/code&gt;释放锁的时候，可能&lt;strong&gt;这把锁已经不属于当前客户端&lt;/strong&gt;，会解除他人加的锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般可以用lua脚本来包一下。lua脚本如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; redis.call(&lt;span&gt;&#x27;get&#x27;&lt;/span&gt;,KEYS[1]) == ARGV[1] &lt;span&gt;then&lt;/span&gt; &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; redis.call(&lt;span&gt;&#x27;del&#x27;&lt;/span&gt;,KEYS[1]) &lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; 0&lt;br/&gt;end;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式比较不错了，一般情况下，已经可以使用这种实现方式。但是还是存在：&lt;strong&gt;锁过期释放了，业务还没执行完的问题&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.5 Redisson&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于可能存在&lt;strong&gt;锁过期释放，业务没执行完&lt;/strong&gt;的问题。我们可以稍微把锁过期时间设置长一些，大于正常业务处理时间就好啦。如果你觉得不是很稳，还可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前开源框架Redisson解决了这个问题。可以看下Redisson底层原理图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6277777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WhXGhJU7kpgiapXIr1LchBwLdhVeKr7A0elDdavt3yDzZhrhdrCdxd2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要线程一加锁成功，就会启动一个&lt;code&gt;watch dog&lt;/code&gt;看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用&lt;code&gt;watch dog&lt;/code&gt;解决了&lt;strong&gt;锁过期释放，业务没执行完问题&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.6 Redisson + RedLock&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面六种方案都只是基于&lt;strong&gt;Redis单机版&lt;/strong&gt;的分布式锁讨论，还不是很完美。因为&lt;strong&gt;Redis&lt;/strong&gt;一般都是集群部署的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3738229755178908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WbTxA3drXiaqSxUnPCct5EgxbR0wibQ11QpYKsl99Q9B3DCf9b84xr2gQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1062&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线程一在&lt;code&gt;Redis&lt;/code&gt;的&lt;code&gt;master&lt;/code&gt;节点上拿到了锁，但是加锁的&lt;code&gt;key&lt;/code&gt;还没同步到&lt;code&gt;slave&lt;/code&gt;节点。恰好这时，&lt;code&gt;master&lt;/code&gt;节点发生故障，一个&lt;code&gt;slave&lt;/code&gt;节点就会升级为&lt;code&gt;master&lt;/code&gt;节点。线程二就可以顺理成章获取同个&lt;code&gt;key&lt;/code&gt;的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，Redis作者antirez提出一种高级的分布式锁算法：&lt;strong&gt;Redlock&lt;/strong&gt;。它的核心思想是这样的：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;部署多个Redis master，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们假设当前有5个Redis master节点，在5台服务器上面运行这些Redis实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4W81f479ib5AYGplGTe5TP1vOCqu2oTZotaXQ1dCZMibPicpjUGv6locoAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;RedLock的实现步骤:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取当前时间，以毫秒为单位。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间,我们就假设超时时间是50ms吧）。如果超时，跳过该master节点，尽快去尝试下一个master节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端使用当前时间减去开始获取锁时间（即步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1，这里是5/2+1=3个节点）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，10s&amp;gt; 30ms+40ms+50ms+4m0s+50ms）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果取到了锁，key的真正有效时间就变啦，需要减去获取锁所使用的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果获取锁失败（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简化下步骤就是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;按顺序向5个master节点请求加锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据设置的超时时间来判断，是不是要跳过该master节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果获取锁失败，解锁！&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Redisson实现了redLock版本的锁&lt;/strong&gt;，有兴趣的小伙伴，可以去了解一下哈~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Zookeeper分布式锁&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在学习Zookeeper分布式锁之前，我们复习一下Zookeeper的节点哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zookeeper的节点Znode有四种类型：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;持久节点&lt;/strong&gt;：默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;持久节点顺序节点&lt;/strong&gt;：所谓顺序节点，就是在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号，持久节点顺序节点就是有顺序的持久节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;临时节点&lt;/strong&gt;：和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;临时顺序节点&lt;/strong&gt;：有顺序的临时节点。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zookeeper分布式锁实现应用了&lt;strong&gt;临时顺序节点&lt;/strong&gt;。这里不贴代码啦，来讲下zk分布式锁的实现原理吧。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.1 zk获取锁过程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当第一个客户端请求过来时，Zookeeper客户端会创建一个持久节点&lt;code&gt;locks&lt;/code&gt;。如果它（Client1）想获得锁，需要在&lt;code&gt;locks&lt;/code&gt;节点下创建一个顺序节点&lt;code&gt;lock1&lt;/code&gt;.如图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5101851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WKNicIzdiciclyicA7eEXIibicq6t4DEWoicwehdgHso6goKqIZwT6iaHWA62hA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，客户端Client1会查找&lt;code&gt;locks&lt;/code&gt;下面的所有临时顺序子节点，判断自己的节点&lt;code&gt;lock1&lt;/code&gt;是不是排序最小的那一个，如果是，则成功获得锁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5101851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WtPstSP6MVv1EgVFibBvHJXARQTias1m9f1HBTQYxD8fxbwmfW4QW4mVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候如果又来一个客户端client2前来尝试获得锁，它会在locks下再创建一个临时节点&lt;code&gt;lock2&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5018518518518519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WUe2KfHbZxqq1HydWw244eoTCusib2qFYbFNfzAoZvP0ia7rErqkXdaWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端client2一样也会查找&lt;span&gt;locks&lt;/span&gt;下面的所有临时顺序子节点，判断自己的节点&lt;span&gt;lock2&lt;/span&gt;是不是最小的，此时，发现&lt;span&gt;lock1&lt;/span&gt;才是最小的，于是获取锁失败。获取锁失败，它是不会甘心的，client2向它排序靠前的节点&lt;span&gt;lock1&lt;/span&gt;注册&lt;span&gt;Watcher&lt;/span&gt;事件，用来监听&lt;span&gt;lock1&lt;/span&gt;是否存在，也就是说client2抢锁失败进入等待状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.524074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WsuEjzIcW3yNzXHPiaGWNLoU2I6icH1Fd5jfMI5mjlhG8zcujzSVVGXRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果再来一个客户端Client3来尝试获取锁，它会在locks下再创建一个临时节点&lt;span&gt;lock3&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5222222222222223&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WNicPWtvZaRia4DSgdIbtYZ3ccnViajVKkiahuFXxeHXdDIhrwaCVa4Oreg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;同样的，client3一样也会查找&lt;span&gt;locks&lt;/span&gt;下面的所有临时顺序子节点，判断自己的节点&lt;span&gt;lock3&lt;/span&gt;是不是最小的，发现自己不是最小的，就获取锁失败。它也是不会甘心的，它会向在它前面的节点&lt;span&gt;lock2&lt;/span&gt;注册&lt;span&gt;Watcher&lt;/span&gt;事件，以监听&lt;span&gt;lock2&lt;/span&gt;节点是否存在。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5138888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WIUM5SKj6ibSLEJ3zIicXBnoOUDBk4j9JoI4OEiaKCvc21JIXzxlTjhaLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 释放锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看看释放锁的流程，Zookeeper的客户端业务完成或者发生故障，都会删除临时节点，释放锁。如果是任务完成，Client1会显式调用删除&lt;span&gt;lock1&lt;/span&gt;的指令&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5194444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WOsJWicJwDQbibOxVic5PBUZcPIYGqyCict2zYtsVvkD1UNgGPzJtLfiasrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是客户端故障了，根据临时节点得特性，&lt;span&gt;lock1&lt;/span&gt;是会自动删除的&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48518518518518516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4Wlu90z3dSWJcK82exrgj0zVEITnkCZTTWbb2Q13nA5amibJQC6libztzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;lock1&lt;/span&gt;节点被删除后，Client2可开心了，因为它一直监听着&lt;span&gt;lock1&lt;/span&gt;。&lt;span&gt;lock1&lt;/span&gt;节点删除，Client2立刻收到通知，也会查找&lt;span&gt;locks&lt;/span&gt;下面的所有临时顺序子节点，发下&lt;span&gt;lock2&lt;/span&gt;是最小，就获得锁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5574074074074075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WTaNEmGzfRdBN9ngKic6yOVeELSdDyDxqgkKFXq3IibBovCM9E52OR8AQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，Client2获得锁之后，Client3也对它虎视眈眈，啊哈哈~&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Zookeeper设计定位就是分布式协调，简单易用。如果获取不到锁，只需添加一个监听器即可，很适合做分布式锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Zookeeper作为分布式锁也缺点：如果有很多的客户端频繁的申请加锁、释放锁，对于Zookeeper集群的压力会比较大。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 三种分布式锁对比&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.1 数据库分布式锁实现&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;简单，使用方便，不需要引入&lt;code&gt;Redis、zookeeper&lt;/code&gt;等中间件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 Redis分布式锁实现&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;性能好，适合高并发场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;较轻量级&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有较好的框架支持，如&lt;span&gt;Redisson&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 Zookeeper分布式锁实现&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;性能不如redis实现的分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比较重的分布式锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;有较好的性能和可靠性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有封装较好的框架，如Curator&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.4 对比汇总&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;从性能角度（从高到低）Redis &amp;gt; Zookeeper &amp;gt;= 数据库；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从理解的难易程度角度（从低到高）数据库 &amp;gt; Redis &amp;gt; Zookeeper；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从实现的复杂性角度（从低到高）Zookeeper &amp;gt; Redis &amp;gt; 数据库；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从可靠性角度（从高到低）Zookeeper &amp;gt; Redis &amp;gt; 数据库。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后(求关注，别白嫖我)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这篇文章对您有所帮助，或者有所启发的话，求一键三连：点赞、转发、在看，您的支持是我坚持写作最大的动力。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>