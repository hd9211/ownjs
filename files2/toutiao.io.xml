<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>83eed925f23bae3547d998c76c48e4be</guid>
<title>有了 RestTemplate 你还在手撕写 HttpClient？</title>
<link>https://toutiao.io/k/zsvnw8f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;在微服务大行其道的今天，&lt;/span&gt;&lt;code&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;/code&gt;&lt;span&gt;调用是程序员无法避免的常规操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;RestTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是&lt;/span&gt;&lt;code&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;/code&gt;&lt;span&gt;提供的一个，用于发起&lt;/span&gt;&lt;code&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;/code&gt;&lt;span&gt;调用的客户端。相比于传统的&lt;/span&gt;&lt;code&gt;&lt;span&gt;HttpComponents&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;&lt;span&gt;RestTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt;使用起来更简单，更方便。&lt;/span&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;发起Get请求&lt;/span&gt;&lt;/h5&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;获取&lt;/span&gt;&lt;code&gt;&lt;span&gt;JSON&lt;/span&gt;&lt;/code&gt;&lt;span&gt;类型的返回&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;RestTemplate restTemplate = &lt;span&gt;new&lt;/span&gt; RestTemplate();&lt;br/&gt;String fooResourceUrl = &lt;span&gt;&quot;http://localhost:8080/spring-rest/foos&quot;&lt;/span&gt;;&lt;br/&gt;ResponseEntity&amp;lt;String&amp;gt; response = restTemplate.getForEntity(fooResourceUrl + &lt;span&gt;&quot;/1&quot;&lt;/span&gt;, String&lt;span&gt;.class)&lt;/span&gt;;&lt;br/&gt;assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;获取&lt;/span&gt;&lt;code&gt;&lt;span&gt;POJO&lt;/span&gt;&lt;/code&gt;&lt;span&gt;类型的返回 我们定义一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;/code&gt;&lt;span&gt;类&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class Foo implements Serializable &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name; &lt;br/&gt;    &lt;span&gt;// standard getters and setters &lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;&lt;code&gt;&lt;span&gt;RestTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt;发起&lt;/span&gt;&lt;code&gt;&lt;span&gt;Get&lt;/span&gt;&lt;/code&gt;&lt;span&gt;请求&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Foo foo = restTemplate .getForObject(fooResourceUrl + &lt;span&gt;&quot;/1&quot;&lt;/span&gt;, Foo&lt;span&gt;.class)&lt;/span&gt;; &lt;br/&gt;assertThat(foo.getName(), notNullValue()); assertThat(foo.getId(), is(&lt;span&gt;1L&lt;/span&gt;));&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;获取Header信息&lt;/span&gt;&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;HttpHeaders httpHeaders = restTemplate.headForHeaders(fooResourceUrl); &lt;br/&gt;&lt;span&gt;//获取ContentType&lt;/span&gt;&lt;br/&gt;assertTrue(httpHeaders.getContentType().includes(MediaType.APPLICATION_JSON));&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;发起Post请求&lt;/span&gt;&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;RestTemplate restTemplate = &lt;span&gt;new&lt;/span&gt; RestTemplate();&lt;br/&gt;HttpEntity&amp;lt;Foo&amp;gt; request = &lt;span&gt;new&lt;/span&gt; HttpEntity&amp;lt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; Foo(&lt;span&gt;&quot;bar&quot;&lt;/span&gt;));&lt;br/&gt;Foo foo = restTemplate.postForObject(fooResourceUrl, request, Foo&lt;span&gt;.class)&lt;/span&gt;;&lt;br/&gt;assertThat(foo, notNullValue());&lt;br/&gt;assertThat(foo.getName(), is(&lt;span&gt;&quot;bar&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;模拟Form表单提交&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;POST&lt;/span&gt;&lt;/code&gt;&lt;span&gt;方式提交表单数据，首先需要设置头部信息，将&lt;/span&gt;&lt;code&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设置为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;application/x-www-form-urlencoded&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们将表单中的数据项封装进&lt;/span&gt;&lt;code&gt;&lt;span&gt;Map&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。最后将&lt;/span&gt;&lt;code&gt;&lt;span&gt;Header&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和表单数据一起封装成&lt;/span&gt;&lt;code&gt;&lt;span&gt;HttpEntity&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码示例如下&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;HttpHeaders headers = &lt;span&gt;new&lt;/span&gt; HttpHeaders(); &lt;br/&gt;&lt;span&gt;//设置头部信息&lt;/span&gt;&lt;br/&gt;headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);&lt;br/&gt;&lt;span&gt;//将表单信息封装进Map&lt;/span&gt;&lt;br/&gt;MultiValueMap&amp;lt;String, String&amp;gt; map= &lt;span&gt;new&lt;/span&gt; LinkedMultiValueMap&amp;lt;&amp;gt;(); &lt;br/&gt;map.add(&lt;span&gt;&quot;id&quot;&lt;/span&gt;, &lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//将表单数据封装进HttpEntity&lt;/span&gt;&lt;br/&gt;HttpEntity&amp;lt;MultiValueMap&amp;lt;String, String&amp;gt;&amp;gt; request = &lt;span&gt;new&lt;/span&gt; HttpEntity&amp;lt;&amp;gt;(map, headers);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//发起POST请求&lt;/span&gt;&lt;br/&gt;ResponseEntity&amp;lt;String&amp;gt; response = restTemplate.postForEntity( fooResourceUrl+&lt;span&gt;&quot;/form&quot;&lt;/span&gt;, request , String&lt;span&gt;.class)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;assertThat(response.getStatusCode(), is(HttpStatus.CREATED));&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;通过PUT方式更新资源&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;更新资源既可以通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;PUT&lt;/span&gt;&lt;/code&gt;&lt;span&gt;方法，也可以通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;exchange()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。示例如下。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Foo updatedInstance = &lt;span&gt;new&lt;/span&gt; Foo(&lt;span&gt;&quot;newName&quot;&lt;/span&gt;); &lt;br/&gt;&lt;br/&gt;updatedInstance.setId(createResponse.getBody().getId()); &lt;br/&gt;&lt;br/&gt;String resourceUrl = fooResourceUrl + &lt;span&gt;&#x27;/&#x27;&lt;/span&gt; + createResponse.getBody().getId();&lt;br/&gt;HttpEntity&amp;lt;Foo&amp;gt; requestUpdate = &lt;span&gt;new&lt;/span&gt; HttpEntity&amp;lt;&amp;gt;(updatedInstance, headers); &lt;br/&gt;&lt;span&gt;//通过exchange发送PUT类型请求&lt;/span&gt;&lt;br/&gt;template.exchange(resourceUrl, HttpMethod.PUT, requestUpdate, Void&lt;span&gt;.class)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//直接通过putAPI进行更新&lt;/span&gt;&lt;br/&gt;template.put(resourceUrl,requestUpdate,Void&lt;span&gt;.class)&lt;/span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;发起DELETE请求&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;delete&lt;/span&gt;&lt;/code&gt;&lt;span&gt;删除资源。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;String entityUrl = fooResourceUrl + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + existingResource.getId();&lt;br/&gt;restTemplate.delete(entityUrl);&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;通过exchange()发起请求&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;exchange()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;方法可以发起任意类型的&lt;/span&gt;&lt;code&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;/code&gt;&lt;span&gt;请求。代码示例如下。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;RestTemplate restTemplate = &lt;span&gt;new&lt;/span&gt; RestTemplate();&lt;br/&gt;HttpEntity&amp;lt;Foo&amp;gt; request = &lt;span&gt;new&lt;/span&gt; HttpEntity&amp;lt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; Foo(&lt;span&gt;&quot;bar&quot;&lt;/span&gt;)); &lt;br/&gt;&lt;span&gt;//传递参数为HttpMethod.POST, 发起POST类型参数&lt;/span&gt;&lt;br/&gt;ResponseEntity&amp;lt;Foo&amp;gt; response = restTemplate .exchange(fooResourceUrl, HttpMethod.POST, request, Foo&lt;span&gt;.class)&lt;/span&gt;;&lt;br/&gt;assertThat(response.getStatusCode(), is(HttpStatus.CREATED));&lt;br/&gt;Foo foo = response.getBody();&lt;br/&gt;assertThat(foo, notNullValue());&lt;br/&gt;assertThat(foo.getName(), is(&lt;span&gt;&quot;bar&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;配置超时时间&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;span&gt;可以通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;ClientHttpRequestFactory&lt;/span&gt;&lt;/code&gt;&lt;span&gt;配置&lt;/span&gt;&lt;code&gt;&lt;span&gt;RestTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的超时时间。代码示例如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;RestTemplate restTemplate = &lt;span&gt;new&lt;/span&gt; RestTemplate(getClientHttpRequestFactory()); &lt;br/&gt;&lt;br/&gt;&lt;span&gt;private ClientHttpRequestFactory getClientHttpRequestFactory() &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; timeout = &lt;span&gt;5000&lt;/span&gt;;&lt;br/&gt;    HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = &lt;span&gt;new&lt;/span&gt; HttpComponentsClientHttpRequestFactory(); &lt;br/&gt;    clientHttpRequestFactory.setConnectTimeout(timeout);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; clientHttpRequestFactory;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;RestTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt;使用起来即简单又方便，&lt;/span&gt;&lt;code&gt;&lt;span&gt;RestTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的设计思想和&lt;/span&gt;&lt;code&gt;&lt;span&gt;JDBCTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt;如出一辙。相信这也是&lt;/span&gt;&lt;code&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的哲学。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;注意：现在&lt;/span&gt;&lt;code&gt;&lt;span&gt;RestTemplate&lt;/span&gt;&lt;/code&gt;&lt;span&gt;已经不被官方推荐使用，官方推荐使用&lt;/span&gt;&lt;code&gt;&lt;span&gt;WebClient&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。下一篇文章将会介绍&lt;/span&gt;&lt;code&gt;&lt;span&gt;WebClient&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的使用。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;本文内容主要翻译自 https://www.baeldung.com/rest-template&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484022&amp;amp;idx=1&amp;amp;sn=d3176ea73e48360b64c3f50e8fd622bf&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;1. Java并发编程那些事儿(十)——最后的总结&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484130&amp;amp;idx=1&amp;amp;sn=eb09dd99d1a8e892a3de73d898c04b0c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;2. 程序员应该掌握的常用网络问题定位工具&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483893&amp;amp;idx=1&amp;amp;sn=85f6a2063048cc244aedde3172444e32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;3. Awk这件上古神兵你会用了吗&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483852&amp;amp;idx=1&amp;amp;sn=6efb0db3d5dff639fae2aaec978c2160&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;4. 手把手教你搭建一套ELK日志搜索运维平台&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ea0e7b6343013d60ea60175c225ac2b</guid>
<title>[译] React 状态管理的前世，今生和未来</title>
<link>https://toutiao.io/k/ttvrzlk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;译者注：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实这篇文章&lt;strong&gt;并没有太多的干货&lt;/strong&gt;，但是它提供了时间维度的视角让我们去观察状态管理是怎么发展；这段简短的历史可以作为我们选择状态管理的参考资料，也可以作为一个技术雷达帮我们发现一些技术广度上的盲点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而我自知翻译仓促和语言能力匮乏，所以留下原文供大家参考；如果有更好的翻译建议和批评可以偷偷告诉我。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全文最有价值的部分可能就是未来部分“关于状态管理如何选择”的部分，不想看水文的可以直接划到最下面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文地址 &lt;/span&gt;&lt;span&gt;https://leerob.io/blog/react-state-management&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;React was introduced in May 2013. Its paradigm shift was that your UI was a function of your state. Given some component state, React can determine what your component will look like. React is built upon the idea of state. However, state has long been one of the most difficult parts of building a React application.&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自2013年5月面世以来，React 给前端带来了新的编程范式：UI 是状态的函数。给定组件一个状态，React 就能决定这个组件的样子。React 就是基于状态的概念来开发的。但是长久以来状态管理是使用 React 开发应用时最头痛的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Let&#x27;s imagine state management in React as a rugged tool belt. You&#x27;ve used this tool belt for years, slowly adding new tools as needed. Each tool serves a very specific purpose. You don&#x27;t use your hammer to screw in bolts. As a craftsman, you&#x27;ve learned the right time and place to use each tool.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果把 React 中状态管理比喻成一个工具箱，里面有一些你已经使用多年的老工具，而且你也会根据不同需要逐渐添加新的工具。每种工具用来解决一个特定的问题。作为代码匠，你知道在不同情况下使用不同工具来解决问题，绝不会用榔头来拧螺丝。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;State management with React is a rugged tool belt, but not everyone has the prior experience to know which tool to reach for. This post will explain the past, present, and future of state management to help you make the correct decision for your team, project, or organization.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;React的状态管理是一个重要的工具箱，但是并不是每个人都有如何筛选工具的经验。这篇文章就是想和大家厘清状态管理的前世，今生和未来，来帮助大家在团队、项目和组织中选择合适的状态管理工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;名词解释 Glossary&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Before we begin, it&#x27;s critical you understand some of the terms commonly used. These aren&#x27;t the canonical names. A few different variations of each float around, but the underlying ideas are the same:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在文章正式开始前，我们先定义下常用的几个名词解释。这些定义并不是专业定义，实际使用的时候也会有些变化，但是背后的概念是一样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;UI State&lt;/strong&gt; &lt;/span&gt;&lt;span&gt;State used for controlling interactive parts of our application (e.g. dark mode toggle, modals).&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;UI 状态&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; - 用来控制如何应用（如主题设置，模态窗口）如何交互的状态。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Server Cache State&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; – State from the server, which we cache on the client side for quick access (e.g. call an API, store the result, use it in multiple places).&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;远程缓存状态&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; - 将服务端的状态缓存在客户端，以便方便使用。（比如，调用一个 API，然后将结果保存，然后在各个组件中使用）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Form State&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;The many different states of a form (e.g. loading, submitting, disabled, validation, retrying). There&#x27;s also controlled &amp;amp; uncontrolled form state.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;表单状态&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; - 表单的各种状态（例如：加载中，提交中，按键不可用，字段校验失败，重试等等），这些状态也分为受控状态和非受控表单状态。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;URL State &lt;/strong&gt;- &lt;/span&gt;&lt;span&gt;State managed by the browser (e.g. filter products, saving to query parameters, and refreshing the page to see the same products filtered)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;URL 状态 &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;- 由浏览器管理的链接状态（例如：一个过滤功能，将过滤参数存储在 URL 中，这样刷新页面还是能看到相同的列表结果）[译者：其实就是路由状态管理]&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;State Machine&lt;/strong&gt; -&lt;/span&gt; &lt;span&gt;An explicit model of your state over time (e.g. a stoplight goes from green → yellow → red, but never green → red).&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;状态机&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; - 明确定义状态随时间变化的模型，比如红绿灯的状态机：从绿灯-&amp;gt; 黄灯-&amp;gt; 红灯，但是不能直接从绿灯直接变成红灯。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;前世 past&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;React&#x27;s component model helped create reusable, composable applications. Each component had its own local state. As web apps became more complex, new solutions emerged to more easily share logic between components.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;React的组件模型让我们能够构建出可复用、可组合的应用。每个组件都有自己的独立状态。当 Web 应用变得越来越复杂，一些新的管理方案应运而生，来解决组件之间如何方便共享复用逻辑的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;时间线&lt;/h2&gt;&lt;p&gt;&lt;span&gt;To help you understand how state management has evolved over time, here&#x27;s a rough timeline of popular state management solutions in React. This list is heavily focused on UI State. This list is not comprehensive, but is enough to give context.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了帮大家更好地理解状态管理发展的历史，我梳理了React 中状态管理库的流行趋势。这些列表主要是 UI 的状态管理的库，所以不是很全面，但是也足以说明问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2013 状态管理萌芽时期&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2014 Flux时代&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2015 Redux&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2016 MobX&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2018 Context&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2019 Hooks引入（同时诞生了 React Query 和 SWR）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2019 Zustand&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2019 基于状态机的 xState &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020 Jotai, Recoil, Valtio&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2021 useSelectedContext&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Just because an item is listed on this timeline does not mean you need to learn it. More on this later. Let&#x27;s dive into the history of state management in React.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只是按照时间顺序罗列了这些状态管理库，并不表示你需要掌握每一个。接下来我一起来深入了解下 React 中的状态管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;Redux&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Redux was originally created as an implementation of the &quot;Flux Architecture&quot;, which was a pattern first suggested by Facebook in 2014. Redux came out in 2015 and quickly became the most popular of many Flux-inspired libraries. It&#x27;s ecosystem of tools and libraries encapsulated both UI state and server caching state. Redux is still extremely popular and widely used.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2014年 Facebook 提出了Flux 单向数据流架构，Redux 就是它的一种具体实现。Redux 于2015年面市，随即成为 Flux 架构下最流行的状态管理库。基于 Redux 已经形成了 UI 状态和服务数据缓存管理库的生态。目前 Redux 仍然非常的流行并且广泛使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.586&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs4k0ZrsZSfza971H2TaDicz2xsjUU4FVpIJcLsvEscBZJgTQ35FKrX0HNBD3dgBJQmYaQzczmROr5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;h3&gt;远程缓存状态管理（原文Server Caching State）&lt;/h3&gt;&lt;p&gt;&lt;span&gt;In the early days of React, lots of state management boiled down to fetching data from APIs and caching it for use across the application. The community leaned heavily on libraries like Redux because there wasn&#x27;t an easy, widely used way to manage just the server cache state.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 React 的早期，大部分的状态管理做的事情就是从服务器取数据，然后缓存在本地，供前端应用使用。社区大量地使用类似 Redux 这样的状态管理，但没有出现一个被大众喜爱好用的缓存服务器状态的工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;With the release of React Hooks, encapsulating logic into shared hooks became much easier and accessible. Libraries like SWR and React Query emerged to solve this problem specifically.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着 React 推出了 Hooks，可以通过把通用逻辑封装在 hooks 中方便复用。于是类似 SWR 和 React Query 出现，专门用来解决远程状态管理的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;You might think, &quot;Why have a separate library just for server caching state?&quot;. Well, caching is hard. Server caching state solves different problems than UI state. Here&#x27;s a shortlist of some of the things these libraries handle for you:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可能会想“为什么需要有一个专门用来做服务器数据缓存状态管理的工具库呢？”。因为：Caching is hard （缓存很难）。远程状态管理相较于 UI 状态管理要解决的是完全不同的问题，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定时轮询数据 Polling on interval&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;选中时重新验证数据 Revalidation on focus&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网络恢复后重新验证数据 Revalidation on network recovery&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本地数据操作（用于实现乐观 UI） Local mutation (Optimistic UI)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;错误的智能重试 Smart error retrying&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分页和无限加载模式中的滚动定位 Pagination and scroll position recovery&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Do you want to implement those yourself? Probably not.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你肯定不会想自己实现上面所有这些功能？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;React Context&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;With v16.3, React Context gave us a first-party solution to share logic between components. This also prevented passing values down as props through multiple levels of nested components (i.e. &quot;prop-drilling&quot;).&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着 16.3 版本的发布， React Context 直接提供组件之间共享逻辑的方案。这样我们就不用通过组件属性一层一层的传递到多层嵌套的组件（也称为：属性钻透 prop-drilling，参考 https://kentcdodds.com/blog/prop-drilling ）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;React Context itself is not state management. It can, however, be paired with hooks like useReducer to become a state management solution. This combination solved UI state for many common use cases.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Context 本身并不是一种状态管理工具，但是通过和 useReducer 这个 hooks 组合就可以成为一种状态管理方案。这种组合的方案解决了很多 UI 状态管理的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.572&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs4k0ZrsZSfza971H2TaDicz2MubaIMYGhEHf3sX75xgVwVib4kzp7FW5ojicyf7nQtTuTMbFxWAQ5Z0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;今生 present&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;In 2021, there are various ways to handle state management in React. As the community has grown to understand the different types of state, more granular libraries have been created solving very specific use cases.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 2021 年涌现了大量的 React 状态管理库。随着社区对状态管理的理解越来越深入，许多不同颗粒度的库被创造出来解决特定的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;状态机&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Let&#x27;s consider a switch statement. If the value of state matches any case, the corresponding code runs. There&#x27;s a finite set of cases. This is the most simple state machine – an explicit model of your state.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设我们有一段 switch 代码，匹配到对应的值就执行对应的代码。这就是一个简单对状态准确定义的状态机。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre data-language=&quot;plain&quot;&gt;// 伪代码&lt;br/&gt;switch (state) { &lt;br/&gt;&lt;br/&gt;Case state === &#x27;loading&#x27;: &lt;br/&gt;// show loading spinner break; &lt;br/&gt;&lt;br/&gt;Case state === &#x27;success&#x27;: &lt;br/&gt;// show success message break; &lt;br/&gt;&lt;br/&gt;Default: &lt;br/&gt;// show error message &lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Finite State Machines and Statecharts are fundamental Computer Science concepts, so this isn&#x27;t anything React specific. You can turn useReducer into a state machine without any third-party libraries.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有限状态机和状态图是计算机领域中两个基础概念，并不是React中特有的东西。你在不引入任何第三方库的情况下，可把&lt;/span&gt;&lt;code&gt;&lt;span&gt;useRecuder&lt;/span&gt;&lt;/code&gt;&lt;span&gt;转换成等价的状态机实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;State Machines are well-adopted everywhere, including databases, electronics, cars, and more. As state management evolved in the React ecosystem, we realized these old ideas could solve modern state management issues. State Machines are most prevalent for solving form state.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;状态机已经在各个领域广泛地使用，数据库、电子产品，汽车等等。随着状态机在 React 生态中的发展，我们发现这个老工具也能解决状态管理这个新问题。状态机特别适合解决表单状态管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;With a Finite State Machine, you have a finite number of states your application or component could be in. In practice, State Machines help you uncover bugs as you&#x27;re required to think through and define edge cases. For much more information on this, I&#x27;d recommend checking out the xState docs or watching this course. You can also visualize entire state machines online.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在一个有限状态机的模型里面，你的系统或者组件会归属到不同的状态。在实践中，状态机需要你思考和定义好边界情况，这样非常有助于你提前发现 bug。如果你想更多地了解状态机的话，我建议你看看 xState的文档(https://xstate.js.org/docs/)和 egghead 的这个教程(https://egghead.io/courses/introduction-to-state-machines-using-xstate)，基于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;xstate&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 定义的状态机还能被可视化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/dlEwIVcKGs4k0ZrsZSfza971H2TaDicz2BBG9lmnnibowQVnmAumOjiab6B6du1BUXCicDtuaia5T36vHTkk4swHQ7A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;h2&gt;Zustand, Recoil, Jotai, Valtio，学不动了！&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Why do so many different libraries for React state management even exist?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么现在会有如此之多的状态管理库呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Let&#x27;s consider Figma (or any other design tool). You have a toolbar of controls that affect other elements outside of its &quot;local&quot; state, or where the component is rendered.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设我们在实现一个类似 Figma 的设计工具。你有一个工具栏，会影响应用中的其他状态，或者应用中组件是如何渲染。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.663&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs4k0ZrsZSfza971H2TaDicz2COqiajdIIOV29m55HsVFDMKxRnVll1QKcdmH4dw0pMaNFkV7ZicHMZdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;As you can imagine, an application of this scale would require a complex state management solution. Performance and frame rate are critical for a good user experience here, so you want control over when &amp;amp; how to re-render. Unique use cases like this have led to lots of exploration in the state management space.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以想象这样大规模地应用肯定需要一个复杂状态管理的解决方案。性能和应用的帧率对用户体验非常的重要，所以你会想控制在UI在何时用各种方式渲染。每种特殊的使用场景都会促进去发明一种新的状态管理的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;To summarize the differences between these libraries, let&#x27;s hear from Daishi Kato:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;用&lt;span&gt;Daishi Kato的话来总结这些不同库的特点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Valtio uses proxies to provide a mutation-style API&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Valtio：使用 Proxy 提供一个可变数据风格 API 的状态管理工具。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Jotai is optimized for &quot;computed values&quot; and async actions&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Jotai：为优化异步更新和“计算值”而生的状态管理&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zustand is a very thin library specifically focused on module state&lt;br/&gt;Zustand：一个专注于状态模块化管理的轻量库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Recoil is an experimental library using a data-flow graph&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Recoil：基于数据流图的实验性质的状态管理库。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Having complex state doesn&#x27;t necessarily mean you have to pull for a third-party library. You can start with React and JavaScript and see how far it takes you. If optimizing requires a state management library, you can track that metric (e.g. frame rate), measure it, and verify it solves a real problem.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有复杂的状态需要管理并不意味着你需要引入一个第三方的状态管理库。你可以试试裸用 React 看看能做到什么程度。如果遇到性能问题，需要引入一个第三方状态管理库，你在定义优化的数值目标（比如：帧率），然后测试下是不是解决了你的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Don&#x27;t choose one of these libraries unless there&#x27;s an obvious need.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除非你真的需要，尽量不要随便引入状态管理库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;Immutable State&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Another debate is mutable vs. immutable state. There are no right answers, just opinions. If you were doing state management with vanilla JavaScript, you&#x27;ll likely have mutable state. You initialize a variable, and then later set it equal to some new value. There are entire debates on let vs. const.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;状态管理的另外一个争论就是：可变状态和不可变状态。这个争论是没有正确答案的，只是两种不同的观点。如果你是直接用 javascript 来做状态管理的，你肯定会有很多状态：你初始化一个变量，然后再给它赋一个新值。其这种争论的本质就是用 let 还是 const。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Immutable state gained a lot of popularity with React. The immutable crowd argues that allowing your state management solution of choice to mutate state directly results in more bugs. The mutable crowd argues it&#x27;s not worth the complex trade-off. Direct manipulation will always be less safe than indirect manipulation. It&#x27;s a tradeoff between convenience and risk, which is up to you and your team.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不可变状态在 React 生态里面很流行。不可变状态的拥护者认为直接修改状态的数据非常容易引入 bug。可变状态的拥护者则认为，不可变带来的复杂度太高了。直接修改状态数据肯定是没有间接的方式安全。但是风险和便利之间应该如何平衡完全由你和你的团队自己决定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Solutions like Immer allow you to write mutable code but execute it immutably. Fancy. The basic idea is you apply your changes to a draft state, which is a proxy of the current state. Once the mutations have completed Immer will produce the next state based on the changes to the draft state.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类似 Immer 让你通过写可变状态的方式实现不可变数据的状态管理。很炫酷。背后的思想就是通过对“草稿”状态直接赋值，“草稿”将这些操作再应用到当前的状态上去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.389&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs4k0ZrsZSfza971H2TaDicz2iazqsSe7g7FCVzPqyqF3xoOP2zGUX8wBiaRjSGicASJoqdXU0bibhw6R9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;h2&gt;URL State&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Let&#x27;s say you&#x27;re building an e-commerce website like Amazon. You search for React books and filter by 4+ stars. This state is persisted as query parameters and managed by the browser. When you refresh the page, you see the same list of products. You can share this URL with others and they also see the same results.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设我们正在开发一个类似亚马逊的电子商务网站。你搜索了 4 星评价以上关于 React 的书，这搜索状态被持久化到URL地址中并被浏览器管理。当你重新刷新浏览器或者把地址分享给其他人，都能看到你的搜索结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.732&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs4k0ZrsZSfza971H2TaDicz2xa3bNiaYQGib1jUeQuXyA0rHDWGGFnPBQ1XibggpNsEEUh0jOnCIe57gA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Another interesting example of this is Nomad List. We can transform the browser URL state into a function of our data. Plus, we can make human-readable URLs (which Google prefers).&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个有趣的例子就是 Nomad list。我们通过一个函数根据页面数据生成一个URL地址 。这样就可以生成一个对人友好可读（对搜索引擎也友好）的 URL 地址。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.676&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dlEwIVcKGs4k0ZrsZSfza971H2TaDicz2sLIBJmjyClPYLMln4C9XRGK8iaKicB64x3WBJI5AK4qL4DmXysXNxb8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;未来 future&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;For large applications, it&#x27;s possible a naive Context-based state management solutions (e.g. with useReducer) could have issues with excessive re-rendering.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在开发大型应用的时候，如果只用朴素的Reat Context 的方式（搭配 &lt;/span&gt;&lt;code&gt;&lt;span&gt;useReducer&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）来状态管理的话，很容易出现大量的多余的重新渲染。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;When a context value changes, all components that useContext will re-render. This makes UI interactions feel slow and janky. If you can&#x27;t visually notice it, you can use React Dev Tools to investigate re-rendering.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为当一个 context 的值发生了改变，那么所有通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;useContext&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 使用这个 context 的组件都会重新渲染。这样会让我们的 UI 变慢变卡。如果察觉不到这个变化的话，可以试试用 React 的开发者工具更加细腻的观察组件的重渲染。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;The React team has proposed a useSelectedContext hook to prevent performance issues with Context at scale. This RFC was introduced in July 2019 and progress has started as of January 2021 behind a feature flag. This hook allows you to select a &quot;slice&quot; of context and only re-render when that piece changes.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;React团队已经在提议了一个新的 hook ，&lt;/span&gt;&lt;code&gt;&lt;span&gt;useSelectedContext&lt;/span&gt;&lt;/code&gt;&lt;span&gt;用来解决 Context 使用过程中的问题。RFC 在 2019 年7 月提出，2021 年 1月就可以通过特性开关来试用。这个 hook 可以让你选择context 中的值部分改变，从而尽量减少不相关的组件的重渲染（译者注：类似 redux 里面的 map 函数）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;There are ways to work around re-rendering performance already (e.g. useMemo) but a first-party solution for Context is preferred.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然有很多方法能解决重渲染的性能问题（比如 useMemo），但是我们还是倾向使用 React 中原生的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;There&#x27;s also a community library use ContextSelector, which takes a similar approach (demo). Jotai and Formik 3 use this under the hood. Having used SelectedContext as part of the React standard library will eliminate complexity and code size in external libraries, as well as provide more performant options by default.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多社区的状态管理工具也是基于 ContextSelector （比如：这个例子）像Jotai 和 formik3 底层就是用的这个。如果使用 React 自带的&lt;/span&gt;&lt;code&gt;&lt;span&gt;selectedContext&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 不仅仅可降低代码量和复杂度，同时能带来性能提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;In the longer-term future, React will automatically figure out which components to re-render (&quot;auto-memoization&quot;).&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在更遥远的未来， React 会自动分析是需要哪些组件需要重渲染（自动useMemo）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;状态管理如何选择&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;This is not a comprehensive list. It&#x27;s also open-source, so please open a PR if you disagree or if something is wrong. In general, lean on whatever empowers your developers and team. Happy with Redux? Stay there!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个列表并不全面，但是随时接受大家提 PR 来更改和添加新的列表内容。总之一个原则就是，使用那些可以提高你团队效率的工具。如果喜欢用 redux，那就用 redux。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;表单状态&lt;/h3&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;开发者经验&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;学习热情&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;团队/项目规模&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;初学者&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;低&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;小&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;useState&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;初学者&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中小&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;专门的表单状态管理库 (Formik, Final Form)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;初学者&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;大&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;和你的 TL 讨论&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中级&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;低&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中小&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;专门的表单状态管理库 (Formik, Final Form)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高级工程师&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;状态机 例如 xState&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高级工程师&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;状态机 例如 xState&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高级工程师&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;大&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;状态机 例如 xState&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;UI 状态管理&lt;/h3&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;开发者经验&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;学习热情&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;团队/项目规模&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;初学者&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;低&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;小&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;useState&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;初学者&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中小&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;useContext + useReducer&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;初学者&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;大&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;和你的 TL 讨论&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中级&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;低&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中小&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;Redux Toolkit&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高级工程师&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;useContext + useReducer&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高级工程师&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;中&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;Jotai, Valtio&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高级工程师&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;高&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;大&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;Recoil (如果在用GraphQL的话试试 Relay)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;远程缓存状态&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Regardless of experience or team size, both SWR and React Query are excellent solutions. You&#x27;ll be happy with either. If you&#x27;re using GraphQL, you probably already know about Apollo.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不用管你的团队规模和经验， SWR 和 React Query 都是很好的选择。你肯定会满意这两个库的；如果你用 Graphql 的话，那你肯定早就知道 Apollo 了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;完&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;State management in React has evolved massively over the past eight years. It&#x27;s one of the most difficult, nuanced parts of building large web applications. Understanding the different types of state and their tradeoffs is crucial for making an informed decision. I hope this post has helped – thanks for reading.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;React 的状态管理在最近的8年时间飞速发展。在构建 web 应用的时候如何选择一个状态管理工具是最头痛的问题。先了解各个类型状态管理工具的优缺点和要解决的问题，是正确选择他们的第一步。希望这篇文章能够帮助到你，谢谢阅读。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f800e6462f0e9dbc9c01ed8df8b6acca</guid>
<title>Android 的消息机制 ThreadLocal 工作原理全面掌握，够深入</title>
<link>https://toutiao.io/k/jk7v7v6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;strong&gt;一、Handler消息机制了解和复习&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Android的消息机制主要是指Handler的运行机制，Handler的运行需要底层的MessageQueue和Looper的支撑&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;MessageQueue&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的中文翻译是消息队列，顾名思义它的内部存储了一组消息，其以队列的形式对外提供插入和删除的工作，虽然叫做消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Looper&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的中文翻译为循环，在这里可以理解为消息循环，由于&lt;strong&gt;MessageQueue&lt;/strong&gt;只是一个消息的存储单元，它不能去处理消息，而&lt;strong&gt;Looper&lt;/strong&gt;就填补了这个功能，Looper会以无限循环的形式去查找是否有新消息，如果有的话就处理消息，否则就一直等待着。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Looper&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;中还有一个特殊的概念，那就是&lt;strong&gt;ThreadLocal&lt;/strong&gt;，&lt;strong&gt;ThreadLocal&lt;/strong&gt;并不是线程，它的作用是可以在每个线程中存储数据。大家知道，&lt;strong&gt;Handler&lt;/strong&gt;创建的时候会采用当前线程的&lt;strong&gt;Looper&lt;/strong&gt;来构造消息循环系统，那么Handler内部如何获取到当前线程的&lt;strong&gt;Looper&lt;/strong&gt;呢？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这就要使用&lt;strong&gt;ThreadLocal&lt;/strong&gt;了，ThreadLocal可以在不同的线程之中互不干扰地存储并提供数据，通过ThreadLocal可以轻松获取每个线程的Looper。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当然需要注意的是，线程是默认没有Looper的，如果需要使用Handler就必须为线程创建Looper。大家经常提到的主线程，也叫UI线程，它就是ActivityThread，ActivityThread被创建时就会初始化Looper，这也是在主线程中默认可以使用Handler的原因。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二、ThreadLocal介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4747826086956522&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kyDL16ViavhFxWxoa9Sy46EHnlfTO9RBR75oibFcm9r79nwpicHLBEdwO6uoMuNQpXgk8X93uXgXWFNh20EYdibnXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;575&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、ThreadLocal是什么？在消息机制应用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;ThreadLocal&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其它线程来说无法获取到数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在日常开发中用到&lt;strong&gt;ThreadLocal&lt;/strong&gt;的地方较少，但是在某些特殊的场景下，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过&lt;strong&gt;ThreadLocal&lt;/strong&gt;可以轻松地实现一些看起来很复杂的功能，这一点在Android的源码中也有所体现，比如Looper、ActivityThread以及AMS中都用到了ThreadLocal。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;具体到&lt;strong&gt;ThreadLocal&lt;/strong&gt;的使用场景，这个不好统一地来描述，一般来说，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;就可以考虑采用&lt;strong&gt;ThreadLocal&lt;/strong&gt;。对于&lt;strong&gt;Handler&lt;/strong&gt;来说，它需要获取当前线程的&lt;strong&gt;Looper&lt;/strong&gt;，很显然&lt;strong&gt;Looper&lt;/strong&gt;的作用域就是线程并且不同线程具有不同的&lt;strong&gt;Looper&lt;/strong&gt;，这个时候通过ThreadLocal就可以轻松实现Looper在线程中的存取，如果不采用ThreadLocal，那么系统就必须提供一个全局的哈希表供Handler查找指定线程的Looper，这样一来就必须提供一个类似于LooperManager的类了，但是系统并没有这么做而是选择了ThreadLocal，这就是ThreadLocal的好处。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;94&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;ThreadLocal的类定义使用了泛型ThreadLocal&amp;lt;T&amp;gt;，其中T指代的是在线程中存取值的类型。（对应Android中使用的ThreadLocal, T则存放的类型为Looper）&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;①set方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public void set(T value) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Thread currentThread = Thread.currentThread();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Values values = values(currentThread);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (values == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        values = initializeValues(currentThread);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    values.put(this, value);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Values values(Thread current) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  return current.localValues;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法中，先通过Thread.currentThread来拿到当前线程，再拿到线程的values属性，并对此values属性进行赋值，其中key为当前的ThreadLocal对象，value则是当前要存放的值。而这个values对象，其中维持了一个一维的object数组，采用偶数为key, （索引为index）奇数为value(索引为index + 1)的数据结构。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;②get方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public T get() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // Optimized for the fast path.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Thread currentThread = Thread.currentThread();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Values values = values(currentThread);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (values != null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Object[] table = values.table;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        int index = hash &amp;amp; values.mask;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (this.reference == table[index]) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return (T) table[index + 1];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        values = initializeValues(currentThread);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return (T) values.getAfterMiss(this);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在进行取值的时候，也是现获取当前线程，然后根据当前ThreadLocal的hash值与values的mask标志位进行与操作，来获取到当前ThreadLocal在这个线程的values中的位置，并通过判断其存放的key是不是当前ThreadLocal，若是的话，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;则返回index+1对应的值，即是我们所存放的值；若不是的话，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;则需要通过values的getAfterMiss方法来进行更进一步详细的搜索。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、Android Handler消息机制中的ThreadLocal&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.606318347509113&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kyDL16ViavhFxWxoa9Sy46EHnlfTO9RBRzEssRXsCZt4Sw53WeK2gHicSKBfph20ic4x1avuJEL9gIsia5PKhDCFfQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;823&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ThreadLocal通过获取当前线程中的values属性，从而实现了每个单独线程的信息绑定。&lt;/span&gt;&lt;span&gt;这样的话，Android的消息机制中，Looper便是采用ThreadLocal作为存储结构，所以looper对象的存储只会在当前线程中，子线程若是使用消息机制的话，必须调用Looper.prepare方法来在线程中新建一个Looper的对象。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们在一个线程中使用Looper的时候，需要调用Looper的prepare方法和loop方法，&lt;/span&gt;&lt;span&gt;不然就会出现异常。&lt;/span&gt;&lt;span&gt;那么，我们就看看这两个方法的源码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public static void prepare() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    prepare(true);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private static void prepare(boolean quitAllowed) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (sThreadLocal.get() != null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    sThreadLocal.set(new Looper(quitAllowed));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;loop方法内部先调用了myLooper方法：&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public static @Nullable Looper myLooper() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return sThreadLocal.get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;很明显，Looper 的prepare方法先创建Looper，并使用ThreadLocal存储即与当前的线程进行关联，然后loop方法开启消息机制的时候，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用ThreadLocal方法获取到&lt;/span&gt;&lt;span&gt;当前线程的Looper。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;日常总结：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;ThreadLocal是一种针对线程间数据副本不同的巧妙设计，开发者无需理会内部的复杂实现，只需在调用的时候使用get和set方法即可！对外屏蔽了细节，是一种设计思想的体现，其内在table数组内存的利用和空间的扩展也值得我们学习。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzk0NDE3MjM1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhFRZkgpibUGGz2NIiaBUpj7NeBSJASje1M1ZhVvpDIGibicMUeCiad3ptsJLaLUjhrVYs5bGZWuenY6UaQ/0?wx_fmt=png&quot; data-nickname=&quot;Android开发编程&quot; data-alias=&quot;&quot; data-signature=&quot;一个有10多年经验开发的android、java、前端等语言的老程序员，在这里一起聊聊技术，一起聊聊生活、一起聊聊中年危机的生存之道，一起进步一起加油，感兴趣的欢迎订阅；不定时的更新。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;想了解更多知识点，请关注谢谢&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;img data-ratio=&quot;0.646875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kyDL16ViavhFxWxoa9Sy46EHnlfTO9RBRfWuew4AMUbGlDaDdKXWZlKibmicGCibF1lY8y22pTNLRfPwJtoVOCGa7g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c9bf77da4f9504e5b2aad96b7a6ba6f5</guid>
<title>JSBridge 原理解析：以 WebviewJavascriptBridge 实现方式为例</title>
<link>https://toutiao.io/k/pz12wl0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、什么是 JSBridge？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JSBridge 是一种 webview 侧和 native 侧进行通信的手段，webview 可以通过 jsb 调用 native 的能力，native 也可以通过 jsb 在 webview 上执行一些逻辑。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、JSB 的实现方式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在比较流行的 JSBridge 中，主要是通过拦截 URL 请求来达到 native 端和 webview 端相互通信的效果的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们以比较火的 WebviewJavascriptBridge 为例，来解析一下它的实现方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码地址：https://github.com/marcuswestin/WebViewJavascriptBridge&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2-1、在 native 端和 webview 端注册 Bridge&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注册的时候，需要在 webview 侧和 native 侧分别注册 bridge，其实就是用一个对象把所有函数储存起来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;registerHandler&lt;/span&gt;(&lt;span&gt;handlerName, handler&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    messageHandlers[handlerName] = handler;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;- (&lt;span&gt;void&lt;/span&gt;)registerHandler:(&lt;span&gt;NSString&lt;/span&gt; *)handlerName handler:(WVJBHandler)handler {&lt;br/&gt;    _base.messageHandlers[handlerName] = [handler &lt;span&gt;copy&lt;/span&gt;];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2-2、在 webview 里面注入初始化代码&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;setupWebViewJavascriptBridge&lt;/span&gt;(&lt;span&gt;callback&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;window&lt;/span&gt;.WebViewJavascriptBridge) { &lt;span&gt;return&lt;/span&gt; callback(WebViewJavascriptBridge); }&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;window&lt;/span&gt;.WVJBCallbacks) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;window&lt;/span&gt;.WVJBCallbacks.push(callback); }&lt;br/&gt;       &lt;span&gt;window&lt;/span&gt;.WVJBCallbacks = [callback];&lt;br/&gt;       &lt;span&gt;var&lt;/span&gt; WVJBIframe = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;iframe&#x27;&lt;/span&gt;);&lt;br/&gt;       WVJBIframe.style.display = &lt;span&gt;&#x27;none&#x27;&lt;/span&gt;;&lt;br/&gt;       WVJBIframe.src = &lt;span&gt;&#x27;https://__bridge_loaded__&#x27;&lt;/span&gt;;&lt;br/&gt;       &lt;span&gt;document&lt;/span&gt;.documentElement.appendChild(WVJBIframe);&lt;br/&gt;       setTimeout(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{ &lt;span&gt;document&lt;/span&gt;.documentElement.removeChild(WVJBIframe) }, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码主要做了以下几件事：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）创建一个名为 WVJBCallbacks 的数组，将传入的 callback 参数放到数组内&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）创建一个 iframe，设置不可见，设置 src 为&lt;code&gt;https://__bridge_loaded__&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）设置定时器移除这个 iframe&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2-3、在 native 端监听 URL 请求&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;iOS 中有两种 webview，一种是 UIWebview，另一种是 WKWebview，这里以 WKWebview 为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;- (&lt;span&gt;void&lt;/span&gt;)webView:(&lt;span&gt;WKWebView&lt;/span&gt; *)webView decidePolicyForNavigationResponse:(&lt;span&gt;WKNavigationResponse&lt;/span&gt; *)navigationResponse decisionHandler:(&lt;span&gt;void&lt;/span&gt; (^)(&lt;span&gt;WKNavigationResponsePolicy&lt;/span&gt;))decisionHandler {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (webView != _webView) { &lt;span&gt;return&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    __&lt;span&gt;strong&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt;(_webViewDelegate) strongDelegate = _webViewDelegate;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (strongDelegate &amp;amp;&amp;amp; [strongDelegate respondsToSelector:&lt;span&gt;@selector&lt;/span&gt;(webView:decidePolicyForNavigationResponse:decisionHandler:)]) {&lt;br/&gt;        [strongDelegate webView:webView decidePolicyForNavigationResponse:navigationResponse decisionHandler:decisionHandler];&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        decisionHandler(&lt;span&gt;WKNavigationResponsePolicyAllow&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码主要做了以下几件事：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）拦截了所有的 URL 请求并拿到 url&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）首先判断&lt;code&gt;isWebViewJavascriptBridgeURL&lt;/code&gt;，判断这个 url 是不是 webview 的 iframe 触发的，具体可以通过 host 去判断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）继续判断，如果是&lt;code&gt;isBridgeLoadedURL&lt;/code&gt;，那么会执行&lt;code&gt;injectJavascriptFile&lt;/code&gt;方法，会向 webview 中再次注入一些逻辑，其中最重要的逻辑就是，在 window 对象上挂载一些全局变量和&lt;code&gt;WebViewJavascriptBridge&lt;/code&gt;属性，具体值如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;window&lt;/span&gt;.WebViewJavascriptBridge = {&lt;br/&gt;        &lt;span&gt;registerHandler&lt;/span&gt;: registerHandler,&lt;br/&gt;        &lt;span&gt;callHandler&lt;/span&gt;: callHandler,&lt;br/&gt;        &lt;span&gt;disableJavscriptAlertBoxSafetyTimeout&lt;/span&gt;: disableJavscriptAlertBoxSafetyTimeout,&lt;br/&gt;        &lt;span&gt;_fetchQueue&lt;/span&gt;: _fetchQueue,&lt;br/&gt;        &lt;span&gt;_handleMessageFromObjC&lt;/span&gt;: _handleMessageFromObjC&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; sendMessageQueue = [];&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; messageHandlers = {};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; responseCallbacks = {};&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; uniqueId = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）继续判断，如果是 isQueueMessageURL，那么这就是个处理消息的回调，需要执行一些消息处理的方法（第四步会详细讲）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2-4、webview 调用 native 能力&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 native 和 webview 都注册好了 Bridge 之后，双方就可以互相调用了，这里先介绍 webview 调用 native 能力的过程。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2-4-1、webview 侧 callHandler&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 webview 调用 native 时，会调用 callHandler 方法，这个方法具体逻辑如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;bridge.callHandler(&lt;span&gt;&#x27;ObjC Echo&#x27;&lt;/span&gt;, {&lt;span&gt;&#x27;key&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;value&#x27;&lt;/span&gt;}, &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;responseCallback&lt;/span&gt;(&lt;span&gt;responseData&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;       &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;JS received response:&quot;&lt;/span&gt;, responseData)&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;callHandler&lt;/span&gt;(&lt;span&gt;handlerName, data, responseCallback&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;arguments&lt;/span&gt;.length == &lt;span&gt;2&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; data == &lt;span&gt;&#x27;function&#x27;&lt;/span&gt;) {&lt;br/&gt;                responseCallback = data;&lt;br/&gt;                data = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;         }&lt;br/&gt;        _doSend({ &lt;span&gt;handlerName&lt;/span&gt;:handlerName, &lt;span&gt;data&lt;/span&gt;:data }, responseCallback);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;_doSend&lt;/span&gt;(&lt;span&gt;message, responseCallback&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (responseCallback) {&lt;br/&gt;               &lt;span&gt;var&lt;/span&gt; callbackId = &lt;span&gt;&#x27;cb_&#x27;&lt;/span&gt;+(uniqueId++)+&lt;span&gt;&#x27;_&#x27;&lt;/span&gt;+&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;().getTime();&lt;br/&gt;               responseCallbacks[callbackId] = responseCallback;&lt;br/&gt;               message[&lt;span&gt;&#x27;callbackId&#x27;&lt;/span&gt;] = callbackId;&lt;br/&gt;         }&lt;br/&gt;         sendMessageQueue.push(message);&lt;br/&gt;         messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + &lt;span&gt;&#x27;://&#x27;&lt;/span&gt; + QUEUE_HAS_MESSAGE;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上就是先生成一个 message，然后 push 到 sendMessageQueue 里，然后更改 iframe 的 src。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2-4-2、native 侧 flushMessageQueue&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，当 native 端检测到 iframe src 的变化时，会走到 isQueueMessageURL 的判断逻辑，然后执行 WKFlushMessageQueue 函数，获取到 JS 侧的 sendMessageQueue 中的所有 message。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;- (&lt;span&gt;void&lt;/span&gt;)&lt;span&gt;WKFlushMessageQueue&lt;/span&gt; {&lt;br/&gt;    [_webView evaluateJavaScript:[_base webViewJavascriptFetchQueyCommand] completionHandler:^(&lt;span&gt;NSString&lt;/span&gt;* result, &lt;span&gt;NSError&lt;/span&gt;* error) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (error != &lt;span&gt;nil&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;NSLog&lt;/span&gt;(&lt;span&gt;@&quot;WebViewJavascriptBridge: WARNING: Error when trying to fetch data from WKWebView: %@&quot;&lt;/span&gt;, error);&lt;br/&gt;        }&lt;br/&gt;        [_base flushMessageQueue:result];&lt;br/&gt;    }];&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)flushMessageQueue:(&lt;span&gt;NSString&lt;/span&gt; *)messageQueueString{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (messageQueueString == &lt;span&gt;nil&lt;/span&gt; || messageQueueString.length == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;NSLog&lt;/span&gt;(&lt;span&gt;@&quot;WebViewJavascriptBridge: WARNING: ObjC got nil while fetching the message queue JSON from webview. This can happen if the WebViewJavascriptBridge JS is not currently present in the webview, e.g if the webview just loaded a new page.&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;id&lt;/span&gt; messages = [&lt;span&gt;self&lt;/span&gt; _deserializeMessageJSON:messageQueueString];&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (WVJBMessage* message &lt;span&gt;in&lt;/span&gt; messages) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (![message isKindOfClass:[WVJBMessage &lt;span&gt;class&lt;/span&gt;]]) {&lt;br/&gt;            &lt;span&gt;NSLog&lt;/span&gt;(&lt;span&gt;@&quot;WebViewJavascriptBridge: WARNING: Invalid %@ received: %@&quot;&lt;/span&gt;, [message &lt;span&gt;class&lt;/span&gt;], message);&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        [&lt;span&gt;self&lt;/span&gt; _log:&lt;span&gt;@&quot;RCVD&quot;&lt;/span&gt; json:message];&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;NSString&lt;/span&gt;* responseId = message[&lt;span&gt;@&quot;responseId&quot;&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (responseId) {&lt;br/&gt;            WVJBResponseCallback responseCallback = _responseCallbacks[responseId];&lt;br/&gt;            responseCallback(message[&lt;span&gt;@&quot;responseData&quot;&lt;/span&gt;]);&lt;br/&gt;            [&lt;span&gt;self&lt;/span&gt;.responseCallbacks removeObjectForKey:responseId];&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            WVJBResponseCallback responseCallback = &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;NSString&lt;/span&gt;* callbackId = message[&lt;span&gt;@&quot;callbackId&quot;&lt;/span&gt;];&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (callbackId) {&lt;br/&gt;                responseCallback = ^(&lt;span&gt;id&lt;/span&gt; responseData) {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (responseData == &lt;span&gt;nil&lt;/span&gt;) {&lt;br/&gt;                        responseData = [&lt;span&gt;NSNull&lt;/span&gt; null];&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    WVJBMessage* msg = @{ &lt;span&gt;@&quot;responseId&quot;&lt;/span&gt;:callbackId, &lt;span&gt;@&quot;responseData&quot;&lt;/span&gt;:responseData };&lt;br/&gt;                    [&lt;span&gt;self&lt;/span&gt; _queueMessage:msg];&lt;br/&gt;                };&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                responseCallback = ^(&lt;span&gt;id&lt;/span&gt; ignoreResponseData) {&lt;br/&gt;                    &lt;span&gt;// Do nothing&lt;/span&gt;&lt;br/&gt;                };&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            WVJBHandler handler = &lt;span&gt;self&lt;/span&gt;.messageHandlers[message[&lt;span&gt;@&quot;handlerName&quot;&lt;/span&gt;]];&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!handler) {&lt;br/&gt;                &lt;span&gt;NSLog&lt;/span&gt;(&lt;span&gt;@&quot;WVJBNoHandlerException, No handler for message from JS: %@&quot;&lt;/span&gt;, message);&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            handler(message[&lt;span&gt;@&quot;data&quot;&lt;/span&gt;], responseCallback);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个 message 结构存在 responseId 的时候说明这个 message 是执行 bridge 后传回的。取不到 responseId 说明是第一次调用 bridge 传过来的，这个时候会生成一个返回给调用方的 message，其 reponseId 是传过来的 message 的 callbackId，当 native 执行 responseCallback 时，会触发_dispatchMessage 方法执行 webview 环境的的 js 逻辑，将生成的包含 responseId 的 message 返回给 webview。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2-4-3、webview 侧 handleMessageFromObjC&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;_handleMessageFromObjC&lt;/span&gt;(&lt;span&gt;messageJSON&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    _dispatchMessageFromObjC(messageJSON);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;_dispatchMessageFromObjC&lt;/span&gt;(&lt;span&gt;messageJSON&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (dispatchMessagesWithTimeoutSafety) {&lt;br/&gt;             setTimeout(_doDispatchMessageFromObjC);&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;             _doDispatchMessageFromObjC();&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;_doDispatchMessageFromObjC&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; message = &lt;span&gt;JSON&lt;/span&gt;.parse(messageJSON);&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; messageHandler;&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; responseCallback;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (message.responseId) {&lt;br/&gt;                responseCallback = responseCallbacks[message.responseId];&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!responseCallback) {&lt;br/&gt;                          &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                responseCallback(message.responseData);&lt;br/&gt;                &lt;span&gt;delete&lt;/span&gt; responseCallbacks[message.responseId];&lt;br/&gt;         } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;               &lt;span&gt;if&lt;/span&gt; (message.callbackId) {&lt;br/&gt;                       &lt;span&gt;var&lt;/span&gt; callbackResponseId = message.callbackId;&lt;br/&gt;                       responseCallback = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;responseData&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                             _doSend({ &lt;span&gt;handlerName&lt;/span&gt;:message.handlerName, &lt;span&gt;responseId&lt;/span&gt;:callbackResponseId, &lt;span&gt;responseData&lt;/span&gt;:responseData });&lt;br/&gt;                        };&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;var&lt;/span&gt; handler = messageHandlers[message.handlerName];&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!handler) {&lt;br/&gt;                        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;WebViewJavascriptBridge: WARNING: no handler for message from ObjC:&quot;&lt;/span&gt;, message);&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                        handler(message.data, responseCallback);&lt;br/&gt;                }&lt;br/&gt;          }&lt;br/&gt;     }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果从 native 获取到的 message 中有 responseId，说明这个 message 是 JS 调 Native 之后回调接收的 message，所以从一开始 sendData 中添加的 responseCallbacks 中根据 responseId（一开始存的时候是用的 callbackId，两个值是相同的）取出这个回调函数并执行，这样就完成了一次 JS 调用 Native 的流程。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2-4-4、过程总结&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过程如下图&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9472817133443163&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibf6ZQ5h2gcznK7gicdLwtKNSes8WInu5fIJHCtL7WXXngicPjsribQXrlSAXhdzSPT9oGMibLwz7fmTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1214&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、native 端注册 jsb&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、webview 侧创建 iframe，设置 src 为&lt;code&gt;__bridge_load__&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、native 端捕获请求，注入 jsb 初始化代码，在 window 上挂载相关对象和方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、webview 侧调用&lt;code&gt;callHandler&lt;/code&gt;方法，并在&lt;code&gt;responseCallback&lt;/code&gt;上添加&lt;code&gt;callbackId: responseCallback&lt;/code&gt;，并修改 iframe 的 src，触发捕获&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、native 收到 message，生成一个&lt;code&gt;responseCallback&lt;/code&gt;，并执行 native 侧注册好的方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、native 执行完毕后，通过 webview 执行&lt;code&gt;_handleMessageFromObjC&lt;/code&gt;方法，取出 callback 函数，并执行&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2-5、native 调用 webview 能力&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;native 调用 webview 注册的 jsb 的逻辑是相似的，不过就不是通过触发 iframe 的 src 触发执行的了，因为 Native 可以自己主动调用 JS 侧的方法。其具体过程如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibf6ZQ5h2gcznK7gicdLwtKNguF55p8FrriajcBjVU4o2jJRUXmmD5BxFLXsXf3UIzibiafReBRrZBOVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、native 侧调用&lt;code&gt;callHandler&lt;/code&gt;方法，并在&lt;code&gt;responseCallback&lt;/code&gt;上添加&lt;code&gt;callbackId: responseCallback&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、native 侧主动调用&lt;code&gt;_handleMessageFromObjC&lt;/code&gt;方法，在 webview 中执行对应的逻辑&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、webview 侧执行结束后，生成带有&lt;code&gt;responseId&lt;/code&gt;的 message，添加到&lt;code&gt;sendMessageQueue&lt;/code&gt;中，并修改 iframe 的 src 为&lt;code&gt;__wvjb_queue_message__&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、native 端拦截到 url 变化，调用 webview 的逻辑获取到 message，拿到&lt;code&gt;responseId&lt;/code&gt;，并执行对应的 callback 函数&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4NTU1OTMwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/wokNJRf0ytp9eiaO3zQL2A6S35JlOVfxuVHias08HZc7ciaCgxP08J8sk5LbUZuHOVRHTCz0mXI6mX5nicc9bJVa2w/0?wx_fmt=png&quot; data-nickname=&quot;太空编程&quot; data-alias=&quot;spacexcode&quot; data-signature=&quot;分享精彩，码上快乐，JavaScript已然上天，有朝一日实现太空编程！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1697eca4b12b4046aab65464c7b4859c</guid>
<title>彻底搞懂事件驱动模型：Reactor</title>
<link>https://toutiao.io/k/flosayk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;p&gt;&lt;span&gt;在高性能网络技术中，大家应该经常会看到Reactor模型。并且很多开源软件中都使用了这个模型，如：Redis、Nginx、Memcache、Netty等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刚开始接触时可能一头雾水，这到底是个什么东东？一查英文解释：“反应堆”，感觉更加唬人了。那么，今天我们来一起看看这个Reactor到底是个啥。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实通俗点讲，Reacotr = IO多路复用 + 池化技术。是“大神”们将IO多路复用技术结合池化技术（线程池进程池）结合的一种模式。IO多路复用负责统一监听事件，收到事件后派发给资源池中的某个线程或进程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中根据Reacotr的数量和资源池中资源的数量和类型，Reactor有以下3种典型实现方案。其中“多Reactor单进程/线程”实现方案相比“单 Reactor 单进程”方案，既复杂又没有性能优势，因此实际没有应用。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单Reactor + 单进程/单线程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单Reactor + 多线程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;多Reactor + 多进程/多线程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;下面我们逐一介绍一下这3个方案，及他们适用的场景。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;单Reactor + 单进程/单线程&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;该方案示意图如下（以进程举例）：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5407166123778502&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/bymGBmLC3zFlWqbJt1oq5LQ8ee7Gy5GRBfuTc2NogMiaJN5yXlHmPDXgZ7kGD06ZMKOGrcQnVPBSEMOiaB1GhebQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1228&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;Reactor 对象通过 select 监控连接事件，收到事件后通过 dispatch 进行分发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果是连接建立的事件，则由 Acceptor 处理，Acceptor 通过 accept 接受连接，并创建一个 Handler 来处理连接后续的各种事件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果不是连接建立事件，则 Reactor 会调用连接对应的 Handler（第 2 步中创建的Handler）来进行响应。Handler 会完成 read-&amp;gt; 处理 -&amp;gt;send 的完整业务流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种优点很明显，就是简单，不用考虑进程间通信、线程安全、资源竞争等问题。但是也有自身的局限性，就是无法利用多核资源，&lt;strong&gt;只适用于业务处理非常快速的场景&lt;/strong&gt;，Redis就是采用的这种方案。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;单Reactor + 多线程&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;该方案示意图如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8690851735015773&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/bymGBmLC3zFlWqbJt1oq5LQ8ee7Gy5GRroibZO0oibX6BXobO8icQhHFyxm9Icd50fiaflMtYUjwI5Ap7vDic4TbS5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;与第一种方案相比，不同的是：Handler只负责响应事件，并不负责处理事件，Handler读取数据后会发送给Processor进行处理。Processor在子线程中完成业务处理，然后将结果发送给Handler。由Handler将结果返回给client。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可能主要到没有列出单Reactor + 多进程方案，主要因为如果采用多进程，就要考虑进程间通信的问题，比如子进程处理完成后需要通知父进程将结果返回给对应的client，处理比较复杂。但多线程之间数据是共享的，复杂度相对比较低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，这种方案下，主线程承担了所有的事件监听和响应。瞬间高并发时可能会成为性能瓶颈。这时就需要多Reactor的方案了。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;多Reactor + 多进程/多线程&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;该方案示意图如下（以进程举例）：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8478260869565217&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/bymGBmLC3zFlWqbJt1oq5LQ8ee7Gy5GRZt6QcMlOiaqhh4U8DbBMfAEWxadia0kjGuGv8qY9wMbicLSSuhFQFNf3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1380&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;父进程中 mainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor接收，将新的连接分配给某个子进程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;子进程的 subReactor 将 mainReactor 分配的连接加入连接队列进行监听，并创建一个Handler 用于处理连接的各种事件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当有新的事件发生时，subReactor 会调用连接对应的 Handler（即第 2 步中创建的Handler）来进行响应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Handler 完成 read→处理→send 的完整业务流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前著名的开源系统 Nginx 采用的是多 Reactor 多进程，采用多 Reactor 多线程的实现有Memcache 和 Netty。不过需要注意的是 Nginx 中与上图中的方案稍有差异，具体表现在主进程中并没有mainReactor来建立连接，而是由子进程中的subReactor建立。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Proactor模式&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;以上就是Reactor模式中的几种常见方案，另外除了Reactor模式还有Proactor模式。Reactor 是非阻塞同步网络模型，因为真正的 read 和 send 操作都需要用户进程同步操作。这里的“同步”指用户进程在执行 read 和 send 这类 I/O 操作的时候是同步的，如果把 I/O 操作改为异步就能够进一步提升性能，这就是异步网络模型 Proactor。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;理论上 Proactor 比 Reactor 效率要高一些，但在 Linux 系统下的异步并不完善，因此在 Linux 下实现高并发网络编程时都是以 Reactor 模式为主。所以今天就不对 Proactor 模式进行过多介绍了。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;https://time.geekbang.org/column/article/8805&lt;/span&gt;&lt;/h2&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU3ODkzMDA2Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/bymGBmLC3zHHpBOxu9TYZst8Q2qU06ACNyezHIIjiajJxUP2w7ia53saAMfI6xbibEXibTC67w8Xa5vibJ4GoJREICA/0?wx_fmt=png&quot; data-nickname=&quot;码匠赵铁柱&quot; data-alias=&quot;coder_tiezhu&quot; data-signature=&quot;我是赵铁柱，是名程序员，喜欢做做饭、看看书，偶有一些感想，希望和你分享&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果以上对你有帮助，欢迎关注铁柱，一起成长。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/bymGBmLC3zFlWqbJt1oq5LQ8ee7Gy5GR07MHWyhQm9bq5nV5E3WkHiaXd5W9J85H6je8IkwibPZz24IabyE3yDGQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>