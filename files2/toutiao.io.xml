<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3d118c2e31438a47014e34138dfd3c44</guid>
<title>精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期</title>
<link>https://toutiao.io/k/3ininot</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第324期（2020-11-11）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;双十一，买它买它买它！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_324.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;基于 Kubernetes 的云原生批量计算平台&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;对以 Transformer 为基础的序列特征提取器 (Encoder) 和自回归的序列解码器 (Decoder) 做了深度优化&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;技术雷达是 ThoughtWorks 每半年发布一次的技术趋势报告&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;这是德勤第 11 年发布技术趋势年度报告&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;你知道吗？&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验总结&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;适合入门&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;基于 Swift 推出的函数响应框架&lt;/p&gt;
        
        &lt;p&gt;使用 JavaScript 来自动化 iOS&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;实践总结&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;细致讲解&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;7年工作经验，技术总监&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451915 即可&lt;/p&gt;
        
        &lt;p&gt;坚持原创，持续分享技术，包括但不限于：分布式、微服务架构，spring cloud、Dubbo微服务框架，Java核心技术，Redis缓存、Kafka消息队列中间件等。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 450130 即可&lt;/p&gt;
        
        &lt;p&gt;一个工作10年的程序猿，分享技术干货及内心的声音。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 413084 即可&lt;/p&gt;
        
        &lt;p&gt;详解数据结构与算法&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 142771 即可&lt;/p&gt;
        
        &lt;p&gt;Web前端、服务端、小程序、App、学习资料、工具、资讯&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 125297 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=20115&amp;amp;url=http%3A%2F%2Fproduct.dangdang.com%2F29132383.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_324.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一个技术总监的忠告&lt;/p&gt;
        
        &lt;p&gt;写作不易&lt;/p&gt;
        
        &lt;p&gt;同理心&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2dbe2bbce25d2e272509fee0f92abdc7</guid>
<title>我用 Python 找出了删除我微信的所有人并将他们自动化删除了</title>
<link>https://toutiao.io/k/km6796s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;概述&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知你是否遇到过在微信上给通讯录中的某个人发消息，结果出现了这一幕：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5393442622950819&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUEofIiaJOoFnzPxNQISYMianWC7URLglsC5kG8ww0zRGSpiaSJMu0fDCag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;610&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平时一直认为自己的心里素质过硬，不过遇到这种情况 ...&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUmegARtxyFceBDF1IybLjfuMia8jQQAicK76QBwSU15iaFe8A0ib4DThvQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我缓了半个钟头（半分钟&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUA5AXj0kKLmjia6S76ez1XDOCd3hC6rfG5lFKcGGmo42FQ19uc9UaFVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;）之后，缓缓拿出了手机，打开微信，找到通讯录中的 &lt;code&gt;ABC&lt;/code&gt;，默默地按下了删除按钮，此刻的我心如止水 ...&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUEz2cg23CJj4kuFTLiaVl68QVrXLgpZzWGqRs1y5icHYFGjO0NfSzDXQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，我们回到正题，为了避免再次出现上述情况，我决定把微信通讯录中删除了自己的人全部找出来并且删除，之前我已经在网上了解到检查自己的微信是否被删比较好的方式就是转账，通过转账我们可以实现无痕检测。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUmJP38Ax2oy5VXhVvgWHoeo23gsDd2DC7XrIP3ibicQEzxmaQcyHhN3og/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们通过两张图片直观的看一下微信被删前后给别人转账的效果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.231696014828545&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUWWUteBlBtP9qt6IzaicsrCQBjpia279uZtOcRiasGlk7ttGJFuZ9dNRZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.4308263695450325&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUyicAh82FR82iaqDgGXwcXJzpyH2DbasUagtuDuYibSORFNfILNccNYRvw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1077&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在已经知道了检测方式，正在我准备挨个检测时，无意识的滑动了微信通讯录列表，100、200 ... 500 ...&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUVTtnU04L7DEGLeOQ6GLCr6fQLTTKFI9Zrow84rbTjnsBd7TonWnnSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我去！什么时候加了这么多人，滑动列表的同时我顺势扫了一眼微信名字：A卖保险、B办理信用卡、C游泳健身、D卖保健品 ... 此刻我知道了微信通讯录中有这么多人的玄机，但是有个问题，这么多人我挨个手动执行转账还不累屎了 ...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果手动执行的方式行不通，那么可以通过编程的方式自动化执行吗？想到这里我陷入了沉思 ...&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUqU2ibC4Bbv2tWmTBRe603cFjEjUQ1hLlHLD7qSxvQpEViczZicNjfFqvw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;突然我脑中闪了一下（不是抽筋哈&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUA5AXj0kKLmjia6S76ez1XDOCd3hC6rfG5lFKcGGmo42FQ19uc9UaFVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;），思绪渐明，前几天我不是写了一篇&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODA5OQ==&amp;amp;mid=2247495223&amp;amp;idx=1&amp;amp;sn=3d81982be5f081daa0dab83be7167dc2&amp;amp;chksm=fd3b1c8bca4c959d4a4230bdf4a909905b0516ba64a56d5c2ff2072bbd3760fef2b1893956f0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;Python + Appium 自动化操作微信入门&lt;/strong&gt;&lt;/a&gt;吗？用这个应该就可以实现，编程实现的基本思路如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;获取微信通讯录列表中每个人的名字（备注）并记录，这个是不会有重复的，因为即使在之前加好友时有重复的，自己也会在备注时给改了&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;遍历获取到的通讯录列表，分别对每一个人执行转账操作，如果检测到是删除自己的人就对其执行删除操作，如果检测到不是删除自己的人则继续检测下一个人，依次往复循环&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;环境&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因之前在模拟器上测试 Appium 模拟微信转账可能有点问题，因此本文使用真机实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先简单介绍一下真机环境，下面一起来看一下相应步骤。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从桌角下取出我的小米5s手机（MIUI10.2、Android8.0.0），擦擦灰尘后用数据线将其连到自己的电脑上&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;手机充了一会电之后开机，打开微信登录自己的微信号&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在手机中依次执行（点击）：设置-&amp;gt;我的设备-&amp;gt;全部参数-&amp;gt;MIUI版本（多次点击，开启开发者模式）-&amp;gt;返回设置列表-&amp;gt;更多设置-&amp;gt;开发者选项-&amp;gt;开启开发者选项并分别开启：USB调试、USB安装、USB调试（安全设置）选项，如图所示：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.32&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUeBJd34FS9A2Ld3nASuuEucwRm4EOLpRG66qyiaMrODu4xIG7v2J3ibuQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1075&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;此时手机上会弹出USB的用途弹框，我们选择传输文件（MTP）即可，如图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7477656405163853&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUoyfUXCwQtW63uNHuMibBAicv2pllDZEk7b5b023b89uVCrcGH3OOvpLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1007&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在电脑 CMD 中执行 &lt;code&gt;adb devices&lt;/code&gt; 命令，看是否能找到自己的手机，比如下图所示就是成功的结果了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.32605042016806723&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUSpJibeO78zk01dzoJCLibbX8DcDCQWFwSxsP8bV1PV5aPNjT02TKqcvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;595&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在上面步骤中你可能出现找不到手机的情况，通常这种情况是驱动问题，这里介绍一种简单的处理方式：下载一个驱动精灵，安装启动之后点击驱动管理，之后安装相应驱动即可解决，如图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUicMaWJkWvkdN86ODfoTgVrviao9Xdz6ibib86iaDnHsQPsM0zylLKGNvsdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.396875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUB1HibicYTzhoZYELcS5zVaJbDbGL6wVkbCV7uNLp6lPt9ibVrmXGRU4uQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的一系列操作，我们已经处理好了真机环境了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Appium 的环境本文就不说了，如果不清楚的话，可以看一下：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODA5OQ==&amp;amp;mid=2247495223&amp;amp;idx=1&amp;amp;sn=3d81982be5f081daa0dab83be7167dc2&amp;amp;chksm=fd3b1c8bca4c959d4a4230bdf4a909905b0516ba64a56d5c2ff2072bbd3760fef2b1893956f0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;Python + Appium 自动化操作微信入门&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们开始手动敲代码，如果对 Appium 基本代码操作不了解的话，还是可以去看一下我之前写的这篇：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODA5OQ==&amp;amp;mid=2247495223&amp;amp;idx=1&amp;amp;sn=3d81982be5f081daa0dab83be7167dc2&amp;amp;chksm=fd3b1c8bca4c959d4a4230bdf4a909905b0516ba64a56d5c2ff2072bbd3760fef2b1893956f0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;Python + Appium 自动化操作微信入门&lt;/strong&gt;&lt;/a&gt;，真机与模拟器的使用基本一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先看一下相应参数配置，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;desired_caps = {&lt;br/&gt;    &lt;span&gt;&quot;platformName&quot;&lt;/span&gt;: &lt;span&gt;&quot;Android&quot;&lt;/span&gt;, &lt;span&gt;# 系统&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;platformVersion&quot;&lt;/span&gt;: &lt;span&gt;&quot;8.0.0&quot;&lt;/span&gt;, &lt;span&gt;# 系统本号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;deviceName&quot;&lt;/span&gt;: &lt;span&gt;&quot;m5s&quot;&lt;/span&gt;, &lt;span&gt;# 设备名&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;appPackage&quot;&lt;/span&gt;: &lt;span&gt;&quot;com.tencent.mm&quot;&lt;/span&gt;, &lt;span&gt;# 包名&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;appActivity&quot;&lt;/span&gt;: &lt;span&gt;&quot;.ui.LauncherUI&quot;&lt;/span&gt;, &lt;span&gt;# app 启动时主 Activity&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&#x27;unicodeKeyboard&#x27;&lt;/span&gt;: &lt;span&gt;True&lt;/span&gt;, &lt;span&gt;# 使用自带输入法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&#x27;noReset&#x27;&lt;/span&gt;: &lt;span&gt;True&lt;/span&gt; &lt;span&gt;# 保留 session 信息，可以避免重新登录&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着看一下如何获取微信通讯录名字（备注）列表？代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 获取通讯录列表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;get_address_list&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    driver.find_elements_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cn_&#x27;&lt;/span&gt;)[&lt;span&gt;1&lt;/span&gt;].click()&lt;br/&gt;    &lt;span&gt;# 获取昵称（备注）&lt;/span&gt;&lt;br/&gt;    address_list = driver.find_elements_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/dy5&#x27;&lt;/span&gt;)&lt;br/&gt;    remarks = []&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; address &lt;span&gt;in&lt;/span&gt; address_list:&lt;br/&gt;        remark = address.get_attribute(&lt;span&gt;&quot;content-desc&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 排除自己和微信官方号&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; remark != &lt;span&gt;&quot;自己的微信名&quot;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;&quot;微信&quot;&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; remark:&lt;br/&gt;            remarks.append(remark)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; remarks&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;取到了微信通讯录列表之后，我们就可以对其进行遍历检测了，下面看一下如何实现检测自己的微信是否被删，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 判断是否被删&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;is_delete&lt;/span&gt;&lt;span&gt;(remark, count)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; count == &lt;span&gt;&quot;1&quot;&lt;/span&gt;:&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击微信搜索框&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cn1&#x27;&lt;/span&gt;).click()&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    print(&lt;span&gt;&#x27;在搜索框输入搜索信息&#x27;&lt;/span&gt;)&lt;br/&gt;    driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/bhn&#x27;&lt;/span&gt;).send_keys(remark)&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    print(&lt;span&gt;&#x27;点击搜索到的好友&#x27;&lt;/span&gt;)&lt;br/&gt;    driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/tm&#x27;&lt;/span&gt;).click()&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;# 转账&lt;/span&gt;&lt;br/&gt;    driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/aks&#x27;&lt;/span&gt;).click()&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    driver.find_elements_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/pa&#x27;&lt;/span&gt;)[&lt;span&gt;5&lt;/span&gt;].click()&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cx_&#x27;&lt;/span&gt;).click()&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cxi&#x27;&lt;/span&gt;).click()&lt;br/&gt;    time.sleep(&lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;# 判断是否被删&lt;/span&gt;&lt;br/&gt;    is_exist = is_element_exist(&lt;span&gt;&#x27;com.tencent.mm:id/jh&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; is_exist &lt;span&gt;is&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; remark&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述方法中，如果检测到是删了自己微信的人就返回那个人的微信名（备注），然后我们将这些人记录起来；如果检测到不是删除自己微信的人就返回 False。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述过程执行完了之后，我们就可以获取到所有删了自己微信的人了，接下来我们就可以将这些人都从自己微信通讯录中删除了，删除实现的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 删除把自己删除的人&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;del_person&lt;/span&gt;&lt;span&gt;(nicks)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; inx, val &lt;span&gt;in&lt;/span&gt; enumerate(nicks):&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; inx == &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;            print(&lt;span&gt;&#x27;在搜索框输入搜索信息&#x27;&lt;/span&gt;)&lt;br/&gt;            driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/bhn&#x27;&lt;/span&gt;).send_keys(val)&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;            time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;            print(&lt;span&gt;&#x27;点击微信搜索框&#x27;&lt;/span&gt;)&lt;br/&gt;            driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cn1&#x27;&lt;/span&gt;).click()&lt;br/&gt;            print(&lt;span&gt;&#x27;在搜索框输入搜索信息&#x27;&lt;/span&gt;)&lt;br/&gt;            time.sleep(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;            driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/bhn&#x27;&lt;/span&gt;).send_keys(val)&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击搜索到的人&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/tm&#x27;&lt;/span&gt;).click()&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击聊天对话框右上角...&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cj&#x27;&lt;/span&gt;).click()&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击头像&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/f3y&#x27;&lt;/span&gt;).click()&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击联系人右上角...&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cj&#x27;&lt;/span&gt;).click()&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击删除按钮&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/g6f&#x27;&lt;/span&gt;).click()&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击弹出框中的删除&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/doz&#x27;&lt;/span&gt;).click()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们就利用 Python + Appium 实现了自动化找出微信中删除自己的人并将其删除的工作了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码在公号 &lt;span&gt;Python小二&lt;/span&gt; 后台回复 &lt;span&gt;201108&lt;/span&gt; 获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原创不易，如果觉得有一些帮助，希望大家给个在看或转发。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7aa41646c166b0f7c5ef5981733e54c2</guid>
<title>深入理解 Java 线程池</title>
<link>https://toutiao.io/k/dwlr0t4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;在开发过程中，合理地使用线程池能够带来至少以下几个好处。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;降低资源消耗&lt;/strong&gt;：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;提高响应速度&lt;/strong&gt;：当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;提高线程的可管理性&lt;/strong&gt;：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须了解其实现原理。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码解耦&lt;/strong&gt;：比如生产者消费者模式。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;线程池实现原理&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;当提交一个新任务到线程池时，线程池的处理流程如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤也需要获取全局锁）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果创建新线程将使当前运行的线程数超出maximumPoolSize，该任务将被拒绝，并调用相应的拒绝策略来处理（RejectedExecutionHandler.rejectedExecution()方法，线程池默认的饱和策略是AbortPolicy，也就是抛异常）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;线程池任务 拒绝策略包括 &lt;strong&gt;抛异常&lt;/strong&gt;、&lt;strong&gt;直接丢弃&lt;/strong&gt;、&lt;strong&gt;丢弃队列中最老的任务&lt;/strong&gt;、&lt;strong&gt;将任务分发给调用线程处理&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;线程池的创建&lt;/strong&gt;：通过ThreadPoolExecutor来创建一个线程池。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, timeUnit, runnableTaskQueue, handler);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;创建一个线程池时需要输入以下几个参数：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到线程池的线程数等于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;- ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;PriorityBlockingQueue：一个具有优先级的无界阻塞队列。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;线程的状态&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在HotSpot VM线程模型中，Java线程被一对一映射到本地系统线程，Java线程启动时会创建一个本地系统线程；当Java线程终止时，这个本地系统线程也会被回收。操作系统调度所有线程并把它们分配给可用的CPU。&lt;/p&gt;&lt;p&gt;thread运行周期中，有以下6种状态，在 java.lang.Thread.State 中有详细定义和说明：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// Thread类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; State {&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 刚创建尚未运行&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    NEW,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 可运行状态，该状态表示正在JVM中处于运行状态，不过有可能是在等待其他资源，比如CPU时间片，IO等待&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    RUNNABLE,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 阻塞状态表示等待monitor锁（阻塞在等待monitor锁或者在调用Object.wait方法后重新进入synchronized块时阻塞）&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    BLOCKED,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 等待状态，发生在调用Object.wait、Thread.join (with no timeout)、LockSupport.park&lt;br/&gt;     * 表示当前线程在等待另一个线程执行某种动作，比如Object.notify()、Object.notifyAll()，Thread.join表示等待线程执行完成&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    WAITING,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 超时等待，发生在调用Thread.sleep、Object.wait、Thread.join (in timeout)、LockSupport.parkNanos、LockSupport.parkUntil&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    TIMED_WAITING,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     *线程已执行完成，终止状态&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    TERMINATED;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;线程池操作&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;向线程池提交任务，可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;threadsPool.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// TODO Auto-generated method stub&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，通过future的get()方法来获取返回值，future的get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务还没有执行完。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Future&amp;lt;Object&amp;gt; future = executor.submit(harReturnValuetask);&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    Object s = future.get();&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;    &lt;span&gt;// 处理中断异常&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (ExecutionException e) {&lt;br/&gt;    &lt;span&gt;// 处理无法执行任务异常&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 关闭线程池&lt;/span&gt;&lt;br/&gt;    executor.shutdown();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;合理配置线程池&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;要想合理配置线程池，必须先分析任务的特点，可以从以下几个角度分析：&lt;/p&gt;&lt;p&gt;性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能少的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置多一点线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。&lt;/p&gt;&lt;p&gt;优先级不同的任务可以使用优先级队列&lt;strong&gt;PriorityBlockingQueue&lt;/strong&gt;来处理。它可以让优先级高的任务先执行。执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;线程池中线程数量未达到coreSize时，这些线程处于什么状态？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这些线程处于RUNNING或者WAITING，RUNNING表示线程处于运行当中，WAITING表示线程阻塞等待在阻塞队列上。当一个task submit给线程池时，如果当前线程池线程数量还未达到coreSize时，会创建线程执行task，否则将任务提交给阻塞队列，然后触发线程执行。（从submit内部调用的代码也可以看出来）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6526548672566371&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMoBzhvMx0xbu7cXpjyWBXMuep0rdzx1icxm1xSShebibnUTtV5vgZuDcGZPI1YGmJ4pRibHzPACoAQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;452&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;ScheduledThreadPoolExecutor&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，但ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9209932279909706&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMoBzhvMx0xbu7cXpjyWBXMuiaHusXfjPicW0JIqs8xkXp0evETFvalz2o8LAEw4C67LfNA5HXWP78A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;443&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，ScheduledThreadPoolExecutor和ThreadPoolExecutor的区别是，ThreadPoolExecutor获取任务时是从BlockingQueue中获取的，而ScheduledThreadPoolExecutor是从DelayedWorkQueue中获取的（注意，DelayedWorkQueue是BlockingQueue的实现类）。&lt;/p&gt;&lt;p&gt;ScheduledThreadPoolExecutor把待调度的任务（ScheduledFutureTask）放到一个DelayQueue中，其中ScheduledFutureTask主要包含3个成员变量：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4896810506566604&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMoBzhvMx0xbu7cXpjyWBXMHvAQwOJa0NIatEG7QhsuroP3iaEnEKosbM0QCywCibaK5u60obbsaQCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;533&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;sequenceNumber：任务被添加到ScheduledThreadPoolExecutor中的序号；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;time：任务将要被执行的具体时间；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;period：任务执行的间隔周期。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;ScheduledThreadPoolExecutor会把待执行的任务放到工作队列DelayQueue中，DelayQueue封装了一个PriorityQueue，PriorityQueue会对队列中的ScheduledFutureTask进行排序，具体的排序比较算法实现如下：&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.604989604989605&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMoBzhvMx0xbu7cXpjyWBXMiaqBRgmib83YVl2NFUic1MrlqhH62Ds6TMzpHric45AGc9DGJCV8JsYZxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;481&quot;/&gt;&lt;/p&gt;&lt;p&gt;ScheduledFutureTask在DelayQueue中被保存在一个PriorityQueue（基于数组实现的优先队列，类似于堆排序中的优先队列）中，在往数组中添加/移除元素时，会调用siftDown/siftUp来进行元素的重排序，保证元素的优先级顺序。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DelayedWorkQueue&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractQueue&lt;/span&gt;&amp;lt;&lt;span&gt;Runnable&lt;/span&gt;&amp;gt;&lt;br/&gt;    &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BlockingQueue&lt;/span&gt;&amp;lt;&lt;span&gt;Runnable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INITIAL_CAPACITY = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RunnableScheduledFuture&amp;lt;?&amp;gt;[] queue =&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; RunnableScheduledFuture&amp;lt;?&amp;gt;[INITIAL_CAPACITY];&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Thread leader = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Condition available = lock.newCondition();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从DelayQueue获取任务的主要逻辑就在take()方法中，首选获取lock，然后获取queue[0]，如果为null则await等待任务的来临，如果非null查看任务是否到期，是的话就执行该任务，否则再次await等待。这里有一个leader变量，用来表示当前进行awaitNanos等待的线程，如果leader非null，表示已经有其他线程在进行awaitNanos等待，自己await等待，否则自己进行awaitNanos等待。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// DelayedWorkQueue&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; RunnableScheduledFuture&amp;lt;?&amp;gt; take() &lt;span&gt;throws&lt;/span&gt; InterruptedException {&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span&gt;this&lt;/span&gt;.lock;&lt;br/&gt;    lock.lockInterruptibly();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            RunnableScheduledFuture&amp;lt;?&amp;gt; first = queue[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (first == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                available.await();&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;long&lt;/span&gt; delay = first.getDelay(NANOSECONDS);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (delay &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; finishPoll(first);&lt;br/&gt;                first = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// don&#x27;t retain ref while waiting&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (leader != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                    available.await();&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    Thread thisThread = Thread.currentThread();&lt;br/&gt;                    leader = thisThread;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        available.awaitNanos(delay);&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (leader == thisThread)&lt;br/&gt;                            leader = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (leader == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; queue[&lt;span&gt;0&lt;/span&gt;] != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            available.signal();&lt;br/&gt;        lock.unlock();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;获取到任务之后，就会执行task的run()方法了，即ScheduledFutureTask.run()：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; periodic = isPeriodic();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!canRunInCurrentRunState(periodic))&lt;br/&gt;        cancel(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!periodic)&lt;br/&gt;        ScheduledFutureTask.&lt;span&gt;super&lt;/span&gt;.run();&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ScheduledFutureTask.&lt;span&gt;super&lt;/span&gt;.runAndReset()) {&lt;br/&gt;        setNextRunTime();&lt;br/&gt;        reExecutePeriodic(outerTask);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c43dc6428983c055f22b5d124bc860ff</guid>
<title>华东师范大学的数据库系统研究</title>
<link>https://toutiao.io/k/vjryow7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;48&quot; data-ratio=&quot;0.10078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUrXicw2VXTQTVVN5yxXWEacdY1ZdxTH195Pgibtib8EENJRMia3tzEnyVfgyfAgRibMssKqwlE186TLSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总第421篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2020年 第45篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img border=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;93&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;93&quot; data-ratio=&quot;0.9966329966329966&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVLR21NicmyQxcmiaqQ2KOJJj2JLwgJL4KSbo7CcuMF1hLf4xFjGQiaDRhSPyERxWGChWYP47Oc4sKGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot; data-width=&quot;100%&quot; opacity=&quot;&quot; title=&quot;undefined&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; data-style=&quot;text-align: left; font-size: 14px; color: inherit;&quot;&gt;&lt;section&gt;&lt;span&gt;【Top Talk/大咖说】由美团技术学院和科研合作部主办，面向全体技术同学，定期邀请美团资深技术专家、业界大咖、高校学者及畅销书作者，为大家分享最佳实践、互联网热门话题、学术界前沿技术进展等内容，帮助美团同学开拓视野、提升认知。&lt;/span&gt;&lt;/section&gt;&lt;p line=&quot;cpHY&quot;&gt;&lt;/p&gt;&lt;p line=&quot;cpHY&quot;&gt;&lt;span&gt;2020年10月27日，Top Talk邀请到了华东师范大学周烜老师，请他带来题为《华东师范大学的数据库系统研究》的分享。本文系周烜老师分享报告的文字版，希望能对大家有所帮助或者启发。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.4058823529411764&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTNV3hiab1rBLbv1KYiaxM1AibAKkZtEqSK6qzJVdq3lASpib6ZsKwGLfiaJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;170&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;/报告嘉宾/&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p line=&quot;4ALq&quot;&gt;&lt;span&gt;&lt;strong&gt;周烜 | 华东师范大学教授，数据科学与工程学院副院长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;4ALq&quot;&gt;&lt;/p&gt;&lt;p line=&quot;4ALq&quot;&gt;2001年本科毕业于复旦大学，2005年在新加坡国立大学取得博士学位，2005年至2010年期间先后在德国L3S研究中心和澳大利亚联邦科工组织从事科研工作，随后在中国人民大学信息学院任教6年，于2017年3月加入华东师范大学。研究兴趣包括数据库系统和信息检索技术。曾参与和负责多个国内外的科研项目和工业合作项目，积累了丰富的数据管理系统研发经验。研究成果被发表于众多国际一流的学术会议和期刊。凭借在分布式数据库领域的成果转化获得国家科技进步二等奖和教育部科技进步一等奖。入选教育部“新世纪优秀人才”支持计划。&lt;/p&gt;&lt;p line=&quot;4ALq&quot;&gt;&lt;/p&gt;&lt;p line=&quot;DQv9&quot;&gt;&lt;span&gt;&lt;strong&gt;/报告摘要/&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;DQv9&quot;&gt;&lt;/p&gt;&lt;p line=&quot;DQv9&quot;&gt;华东师范大学是国内为数不多长期坚持数据库内核技术研究的高校，在学术界和工业界均建立了较好的声誉。本次讲座将分享华东师范大学数据库团队近期的一些科研思路和研究成果。首先分析驱动数据库技术发展的主要因素，谈一谈未来有价值的研究方向。再聊一聊团队近来取得的一些有趣的研究成果，领域包括新硬件的数据库适配、分布式事务处理、HTAP、系统实现模块化（&lt;span&gt;Modularization&lt;/span&gt;）等等。&lt;/p&gt;&lt;p line=&quot;DQv9&quot;&gt;&lt;/p&gt;&lt;p line=&quot;mwPp&quot;&gt;&lt;strong&gt;&lt;span&gt;00 引言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p line=&quot;Wkb8&quot;&gt;       &lt;img data-ratio=&quot;0.5612391930835735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaThBx3V4piaq7YMOCp2eBe8tT1rDKxBOLntKibOeibbP84lxl1W8KWNug8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1388&quot;/&gt;
      &lt;/p&gt;&lt;p&gt;今天我代表华东师范大学的数据库团队，来分享一下对数据库这种技术或者这种产品的一些研究心得以及当前的研究成果。其实，高校跟企业实际上是处在两个不同的生态领域当中，高校更关注关于研究理论的一些问题，但是企业更多的关注企业本身的产品以及用户，所以两者面向的目标是不太一样的。但是经过我们在华师大这么多年的一些摸索，特别是我们自己研究上的一些摸索，以及跟企业合作的经历，我们觉得实际上高校和企业应该一起来做我们称为数据库系统或者基础软件的研究，因为只有这样才能够更好的推动这个行业本身的发展。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我的报告内容会分成两个部分。首先分享一下我们对数据库这种技术发展动态的看法，我们团队在数据库这个领域也做了很多年，包括我之前在中国人民大学也是做数据库系统的，我在这个领域里面有可能不到20年的积累。我希望能够提出我们的看法，并且能够得到大家的一些反馈，纯粹是做一种探讨，因为对技术的发展方向的探索，没有标准的答案。我觉得大家应该集思广益，共同去探讨，才能把这个问题看得更清楚，这是讲座前面一部分的内容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;pTuF&quot;&gt;后面一部分的内容我会聚焦到我们的一些研究成果上，这些研究成果可能就会比较技术细节了，会更适合搞技术、数据库、系统的这些同学，但是我会尽量把讲座的形式变得更大众化一点，尽量用更通俗的方式去给大家介绍。我希望通过这种细节的介绍，也能够让大家了解一下，我们在设计系统的时候，通常一个工程师、一个研究者或者一个学者，他的思路大概是怎么样的，我不能代表所有的人，但是因为我们这个团队是一个典型的做系统的团队，所以这个思路可能仅代表了一部分做系统的学者的思路。&lt;/p&gt;&lt;p line=&quot;B1ee,2vCq,lVny,7tvx,BFNP,PtK4&quot;&gt; &lt;/p&gt;&lt;p line=&quot;XgnE&quot;&gt;&lt;span&gt;01 数据库系统的形态变化&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;XgnE&quot;&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1 什么引起了数据库系统的形态变化？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先问大家一个问题，什么引起了数据库系统的形态变化？我们知道数据库系统实际上是一个有很长历史的系统，是现代软件开发的一个核心部件。任何应用都离不开某种数据库，但是我们其实也可以看到，如果你有一定的经验，比如大概10年的工作经验，你会看到数据库系统的形态是在发生变化的，10年前用的很流行的东西，现在不见得普遍被采用。这个系统虽然有很长很长的历史，也很成熟了，但是它的形态还是在发生变化的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;什么在驱动数据库系统的形态变化？这是一个很重要的问题，也是比较有趣的问题，但并不是一个好回答或者能够全面的回答的问题。我这里就直接抛出我们对这个问题的一些看法，我们觉得数据库系统的形态变化，主要来自三个方面的推动力：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;xF25&quot;&gt;&lt;/p&gt;&lt;p line=&quot;xF25&quot;&gt;我们看到的推动力主要就是这三个。我们认为未来推动数据库变化的原因也不出于这三个，我们可以通过这个东西去预知未来应该朝什么方面去推进我们的数据库技术的进步。下面我就大概做一个简单的展开。&lt;/p&gt;&lt;p line=&quot;MXZn&quot;&gt; &lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;1.1.1 应用需求的变化&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先第一点就是应用需求的变化。我们认为这实际上是在推动底层技术，像数据库系统这种技术变化的一个主要原因。&lt;/p&gt;&lt;p line=&quot;IgaT&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTXonKYl4ibx6zjocvs9H8jZiaINMsdhbcoLAQibL3zZAh0EvmdMfQYddTw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;115.84775086505189&quot; data-cropy2=&quot;541.8685121107266&quot; data-ratio=&quot;0.39444444444444443&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTibHkHU0UDqEKjMn9ZaKbnichRpae1fqkGAqLJJ9rjE85kSfmcjFrWj5g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p&gt;通过上面这三幅图大家能够很容易去理解数据库诞生的年代，那个时候磁盘作为一个存储介质，刚刚在市场上推广，磁盘取代了磁带，数据的随机访问变的可能了。那个时候对数据管理功能的需求一下子就增长了，当时出现了各种各样的数据库，包括网状数据库，包括后面的关系数据库，那个时候是我们叫前互联网时代就出来了。但那个时候应用的规模并不大，数据库的用户量一般，终端用户其实很少，对于一个银行来讲就是那些银行职员在使用数据库，普通用户在银行排队，他们不是终端的使用者。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;后来进入到互联网时代之后，我们发现终端的使用者一下子就爆炸性的增长了。现在我们每个人有一个手机，随时都在使用手机上的App，然后这个App他随时都会把请求发送给后台的数据库。我们看到应用规模在最近20年有一个很大的增长，如果往后看的话，未来我们认为增长有可能还会继续。我们的工业互联网、物联网使用的话，我们的终端会变得更多，他可能对数据管理系统的压力会变得更大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以我们看到应用不断的扩张，给数据库这种底层系统有一个持续增长的压力，要应对这样的压力，以前对数据库的设计，它逐渐就变得不太实用，必须去革新，必须去改变它。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个是我们看到的一个最主要的推动力。但除了应用规模的扩展，当然就还有一个应用领域的扩展，最开始的数据库它就是金融领域或者电信领域去使用，并不会在互联网、销售或者传媒等等这些领域去大规模的使用，但是我们发现IT的渗透到各行各业之后，它的应用范围也在增加，应用范围增加对传统的系统来讲是不友好的，或者是说你的传统数据库系统对这些应用是不友好的，所以这个也在推动它的一个变革。&lt;/p&gt;&lt;p line=&quot;M2m5&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT1zLINEMUUAhHmZxd5qTYAlDs9SNlUuicicxtWiaJNoAdxnMdMScd8icHRw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;125.1903114186851&quot; data-cropy2=&quot;609.1349480968858&quot; data-ratio=&quot;0.44907407407407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT9dXdwb0ZRHmvZgcKuOcT841K5fpJZVMSRKAD6NIvqdYxTWvQvib7XYA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p&gt;应用需求带来什么变化？我们回顾历史的话，我们看到分布式数据库现在变得越来越被大家所需要，大家看到了谷歌的一些分布式数据库的产品，它现在作为一种标杆的产品，然后国内也有一些分布式数据库的场景，包括美团在内，听说美团内部也在研制自己的分布式数据库，实际上是在对需求的负载增加的一个应对。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;应对它实际上并不是一个很简单的事情，如果要增加你的数据库的扩展性，有时候你必须要重新去设计你的数据库的架构。我们通常做系统的同学应该了解，其实在做系统的时候，你需要做很多折中的考量的，有些东西是不能兼顾的，比如说你的功能性和应用性对吧？一个东西特别简单去使用的话，它功能性有时候就是比较简单，它复杂的功能处理不了，或者是你的功能很复杂的时候，你的扩展性又上不去。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在系统设计的时候你必须去做一种权衡，去获得一部分这方面的能力，你就必须丢失其他的一些能力。当你需要它的扩展性非常强的时候，你有可能就要去重新考量它，你要去丢弃什么东西，你要去忍受什么其他的一些东西，然后这个时候就产生架构的变化，这样的话我们就会发现有新的系统出来，比如说以前的是SQL，我们现在有讲NoSQL大家认为它的扩展性容易做的更好一些，然后会有其他形态的一些数据管理产品。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对这个问题，学界工业界都有很多的讨论，Michael Stonebrake大概10多年前发表的一些言论，就说“One size does not fit all”，你不太能指望某一个系统能够能够处理所有的应用需求。因为不同的应用需求，你可能必须要做不同的折中、重新的考量，你只能顾此，你顾此只能失彼，所以这样就产生了一个多样化的形态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;9M90,GE9z,Hbyh,tY7h,dOMR,BQlZ,dT0W,DJqI,Vibo,viDe&quot;&gt;我们现在看到的数据库，如果你们在使用的话，你会面临很多选择，你到底用MySQL还是MongoDB对吧？你的分析的时候你要用什么？用Hadoop还是用传统的数仓MPP产品，有不同的需求，可能有不同的考量。这个我们看到应用需求它的变化，它的增加，它在实际上对这个系统起到了一个很重要的推动的这个作用，这是我展开的第一点。&lt;/p&gt;&lt;p line=&quot;9M90,GE9z,Hbyh,tY7h,dOMR,BQlZ,dT0W,DJqI,Vibo,viDe&quot;&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;1.1.2 软件开发模式的转变&lt;/strong&gt;&lt;/p&gt;&lt;p line=&quot;pVca&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTqsic7tlUygJ38IrJiaiboJWLPlzag68NCLKoEhQo1vOIzd5ktyw97twZA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;147.61245674740482&quot; data-cropy2=&quot;541.8685121107266&quot; data-ratio=&quot;0.36574074074074076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTaeKEhhf4OPEOJVee9FbmLdJlZLAaPHV1uiaSh1VL6aQCBymibgnZtLKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p&gt;然后，第二点就是我们发现软件开发模式的变化，也在促进数据库本身的改变。就像我刚才提到的，现在用到的很多软件开发的模式跟以前不一样。以前关系数据库这样的产品刚刚被广泛应用的时候，当时的软件开发它是以数据为中心的，一个数据库设计出来，有好多应用都会去用它，它是一个Shared底层系统。那个时候数据库的设计过程，它是相对独立的，DBA根据App开发人员的需求、用户的需求，以DBA的方式去设计数据库，按照对数据模型的理解，把它设计得非常的规整，要满足各种各样的范式，然后给不同的应用去用。但现在我们发现一旦用到微服务这种新的开发模式的时候，很多时候这种横向的分割变得不是那么重要了。原本数据是一层、应用逻辑是一层，这两层之间的解耦是很重要的，但现在不是了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;现在是微服务的形式，是纵向的切割，把业务整个分成一块一块的，每一块里面都有单独的数据库，有单独的功能设计，这弱化了数据库跟应用之间的界限，强化了应用里面不同模块的界限。这样的话，每个模块可以用不同的数据库产品，比如说一个设备用MySQL，另外一个设备可能用MongoDB，第三个设备可能用ES，这些模块之间的数据有同步有交互，可以用一些比如像事件驱动的架构，像Kafka这种MQ (&lt;span&gt;Message Queue&lt;/span&gt;)去连接在一起，形成一个总体的架构。&lt;/p&gt;&lt;p line=&quot;bHDU&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTLIfh3K4huuFjPX0uvA3vgibqpPFIOEX1q8bDZANTZKSC5zJIjtcbHDw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;155.0865051903114&quot; data-cropy2=&quot;487.681660899654&quot; data-ratio=&quot;0.3074074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTicoewcVusEPU2F0NphufNc4TU3vytk8hgbpU0SfyVY2qwOKRAUJezUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;1ZLg&quot;&gt;这种设计跟以前的数据库是不太一样的，对于数据库本身的要求也不太一样。不同的Service会用不同形态的数据库产品，根据需求或者根据软件开发者的习惯，去采用各种缓存、消息队列等，去把这些东西给嫁接在一起。这样的形态对数据库有不同的要求，所以NoSQL被很多人接受。&lt;/p&gt;&lt;p line=&quot;1ZLg&quot;&gt;&lt;/p&gt;&lt;p line=&quot;1ZLg&quot;&gt;在某些软件开发的场景下，NoSQL就是比关系数据库使用起来更简单。然后事务的处理方式也变得很不一样，现在的消息队列在事务处理中，它的权重非常的高，而不是完全依赖于传统数据库内部支持事务处理的模式。这个是我们也看到这样的一些变化，这个是软件开发模式带来的一些改变。&lt;/p&gt;&lt;p line=&quot;1ZLg&quot;&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;1.1.3 硬件平台的革新&lt;/strong&gt;&lt;/p&gt;&lt;p line=&quot;ATrQ&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT4nOniam8jx6V1E9zvzpibRDNFI7tU3lhv3ecxibiaVc4s0Id5jZgg1tKiaw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;115.84775086505189&quot; data-cropy2=&quot;569.8961937716263&quot; data-ratio=&quot;0.4212962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTdeWvL1JvyCzBE2uYcQ6mc33nA7ZKicibW2563ByqFmRcWXSvW1HXCWsQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;PlbU&quot;&gt;第三个方面就是平台的革新。其实我们不会对传统的数据库的硬件平台灵活性有太多的关注，但现在数据库产品面向的基本上都是云平台，不是以前的IBM大型机了，不是Oracle那个时候的硬件平台。我们面对的是一个云平台，云平台自身是在发展的。以后的云平台其实可以预见得到，它不单单是现在我们看到的，是由一个个虚拟机或者是一个个容器组成的一个计算平台，还有可能就像一个大型的计算机一样，只是这种大型计算机它的资源非常的丰富，需要调用什么样的资源都可以获得，需要更多的内存、CPU、存储，都可以直接的获取。&lt;/p&gt;&lt;p line=&quot;PlbU&quot;&gt;&lt;/p&gt;&lt;p line=&quot;PlbU&quot;&gt;云平台通过比较高效的网络方式把这些资源全部连在一起，然后给用户的接口也很简单，很多维护功能是在云平台内部去实现的。数据库要扎根在这样的一个云平台上面，其实对数据库系统就会有新的要求。以前的数据库，大家都记得有几种架构可以选择，叫Shared Everything、Shared Nothing、Shared Disk这样的一些架构。&lt;/p&gt;&lt;p line=&quot;PlbU&quot;&gt;&lt;/p&gt;&lt;p line=&quot;PlbU&quot;&gt;但是我觉得在“云”层面上，数据库其实不再是那么简单去划分的，就是说数据库系统的产品，必须要做到具有很好的弹性。任何的资源在短缺的时候，可以通过云的这种方式很快的把资源调度过来，从而增加数据库的能力。对用户的话，只是提供一种数据库的服务，用户用多少？就提供多少。这样的一个云架构下的数据库，形态可能跟以前要有一些变化。除了这种云的体系之外，其实还有一些新硬件出现，硬件种类也变得越来越多。不同的种类的硬件，在不同的条件下，算力也在不断增加。当然除了计算，还有存储也发生很多变化，把这些放到云的里面去，云的资源变得更加丰富，对数据库的要求也会变得更高。&lt;/p&gt;&lt;p line=&quot;PlbU&quot;&gt;&lt;/p&gt;&lt;p line=&quot;XLat&quot;&gt;因此，我们看到这种硬件平台的变革，它实际上在推动数据库的一些发展。现在大家很常见的就是这种计算与存储分离的这种架构的数据库。我把数据库本身这种系统，它的计算层跟存储层完全的分割开，计算层可以自己扩展，存储层也可以自己扩展，两层就通过云这种高速的、互联的通道能够连接在一起，这种实际上就是针对云的一个特殊的处理。我们知道存储是便宜的，所以在存储需要扩展的时候，没有必要在扩展存储的基础上去加CPU的资源，因为CPU比较贵。如果分开扩展的话，这样确实会在成本上有极大的提升。&lt;/p&gt;&lt;p line=&quot;X64e&quot;&gt;&lt;/p&gt;&lt;p line=&quot;X64e&quot;&gt;未来各种资源加进去之后，它都有可能有扩展的需求。比如说缓存，新的存储器，新的内存加进去之后，有可能需要它跟底层的存储分开，进行一个隔离，再分别去扩展，这都是有可能的。但现在的数据库产品其实面对这种扩展能力，实际上是非常有限的，存储和计算分开扩展到一定程度，实际上它的能力就达到一个峰值了。那么怎样去推动它进一步的这种弹性的增加，实际上是一个挺难的问题，但是也是挺有趣的问题。&lt;/p&gt;&lt;p line=&quot;HQCb&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTicm1HcOmiaDe3VcEBUXrsicEjuE9nP5ovAHJoeN2L4edY0J0n1Gxibn03A/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;112.1107266435986&quot; data-cropy2=&quot;560.553633217993&quot; data-ratio=&quot;0.41574074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTBfAsC4jI9LvG062a9Z9TKIibvica9A50npLL9E0YXEyzews7c3aJEzHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;zdKI&quot;&gt;新硬件对数据库产品的影响，这里有一个简单的公式，公式的左边叫做Data/Cost，单位数据处理，单位代价上面可以处理多少数据。这个是我们需要提升的，因为可以想象以后的数据量会越来越大，如果不把单位价格上面能处理的数据这个值提升的话，应对数据的能力就没办法提升。数据越多，需要花费的资源或者代价就越多，这个是我们不希望看到的。希望左边这个式子中Data/Cost的值随着技术的进步，它可以逐渐的提升。&lt;/p&gt;&lt;p line=&quot;zdKI&quot;&gt;&lt;/p&gt;&lt;p line=&quot;mmR3&quot;&gt;然后把左边这个式子它分解一下，分解成Data/Hardware和Hardware/Cost的一个乘积。这其实是很简单的一个因素分解，大家能够看得很明白。我们发现后面这个式子Hardware/Cost，实际上它的增长在逐渐的趋缓甚至停滞，主要的一个问题就是单位价格能够买到的硬件资源，要在这上面做更进一步的提升，会变得非常的困难。&lt;/p&gt;&lt;p line=&quot;mmR3&quot;&gt;&lt;/p&gt;&lt;p line=&quot;97M0&quot;&gt;最后，如果想实现Data/Cost的提升的话，只能去提升左边这个式子Data/Hardware，这个是未来一个很明显的趋势。怎么样能够提升Data/Hardware？就是单位硬件下处理数据的能力要怎样提升？我们认为只有两种途径，第一种是硬件定制化，面对不同的应用需求，需要为这种应用需求做特殊的硬件。其实我们能看到像GPU、TPU这种出现，其实就已经在揭示这种规律了，专用硬件效率总是要比通用硬件好的。然后软件是一样的，专用的软件的效率肯定比通用的软件好。&lt;/p&gt;&lt;p line=&quot;97M0&quot;&gt;&lt;/p&gt;&lt;p line=&quot;97M0&quot;&gt;这个趋势我觉得可以从长期来看，短期可能并不是那么的明显，但长期来看的话，这个过程应该是不可阻挡的，也就是说我们可能会面临要去为应用去定制系统，要为专门的这种系统配置适合它的硬件。&lt;/p&gt;&lt;p line=&quot;97M0&quot;&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2 数据库系统的未来发展趋势&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;3MOW&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTwCGVsIOfhW57zGIBH1OPNNvjvesQ7M3skQlyDlNmXJeF64Iql1ibd4A/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;149.48096885813146&quot; data-cropy2=&quot;609.1349480968858&quot; data-ratio=&quot;0.42592592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTj62ytEXKCsvjeCvEzEBCAq2YTKPxdBSfzL4g6DEcPmuHHiarBRgqcUQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;UsZj&quot;&gt;我们刚才讲了三点，第一点就是应用的变化在推动系统的演进；第二个是软件开发模式的变化实际上也在带来系统的功能的一种变革；最后是硬件平台。因此，我们觉得未来数据库发展的趋势：&lt;/p&gt;&lt;p line=&quot;UsZj&quot;&gt;&lt;/p&gt;&lt;p line=&quot;CnGd&quot;&gt;&lt;/p&gt;&lt;p line=&quot;CnGd&quot;&gt;&lt;span&gt;02 华师大的数据库系统研究&lt;/span&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 研究团队&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;Zj9d&quot;&gt;       &lt;img data-ratio=&quot;0.5655619596541787&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTEsdiaDjp74FpLo90k4BlhUEYIGDaLT911F3Jyt8VGYqxNibphxKUlSCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1388&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;4Dxy&quot;&gt;然后介绍一下我们现在这个团队，华东师范大学数据科学工程学院大概有20多个老师，大概10个老师是从事数据库内核的研究的。整个团队的历史是超过20年的，我们近10年其实做了非常多的系统内核研发的工作，跟业界的很多的公司也有合作。我们的学生其实也做了很多工程性的工作。&lt;/p&gt;&lt;p line=&quot;4Dxy&quot;&gt;&lt;/p&gt;&lt;p line=&quot;kIr2&quot;&gt;去年我们有拿到一个国家科技进步二等奖，这个是基于我们当时和某银行一起做的一款数据库产品，是我们基于OceanBase的一个早期开源的版本上实现的一个系统，具体的这种内容我就不做过多的介绍，这个系统实际上在某银行得到了比较深入的应用，是我们比较引以为豪的一个研究成果。&lt;/p&gt;&lt;p line=&quot;kIr2&quot;&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2 研究成果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;BXer&quot;&gt;我们团队的研究其实还是蛮广泛的，我们在事务型数据库和分析型数据库其实都有研究，但我们更多的精力还是集中在事务型数据库上面。然后接下来，我会介绍一些典型的研究成果，让大家了解一下我们的研究是在做一些什么事情，主要分三个部分，第一个是分布式事务，第二个是数据库系统解耦合，第三个是新硬件。&lt;/p&gt;&lt;p line=&quot;BXer&quot;&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;2.2.1 分布式事务&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;f4Ps&quot;&gt;分布式事务是一个几十年来大家都在探讨的话题，实际上也是有一定的争论：分布式事务到底合不合用？我们在使用事务处理这种功能的时候，是不是应该去规避分布式事务？还是我们应该进一步去增强数据库支撑分布式事务的能力，让程序员不要刻意去规避分布式思维？这实际上是一个疑问，目前没有一个明确的答案。&lt;/p&gt;&lt;p line=&quot;f4Ps&quot;&gt;&lt;/p&gt;&lt;p line=&quot;cnyq&quot;&gt;如果分布式事务确实是不行的，那我们就应该做一些其他方面的处理，来弥补分布式事务本身的缺陷，这样做有两种方式：&lt;/p&gt;&lt;p line=&quot;cnyq&quot;&gt;&lt;/p&gt;&lt;p line=&quot;W2xX&quot;&gt;&lt;/p&gt;&lt;p line=&quot;W2xX&quot;&gt;我们认为现在以NoSQL为代表的这些系统的推动者，实际上是持这样的观点的。比如典型的NoSQL客户系统MongoDB，它的一般的事务处理或者数据库的访问，都是Single Document一个文档一个文档去处理的。实际上，就是如果真要进行复杂的事务处理，那就到上层应用去处理，就用最定制化的方式去应对这种事务，它的效率可以比较高。&lt;/p&gt;&lt;p line=&quot;W2xX&quot;&gt;&lt;/p&gt;&lt;p line=&quot;FLjF&quot;&gt;另外一种观点认为分布式事务本身应该是可行的，我们应该提升数据库处理分布式事务的能力，解放开发者。&lt;/p&gt;&lt;p line=&quot;FLjF&quot;&gt;&lt;/p&gt;&lt;p line=&quot;DMQ7&quot;&gt;&lt;span&gt;这样的观点就是那些推动NewSQL这一类系统的人所持的观点，比如说谷歌的Spanner 、TiDB、OceanBase。那么想要把分布式事务做好，怎样去优化，提升分布式事务的能力？首先要处理异常，分布式事务最害怕的一个问题就是出现异常，出现异常之后，如果是一个分布式事务，一旦事务锁掉一个节点上的数据，另一个节点出现故障的话，就会很麻烦。那为了处理异常，然后以Spanner为代表，使用了很多高可用的系统架构，用Paxos/Raft创建这种在云平台，在这种廉价计算机上同样能够有高可用能力的基础设施，在这个上面我可以去规避分布式事务所遇到的这种异常的问题。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;DMQ7&quot;&gt;&lt;/p&gt;&lt;p line=&quot;YREk&quot;&gt;但除了异常问题之外，实际上还有分布式事务的扩展性的问题。虽然分布式事务可以比较放心地应用于可靠的、高可用的系统上，但是它的性能会比较差。因此，我们必须要优化它的性能，为此学术界也做了很多尝试，对于团队来讲，最近几年，我们也做过一些研究和尝试。接下来我就大概讲一下我们的大概思路。&lt;/p&gt;&lt;p line=&quot;YREk&quot;&gt;&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;首先，我们要了解到底是什么限制了分布式事务的扩展能力，大家是比较公认的一种观点是制约分布式事务扩展的主要是事物之间的这种阻塞Blocking。你可以想象一下，当一个事物它去访问一个数据，特别是修改一个数据之后，它会加锁，然后在加锁的过程中，又要去跟其他的节点进行各种通信。&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;其实这种通信有时候是很耗时的，有时候甚至要跟异地的节点，比如说要做高可用，就需要跟异地的节点建立通信。在加锁的过程中去通信，由于通信的过程很长，然后就会把加锁的时长变得特别的长，阻塞就会变得很严重。一旦事务处理的阻塞时间增加，它的事物的吞吐有可能会受到很严重的影响，特别对于有一些热点的数据出现的话，不是时长增加一倍，性能就降低一倍的，有时候时长增加一倍，性能可能会降低若干倍，这是一个很麻烦的问题。&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;&lt;span&gt;所以说，真的想要解决分布式的扩展能力的话，在已经有高可用的前提下，我们最重要的目标就是要降低阻塞。怎样降低阻塞？其实可以用到很多的技术。比如说MVCC/OCC、 MVCC是多版本的数据管理，它可以降低阻塞，这个很直观，就是我一个数据有多个版本，当我的一个事务去改动数据的时候，我直接产生一个新的版本，这样就不用去阻止别人读你的旧版本。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;&lt;span&gt;因为你有多个版本，新版本在产生的过程中，你没有办法去读，可以去读旧版本不用阻塞，这就是MVCC的使用。然后OCC也是一样的，就是OCC就是乐观并发控制，也就是说默认不需要加锁，到最后再来检测这个事务是不是执行正确，如果执行不正确推翻就行了。然后还有一些锁的优化，通过各种各样的技术，来把阻塞的现象把它尽量的减少，从而来提升分布式事务的扩展能力。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;MVCC时间戳分配去中心化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;ZFQJ&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaToZRRORibDibqAYXnGd1E1oDrSnJD2yA22tawn3bibicAL3pSgQHAlSUsPA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;147.61245674740482&quot; data-cropy2=&quot;543.7370242214532&quot; data-ratio=&quot;0.3675925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT4vX85pxibayOtZQXia7akDoiapflrmY0fjINAqKic30Vs6oibJwhC83qNOQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;r6aP&quot;&gt;在MVCC上我们做过一些工作。当然MVCC有一个时间戳分配的问题，就是说它来判断一个事务或者一个数据或者一个数据的版本，它是不是应该由某一个事务去读取的话，它要通过一些时间戳的判断来做。时间戳的分配很麻烦，按道理来说，它是应该有一个中心的时钟，大家都去中心的时钟去拿时间戳，这样就可以保证事务处理正确无误。但通常如果有一个中心的时钟的话，那扩展性就受限了，比如谷歌的Spanner用一些原子钟去规避这个问题。然后我们做的一个研究就是去中心化，去优化了SI的隔离级别。&lt;/p&gt;&lt;p line=&quot;r6aP&quot;&gt;&lt;/p&gt;&lt;p line=&quot;r6aP&quot;&gt;SI是一种典型的MVCC的隔离算法或者并发控制的算法，它是需要时间戳的。我们做了一个去中心化。想法是我在给事务分配时间戳的时候，不是在事务开始的时候分配，而是在事务要结束的时候，根据它跟其他事务的关系、冲突情况，来给它指定一个合适的时间戳，所以叫后验时间戳，Posterior SI。这种方式使得我们可以不需要用一个中心的时间戳去做这个事情，但这个东西做起来其实蛮复杂的，我们大概5年前做了这件事情，最后有一些实验没有实现在现实的系统里面去，因为实现相对来说比较复杂，而实际应用中使用一个统一的中心的时间戳，基本的应用还是可以满足的。&lt;/p&gt;&lt;p line=&quot;xikF&quot;&gt;       &lt;img data-backh=&quot;241&quot; data-backw=&quot;402&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTW4V9moxItcbOGFEd1TItGfEvmQxoGDvEVG5hunr4nicuhUl0CVz7yiag/640?wx_fmt=png&quot; data-cropx1=&quot;145.7439446366782&quot; data-cropx2=&quot;896.8858131487889&quot; data-cropy1=&quot;125.1903114186851&quot; data-cropy2=&quot;575.5017301038062&quot; data-ratio=&quot;0.5992010652463382&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT9R3JiaC7xJ8pniaBYU9EayvfKibiaUzvM2vjBW9icXmHXHdMnVO9Cq1U5Nw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;751&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;z9Eo&quot;&gt;我们做了很多的实验，实验结果可以表明我们的方法，当扩展到一定程度的时候，这种时间戳的分配是不会成为一个扩展性的瓶颈的。&lt;/p&gt;&lt;p line=&quot;z9Eo&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;降低OCC的阻塞时间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;NxUT&quot;&gt;&lt;/p&gt;&lt;p line=&quot;NxUT&quot;&gt;我们也做了一些OCC的工作。OCC在事务访问数据的时候，就放开让事务去访问，访问完了事务要结束的时候会做一个验证叫Validation，做完验证，再决定这个事务是提交还是回滚。这种方式也是降低事务之间阻塞的一种方法。其实这种事务的最后的正确性验证，有时候会挺耗时间的，所以在这个上面做了一个优化。&lt;/p&gt;&lt;p line=&quot;MNpV&quot;&gt;       &lt;img data-backh=&quot;222&quot; data-backw=&quot;490&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTGMjBGFg13oqsaMoVnOiaDajC6hyxgbicsx6EuzrzLza20RrDL1NYgpKw/640?wx_fmt=png&quot; data-cropx1=&quot;69.13494809688581&quot; data-cropx2=&quot;984.7058823529412&quot; data-cropy1=&quot;145.74394463667818&quot; data-cropy2=&quot;560.553633217993&quot; data-ratio=&quot;0.453551912568306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT1bdVQsckBR8Ju8HYj4lT8dzd9Ek2hcnQAt57moKeT8ufft1AOPdibZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;915&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;OKhI&quot;&gt;       &lt;img data-backh=&quot;239&quot; data-backw=&quot;498&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTF3Jnx0rIU7icUs5L7B9iaTqu217er4xs1V1I17vZRkMicyKEeCQyV5Jqw/640?wx_fmt=png&quot; data-cropx1=&quot;65.39792387543253&quot; data-cropx2=&quot;995.916955017301&quot; data-cropy1=&quot;160.69204152249134&quot; data-cropy2=&quot;607.2664359861591&quot; data-ratio=&quot;0.4806451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTk3p1JJX9UmfBGZpyz3iag84fACL4QeEN6pt8cMtsPp6Mm4kXAVGevdw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;930&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;X1Vz&quot;&gt;我们认为做正确性验证的方式有两种，一种主要的方式叫Local Readset Validation，每个事务把它读过的数据记录下来，最后再去查读过的数据有没有被改动过。这种方式的缺点是当读取的东西特别多的时候，它的代价就会相当的大。&lt;/p&gt;&lt;p line=&quot;X1Vz&quot;&gt;&lt;/p&gt;&lt;p line=&quot;X1Vz&quot;&gt;然后，还有一种方式叫Global Writeset Validation，这种方式就是我不去记录每个事务读过的数据，只记录现在有多少正在运行的事务改动了那些数据，也就是说记录的是那些被改动的数据。然后读的时候，观察它的范围有没有包括改的数据，如果包括了验证就失败。这种方式对读取数据内容比较多的事务是友好的，但对那种小的、短的事务并没有那么友好。&lt;/p&gt;&lt;p line=&quot;Na2V&quot;&gt;       &lt;img data-backh=&quot;230&quot; data-backw=&quot;419&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTmYEHO1U2BHdwsaFYy4tj1mTLcr2Jg1nvWJVRWxYbuGjnofpkEloUNg/640?wx_fmt=png&quot; data-cropx1=&quot;117.71626297577855&quot; data-cropx2=&quot;900.6228373702422&quot; data-cropy1=&quot;145.74394463667818&quot; data-cropy2=&quot;573.6332179930795&quot; data-ratio=&quot;0.5478927203065134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTFic64VB8CIDMfiaX00ZXymENfiaDNQLn2fG6LDGuTuzaXkfM1o4gHzLnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;783&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;rwgq&quot;&gt;所以我们就做了一个叫AOCC，Adaptive OCC，就是把这两种方式给结合起来，我们会判断一个事务的运行情况，如果读取的数据很多，就用Writeset Validation；如果读取得很少，就用Local Readset Validation，这样的话就把两种方式的优点结合起来。&lt;/p&gt;&lt;p line=&quot;ghLQ&quot;&gt;       &lt;img data-backh=&quot;310&quot; data-backw=&quot;342&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTEngputapG24yO7N5fowlNhjSd4kxtepgiaQt83zhMAEzPZVsPtPIlOw/640?wx_fmt=png&quot; data-cropx1=&quot;282.1453287197232&quot; data-cropx2=&quot;921.1764705882352&quot; data-cropy1=&quot;28.02768166089965&quot; data-cropy2=&quot;607.2664359861591&quot; data-ratio=&quot;0.9076682316118936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTQ5w0opBmhq8wxRialVq8I9BYOwyZEeKGwJ3SLhBd9J2xXE6s4I9k4ibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;639&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;ZTaV&quot;&gt;我们做了一些实验，实际上结果确实证明这种方式没有极端的情况的缺陷。因为以前的那种就是读集Receipt Validation和Receipt，德行在在各自的极端情况下都会呈现出特别差的一个性能。但是我们这种方法实际上它是比较均衡的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;跨区域高可用系统的锁时长&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p line=&quot;fwPy&quot;&gt;&lt;/p&gt;&lt;p line=&quot;fwPy&quot;&gt;然后第三个工作也是关于分布式事务的，就是我们做了类似于Spanner这样的系统，跨区域的高可用的系统。&lt;/p&gt;&lt;p line=&quot;8JIn&quot;&gt;       &lt;img data-backh=&quot;213&quot; data-backw=&quot;360&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTjImxGq9yRSAka04d4EFJ470I0Lf01evjiamUusEmJQSX2VF3SkxGqSw/640?wx_fmt=png&quot; data-cropx1=&quot;175.6401384083045&quot; data-cropx2=&quot;848.3044982698962&quot; data-cropy1=&quot;153.21799307958474&quot; data-cropy2=&quot;551.2110726643598&quot; data-ratio=&quot;0.5913818722139673&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT9VSxMwoiaZgAicPKLaL1ADPOwUfo5ANCqNdRVbbxiac98K3VIkMdkibcEg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;673&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;1Pnr&quot;&gt;就像我刚才提到的，一旦加锁，加锁的过程中，出现了跨区域数据的通信，这个持锁的时间就会特别的长。这里是一个例子，在跨区域高可用的系统上做的一个两阶段提交。可以看到红色的线是一个加锁的过程，这个过程已经是在一个正常的事务里面最短的加锁过程了，它是在事务提交开始之前加锁，一直到事务提交完成之后释放锁。&lt;/p&gt;&lt;p line=&quot;1Pnr&quot;&gt;&lt;/p&gt;&lt;p line=&quot;1Pnr&quot;&gt;对一个普通的事务来说，它本身就是要加锁的，但这个加锁的时间可以看到，在加锁过程中，Prepare阶段会有大量的本地节点跟异地节点之间的同步，然后在Commit阶段，同样的也有大量的本地节点跟异地节点之间的同步，这样的一个同步是很耗时间的，如果在这个时间上去做加锁的话，一旦遇到热点的数据访问，这个事务处理的性能就会极度的下降。所以在这样的条件下，我们就想可不可以用提前释放锁的方式去规避加锁，缩短加锁的长度，直接降低阻塞概率。&lt;/p&gt;&lt;p line=&quot;pbK8&quot;&gt;       &lt;img data-backh=&quot;207&quot; data-backw=&quot;356&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTYNrJwdz4SsGEHsgGzYf4GuZkQderzvnq3736ib7jdy8mm3sJQMia1moA/640?wx_fmt=png&quot; data-cropx1=&quot;199.93079584775086&quot; data-cropx2=&quot;865.121107266436&quot; data-cropy1=&quot;145.74394463667818&quot; data-cropy2=&quot;532.5259515570933&quot; data-ratio=&quot;0.581081081081081&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTcQu8vgLsmzk8gctp3IQ4Etuya0ibgBVrBwUyNWvxO9sDZ9iaGUr1rMHA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;666&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;KZN5&quot;&gt;然后我们就设计了叫DLV，LV的意思是Lock Violation，实际上就是提前释放锁。DLV的话我们叫Distributed Lock Violation，同样是一个两阶段提交的一个协议。我们就看在什么地方释放所，它的效率是好的。我们选择了四个时间点：&lt;/p&gt;&lt;p line=&quot;KZN5&quot;&gt;&lt;/p&gt;&lt;p line=&quot;nwpn&quot;&gt;       &lt;img data-backh=&quot;295&quot; data-backw=&quot;426&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTD5BibjO3PnjzlvI0EUvWOnIpt463LcCmkKXyWnUJVYUiaXcbxgbTNicKQ/640?wx_fmt=png&quot; data-cropx1=&quot;205.53633217993078&quot; data-cropx2=&quot;1001.522491349481&quot; data-cropy1=&quot;56.0553633217993&quot; data-cropy2=&quot;607.2664359861591&quot; data-ratio=&quot;0.6922110552763819&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT1zNep73xZpzJkLM1TFk2tQyuPy1xB3sqV9n16BB8HERjk0HsQUbZrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;796&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;491G&quot;&gt;然后我们就实验了这些不同的加锁和释放锁的方式，得到的一个结论，左边这两张图（&lt;span&gt;横轴是远程通信的时长&lt;/span&gt;）说明两个计算机中心离得越远，它通信时间越长，然后用这种传统的方式，会看到时长越长，它的性能就会越差。在高冲突的情况下，分布式事务处理性能就会比较差。但是如果使用提前释放锁的方式，性能就是绿色蓝色的线，表示着它的性能会有一个比较大的提升，这个就说明提前释放锁是有用的。&lt;/p&gt;&lt;p line=&quot;491G&quot;&gt;&lt;/p&gt;&lt;p line=&quot;491G&quot;&gt;但什么时候提前释放锁最合适呢？右边这个图我们做的一个实验最后的结论是第三个时间点就是DLV1x这种方式，协调节点跟事务处理阶段有一个短通信，这个是本地通信，不是异地通信，通信之后确认所有节点都做完了，这个时候释放锁，这样的负面作用是最少的，而且它的加锁时间也会很短，这种方式它的效率是最高的。&lt;/p&gt;&lt;p line=&quot;491G&quot;&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;2.2.2 数据库系统解耦合&lt;/strong&gt;&lt;/p&gt;&lt;p line=&quot;8g8H&quot;&gt;       &lt;img data-backh=&quot;200&quot; data-backw=&quot;498&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTh66fVSNmTowgtKAVv9xPjWeqkbcqtMeGIhTf9pWYZykakGbswOEyEw/640?wx_fmt=png&quot; data-cropx1=&quot;61.660899653979236&quot; data-cropx2=&quot;992.1799307958478&quot; data-cropy1=&quot;156.95501730103805&quot; data-cropy2=&quot;530.6574394463668&quot; data-ratio=&quot;0.40171858216971&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTibH3uL7tQ8cezOwOOZse5tJjiaF9ZzIhWeyHYB6Wc80JQzIicrDRAZGgw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;931&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;cne7&quot;&gt;我刚才介绍了三项研究，都是关于分布式事务处理的，然后我接下来再讲一讲我们在数据库系统解耦上面的一些研究，这也是非常有趣的一个问题。什么叫数据库系统的解耦？实际上教科书会把数据库系统拆成一个一个的模块，比如说这个是collector就是跟应用对接的连接器，还有Query Optimize、Query Evaluator或者叫Query Processor，就是查询处理查询优化的模块，New Storage Manager、New Transaction Manager，还有各种日志、Lock、Manager等等，这个是我们教科书上面对数据库一个模块的切分。&lt;/p&gt;&lt;p line=&quot;cne7&quot;&gt;&lt;/p&gt;&lt;p line=&quot;cne7&quot;&gt;但实际上当我们去真正的看一个数据库系统的实现，就会发现这些模块之间实际上没有切分的那么干净的，而且有时候是实际上模块之间很高耦合的，很紧的耦合在一起。对于一个刚开始做数据库的人会觉得跟我们学的东西会不完全一样。然后很少的人真的去探究为什么会是这样。我们在实现数据库系统的时候，实际上这种高耦合的系统架构给我们带来了很大的困扰。&lt;/p&gt;&lt;p line=&quot;cne7&quot;&gt;&lt;/p&gt;&lt;p line=&quot;4Orv&quot;&gt;我们当时在某银行改那个OceanBase的系统时，改动一个数据类型，我记得好像花了好几个月的时间，很多人去做这个事情。这实际上一听上去会让人比较诧异，但实际上你去看系统的实现，它就是这么回事。一个数据类型好多地方都会用到，必须把每一个地方都清除掉，这个时候就必须花很多时间去读代码去理解去测试的。其实我们觉得如果一个系统的耦合度能够变低，模块之间能够分得很清楚，实际上对系统工程来讲是有很大收益的。&lt;/p&gt;&lt;p line=&quot;4Orv&quot;&gt;&lt;/p&gt;&lt;p line=&quot;4Orv&quot;&gt;我们回顾刚才讲的一个数据库的发展趋势，叫“One size fits a bunch”，也就是说我们认为以后系统会变得很定制化。如果一个系统的模块化做得很好的话，去定制去改动这个系统也会变得很简单。一旦一个新的硬件出现的时候，我们要去使用新的硬件去对这个系统进行优化，会变得更简单。&lt;/p&gt;&lt;p line=&quot;4Orv&quot;&gt;&lt;/p&gt;&lt;p line=&quot;7zIu&quot;&gt;其实一个数据库系统的实现，是有需要去做进一步的解耦合，这里面其实有很多问题。我们去做了一些探索，但其实是非常有限的探索，我觉得这个工作其实可以有更多的人去做。我们做的探索，就是说想把并发控制直接从数据库的存储层抽离出来，然后让存储的代码跟并发控制的代码尽量的互不相关。&lt;/p&gt;&lt;p line=&quot;DOkc&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTD6s9cxJNvTgO3ldo2HcJ3SZHrbibI75OpDWPNGOFK4ChKl7icoZJ8yTA/640?wx_fmt=png&quot; data-cropx1=&quot;276.53979238754323&quot; data-cropx2=&quot;794.1176470588235&quot; data-cropy1=&quot;203.66782006920414&quot; data-cropy2=&quot;397.99307958477505&quot; data-ratio=&quot;0.3745173745173745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTJ8o5uft5AePSpPVrO54qdo8Xr42dfOUMHZiaarAibibh18xI1VHev8hicg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;518&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;KtWr&quot;&gt;这是一个B-Tree的Search Function的例子，在教科书里面，关于B-Tree的Search，你可能会看到这样一个代码，非常简单。&lt;/p&gt;&lt;p line=&quot;nOrD&quot;&gt;       &lt;img data-backh=&quot;263&quot; data-backw=&quot;385&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTG1lTEqWBa3wu7Al8tT6qZXm6hctrfK30FoLUJicaNXhX2Zxb30wgGHw/640?wx_fmt=png&quot; data-cropx1=&quot;188.719723183391&quot; data-cropx2=&quot;908.0968858131488&quot; data-cropy1=&quot;117.71626297577853&quot; data-cropy2=&quot;609.1349480968858&quot; data-ratio=&quot;0.6833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTNoCTDlsAWGacibOniaAglickXiboOD0YdYKZCDlibwal8lYpuwD6jaAzSrg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;wmaq&quot;&gt;但实际上一个B-Tree的Search没有那么简单，可以看到这里面有好多的东西，这还只是一个例子。如果对开源系统比较熟悉的话，一般的一个开源系统的B-Tree，差不多要将近十万行代码，非常复杂。&lt;/p&gt;&lt;p line=&quot;wmaq&quot;&gt;&lt;/p&gt;&lt;p line=&quot;AC2e&quot;&gt;这个代码为什么这么复杂？可以看到B-Tree里面有很多的锁，有比如Latch、Lock之类的很多东西，它实际上是在做并发控制。当然并发控制只是导致代码复杂的原因之一，但还有其他的原因，并发控制把这个代码变得远远的复杂于B-tree本身功能的程度。其实这就是数据库解耦合的一个动机，如果可以把耦合度解开，并发控制可以交给一个单独的模块去做，B-Tree的代码就可以像第一个例子那样写，事情就变得很简单。&lt;/p&gt;&lt;p line=&quot;Hm1Y&quot;&gt;       &lt;img data-backh=&quot;193&quot; data-backw=&quot;432&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTyuWTZKXsK15libXklicxuPice3N4cBF8GTpzMzDaXS3guGCCVvkIdNntQ/640?wx_fmt=png&quot; data-cropx1=&quot;134.53287197231833&quot; data-cropx2=&quot;941.7301038062284&quot; data-cropy1=&quot;164.42906574394462&quot; data-cropy2=&quot;525.0519031141868&quot; data-ratio=&quot;0.44609665427509293&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT5icnEoibNu5kl3W1ASyx1PFZkehSia0MMEiaZYko7YUqCgpibibMV9dGxf0A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;807&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;tI2k&quot;&gt;于是，我们就想如果把CC就是并发控制从数据库这种体系里面解耦出来应该怎么做？有很多种方式，最左边的这种其实是比较传统的方式，这种方式实际上并没有让数据库存储层变得更简单，只是在存储地上面做了一个事务处理层，这是一个比较浅的做法。中间的这种就是一个很暴力的做法，它是在物理的存储上面加一个Transaction Tier，然后在上面做存储做运算。&lt;/p&gt;&lt;p line=&quot;tI2k&quot;&gt;&lt;/p&gt;&lt;p line=&quot;tI2k&quot;&gt;大家应该听说过Transactional Memory，就是事务内存，这种就是直接用事务内存做事务处理，是一种很暴力的方式。最右边是我们提出来的方式，把并发控制的层次分成了两层，一种是我们叫操作层的并发控制，一种是事务层的并发控制，把它们合在一起变成一个新的模块。实践下来肯定是我们这种方式效果明显地更好，这种很暴力的事务内存的方式，实际上性能是不可以接受的。&lt;/p&gt;&lt;p line=&quot;tI2k&quot;&gt;&lt;/p&gt;&lt;p line=&quot;dTrb&quot;&gt;我们其实看到现在有一些做存储的同学，他有一些比较天真的想法，他认为把事务做到存储的最底层，然后上面就不需要关心事务了，实际上那是不行的。事务是跟系统的功能是有很多耦合的因子在里面的，不能完全把它抛弃掉。然后最左边这种方式的结果是不彻底的，实现B-tree的时候还是会挺复杂的。然后我们提出的这种方式，可以清楚的把CC给抽离出来。&lt;/p&gt;&lt;p line=&quot;aDJk&quot;&gt;       &lt;img data-backh=&quot;182&quot; data-backw=&quot;436&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT5iaScYviaz5CQicAAKw8Ak5araOeLKhjiaEfYjnqq8LJPdiacTOHb3jN9Ag/640?wx_fmt=png&quot; data-cropx1=&quot;142.00692041522493&quot; data-cropx2=&quot;956.6782006920415&quot; data-cropy1=&quot;145.74394463667818&quot; data-cropy2=&quot;485.81314878892726&quot; data-ratio=&quot;0.4176904176904177&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTj2oD9s9TpVAsWYCnEI78DfTia2a4Aib6YjiceLztV2OY6icenxMyEiaNDCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;814&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;YSY0&quot;&gt;这个事情其实并不是那么的简单，上面是一个很简单的例子，A和B是两个物理数据，然后在数据库的数据结构里面，定义两个引用（&lt;span&gt;Reference&lt;/span&gt;），A1和A2，B1和B2，A1和A2都是指向A的，B1和B2都是指向B的。上面的事务层实际上是对A1、A2、B1、B2进行访问的。这个时候如果只是通过逻辑层去决定事物跟事物是否冲突的话，是会出错的。因为这里的逻辑层跟物理层，有一个重复引用的关系，可以看到下面这个事务处理的Schedule，从A1、A2、B1、B2这种方式去看，好像这两个事务这样处理是没问题的，它是有这种可串行化的能力的，但实际上并没有，因为A1和A2指向的是同样一个数据。&lt;/p&gt;&lt;p line=&quot;qbXP&quot;&gt;       &lt;img data-backh=&quot;191&quot; data-backw=&quot;505&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTIrNqI2M8waiarCOyicjmWGT3SmJwzzn39jzh1iaY0LqksLxVq899pl3hQ/640?wx_fmt=png&quot; data-cropx1=&quot;67.26643598615917&quot; data-cropx2=&quot;1010.8650519031141&quot; data-cropy1=&quot;160.69204152249134&quot; data-cropy2=&quot;517.5778546712802&quot; data-ratio=&quot;0.37857900318133614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTfLxkDrldBrEGksXbqK8NzJGw7PmPPgGQiaWIheAVgITg7H9icuSY8oZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;943&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;AeH5&quot;&gt;这种实际上就是说如果真的要去把这个事务抽离出来的时候，会有很多的问题需要去解决，我这里没有办法深入地探讨，总之我们做了这样一个尝试，我们叫Transparent Concurrency Control（&lt;span&gt;TCC&lt;/span&gt;），就是透明的并发控制的一种模式。&lt;/p&gt;&lt;p line=&quot;AeH5&quot;&gt;&lt;/p&gt;&lt;p line=&quot;AeH5&quot;&gt;我们把这个事务层抽成两层，一个是事务层次的并发控制，一个是操作层次的并发控制，让这两种东西能够配合起来使用。然后用户去编写程序的时候，他可以不要去关心操作层面的并发控制，他直接去写他的B-Tree就行了。但是写好B-Tree之后，在事务层次上的这种并发控制，需要提供一些语义的信息说明哪种操作跟哪种操作之间实际上是不会冲突的，这样整个事务处理过程就可以保证正确性和高效性。&lt;/p&gt;&lt;p line=&quot;IgJe&quot;&gt;       &lt;img data-backh=&quot;223&quot; data-backw=&quot;460&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTFu2ParAjJVYGdicq6VNEK3zMfIGmKr9wogskpVrKtvTCtEPoLdhwj6Q/640?wx_fmt=png&quot; data-cropx1=&quot;108.37370242214533&quot; data-cropx2=&quot;967.8892733564014&quot; data-cropy1=&quot;134.53287197231833&quot; data-cropy2=&quot;551.2110726643598&quot; data-ratio=&quot;0.48544819557625146&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTmZO81dz21ofCXL2eUSm4LnictVQCa1nwCy0cctkVG5GiblJiahX94jFjw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;859&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;gg5e&quot;&gt;我们做了一些实验，去验证这样的一个解耦。右边的这些图，这种圆圈的线代表原始数据库实现的性能，可以看到我们的方式（&lt;span&gt;TCC&lt;/span&gt;）的性能在很多情况下可以接近原始数据库的性能，这是解耦之后数据库的表现。很多时候解耦之后的表现可以接近原始数据库的性能，所以我们觉得这种解耦实际上还是可行的。但如果真的要把它用到一个现实的系统当中，其实并没有那么简单。这是我介绍的第二个研究工作，就是我们在数据库解耦上面的一些有趣的发现。&lt;/p&gt;&lt;p line=&quot;gg5e&quot;&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;2.2.3 新硬件&lt;/strong&gt;&lt;/p&gt;&lt;p line=&quot;I4N8&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT3kXadsGickTPyKzqNFAfEEUhql9nqXsHmNsxBtZfiajWE0FPLLiaK5ADA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;145.74394463667818&quot; data-cropy2=&quot;568.0276816608996&quot; data-ratio=&quot;0.3907407407407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTOl7dwhA1pr8uBmxvpEeKEBjorTkic4KKgOFd7RgXMb93EWNt24Aqs2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;8RxG&quot;&gt;最后我再谈一谈新硬件，就是这种非易失内存。英特尔的傲腾是现在市面上唯一的一个真正的非易失内存产品，图中是产品的相关指标。对于存储器件的话，我们一般看两个指标，一个是带宽，一个是延迟。&lt;/p&gt;&lt;p line=&quot;8RxG&quot;&gt;&lt;/p&gt;&lt;p line=&quot;8RxG&quot;&gt;可以看到它的带宽和延迟都是远远超过SSD，当然更加超过这种硬盘。它的价格会比SSD和硬盘要昂贵不少，但相对于内存而言，它还是便宜的，我们可以预测它后面会越来越便宜，它跟SSD之间的一个价格的差异会变得越来越小，所以以后它有可能会取代SSD这种固态硬盘，但是不会太早。这种新的存储，它的性能更好，又比内存的造价低，所以它以后在系统当中肯定是有很重要的一个位置的。现在有了这种硬件之后，我们需要讨论在数据库系统里面，这个硬件到底起什么作用，一个新的数据库的架构应该怎么去使用它？怎么定位它的价值和位置？&lt;/p&gt;&lt;p line=&quot;Nt28&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTiavTGlszibXJQiaHyX22JjBuJroHS4uSCXawAsczrUXHeWOMgFC5maJHQ/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;113.97923875432525&quot; data-cropy2=&quot;577.3702422145328&quot; data-ratio=&quot;0.42962962962962964&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTeeiahla1YObFT4AwDtf3TviajIqycVySowAFZ02ib5viaM66qmsM5N3q5A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;JQjv&quot;&gt;我们团队对这个东西讨论了很长的时间，最后有一个这样的设计，首先非易失内存这个东西，当然要用到数据库里面，数据库有各种形态的数据库，不同的形态的数据库使用方式是不一样的，但我们最后把它定位在云的数据库上面，因为我们知道云是未来的最主要的架构。在云的数据库上面怎么去用这个东西，我们觉得它跟RDMA的使用应该结合在一起。&lt;/p&gt;&lt;p line=&quot;u6pT&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTeZSRqaMZhwdfcLibhctwQgA36w32tcFwp23X5FnvRAHiazKW9cErqsXA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;104.63667820069203&quot; data-cropy2=&quot;554.9480968858131&quot; data-ratio=&quot;0.41759259259259257&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTQXicvm7z9ZHqic2zuZmVtKkbmzXgzcZ6XfCUs1hEtQjNXib1G2XwwsdvA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;8Olk&quot;&gt;现在的云数据库变成一种计算节点跟存储节点是相对分开的架构方式。然后一旦NVM加进来之后，我们希望它成为计算节点跟存储节点之间的一个缓存。我们觉得现在暂时不能用它来做全量数据的存储，因为它的价格实在是比较昂贵，很多冷的数据，完全没有必要存在这样昂贵的存储里面，所以它作为一种缓存，比较合适的。&lt;/p&gt;&lt;p line=&quot;8Olk&quot;&gt;&lt;/p&gt;&lt;p line=&quot;8Olk&quot;&gt;另外一方面，它作为一个缓存，不应该是一个割裂的节点，因为我们去看它的性能指标，可以看到实际上这种非易失内存的吞吐、延迟，和在高速网络上的RDMA的吞吐和延迟是比较接近的。如果比较接近的话，这个器件是通过RDMA的远程去访问，还是通过本地访问的速度差异有可能并不会很大。如果这个速度的差异并不会很大的话，我们实际上是可以把多个节点的NVM联合在一起，作为共享的缓存，缓存共享有非常多的优势，省去了很多缓存数据同步的代价，然后还可以让系统的负载均衡变得更好。&lt;/p&gt;&lt;p line=&quot;8Olk&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;8Olk&quot;&gt;&lt;span&gt;我们决定去设计这样一个系统架构。这个是NVM，我们叫存储节点和计算节点之间的一个缓存。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;gQEX&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTZoPoEQ56kVOic5vsKO1QBapAFsqQAuaFcXHTlw4bm51DbesfRd6ichrw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;102.76816608996539&quot; data-cropy2=&quot;562.4221453287197&quot; data-ratio=&quot;0.42592592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTuAr5RrEfaukqKBEC3nSCLAnVoGG5uNhrFe4piaVTBsiaKkWaEoNzPrwA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;span&gt;       &lt;/span&gt;&lt;img data-ratio=&quot;0.5632682574114244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTbhFb6ib4MKMlvTzrbF3kMdyAlnVZA8WnRSNwFdnDJwG9ZopViauuHiczw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1383&quot;/&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;vf9m&quot;&gt;我们这个事情正在做的过程中，所以目前为止我们是实现了一个分布式的缓存，可以作为共享缓存来用。我们开始讨论它应该是作为数据库而言，是行级别的缓存还是块级别的缓存，最后我们的选择是块级别的缓存，主要的原因还是因为实现起来更简单。我们先试一试，如果做到行级别的缓存的话，是有很多的工作量的，我们后期可能还会去尝试。&lt;/p&gt;&lt;p line=&quot;7vV5&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTT0VaGiawEjNpibdHn3TINOIVxBNyRSR3AuzpcytEGREf9lGkQJZyBEWA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;100.89965397923874&quot; data-cropy2=&quot;607.2664359861591&quot; data-ratio=&quot;0.46944444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTzE8VdQ9gXZ4iacUMK4wSian43eWU3H7ttMpqmENnkWWftYWaJeCbCeKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;2G3d&quot;&gt;然后缓存的基本的测试，我们觉得我们的实现基本已经到位了，就是它的带宽的瓶颈基本上压到了RDMA访问带宽的瓶颈，如果要对它进行读写的话，它的瓶颈基本上就是RDMA远程访问的瓶颈，然后它的性能是远远高于像Redis这样的一个系统的，我们希望用这个缓存把它放在数据库里面，去提升这种云数据库的一个性能，但这个过程我们还在实现当中，我们有一些初步的结果，它是有一些效果的，特别是面对底层是SSD或者磁盘这样的系统的时候。我们希望后面有更明确结果的时候，再给大家介绍。&lt;/p&gt;&lt;p line=&quot;2G3d&quot;&gt;&lt;/p&gt;&lt;p line=&quot;ulnt&quot;&gt;&lt;span&gt;&lt;strong&gt;03 相关论文列表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;ZP2M&quot;&gt;       &lt;img data-backh=&quot;253&quot; data-backw=&quot;578&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTiawGPRfk7oF9ywo26L2qTiaDFy1JY5F93jjYQva4Lib8W10KgqLoibDsKw/640?wx_fmt=png&quot; data-cropx1=&quot;74.14925373134328&quot; data-cropx2=&quot;1005.8507462686567&quot; data-cropy1=&quot;157.78988441434143&quot; data-cropy2=&quot;563.5353014797909&quot; data-ratio=&quot;0.4371643394199785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTkXQ4WA6eNWibiaF6qKL6vgNxib9THIRXeY3xHRoeT0M0k2AEq7yGibD9cQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;931&quot;/&gt;&lt;span&gt;这是我们实验室的一些代表性论文，不是很全，我刚才讲的部分技术并不在列，因为还没有公开发表。如果感兴趣的话，大家可以阅读一下。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;ZP2M&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;ZP2M&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;写在后面&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;ZP2M&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;华东师范大学周烜教授也是2020-2021年度美团科研课题合作学者。当前美团技术团队与超过30位来自国内外高校和科研院所的学者建立了科研课题合作。美团科研合作计划，基于美团在生活服务领域全场景里提炼出的科研命题，面向学术界征集前沿解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们致力于与学术界“一起解决真实世界的问题”，愿与学术界共同推动产学研成果落地。2021年将更加精彩纷呈，敬请期待。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;ZP2M&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;----------  END  ----------&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;也许你还想看&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;| &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651753413&amp;amp;idx=2&amp;amp;sn=b121efdbbed54888f59a61fbcf7a7301&amp;amp;chksm=bd1252888a65db9e6a89e772298827fc302e22b6f84d17e9fa60c3bbe384e3988a9061920126&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;美团内部讲座｜清华大学莫一林：信息物理系统中的安全控制算法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651753855&amp;amp;idx=2&amp;amp;sn=3032c8c0904fd8924fd8b8a0c71a5a6d&amp;amp;chksm=bd1254328a65dd2428955ee261ccc5a838ef7a1dbf5d920fc42dfebd7eff0748dea35429bf66&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;美团内部讲座｜北航全权：一种城市空中移动性管理分布式控制框架&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;| &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651753413&amp;amp;idx=3&amp;amp;sn=580964919c613404f35864205ff69ed9&amp;amp;chksm=bd1252888a65db9eafea57ec18d9abc7a11de6bf30446c4beb7a21f37a0377633864355fc32c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651753413&amp;amp;idx=3&amp;amp;sn=580964919c613404f35864205ff69ed9&amp;amp;chksm=bd1252888a65db9eafea57ec18d9abc7a11de6bf30446c4beb7a21f37a0377633864355fc32c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;喜讯！美团-清华大数据课程对外开放啦！&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;560&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;249&quot; data-ratio=&quot;0.44533333333333336&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUrXicw2VXTQTVVN5yxXWEacsJ3aFxXFol84VVW89JYtgorr2aQnLz2YzwrVicCFXS7hEPGWvVJ6LWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1875&quot;/&gt;&lt;/p&gt;&lt;p line=&quot;ZP2M&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7185f385817be0ab117714f321551cda</guid>
<title>人生是一个回环：我的十年安全工作总结</title>
<link>https://toutiao.io/k/41asxjm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section&gt;&lt;span lang=&quot;EN-US&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5462962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kYREiceLybrhgkMKyuu37uUVDzG87Djz0ZOiba8GWhwy50bd2TnMiciaxhDukaC2PLhjia0OiaxawY2oK9JibKtA9F8fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;“大家好！&lt;/span&gt;&lt;span&gt;我是李雪琴……”，自去年起，那个北大毕业的“最土”女生火了。&lt;/span&gt;&lt;span&gt;近期，听到她在脱口秀大会讲她妈妈的“哲学”理论：&lt;/span&gt;&lt;span&gt;宇宙也有终点，终点在人生的起点；&lt;/span&gt;&lt;span&gt;看到她先从“人生的起点”来北京赴学，再回到“人生的起点”，这次又离开起点出来闯荡。&lt;/span&gt;&lt;span&gt;心里颇有感触，在“宇宙终点”之前，显然她的脚步还远没有停止。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;我的人生回环&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;大家好！我是叶猛，我又回到了北京，跟北京说声：“嗨！”。这次我用了自己的真名字。在这个名字之前，我还有一长串的昵称或称呼：梦晔、Monyer、梦之光芒、猛子、小叶、叶队、叶帅、叶师傅、叶支、猛队……，这些称呼伴随着我前十年工作生涯的各个阶段。梦晔是我的笔名，是我姓名的倒序，在那个年少轻狂且心中“文意纵横”的时代，看到老舍把自己的姓拆开做字，便有学有样起了这个笔名。Monyer是从梦晔的发音造出来的英文昵称，从高中起一直用到现在。梦之光芒是从梦晔拓展出来的中文昵称，因为“晔”就是光芒的意思。这个中文昵称先是从05年起作为《黑客防线》的投稿笔名，后是作为百度空间的博客名一直到空间关闭。猛子这个昵称主要是刚毕业后在B公司工作，大哥大姐们的亲切称呼；小叶是后来特招到某省公安厅后，领导们的“爱称”；叶队是在公安厅任某科室支队长后，兄弟单位及合作伙伴的称呼；叶师傅、叶帅是省厅同事间的敬称和戏称；叶支、猛队是来到Q公司后，组建起国内顶级实战攻防红队，大家的敬称。关于我的称呼曾有过很有意思的事情，曾有不少人认识网上的Monyer还加了QQ好友，也认识现实中的叶队，但却不知道这是一个人。所以今天我用我的真名字为自己代言，也算是第一个回环吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;听到宇宙的终点是人生的起点，我不禁莞尔，因为我也感觉人生是一个回环。称谓上的回环暂且不论，最近十年我又进行着另两个回环：一是从网络安全的甲方到监管方，再到乙方，又回到了甲方的回环；二是从沈阳到北京，到回沈阳，又回到北京的回环。我爱人说：你看你，兜兜转转，又转回去了。我说不然，虽然又转回去了，但能力变了、眼界变了、境遇也变了。如果用一个恰当的比较，这不是一个简单的循环，而是一个如同莫比乌斯带般的回环，虽然转了整整一圈，但已经站在了环的另外一面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近在和不少老板聊天时，都谈到了我的网络安全从业经历，也因此有了更多的感触。回顾是为了沉淀和畅想，总结是为了把握未来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我的职业生涯从不同角度来看，算是既简单又惊奇。简单的原因是十余年工作经历全部是跟网络安全相关的，并且一共也只有3个东家。惊奇的原因则是恰好这3个东家覆盖了整个安全届的角色划分：甲方、监管和乙方，而且朋友同事听到我离开消息后，是一个比一个惊奇。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么？离开北京大公司回辽宁了？……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么？公安厅支队长都不干了？……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么？要抛家弃子回北京了？……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0462016881386051&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kYREiceLybrhgkMKyuu37uUVDzG87Djz0OH4icfUY9ibxSfXCdVCByKL80PA3hYJAp54q5L4AVCmX5E49BRxvp75g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2251&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（当别人告诉我，我的离职上了热门讨论，让大家震惊了一下，我还有些忍俊不禁。）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;甲方时代：安全是为业务服务的&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如果用一句话来总结我甲方的工作经验，那就是：“安全是为业务服务的”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实去B公司是有着偶然因素和侥幸成分的。在去之前A公司曾邀请我去面试，不过去跟导员请假没有申请下来，就作罢了。等B公司找到我时，恰逢暑假，遂商定好只做暑期实习生。不过实习期间，所在团队给我很大触动，那是一个高效、团结、热情、专业的团队，值得我继续实习下去。于是我跟学院做了申请，整个大四都是在B公司度过的，顺利拿到Offer，毕业后的两年也一直在B公司。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我所在部门是当时处于创业状态下的电商团队，职位最开始是渗透测试工程师，主要是代码和业务层面的安全工作，前期一直是我一个人。那时敏捷开发还在尝试阶段，DevOps更是影儿都没有。系统还是版本制，上线时需要在半夜进行，停服维护。期间比较有意思的事儿是协助架构师做MVC 2.0框架设计，通过框架和系统架构天然防御常见漏洞，当然现在很多开源的MVC框架也都内置了安全防护功能。后来11年部门拆分，便到了基础平台架构部，负责公司产品线的安全测试、代码审计以及安全内训工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在工作中也慢慢发现，随着安全从业者能力的提升，在掌握更多安全知识和理念的过程中，很容易陷入脱离业务过度防御的误区。有时安全人员会有种系统到处都是漏洞无从下手的感觉，甚至认为系统功能的本身就是漏洞。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Feature还是Bug这是一个问题！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这有点像我之前在知乎上回答的一个问题：某公司的安全人员认为手机验证码一定要是6位以上的，产品经理认为从易用性角度上一定要是4位的，于是就闹了很多矛盾。然而4位的验证码就一定不安全么？就没有更好的解决办法么？想当年支付密码必须要数字+大小写字母+特殊字符，要大于10位以上。而现如今，几乎所有支付应用的密码全部是6位纯数字，那么安全性是提升了，还是下降了呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;安全是为业务服务的。脱离了业务本身去谈安全是没意义的，过度强调安全而忽视了业务可用性也是无稽之谈。不考虑系统架构和网络运行情况，生搬硬套各种先进安全理念和安全框架，会浪费大量资源又达不到预期效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，这并不是说安全要无限制地为业务让路，而是说安全人员要时刻思考如何在尽量保证业务的前提下，去维护系统安全，要考虑安全与业务共生的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;皮之不存，毛将焉附？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;监管时代：技术是达成目标的一种手段&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如果用一句话来总结我在网络监管单位的工作经验，那么就是：“技术是达成目标的一种手段”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当时一些客观原因和机缘巧合，使我于11年底通过公务员特殊人才招募通道来到某省公安厅网安总队工作，一直到18年初离职为止。由于敏感性原因，工作内容暂且不谈。但这些年个人的成长和进步还是蛮大的，最重要的是在做人上有了长足的提高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用技术去辅助公安工作，可以起到四两拨千斤的效果。我举个的例子：譬如某舆情事件，领导的想法是通过统计分析得出关键线索。但统计分析的前提是数据的获取、处理、存储、分析和展示。随着事件的持续性发展，如果纯人工去做，那么投入成本会是时间线性增加的，甚至会出现人工分析赶不上事态发展速度的情况。而通过程序去做，则可以在更短的时间内获得更好的结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是不是说技术就永远比传统手段更好用呢？也不尽然。从另外一个例子来看：如果拿到了犯罪嫌疑人的手机，还在想着用技术手段去破解开机密码，就没有那些公安老哥们直接从嫌疑人口中撬出密码来的方便。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然我只举两个很简单也不那么敏感的例子，实际上在这近7年的工作中，上百场战役和案件的侦办给我留下很深刻的认知：就是“技术是达成目标的一种手段”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网安的成功破案并不是在我们这种技术人员招进来后才有的，只不过我们给了网安多一种选择，有时则是一种更短的路径。而在工作中，包括体制内、甲方和乙方，也不应该总从纯技术角度去考虑问题，有时换一种思路会发现有更快更容易的解决途径。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;乙方时代：打铁必须自身硬&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如果用一句话来总结我在乙方的工作经验，那么就是：“打铁必须自身硬”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Q公司是目前网络安全toB领域的佼佼者。18年初我来Q公司时，它还没有自己的专业化红队。一些实战攻防演习任务的承接还要靠抽调各地渗透测试人员临时组队，人员战斗力以及演习排名均得不到保障。入职时，我在主管副总裁的引荐下，带着一个题为《专业化渗透团队可行性研究分析》的团队规划PPT赶赴北京见到了董事长。里面讲的就是要建立一支高精尖、能打胜仗的专业化渗透团队。汇报比较顺利，董事长最终同意给我5-6个HC来建设这样一支团队。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为这个团队主要是模拟黑客APT手段来开展工作业务，因此我从APT“高级持续性威胁”这个名词中借用了“高级”二字，从零开始组建了“高级攻防部”网络攻防实战团队。在团队建设过程中，我借鉴了体制内团队建设管理经验，以“队”为建制来组建红队，把每支红队的管理者称为“队长”，队内员工称之为“队员”，红队按区域做命名，譬如“成都队”、“南京队”、“沈阳队”、“杭州队”等。在接下来的两年中，队伍一直在向着最高效、最专业化的道路迈进。建设过程含辛茹苦暂且不谈，现如今高级攻防部已经是一支横跨全国三个大区，人数超过*0人的专业级红队，攻击队数量也从0增长到*支。每次工作任务都以攻击队为单位来开展，类似于特种部队中的作战单元。一支攻击队由*-*个人构成，以攻击队队长为技术及领导核心，团队成员各具打点、社工、内网等不同方向本领，大家协同作战。正如任正非所言：要把能力建立在组织上。这样的团队组成模式对于实战攻防演习及红队评估项目来说是最有战斗力的。我统计过去年（2019年）的全年实战演习项目，我们排名第一次数是76%，排名第二是24%（第三及以后没有），综合作战能力已经远远将友商团队甩到了后面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在部门的成长和管理过程当中，技术是我们的饭碗、能力是我们的本钱、排名是我们的荣誉。团队成员在技术能力、带队能力以及声望名气上均日新月异，长足提高。我们没有设立任何类似于996的工作制度，也不树立任何“舍己为人”的典型，但在项目中所有人都勇于吃苦耐劳、加班熬夜、奋战到底，因为大家都知道“打铁必须自身硬”，自身硬就是本钱，就是底气，就是话语权，是谁都拿不走的资本。前些日子，团队中某个毕业2年带队1年多的攻击队队长被某大型合资公司以高年薪挖走了，去做安全防护方面的负责人，还给配车。在不舍的同时，我也感到十分欣慰，有着沉甸甸的满足感，感觉团队没白带，人没看错也没白培养。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多管理者怕人员流动，其实正常的人员流动对于团队和个人都有着好处。对于团队所有人员，我一直在宣贯着我称之为“技术人员发展四阶段”的成长路线：技术输出、经验输出、思路输出和决策输出（这个上一篇公众号也有详细地说明）。我希望从我团队走出的技术人员能成为外面的技术Leader，技术Leader能成为外面的技术经理，技术经理能成为技术总监。在日常的团队管理中，我也会尽量为大家提供能够向下一阶段发展的舞台和平台，给大家锻炼成长的机会。我认为这样的团队氛围才是健康的，对于团队成员来说才是负责任的，这也是自身硬的表现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;坚守梦想，持续奋斗&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;最近“刘备”那段“接着奏乐，接着舞”火了，然而在这个梗之前“刘备”说了一句话：“我打了一辈子仗，就不能享受享受吗？”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以享受吗？当然可以！然而梦想达成了吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于刘备来说，没有！对于我来说，也没有！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么就远没有到可以享受的时候。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在机关单位后期的安逸并不是我想要的。很多人打破脑袋想要进机关，捧着铁饭碗“混机关”。但对我来说混的不是机关，混的是自己。铁饭碗不应该是某个单位，应该是自己的能力和本事。不能靠“混”的施舍，因为混着混着就到达“宇宙的终点”了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在乙方团队建成后的功成名就也不是我期望的状态。临走前有个大哥劝我说：如今团队已经建起来了，最难的时候都过去了，接下来可以养老了，只要大差不差干一干，可以活得比很多人都好。他说的都是真心话，我也都想到。但我还有追求，还想发展，还想做更多，还想做得更好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正如最近这个段子：“看到74岁与77岁的两个老人为了一份工作还争吵这么激烈，你的人生还有什么借口不努力呢？”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，我的人生又经历了这一次回环：我又从乙方回到了甲方，我又从沈阳回到了北京。虽然岗位在变，城市在变，但奋斗的心没变。在接下来工作中，持续奋斗还是会贯穿我工作的始终。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;仅以此文作为第一个十年工作的总结，也作为接下来工作的自勉吧！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;感谢爱人的理解，朋友的支持！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也感谢屏幕前您的传阅，谢谢！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>