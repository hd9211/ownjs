<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>59c01526d57395228d80f47c441110a6</guid>
<title>为什么放弃 Kafka，选择 Pulsar?</title>
<link>https://toutiao.io/k/wxrneux</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心、分布式配置等常用开源组件，大概有几十篇文章，陆续会开放出来，感兴趣同学请提前关注&amp;amp;收藏&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Pulsar 介绍&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 是 Yahoo 在 2013 年创建的，2016年贡献给了 Apache 基金会，目前已经是 Apache 的顶级项目。Yahoo、Verizon、Twitter 等很多公司都在使用 Pulsar 来处理海量消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 声称比 Kafka 更快、运行成本更低、解决了很多 Kafka 的痛点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 非常灵活，可以像&lt;code&gt;Kafka&lt;/code&gt; 一样作为分布式日志系统，也可以作为类似&lt;code&gt;RabbitMQ&lt;/code&gt; 这类简单的消息系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 有多种订阅类型、传递保障、保存策略。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;特性&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同的团队可以使用同一个集群，互相隔离。支持隔离、认证授权、配额。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 使用特定的数据层来存储 topic 数据，使用了 Apache BookKeeper 作为数据账本。Broker 与存储分离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用分隔机制可以解决集群的扩展、再平衡、维护等问题。也提升了可用性，不会丢失数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为使用了多层架构，对于 topic 数量没有限制，topic 与存储是分离的，也可以创建非持久化的 topic。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 中存储是很昂贵的，所以很少存储冷数据。Pulsar 使用了多层存储，可以自动把旧数据移动到专门的存储设备，例如 Amazon S3，但是对于客户端来讲是透明的，还可以正常使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar Function 是一种部署简单，轻量级计算、对开发人员友好的 API，无需像 Kafka 那样运行自己的流处理引擎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内置了代理、多租户安全机制、可插入的身份验证等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;partition 被分为了小块儿，所以再平衡时非常快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 Kafka、RabbitMQ 等系统都可以轻松集成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 Go、Java、Scala、Node、Python 等等&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么选择 Pulsar&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前业界使用比较多的是 Kafka，主要场景是大数据日志处理，较少用于金融场景。RocketMQ 对 Topic 运营不太友好，特别是不支持按 Topic 删除失效消息，以及不具备宕机 Failover 能力。选 Pulsar 是因为其原生的高一致性，基于 BookKeeper 提供高可用存储服务，采用了存储和服务分离架构方便扩容，同时还支持多种消费模式和多域部署模式。Kafka、RocketMQ 和 Pulsar 的对比如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7586705202312138&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXLb8xCP32L8huVaUIW7nm3GfctVQTmqQrKEEKOp1PxibWnCDgbzAhleXsmaY4F807U3iaMJveRPSdqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;692&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Show me the code&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;外部依赖：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 pom.xml 中添加 Pulsar 依赖：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.apache.pulsar&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;pulsar-client&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;2.4.0&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;配置文件：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在配置文件 &lt;code&gt;application.yaml&lt;/code&gt;中配置 Pulsar 的相关参数，具体内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pulsar:&lt;br/&gt;  service:&lt;br/&gt;    url: pulsar://127.0.0.1:6650&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Producer 发送消息：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产端提供了一个restful接口，模拟发送一条创建新用户消息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Long id = Long.valueOf(new Random().nextInt(1000));&lt;br/&gt;User user = User.builder().id(id).userName(&lt;span&gt;&quot;TomGE&quot;&lt;/span&gt;).age(29).address(&lt;span&gt;&quot;上海&quot;&lt;/span&gt;).build();&lt;br/&gt;userPulsarMsgProducer.send(user);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内部通过 &lt;code&gt;@PostConstruct&lt;/code&gt; 在应用启动时，初始化&lt;code&gt;org.apache.pulsar.client.api.Producer&lt;/code&gt;实例，并交由spring 容器统一管理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public void send(T msg) {&lt;br/&gt;    String msgBody = JSON.toJSONString(msg);&lt;br/&gt;    try {&lt;br/&gt;        MessageId messageId = producer.send(msgBody.getBytes(StandardCharsets.UTF_8));&lt;br/&gt;        log.info(&lt;span&gt;&quot;pulsar msg send success, topic:{}, messageId:{}, msg:{}&quot;&lt;/span&gt;, getTopic(), messageId, msgBody);&lt;br/&gt;    } catch (Throwable e) {&lt;br/&gt;        log.error(&lt;span&gt;&quot;pulsar msg send failed, topic:{}, msg:{}&quot;&lt;/span&gt;, getTopic(), msgBody);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Producer 发送延迟消息：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适用于一些有&lt;code&gt;延迟处理&lt;/code&gt;要求的业务场景，比如电商交易的&lt;code&gt;自动确认收货&lt;/code&gt;，在卖家发出货品后，有15天的观察期，这期间如果买家没有发起逆向流程/申请退款，将会由系统自动触发&lt;code&gt;超时确认收货&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同业务场景，设定不同的延迟时间值，可以让消费端在延迟指定时间后才能拉取到消息并进行消费。借助于该框架特性，有效节省开发成本和难度。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;producer.newMessage().deliverAfter(delay, unit)&lt;br/&gt;        .value(msgBody.getBytes(StandardCharsets.UTF_8))&lt;br/&gt;        .send();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Consumer 消费消息：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统启动时，自动创建consumer消费实例，并埋入&lt;code&gt;org.apache.pulsar.client.api.MessageListener&lt;/code&gt;接口实现，用于具体的消息消费处理逻辑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@PostConstruct&lt;br/&gt;void init() throws PulsarClientException {&lt;br/&gt;    consumer = client.createConsumer(getTopic(), getSubscriptionName(), new DefaultJsonMsgListener());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt; class DefaultJsonMsgListener implements MessageListener&amp;lt;byte[]&amp;gt; {&lt;br/&gt;&lt;br/&gt;        @Override&lt;br/&gt;        public void received(Consumer&amp;lt;byte[]&amp;gt; consumer, Message&amp;lt;byte[]&amp;gt; message) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (null != message &amp;amp;&amp;amp; null != message.getData() &amp;amp;&amp;amp; message.getData().length != 0) {&lt;br/&gt;                String msgBody = new String(message.getValue(), StandardCharsets.UTF_8);&lt;br/&gt;&lt;br/&gt;                log.warn(&lt;span&gt;&quot;topic:{} receive message:{}&quot;&lt;/span&gt;, getTopic(), msgBody);&lt;br/&gt;                try {&lt;br/&gt;                    T msg = JSON.parseObject(msgBody, clazzT);&lt;br/&gt;                    handleMsg(msg);&lt;br/&gt;                } catch (Exception e) {&lt;br/&gt;                    log.error(&lt;span&gt;&quot;handle msg failed, topic:{}, message:{}&quot;&lt;/span&gt;, getTopic(), msgBody, e);&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            try {&lt;br/&gt;                // 提交消费位移&lt;br/&gt;                consumer.acknowledge(message);&lt;br/&gt;            } catch (PulsarClientException e) {&lt;br/&gt;                log.error(&lt;span&gt;&quot;topic:{} ack failed&quot;&lt;/span&gt;, getTopic(), e);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2&gt;&lt;span&gt;演示代码地址&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;https://github.com/aalansehaiyang/spring-boot-bulking  &lt;br/&gt;&lt;br/&gt;模块：spring-boot-bulking-pulsar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9f3cf9678bb7065369cffe0483b71728</guid>
<title>协程切换会引起什么问题</title>
<link>https://toutiao.io/k/xkhaihd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;post&quot;&gt;
&lt;p&gt;在微信的业务中协程被大规模应用，在使用的过程中遇到了一些和业务场景相关的问题。本文自下而上从 CPU 中断到 Linux 内核态、再到用户态进程、最后到协程，由这种视角去分析协程切换时引起问题的原因，希望可以更好地理解协程。&lt;/p&gt;

&lt;p&gt;计算机里有两类大的资源：CPU 资源和 IO 资源。计算型的任务主要消耗 CPU 资源，比如对字符串进行 base64 编码，我之前遇到 3W/min 的线上接口加了 base64 编码把 CPU 跑满；输入输出类的系统调用主要消耗 IO 资源，部分 IO 和硬件中断相关。CPU 芯片引脚上接入了很多控制芯片，比如中断控制器芯片 8259A。当键盘打字，中断芯片触发 CPU 上的硬件中断，CPU 被调度来处理键盘输入。&lt;/p&gt;

&lt;p&gt;计算机上有这么多的任务需要消耗 CPU 和 IO 资源，操作系统怎么去优化资源利用呢？&lt;/p&gt;

&lt;p&gt;对于计算密集型任务，可以用多进程/线程将任务分发到不同的 CPU 核上并行处理来提高效率；对于 IO 密集型任务，操作系统已经有中断回调机制，对于正在到来的 IO 事件进行处理。&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;中断机制&quot;&gt;中断机制&lt;/h2&gt;

&lt;p&gt;外围硬件设备连接到中断控制器芯片上，产生的电信号经过中断控制器芯片编码后写到 CPU 的控制寄存器中。那 CPU 怎么知道寄存器发生了改变？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当执行了一条指令后，cs 和 eip 这对寄存器包含了下一条将要执行的指令的逻辑地址。在处理那条指令之前，控制单元会检查在运行前一条指令时是否已经发生了一个中断或异常，如果发生了一个中断或异常，那么控制单元执行下列操作 ——「深入理解 linux 内核」&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是 CPU 在每个指令周期都会去查看中断寄存器，这是硬件级别的轮询。用这种轮询来实现了中断控制，这种中断回调存在于内核态。&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;操作系统之上再造系统&quot;&gt;操作系统之上再造系统&lt;/h2&gt;

&lt;p&gt;业务的进程中，既需要使用 CPU，又需要使用大量 IO。怎么去优化这种场景？&lt;/p&gt;

&lt;p&gt;在进程中再开线程？在线程中出现 IO 调用时（主要讨论同步 IO，Linux 中还没有完善的异步 IO），让线程睡眠，让其他的线程去处理任务。假设现在 8 核 CPU 上有 4 个进程，每个进程开 10 个线程，理论上也只能同步并行跑 8 个线程，其他线程都是假性的并行运行。如果这时出现大量的阻塞 IO 调用，所有的线程都会进入睡眠，等待同步 IO 的数据返回；如果是非阻塞 IO 调用（O_NONBLOCK），使用 poll/epoll 来轮询事件到来，虽然不会进入睡眠，但线程不断从内核态到用户态的上下文切换效率较低。&lt;/p&gt;

&lt;p&gt;有什么办法可以让用户态的进程/线程中拥有一种异步回调的能力，在发生 IO 调用时切换到其他进程/线程，又能保证不睡眠进入内核态。在 IO 事件到来时，再切换回这个进程/线程，整个过程都是在用户态完成。这相当于在操作系统上重新造了一个操作系统来进行进程/线程调度，梦境之上再造梦境。&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;协程是什么&quot;&gt;协程是什么&lt;/h2&gt;

&lt;p&gt;想象一个人进入到进程中，现在有两个子函数：一个函数负责倒开水，一个函数负责晾衣服。当人看到开水烧开了，调用函数去倒开水；当看到衣服洗好了，调用函数晾衣服。这个人就是程序员本人，他来负责子程序的调度。子程序就是协程，这个人就是程序员本人，可以看作是人肉协程调度器。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Huangtuzhi/ucoroutine/blob/master/ucoroutine.cpp&quot;&gt;ucoroutine&lt;/a&gt; 是一个协程调度的示例，使用 Linux getcontext、makecontext、swapcontext 函数簇来实现协程切换。&lt;/p&gt;

&lt;p&gt;那么人肉调度器可以由什么来自动化替代呢？这个调度器需要实现这些功能&lt;/p&gt;



&lt;p&gt;比如对于网络应用场景，hook 掉 socket 簇 read、write、connect、send、recv 函数，让这些函数调用时发生用户态协程切换，同时记录下相应的上下文信息&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;加入异步回调机制，在 IO 事件到来时回调到事件对应的处理协程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个东西是不是可以用 epoll 实现？在 IO 调用时把事件注入到 epoll 事件池，同时发生协程切换，等 IO 事件到来时由主协程用 epoll 去回调切换到对应的协程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void ucoroutine_body(schedule_t *ps)
{
int id = ps-&amp;gt;running_coroutine;

if (id != -1) {
ucoroutine_t *t = &amp;amp;(ps-&amp;gt;coroutines[id]);
t-&amp;gt;func(t-&amp;gt;arg);
// 模拟函数阻塞，进行调度。在这里将事件注入到了 epoll 中即可
puts(&quot;before yield&quot;);
ucoroutine_yield(*ps);
puts(&quot;after yield&quot;);
t-&amp;gt;state = IDLE;
ps-&amp;gt;running_coroutine = -1;
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就实现了用户态的操作系统。&lt;/p&gt;

&lt;p&gt;常见的协程库实现有三种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用 glibc 的 ucontext 库&lt;/li&gt;
  &lt;li&gt;使用汇编代码切换上下文，微信 libco 使用这种方式&lt;/li&gt;
  &lt;li&gt;利用 C 语言的 setjmp 和 longjmp&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些方式的原理都是通过保存和恢复寄存器的状态，来进行各协程上下文的保存和切换。&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;切换引起的问题&quot;&gt;切换引起的问题&lt;/h2&gt;

&lt;p&gt;在使用 libco 时，已 hook 掉所有的 socket read/write/send/recv 系统调用，在发生这些系统调用时，libco 会切换协程，将当前的上下文保存，切换到其他协程使用 CPU。所以在业务代码中发起 RPC 调用会触发协程切换，这种切换会引起一些问题。&lt;/p&gt;

&lt;h4 id=&quot;问题-1幻读&quot;&gt;问题 1：”幻读“&lt;/h4&gt;

&lt;p&gt;最近在进行一个项目的改造，有这样一段代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;m_config = config; // 进程变量
m_config-&amp;gt;cmdid() = 100; // 这个值根据请求不同会变化

id_a = m_config-&amp;gt;cmdid()
CallRPC()
id_b = m_config-&amp;gt;cmdid()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个代码段有多个协程共用，最后发现 id_a != id_b，出现了”幻读“问题。&lt;/p&gt;

&lt;p&gt;这是因为 CallRPC 时会发生协程切换，等再次切换回来，cmdid 已经被其他协程修改了。&lt;/p&gt;

&lt;p&gt;使用协程原则：全局变量和静态变量为所有协程共享，不要使用全局变量，静态变量。&lt;/p&gt;

&lt;h4 id=&quot;问题-2死锁&quot;&gt;问题 2：死锁&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NoticeConfig::NoticeConfig()
{
CallRPC();
}

NoticeConfig* NoticeConfig::GetDefault()
{
static NoticeConfig conf; // 卡在这里
return &amp;amp;conf;
}

func()
{
auto conf = NoticeConfig::GetDefault();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;协程 A 中 func 调用 GetDefault 获取单例，GetDefault 中初始化 conf 时，构造函数调用了 RPC 发生了协程切换，CPU 让给协程 B。而对于 static 变量，gcc 在构造时会加锁，所以 A 获得了这把锁。当协程 B 调用 func 时，conf 还没初始化完成，会尝试再次加锁。所以其他协程都会卡死在这里。&lt;/p&gt;

&lt;p&gt;这种场景出现需要满足两个条件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;构造函数中加了 RPC 操作&lt;/li&gt;
  &lt;li&gt;用 static 来实现单例&lt;/li&gt;
&lt;/ul&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;从上面的分析可以知道协程的使用场景&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;频繁发生 RPC 调用，可以最大程度使用协程的能力。相比线程节省系统资源&lt;/li&gt;
  &lt;li&gt;非计算密集型任务，CPU 计算不复杂。CPU 计算会占用大量时间，会让协程占用 CPU 时间过长，影响其他协程正常运行。同理 sleep 也不能使用，会让进程睡眠而无法进行切换，使用 poll(NULL, 0, sec) 代替。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外操作系统中存在这三种层次的回调&lt;/p&gt;

&lt;p&gt;1、硬件设备往内核态的回调通过硬件中断实现&lt;/p&gt;

&lt;p&gt;2、内核态往用户态的回调通过睡眠队列唤醒 + 进程切换实现&lt;/p&gt;

&lt;p&gt;3、用户态中进程/线程往协程的回调通过协程调度器（epoll）实现&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Tencent/libco&quot;&gt;微信 libco&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/80206565&quot;&gt;一次系统调用开销到底有多大？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sites.google.com/site/polarisnotme/linux/gcc&quot;&gt;GCC 优化编译指南&lt;/a&gt;&lt;/p&gt;

                          
&lt;/section&gt;



&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4103c399710dbdade8475a2b5cb3e864</guid>
<title>架构模式之分层架构总结</title>
<link>https://toutiao.io/k/fwtxydd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个问题，我们要把它搞清楚。需要深入的思考，从演进出发，从核心出发，探索它的本质。这样才能在工作中举一反三。探索本质的思想，对于架构者来说尤其重要。本文想探讨架构模式之分层设计的本质和核心。以便于更好的将正确的方式应用到项目中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么分层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三层架构，多层架构我们听到的很多，那有没有考虑过为什么需要分层呢？不分不是更简单更方便吗，何必大费周折搞出一个分层架构？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举一个例子，如果我们开一个饭店，一个人把采购，炒菜，上菜全部做了，一个月也有不错的收入。只是会比较忙，很辛苦。因为自己的能力毕竟有限，有时候也会把事情搞错，再比如哪天生病了，生意就没法做了。当人多了的时候就忙不过来了，大批的顾客就会跑到别人的饭店。这时候，我们就会考虑雇人，人多了就会考虑分工的问题，有的负责采购，有的负责炒菜，有的负责上菜，这样实际分层就产生了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分层本质是解耦和分类，解决职责不清的耦合问题，解决职责过大不利于发展的问题，在分层的基础上为团队分工和协作提供了依据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层的好处&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;隔离业务复杂度和技术复杂度，可独立变化发展&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;职责清晰，减少耦合，提高复用性，可维护性，扩展性（部分）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;有利于团队分工协作&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层的不足&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;代码理解的复杂度高了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;性能低了，原本一次完成的事情，需要调多层实现&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;管理成本高了，需要考虑每层的边界，代码结构和团队情况&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;如何分层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;         &lt;span&gt;分层设计也是一种抽象的思想，每层代表一个关注点，多层之间的协作实现了整个调用链路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;基于职责（关注点）不同进行分层&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;基于变化的程度进行分层&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;同一抽象层次的组件放在同一层&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层中的设计思想&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果用一句话描述的话，个人理解的就是高内聚，松耦合。展开讲的话有以下几点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;单一职责原则，分离关注点，每个层的职责是单一的，只做一类事情；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;开闭原则：隔离变化，对扩展开放，对修改关闭；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;依赖倒置原则：基于接口（抽象）编程，层与层之间的调用都应该依赖抽象而不是具体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层的方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;         &lt;span&gt;一般讲的都是逻辑分层，实际也存在物理层面进行分层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;物理分层（&lt;/span&gt;Tier&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要从物理元素切入，个人理解从物理层面有两类，一类从部署的角度考虑，一类从项目结构角度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从部署角度考虑，典型的&lt;/span&gt;J2EE N Tire&lt;span&gt;架构，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4935064935064935&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCEGFAicp5KR5MN1aW4KibL6taEZiaz7mn5QAfSoMAia2ibd4R3eVmolecWXw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;770&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大型分布式系统的分层（简化版），如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9141630901287554&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCnFzxy5SbEFPxPGPp6ficoLF2njWBSmibeNU7nAib4MLDxAA3NuSAiaPKRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;466&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从项目结构考虑（很少有人这么讲）&lt;/span&gt;1&lt;span&gt;、项目的分包结构；&lt;/span&gt;2&lt;span&gt;、&lt;/span&gt;maven&lt;span&gt;中的父子项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;逻辑分层（&lt;/span&gt;Layer&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;         &lt;span&gt;大家常见的分层方式，典型的有三层，四层，七层，如下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.3875968992248062&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCVWtdL880OPRMgYMdqnolpvTiaOUib6E4IXuUd3b08uskX3s7hqxibicpKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;516&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中三层和四层从结构上看相差不大，主要是在三层数据访问层的基础上，扩展了如服务，设备等的调用。但是从架构层面，已经有比较大的改进。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;一个架构设计到这个程度就可以了吗？远远不够，下一步需要对分层架构进行细化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层详解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在做设计的时候，需要将每一个组件，每一个角色落地，让各个参与者都能清楚，明白。以四层架构为例，详细介绍每层的关注点和设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;明确各层的关注点和职责。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9356223175965666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCl04zZsIayiaG7dbn85JS5v29SHlZOkBknWicQp9oGyLr5ymqTsf9gCpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;466&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;表现层&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注点：&lt;/span&gt;&lt;span&gt;用户交互和页面渲染&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;职责：&lt;/span&gt;&lt;span&gt;接收用户输入，调用业务逻辑层，接收业务逻辑返回实现页面渲染。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;业务逻辑层&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注点：领域模型和&lt;/span&gt;&lt;span&gt;业务逻辑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;职责：&lt;/span&gt;&lt;span&gt;系统的核心部分，实现业务逻辑和业务规则，实现事务控制，调用资源访问层；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;资源整合层：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注点：&lt;/span&gt;&lt;span&gt;各类资源的调用和隔离&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;职责：&lt;/span&gt;&lt;span&gt;整合数据访问（读写），整合外部接口，整合设备交互。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;明确各层的设计（代码级）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;671&quot; data-ratio=&quot;1.159744408945687&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCaqDGia7IGGEaV3Q3XWdws8uEN18lmom1EwJEhcW8iciaLFPplWDb7UnIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    上图已经把代码层面的组件画出来了，按照这个方案就可以进行开发了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;（1）&lt;/span&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;VO&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;BO&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Entity&lt;/span&gt;&lt;span&gt;可以使用同一套实体类也可以分开，比较推荐的做法是&lt;/span&gt;&lt;span&gt;VO&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;BO&lt;/span&gt;&lt;span&gt;使用一套，&lt;/span&gt;&lt;span&gt;Entity&lt;/span&gt;&lt;span&gt;使用一套。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;（2）&lt;span&gt;      &lt;/span&gt;&lt;span&gt;业务逻辑层：抽象了&lt;/span&gt;Logic&lt;span&gt;接口，用于定义每个服务方法的步骤，该部分会有一些通用的&lt;/span&gt;Logic&lt;span&gt;用于多个服务方法复用。&lt;/span&gt;Service&lt;span&gt;会调用具体的&lt;/span&gt;Logic&lt;span&gt;实现逻辑逻辑，达到了最大程度的解耦和复用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;业务逻辑层：对于&lt;/span&gt;&lt;span&gt;Logic&lt;/span&gt;&lt;span&gt;内复用的，可以下沉到&lt;/span&gt;&lt;span&gt;Manager&lt;/span&gt;&lt;span&gt;中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;（4）&lt;/span&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;业务逻辑层：还可以在&lt;/span&gt;&lt;span&gt;Servide&lt;/span&gt;&lt;span&gt;的基础上封装一层&lt;/span&gt;&lt;span&gt;Façade&lt;/span&gt;&lt;span&gt;，用于聚合多个&lt;/span&gt;&lt;span&gt;Servie&lt;/span&gt;&lt;span&gt;方法的调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（5）资源整合层：包含传统的数据库访问层结构和，调用接口的实现。调用接口使用代理模式实现，隔离了外部差异。复杂的话，可以考虑使用策略+适配器的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;层之间的调用关系&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    标准的调用是严格按照上次调用下层的顺序，实际也可以跨层调用（根据团队规范，约定好）。&lt;/span&gt;&lt;span&gt;但是，应避免循环调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1612903225806452&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCoAPc3IzRNlejb0ibIrwoZkhVU0QyzfI7AvMicZhWAczKFNhWktSnDAcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;341&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;物理分层与逻辑分层的关系&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;        &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.773371104815864&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCoViawUz3q20A4wriafspocRib6pV0X7C5kZTYb50q90rdUql1a6ibkjkCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;706&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;逻辑架构会以不同的方式，表现到物理架构中。拿分层来讲，常见的方式有全部逻辑分层一起部署，逻辑分层部分分开部署和逻辑分层完全分开部署。分开部署后会涉及到&lt;/span&gt;RPC&lt;span&gt;调用和服务高可用等问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;文章总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;         分层架构是项目中用到的最多的架构模式之一，核心思想是归类和解耦，实现有多种方式，不应局限于三层，四层，也可能是两层，五层，六层，具体以实际的项目为准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;          本文希望由浅入深的介绍分层相关的知识，使大家不仅知道分层，还知道为什么分，怎么分。从概念到落地是架构师必须跨过的一道坎。通过了这个坎就可以将架构知识灵活的运用到项目中，实现能力的升华，成为真正的架构师。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;           实际每一层还会有一些变化，不同的设计模式和架构模式实现的分层和代码的组织方式也是不同的，没有完全一样的架构，合适的就是最好的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dbf33734ebfd118f37f9fae450ccab39</guid>
<title>JavaScript 垃圾回收策略</title>
<link>https://toutiao.io/k/i8pbfyr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;blockquote&gt;&lt;p&gt;前段时间，面了不少公司，不少面试官都会问到JavaScript垃圾回收。说实话，平时还真的了解不多，最近正在看“JavaScript高级程序设计”，从头把基础再巩固下。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;JavaScript 是使用垃圾回收的语言，通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：&lt;span&gt;垃圾收集器会按照固定的时间间隔或代码执行中预定的收集时间，周期性地执行操作--找出不再继续使用的变量，然后释放其占用的内存&lt;/span&gt;。如何找出不再继续使用的变量，浏览器发展怎么多年，出现了几种不同的实现方案，标记清理和引用计数。今天简单说说 JavaScript 最常用的垃圾回收策略 -【标记清理】。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;标记清理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; a = 1&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以手动释放：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; a = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 释放&lt;/span&gt;&lt;br/&gt;a = &lt;span&gt;null&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有种不太常用的垃圾回收策略-引用计数（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。由于不太常用，我们这里就不多介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面的内容，基本可以在“JavaScript高级程序设计”找到，感兴趣的可以读一读这本书，收获还是蛮大的，之后有时间，我会把书中的知识点整理，总结在公众号中，现在已经整理了一部分，后期会不定时更新。&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;我坚信，赞赏是不耍流氓的鼓励!&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3cef4cc8ead3ba832247b2e7390b7bde</guid>
<title>Java 8 中的 Lambda 表达式</title>
<link>https://toutiao.io/k/zahd9yv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：汤圆&lt;/p&gt;

&lt;p&gt;个人博客：&lt;a href=&quot;http://www.javalover.cc&quot;&gt;javalover.cc&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;大家好啊，我是汤圆，今天给大家带来的是《Java8中的Lambda表达式》，希望对大家有帮助，谢谢&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;文章纯属原创，个人总结难免有差错，如果有，麻烦在评论区回复或后台私信，谢啦&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;简介&lt;/h2&gt;

&lt;p&gt;Lambda表达式是一个可传递的代码块，可以在以后执行一次或多次；&lt;/p&gt;

&lt;p&gt;下面贴个对比代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// Java8之前：旧的写法
Runnable runnable = new Runnable() {
  @Override
  public void run() {
    System.out.println(&quot;old run&quot;);
  }
};
Thread t = new Thread(runnable);

// Java8之后：新的写法
Runnable runnable1 = ()-&amp;gt;{
  System.out.println(&quot;lambda run&quot;);
};
Thread t1 = new Thread(runnable1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，有了lambda，代码变得简洁多了&lt;/p&gt;

&lt;p&gt;你可以把lambda当作一个语法糖&lt;/p&gt;

&lt;p&gt;下面让我们一起来探索lambda的美好世界吧&lt;/p&gt;

&lt;h2&gt;目录&lt;/h2&gt;

&lt;p&gt;下面列出本文的目录&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;lambda的语法&lt;/li&gt;
&lt;li&gt;为啥引入lambda&lt;/li&gt;
&lt;li&gt;什么是函数式接口&lt;/li&gt;
&lt;li&gt;什么是行为参数化&lt;/li&gt;
&lt;li&gt;手写一个函数式接口&lt;/li&gt;
&lt;li&gt;常用的函数式接口&lt;/li&gt;
&lt;li&gt;什么是方法引用&lt;/li&gt;
&lt;li&gt;什么是构造引用&lt;/li&gt;
&lt;li&gt;lambda的组合操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;正文&lt;/h2&gt;

&lt;h3&gt;1. lambda的语法&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008eGmZEgy1gpjlspdm1oj30jv04t0t9.jpg&quot; alt=&quot;lambda语法&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面分别说下语法中的三个组成部分&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参数: &lt;code&gt;( Dog dog )&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;参数类型可省略（当编译器可以自动推导时），比如&lt;code&gt;Comparator&amp;lt;String&amp;gt; comparatorTest = (a, b)-&amp;gt;a.length()-b.length();&lt;/code&gt;,可以推导出a,b都为String&lt;/li&gt;
&lt;li&gt;当参数类型可省略，且只有一个参数时，括弧也可以省略（但是个人习惯保留）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;符号： &lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主体：&lt;code&gt;{ System.out.println(&quot;javalover&quot;); }&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;如果是一条语句，则需要加大括号和分号&lt;code&gt;{;}&lt;/code&gt;（比如上图所示）&lt;/li&gt;
&lt;li&gt;如果是一个表达式，则直接写，啥也不加（比如&lt;code&gt;a.length()- b.length()&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;2. 为啥引入lambda&lt;/h3&gt;

&lt;p&gt;为了简化代码&lt;/p&gt;

&lt;p&gt;因为Java是面向对象语言，所以在lambda出现之前，我们需要先构造一个对象，然后在对象的方法中实现具体的内容，再把构造的对象传递给某个对象或方法&lt;/p&gt;

&lt;p&gt;但是有了lambda以后，我们可以直接将代码块传递给对象或方法&lt;/p&gt;

&lt;p&gt;现在再回头看下开头的例子&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008eGmZEgy1gpjml3pt6sj30m2092abo.jpg&quot; alt=&quot;lambda减少了模板代码&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到，用了lambda表达式后，少了很多模板代码，只剩下一个代码块（最核心的部分）&lt;/p&gt;

&lt;h3&gt;3. 什么是函数式接口&lt;/h3&gt;

&lt;p&gt;就是只定义了一个抽象方法的接口&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;正例：有多个&lt;a href=&quot;https://mp.weixin.qq.com/s/NAO8W8YbnxWZpNEDh1xskQ&quot;&gt;默认方法&lt;/a&gt;，但是如果只有一个抽象方法，那它就是函数式接口，示例代码如下&lt;/li&gt;
&lt;/ul&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;@FunctionalInterface
public interface FunctionInterfaceDemo {
    void abstractFun();
    default void fun1(){
        System.out.println(&quot;fun1&quot;);    
    }
    default void fun2(){
        System.out.println(&quot;fun2&quot;);
    }   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;这里的注解@FunctionalInterface可以省略，但是建议加上，就是为了告诉编译器，这是一个函数式接口，此时如果该接口有多个抽象方法，那么编译器就会报错&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;反例：比如A extends B，A和B各有一个抽象方法，那么A就不是函数式接口，示例代码如下&lt;/li&gt;
&lt;/ul&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 编译器会报错，Multiple non-overriding abstract methods found in XXX
@FunctionalInterface
public interface NoFunctionInterfaceDemo extends FunctionInterfaceDemo{
  void abstractFun2();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;上面的父接口FunctionInterfaceDemo中已经有了一个抽象方法，此时NoFunctionInterfaceDemo又定义了一个抽象方法，结果编译器就提示了：存在多个抽象方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在Java8之前，其实我们已经接触过函数式接口&lt;/p&gt;

&lt;p&gt;比如Runnable 和 Comparable &lt;/p&gt;

&lt;p&gt;只是没有注解@FunctionalInterface。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;那这个函数式接口要怎么用呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;配合lambda食用，效果最佳（就是把lambda传递给函数式接口），示例代码如下：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;new Thread(() -&amp;gt; System.out.println(&quot;run&quot;)).start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中用到的函数式接口是&lt;code&gt;Runnable&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;4. 什么是行为参数化&lt;/h3&gt;

&lt;p&gt;就是把&lt;strong&gt;行为&lt;/strong&gt;定义成&lt;strong&gt;参数&lt;/strong&gt;，行为就是&lt;strong&gt;函数式接口&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;类似&lt;a href=&quot;https://mp.weixin.qq.com/s/NgqWzRbrHmO9iTBAQM-7zw&quot;&gt;泛型&lt;/a&gt;中的类型参数化&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;，类型参数化是把&lt;strong&gt;类型&lt;/strong&gt;定义成&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;行为参数化，通俗点来说：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;就是用&lt;strong&gt;函数式接口&lt;/strong&gt;做&lt;strong&gt;形参&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;然后传入接口的各种实现内容（即&lt;strong&gt;lambda表达式&lt;/strong&gt;）作为&lt;strong&gt;实参&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;最后在lambda内&lt;strong&gt;实现各种行为&lt;/strong&gt;（好像又回到&lt;a href=&quot;&quot;&gt;多态&lt;/a&gt;的那一节了？这也是为啥多态是Java的三大特性的原因之一，应用太广泛了）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样来看的话，&lt;strong&gt;行为参数化&lt;/strong&gt;和设计模式中的&lt;strong&gt;策略模式&lt;/strong&gt;有点像了（后面章节会分别讲常用的几种设计模式）&lt;/p&gt;

&lt;p&gt;下面我们手写一个函数式接口来加深理解吧&lt;/p&gt;

&lt;h3&gt;5. 手写一个函数式接口&lt;/h3&gt;

&lt;p&gt;下面我们循序渐进，先从简单的需求开始&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一步：比如我们想要&lt;strong&gt;读取某个文件&lt;/strong&gt;，那可以有如下方法：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public static String processFile() throws IOException {
    // Java7新增的语法，try(){}，可自动关闭资源，减少了代码的臃肿
    try( BufferedReader bufferedReader = 
        new BufferedReader(new  FileReader(&quot;D:\\JavaProject\\JavaBasicDemo\\test.txt&quot;))){
        return bufferedReader.readLine();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，核心的行为动作就是 &lt;code&gt;return bufferedReader.readLine();&lt;/code&gt;，表示读取第一行的数据并返回&lt;/p&gt;

&lt;p&gt;那如果我们想要读取两行呢？三行？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第二步：这时就需要用到上面的&lt;strong&gt;函数式接口&lt;/strong&gt;了，下面就是我们自己编写的函数式接口&lt;/li&gt;
&lt;/ul&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;@FunctionalInterface
interface FileReadInterface{
    // 这里接受一个BufferedReader对象，返回一个String对象
    String process(BufferedReader reader) throws IOException;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，只有一个抽象方法&lt;code&gt;process()&lt;/code&gt;，它就是用来处理第一步中的核心动作（读取文件内容）&lt;/p&gt;

&lt;p&gt;至于想读取多少内容，那就需要我们在lambda表达式中定义了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第三步：接下来我们定义多个&lt;strong&gt;lambda表达式&lt;/strong&gt;，用来&lt;strong&gt;传递&lt;/strong&gt;给&lt;strong&gt;函数式接口&lt;/strong&gt;，其中每个lambda表达式就代表了一种不同的行为，代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 读取一行
FileReadInterface fileReadInterface = reader -&amp;gt; reader.readLine();
// 读取两行
FileReadInterface fileReadInterface2 = reader -&amp;gt; reader.readLine() + reader.readLine();

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;第四步：我们需要修改第一步的&lt;code&gt;processFile()&lt;/code&gt;，让其接受一个函数式接口，并调用其中的抽象方法，代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 参数为第二步我们自己手写的函数式接口
public static String processFile(FileReadInterface fileReadInterface) throws IOException {
        try( BufferedReader bufferedReader =
                 new BufferedReader(new FileReader(&quot;./test.txt&quot;))){
                    // 这里我们不再自己定义行为，而是交给函数式接口的抽象方法来处理，然后通过lambda表达式的传入来实现多个行为
          return fileReadInterface.process(bufferedReader);
        }
    }
&lt;/code&gt;&lt;/pre&gt;



&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class FileReaderDemo {
    public static void main(String[] args) throws IOException {
                // 第三步： 
        // lambda表达式1 传给 函数式接口：只读取一行
        FileReadInterface fileReadInterface = reader -&amp;gt; reader.readLine();
                // lambda表达式2 传给 函数式接口：只读取两行
        FileReadInterface fileReadInterface2 = reader -&amp;gt; reader.readLine() + reader.readLine();
        // 最后一步： 不同的函数式接口的实现，表现出不同的行为
        String str1 = processFile(fileReadInterface);
        String str2 = processFile(fileReadInterface2);
        System.out.println(str1);
        System.out.println(str2);
    }
    // 第四步： 读取文件方法，接受函数式接口作为参数
    public static String processFile(FileReadInterface fileReadInterface) throws IOException {
        try( BufferedReader bufferedReader =
                 new BufferedReader(new FileReader(&quot;./test.txt&quot;))){
                    // 调用函数式接口中的抽象方法来处理数据                   
          return fileReadInterface.process(bufferedReader);
        }
    }
    // 第一步：
  public static String processFile() throws IOException {
        try( BufferedReader bufferedReader =
                 new BufferedReader(new FileReader(&quot;./test.txt&quot;))){
          return bufferReader.readLine();
        }
    }


}

// 第二步： 我们手写的函数式接口
@FunctionalInterface
interface FileReadInterface{
    String process(BufferedReader reader) throws IOException;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实你会发现，我们手写的这个函数式接口，其实就是&lt;code&gt;Function&amp;lt;T&amp;gt;&lt;/code&gt;去除泛型化后的接口，如下所示：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;@FunctionalInterface
public interface Function&amp;lt;T, R&amp;gt; {
    // 都是接受一个参数，返回另一个参数
  R apply(T t);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们列出Java中常用的一些函数式接口，你会发现自带的已经够用了，基本不会需要我们自己去写&lt;/p&gt;

&lt;p&gt;这里的手写只是为了自己实现一遍，可以加深理解程度&lt;/p&gt;

&lt;h3&gt;6. 常用的函数式接口&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008eGmZEgy1gpkrz12s52j312u0fkwpt.jpg&quot; alt=&quot;常用的函数式接口&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;7. 什么是方法引用&lt;/h3&gt;

&lt;p&gt;我们先看一个例子&lt;/p&gt;

&lt;p&gt;前面我们写的lambda表达式，其实还可以简化，比如&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 简化前
Function&amp;lt;Cat, Integer&amp;gt; function = c-&amp;gt;c.getAge();
// 简化后
Function&amp;lt;Cat, Integer&amp;gt; function2 = Cat::getAge;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中简化后的&lt;code&gt;Cat::getAge&lt;/code&gt;，我们就叫做&lt;strong&gt;方法引用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法引用就是引用类或对象的方法&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;下面我们列出方法引用的三种情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Object::instanceMethod（对象的实例方法）&lt;/li&gt;
&lt;li&gt;Class::staticMethod（类的静态方法）&lt;/li&gt;
&lt;li&gt;Class::instanceMethod（类的实例方法）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;像我们上面举的例子就是第三种：类的实例方法&lt;/p&gt;

&lt;p&gt;下面我们用代码演示上面的三种方法：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class ReferenceDemo {
    public static void main(String[] args) {
        // 第一种:引用对象的实例方法
        Cat cat = new Cat(1);
        Function&amp;lt;Cat, Integer&amp;gt; methodRef1 = cat::getSum; 
        // 第二种:引用类的静态方法
        Supplier&amp;lt;Integer&amp;gt; methodRef2 = Cat::getAverageAge;
        // 第三种：引用类的实例方法
        Function&amp;lt;Cat, Integer&amp;gt; methodRef3 = Cat::getAge;
    }
}
class Cat {
    int age;

    public Cat(int age) {
        this.age = age;
    }

    // 获取猫的平均年龄
    public static int getAverageAge(){
        return 15;
    }
    // 获取两只猫的年龄总和
    public int getSum(Cat cat){
        return cat.getAge() + this.getAge();
    }

    public int getAge() {
        return age;
    }    public void setAge(int age) {
        this.age = age;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;为啥要用这个方法引用呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;方法引用好比lambda表达式的语法糖，语法更加简洁，清晰&lt;/p&gt;

&lt;p&gt;一看就知道是调用哪个类或对象的哪个方法&lt;/p&gt;

&lt;h3&gt;8. 什么是构造引用&lt;/h3&gt;

&lt;p&gt;上面介绍了方法引用，就是直接引用某个方法&lt;/p&gt;

&lt;p&gt;这里的构造引用同理可得，就是引用某个类的构造方法&lt;/p&gt;

&lt;p&gt;构造引用的表达式为：&lt;code&gt;Class::new&lt;/code&gt;，仅此一种&lt;/p&gt;

&lt;p&gt;如果你有多个构造函数，那编译器会自己进行推断参数（你看看，多好，多简洁）&lt;/p&gt;

&lt;p&gt;比如下面的代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 这里调用 new Cat()
Supplier&amp;lt;Cat&amp;gt; constructRef1 = Cat::new;
// 这里调用 new Cat(Integer)
Function&amp;lt;Integer, Cat&amp;gt; constructRef2 = Cat::new;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;9. lambda表达式中引入外部变量的限制&lt;/h3&gt;

&lt;p&gt;要求引入lambda表达式中的变量，必须是最终变量，即该变量不会再被修改&lt;/p&gt;

&lt;p&gt;比如下面的代码：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public static void main(String[] args) {
  String str = &quot;javalover.cc&quot;;
  Runnable runnable = ()-&amp;gt;{
    str = &quot;1&quot;;// 这里会报错，因为修改了str引用的指向
    System.out.println(str);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，lambda表达式引用了外面的str引用，但是又在表达式内部做了修改，结果就报错了&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;为啥要有这个限制呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了线程安全，因为lambda表达式有一个好处就是只在需要的时候才会执行，而不是调用后立马执行&lt;/p&gt;

&lt;p&gt;这样就会存在多个线程同时执行的并发问题&lt;/p&gt;

&lt;p&gt;所以Java就从根源上解决：不让变量被修改，都是只读的&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;那你可能好奇，我不把str的修改代码放到表达式内部可以吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也不行，道理是一样的，只要lambda有用到这个变量，那这个变量不管是在哪里被修改，都是不允许的&lt;/p&gt;

&lt;p&gt;不然的话，我这边先执行了一次lambda表达式，结果你就改了变量值，那我第二次执行lambda，不就乱了吗&lt;/p&gt;

&lt;h3&gt;10. lambda的组合操作&lt;/h3&gt;

&lt;p&gt;最后是lambda的必杀技：&lt;strong&gt;组合操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在这里叫组合或者复合都可以&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;概述：组合操作就是先用一个lambda表达式，然后再在后面组合另一个lambda表达式，然后再在后面组合另另一个lambda表达式，然后。。。有点像是链式操作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;学过JS的都知道Promise，里面的链式操作就和这里的组合操作很像&lt;/p&gt;

&lt;p&gt;用过Lombok的朋友，应该很熟悉@Builder注解，其实就是构造者模式&lt;/p&gt;

&lt;p&gt;下面我们用代码演示下组合操作：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 重点代码
public class ComposeDemo {
    public static void main(String[] args) {
        List&amp;lt;Dog&amp;gt; list = Arrays.asList(new Dog(1,2), new Dog(1, 1));
        // 1. 先按年龄排序（默认递增）
        // Dog::getAge, 上面介绍的方法引用
        // comparingInt, 是Comparator的一个静态方法，返回Comparator&amp;lt;T&amp;gt;
        Comparator&amp;lt;Dog&amp;gt; comparableAge = Comparator.comparingInt(Dog::getAge);
        // 2. 如果有相同的年龄，则年龄相同的再按体重排序（如果年龄已经比较出大小，则下面的体重就不会再去比较）
        Comparator&amp;lt;Dog&amp;gt; comparableWeight = Comparator.comparingInt(Dog::getWeight);;
        // 3. 调用list对象的sort方法排序，参数是Comparator&amp;lt;? super Dog&amp;gt;
        list.sort(comparableAge.thenComparing(comparableWeight));
        System.out.println(list);
    }
}
// 非重点代码
class Dog{
    private int age;
    private int weight;

    public Dog(int age, int weight) {
        this.age = age;
        this.weight = weight;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getWeight() {
        return weight;
    }

    public void setWeight(int weight) {
        this.weight = weight;
    }

    @Override
    public String toString() {
        return &quot;Dog{&quot; +
                &quot;age=&quot; + age +
                &quot;, weight=&quot; + weight +
                &#x27;}&#x27;;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;code&gt;[Dog{age=1, weight=1}, Dog{age=1, weight=2}]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;比较的流程如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008eGmZEgy1gpksrxyd3rj312y0n6wgw.jpg&quot; alt=&quot;组合操作&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;lambda的语法:  参数+符合+表达式或语句，比如&lt;code&gt;(a,b)-&amp;gt;{System.out.println(&quot;javalover.cc&quot;);}&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数式接口：只有一个抽象方法，最好加@FunctionalInterface，这样编译器可及时发现错误，javadoc也说明这是一个函数式接口（可读性）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行为参数化：就是函数式接口作为参数，然后再将lambda表达式传给函数式接口，通过不同的lambda内容实现不同的行为&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法引用：lambda的语法糖，总共有三种:&lt;/p&gt;

&lt;/li&gt;
&lt;li&gt;&lt;p&gt;构造引用：就一种，编译器自己可判断是哪个构造函数，语法为&lt;code&gt;Class::new&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在lambda中引入外部变量，必须保证这个变量是最终变量，即不再被修改&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lambda的组合操作，就是链式操作，组合是通过函数式接口的静态方法来组合（静态方法会返回另一个函数式接口的对象）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;比如&lt;code&gt;list.sort(comparableAge.thenComparing(comparableWeight));&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;后记&lt;/h2&gt;

&lt;p&gt;最后，感谢大家的观看，谢谢&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>