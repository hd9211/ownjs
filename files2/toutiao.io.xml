<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>91b513559ba60ceb575179669418e339</guid>
<title>腾讯 T4 一年的心血成就 17W 字操作系统、网络协议教程（附导图 + 笔记）</title>
<link>https://toutiao.io/k/kzxohh6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;article_content&quot; class=&quot;article_content clearfix&quot;&gt;
        
                &lt;div id=&quot;content_views&quot; class=&quot;htmledit_views&quot;&gt;
                    &lt;ul&gt;&lt;li&gt;《Java 核心技术总结》&lt;/li&gt;&lt;li&gt;《HTTP 总结》&lt;/li&gt;&lt;li&gt;《程序员必知的基础知识》&lt;/li&gt;&lt;li&gt;《操作系统总结》&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;这四本 PDF 可以说是一个比一个硬核。&lt;/p&gt; 
&lt;p&gt;先来说说 Java 核心技术总结&lt;/p&gt; 
&lt;h1&gt;Java 核心技术总结&lt;/h1&gt; 
&lt;p&gt;先来看一下本篇文章的思维导图吧，文章围绕下面这些内容进行讲解。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/972c835008f1bb8f20c1e539d4824b2a.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;这本 PDF 可以作为你的 Java 入门开发手册，也可以作为查漏补缺的利器&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/9c5dfcc1c3a06c599c3f3ae91c5a8d60.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/43de11080035e70fdda879e75b82ae1c.png&quot;/&gt;&lt;/p&gt; 
&lt;h1&gt;HTTP 核心总结&lt;/h1&gt; 
&lt;p&gt;第二本 PDF 的思维导图&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/5d44480ca1932b56955dd2da5c05257f.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;可以看看里面的绘图，真的是非常下功夫的。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/b85c0354729eadabd740e30dce2d7a90.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/6d26200b2b55f223a958978963dc7313.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这个 PDF 几乎涵盖了关于 HTTP 99% 的知识点了&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/7501c9df42fd1ef0df9417cd9eeb4add.png&quot;/&gt;&lt;/p&gt; 
&lt;h1&gt;程序员必知的硬核知识&lt;/h1&gt; 
&lt;p&gt;在技术不断更新迭代的今天，你学习的速度已经跟不上框架迭代的速度了，当你还在学 Spring 3 的时候，Spring 5 就已经出来了。而且，现在会使用 Spring 的人简直太多了，大家都在研究新技术怎么用，框架怎么好，却忘了为什么要这么设计，构造原理是怎么样？所以，基础是重中之重，若干年前计算机只认识 0 和 1，现在仍然只能认识 0 和 1，所以你要把有限的时间放在不会改变的技术上。基础知识是亘古不变的，改变也只是会调优，而不会推翻。所以，我自己写了一本 PDF，是程序员必知的基础知识，来为你讲述这些不变的根本。&lt;/p&gt; 
&lt;p&gt;我带你重新认识了一下 CPU 是什么，CPU 寄存器有哪些&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/f70b396fea5f56c0354ccecce1e418e8.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/0025ed1955567d019250a22624f59444.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;我和你聊聊内存是什么&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/db0e4f15538f6a2cc5cabfede4ba78c2.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;我非常认真的为你总结了计算机中二进制的计算原则&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/0f54bcf40ebbed84f4fc0310892a3b50.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;我和你聊聊磁盘是如何出现的，以及它的发展历程，为什么磁盘能够存储数据？&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/b5a3f9d51081b75b6388f97568186d2c.png&quot;/&gt;&lt;/p&gt; 
&lt;h1&gt;操作系统总结&lt;/h1&gt; 
&lt;p&gt;这是我最硬核的一本 PDF 了&lt;/p&gt; 
&lt;p&gt;目录&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/415abd2a43a6fc140d85c789db46c88e.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;操作系统确实 太重要了，可以说没有操作系统，也就没有人给你扯这么多。所以非常有必要认识一下操作系统。&lt;/p&gt; 
&lt;p&gt;这本 PDF 带你认识了一下操作系统的一些核心概念，能够让你有个全局认识。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/0070a00b56c0a216840d5455ab48711e.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这本 PDF 带你从入门到深入理解操作系统最核心的抽象：&lt;/p&gt; 
&lt;h1&gt;进程、文件、地址&lt;/h1&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d804f8efe96fc6acd28a60bc13589bfd.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/cb551521aae107442484ef1d5c98328d.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/97b7a8356577d3eb5b92a9fde769219c.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;还为你汇总了操作系统核心面试题，助你一臂之力&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/82b097e87d093dfe2aca9b887b64d01d.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这本 PDF 一共是 306 页，17w 字，我想这应该是全网第一份操作系统 PDF 了吧，希望大家能够珍藏。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/ee4acf87ee3b2a82c380cb9a7d946c2b.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;《Java 核心技术总结》《HTTP 总结》《程序员必知的基础知识》《操作系统总结》四本实战且实用的好教程你值得拥有，转发+评论，关注我添加VX：MXW5308 即可免费获取《Java 核心技术总结》《HTTP 总结》《程序员必知的基础知识》《操作系统总结》学习教程.pdf&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/20201006145432207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTEzMjIzOA==,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt;
                &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a642c6fc0d66e4671c3bb7ef6a9e1db9</guid>
<title>虚拟机系列：JVM 运行时数据区</title>
<link>https://toutiao.io/k/otkcgzi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、内存与线程&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、内存结构&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;内存是计算机的重要部件之一,它是外存与CPU进行沟通的桥梁，计算机中所有程序的运行都在内存中进行，内存性能的强弱影响计算机整体发挥的水平。JVM的内存结构规定Java程序在执行时内存的申请、划分、使用、回收的管理策略，通说来说JVM的内存管理指运行时数据区这一大块的管理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5402298850574713&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBS1pq4s6Msxgia1CKUMqTWdgtf3jWpQibAn0R2sDjFbnNdHX2a1Iia00icAEO8ooibhtia1pa6yuquNSWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;870&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、线程运行&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;JVM中一个应用是可以有多个线程并行执行，线程被一对一映射为服务所在操作系统线程，调度在可用的CPU上执行，启动时会创建一个操作系统线程；当该线程终止时，这个操作系统线程也会被回收。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.554635761589404&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uUIibyNXbAvBS1pq4s6Msxgia1CKUMqTWdMBHFVkiavMxy3YoBibAichXoOl7Mq7zC0BeWSBopibhfOhYcq8BJjlX6mA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;604&quot;/&gt;&lt;/p&gt;&lt;p&gt;在虚拟机启动运行时，会创建多个线程，数据区中有的模块是线程共享的，有的是线程私有的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.048780487804878&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBS1pq4s6Msxgia1CKUMqTWd038zciaxwKSb6GdJVx7gvbmdCzHLjIj1rWDt3sITDDvPlnqqrI6o6uQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot;/&gt;&lt;/p&gt;&lt;p&gt;线程共享：元数据区、堆Heap；&lt;/p&gt;&lt;p&gt;线程私有：虚拟机栈、本地方法栈、程序计数器；&lt;/p&gt;&lt;p&gt;单个CPU在特定时刻只能执行一个线程，所以多线程通过几块空间的使用，然后不断的争抢CPU的执行时间段。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、元数据空间&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;基本描述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;方法元空间(方法区)在JVM启动的时候被创建，是被各个线程共享的内存空间，用于存放类和方法的元数据以及常量池，比如Class和Method。&lt;/p&gt;&lt;p&gt;在实际的开发中，经常因为加载的类太多，进而导致内存溢出问题，这样可以对元空间的大小进行扩展。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;与堆的关系&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5643340857787811&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBS1pq4s6Msxgia1CKUMqTWd0NK8W3DP7Kw1O9NQ3w5ccjlQLbqQOZ7OVubUnstyb0YgSkUibnkiaqsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;886&quot;/&gt;&lt;/p&gt;&lt;p&gt;元空间存放加载的类信息，当类被实例化时，堆中存储实例化的对象信息，并且通过对象类型数据的指针找到类。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、堆空间&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;基本描述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;JVM启动时创建堆区，是内存管理的核心区，通常情况下也是最大的内存空间，是被所有线程共享的，几乎所有的对象实例都要在堆中分配内存，所以这里也是垃圾回收的重点空间。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;堆栈关系&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4810606060606061&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBS1pq4s6Msxgia1CKUMqTWdOa4jwFr4xicypwMdhUHSlZE0hWehxPapB8ROpRAcIsfsTfjIIIFk0QA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/p&gt;&lt;p&gt;栈是JVM运行时的单位，堆是存储单位，当栈中方法结束，相关对象失去所有引用后，不会马上被移除堆空间，要等到垃圾收集器运行的时候。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、虚拟机栈&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;虚拟机栈(Java栈)在每个线程创建时都会生成一个虚拟机栈，栈的内部是一个个栈帧单元，对应Java方法的调用，其生命周期和线程周期保持一致。用来存储方法的局部遍历，部分执行结果，方法的调用和返回。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5358024691358024&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBS1pq4s6Msxgia1CKUMqTWdePzvjCycphicyJHOcVsjmAqibfnl4ibJLlaHyUttEE359XgstJGFyxhPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot;/&gt;&lt;/p&gt;&lt;p&gt;栈帧是方法执行的数据集，维持执行过程中的各种数据信息，执行的方法依次入栈，栈顶存放当前要执行的方法，执行结束后出栈，对于栈没有垃圾回收问题。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、程序计数器&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;基本描述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;JVM中程序计数寄存器用来存储下一条将要执行指令的地址，执行引擎获取到指令后进行执行，是线程私有的。它可以看作是当前线程所执行的字节码的行号指示器。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5429184549356223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBS1pq4s6Msxgia1CKUMqTWdoicrbxfHfcGeYd8zOT7GRyl2KZanJudibzugjhsfY0WLkMaIyNVxSFKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;932&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;前后关系&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;线程在获取CPU的时间段内执行代码，但是线程随时可能没有执行完就被挂起，等到线程A再次获取CPU执行时，CPU 得知道执行到线程A的哪一个指令，程序计数器会存储该动作。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;六、本地方法栈&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;本地方法栈与虚拟机栈所起到的作用是类似的，虚拟机栈为虚拟机执行Java方法，本地方法栈管理虚拟机使用到的 本地方法，在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。HotSpot虚拟机直接就把本地方法栈和虚拟机栈合二为一。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;七、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/java-base-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/java-base-parent&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b6667d7499592fa75ef4edb661b5cbd6</guid>
<title>想要 4 个 9？本文告诉你监控告警如何做</title>
<link>https://toutiao.io/k/9vxbpn0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“你说说，没有仪表盘的车，你敢开吗？”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“没有仪表盘的车开在路上，你怎么知道现在是什么情况？”&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iachwhMRhBibb9pv5Kyriary5QLZsJ4I8ZQ4l32JOMBsc4T3Veg7OPUIwicDJrsF1mwPBL1Z9K9IGVtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“客户说你这车又崩了，咋知道什么时候好的？啥时候出的问题？”&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将思考转换到现实的软件系统中，可想而知没有监控系统的情况下，也就是没有 ”仪表盘“ 的情况下实在是太可怕了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的故障永远都是你的客户告诉你的，而...在什么时候发生的，你也无法确定，只能通过客户的反馈倒推时间节点，最后从错误日志中得到相对完整的日志信息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更要命的是你无法掌握主动权，错误日志有可能会有人漏记录，平均修复时间（MTTR）更不用想了，需要从 0.1 开始定位，先看 APP 是哪个模块报错，再猜测是哪个服务导致，再打开链路追踪系统，或是日志平台等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稍微复杂些的，排查来来往往基本都是半小时、一小时以上，那 4 个 9 肯定是达不到的了，以此几次 P0 几小时怕不是业务绩效也凉凉，因为故障修复的速度实在是太慢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那归根到底，想破局怎么办，核心第一步就是要把监控告警的整个生态圈给建设好。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;监控定义&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常说监控监控，监控的定义就是监测和控制，检测某些事物的变化，以便于进行控制。在常见的软件系统中，大多分为三大观察类别：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5654596100278552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iachwhMRhBibb9pv5Kyriary5a6fQgicUpP748xYQC1icwO90lEm4DwyycqO3DEC4Feibt7AWxJFreGQkQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1436&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;业务逻辑：项目所对应的服务其承担的业务逻辑，通常需要对其进行度量。例如：每秒的下单数等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;应用程序：应用程序。例如：统一的基础框架。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;硬件资源：服务器资源情况等。例如：Kubernetes 中的 Cadvisor 组件便会提供大量的资源指标。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从软件系统来讲，监控的定义就是收集、处理、汇总，显示关于某个系统的实时量化数据，例如：请求的数量和类型，错误的数量和类型，以及各类调用/处理的耗时，应用服务的存活时间等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;监控目标&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了监控的定义，了解了监控的作用和具体的实施指标后。我们需要明确的知道，做监控的目标是什么：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6142061281337048&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iachwhMRhBibb9pv5Kyriary5cAwpgsyOHPOhB8sRdMEEQsmkFKALjTkaRXIBfEoZZZlOcicHiaNic64RQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1436&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从现实层面出发，做监控的初衷，就是希望能够及时的发现线上环境的各种各样奇奇怪怪的问题，为业务的正常运转保驾护航。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此整体分为上图四项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;预测故障：故障还没出现，但存在异常。监控系统根据流量模型、数据分析、度量趋势来推算应用程序的异常趋势，推算可能出现故障的问题点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;发现故障：故障已经出现，客户还没反馈到一线人员。监控系统根据真实的度量趋势来计算既有的告警规则，发现已经出现故障的问题点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;定位故障：故障已经出现，需要监控系统协助快速定位问题，也就是根因定位（root cause）。此时是需要协调公司内生态圈的多个组件的，例如：链路追踪系统、日志平台、监控系统、治理平台（限流熔断等），根据监控系统所告警出来的问题作为起始锚点，对其进行有特定方向的分析，再形成 ”线索“ 报告，就可以大力的协助开发人员快速的定位问题，发现故障点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;故障恢复：故障已经出现，但自动恢复了，又或是通过自动化自愈了。这种情况大多出现在告警规则的阈值配置的不够妥当，又或是第三方依赖恰好恢复了的场景。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而更值得探讨的的是监控告警的后半段闭环，故障自愈，通过上述三点 “预测故障、发现故障、定位故障”，已经定位到故障了，就可以配合内部组件，实现自动化的 ”自愈“，减少人工介入，提高 MTTR。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6142061281337048&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iachwhMRhBibb9pv5Kyriary5AezX00H2MpaGqB3Utj9rL8mBASLMWGk2nLHKJO7r2P8icO6cNRtN0ww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1436&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此做监控系统的目标很明确，就是发现问题，解决问题，最好自愈，达到愉快休假，业务安心的目的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4 个黄金指标&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有定义，有目标，那指导呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上 “业务逻辑、应用程序、硬件资源” 已经成为了一个监控系统所要监控构建的首要目标，绝大部分的监控场景都可以归类进来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对这三大项，《Google SRE 运维解密》 也总结出了 4 个黄金指标，在业界广为流传和借鉴：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;延迟：服务处理某个请求所需要的时间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;区分成功和失败请求很重要，例如：某个由于数据库连接丢失或者其他后端问题造成的 HTTP 500 错误可能延迟很低。因此在计算整体延迟时，如果将 500 回复的延迟也计算在内，可能会产生误导性的结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“慢” 错误要比 “快” 错误更糟糕。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;流量：使用系统中的某个高层次的指标针对系统负载需求所进行的度量。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对 Web 服务器来讲，该指标通常是每秒 HTTP 请求数量，同时可能按请求类型分类（静态请求与动态请求）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对音频流媒体系统来说，指标可能是网络 I/O 速率，或者并发会话数量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对键值对存储系统来说，指标可能是每秒交易数量，或每秒的读者操作数量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;错误：请求失败的速率。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;显式失败（例如：HTTP 500）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;隐式失败（例如：HTTP 200 回复中包含了错误内容）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;策略原因导致的失败（例如：如果要求回复在 1s 内发出，任何超过 1s 的请求就都是失败请求）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;饱和度：服务容量有多 “满”，通常是系统中目前最为受限的某种资源的某个具体指标的度量，例如：在内存受限的系统中，即为内存；在 I/O 受限的系统中，即为 I/O。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;很多系统在达到 100% 利用率之前性能会严重下降，因此可以考虑增加一个利用率目标。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;延迟增加是饱和度的前导现象，99% 的请求延迟（在某一个小的时间范围内，例如一分钟）可以作为一个饱和度早期预警的指标。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;饱和度需要进行预测，例如 “看起来数据库会在 4 小时内填满硬盘”。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果已经成功度量了这四个黄金指标，且在某个指标出现故障时能够发出告警（或者快要发生故障），那么在服务的监控层面来讲，基本也就满足了初步的监控诉求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是可以做到知道了是什么出问题，问题出在哪里，单这一步就已经提高了不少定位问题的时间效率，是一个从 0 到 1 的起步阶段。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实践案例&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道是什么（定义），为什么要做（目标），做的时候需要什么（4 个黄金指标）后，还缺乏的是一个承载这些基础应用、业务思考的平台，让架构+运维+业务共同在上面施展拳脚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公司内部至少需要有一个监控告警管理平台。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;平台搭建&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在目前云原生火热的情况下，Kubernetes 生态中大多惯用 Prometheus，因此 Prometheus+Grafana+AlertManger 成为了一大首选，业内占比也越来越高，其基本架构如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6122448979591837&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iachwhMRhBibb9pv5Kyriary5qJNWicfLhjrDiafDn5ictrTfArvHJBErvZZmb4zzTJGK25OVmENKpmjkA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1960&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Prometheus Server：用于收集指标和存储时间序列数据，并提供一系列的查询和设置接口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Grafana：用于展示各类趋势图，通过 PromQL 从 Prometheus 服务端查询并构建图表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Alertmanager：用于处理告警事件，从 Prometheus 服务端接收到 alerts 后，会进行去重，分组，然后路由到对应的Receiver，发出报警。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这块具体的基本知识学习和搭建可详见我写的 Prometheus 系列，本文不再赘述。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;监控指标&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在平台搭建完毕后，常要做的第一步，那就是规划你整个系统的度量指标，结合 Google SRE 的 4 个黄金指标，可以初步划分出如下几种常用类型：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;系统层面：Kubernetes Node、Container 等指标，这块大多 Cadvisor 已采集上报，也可以安装 kube-state-metrics 加强，这样子就能够对 Kubernetes 和应用程序的运行情况有一个较好的观察和告警。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;系统层面：针对全链路上的所有基础组件（例如：MySQL、Redis 等）安装 exporter，进行采集，对相关基础组件进行监控和告警。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;业务服务：RPC 方法等的 QPS 记录。可以保证对业务服务的流量情况把控，且后续可以做预测/预警的一系列动作，面对突发性流量的自动化扩缩容有一定的参考意义。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;业务服务：RPC 方法等的错误情况。能够发现应用程序、业务的常见异常情况，但需要在状态/错误码规划合理的情况下，能够起到较大的作用，有一定困难，要在一开始就做对，否则后面很难扭转。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;应用程序：各类远程调用（例如：RPC、SQL、HTTP、Redis）的调用开销记录。最万金油的度量指标之一，能够在很多方面提供精确的定位和分析，Web 应用程序标配。常见于使用 P99/95/90。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;语言级别：内部分析记录，例如：Goroutines 数量、Panic 情况等，常常能发现一些意想不到的泄露情况和空指针调用。没有这类监控的话，很有可能一直都不会被发现。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;指标落地&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步完成了整个系统的度量指标规划后，第二步就是需要确确实实的把指标落地了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是统一基础框架的打点，系统组件的 exporter，大多涉及了公司级的跨多部门协作，这时候需要更多的耐心和长期主义和不断地对方向纠错，才能尝到体系建设后的果实。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;告警体系&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在完成监控指标和体系的建设后，告警如何做，成为了一大难题，再好的监控体系，闭环做不好，就无法发挥出很大的作用。因此我们给告警定义一些准则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;告警不要太多，否则会导致“狼来了”。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;告警出现时，应当要具体操作某些事情，是亟待解决的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;告警出现时，应当要进行某些智力分析，不应该是机械行为。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不需要人工响应/处理的告警规则，应当直接删除。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;告警出现时，你下意识要再观察观察的告警，要直接进行调整。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;告警应当足够的简单，直观，不需要猜。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来讲就是告警要少，事件需要解决，处理要人工介入。否则右拐自动化自愈恢复可能更香。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;告警给谁？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一个难题就是：谁诱发处理的告警，要通知给谁？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个很需要斟酌的问题，在告警的规范上，尽可能遵循最小原则，再逐级上报。也就是先告警给 on-call 人，若超出 X 分钟，再逐级上报到全业务组，再及其负责人，一级级跟踪，实现渐进式告警。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7085635359116023&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4iachwhMRhBibb9pv5Kyriary5qictcSlc0nwZUNNOYxyYxC4elFolvpu9iarMO7Vnzoc84SZiaFBwzVtgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1448&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;逐级上报，响应即跟踪，明确问题点的责任人。而逐级上报的数据来源，可通过员工管理系统来获取，在员工管理系统中有完整的上下级关系（类似 OA 审批上看到的流程节点），但如果该系统没有开放 API 之类的，那可能你只能通过其他方式来获取了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如像是通过企业微信获取部门关系和人员列表，再手动设置上下级关联关系，也可以达到目的，且在现实世界中，有可能存在定制化的诉求。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;规范建立&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使所以监控体系、指标落地、告警体系都建立起来了，也不能掉以轻心。实际上在成为事实标准后，你仍然需要尽快为告警后奔跑，将整个闭环搭建起来，也就是故障管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与公司内部的流程管理的同学或 QA，一起设立研发底线的规范，进行细致的告警分级识别，告警后的汇总运营分析，形成一个真正意义上的故障管理规范。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;否则最后可能会疲于奔命，人的时间精力总是有限的，而面对整个公司的监控告警的搭建，体系上与业务组的共建，督促告警响应，极有可能最后会疲于奔命，即使真的有一定用处，在杂乱无人收敛的告警中最后流于形式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;监控告警的体系生态做来有意义吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是必然的，成熟且规范的监控告警的体系生态是具有极大意义，可以提前发现问题，定位问题，解决问题。甚至这个问题的说不定还不需要你自己处理，做多组件的闭环后，直接实施自动化的服务自愈就可以了，安心又快快乐乐的过国庆节，是很香的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而故障管理的闭环实施后，就可以分析业务服务的告警情况，结合 CI/CD 系统等基础平台，每季度自动化分析实施运营报表，帮助业务发现更多的问题，提供其特有的价值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但，想真正做到上述所说的成熟且规范，业务共建，有难度，需要多方面认同和公司规范支撑才能最佳实现。因此共同认可，求同存异，多做用户反馈分析也非常重要。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>42a4a9047542322ebd3dc793fd94d968</guid>
<title>RocketMQ 进阶：事务消息</title>
<link>https://toutiao.io/k/ada62ci</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式消息选型的时候是否支持事务消息是一个很重要的考量点，而目前只有RocketMQ对事务消息支持的最好。今天我们来唠唠如何实现RocketMQ的事务消息！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apache RocketMQ在4.3.0版中已经支持分布式事务消息，这里RocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示。&lt;img data-ratio=&quot;0.4503464203233256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjnG5D5L80UwMEnch2lhFCU6S01vMG5DdeLS9icD5hIOXFZgmnQUzyUWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;866&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RocketMQ事务流程概要&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ实现事务消息主要分为两个阶段：正常事务的发送及提交、事务信息的补偿流程
整体流程为：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产者发送一个半消息给MQServer（半消息是指消费者暂时不能消费的消息）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端响应消息写入结果，半消息发送成功&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开始执行本地事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据本地事务的执行状态执行Commit或者Rollback操作&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果MQServer长时间没收到本地事务的执行状态会向生产者发起一个确认回查的操作请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者收到确认回查请求后，检查本地事务的执行状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据检查后的结果执行Commit或者Rollback操作
补偿阶段主要是用于解决生产者在发送Commit或者Rollback操作时发生超时或失败的情况。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RocketMQ事务流程关键&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;事务消息在一阶段对用户不可见
事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的，也就是说消费者不能直接消费。这里RocketMQ的实现方法是原消息的主题与消息消费队列，然后把主题改成 &lt;code&gt;RMQ_SYS_TRANS_HALF_TOPIC&lt;/code&gt; ，这样由于消费者没有订阅这个主题，所以不会被消费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何处理第二阶段的失败消息？在本地事务执行完成后会向MQServer发送Commit或Rollback操作，此时如果在发送消息的时候生产者出故障了，那么要保证这条消息最终被消费，MQServer会像服务端发送回查请求，确认本地事务的执行状态。当然了rocketmq并不会无休止的的信息事务状态回查，默认回查15次，如果15次回查还是无法得知事务状态，RocketMQ默认回滚该消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息状态
事务消息有三种状态：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TransactionStatus.CommitTransaction&lt;/strong&gt;：提交事务消息，消费者可以消费此消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TransactionStatus.RollbackTransaction&lt;/strong&gt;：回滚事务，它代表该消息将被删除，不允许被消费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TransactionStatus.Unknown&lt;/strong&gt; ：中间状态，它代表需要检查消息队列来确定状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先假设我们有这样一个需求：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户请求订单微服务 &lt;code&gt;order-service&lt;/code&gt; 接口删除订单（退货），删除订单后需要发送消息给用户服务 &lt;code&gt;account-service&lt;/code&gt;，用户微服务收到消息后会给用户账户增加余额。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个需求跟钱相关，肯定要保证消息的事务性，接下来我们根据上面的原理实现整个流程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基础配置&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者order-servcie和account-service都要引入RocketMQ相关依赖，增加RocketMQ的相关配置&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.rocketmq&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;rocketmq-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# within rocketmq&lt;/span&gt;&lt;br/&gt;&lt;span&gt;rocketmq:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  name-server:&lt;/span&gt; &lt;span&gt;xxx.xx.x.xx:9876;&lt;/span&gt; &lt;span&gt;xxx.xx.x.xx:9876&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  producer:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    group:&lt;/span&gt; &lt;span&gt;cloud-group&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;发送半消息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;order-service在执行删除订单操作时发送一条半消息给MQServer，发送半消息主要是使用 &lt;code&gt;rocketMQTemplate.sendMessageInTransaction()&lt;/code&gt; 方法，发送事务消息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(String orderNo)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; Order order = orderMapper.selectByNo(orderNo);&lt;br/&gt; &lt;span&gt;//如果订单存在且状态为有效，进行业务处理&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (order != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; CloudConstant.VALID_STATUS.equals(order.getStatus())) {&lt;br/&gt;  String transactionId = UUID.randomUUID().toString();&lt;br/&gt;  &lt;span&gt;//如果可以删除订单则发送消息给rocketmq，让用户中心消费消息&lt;/span&gt;&lt;br/&gt;  rocketMQTemplate.sendMessageInTransaction(&lt;span&gt;&quot;add-amount&quot;&lt;/span&gt;,&lt;br/&gt;    MessageBuilder.withPayload(&lt;br/&gt;      UserAddMoneyDTO.builder()&lt;br/&gt;        .userCode(order.getAccountCode())&lt;br/&gt;        .amount(order.getAmount())&lt;br/&gt;        .build()&lt;br/&gt;    )&lt;br/&gt;    .setHeader(RocketMQHeaders.TRANSACTION_ID, transactionId)&lt;br/&gt;    .setHeader(&lt;span&gt;&quot;order_id&quot;&lt;/span&gt;,order.getId())&lt;br/&gt;    .build()&lt;br/&gt;    ,order&lt;br/&gt;  );&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先先校验一下订单状态，然后发送消息给MQServer，这个逻辑大家都看得懂，主要是关注 &lt;code&gt;sendMessageInTransaction()&lt;/code&gt; 方法，源码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; TransactionSendResult &lt;span&gt;sendMessageInTransaction&lt;/span&gt;&lt;span&gt;(String destination, Message&amp;lt;?&amp;gt; message, Object arg)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; MessagingException &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (((TransactionMQProducer)&lt;span&gt;this&lt;/span&gt;.producer).getTransactionListener() == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;The rocketMQTemplate does not exist TransactionListener&quot;&lt;/span&gt;);&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   org.apache.rocketmq.common.message.Message rocketMsg = &lt;span&gt;this&lt;/span&gt;.createRocketMqMessage(destination, message);&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.producer.sendMessageInTransaction(rocketMsg, arg);&lt;br/&gt;  }&lt;br/&gt; } &lt;span&gt;catch&lt;/span&gt; (MQClientException var5) {&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; RocketMQUtil.convert(var5);&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法有三个参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;destination：目的地(主题)，这里发送给 &lt;code&gt;add-amount&lt;/code&gt; 这个主题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;message：发送给消费者的消息体，需要使用 &lt;code&gt;MessageBuilder.withPayload()&lt;/code&gt; 来构建消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;arg：参数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意，这里我们生成了一个transactionId，并放在header中跟消息一起发送（这里实际也可以构造成一个对象，放在arg里进行发送），作用后面再讲！&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;执行本地事务与回查&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MQServer收到半消息后会告诉生产者order-service确认收到半消息，这时候order-service需要执行本地事务，执行完本地事务后再告诉MQServer本地事务的执行状态，确认消息究竟是Commit还是Rollback。如果在告诉MQServer本地执行状态的时候出异常了还需要让MQServer能够回查到，怎么实现这一些列操作呢？&lt;img data-ratio=&quot;0.7412060301507538&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxj3QibVZ0koLBg4JckXpA1z003PvwDljjAYVC5goB6AnWOGsFrGYU2E4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;398&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ提供了 &lt;code&gt;RocketMQLocalTransactionListener&lt;/code&gt; 接口，本地事务监听器，这个接口类的实现如下：&lt;img data-ratio=&quot;0.2632135306553911&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjydfzgB9oiaicpcVWOd57ICeTJFmrDD2Mibfb1ayy81CfrBtL0D6CTdiagA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;946&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个方法 &lt;code&gt;executeLocalTransaction&lt;/code&gt; 为执行本地事务；第二个方法 &lt;code&gt;checkLocalTransaction&lt;/code&gt; 为检查本地事务的执行状态，也就是回查动作。有了这个接口类我们的执行逻辑清楚了，但是还有个问题：本地事务已经执行完成了，怎么去回查本地事务的执行结果呢？&lt;img data-ratio=&quot;0.5517241379310345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjFJCCaaZWfRiaaicmrlXd4VcJuV82icAicfjxZsELg0IXy0UNMxz65eDuyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;290&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在执行本地事务的时候同时生成一个事务日志，让本地事务与日志事务在同一个方法中，同时添加 &lt;code&gt;@Transactional&lt;/code&gt; 注解，保证两个操作事务是一个原子操作。&lt;strong&gt;这样如果事务日志表中有这个本地事务的信息，那就代表本地事务执行成功，需要Commit，相反如果没有对应的事务日志，则表示没执行成功，需要Rollback&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思路既然理顺了，咱们就开撸。&lt;img data-ratio=&quot;0.759493670886076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjicJkCics3WVeNZO6kEU5ibFnz2bbYj083lV1IVjWJnGnVqB83OqNq4rdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;395&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先创建一个日志表&lt;img data-ratio=&quot;0.26905829596412556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjrVVVoX2Nq9llpEAiaKLBKsTqQg6H9REWLuX7VicbKZqGBOfXOKtoTaRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;669&quot;/&gt;很简单的三个字段，主要是这个事务id，需要根据这个事务id回查事务，还记得我们在发送半消息时生成的事务id吗，就是干这个用的！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在生产者编写方法实现 &lt;code&gt;RocketMQLocalTransactionListener&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@RocketMQTransactionListener&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequiredArgsConstructor&lt;/span&gt;(onConstructor = @__(&lt;span&gt;@Autowired&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AddUserAmountListener&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;RocketMQLocalTransactionListener&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; OrderService orderService;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RocketMqTransactionLogMapper rocketMqTransactionLogMapper;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 执行本地事务&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RocketMQLocalTransactionState &lt;span&gt;executeLocalTransaction&lt;/span&gt;&lt;span&gt;(Message message, Object arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;执行本地事务&quot;&lt;/span&gt;);&lt;br/&gt;        MessageHeaders headers = message.getHeaders();&lt;br/&gt;        &lt;span&gt;//获取事务ID&lt;/span&gt;&lt;br/&gt;        String transactionId = (String) headers.get(RocketMQHeaders.TRANSACTION_ID);&lt;br/&gt;        Integer orderId = Integer.valueOf((String)headers.get(&lt;span&gt;&quot;order_id&quot;&lt;/span&gt;));&lt;br/&gt;        log.info(&lt;span&gt;&quot;transactionId is {}, orderId is {}&quot;&lt;/span&gt;,transactionId,orderId);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;//执行本地事务，并记录日志&lt;/span&gt;&lt;br/&gt;            orderService.changeStatuswithRocketMqLog(orderId, CloudConstant.INVALID_STATUS,transactionId);&lt;br/&gt;            &lt;span&gt;//执行成功，可以提交事务&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; RocketMQLocalTransactionState.COMMIT;&lt;br/&gt;        }&lt;span&gt;catch&lt;/span&gt; (Exception e){&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; RocketMQLocalTransactionState.ROLLBACK;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 本地事务的检查，检查本地事务是否成功&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RocketMQLocalTransactionState &lt;span&gt;checkLocalTransaction&lt;/span&gt;&lt;span&gt;(Message message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        MessageHeaders headers = message.getHeaders();&lt;br/&gt;        &lt;span&gt;//获取事务ID&lt;/span&gt;&lt;br/&gt;        String transactionId = (String) headers.get(RocketMQHeaders.TRANSACTION_ID);&lt;br/&gt;        log.info(&lt;span&gt;&quot;检查本地事务,事务ID:{}&quot;&lt;/span&gt;,transactionId);&lt;br/&gt;        &lt;span&gt;//根据事务id从日志表检索&lt;/span&gt;&lt;br/&gt;        QueryWrapper&amp;lt;RocketmqTransactionLog&amp;gt; queryWrapper = &lt;span&gt;new&lt;/span&gt; QueryWrapper&amp;lt;&amp;gt;();&lt;br/&gt;        queryWrapper.eq(&lt;span&gt;&quot;transaction_id&quot;&lt;/span&gt;,transactionId);&lt;br/&gt;        RocketmqTransactionLog rocketmqTransactionLog = rocketMqTransactionLogMapper.selectOne(queryWrapper);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; != rocketmqTransactionLog){&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; RocketMQLocalTransactionState.COMMIT;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; RocketMQLocalTransactionState.ROLLBACK;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor = RuntimeException.class)&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;changeStatuswithRocketMqLog&lt;/span&gt;&lt;span&gt;(Integer id,String status,String transactionId)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//将订单状态置位无效&lt;/span&gt;&lt;br/&gt; orderMapper.changeStatus(id,status);&lt;br/&gt;    &lt;span&gt;//插入事务表&lt;/span&gt;&lt;br/&gt; rocketMqTransactionLogMapper.insert(&lt;br/&gt;   RocketmqTransactionLog.builder()&lt;br/&gt;     .transactionId(transactionId)&lt;br/&gt;     .log(&lt;span&gt;&quot;执行删除订单操作&quot;&lt;/span&gt;)&lt;br/&gt;   .build()&lt;br/&gt; );&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这一块的代码逻辑都是在生产端，即Order-Server，大家不要搞错了&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消费消息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rollback的消息MQServer会给我们处理，我们只要关注Commit状态时消费端可以正常消费即可。在 &lt;code&gt;account-service&lt;/code&gt;监听消息，如果收到消息则给用户账户增加余额。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RocketMQMessageListener&lt;/span&gt;(topic = &lt;span&gt;&quot;add-amount&quot;&lt;/span&gt;,consumerGroup = &lt;span&gt;&quot;cloud-group&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RequiredArgsConstructor&lt;/span&gt;(onConstructor = @__(&lt;span&gt;@Autowired&lt;/span&gt;) )&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AddUserAmountListener&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;RocketMQListener&lt;/span&gt;&amp;lt;&lt;span&gt;UserAddMoneyDTO&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AccountMapper accountMapper;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 收到消息的业务逻辑&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onMessage&lt;/span&gt;&lt;span&gt;(UserAddMoneyDTO userAddMoneyDTO)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;received message: {}&quot;&lt;/span&gt;,userAddMoneyDTO);&lt;br/&gt;        accountMapper.increaseAmount(userAddMoneyDTO.getUserCode(),userAddMoneyDTO.getAmount());&lt;br/&gt;        log.info(&lt;span&gt;&quot;add money success&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;测试&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11811811811811812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjxLv8TF72nHOTTxY8xXibY4ibOo9l70USluxXHn85tKXKvMatVr4zVxsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;999&quot;/&gt;订单表有这样一条记录，用户为jianzh5，amount为200&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23542116630669546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjxvLMFAPHQZ1kJ4NdL2Seicez3K78BlcXZia75j3sWIGaCeJd33BrHNgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;463&quot;/&gt;用户表的记录，执行完成后jianzh5的账户应该变成250&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用删除订单接口，删除订单&lt;img data-ratio=&quot;0.31353919239904987&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxj6icJd3cxXCVe87TX2Cd5AAeZh1ffMEWSGNxACV9I72yHM9SKBcu9nAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;842&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送半消息&lt;img data-ratio=&quot;0.4354575163398693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjfB6mCicYDIibE05pXKtLoRhgtF0jWtoLmIib15VwjYbaPtHbQ2nNgR9rQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1224&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行本地事务，并生成事务日志&lt;img data-ratio=&quot;0.49115755627009644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjAUlYxMLGUQqLdMoCBe41Jj6wLF6icQfztf5WuP8libNvRH4Jp0sfutcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1244&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模拟异常情况
在发送Commit消息的时候我们用命令杀掉进程 &lt;code&gt;taskkill /pid 19748 -t -f&lt;/code&gt;，模拟异常！&lt;img data-ratio=&quot;0.3416757344940152&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjhNSgHw177hlb3a8Ivzl4mibjiaPmp4GvbD5Pe9Y7RguXD6oh82kDlSyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;919&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重新启动order-service，查看是否会执行回查动作&lt;img data-ratio=&quot;0.45143745143745145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxjxhmJZiajFSK3E2UeyqRLgDS5UibA1qOXNLavUUHZdSef0EQBJ0FooN1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1287&quot;/&gt;MQServer进行回查，检查事务日志，判断是否可以提交事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者消费事务消息，保证事务的一致性&lt;img data-ratio=&quot;0.1837916063675832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4iadbDkJB1sb7WHg913YQGxj3bFhlnZdPcF8qejB7zeJbOyGiaGS4GpMibth1RqzYGNJ24pUic32zAibHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用RocketMQ实现事务消息的过程还是很复杂的，需要好好理解开头的那张图，只有理解了事务消息的交互过程才能编写相应的代码！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bba2ac66fcedf9518eed5d876f4a0873</guid>
<title>Python 为什么不支持 switch 语句？</title>
<link>https://toutiao.io/k/78k43sd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;在这篇文章里，我们会聊一聊为什么 Python 决定不支持 switch 语句。&lt;/p&gt;&lt;p&gt;为什么想要聊这个话题呢？&lt;/p&gt;&lt;p&gt;主要是因为 switch 在其它语言中太常见了，而 Python 却不支持，这样的独特性本身就值得关注，而回答这个问题，也能更加看清 Python 在程序设计上的理念，了解 Python 在语法设计中的决策过程。&lt;/p&gt;&lt;p&gt;本文除了会详细分析 PEP-275 和 PEP-3103，还会介绍到 Python 最新的发展动态（PEP-622），即可能要引入的模式匹配（pattern matching）语法，相信这个话题会开阔大家的眼界，从而对 switch 语法有更为全面的认识。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、switch 是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在开始正题之前，我们需要先聊聊 switch 是什么？&lt;/p&gt;&lt;p&gt;有些同学可能会第一时间想到它……&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5533333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTOIJ4jkDR6QiaMnPO8445iaO7HicMjnWKTGU7bHvxMcFwX8KKLx0XFh8UMaJAKQRz7D20am7YOo7wcZg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;喂~喂~，麻烦收收心，别总想着游戏啦，我们要说的是编程语言中的 switch 语句。&lt;/p&gt;&lt;p&gt;一般而言，switch 的语法格式如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;switch&lt;/span&gt;(expression){&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; value1:&lt;br/&gt;       &lt;span&gt;// 语句&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;break&lt;/span&gt;; &lt;span&gt;// 可选&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; value2:&lt;br/&gt;       &lt;span&gt;// 语句&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;break&lt;/span&gt;; &lt;span&gt;// 可选&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;: &lt;span&gt;// 可选&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;// 语句&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用流程图来表示，大概是这样的：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.3410596026490067&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTOIJ4jkDR6QiaMnPO8445iaO7sYINqDhYiaxnDj3Gn9Ku8Em9iafVgDhUyAZc7oyPCxj2G5UPcuoYDxSQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;302&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;它的用法不难理解：switch 语句的值满足哪一个 case 情况，就会执行对应的代码块，执行时遇到 break 就跳出，否则就继续执行下一个 case 分支；一般会在最后放一个 default 分支，作为兜底。&lt;/p&gt;&lt;p&gt;大多数语言都提供了 switch 语句或者极其相似的东西，例如，在 C/C++/Java /Go 等静态语言中，它们都支持 switch-case 结构；在 Ruby 中有类似的 case-when 结构，在 Shell 语言中，有相似的 case-in 结构，在 Perl 中，有 switch-case-else……&lt;/p&gt;&lt;p&gt;switch 语句的好处是支持“单条件多分支”的选择结构，相比 if-else 的二分选择结构，在某些时候会更为简洁清晰。&lt;/p&gt;&lt;p&gt;但是，在 Python 中，我们看不到 switch-case 或者相近的语法结构，这是为什么呢？&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、Python 为什么不支持 switch?&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;官方文档中有一篇 FAQ 包含了这个问题：&lt;span&gt;Why isn’t there a switch or case statement in Python?&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6902173913043478&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTOIJ4jkDR6QiaMnPO8445iaO771QrgGNfCzchJX4j5ibzXicC4FsYfgY3epgFTjwgKrWfVguAITJ0YTdQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1288&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;FAQ 即 &lt;span&gt;Frequently Asked Questions&lt;/span&gt; 的缩写，表示常见问题，官方列了 27 个常见问题，完整清单在此：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247484706&amp;amp;idx=1&amp;amp;sn=7e15c72255495a0f6e8442f902153ff5&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;https://mp.weixin.qq.com/s/zabIvt4dfu_rf7SmGZXqXg&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;该文档给出了几个建议，告诉了我们几个 switch/case 的替代方案：&lt;/p&gt;&lt;p&gt;曾有人提出过一些提案（即 PEP-275 和 PEP-3103），想给 Python 引入 switch 语法，然而，对于“&lt;strong&gt;是否以及如何进行靶场测试&lt;/strong&gt;”，大家没有达成一致的共识。&lt;/p&gt;&lt;p&gt;靶场测试，即 range test，指的是对武器弹药的技术性能作各种测试验证，与药物的临床试验一样，都是在最终产品交付前的一项关键性测试。&lt;/p&gt;&lt;p&gt;官方文档对于“为什么 Python 不引入 switch”的解释，实际上来源于 Python 之父 Guido van Rossum 在 PEP-3103 中的意见：&lt;/p&gt;&lt;img data-ratio=&quot;0.547550432276657&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTOIJ4jkDR6QiaMnPO8445iaO7gTwlmqb3tYOuj5oGKWpRu56eVv5kibGaibpdDq1obtWV38ppKx8gGt6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1041&quot; title=&quot;&quot;/&gt;&lt;span&gt;出处&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;https://www.python.org/dev/peps/pep-3103&lt;/span&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;A quick poll during my keynote presentation at PyCon 2007 shows this proposal has no popular support. I therefore reject it.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我在 PyCon 2007 的主题演讲中做了一个快速的民意调查，结果表明这个提案没有得到广泛的支持。因此，我拒绝了它。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;简而言之，&lt;strong&gt;PEP 提案有了，语法实现也有了雏形，但是核心开发者们似乎没有达成一致意见，最终导致提案流产了。&lt;/strong&gt; &lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、PEP-275 与 PEP-3103 说了什么？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;PEP-3103 是在 2006 年提出的，PEP-275 则是在 2001 年提出的，它们的共同之处是提出了引入 switch 语句的某种必要性、分析了好几种备选的实现方案，然而，结局是都被拒绝了。&lt;/p&gt;&lt;img data-ratio=&quot;0.5551142005958292&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTOIJ4jkDR6QiaMnPO8445iaO7Hk0Qgx357HSpCykc0cibDf6ekYeUibrawicKXOhtIv0FDX0gGGNibPG00Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1007&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;span&gt;出处：&lt;/span&gt;&lt;span&gt;https://www.python.org/dev/peps/pep-0275&lt;/span&gt;&lt;/p&gt;&lt;p&gt;那么，我们就先来回顾一下核心开发者们都做出了哪些讨论，看一看如果 Python 要实现 switch 结构，会是怎么样子的？（PS：PEP 里还涉及其它内容，本文只摘取与 switch 直接相关的部分）&lt;/p&gt;&lt;p&gt;PEP-275 提出的语法结构如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;switch EXPR:&lt;br/&gt;    case CONSTANT:&lt;br/&gt;        SUITE&lt;br/&gt;    case CONSTANT:&lt;br/&gt;        SUITE&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;        SUITE&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 else 分支是可选的，如果没有它，并且前面的分支都不满足的话，就什么也不做。另外 case 值 constant 支持不同类型，因为 expr 表达式的类型是动态的。&lt;/p&gt;&lt;p&gt;PEP-275 还提出让 switch 不支持掉落（fall-through）行为，即每个 case 分支相互独立而完整，不用像 C 语言那样需要写 break。&lt;/p&gt;&lt;p&gt;该 PEP 还列举了一些其它的 issue：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重用现有关键字，不引入“switch”和“case”&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用新的关键字，避免与 C 的 switch 概念混淆&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持单分支多值选择（例如：case &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;: …）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;还有建议支持范围取值判断（例如：case 10..14: …）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;除了首选方案，该 PEP 还记录了几种风格各异的语法方案：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;case EXPR:&lt;br/&gt;    of CONSTANT:&lt;br/&gt;        SUITE&lt;br/&gt;    of CONSTANT:&lt;br/&gt;        SUITE&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;        SUITE&lt;br/&gt;&lt;br/&gt;case EXPR:&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; CONSTANT:&lt;br/&gt;         SUITE&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; CONSTANT:&lt;br/&gt;        SUITE&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;        SUITE&lt;br/&gt;&lt;br/&gt;when EXPR:&lt;br/&gt;    &lt;span&gt;in&lt;/span&gt; CONSTANT_TUPLE:&lt;br/&gt;        SUITE&lt;br/&gt;    &lt;span&gt;in&lt;/span&gt; CONSTANT_TUPLE:&lt;br/&gt;        SUITE&lt;br/&gt;    ...&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;     SUITE&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PEP-275 记录下了不少重要的思路和问题，为 PEP-3103 的出现做了很好的铺垫。&lt;/p&gt;&lt;p&gt;那么，我们再来看看由 Guido 编写的 PEP-3103 说了些什么吧。&lt;/p&gt;&lt;p&gt;它首先认可了 PEP-275 中的两个基础设定，例如，实现“隐式的 break”，不让 case 分支出现 fall-through 这种转移控制权的情况（其它语言似乎都要求显式地写 break）；else 分支是可选的，复用 else 关键字，而不用引入“default”。&lt;/p&gt;&lt;p&gt;对于 PEP-275 提倡的那种风格，Guido 比较认可，但也认为它的问题是缩进层次太多，因此建议减少代码分支缩进的空格数，例如本来缩进 4 空格，改为缩进 2 空格。&lt;/p&gt;&lt;p&gt;PEP-3103 还列举了另外三种实现方案，分析了它们的差异以及问题，具体内容从略，这里只给大家看看它们的风格：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# case 分支不缩进&lt;/span&gt;&lt;br/&gt;switch EXPR:&lt;br/&gt;case EXPR:&lt;br/&gt;    SUITE&lt;br/&gt;case EXPR:&lt;br/&gt;    SUITE&lt;br/&gt;....&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;    SUITE&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# switch 语句后不加冒号&lt;/span&gt;&lt;br/&gt;switch EXPR&lt;br/&gt;case EXPR:&lt;br/&gt;    SUITE&lt;br/&gt;case EXPR:&lt;br/&gt;    SUITE&lt;br/&gt;....&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;    SUITE&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 省略 case 关键字&lt;/span&gt;&lt;br/&gt;switch EXPR:&lt;br/&gt;    EXPR:&lt;br/&gt;        SUITE&lt;br/&gt;    EXPR:&lt;br/&gt;        SUITE&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;        SUITE&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在基础语法之外，Guido 花了很多篇幅来讨论扩展语法（Extended Syntax），即在一个 case 分支中实现匹配多个值的复杂情况：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;case EXPR, EXPR, ...:&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Guido 优选的&lt;/span&gt;&lt;br/&gt;case &lt;span&gt;in&lt;/span&gt; EXPR_LIST:&lt;br/&gt;&lt;br/&gt;case *EXPR:&lt;br/&gt;&lt;br/&gt;case [*]EXPR, [*]EXPR, ...:&lt;br/&gt;&lt;br/&gt;case *(EXPR, EXPR, ...):&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;他重点考虑到的问题包括：switch 中表达式的结果是元组或可迭代对象的情况、case 的值被看成元组解包的情况、在 case 分支作“*”星号操作……&lt;/p&gt;&lt;p&gt;接着，Guido 又用了非常非常多的篇幅来分析该如何实现 switch，其中讨论到的主要思路有：&lt;/p&gt;&lt;p&gt;PEP 中这部分的内容非常多，因为在每个思路上，Guido 还考虑到了好几种实现路径，这导致了他在复杂分析后的结论是：It is too early to decide（ 现在做决定为时尚早）。&lt;/p&gt;&lt;p&gt;阅读完 PEP-3103 后，我总体的感觉是：Guido 的思路非常发散、层次丰富，但是，缺少了他在面对其它问题时那“快刀斩乱麻”式的洞察力。&lt;/p&gt;&lt;p&gt;也就是说，在诸多的可能性方案中，他力求面面俱到，最终无法说服自己做出一个独裁的决定。阻力主要来自于他自己，而不是其他人。&lt;/p&gt;&lt;p&gt;不过，之所以会出现这种情况，也许跟他的预设立场有关：他似乎认为“Python is fine without a switch statement”，因此尽管写了很长的 PEP，但只是在把问题复杂化，把议题搁置起来。&lt;/p&gt;&lt;p&gt;最后，他在 PyCon 上做了一个小范围调查，借此“名正言顺”地拒绝了自己发起的 PEP，试图堵住众人的悠悠之口……&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4、未来会有 switch 语句么？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;归结起来，之所以 Python 没有 switch 语句，原因有：&lt;strong&gt;switch 的实现细节/功能点未经敲定、没有 switch 也挺好的、有其它不错的方法替代 switch、Guido 的小任性……&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;但是，我们还是要追问一句：&lt;strong&gt;未来会有 switch 语句么？或者类似的多分支选择结构？&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;为什么要有此一问呢？原因是有太多语言自带 switch 语句，而且也有很多人尝试编写提供 switch 功能的库（我记得在 &lt;em&gt;PyCoder&#x27;s Weekly&lt;/em&gt; 里曾见到过两次）。&lt;/p&gt;&lt;p&gt;我（Python猫）本人自始至终并不喜欢 switch，几乎可以肯定地说，Python 未来也不会有 switch，但是，它很可能会引入一个类似于 switch 且更为复杂的语法结构！&lt;/p&gt;&lt;p&gt;2020 年 6 月，PEP-622 被提出了，它建议引入在 Scala、Erlang 和 Rust 等语言中的模式匹配语法（&lt;strong&gt;pattern matching&lt;/strong&gt;）。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6333615580016935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTOIJ4jkDR6QiaMnPO8445iaO7yxy1dpjgHPtee1t0KyibgPEfvjj6OoCGOKXeH8ZroQtNzRRneRHicPBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1181&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;截至 2020 年 10 月，该 PEP 已被分解成另外三个 PEP（634-636），目前都处于草案阶段。考虑到核心开发者们的参与情况以及话题讨论的情况，这些提案极有可能会在未来版本（比如正在开发中的 3.10）中实现。&lt;/p&gt;&lt;p&gt;以一个求平均数的函数为例，模式匹配语法可以实现成这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;average&lt;/span&gt;&lt;span&gt;(*args)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    match args:&lt;br/&gt;        case [x, y]:           &lt;span&gt;# captures the two elements of a sequence&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (x + y) / &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;        case [x]:              &lt;span&gt;# captures the only element of a sequence&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; x&lt;br/&gt;        case []:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        case x:                &lt;span&gt;# captures the entire sequence&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; sum(x) / len(x)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;match-case 结构神似于 switch-case 结构，然而它基于模式（pattern）而非表达式（expression），因此有更多待考虑的细节问题，也有更为广阔的应用空间。&lt;/p&gt;&lt;p&gt;对此话题感兴趣的读者，建议去查阅这几个新的 PEP。&lt;/p&gt;&lt;p&gt;最后，让我们回到标题中的问题：&lt;strong&gt;Python 为什么不支持 switch 语句？&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;官方文档的 FAQ 对此问题有一个解答，告诉我们有几个不错的替代写法，同时也留下了一条线索：曾有 PEP 提议引入 switch，只是没有成功实现。&lt;/p&gt;&lt;p&gt;沿着这条线索，本文拆解了 PEP-275 和 PEP-3103 这两篇文档，带大家看到了 Python 社区里提出过的风格各异的 switch 方案，以及诸多的悬而未决的问题。&lt;/p&gt;&lt;p&gt;最后，我们还关注到了最新的 PEP-622 的动态，看起来 switch 的“孪生兄弟” match 语法有望引入到 Python 中！switch 话题的讨论似乎要终止了，但是另一个更大的话题正在进行中！&lt;/p&gt;&lt;section&gt;&lt;mp-qa class=&quot;js_uneditable custom_select_card qa_iframe&quot; data-pluginname=&quot;insertquestion&quot; data-id=&quot;1552477532275441665&quot; data-bizuin=&quot;MzUyOTk2MTcwNg==&quot; data-title=&quot;你有什么想说的呢？&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;本文属于“Python为什么”系列（Python猫出品），该系列主要关注 Python 的语法、设计和发展等话题，以一个个“为什么”式的问题为切入点，试着展现 Python 的迷人魅力。所有文章将会归档在 Github 上，欢迎大家给颗小星星，项目地址：&lt;span&gt;https://github.com/chinesehuazhou/python-whydo&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>