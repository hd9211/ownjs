<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6b636b9eaebb464527414216810bf75c</guid>
<title>春联专用喷胶，点击领券现价只需4.6元！</title>
<link>https://toutiao.io/k/1i9uqmb</link>
<content:encoded>&lt;div&gt;&lt;body data-spm=&quot;10720394/n&quot; id=&quot;readabilityBody&quot;&gt;
    
    
    
    
    
    
      
      
    
    
    
    
    
  &lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d40ba7b5bb696d353f0f2927d20c40cf</guid>
<title>JuiceFS 即将发布 1.0 并调整开源许可</title>
<link>https://toutiao.io/k/ggg0uey</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post_content markdown&quot;&gt;&lt;h2 id=&quot;开源一周年&quot;&gt;开源一周年&lt;/h2&gt;&lt;p&gt;JuiceFS 开始于 2017 年，是一款云原生分布式文件系统，旨在帮助企业解决多云、跨云、混合云环境下所面临的诸多挑战：数据安全和保护、大数据架构升级、海量小文件访问、Kubernetes 标准存储等。 JuiceFS 完全兼容 POSIX、HDFS、S3 访问协议，并提供 Kubernetes CSI 驱动，在全球公有云上均有全托管服务。为了更好的打造让开发者爱不释手的软件，我们于 2021 年 1 月 11 日在 GitHub 上开源了 JuiceFS。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;今天， JuiceFS 已经开源一周年了！&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;一年前的今天，我们将 JuiceFS 在 GitHub 上开源，初心其实很简单：&lt;strong&gt;希望通过开源让 JuiceFS 被更多的开发者知道、了解、并使用。&lt;/strong&gt;毕竟软件最大的价值还是被使用。开源后的 JuiceFS 让用户不再担心黑盒的云服务，用户可以自行下载代码，探索 JuiceFS 的无限可能；开发者可以查阅 JuiceFS 的代码，从最底层了解、熟悉、信任他，甚至可以参与到 JuiceFS 的打造中。我们希望营造一个互相尊重的社区文化，身处其中不仅可以使用 JuiceFS，也可以在这交流新场景、新玩法，还可以讨论 JuiceFS 的工程设计理念和参与未来方向的制定。&lt;/p&gt;&lt;p&gt;开发者们对 JuiceFS 开源的反馈也超出我们的预期，开源第一周就登上了 GitHub Trending、Hacker News、InfoQ 等以开发者为主要受众的的媒体平台。&lt;/p&gt;&lt;p&gt;经过一年的时间，JuiceFS 在社区和产品都取得了长足的进步，但行百里者半九十，我们深知坚持的难度，也将继续怀着开放和连接的心态砥砺前行。&lt;/p&gt;&lt;h2 id=&quot;产品全面升级-更加开放&quot;&gt;产品全面升级，更加开放&lt;/h2&gt;&lt;p&gt;JuiceFS 刚开源时，元数据引擎的选择只有 Redis。存储介质为内存的 Redis 在数据可靠性和扩展性上存在诸多挑战。我们将元数据引擎的相关代码进行了可插拔改造，引入了对关系型数据库和像 TiKV 这样的事务型 KV 存储的支持，解决了可靠性和可扩展性问题，给了用户更多的选择。&lt;/p&gt;&lt;p&gt;作为 JuiceFS 数据持久层的对象存储，我们也支持了近 40 种，基本涵盖了公有云、边缘云、私有云等环境中部署使用的常见种类。当然，如果有遗漏欢迎 GitHub 上发起 issue，我们将尽快支持。拓宽 JuiceFS 的生态和提升 JuiceFS 开放性是我们矢志不渝的追求。&lt;/p&gt;&lt;p&gt;最开始的 JuiceFS 只支持应用最广泛的 POSIX API，此后陆续支持了 HDFS、S3 API，和 Kubernetes CSI 和 Windows 操作系统，未来我们还将支持更多更灵活的访问方式。 这些协议点缀成线，将散落在企业内部的数据孤岛，编织成网，更好的帮助企业打通多态业务系统的数据，整合不同的技术体系，连接多云，帮助客户搭建更加开放的数据存储平台。&lt;/p&gt;&lt;p&gt;JuiceFS 还提供了元数据的备份和导入功能，让用户在「意外」面前更多一份保障和可靠。 这一功能给予了用户按照 JSON 格式进行备份的能力，提高数据可读性的同时，也保证了数据在不同元数据引擎间的可交换性。最后，可靠的 JuiceFS 还提供了 &lt;strong&gt;「回收站」&lt;/strong&gt; 的功能，在这里可以找到那些被误删除的数据。&lt;/p&gt;&lt;p&gt;除了在产品开放性上的持续投入，我们还将目光放到了文档的开放性和易用性上。我们深刻理解，文档是用户与产品之间重要的纽带！自 JuiceFS 开源以来，我们始终坚持高品质的技术与高品质的文档并行输出的原则。2021 年，我们对文档进行了三次完整迭代，实现了&lt;strong&gt;文档从「专业性」到「普适性」，再到「体验性」的持续蜕变。&lt;/strong&gt;优化文档的工作仍在继续，努力确保 JuiceFS 的文档能够 &lt;strong&gt;「让新用户马上用」，「让老用户放心用」&lt;/strong&gt;。除了文档的工作以外，在快速的版本迭代中，JuiceFS 也一直保持数据格式、通信协议的兼容性，保证版本的向前兼容，让用户可以平滑升级。&lt;/p&gt;&lt;p&gt;JuiceFS 开源的一年里，产品也有了巨大的变化，也让我们更加坚定走开源路线是无比正确的，因为只有开放的生态是最具生命力的。&lt;/p&gt;&lt;h2 id=&quot;丰富场景落地-生态共建&quot;&gt;丰富场景落地，生态共建&lt;/h2&gt;&lt;p&gt;JuiceFS 开源的一年里，依托我们的开源社区，我们完成了开发者和代码贡献、用户和使用场景的连接。&lt;/p&gt;&lt;p&gt;在短短的一年时间里，有超过 4400 多位的开发者给 JuiceFS 点了个赞。这些开发者不仅仅来自于中国，也有来自于欧洲、美洲大陆、非洲，甚至中东的地区的开发者。新冠疫情虽然隔断了我们物理上的联系，但开源社区让我们齐聚一堂，一起在过去的 2021年，为 JuiceFS 的社区添砖加瓦。过去的一年里有超过 40 位贡献者完成了超过 800 次 Pull Requests，这是我们通过 GitHub 和开发者群体完成的 800 次连接。在这 800 次连接的加持下，JuiceFS 发布了 16 次新版本，这些背后默默关注 JuiceFS 的社区用户，让我们压力倍增的同时也给我们满满的动力。&lt;/p&gt;&lt;p&gt;基于微信和 Slack 的社群，搭建了超过 1500 人的用户交流群组，参与了 9 场活动，大家从使用出发，满载而归的是 33 篇关于 JuiceFS 的技术内容和场景实践。在这里，我们连接了场景和用户。文件系统是各种应用开发的基石，如何与其他应用结合，提供杰出的表现和良好的体验，形成生态，是 JuiceFS 社区的重要工作。在过去的一年中，JuiceFS 已经在一些领域受到了大家的认可，取得了不错的进展。&lt;/p&gt;&lt;h3 id=&quot;大数据生态&quot;&gt;大数据生态&lt;/h3&gt;&lt;p&gt;JuiceFS 可以完全兼容 HDFS，与 Hadoop 生态无缝集成，一些客户已经替换了 HDFS实现存算分离的架构升级。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Apache Kylin 4.0 发布了使用 JuiceFS 构建集群的解决方案。&lt;/li&gt;&lt;li&gt;利用 ClickHouse 和 Elasticsearch 的数据生命周期特性，JuiceFS 可以轻松实现数据分层存储，为用户增效降本。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;ai-生态&quot;&gt;AI 生态&lt;/h3&gt;&lt;p&gt;JuiceFS 多访问协议的支持可以大量省去业务流程中数据迁移调度工作，与主流机器学习、深度学习训练框架全部兼容。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;旷视技术团队还贡献了 JuiceFS Python SDK，方便在 Serverless 环境中访问 JuiceFS 数据。&lt;/li&gt;&lt;li&gt;JuiceFS 缓存加速是 AI 训练场景最受欢迎的特性，PaddlePaddle 已经将 JuiceFS 集成到 Paddle Operator 中为训练加速。&lt;/li&gt;&lt;li&gt;云知声团队的伙伴为 Fluid 社区贡献了 JuiceFSRuntime。&lt;/li&gt;&lt;li&gt;向量搜索引擎 Milvus 也发布了基于 JuiceFS 构建分布式集群的解决方案。&lt;/li&gt;&lt;li&gt;Byzer 社区也将 JuiceFS 作为云原生文件系统集成到自己的解决方案中。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;kubernetes-生态&quot;&gt;Kubernetes 生态&lt;/h3&gt;&lt;p&gt;JuiceFS 非常适合作为 PV（PersistentVolume）使用，是容器原生存储(Container Native Storage)。社区提供了 CSI 驱动和全面的文档指南，而且已经入驻了 KubeSphere 应用商店，在 Rancher 和云托管的 Kubernetes 服务中使用也同样简单。&lt;/p&gt;&lt;p&gt;在使用 JuiceFS 的朋友，也希望把你的经验和问题反馈到 JuiceFS 社区，不仅能得到支持和帮助，还能让你的经验帮到很多人，这正是开源社区的价值和魅力。&lt;/p&gt;&lt;h2 id=&quot;多行业生产环境验证-juicefs-1-0-来了&quot;&gt;多行业生产环境验证，JuiceFS 1.0 来了&lt;/h2&gt;&lt;p&gt;对于存储系统而言，可靠性永远排在第一位。JuiceFS 创新性地将元数据和数据分别保存到成熟的数据库和对象存储中，一开始就有了可靠性保证，这也是众多科技公司在能够在 JuiceFS 发布半年内就投入生产环境并保证稳定运行的关键所在。依托于标准访问协议，JuiceFS 采用了开源社区已有的测试集来保证兼容性和可靠性，还有各种单元测试、压力测试、混沌测试和性能测试保障，在产品快速迭代的同时保证每次版本发布的高品质。&lt;/p&gt;&lt;p&gt;JuiceFS 开源的一年里，已经有小米、Shopee、理想汽车、知乎、航天宏图、尧信等多家厂商在生产环境中部署了 JuiceFS，稳定运行半年以上:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;小米用 JuiceFS 做 AI 平台的存储底座。&lt;/li&gt;&lt;li&gt;Shopee 将 JuiceFS 作为云平台的文件存储服务提供给各业务线，支持了多样的业务场景。&lt;/li&gt;&lt;li&gt;理想汽车用 JuiceFS 实现了数仓的存算分离。&lt;/li&gt;&lt;li&gt;知乎用 JuiceFS 把 Flink 流计算的启动加载提速 4 倍。&lt;/li&gt;&lt;li&gt;……&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;JuiceFS 已经稳定持续的运行多家互联网和 AI 企业的生产环境中，不仅仅为客户降本，更为客户提升数据使用的效率和缩短新业务上线的周期，当然内置的数据保护和加密也让客户大大宽心。在过去的一年里，每天在线的 JuiceFS 集群数量也稳步上升，从最初的几个，到现在的超过 500，保持了较高的增长速率。值得一提的是，这仅仅是我们有记录的数据，相信还有很多我们没联系到的用户。&lt;/p&gt;&lt;p&gt;在国内外互联网、自动驾驶、基因测序、金融科技、智能制造等多个行业，以及广大社区开发者的支持、验证和持续反馈之下，经过全面的评估和各类场景下的验证，&lt;strong&gt;JuiceFS 社区将于本周发布 JuiceFS v1.0-beta&lt;/strong&gt;，欢迎社区用户测试并给我们反馈，根据反馈改进后发布 v1.0-GA。&lt;/p&gt;&lt;h2 id=&quot;重新思考开源许可&quot;&gt;重新思考开源许可&lt;/h2&gt;&lt;p&gt;回到 2021 年发布之初，JuiceFS 只支持在挂载后通过 POSIX 方式访问数据，应用是通过内核来访问数据，并不需要直接跟 JuiceFS 打交道，应用并不会被 GPL 系列的许可影响，所以当时采用了文件存储界使用最广泛的 GPL 许可（AGPL v3）。&lt;/p&gt;&lt;p&gt;随着 JuiceFS 的不断迭代，引入了更多的访问协议和 SDK（S3 兼容的 HTTP 协议以及跟 HDFS兼容的 Java SDK），影响用户基于它们去开发商业产品。同时，也有一些开源社区和开发者希望将 JuiceFS 作为存储底座，整合到自己的项目中，但 AGPL v3 与其他开源协议（比如 Apache 协议）的兼容性不太好，阻碍了更多人去享受 JuiceFS 提供的多协议互通和高效缓存系统等诸多便利。&lt;/p&gt;&lt;p&gt;所以，为了我们的初心——打造开发者最喜欢的存储产品，&lt;strong&gt;Juicedata 团队决定自 JuiceFS v1.0 起将许可更改为 Apache 2.0&lt;/strong&gt;。&lt;/p&gt;&lt;h2 id=&quot;重新定义文件存储-未来可期&quot;&gt;重新定义文件存储，未来可期&lt;/h2&gt;&lt;p&gt;JuiceFS v1.0 是一个重要的里程碑，代表它可以被放心的使用于各种场景的生产环境，开始接受更多更严苛的挑战。之后社区仍将持续加大投入，持续为大家带来更多有价值的特性，比如呼声最高的配额管理，Snapshot，支持更多元数据引擎等。&lt;/p&gt;&lt;p&gt;随着数据规模的快速增长，分布式文件系统愈发重要。传统分布式文件系统都采用自底向上的一整套系统，复杂度高，难以掌握。&lt;strong&gt;JuiceFS 创新性地分离元数据和数据存储，并尽量复用已有的成熟数据库和对象存储等基础设施，访问协议也是同时兼容所有主流的接口，将分布式文件系统的系统复杂度和使用门槛大幅降低，重新定义了分布式文件系统的构建方式，通过一套体系和不同组件的搭配，可以满足不同规模和场景的非结构化存储需求。&lt;/strong&gt;同时，JuiceFS 是完全云原生的设计，可以跟云上的生态很好地衔接，符合云存储发展的大趋势，有非常广泛的应用前景。&lt;/p&gt;&lt;p&gt;尽管 JuiceFS 已经做了非常多的减法，尽量避免重复造轮子，打造成熟可靠的存储产品仍然需要巨大的工程投入。我们在过去一年里也进一步壮大了工程师团队，很多都是从 JuiceFS 社区的参与到加入 Juicedata 团队，也欢迎更多志同道合的同学们加入，一起开创分布式文件存储的新时代。&lt;/p&gt;&lt;p&gt;开源产品的研发，需要持续的资金投入，我们花了 4 年验证过的商业化服务也在快速增长，为 JuiceFS 的发展提供持续可靠的资金保障。开源是我们的星辰大海，商业化为它保障护航。&lt;/p&gt;&lt;p&gt;道阻且长，但行则将至！&lt;/p&gt;&lt;h2 id=&quot;用户寄语&quot;&gt;用户寄语&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;按姓氏首字母排序&lt;/p&gt;&lt;/blockquote&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cee6102e15d0e542a5f01c3dc3ea92f3</guid>
<title>摸清Git的门路，这22张图足够了！</title>
<link>https://toutiao.io/k/l7ititt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;微信搜索&lt;code&gt;逆锋起笔&lt;/code&gt;关注后回复&lt;code&gt;编程pdf&lt;/code&gt;&lt;br/&gt;领取编程大佬们所推荐的 23 种编程资料！&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Git 是程序员学习和工作都离不开发工具，也是非程序员好用的文档版本管理工具。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文图解 Git 中的最常用命令。如果你稍微理解 Git 的工作原理，这篇文章能够让你理解的更透彻。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;67&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span&gt;原文链接：https://marklodato.github.io/visual-git-guide/index-zh-cn.html&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基本用法&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;239&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.4282115869017632&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibqusjLdmEbIVyxtkjfdtVF9qLMkEkVD69ZwzCuOHiaEFczrkAtib8ic7JznA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的四条命令在工作目录、暂存目录(也叫做索引)和仓库之间复制文件。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;git add files 把当前文件放入暂存区域。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;git commit 给暂存区域生成快照并提交。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;git reset -- files 用来撤销最后一次git add files，你也可以用git reset 撤销所有暂存区域文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;git checkout -- files 把文件从暂存区域复制到工作目录，用来丢弃本地修改。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以用 git reset -p, git checkout -p, or git add -p进入交互模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以跳过暂存区域直接从仓库取出文件或者直接提交代码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;201&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.35978835978835977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibqud6LC2aicjNKDWT21Hia4rNsykKdUKvNLicCGEb17M3RSz3ica06iaGsJ26Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;git commit -a 相当于运行 git add 把所有当前目录下的文件加入暂存区域再运行。git commit.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;git commit files 进行一次包含最后一次提交加上工作目录中文件快照的提交。并且文件被添加到暂存区域。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;git checkout HEAD -- files 回滚到复制最后一次提交。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;约定&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后文中以下面的形式使用图片。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibqu7NiaX2TCRf2LmScVxMq6Vuuu27PCD5zQARVFmicaicOTqmf58KDHjsWFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;绿色的5位字符表示提交的ID，分别指向父节点。分支用橘色显示，分别指向特定的提交。当前分支由附在其上的HEAD标识。这张图片里显示最后5次提交，ed489是最新提交。main分支指向此次提交，另一个stable分支指向祖父提交节点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;命令详解&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Diff&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有许多种方法查看两次提交之间的变动。下面是一些示例。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibqulXh7n4XFXW9Su6bIuaYrO1QVSG0DUx3XQV39r47DtTibzpKMWybdCaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Commit&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提交时，git用暂存区域的文件创建一个新的提交，并把此时的节点设为父节点。然后把当前分支指向新的提交节点。下图中，当前分支是main。在运行命令之前，main指向ed489，提交后，main指向新的节点f0cec并以ed489作为父节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibquicW9XtH5x8uZYXgxTibAzI6NMHyYQicTQpx088lCjODPjyntB6fxcqEwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即便当前分支是某次提交的祖父节点，git会同样操作。下图中，在main分支的祖父节点stable分支进行一次提交，生成了1800b。这样，stable分支就不再是main分支的祖父节点。此时，&lt;strong&gt;合并&lt;/strong&gt; (或者 &lt;strong&gt;衍合&lt;/strong&gt;) 是必须的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibquaQAps6sd0gF62lnMliafhlMU1JnZ0hwmroPmw3zA4mWBYSpS6JEPbAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想更改一次提交，使用 git commit --amend。git会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibquVBHmp05AuxQYOLNbyISvKFSpibicGXcN80BFQDGMfWeuFniaekxQw98Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个例子是分离HEAD提交,后文讲。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Checkout&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;checkout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当给定某个文件名（或者打开-p选项，或者文件名和-p选项同时打开）时，git会从指定的提交中拷贝文件到暂存区域和工作目录。比如，git checkout HEAD~ foo.c会将提交节点HEAD~(即当前提交节点的父节点)中的foo.c复制到工作目录并且加到暂存区域中。（如果命令中没有指定提交节点，则会从暂存区域中拷贝内容。）注意当前分支不会发生变化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibquYRJlVeV37BX7p2RjOnhiaicKrXmVA5cET0wsFEtibEmiaicia99uvrBhicDog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当不指定文件名，而是给出一个（本地）分支时，那么HEAD标识会移动到那个分支（也就是说，我们“切换”到那个分支了），然后暂存区域和工作目录中的内容会和HEAD对应的提交节点一致。新提交节点（下图中的a47c3）中的所有文件都会被复制（到暂存区域和工作目录中）；只存在于老的提交节点（ed489）中的文件会被删除；不属于上述两者的文件会被忽略，不受影响。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibquwAYoaS7XxctZHcMJRd9X2Uj0XuJJvEu97JCZE9zaicxrlv0icDxaIhAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、SHA-1值或者是像main~3类似的东西，就得到一个匿名分支，称作detached HEAD（被分离的HEAD标识）。这样可以很方便地在历史版本之间互相切换。比如说你想要编译1.6.6.1版本的git，你可以运行git checkout v1.6.6.1（这是一个标签，而非分支名），编译，安装，然后切换回另一个分支，比如说git checkout main。然而，当提交操作涉及到“分离的HEAD”时，其行为会略有不同，详情见在下面。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibqu2YZpLEkZIPkhQt9QhMSDgZEqqKRmUfJ88OEAJ4wHR2VEm7N4icOFN7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;HEAD标识处于分离状态时的提交操作&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当HEAD处于分离状态（不依附于任一分支）时，提交操作可以正常进行，但是不会更新任何已命名的分支。(你可以认为这是在更新一个匿名分支。)&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibqua9280QsWR9xas8oZ5VVqTicr8mKI9Xw4uicksmSMABnDxwXn2TJicQExQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一旦此后你切换到别的分支，比如说main，那么这个提交节点（可能）再也不会被引用到，然后就会被丢弃掉了。注意这个命令之后就不会有东西引用2eecb。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibqupnjPcO08ibU5I35DVVPsx6y7KpbIklBRonjWOFDibZAKQuIMOpqVDm6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果你想保存这个状态，可以用命令git checkout -b name来创建一个新的分支。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibquCxouWHoFCoQH8trhDRvSYXia7qjpAskdzFgpIwmGzMretUuwwsUAvBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Reset&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;reset命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不给选项，那么当前分支指向到那个提交。如果用--hard选项，那么工作目录也更新，如果用--soft选项，那么都不变。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibquR2ssrwZCkzWpAicgu6ka8coVOwia46EHpmnmibVjicrbxF6bX4VXfPiaLEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有给出提交点的版本号，那么默认用HEAD。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用--hard选项，工作目录也同样。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibqu4aYibTEhy50rlJC7foIuM354xEGwPDa5wpVRkoUkZ2l8STF4xob4hjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果给了文件名(或者 -p选项), 那么工作效果和带文件名的checkout差不多，除了索引被更新。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibqul6v6bPIWC2R2Hgq5RdurdLs2AkW0aZvZJz3EqMbo3hkb2G7T78VZibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Merge&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;merge 命令把不同分支合并起来。合并前，索引必须和当前提交相同。如果另一个分支是当前提交的祖父节点，那么合并命令将什么也不做。另一种情况是如果当前提交是另一个分支的祖父节点，就导致fast-forward合并。指向只是简单的移动，并生成一个新的提交。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibqufNibdMOHpQeibRTtmOmNAkW2jGcMl1UsDWeuw2N4sKjrXDckg2FR2BFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;否则就是一次真正的合并。默认把当前提交(ed489 如下所示)和另一个提交(33104)以及他们的共同祖父节点(b325c)进行一次三方合并。结果是先保存当前目录和索引，然后和父节点33104一起做一次新提交。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibqu7GCEon8ZIjiaUnX3OOwibRJJnrPmdTwibGAHDibh9sthaYCjvYAFGAr27g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Cherry Pick&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cherry-pick命令&quot;复制&quot;一个提交节点并在当前分支做一次完全一样的新提交。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibquoRiat32geHjtWMakEDd8Ldr65lLxb9zFN5aSR8ub2ogDeFPwibr6wFBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Rebase&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;衍合是合并命令的另一种选择。合并把两个父分支合并进行一次提交，提交历史不是线性的。衍合在当前分支上重演另一个分支的历史，提交历史是线性的。本质上，这是线性化的自动的 cherry-pick&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibqunYS5PT91Cgu74kKP9HK1biaUCxs7rvWT49u5OZIA0MAbLoTEIxicEKpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的命令都在topic分支中进行，而不是main分支，在main分支上重演，并且把分支指向新的节点。注意旧提交没有被引用，将被回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要限制回滚范围，使用--onto选项。下面的命令在main分支上重演当前分支从169a6以来的最近几个提交，即2c33a。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;325&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5832414553472988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v1JN0W4OpXjuEjicbH8PQibIRkiaNHr9ibqu8oVsj0EWGa0IEXc1USnHJfl7GKJDbHkiaZj5k3XdwTSwZhfibcq4gqWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样有git rebase --interactive让你更方便的完成一些复杂操作，比如丢弃、重排、修改、合并提交。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;技术说明&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件内容并没有真正存储在索引(.git/index)或者提交对象中，而是以blob的形式分别存储在数据库中(.git/objects)，并用SHA-1值来校验。索引文件用识别码列出相关的blob文件以及别的数据。对于提交来说，以树(tree)的形式存储，同样用对于的哈希值识别。树对应着工作目录中的文件夹，树中包含的 树或者blob对象对应着相应的子目录和文件。每次提交都存储下它的上一级树的识别码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用detached HEAD提交，那么最后一次提交会被the reflog for HEAD引用。但是过一段时间就失效，最终被回收，与git commit --amend或者git rebase很像。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;逆锋起笔&lt;/code&gt;是一个专注于程序员圈子的技术平台，你可以收获&lt;code&gt;最新技术动态&lt;/code&gt;、&lt;code&gt;最新内测资格&lt;/code&gt;、&lt;code&gt;BAT等大厂大佬的经验&lt;/code&gt;、&lt;code&gt;增长自身&lt;/code&gt;、&lt;code&gt;学习资料&lt;/code&gt;、&lt;code&gt;职业路线&lt;/code&gt;、&lt;code&gt;赚钱思维&lt;/code&gt;，微信搜索&lt;code&gt;逆锋起笔&lt;/code&gt;关注！&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;pre ng-bind-html=&quot;message.MMActualContent&quot;&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;往期阅读：&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247493238&amp;amp;idx=1&amp;amp;sn=b92e65ee96d1c998d823b55d7fafc234&amp;amp;chksm=fa3f072dcd488e3b997e0b9b4b48f5c4de6513c91fd46a4d1bde7bb89bf61af7c319e2d5dfff&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;在 GitHub 上提交代码必备指南！&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247491813&amp;amp;idx=1&amp;amp;sn=44468a554a5ecf7a3b7a805d427c7b10&amp;amp;chksm=fa3f01becd4888a8305fbb96fd4baa784fdfe80302a480b03e4ea303af2b11d23424239b33a1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;程序员必备的 10 大 GitHub 仓库&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247490214&amp;amp;idx=2&amp;amp;sn=93e7b9a3b24e45ff02ecadf251595bcb&amp;amp;chksm=fa3cfbfdcd4b72eb393a856ba99cefac5cf3eed462b4d9ee3e71e1c51d7adcef1884509510d0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;万字详解！Git 入门最佳实践&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247488785&amp;amp;idx=2&amp;amp;sn=c504f26ab3ea3fb6e7bb84470862412c&amp;amp;chksm=fa3cf44acd4b7d5c831364b3ac63164e18ce2a4a904d27a5ad909c87100754cdb9842699d2d4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;开眼了，腾讯是如何使用 Git 的 ？&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247488366&amp;amp;idx=1&amp;amp;sn=36dbc2b3480c97ce7d8f6e12e367193a&amp;amp;chksm=fa3cf235cd4b7b23d1bd67fb3e4730748ba4eb43d439c4b1acaa33cd2357e56527224b7d7aa5&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;提高 Github下载速度到 2MB/s&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hs540iaTKoaJzr8mCunJ8fiaLHTVy5ic53H2dSVXKlA7iaibMyl7qJNTePsPptc1CdmciaD2PmhG5J98xjRicQ3Ob0diaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span data-darkmode-bgcolor-15865441435016=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15865441435016=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15865441435016=&quot;rgb(255, 21, 21)&quot; data-darkmode-original-color-15865441435016=&quot;rgb(255, 0, 0)&quot; data-style=&quot;max-width: 100%; color: rgb(255, 0, 0); font-family: Optima-Regular, PingFangTC-light; font-weight: 700; letter-spacing: 0.544px; widows: 1; word-spacing: 2px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__37&quot; data-darkmode-bgcolor-15866879525102=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15866879525102=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15866879525102=&quot;rgb(255, 21, 21)&quot; data-darkmode-original-color-15866879525102=&quot;rgb(255, 0, 0)&quot; data-darkmode-bgcolor-158705654000210=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-158705654000210=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-158705654000210=&quot;rgb(255, 21, 21)&quot; data-darkmode-original-color-158705654000210=&quot;rgb(255, 0, 0)&quot; data-darkmode-bgcolor-15870565400370=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15870565400370=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15870565400370=&quot;rgb(255, 21, 21)&quot; data-darkmode-original-color-15870565400370=&quot;rgb(255, 0, 0)&quot;&gt;支持下 &lt;/span&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1.764&quot; data-type=&quot;gif&quot; data-w=&quot;250&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ibsfLhQMgy09JhlUaCQZm4kXHBSlPxPOOpOcfiaNmJRjoem28z1x3CbXNG2eQNK8Tic1Yyf1WqKZ3VibvSicNtwcguQ/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>54e0fda7ac7efe5b532f790f058ca1e3</guid>
<title>Spark作业不知道该如何分配资源怎么办？</title>
<link>https://toutiao.io/k/visuj3y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;前几天有好几个朋友问我关于spark作业分配资源的问题：即在提交作业的时候，不知道该分配多少资源比较好？我的回答是&lt;strong&gt;靠经验&lt;/strong&gt;，仔细想想靠经验这等于不是没说吗，总有一些方法论或者思路的吧。所以就有了这篇文章，下笔的时候着实是不知道该怎么写，所以在网上搜索了一下，看看大佬们是怎么回答的。赶巧了不是，还真发现3年前就有人问过这个问题。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0279465370595382&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/fBHtXf4CBicKb7VEdX18d26C7a2MAh2TDufX3OykhZUzc1Y2Ztm7Jjyp6iac7bkqdNnyBzicJLBfKbm8tibFMKaQog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot;/&gt;&lt;/p&gt;&lt;p&gt;看了下评论，我感觉我能看懂，但不知道朋友们是否能看懂，所以我想还是要再详细啰嗦一下吧&lt;/p&gt;&lt;p&gt; &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/fBHtXf4CBicKb7VEdX18d26C7a2MAh2TD2c8XbibyHHznesTuR6iagGpQwYm42cx5UzZnLevzZn2yDaBDic6baa06A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;240&quot;/&gt;&lt;/p&gt;&lt;p&gt;首先呢，spark官网给我们提供了一些硬件层面的建议，先上链接https://spark.apache.org/docs/latest/hardware-provisioning.html。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是这个文章并没有很细粒度介绍应用级别该如何分配资源。不过涉及到的几个方向可以参考一下，比如&lt;strong&gt;内存，CPU&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先来复习一下spark涉及到这两块部分参数如下：&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;--num-executors/(SparkSQL中是spark.executor.instances 参数)&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;该参数代表了作业使用的总共executor个数&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;--driver-memory/(SparkSQL配置的是spark.driver.memory参数)&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;该参数代表了Driver端所消耗的内存，通常Driver端不会消耗太多资源，所以不需要给太多资源。&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;--executor-memory(SparkSQL配置的是spark.executor.memory参数)&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;该参数代表了每个executor所占用的内存&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;--executor-cores/(SparkSQL配置的是spark.executor.cores参数)&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;该参数代表了一个executor中能够并行执行的task数（注意并行和并发的区别！）&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常一个Spark作业所消耗的总内存数&amp;gt;=(spark.executor.instances)*(spark.exector.memory)；&lt;/p&gt;&lt;p&gt;所占用的CPU个数&amp;gt;=（spark.executor.instances）*(spark.exector.cores)。&lt;/p&gt;&lt;p&gt;这里之所以要用大于，是因为AppMaster也要占用资源的！扯到AppMaster，那需要再复习一下Yarn部分的两个参数：&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;yarn.nodemanager.resource.memory-mb&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;该参数表示的是nm可供Yarn使用最大可用内存&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;yarn.nodemanager.resource.cpu-vcores&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;该参数表示的是nm可供yarn使用的最大虚拟cpu数量&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一般在实际生产环境中，yarn可分配的总资源肯定是已经分配好了的。甚至是会有单独的spark作业队列（这里也要看yarn的调度模式，是fair，还是fifo，还是capacity）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们这里先举个例子来说明下：假设我们有一个裸集群，共有6个节点，每个节点都是16c 64g的配置（真实情况下每个节点的配置可能是参差不齐的）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是我们不可能把所有的资源全分配到yarn上，还是要留一部分作为系统运转的，那么每个节点留1C 1G 好了，采取极限的方式。最后每个节点可供yarn分配的资源如下：&lt;/p&gt;&lt;p&gt;yarn.nodemanager.resource.memory-mb=63g&lt;/p&gt;&lt;p&gt;yarn.nodemanager.resource.cpu-vcores=15&lt;/p&gt;&lt;p&gt;那么总资源就是all_memory=63*6=378g；all_cpu=6*15=90c&lt;/p&gt;&lt;p&gt;我们假设每个Executor并行度为5，那么就需要90/5=18个executor，但是需要留一个给AppMaster，所以--num-exectors=17；刚才算下来总共需要18个Executor，一共6个节点，平均每个节点是启动3个exector，一个节点是63g，那么每个executor可占用内存就是21g，请注意哦：每个executor并不是把21g全部给作业用，还要留一部分资源用来存储栈，buffer之类的开销以此来保证稳定性，也就是常说的堆外内存，通过spark.executor.memoryOverhead参数来设置这块的开销，其值=max(384mb,0.1*executorMemory)。因此这部分堆外内存=max(384mb,0.1*21)~=2g。那么堆内内存=21-2=19g。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里用表格来汇总一下：&lt;/p&gt;&lt;p&gt;也就是说在提交作业的时候，其参数配置值不能大于以下值（这里的例子是假设把资源全给你的任务去用！）:&lt;/p&gt;&lt;pre data-language=&quot;shell&quot;&gt;--executor-cores / spark.executor.cores = 5&lt;br/&gt;--executor-memory / spark.executor.memory = 19&lt;br/&gt;--num-executors / spark.executor.instances = 17&lt;/pre&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;节点数&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;内存/每节点&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;CPU/每节点&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Yarn可分配最大内存数&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Yarn可分配最大CPU&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;假设每个executor并行度数&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;总executor数&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;实际干活的executor数&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;每个节点可启动的executor数&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;每个executor占用的内存&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;堆外内存&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;实际干活所用到的内存&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;6&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;64g&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;16C&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;63g*6=378g&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;15C*6=90C&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;5&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;90C/5=18&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;18-1=17&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;18/6=3&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;63g/3=21g&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;max(384mb,0.1*21g)=2g&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;21g-2g=19g&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;9&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;90c/9=10&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;10-1=9&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;10/6~=2&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;63g/~=2~=37g&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;max(384mb,0.1*37g)=3g&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;37g-3=34g&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可能有朋友会困惑，为什仫每个executor并行度设置为5，当然也可以调大。如果调大每个executor的并行度，也相当于是提高了并行能力，这样的话就减少了task来回轮询的次数，比如你有100个task，每个executor执行20个task，那么要轮询5次；如果每个executor设置50个task，那么要轮询2次；这样一来就会增大每个executor所持有的内存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其实可以按照前面论坛里提到的一种评估方式就是按照task数量来倒推，官方建议一个cpu core是处理2~3个task。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20710059171597633&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/fBHtXf4CBicKb7VEdX18d26C7a2MAh2TDwfSThXMMEJFGhibpTjm2Lpy2oCOuPxYopVyYNWZF4T7f8a8DQReG46w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么假设有100个task，最多需要50c，还是按照上面的例子，这个时候就要看你是采取每个节点均摊的方式呢，还是某几个节点集中处理。采取何种方式还要结合你实际处理的数据量和计算复杂逻辑（因为这里还要思考网络消耗和本地化计算，每个节点的负载情况等等因素），当然通常情况下是采取均摊的方式，那么每个节点大概会使用8c。那么每个节点启动几个executor呢？是启动一个executor，还是2个executor，每个executor，每个executor大概占用多大内存呢？这个时候就要看你的代码逻辑是计算多一些还是缓存多一些。这里就涉及到内存模型的东西了，不知道内存模型的朋友再复习一下我原来写的文章：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4MDkzMDE4Nw==&amp;amp;mid=2247484700&amp;amp;idx=1&amp;amp;sn=4ef0171bd8b3fe97932cf379f06787f6&amp;amp;chksm=fd4e1af8ca3993ee5808c0e563366236a4faaf7cb9307bcdea8256daa23d2008433e98bf7d36&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Tungsten On Spark-内存模型设计&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Tungsten On Spark-内存模型设计&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;尽管以上资源分配都已经评估好了，但并不代表后续不需要优化了，不然网上怎么会有那么多优化文章，同时还要注意团队协作资源，不能把所有的资源都给你用，不然别人还怎么干活？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/fBHtXf4CBicKb7VEdX18d26C7a2MAh2TDJYKvjRWB66Ahza2VNePPXnibLQWrbIenwu1G0KlTiaUL586ZUEX1drYA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;270&quot;/&gt;&lt;/p&gt;&lt;p&gt;所以还要在你评估的资源上再缩减一部分，这样一来一回可能需要不断的调整，这也是为什仫很多人问到怎么分配资源的时候，都会说一句靠经验！&lt;/p&gt;&lt;p&gt;小编觉得这玩意真的是没有公式可套用的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/fBHtXf4CBicKb7VEdX18d26C7a2MAh2TD8icGwn5o0MuHrpep5VkfI0gTUmIaGpzsOs1jYKlgic3U843S8a4aS9Lg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;240&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果你有更好的分配资源的方法论或者有哪里写的不对的地方，欢迎大佬联系我分享给其他小伙伴们。&lt;/p&gt;&lt;p&gt;如果你有其他困扰的问题，欢迎骚扰我~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.3293768545994065&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/fBHtXf4CBicLd8whjPgKlmjshdhAS8O4EWI3ribibuWdbHJ52hacv09JKnnwDgRPzU0K2JDI392PxuhhfcFwH0iaqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;674&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;参考:&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e1b656097578f6c188dd026240e0074e</guid>
<title>【Rust日报】2022-01-10 使用 Nom 解析文本</title>
<link>https://toutiao.io/k/pa3290s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left js_a11y_comma js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI1MjAzNDI1MA==&amp;amp;action=getalbum&amp;amp;album_id=1832971445459615749#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1832971445459615749&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#Rust日报&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;243个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;strong&gt;&lt;span&gt;使用 Nom 解析文本&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;section&gt;本教程是关于 Nom 的，它是我最喜欢的Rust解析库。它使用解析器组合子方法:开始编写匹配单个数字或字符的小型解析器。这些将成为更大的解析器的构建块，用于匹配，比如日期或电话号码。通过将许多小型解析器组合在一起，您可以构建一个大型解析器，将文件或流解码为漂亮的Rust结构和枚举。在本教程中，我们将使用Nom解析输入文件到一个Advent of Code的谜题。&lt;/section&gt;&lt;section&gt;原文链接: https://blog.adamchalmers.com/nom-chars/&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;Bevy是如何使用 Rust traits 来添加标签的&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;section&gt;出于好奇，作者最近开始关注Bevy的开发，Bevy是一个用Rust编写的游戏引擎。今天作者想谈谈Bevy如何使用Rust特性让用户非常方便地为元素添加标签。&lt;/section&gt;&lt;section&gt;注意: 这里的实现实际上是非常通用的, 您可以很容易地将其应用到任何其他Rust项目&lt;/section&gt;&lt;section&gt;原文链接: https://deterministic.space/bevy-labels.html&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;Serde Playground&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;section&gt;这是一个 Serde Playground, 上面可以快速验证自己的序列化结果.&lt;/section&gt;&lt;section&gt;原文链接: https://hkalbasi.github.io/serde-rs.github.io/playground.html&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;Rexie: IndexedDB wrapper&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;section&gt;Rexie 是一个易于使用的、基于特性的的 IndexedDB 包装器，可以编译成 webassembly。&lt;/section&gt;&lt;section&gt;github 地址: https://github.com/devashishdxt/rexie&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;cargo-xcodebuild: 编译和运行 iOS 的 apps.&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;section&gt;让 cargo 编译和运行 iOS 的 apps.&lt;/section&gt;&lt;section&gt;例如, 只要很小的改动,就可以使用 xcodebuild 来运行 &lt;code&gt;bevy/miniquad/wgpu/etc..&lt;/code&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Cargo.toml&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;[lib]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;crate-type&lt;/span&gt; = [&lt;span&gt;&quot;staticlib&quot;&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;&lt;br/&gt;[package.metadata.ios]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;build_targets&lt;/span&gt; = [&lt;span&gt;&quot;aarch64-apple-ios&quot;&lt;/span&gt;, &lt;span&gt;&quot;aarch64-apple-ios-sim&quot;&lt;/span&gt;, &lt;span&gt;&quot;x86_64-apple-ios&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;lib.rs&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;#[no_mangle]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;pub&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;C&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main_rs&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// start game code here&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;运行步骤:&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;启动一个模拟器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cargo xcodebuild run&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;--&lt;/section&gt;&lt;section&gt;From 日报小组 BobQin，FBI小白&lt;/section&gt;&lt;section&gt;社区学习交流平台订阅：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Rustcc论坛: 支持rss&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;微信公众号：Rust语言中文社区&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>