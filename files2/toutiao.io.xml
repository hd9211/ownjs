<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1adc0ba121054fdc747a967b012b99ac</guid>
<title>开源｜基于 Vue 开发的可视化商城搭建平台</title>
<link>https://toutiao.io/k/48imbcu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断。&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;扫描下方二维码&lt;/span&gt;，即刻加入！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个基于 Vue 开发的可视化商城搭建平台，包括多页面可视化构建、JSON Schema 生成器（可视化搭建物料控制面板），实现组件流水线式标准接入平台。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最新版本使用 uni-app 重构物料、模板项目，支持生成 H5、小程序多端商城。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.0773333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavibCSiaxHO1EIWViadicfiaJfeFmJIiciaVjvXJTOBnLzoTSicibvJvQbXkcRgFIicia0JzeEgLH2mLIhZqhukMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f4e777e0f422683e248d61e5ca9fb9a0</guid>
<title>用 vscode 写 C/C++ 代码</title>
<link>https://toutiao.io/k/e3l7be3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/otHvoL6neeIxIugZwRtMH5VUj2nppdvm3sGbAq6eHwb2SOd1wlEibUiceiaAfPl39lhaZQ0TCHzHDwr2G8ERvzOiaw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;最近用上了 MacBookPro M1，使用 &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjMxNzQ0MQ==&amp;amp;mid=2651106013&amp;amp;idx=1&amp;amp;sn=77921f12bcea5baa71bc4489465d5484&amp;amp;chksm=813c4733b64bce252eec22f93038e1696568208be334549b1c2c77506e43a46ae40f8399e3f4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;dotfile&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;dotfile&lt;/a&gt;&lt;span&gt; 配置好基本环境后，发现我的 vscode 里 C/C++ 开发环境还没配置好。&lt;/span&gt;&lt;span&gt;一直以来，vscode 都是我的主力 C/C++ 开发环境，这其中离不开 cquery 插件。&lt;/span&gt;&lt;span&gt;2018 年我曾写过一篇文章&lt;/span&gt;&lt;span&gt;：《&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjMxNzQ0MQ==&amp;amp;mid=2651105907&amp;amp;idx=1&amp;amp;sn=e3f5009a5ea5049aebf590afe48078fe&amp;amp;chksm=813c479db64bce8babe5f45eda9eb20044072a4a2ce574d2b2007ac9c0a0e2aba6f7557111fc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;神器：VSCode 的 cquery 插件&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;神器：VSCode 的 cquery 插件&lt;/a&gt;&lt;span&gt;》&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;cquery 在头文件搜索，符号跳转，代码提示和补全等方面都令人满意。甚至在 V8 这样的大型仓库上，官方也有说明如何配合 cquery 进行开发 V8(https://v8.dev/docs/ide-setup#visual-studio-code-and-cquery)。&lt;/p&gt;&lt;p&gt;几年过去了，今天在 M1 上编译 cquery 时，才发现 cquery 已经很久不维护了，github 的 repo 已经 archived 很长一段时间了（应该是2018年就关了）。这就直接导致了在 Apple Silicon 上编译不了 cquery，也就无法使用 cquery 了。&lt;/p&gt;&lt;p&gt;于是，得寻找一套替代 cquery 的方案。一番寻找，两个替代方案出现了：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ccls&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;clangd&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;2018年 4月，一位中国的年轻小伙 &lt;span&gt;MaskRay&lt;/span&gt; 从 cquery fork 了一份代码出来，并且对原有代码进行了大刀阔斧的重构：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;在cquery的代码库上做了大量清理工作：删除第三方库、精简代码、删除过度的抽象、合并拆得过碎的文件，当然还有改名、删除waf构建系统、删除无用blob、……自己用得舒服了再推己及人，希望别人也能用上满足自己的虚荣心。其实说穿了就是和cquery/clangd抢夺用户。精简并不能改变用户习惯，带来用户。我很快瞄准了cquery用户的一个痛点：auto-index pipeline的稳定性。最大的问题是，保存文件后容易导致重复或丢失的references。如果.h和.cc没有放在同一个目录，更容易出问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;by MaskRay《C++ language server ccls一周年》&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;重构和优化后的 ccls 在社区里获得不错的评价。在 cquery 停止维护，clangd 还不成熟的时候，ccls 一度还是该领域的最佳选择。而我这种老旧派还一直固守着 cquery 这只已经不再前进的工具。cquery 的作者不再维护的原因之一，竟是期待 clangd 来取代自己。&lt;/p&gt;&lt;p&gt;这 clangd 从名字上看来就大有来头。它背后是著名的 llvm 官方团队。它基于 Clang C++ Compiler，默认集成到了 llvm 项目中。也就是说，只要你安装了 llvm，就默认带了 clangd，不需要像 cquery, ccls 一样额外安装。&lt;/p&gt;&lt;p&gt;但早期的 clangd 不够成熟，bug 不断，对使用的稳定性造成了不少影响。于是不少用户转向了 ccls，虽然是个人项目，但是功能稳定，在一些特性方面支持也很好。同时 clangd 也在不断的更新迭代，早期的各种问题也在逐步的解决掉，稳定性也在逐步的加强。&lt;/p&gt;&lt;p&gt;我很敬佩 ccls 作者所做的贡献。但是，2022年，我会先选 clangd，原因是它默认随 llvm 安装，以及它背后的 llvm 团队。简单试用后，感觉也非常的不错。待我再用长一段时间，再回过来评价，至少，还有另一个选择：ccls，在等着我。&lt;/p&gt;&lt;h5&gt;vscode + clangd 使用指南&lt;/h5&gt;&lt;p&gt;第一步：&lt;span&gt;安装 clangd，安装 llvm 即可：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; brew install llvm&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;第二步：vscode 安装 clangd 插件，搜索”clangd”安装即可&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.20333333333333334&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/otHvoL6neeIxIugZwRtMH5VUj2nppdvmzF8DESRj9eJrdjxhTLfqqcQ3KhKvVicXmXo0kbzvalt4TibhUSHtwyibQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第三步：vscode 官方的 C/C++ 插件还是需要的，因为我们调试等功能还需要用到。但是需要关闭它的智能提示功能：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;C_Cpp.intelliSenseEngine&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Disabled&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第四步：生成 compile_commands.json 文件，clangd 依赖它来分析所有的依赖关系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果使用 CMake 编译，编译时，添加参数：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; cmake .. -DCMAKE_EXPORT_COMPILE_COMMANDS=YES&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;或者在 CMakeLists.txt 里，指定生成：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;set(&lt;span class=&quot;code-snippet__built_in&quot;&gt;CMAKE_EXPORT_COMPILE_COMMANDS&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;YES&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;生成的 compile_commands.json 文件可能在 build 目录下，这时需要在项目主目录里创建一个该文件的软链：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; ln -s build/compile_commands.json .&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第五步：重启 vscode，或者 CMD+Shift+P 输入 Reload Window&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们以著名开源代码 libuv 为例，生成 compile_commands.json 后，打开工程， 所有头文件，符号都能正确的索引和跳转：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7775&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/otHvoL6neeIxIugZwRtMH5VUj2nppdvmk0pE8Tyw9icughHcypPT3MjpmJuJ6kiaTG5hwpL1DqXib10oW7SB3JKpQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;h5&gt;关于 Python 和 C++ 的一则趣闻&lt;/h5&gt;&lt;p&gt;Python 的作者 Guido van Rossum 的博客几年没更新了，最新更新了一篇文章，翻译过来就是：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;2005 年底，我加入了谷歌。采访花费了令人惊讶的长时间，这是另一个故事。今天我想讲一个故事，发生在我在谷歌园区的第一周。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在主楼有一个令人印象深刻的楼梯，通往二楼。靠近顶部的地方是一间宽敞的办公室。一位非常重要的工程师在那里工作。我看了看门上的名字，发现我认识他：他曾经是英国的一名研究生，90 年代初曾在阿姆斯特丹的数学和计算机科学研究学会（CWI）访问过我们的研究小组（Amoeba 项目）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很高兴找到一个我很久以前就认识的人，有一天我敲门自我介绍。是的，他也记得我，但我的喜悦很快就结束了。不仅 Python 是 Mike 在 Google 的痛苦之源（他讨厌所有非 C++ 的东西），而且他在阿姆斯特丹逗留期间，留下的一个突出的记忆是，大约有一次我带他骑车穿过城镇，坐在我的自行车后面：“这是我一生中最糟糕的骑行。”&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fc6ded4e6973937591fa01d39fa5160f</guid>
<title>面试必备：聊聊分布式锁的多种实现！</title>
<link>https://toutiao.io/k/kypk9q4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是&lt;strong&gt;捡田螺的小男孩&lt;/strong&gt;。今天跟大家探讨一下分布式锁的设计与实现。希望对大家有帮助，如果有不正确的地方，欢迎指出，一起学习，一起进步哈~&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;分布式锁概述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Zookeeper分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;三种分布式锁对比&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 分布式锁概述&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的系统都是分布式部署的，日常开发中，&lt;strong&gt;秒杀下单、抢购商品&lt;/strong&gt;等等业务场景，为了防⽌库存超卖，都需要用到&lt;strong&gt;分布式锁&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业界流行的分布式锁实现，一般有这3种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;基于数据库实现的分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于Redis实现的分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于Zookeeper实现的分布式锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 基于数据库的分布式锁&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 数据库悲观锁实现的分布式锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;code&gt;select ... for update &lt;/code&gt;来实现分布式锁。我们自己的项目，&lt;strong&gt;分布式定时任务&lt;/strong&gt;，就使用类似的实现方案，我给大家来展示个&lt;strong&gt;简单版的哈&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CREATE TABLE `t_resource_lock` (&lt;br/&gt;  `key_resource` varchar(45) COLLATE utf8_bin NOT NULL DEFAULT &lt;span&gt;&#x27;资源主键&#x27;&lt;/span&gt;,&lt;br/&gt;  `status` char(1) COLLATE utf8_bin NOT NULL DEFAULT &lt;span&gt;&#x27;&#x27;&lt;/span&gt; COMMENT &lt;span&gt;&#x27;S,F,P&#x27;&lt;/span&gt;,&lt;br/&gt;  `lock_flag` int(10) unsigned NOT NULL DEFAULT &lt;span&gt;&#x27;0&#x27;&lt;/span&gt; COMMENT &lt;span&gt;&#x27;1是已经锁 0是未锁&#x27;&lt;/span&gt;,&lt;br/&gt;  `begin_time` datetime DEFAULT NULL COMMENT &lt;span&gt;&#x27;开始时间&#x27;&lt;/span&gt;,&lt;br/&gt;  `end_time` datetime DEFAULT NULL COMMENT &lt;span&gt;&#x27;结束时间&#x27;&lt;/span&gt;,&lt;br/&gt;  `client_ip` varchar(45) COLLATE utf8_bin NOT NULL DEFAULT &lt;span&gt;&#x27;抢到锁的IP&#x27;&lt;/span&gt;,&lt;br/&gt;  `time` int(10) unsigned NOT NULL DEFAULT &lt;span&gt;&#x27;60&#x27;&lt;/span&gt; COMMENT &lt;span&gt;&#x27;方法生命周期内只允许一个结点获取一次锁，单位：分钟&#x27;&lt;/span&gt;,&lt;br/&gt;  PRIMARY KEY (`key_resource`) USING BTREE&lt;br/&gt;) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁&lt;code&gt;lock&lt;/code&gt;方法的伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Transcational //一定要加事务&lt;br/&gt;public boolean lock(String &lt;span&gt;keyRe&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;，int time){&lt;br/&gt;   resourceLock = &lt;span&gt;&#x27;select * from t_resource_lock where key_resource =&#x27;&lt;/span&gt;&lt;span&gt;#{keySource}&#x27; for update&#x27;;&lt;/span&gt;&lt;br/&gt;   &lt;br/&gt;   try{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(resourceLock==null){&lt;br/&gt;      //插入锁的数据&lt;br/&gt;      resourceLock = new ResourceLock();&lt;br/&gt;      resourceLock.setTime(time);&lt;br/&gt;      resourceLock.setLockFlag(1);  //上锁&lt;br/&gt;      resourceLock.setStatus(P); //处理中&lt;br/&gt;      resourceLock.setBeginTime(new Date());&lt;br/&gt;      int count = &lt;span&gt;&quot;insert into resourceLock&quot;&lt;/span&gt;; &lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(count==1){&lt;br/&gt;         //获取锁成功&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;   }&lt;br/&gt;   }catch(Exception x){&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;   }&lt;br/&gt;   &lt;br/&gt;   //没上锁并且锁已经超时，即可以获取锁成功&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(resourceLock.getLockFlag==&lt;span&gt;&#x27;0&#x27;&lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;&#x27;S&#x27;&lt;/span&gt;.equals(resourceLock.getstatus)&lt;br/&gt;    &amp;amp;&amp;amp; new Date()&amp;gt;=resourceLock.addDateTime(resourceLock.getBeginTime(,time)){&lt;br/&gt;      resourceLock.setLockFlag(1);  //上锁&lt;br/&gt;      resourceLock.setStatus(P); //处理中&lt;br/&gt;      resourceLock.setBeginTime(new Date());&lt;br/&gt;      //update resourceLock;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;   }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(new Date()&amp;gt;=resourceLock.addDateTime(resourceLock.getBeginTime(,time)){&lt;br/&gt;     //超时未正常执行结束,获取锁失败&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;   }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;   } &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解锁&lt;code&gt;unlock&lt;/code&gt;方法的伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public void unlock(String v，status){&lt;br/&gt;      resourceLock.setLockFlag(0);  //解锁&lt;br/&gt;      resourceLock.setStatus(status); S:表示成功，F表示失败&lt;br/&gt;      //update resourceLock;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体流程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;try{&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(lock(&lt;span&gt;keyRe&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;,time)){ //加锁&lt;br/&gt;   status = process();//你的业务逻辑处理。&lt;br/&gt; }&lt;br/&gt;} finally{&lt;br/&gt;    unlock(&lt;span&gt;&lt;span&gt;keyRe&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;/span&gt;,status); //释放锁&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这个悲观锁实现的分布式锁，整体的流程还是比较清晰的。就是先&lt;code&gt;select ... for update &lt;/code&gt;锁住主键&lt;code&gt;key_resource&lt;/code&gt;那个记录，如果为空，则可以插入一条记录，如果已有记录判断下&lt;strong&gt;状态和时间&lt;/strong&gt;，&lt;strong&gt;是否已经超时&lt;/strong&gt;。这里需要注意一下哈，必须要加&lt;strong&gt;事务&lt;/strong&gt;哈。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 数据库乐观锁实现的分布式锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了悲观锁，还可以用&lt;strong&gt;乐观锁实现分布式锁&lt;/strong&gt;。乐观锁，顾名思义，就是很乐观，每次更新操作，都觉得不会存在并发冲突，只有更新失败后，才重试。它是基于CAS思想实现的。我以前的公司，&lt;strong&gt;扣减余额&lt;/strong&gt;就是用这种方案。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;搞个version字段，每次更新修改，都会自增加一，然后去更新余额时，把查出来的那个版本号，带上条件去更新，如果是上次那个版本号，就更新，如果不是，表示别人并发修改过了，就继续重试。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;查询版本号和余额&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;select version,balance from account &lt;span&gt;where&lt;/span&gt; user_id =&lt;span&gt;&#x27;666&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设查到版本号是oldVersion=1.&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;逻辑处理，判断余额&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(balance&amp;lt;扣减金额){&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;；&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;left_balance = balance - 扣减金额;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;进行扣减余额&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;update account &lt;span&gt;set&lt;/span&gt; balance = &lt;span&gt;#{left_balance} ,version = version+1 where version &lt;/span&gt;&lt;br/&gt;= &lt;span&gt;#{oldVersion} and balance&amp;gt;= #{left_balance} and &lt;span&gt;use&lt;/span&gt;&lt;span&gt;r_id =&lt;/span&gt;&lt;span&gt;&#x27;666&#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以看下这个流程图哈：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2335600907029478&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WJsIDNsJ3NhVQicicLAd2B6pa8UczfIuLicF6R1yKphZ5TZ1N0pBZKP9aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;882&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种方式适合&lt;strong&gt;并发不高&lt;/strong&gt;的场景，一般需要设置一下重试的次数&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.基于Redis实现的分布式锁&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis分布式锁一般有以下这几种实现方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;setnx + expire&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;setnx + value值是过期时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;set的扩展命令（set ex px nx）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;set ex px nx + 校验唯一随机值,再删除&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redisson&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redisson + RedLock&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 setnx + expire&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聊到Redis分布式锁，很多小伙伴反手就是&lt;code&gt;setnx + expire&lt;/code&gt;，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;（jedis.setnx(key,lock_value) == 1）{ //setnx加锁&lt;br/&gt;    expire（key，100）; //设置过期时间&lt;br/&gt;    try {&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; something  //业务处理&lt;br/&gt;    }&lt;span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;    }&lt;br/&gt;  finally {&lt;br/&gt;       jedis.del(key); //释放锁&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码是可以加锁成功，但是你有没有发现问题，&lt;strong&gt;加锁操作和设置超时时间是分开的&lt;/strong&gt;。假设在执行完&lt;code&gt;setnx&lt;/code&gt;加锁后，正要执行&lt;code&gt;expire&lt;/code&gt;设置过期时间时，进程&lt;code&gt;crash&lt;/code&gt;掉或者要重启维护了，那这个锁就&lt;strong&gt;长生不老&lt;/strong&gt;了，别的线程永远获取不到锁啦，所以&lt;strong&gt;分布式锁不能这么实现&lt;/strong&gt;！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 setnx + value值是过期时间&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;long expires = System.currentTimeMillis() + expireTime; //系统时间+设置的过期时间&lt;br/&gt;String expiresStr = String.valueOf(expires);&lt;br/&gt;&lt;br/&gt;// 如果当前锁不存在，返回加锁成功&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (jedis.setnx(key, expiresStr) == 1) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;} &lt;br/&gt;// 如果锁已经存在，获取锁的过期时间&lt;br/&gt;String currentValueStr = jedis.get(key);&lt;br/&gt;&lt;br/&gt;// 如果获取到的过期时间，小于系统当前时间，表示已经过期&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (currentValueStr != null &amp;amp;&amp;amp; Long.parseLong(currentValueStr) &amp;lt; System.currentTimeMillis()) {&lt;br/&gt;&lt;br/&gt;     // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间（不了解redis的getSet命令的小伙伴，可以去官网看下哈）&lt;br/&gt;    String oldValueStr = jedis.getSet(key, expiresStr);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (oldValueStr != null &amp;amp;&amp;amp; oldValueStr.equals(currentValueStr)) {&lt;br/&gt;         // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;        &lt;br/&gt;//其他情况，均返回加锁失败&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常开发中，有些小伙伴就是这么实现分布式锁的，但是会有这些&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;过期时间是客户端自己生成的，分布式环境下，&lt;strong&gt;每个客户端的时间必须同步。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有保存持有者的唯一标识，&lt;strong&gt;可能被别的客户端释放/解锁&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;锁过期的时候，并发多个客户端同时请求过来，都执行了&lt;code&gt;jedis.getSet()&lt;/code&gt;，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，&lt;strong&gt;可能被别的客户端覆盖。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3  set的扩展命令(set ex px nx)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个命令的几个参数分别表示什么意思呢？跟大家复习一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SET key value [EX seconds] [PX milliseconds] [NX|XX]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;EX second ：设置键的过期时间为&lt;code&gt;second&lt;/code&gt;秒。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PX millisecond ：设置键的过期时间为&lt;code&gt;millisecond&lt;/code&gt;毫秒。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NX ：只在键不存在时，才对键进行设置操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;XX ：只在键已经存在时，才对键进行设置操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;（jedis.set(key, lock_value, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;EX&quot;&lt;/span&gt;, 100s) == 1）{ //加锁&lt;br/&gt;    try {&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; something  //业务处理&lt;br/&gt;    }&lt;span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;  }&lt;br/&gt;  finally {&lt;br/&gt;       jedis.del(key); //释放锁&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案可能存在这样的问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些伙伴可能会有个疑问，就是&lt;strong&gt;锁为什么会被别的线程误删&lt;/strong&gt;呢？假设并发多线程场景下，&lt;strong&gt;线程A获得了锁，但是它没释放锁的话，线程B是获取不到锁的&lt;/strong&gt;，所以按道理它是执行不到加锁下面的代码滴，怎么会导致锁被别的线程误删呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;假设线程A和B，都想用&lt;code&gt;key&lt;/code&gt;加锁，最后A抢到锁加锁成功，但是由于执行业务逻辑的耗时很长，超过了设置的超时时间&lt;code&gt;100s&lt;/code&gt;。这时候，Redis就自动释放了&lt;code&gt;key&lt;/code&gt;锁。这时候线程B就可以加锁成功了，接下啦，它也执行业务逻辑处理。假设碰巧这时候，A执行完自己的业务逻辑，它就去释放锁，但是它就把B的锁给释放了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4 set ex px nx + 校验唯一随机值,再删除&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决&lt;strong&gt;锁被别的线程误删&lt;/strong&gt;问题。可以在&lt;code&gt;set ex px nx&lt;/code&gt;的基础上，加上个校验的唯一随机值，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;（jedis.set(key, uni_request_id, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;EX&quot;&lt;/span&gt;, 100s) == 1）{ //加锁&lt;br/&gt;    try {&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; something  //业务处理&lt;br/&gt;    }&lt;span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;  }&lt;br/&gt;  finally {&lt;br/&gt;       //判断是不是当前线程加的锁,是才释放&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (uni_request_id.equals(jedis.get(key))) {&lt;br/&gt;          jedis.del(key); //释放锁&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里，判断当前线程加的锁和释放锁&lt;strong&gt;不是一个原子操作&lt;/strong&gt;。如果调用&lt;code&gt;jedis.del()&lt;/code&gt;释放锁的时候，可能&lt;strong&gt;这把锁已经不属于当前客户端&lt;/strong&gt;，会解除他人加的锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般可以用lua脚本来包一下。lua脚本如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; redis.call(&lt;span&gt;&#x27;get&#x27;&lt;/span&gt;,KEYS[1]) == ARGV[1] &lt;span&gt;then&lt;/span&gt; &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; redis.call(&lt;span&gt;&#x27;del&#x27;&lt;/span&gt;,KEYS[1]) &lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; 0&lt;br/&gt;end;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式比较不错了，一般情况下，已经可以使用这种实现方式。但是还是存在：&lt;strong&gt;锁过期释放了，业务还没执行完的问题&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.5 Redisson&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于可能存在&lt;strong&gt;锁过期释放，业务没执行完&lt;/strong&gt;的问题。我们可以稍微把锁过期时间设置长一些，大于正常业务处理时间就好啦。如果你觉得不是很稳，还可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前开源框架Redisson解决了这个问题。可以看下Redisson底层原理图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6277777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WhXGhJU7kpgiapXIr1LchBwLdhVeKr7A0elDdavt3yDzZhrhdrCdxd2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要线程一加锁成功，就会启动一个&lt;code&gt;watch dog&lt;/code&gt;看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用&lt;code&gt;watch dog&lt;/code&gt;解决了&lt;strong&gt;锁过期释放，业务没执行完问题&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.6 Redisson + RedLock&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面六种方案都只是基于&lt;strong&gt;Redis单机版&lt;/strong&gt;的分布式锁讨论，还不是很完美。因为&lt;strong&gt;Redis&lt;/strong&gt;一般都是集群部署的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3738229755178908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WbTxA3drXiaqSxUnPCct5EgxbR0wibQ11QpYKsl99Q9B3DCf9b84xr2gQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1062&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线程一在&lt;code&gt;Redis&lt;/code&gt;的&lt;code&gt;master&lt;/code&gt;节点上拿到了锁，但是加锁的&lt;code&gt;key&lt;/code&gt;还没同步到&lt;code&gt;slave&lt;/code&gt;节点。恰好这时，&lt;code&gt;master&lt;/code&gt;节点发生故障，一个&lt;code&gt;slave&lt;/code&gt;节点就会升级为&lt;code&gt;master&lt;/code&gt;节点。线程二就可以顺理成章获取同个&lt;code&gt;key&lt;/code&gt;的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，Redis作者antirez提出一种高级的分布式锁算法：&lt;strong&gt;Redlock&lt;/strong&gt;。它的核心思想是这样的：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;部署多个Redis master，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们假设当前有5个Redis master节点，在5台服务器上面运行这些Redis实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4W81f479ib5AYGplGTe5TP1vOCqu2oTZotaXQ1dCZMibPicpjUGv6locoAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;RedLock的实现步骤:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取当前时间，以毫秒为单位。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间,我们就假设超时时间是50ms吧）。如果超时，跳过该master节点，尽快去尝试下一个master节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端使用当前时间减去开始获取锁时间（即步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1，这里是5/2+1=3个节点）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，10s&amp;gt; 30ms+40ms+50ms+4m0s+50ms）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果取到了锁，key的真正有效时间就变啦，需要减去获取锁所使用的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果获取锁失败（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简化下步骤就是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;按顺序向5个master节点请求加锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据设置的超时时间来判断，是不是要跳过该master节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果获取锁失败，解锁！&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Redisson实现了redLock版本的锁&lt;/strong&gt;，有兴趣的小伙伴，可以去了解一下哈~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Zookeeper分布式锁&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在学习Zookeeper分布式锁之前，我们复习一下Zookeeper的节点哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zookeeper的节点Znode有四种类型：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;持久节点&lt;/strong&gt;：默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;持久节点顺序节点&lt;/strong&gt;：所谓顺序节点，就是在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号，持久节点顺序节点就是有顺序的持久节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;临时节点&lt;/strong&gt;：和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;临时顺序节点&lt;/strong&gt;：有顺序的临时节点。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zookeeper分布式锁实现应用了&lt;strong&gt;临时顺序节点&lt;/strong&gt;。这里不贴代码啦，来讲下zk分布式锁的实现原理吧。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.1 zk获取锁过程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当第一个客户端请求过来时，Zookeeper客户端会创建一个持久节点&lt;code&gt;locks&lt;/code&gt;。如果它（Client1）想获得锁，需要在&lt;code&gt;locks&lt;/code&gt;节点下创建一个顺序节点&lt;code&gt;lock1&lt;/code&gt;.如图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5101851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WKNicIzdiciclyicA7eEXIibicq6t4DEWoicwehdgHso6goKqIZwT6iaHWA62hA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，客户端Client1会查找&lt;code&gt;locks&lt;/code&gt;下面的所有临时顺序子节点，判断自己的节点&lt;code&gt;lock1&lt;/code&gt;是不是排序最小的那一个，如果是，则成功获得锁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5101851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WtPstSP6MVv1EgVFibBvHJXARQTias1m9f1HBTQYxD8fxbwmfW4QW4mVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候如果又来一个客户端client2前来尝试获得锁，它会在locks下再创建一个临时节点&lt;code&gt;lock2&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5018518518518519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WUe2KfHbZxqq1HydWw244eoTCusib2qFYbFNfzAoZvP0ia7rErqkXdaWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端client2一样也会查找&lt;span&gt;locks&lt;/span&gt;下面的所有临时顺序子节点，判断自己的节点&lt;span&gt;lock2&lt;/span&gt;是不是最小的，此时，发现&lt;span&gt;lock1&lt;/span&gt;才是最小的，于是获取锁失败。获取锁失败，它是不会甘心的，client2向它排序靠前的节点&lt;span&gt;lock1&lt;/span&gt;注册&lt;span&gt;Watcher&lt;/span&gt;事件，用来监听&lt;span&gt;lock1&lt;/span&gt;是否存在，也就是说client2抢锁失败进入等待状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.524074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WsuEjzIcW3yNzXHPiaGWNLoU2I6icH1Fd5jfMI5mjlhG8zcujzSVVGXRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果再来一个客户端Client3来尝试获取锁，它会在locks下再创建一个临时节点&lt;span&gt;lock3&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5222222222222223&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WNicPWtvZaRia4DSgdIbtYZ3ccnViajVKkiahuFXxeHXdDIhrwaCVa4Oreg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;同样的，client3一样也会查找&lt;span&gt;locks&lt;/span&gt;下面的所有临时顺序子节点，判断自己的节点&lt;span&gt;lock3&lt;/span&gt;是不是最小的，发现自己不是最小的，就获取锁失败。它也是不会甘心的，它会向在它前面的节点&lt;span&gt;lock2&lt;/span&gt;注册&lt;span&gt;Watcher&lt;/span&gt;事件，以监听&lt;span&gt;lock2&lt;/span&gt;节点是否存在。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5138888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WIUM5SKj6ibSLEJ3zIicXBnoOUDBk4j9JoI4OEiaKCvc21JIXzxlTjhaLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 释放锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看看释放锁的流程，Zookeeper的客户端业务完成或者发生故障，都会删除临时节点，释放锁。如果是任务完成，Client1会显式调用删除&lt;span&gt;lock1&lt;/span&gt;的指令&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5194444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WOsJWicJwDQbibOxVic5PBUZcPIYGqyCict2zYtsVvkD1UNgGPzJtLfiasrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是客户端故障了，根据临时节点得特性，&lt;span&gt;lock1&lt;/span&gt;是会自动删除的&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48518518518518516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4Wlu90z3dSWJcK82exrgj0zVEITnkCZTTWbb2Q13nA5amibJQC6libztzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;lock1&lt;/span&gt;节点被删除后，Client2可开心了，因为它一直监听着&lt;span&gt;lock1&lt;/span&gt;。&lt;span&gt;lock1&lt;/span&gt;节点删除，Client2立刻收到通知，也会查找&lt;span&gt;locks&lt;/span&gt;下面的所有临时顺序子节点，发下&lt;span&gt;lock2&lt;/span&gt;是最小，就获得锁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5574074074074075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyOKCFvj0BvDAcATfYe8b4WTaNEmGzfRdBN9ngKic6yOVeELSdDyDxqgkKFXq3IibBovCM9E52OR8AQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，Client2获得锁之后，Client3也对它虎视眈眈，啊哈哈~&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Zookeeper设计定位就是分布式协调，简单易用。如果获取不到锁，只需添加一个监听器即可，很适合做分布式锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Zookeeper作为分布式锁也缺点：如果有很多的客户端频繁的申请加锁、释放锁，对于Zookeeper集群的压力会比较大。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 三种分布式锁对比&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.1 数据库分布式锁实现&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;简单，使用方便，不需要引入&lt;code&gt;Redis、zookeeper&lt;/code&gt;等中间件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 Redis分布式锁实现&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;性能好，适合高并发场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;较轻量级&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有较好的框架支持，如&lt;span&gt;Redisson&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 Zookeeper分布式锁实现&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;性能不如redis实现的分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比较重的分布式锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;有较好的性能和可靠性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有封装较好的框架，如Curator&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.4 对比汇总&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;从性能角度（从高到低）Redis &amp;gt; Zookeeper &amp;gt;= 数据库；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从理解的难易程度角度（从低到高）数据库 &amp;gt; Redis &amp;gt; Zookeeper；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从实现的复杂性角度（从低到高）Zookeeper &amp;gt; Redis &amp;gt; 数据库；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从可靠性角度（从高到低）Zookeeper &amp;gt; Redis &amp;gt; 数据库。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后(求关注，别白嫖我)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这篇文章对您有所帮助，或者有所启发的话，求一键三连：点赞、转发、在看，您的支持是我坚持写作最大的动力。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f3790fbd78057a799fd94291378f5209</guid>
<title>优质网站同好者周刊（第 60 期）- 倾城之链 - 悠然宜想亭</title>
<link>https://toutiao.io/k/lsj3633</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Post-body&quot;&gt;
                    &lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot; rel=&quot; nofollow ugc&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot; rel=&quot; nofollow ugc&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot; rel=&quot; nofollow ugc&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot; rel=&quot; nofollow ugc&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot; rel=&quot; nofollow ugc&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%95%88%E7%8E%87&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;效率&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BA%94%E7%94%A8&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;应用&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;跨平台&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;A cross-platform Text Expander written in Rust. A text expander is a program that detects when you type a specific keyword and replaces it with something else.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/espanso.org.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Espanso - A Privacy-first, Cross-platform Text Expander&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://espanso.org/&quot; rel=&quot; nofollow ugc&quot;&gt;espanso&lt;/a&gt; 是一个用 &lt;code&gt;Rust&lt;/code&gt; 编写的跨平台文本扩展器，它可以检测您何时键入特定的关键字，并用其他内容替换它。espanso 具有以下功能特征：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;适用于&lt;strong&gt;Windows&lt;/strong&gt;、&lt;strong&gt;macOS&lt;/strong&gt; 和 &lt;strong&gt;Linux&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;适用于几乎&lt;strong&gt;任何程序&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;与&lt;strong&gt;表情符号一起使用&lt;/strong&gt; 😄；&lt;/li&gt;
&lt;li&gt;适用于&lt;strong&gt;图像&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;包括一个强大的&lt;strong&gt;搜索栏&lt;/strong&gt; 🔎；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日期&lt;/strong&gt;扩展支持；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自定义脚本&lt;/strong&gt;支持；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外壳命令&lt;/strong&gt;支持；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特定于应用程序的&lt;/strong&gt;配置；&lt;/li&gt;
&lt;li&gt;支持 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://espanso.org/docs/forms/&quot; rel=&quot; nofollow ugc&quot;&gt;表格&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;可扩展&lt;strong&gt;包&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://hub.espanso.org/&quot; rel=&quot; nofollow ugc&quot;&gt;espanso hub&lt;/a&gt; 的内置&lt;strong&gt;包管理&lt;/strong&gt;器；&lt;/li&gt;
&lt;li&gt;基于文件的配置；&lt;/li&gt;
&lt;li&gt;支持正则表达式触发器；&lt;/li&gt;
&lt;li&gt;实验性 Wayland 支持；&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://espanso.org/&quot; rel=&quot; nofollow ugc&quot;&gt;Espanso&lt;/a&gt;，可以用来做什么呢？在 Github 开源仓库，有写到 Espanso 在以下方面很有用：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;节省大量打字，扩展常用句子；&lt;/li&gt;
&lt;li&gt;创建系统范围的代码片段；&lt;/li&gt;
&lt;li&gt;执行自定义脚本；&lt;/li&gt;
&lt;li&gt;像专业人士一样使用表情符号；&lt;/li&gt;&lt;/ul&gt;

&lt;h3&gt;更智能的打字&lt;/h3&gt;

&lt;p&gt;无需再复制和粘贴，只需创建一次模板，然后让 Espanso 为您完成剩下的工作。客户支持回复、销售宣传、医疗报告，应有尽有。埃斯潘索为您提供保障。&lt;/p&gt;

&lt;h3&gt;每一句话，一搜就走&lt;/h3&gt;

&lt;p&gt;不记得捷径？不用担心。只需按 &lt;code&gt;⌥ +Space&lt;/code&gt;（Mac OS） ，Espanso 的搜索栏 就会打开，让您搜索完美的片段。&lt;/p&gt;

&lt;h3&gt;日期、表情符号 🚀 等等&lt;/h3&gt;

&lt;p&gt;不要纠结日期。Espanso 让它们易于使用，无论是过去的还是未来的。将表情符号 🤠 带入您喜爱的所有应用程序中，只需一个快捷方式。&lt;/p&gt;

&lt;h3&gt;无限的可扩展性&lt;/h3&gt;

&lt;p&gt;使用软件包扩展 Espanso 的功能，或创建您自己的并在 Espanso Hub 上与社区分享。需要插入数学符号吗？或者也许是德国口音？我们为他们准备了一个包裹。&lt;/p&gt;

&lt;h3&gt;Shell 和脚本支持&lt;/h3&gt;

&lt;p&gt;对于高级用例，您可以使用 Shell 命令或自定义脚本扩展 Espanso 的代码片段。不再从终端复制粘贴，直接将输出注入应用程序。&lt;/p&gt;

&lt;h3&gt;表格支持&lt;/h3&gt;

&lt;p&gt;使用表单来处理复杂的工作流程，创建可以轻松重复使用的模板。您甚至可以将表单值转发到自定义脚本中，从而开启无限可能。&lt;/p&gt;

&lt;h3&gt;全系统集成&lt;/h3&gt;

&lt;p&gt;Espanso 适用于大多数应用程序，因此您可以在任何地方提高工作效率。&lt;/p&gt;

&lt;p&gt;最近，就安装并使用了 Espanso （基于 Mac OS），感觉非常棒，其体验要比 Mac 自带的体验要好很多。而且，文档对于如何安装、配置、使用等，都写的全面易懂；与 Windows 平台下 &lt;a href=&quot;https://nicelinks.site/post/5ae83b115ecfb73d26e47296&quot; rel=&quot; nofollow ugc&quot;&gt;AutoHotkey&lt;/a&gt; 应用的部分功能很像。如果您也是一位基于电脑码字较多的朋友，那么 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://espanso.org/&quot; rel=&quot; nofollow ugc&quot;&gt;Espanso&lt;/a&gt; 非常值得您采用，从而节省大量打字时间，以提升&lt;strong&gt;效率&lt;/strong&gt;和&lt;strong&gt;幸福感&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/624efb22b7bf120669dbd40c&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Espanso - A Privacy-first, Cross-platform Text Expander&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;命令行&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BB%88%E7%AB%AF&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;终端&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BA%94%E7%94%A8&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;应用&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Warp is a modern Rust-based terminal that’s fast, easy to use, and built for teams.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.warp.dev.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Warp: The terminal for the 21st century&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.warp.dev/&quot; rel=&quot; nofollow ugc&quot;&gt;WARP&lt;/a&gt; 是一个速度极快、基于 RUST 的终端，从头开始重新构想，可以像现代应用程序一样工作。它具有以下功能特征：&lt;/p&gt;

&lt;h3&gt;快速地&lt;/h3&gt;

&lt;p&gt;完全原生的、基于 Rust 的终端。没有电子或网络技术。&lt;/p&gt;

&lt;h3&gt;私密和安全&lt;/h3&gt;

&lt;p&gt;所有云功能都是可选的。数据是静态加密的。&lt;/p&gt;

&lt;h3&gt;向后兼容&lt;/h3&gt;

&lt;p&gt;Warp 与 zsh、fish 和 bash 一起开箱即用。&lt;/p&gt;

&lt;p&gt;此外，它具有现代发展的现代特征：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;感觉像代码在编辑器上输入&lt;/strong&gt;：在终端中编写代码不应该像 1978 年那样。编辑命令就像在现代代码编辑器中一样，带有选择、光标定位和完成菜单；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不再滚动浏览文字墙&lt;/strong&gt;：逐个命令地浏览您的终端。一键复制输出，零滚动；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以思考的速度形成命令&lt;/strong&gt;：使用简单的 GUI 访问常见的工作流程。您可以创建自己的工作流程，并与您的团队共享；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在终端内运行您的文档&lt;/strong&gt;：用混合文档和 CLI 命令的本地终端笔记本替换 wiki。手写这些，或从终端输出转换它们。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;终端共享&lt;/strong&gt;：将您的会话的固定链接分享给您的团队。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.warp.dev/&quot; rel=&quot; nofollow ugc&quot;&gt;WARP&lt;/a&gt; 是一个完全原生的、GPU 加速的、基于 Rust 的终端。没有电子或网络技术。在 4K 屏幕上为 60fps。其目标是：将&lt;strong&gt;命令行&lt;/strong&gt;重新创建为现代应用程序，为每个人提供更实用、更人性化、最终更强大的 CLI。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/624ee3edb7bf120669dbd40a&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Warp: The terminal for the 21st century&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;编程语言&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BC%96%E7%A8%8B&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;编程&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E5%8F%91%E8%80%85&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;开发者&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;OverAPI.com is a site collecting all the cheatsheets,all!&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/overapi.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - OverAPI.com | Collecting all the cheat sheets&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://overapi.com/&quot; rel=&quot; nofollow ugc&quot;&gt;OverAPI.com&lt;/a&gt; 是一个在线服务，旨在：&lt;strong&gt;收集所有编程语言备忘单&lt;/strong&gt;，被业界称为： 最全的开发人员在线速查手册。它将编程语言所涉及到的&lt;strong&gt;方法&lt;/strong&gt;，进行分门别类，并且按顺序展示于一个界面中，且对该方法做了站外链接（到具体语言方法文档）；而且提供检索过滤功能，使得用户能方便检索到要查找的方法名。&lt;/p&gt;

&lt;p&gt;该网站最令人惊叹的是，所涉及编程语言极其广泛，无论是流行的 JavaScript、Python、Java、Node.js、PHP、Ruby、CSS、HTML，&lt;a href=&quot;https://nicelinks.site/redirect?url=https://overapi.com/regex&quot; rel=&quot; nofollow ugc&quot;&gt;RegEx&lt;/a&gt; 乃至非常冷门的语言，或者 Git、SVN、Mac、CVS 等工具，也都有涉及；即便没有详细方法罗列，也会附上诸如像官方网站、&lt;code&gt;Wikipedia&lt;/code&gt; 等地址。除了网站外，还提供了 Chrome 扩展：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://chrome.google.com/webstore/detail/all-cheat-sheets/oedodeocfdeegliepeeoieemhdgoijod&quot; rel=&quot; nofollow ugc&quot;&gt;All Cheat Sheets&lt;/a&gt;。如果您从事某种编程语言开发不久，相信 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://overapi.com/&quot; rel=&quot; nofollow ugc&quot;&gt;OverAPI.com&lt;/a&gt; 对您能够很有帮助。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/624d8dc0b7bf120669dbd407&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - OverAPI.com | Collecting all the cheat sheets&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;网页设计&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/HTML&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;HTML&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/CSS&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;CSS&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：网页设计, UI, 灵感, 代码片段, HTML, CSS, JavaScript, Web Design&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Handpicked collection of Web Design &amp;amp; UI Inspiration with Code Snippets. ✅ GIF preview ✅ HTML CSS copy paste code.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/codemyui.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - CodeMyUI&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://codemyui.com/&quot; rel=&quot; nofollow ugc&quot;&gt;CodeMyUI&lt;/a&gt;，一个网页设计和 UI 灵感与代码片段的网站；这里有精心挑选的网页设计和 UI 灵感与代码片段的集合。支持 GIF 预览、 HTML CSS 复制粘贴代码。如果您从事 Web 前端开发，可以从这汲取灵感，诸如：滚动图像以更改文本视差效果、带有滚动效果的凸窗样式图像滑块、悬停时带有解释的删除线文本、图像的纯 CSS 翻页动画等等。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/624d294bb7bf120669dbd405&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - CodeMyUI&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Windows&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;Windows&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B7%A5%E5%85%B7&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;工具&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%BD%AF%E4%BB%B6&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;软件&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Everything，Windows 系统下，基于名称快速定位文件和文件夹的搜索工具。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.voidtools.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - voidtools | Everything&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.voidtools.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Everything&lt;/a&gt;，此为 Windows 桌面搜索引擎：&quot;Everything&quot; 的官方网站。Everything 是 voidtools 开发的一款&lt;strong&gt;文件搜索&lt;/strong&gt;工具，官网描述为“基于名称实时定位文件和目录；它体积小巧，界面简洁易用，快速建立索引，快速搜索，同时占用极低的系统资源，实时跟踪文件变化，并且还可以通过 http 或 ftp 形式分享搜索。&lt;code&gt;Everything&lt;/code&gt; 具有以下功能特色：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;轻量安装文件；&lt;/li&gt;
&lt;li&gt;干净简洁的用户界面；&lt;/li&gt;
&lt;li&gt;快速文件索引；&lt;/li&gt;
&lt;li&gt;快速搜索；&lt;/li&gt;
&lt;li&gt;最小资源使用；&lt;/li&gt;
&lt;li&gt;便于文件分享；&lt;/li&gt;
&lt;li&gt;实时更新；&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;在搜索框输入文字，它就会只显示过滤后的文件和目录。Everything 搜索只基于文件和文件夹的名称，所以它创建数据库很快。如果你希望能按文件名进行高速搜索文件，并且硬盘分区都是使用 NTFS 格式的，又或者需要远程搜索其他计算机上的文件，那么你绝对不能错过 Everything 这款仅几百 KB 的免费软件！它绝对值得你收藏与试用的。&lt;/p&gt;

&lt;p&gt;早在 2014 年，初次接触到 Everything，开启了笔者对工具的折腾之旅，并乐此不疲；时隔多年，受益匪浅；多年来也有写些相关分享，诸如：&lt;a href=&quot;https://www.jeffjade.com/2016/03/17/2016-03-17-jade-tools/&quot; rel=&quot; nofollow ugc&quot;&gt;那些所倚靠的利器记载&lt;/a&gt;、&lt;a href=&quot;https://www.jeffjade.com/2016/05/22/108-Listary-Everything-Wox-Launch/&quot; rel=&quot; nofollow ugc&quot;&gt;Listary Everything Wox Launch&lt;/a&gt; 等文章；在多番尝试后，Windows 中检索内容，更喜欢 &lt;a href=&quot;https://nicelinks.site/post/5f217282b1689d3f5f920012&quot; rel=&quot; nofollow ugc&quot;&gt;Listary&lt;/a&gt; 革命性搜索实用程序，它使普通用户和高级用户，都能快速找到文件并启动应用程序，真的可以&lt;strong&gt;让文件在你指尖流动&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/624b0cd0b7bf120669dbd403&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - voidtools | Everything&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E9%AB%98%E7%A7%91%E6%8A%80&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;高科技&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%AE%98%E7%BD%91&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;官网&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E4%BA%A7%E5%93%81&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;产品&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：space, spacex, aerospace, elon musk, mars, falcon 9, falcon heavy, dragon&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;SpaceX designs, manufactures and launches advanced rockets and spacecraft. The company was founded in 2002 to revolutionize space technology, with the ultimate goal of enabling people to live on other planets.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.spacex.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - SpaceX&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.spacex.com/&quot; rel=&quot; nofollow ugc&quot;&gt;SpaceX&lt;/a&gt;（太空探索技术公司，即美国太空探索技术公司）：设计、制造和发射先进的火箭和航天器。该公司是一家由 PayPal 早期投资人埃隆·马斯克（Elon Musk）2002 年 6 月建立，旨在革新太空技术，最终目标是&lt;strong&gt;让人们能够生活在其他星球上&lt;/strong&gt;。它开发了可部分重复使用的猎鹰 1 号和猎鹰 9 号运载火箭。SpaceX 同时开发 Dragon 系列的航天器以通过猎鹰 9 号发射到轨道。SpaceX 主要设计、测试和制造内部的部件，如 Merlin、Kestrel 和 Draco 火箭发动机。&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;“你想在早上醒来并认为未来会很美好 ── 这就是成为航天文明的全部意义所在。这是关于相信未来，认为未来会比过去更好。我想不出有什么比走出去，置身于群星之中更令人兴奋的事情了。”── 埃隆·马斯克&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;在 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.spacex.com/mission&quot; rel=&quot; nofollow ugc&quot;&gt;SpaceX&lt;/a&gt; 页面，不仅展示了 Elon Musk 美好愿景，而且介绍了其公司使命：&lt;/p&gt;

&lt;h3&gt;使人类多行星&lt;/h3&gt;

&lt;p&gt;在 Falcon 9 和 Falcon Heavy 的成就基础上，SpaceX 正在开发下一代完全可重复使用的运载火箭，这将是有史以来最强大的运载火箭，能够将人类运送到火星和太阳系的其他目的地。&lt;/p&gt;

&lt;h3&gt;创造历史&lt;/h3&gt;

&lt;p&gt;SpaceX 因一系列历史性里程碑而受到全球关注。它是唯一一家能够从近地轨道返回航天器的私营公司，2012 年，我们的龙飞船成为第一艘往返国际空间站运送货物的商业航天器。2020 年，SpaceX 也成为第一家将人类带到那里的私营公司。单击上面的时间线以查看我们的一些里程碑式成就。&lt;/p&gt;

&lt;h3&gt;可重用性&lt;/h3&gt;

&lt;p&gt;SpaceX 认为，完全且快速可重复使用的火箭是大幅降低太空访问成本所需的关键突破。大部分发射成本来自建造火箭，该火箭历史上只飞行过一次。&lt;/p&gt;

&lt;p&gt;将其与商用客机进行比较——每架新飞机的成本与猎鹰 9 号大致相同，但每天可以飞行多次，并在其生命周期内进行数万次飞行。按照商业模式，可快速重复使用的太空运载火箭可以将前往太空的成本降低一百倍。&lt;/p&gt;

&lt;p&gt;虽然大多数火箭设计为在再入时燃烧，但 SpaceX 火箭不仅可以承受再入，还可以成功降落在地球上并再次重新飞行。&lt;/p&gt;

&lt;h3&gt;降落&lt;/h3&gt;

&lt;p&gt;SpaceX 的猎鹰运载火箭系列是第一个也是唯一一个能够重新发射的轨道级火箭。根据任务所需的性能，猎鹰降落在我们的一艘自主太空港无人驾驶飞机上，或者我们的发射台附近的着陆区之一。&lt;/p&gt;

&lt;p&gt;凭借特斯拉、SpaceX 等过硬科技产品，以及无与伦比的营销，2021 年，Elon Musk 个人净资产升至 1850 亿美元，以 15 亿美元之差超越亚马逊 CEO 贝佐斯，成为全球首富。这无疑佐证了 Elon Musk 及旗下产品的创新及成功。SpaceX 近 20 年发展及声誉，皆是蒸蒸日上；但在未来，能够成为造福人类的划时代产品，让时间来检验，我们拭目以待。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6249978fb7bf120669dbd3ff&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - SpaceX&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; title=&quot;&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;本期文末寄语&lt;/h2&gt;

&lt;p&gt;吾生也有涯，而知也无涯。以有涯随无涯，殆已！已而为知者，殆而已矣！&lt;strong&gt;为善无近名，为恶无近刑，缘督以为经，可以保身，可以全生，可以养亲，可以尽年&lt;/strong&gt;。战国 · 庄子 ──《庄子·内篇·养生主》&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; title=&quot;&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;您可能感兴趣的文章&lt;/h3&gt;



                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>44be451dbffce1c0002c8f7c9967eaaa</guid>
<title>杨尚昂：FlinkSQL在京东实时维度建模中的应用</title>
<link>https://toutiao.io/k/81ouxgp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-backh=&quot;161&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;161&quot; data-fileid=&quot;100072688&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh7SwtLWpnpAXTOWaOPZYslMYaP54YrW09u7JbzkuR03o15wm0Gbial1PGDXGAICxfN1urRfLwHTpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZUhyOUQrkiaMibYN5AjAqoK51wKKdjAobj3VdMUBLEmlDzz3X4iaWqJEFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: -10px; margin-left: -8px; max-width: 100%; width: 18px; height: 18px; border-top: 8px solid rgb(54, 65, 173); border-left: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-style=&quot;max-width: 100%; width: 543.333px; background: rgb(247, 247, 247); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;分享嘉宾&lt;/span&gt;&lt;span&gt;：杨尚昂 京东 BI工程师&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;编辑整理&lt;/span&gt;&lt;span&gt;：闵强 明略科技&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;出品平台：DataFunTalk&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; width: 18px; height: 18px; border-bottom: 8px solid rgb(54, 65, 173); border-right: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;今天给大家分享京东在实&lt;/span&gt;&lt;span&gt;时建模过程中使用Flink SQL的应用案例。&lt;/span&gt;&lt;span&gt;主要从问题、难点、方案和规划四个方面来介绍。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;问题&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在维度建模中有很多技术场景，本文挑选其中两个较难的场景来进行详细阐述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题一 实时多流全量关联的问题&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; A &lt;span class=&quot;code-snippet__keyword&quot;&gt;full&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;join&lt;/span&gt; B &lt;span class=&quot;code-snippet__keyword&quot;&gt;on&lt;/span&gt; A.name = B.name;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;此问题关联SQL比较简单，只有A流和B流两个实时流进行full join，但还可能涉及到其中有一流数据需要关联全量历史数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题二 实时流全量分组计算的问题&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;,&lt;span class=&quot;code-snippet__keyword&quot;&gt;name&lt;/span&gt;,val,row_number() &lt;span class=&quot;code-snippet__keyword&quot;&gt;over&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;partition&lt;/span&gt; byname &lt;span class=&quot;code-snippet__keyword&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt; val) &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; rn &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; A;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;name&lt;/span&gt;,&lt;span class=&quot;code-snippet__keyword&quot;&gt;min&lt;/span&gt;(val) &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; A &lt;span class=&quot;code-snippet__keyword&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt; k;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个问题是&lt;/span&gt;&lt;span&gt;实时流全量分组计算，涉及到分组排序值，或者分组求最小值等操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对以上两个问题，似乎使用SQL处理起来比较简单，甚至我们可以直接用Flink SQL去完成。而实际直接使用以上Flink SQL计算存在若干问题。第一个问题是在最初生产数据的时候，可能并没有接入实时数据流。在实际场景中，往往需要在过程中接入实时数据。比如接入binlog之类的数据，其实是从当前时刻到未来这一时间段。例如商品SPU信息，一般需要有历史数据。只有获取历史数据，在订单数据流关联的时候，才能关联上这个订单所对应的历史信息。如果商品信息都是从产生后一段时间才接入数据，即从当前时刻才有的，那就无法获取到历史信息。第二个问题是状态数据，在用Flink SQL进行计算时，需要维护若干状态数据放到内存中，这种操作比较消耗内存。对于商品几年的历史数据，如果将状态数据存放在rocksdb中，经测试性能无法得到保障。基于此，如果直接用Flink SQL肯定无法解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下分析怎么去解决此类问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先看第一个问题，即实时多流全量关联的问题。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;span&gt;第一部分就是从最初时刻到当前时刻的时间区间，可以认为是历史状态数据。此处分别是A表和B表的记录。然后我们按照对应的关联键，如分别按name进行关联。通过name字段把它拆成几个部分，右侧是关联出来的结果表。当有一个消息进入，这个消息体可能是一个变更的消息记录。此处略过较为简单的新增或者删除操作，重点分析更新操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZzJ426cjgB0Q09OgCGcu5BmZDDwpDcsDePDKt5rtMbCgicqibdWNSqw9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如下图中消息mid=1，将A表里边的id=1000001这条记录里面aaa的记录值改成了bbb。但这个name字段是关联键，所以这就导致它影响了两个分组下的关联键下的记录。最终在A里面，它与B关联上的，之前的这两条记录(name=aaa)，在它被修改之后就不存在了，所以我们需要给下游发删除记录。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZDLQffs2EKSpoUmoykMg7aY3g2VkyF2KsCS9qrvrxVJEACUZjq40QOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时在A表的分组中，即在name=bbb分组下，这个关联键下会新增一条插入的记录。所以需要向下游下发这条新增记录跟B表关联到的这两条宽表记录。如果再有一条消息体过来，那么同样存在插入和删除记录。以此类推，B表变更逻辑相类似。在此过程中，当一条变更的消息体来了之后，需要考虑在实时维度建模里面去做哪些操作。例如在这个建模过程中需要变更的可能不只是当前的那个记录状态，之前的状态也有关联。而在进行分布式去计算的时候，不同的关联键也会分发到不同的节点上去计算。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZADKmtcGyTnBRTl3tNCzCb0ldzuyJmAzdtNS5LCRAI5B7rCy1Wlkw7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZHRzQNRalVhuOJwbSUv8cW5NFp58MEpPUJJeGkP6SSbxjib7JlFHhR2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;再看第二个问题，全量分组计算问题。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类似地，当源端来了一个消息体，本来是一个原始状态值name=bbb，当它变更之后，现在变更成name=aaa，最终会影响分组排序的结果。原本是按照val=21,33,66 (name=aaa)依次排序，现在只有val=33,66 (name=bbb)，因为（id=100003）这条记录中的name值从bbb变成了aaa。所以在排序时row_number会发生变更，而下发的相关联的数据同样都会变更。当产生变更时，分组中最小值(min)是一样的，在涉及变更行为之后都需要更改。我们在进行计算时就需要考虑以上这些情况。因此每一次计算过程，都需要拿到A表的全量历史数据跟B表的全量历史数据去进行关联计算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZMC8KtwRAyyfEIicO27xD2iaibK6oRNTXM3QIIf2l4qavVHb54V1gmuTicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZKbxokKnDBFZQFiakWpejkn3nSaYsIjxxEposMQbGOmDic9hgMDlRxoiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然也可能存在A表发生变更，需要拿关联的B表的全量，这样可以把所有的数据都进行关联，包括之前这个状态将对应的B的全量取出来然后去做关联。以上这两类问题，通过画图和描述来看，似乎较为简单。但问题在于有数据流的变更，还需要还原出对应的状态表，然后由状态表关联结果，最终还原出对应的关联结果的流式变更记录，这类操作就涉及状态存储与读取的技术难点。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;难点&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以上两类问题，如果进行全量数据关联操作，很快就能得到关联出的所有全量结果，然后去做计算，在性能上似乎也不用考虑太多，但实际操作存在一定难度。&lt;/span&gt;&lt;span&gt;以下阐述了问题难点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先需要明确，问题难点准确来说是相对繁琐之处。实时维度建模有别于离线维度建模，需要考虑的地方很多，因此会增加实时维度建模的开发难度以及需要人为的干涉的地方。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;难点一，如何获取到历史数据。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果是使用Flink SQL来实现，需要保存全量的历史信息。既然我们无法保存状态，那就存到外设KV存储里面，存到外部的KV Storage。在这个过程中，需要考虑以什么结构去存储；如何去维护A、B、C三个表的数据，用这三个流表去做关联；这三个流表与各自对应的外设存储比如说A的HBase表跟B的HBase表跟C的HBase表或者与D的HBase表等等类似KV存储这种类型的；要对这几个表之间的关系进行组织；在组织关联出了结果之后，需要考虑在关联结果里面是否还存在时序问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上描述的关联结果里面存在三个消息，当三个消息体来了之后，对应的有一组下发流。如id=100001对应的键，它存在多条记录，如果时序发生混乱，最终可能导致宽表的结果还原错误。那怎么来保证时序的正确性，如果直接用Flink SQL进行计算，可能需要创建一个HBase table source（类似table function）的方式去做关联。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;难点二，如何提升性能。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果直接使用Flink SQL进行计算，需要考虑如何获取数据包括IO操作，且如何更高效地去实现这个过程。关于提升性能，最直接地有两种途径，一是降低IO的请求次数，二是增加并发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;降低IO请求，具体实现方法是做业务逻辑过滤或者根据业务逻辑做一定计算，或者做一些请求合并，或者用一些批量请求的方式去发请求。另外是设置缓存，通过设置一个合理的缓存值，能够做到缓存有一个较高的命中率。同时还需要考虑是设置被动缓存还是主动缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;增加并发，具体需要考虑是使用异步IO，还是使用增加并行度、引擎优化等等。因为以上两个较为繁琐支出，所以开发难度相对较高，需要考虑的细节问题较多。如果直接使用Flink SQL，其代价也许比写Flink程序去做维度建模工作更大。以上就是使用Flink SQL做维度建模工作遇到的若干难题。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;方案&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;那如何去解决以上问题？&lt;/span&gt;&lt;span&gt;首先考虑采用组件化的设计方式，把用户所需要的维度建模功能做成若干组件，用户可以直接通过组件化的配置，就能够完成维度建模的开发。&lt;/span&gt;&lt;span&gt;这样达到了降低代码开发成本的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZno36s2xnxsKibicKR4vfp3JYuyxhXFQOCFgMUNGw19eWDmyP7N45gwCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次是将计算逻辑使用Flink SQL来表达。因为SQL在数据开发过程中是一种通用性较强的方式，并且其学习成本或研发、维护等等成本相对较低。采用以上两种方式需要解决前文提到的难点，下面看具体方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里构建了一个产品RDM Building用来完成维度建模构建工作。它主要分为三层（Components Config、RDDM Component Builder、RDDM Component Parse），首先用户可以写组件配置，然后构建器会根据配置生成对应的一些组件对象，接着组件对象通过RDDM Component Parse就会将对应的组件转化Flink SQL算子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如使用A、B、C三个流进行关联计算，它们都是通过同样一组key关联，其关联键是相同的，最终关联生成一个结果表。这类操作可以使用His Rows Component组件进行处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它负责的过程是将A、B、C流分别对应的KV存储里面存储的历史数据取出，拿到对应的关联历史数据，比如A流数据过来就取到对应的关联的B表跟C表的历史数据。同样的针对B流，会将关联的A流跟C流的历史信息也都取出。对于C表也是如此。这样需要关联的所有历史数据，再组合成对应的A&#x27;、 B&#x27;、C&#x27;，其种A&#x27;不仅包含了A当前的数据，还包含了A要跟其它流关联的、相关的历史数据。所以在A&#x27;、 B&#x27;、C&#x27;里面，不仅有A、B、C流数据，而且包含了对应的历史数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照以上设计，实时流的历史数据可以一直保存，那就基本解决历史数据这个难点。还需要考虑的问题是cache随着时间增长存不下，或者因cache太大导致速度很慢。又或者使用rocksdb的方式发现性能较低，但同时缺乏rocksdb方面优化的专业能力。但可以相对较为成熟的KV存储，而且数据可能本身使用KV存储进行保存。那么直接使用KV存储就能解决历史数据问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图可以看到His Rows Component组件的详细执行过程，我们以这个组件为例来进行展开分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZ0G2OAPc9W15UescZl2OII4h0kTOr0XZZO9C1P0HjrQXdfbMetd0v4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，我们拿到A、B、C三个流表，拿到之后先根据其对应的组件去做keyBy操作，再去做窗口聚合。窗口聚合的功能是什么？在实际业务过程中，A表的业务数据在处理过程中可能存在事务操作。它的事务操作里面可能存在先签了一条记录，然后再把里面改了一下某一个值；也可能先删了一条记录，然后又插入了一条记录。这取决于业务系统的多样性操作，所以可能存在业务上只做了一次变动，但发了若干条消息对应的binlog。那就需要首先对其进行微批处理，来减少我们处理的记录数，然后处理生成A、B、C一一对应的三个流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着再把它们进行格式转换，转换成对应的tuple。比如相同的一个格式，可能是表名、分组键、主键以及转换成的统一的Bean结构。此处需要注意的问题是，对更新这种操作需要拆分。具体有两类，一类是插入的tuple，一类是删除的tuple，它会有对应两条记录，一条删除的一条新增的。在统一格式之后，再把它们union(合并)到同一个流，然后根据相同的关联键去做keyBy。这个过程中合流统一keyBy，是想用这种方式把所有的需要关联的流数据通过相同的键去做keyBy然后做分发，保证的结果是使相同存储键的记录分发到相同slot，以提升缓存利用率。从KV Storage获取数据，或者过程中使用的缓存的高命中率，包括缓存的有效性，以及缓存一致性，即最终同样的一个key一定会落到同一个slot上去计算。这样就能够保证不会存在多个slot上都存了同一个关联键的一些信息，从而可以避免不一致或先后问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;得到keyBy之后的结果，下一步经过flatmap算子，可以把历史数据从cache缓存、KV存储中加载进来。加载进来之后再比较它们的消息的id，如果是最新记录则就写入cache及KV存储并向下发送记录。当A流来了，关联的是B流历史跟C流历史；当B流来了，同样会关联A流历史和C流历史。同理C流也是如此。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下一步把从hisStreams流中分拆加载出来的数据流，合并得到包含历史数据的A_all、B_all、C_all 中，并用于下一步SQL计算。这个功能是将A、B、C流映射成了A_all、B_all、C_all，即所有的SQL逻辑就都可以直接写Flink SQL并用这三个流表(A_all、B_all、C_all)去计算，如此就包含短时间内的历史数据在进行计算。当然如果缓存中有数据的话，就不需要从KV中加载。而且同样的key会发到同一个slot上，它的缓存的命中率是很高的。另外以上都是按关联键去存的，如果同时有A、B、C等多条消息来了之后，都会命中同一条KV存储的key，也会提升缓存命中率。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;规划&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以上是具体实现的方案，下面是我们后续的规划。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前在用户使用以上组件时，还存在较高的学习成本。后续我们可能会增加一个前端页面，可以直接生成基于类似流程图面板以及点击、拖拉拽等形式生成对应不同类型的组件。采用这种配置方式可以降低用户的学习成本，增加使用的便捷性。另外我们还要扩展底层对多种实时计算引擎的支持。现在采用RDDM Component Parse会把对应的组件转成Flink算子(keyBy、flatMap等)，但可能在某些应用场景下还会使用SparkStreaming，或其它实时计算引擎。针对这种场景，我们可以将其独立出来，供用户自由地选择实时计算引擎。在KV存储方面，目前以内部使用为主，暂时只支持HBase、redis这两类KV存储，也需要把这部分信息彻底地独立。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;今天的分享就到这里，谢谢大家。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在文末分享、点赞、在看，给个3连击呗~&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享嘉宾：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;289&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPheicIYiaJF26lh45fT4KIJdZfFZG3uicFhXh6VGdvk98b08a1KJyRQHstzZY2Xicv09eCBYMX8KIibWVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;免费福利：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&amp;amp;mid=2247566213&amp;amp;idx=1&amp;amp;sn=69e814aa3b3e8e988cc209ec942ee791&amp;amp;chksm=fbd671e9cca1f8ff9638e1b4c102e96faeb63db648aab222741b047fe357dcc8a37b9e126e0c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;互联网核心应用算法宝藏书PPT电子版下载！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;互联网核心应用算法宝藏书PPT电子版下载！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&amp;amp;mid=2247566135&amp;amp;idx=1&amp;amp;sn=9010e14646fbd877ff7da4165e0b2353&amp;amp;chksm=fbd6715bcca1f84d26d9fd178144c3acd465369fe3f5fe923e707790583189315c2dec4dbc36&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;大数据典藏版合集PPT电子书下载！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;大数据典藏版合集PPT电子书下载！&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;活动推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;1776&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1741&quot; data-galleryid=&quot;&quot; data-ratio=&quot;3.0722222222222224&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm0N8I0SyMfKANGoTtHU8BN3T3k9wBMt80mI237XrFP6DdINrUKKWOXCfica9q96liaK11MLeFdnKEuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关于我们：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;DataFun：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;专注于大数据、人工智能技术应用的分享与交流。发起于2017年，在北京、上海、深圳、杭州等城市举办超过100+线下和100+线上沙龙、论坛及峰会，已邀请近1000位专家和学者参与分享。其公众号 DataFunTalk 累计生产原创文章500+，百万+阅读，13万+精准粉丝。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1NTMyOTI4Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh87SyjsEtoRFs9iaLyPXYh9ls0BcsiaPDnFkg72xgLsvku13ZRYibyq93DgRoCaTaTkbJj7Hia4dvI1w/0?wx_fmt=png&quot; data-nickname=&quot;DataFunTalk&quot; data-alias=&quot;datafuntalk&quot; data-signature=&quot;专注于大数据、人工智能技术应用的分享与交流。致力于成就百万数据科学家。定期组织技术分享直播，并整理大数据、推荐/搜索算法、广告算法、NLP 自然语言处理算法、智能风控、自动驾驶、机器学习/深度学习等技术应用文章。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;🧐&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;，给个&lt;strong&gt;3连击&lt;/strong&gt;呗！&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>