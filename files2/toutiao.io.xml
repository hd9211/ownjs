<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c1d0db8073c1faaac504e2f71d432d27</guid>
<title>面试官问: 如何设计一个高并发系统?</title>
<link>https://toutiao.io/k/7hrrplb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;题目描述&lt;/h2&gt;

&lt;p&gt;面试官有时在面试中会直接问你：你是如何设计一个高并发系统？&lt;/p&gt;

&lt;h2&gt;面试官心理分析（解题思维方向）&lt;/h2&gt;

&lt;p&gt;说实话，如果面试官问你这个题目，那么你必须要使出全身吃奶劲了。为啥？因为你没看到现在很多公司招聘的 JD 里都是说啥，有高并发就经验者优先。&lt;/p&gt;

&lt;p&gt;如果你确实有真才实学，在互联网公司里干过高并发系统，那你确实拿 offer 基本如探囊取物，没啥问题。面试官也绝对不会这样来问你，否则他就是蠢。&lt;/p&gt;

&lt;p&gt;假设你在某知名电商公司干过高并发系统，用户上亿，一天流量几十亿，高峰期并发量上万，甚至是十万。那么人家一定会仔细盘问你的系统架构，你们系统啥架构？怎么部署的？部署了多少台机器？缓存咋用的？MQ 咋用的？数据库咋用的？就是深挖你到底是如何扛住高并发的。&lt;/p&gt;

&lt;p&gt;因为真正干过高并发的人一定知道，脱离了业务的系统架构都是在纸上谈兵，真正在复杂业务场景而且还高并发的时候，那系统架构一定不是那么简单的，用个 redis，用 mq 就能搞定？当然不是，真实的系统架构搭配上业务之后，会比这种简单的所谓“高并发架构”要复杂很多倍。&lt;/p&gt;

&lt;p&gt;如果有面试官问你个问题说，如何设计一个高并发系统？那么不好意思，一定是因为你实际上没干过高并发系统。面试官看你简历就没啥出彩的，感觉就不咋地，所以就会问问你，如何设计一个高并发系统？其实说白了本质就是看看你有没有自己研究过，有没有一定的知识积累。&lt;/p&gt;

&lt;p&gt;最好的当然是招聘个真正干过高并发的哥儿们咯，但是这种哥儿们人数稀缺，不好招。所以可能次一点的就是招一个自己研究过的哥儿们，总比招一个啥也不会的哥儿们好吧！
所以这个时候你必须得做一把个人秀了，秀出你所有关于高并发的知识！&lt;/p&gt;

&lt;h2&gt;面试题剖析&lt;/h2&gt;

&lt;p&gt;其实所谓的高并发，如果你要理解这个问题呢，其实就得从高并发的根源出发，为啥会有高并发？为啥高并发就很牛逼？&lt;/p&gt;

&lt;p&gt;我说的浅显一点，很简单，就是因为刚开始系统都是连接数据库的，但是要知道数据库支撑到每秒并发两三千的时候，基本就快完了。所以才有说，很多公司，刚开始干的时候，技术比较 low，结果业务发展太快，有的时候系统扛不住压力就挂了。&lt;/p&gt;

&lt;p&gt;当然会挂了，凭什么不挂？你数据库如果瞬间承载每秒 5000/8000，甚至上万的并发，一定会宕机，因为比如 mysql 就压根儿扛不住这么高的并发量。&lt;/p&gt;

&lt;p&gt;所以为啥高并发牛逼？就是因为现在用互联网的人越来越多，很多 app、网站、系统承载的都是高并发请求，可能高峰期每秒并发量几千，很正常的。如果是什么双十一之类的，每秒并发几万几十万都有可能。&lt;/p&gt;

&lt;p&gt;那么如此之高的并发量，加上原本就如此之复杂的业务，咋玩儿？真正厉害的，一定是在复杂业务系统里玩儿过高并发架构的人，但是你没有，那么我给你说一下你该怎么回答这个问题：&lt;/p&gt;

&lt;p&gt;可以分为以下 6 点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;系统拆分&lt;/li&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;li&gt;MQ&lt;/li&gt;
&lt;li&gt;分库分表&lt;/li&gt;
&lt;li&gt;读写分离&lt;/li&gt;
&lt;li&gt;ElasticSearch&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;系统拆分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现
在多个数据库，不也可以扛高并发么。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一
份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考
虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MQ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，后边系统消费后慢慢写，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的，这个之前还特意说过。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分库分表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高 sql 跑的性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;读写分离&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ElasticSearch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。&lt;/p&gt;

&lt;p&gt;上面的 6 点，基本就是高并发系统肯定要干的一些事儿，大家可以仔细结合之前讲过的知识考虑一下，到时候你可以系统的把这块阐述一下，然后每个部分要注意哪些问题，之前都讲过了，你都可以阐述阐述，表明你对这块是有点积累的。&lt;/p&gt;

&lt;h2&gt;考题变形&lt;/h2&gt;



&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;其实实际上在真正的复杂的业务系统里，做高并发要远远比上面提到的点要复杂几十倍到上百倍。你需要考虑：哪些需要分库分表，哪些不需要分库分表，单库单表跟分库分表如何 join，哪些数据要放到缓存里去，放哪些数据才可以扛住高并发的请求，你需要完成对一个复杂业务系统的分析之后，然后逐步逐步的加入高并发的系统架构的改造&lt;/p&gt;

&lt;h2&gt;号外号外&lt;/h2&gt;

&lt;p&gt;给大家整理了Java最新大厂面试题及答案，并且整理成了PDF格式方便阅读。 欢迎大家关注”浅谈架构“ 公众号 (后台私信”面试“即可获取)。另外需要大厂内推同学也可以私信我。 &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.bytearch.com/images/mianshiti.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.bytearch.com/images/wxgzh.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7af0885bb4ddd5ecd6d8bf0631a36e80</guid>
<title>原来这才是动态代理！！！</title>
<link>https://toutiao.io/k/ectyif9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各位小伙伴们大家吼啊！我是 cxuan，距离上次更新已经有段时间了，临近过年了，项目这边也比较忙，而且最近很多时间都花在看书、提升自己上面，文章写的比较拖沓，这里我要自我反思（其实我已经筹备了几篇文章，就等结尾了，嘿嘿嘿）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们上篇文章聊了一波什么是动态代理，然后我又从动态代理的四种实现为切入点，为你讲解 JDK 动态代理、CGLIB 动态代理、Javaassist、ASM 反向生成字节码的区别，具体的内容你可以参见下面这篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&amp;amp;mid=2247495729&amp;amp;idx=1&amp;amp;sn=a8960d2bf5a3cb61ad1cbd4fe0f547bc&amp;amp;chksm=c04ae76ff73d6e79f0f786666dfc769fda050c497d9b5ce2a40e4218fa409c9c87640c9834af&amp;amp;token=65407122&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;动态代理竟然如此简单！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这篇文章我们来聊一下动态代理的&lt;code&gt;实现原理&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保险起见，我们首先花几分钟回顾一下&lt;strong&gt;什么是动态代理吧&lt;/strong&gt;！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是动态代理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，动态代理是&lt;code&gt;代理模式&lt;/code&gt;的一种实现方式，代理模式除了动态代理还有 &lt;code&gt;静态代理&lt;/code&gt;，只不过静态代理能够在编译时期确定类的执行对象，而动态代理只有在运行时才能够确定执行对象是谁。代理可以看作是对最终调用目标的一个封装，&lt;strong&gt;我们能够通过操作代理对象来调用目标类，这样就可以实现调用者和目标对象的解耦合&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动态代理的应用场景有很多，最常见的就是 &lt;strong&gt;AOP 的实现、RPC 远程调用、Java 注解对象获取、日志框架、全局性异常处理、事务处理等&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动态代理的实现有很多，但是 JDK 动态代理是很重要的一种，下面我们就 JDK 动态代理来深入理解一波。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JDK 动态代理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们先来看一下动态代理的执行过程&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5746971736204576&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaT40LtvZPBHqrnpUGk6DMoLR8sO2ceHpP6hDyJNdgOHqzcIpKKOfX7LxhDIHAYtxUZSLgHIn5cS8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1486&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 JDK 动态代理中，实现了 &lt;code&gt;InvocationHandler&lt;/code&gt; 的类可以看作是 &lt;code&gt;代理类&lt;/code&gt;(因为类也是一种对象，所以我们上面为了描述关系，把代理类形容成了代理对象)。JDK 动态代理就是围绕实现了 InvocationHandler 的代理类进行的，比如下面就是一个 InvocationHandler 的实现类，同时它也是一个代理类。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserHandler&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InvocationHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserDao userDao;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;UserHandler&lt;/span&gt;&lt;span&gt;(UserDao userDao)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.userDao = userDao;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;invoke&lt;/span&gt;&lt;span&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        saveUserStart();&lt;br/&gt;        Object obj = method.invoke(userDao, args);&lt;br/&gt;        saveUserDone();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; obj;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;saveUserStart&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;---- 开始插入 ----&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;saveUserDone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;---- 插入完成 ----&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代理类一个最最最重要的方法就是 &lt;code&gt;invoke&lt;/code&gt; 方法，它有三个参数&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Object proxy&lt;/code&gt;: 动态代理对象，关于这个方法我们后面会说。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Method method&lt;/code&gt;: 表示最终要执行的方法，method.invoke 用于执行被代理的方法，也就是真正的目标方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Object[] args&lt;/code&gt;: 这个参数就是向目标方法传递的参数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们构造好了代理类，现在就要使用它来实现我们对目标对象的调用，那么如何操作呢？请看下面代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;dynamicProxy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  UserDao userDao = &lt;span&gt;new&lt;/span&gt; UserDaoImpl();&lt;br/&gt;  InvocationHandler handler = &lt;span&gt;new&lt;/span&gt; UserHandler(userDao);&lt;br/&gt;&lt;br/&gt;  ClassLoader loader = userDao.getClass().getClassLoader();&lt;br/&gt;  Class&amp;lt;?&amp;gt;[] interfaces = userDao.getClass().getInterfaces();&lt;br/&gt;&lt;br/&gt;  UserDao proxy = (UserDao)Proxy.newProxyInstance(loader, interfaces, handler);&lt;br/&gt;  proxy.saveUser();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要用 JDK 动态代理的话，就需要知道&lt;code&gt;目标对象&lt;/code&gt;的&lt;strong&gt;类加载器、目标对象的接口，当然还要知道目标对象是谁&lt;/strong&gt;。构造完成后，我们就可以调用 &lt;code&gt;Proxy.newProxyInstance&lt;/code&gt;方法，然后把类加载器、目标对象的接口、目标对象绑定上去就完事儿了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里需要注意一下 &lt;code&gt;Proxy&lt;/code&gt; 类，它就是动态代理实现所用到的代理类。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Proxy 位于&lt;code&gt;java.lang.reflect&lt;/code&gt; 包下，这同时也旁敲侧击的表明动态代理的本质就是&lt;code&gt;反射&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就围绕 JDK 动态代理，来深入理解一下它的原理，以及搞懂为什么动态代理的本质就是反射。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;动态代理的实现原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解动态代理的实现原理之前，我们先来了解一下 InvocationHandler 接口&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;InvocationHandler 接口&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JavaDoc 告诉我们，InvocationHandler 是一个接口，实现这个接口的类就表示该类是一个代理实现类，也就是代理类。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.618595825426945&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaT40LtvZPBHqrnpUGk6DMoLzYzI9T1amvjIY9YjrYXg8BWLE6JldCOABxZJOtjzpoe3e6UOXPhd6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1054&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InvocationHandler 接口中只有一个 invoke 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动态代理的优势在于能够很方便的对代理类中方法进行集中处理，而不用修改每个被代理的方法。因为所有被代理的方法（真正执行的方法）都是通过在 InvocationHandler 中的 invoke 方法调用的。所以我们只需要对 invoke 方法进行集中处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;invoke 方法只有三个参数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;invoke&lt;/span&gt;&lt;span&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; Throwable&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;proxy：代理对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;method: 代理对象调用的方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;args：调用方法中的参数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动态代理的整个代理过程不像静态代理那样一目了然，清晰易懂，因为在动态代理的过程中，我们没有看到代理类的真正代理过程，也不明白其具体操作，所以要分析动态代理的实现原理，我们必须借助&lt;code&gt;源码&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，首先第一步应该从哪分析？如果不知道如何分析的话，干脆就使用&lt;code&gt;倒推法&lt;/code&gt;，从后往前找，我们直接先从 &lt;em&gt;Proxy.newProxyInstance&lt;/em&gt;入手，看看是否能略知一二。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Proxy.newInstance 方法分析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Proxy 提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Proxy.newProxyInstance 源码（java.lang.reflect.Proxy）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object &lt;span&gt;newProxyInstance&lt;/span&gt;&lt;span&gt;(ClassLoader loader,&lt;br/&gt;                                      Class&amp;lt;?&amp;gt;[] interfaces,&lt;br/&gt;                                      InvocationHandler h)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;throws&lt;/span&gt; IllegalArgumentException&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  Objects.requireNonNull(h);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt;[] intfs = interfaces.clone();&lt;br/&gt;  &lt;span&gt;final&lt;/span&gt; SecurityManager sm = System.getSecurityManager();&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (sm != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    checkProxyAccess(Reflection.getCallerClass(), loader, intfs);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  Class&amp;lt;?&amp;gt; cl = getProxyClass0(loader, intfs);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (sm != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      checkNewProxyPermission(Reflection.getCallerClass(), cl);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Constructor&amp;lt;?&amp;gt; cons = cl.getConstructor(constructorParams);&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; InvocationHandler ih = h;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!Modifier.isPublic(cl.getModifiers())) {&lt;br/&gt;      AccessController.doPrivileged(&lt;span&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;Void&amp;gt;() {&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Void &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;          cons.setAccessible(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;      });&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; cons.newInstance(&lt;span&gt;new&lt;/span&gt; Object[]{h});&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;乍一看起来有点麻烦，其实源码都是这样，看起来非常复杂，但是慢慢分析、厘清条理过后就好，最重要的是分析源码不能着急。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个 Proxy.newProxyInstsance 其实就做了下面几件事，我画了一个流程图作为参考。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5645161290322581&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaT40LtvZPBHqrnpUGk6DMoLZxTZicBLhiaEKcicHd3XZHSq38awb0VibAShEvKhtJgtyqdbH3RbO7hoSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2356&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图中我们也可以看出，newProxyInstsance 方法最重要的几个环节就是获得代理类、获得构造器，然后构造新实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对反射有一些了解的同学，应该会知道获得构造器和构造新实例是怎么回事。关于反射，可以参考笔者的这篇文章&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&amp;amp;mid=2247495851&amp;amp;idx=1&amp;amp;sn=fe53ba6e2f2d1098fb0c8cd82420e885&amp;amp;chksm=c04ae7f5f73d6ee35caa07a1ecb649d99aba9248e0db1178c0526f524c9f1f66abe37f76a246&amp;amp;token=65407122&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;学会反射后，我被录取了！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们的重点就放在了&lt;strong&gt;获得代理类&lt;/strong&gt;，这是最关键的一步，对应源码中的 &lt;em&gt;Class&amp;lt;?&amp;gt; cl = getProxyClass0(loader, intfs);&lt;/em&gt; 我们进入这个方法一探究竟&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Class&amp;lt;?&amp;gt; getProxyClass0(ClassLoader loader,&lt;br/&gt;                                           Class&amp;lt;?&amp;gt;... interfaces) {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (interfaces.length &amp;gt; &lt;span&gt;65535&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;interface limit exceeded&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; proxyClassCache.get(loader, interfaces);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法比较简单，首先会直接判断接口长度是否大于 65535（刚开始看到这里我是有点不明白的，我心想这个判断是要判断什么？interfaces 这不是一个 class 类型吗，从 length 点进去也看不到这个属性，细看一下才明白，这居然是&lt;em&gt;可变参数&lt;/em&gt;，&lt;em&gt;Class ...&lt;/em&gt; 中的 ... 就是可变参数，所以这个判断我猜测应该是判断接口数量是否大于 65535。）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后会直接从 proxyClassCache 中根据 loader 和 interfaces 获取代理对象实例。&lt;strong&gt;如果能够根据 loader 和 interfaces 找到代理对象，将会返回缓存中的对象副本；否则，它将通过 ProxyClassFactory 创建代理类&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;proxyClassCache.get 就是一系列从缓存中的查询操作，注意这里的 proxyClassCache 其实是一个 &lt;em&gt;WeakCache&lt;/em&gt;，WeakCahe 也是位于 java.lang.reflect 包下的一个缓存映射 map，它的主要特点是一个弱引用的 map，但是它内部有一个 SubKey ，这个子键却是强引用的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里我们不用去追究这个 proxyClassCache 是如何进行缓存的，只需要知道它的缓存时机就可以了：即在类加载的时候进行缓存。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果无法找到代理对象，就会通过 ProxyClassFactory 创建代理，ProxyClassFactory 继承于 BiFunction&lt;span/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ProxyClassFactory&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BiFunction&lt;/span&gt;&amp;lt;&lt;span&gt;ClassLoader&lt;/span&gt;, &lt;span&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt;[], &lt;span&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt;&amp;gt;&lt;br/&gt;    &lt;/span&gt;{...}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ProxyClassFactory 里面有两个属性一个方法。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5432276657060519&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaT40LtvZPBHqrnpUGk6DMoLSco7QPjKBGWA2mQKe64ht4CoGcumEBicnT0lic5ib1PSdqvVsoMnq6yMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1388&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;proxyClassNamePrefix：这个属性表明使用 ProxyClassFactory 创建出来的代理实例的命名是以 &quot;$Proxy&quot; 为前缀的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;nextUniqueNumber：这个属性表明 ProxyClassFactory 的后缀是使用 AtomicLong 生成的数字&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以代理实例的命名一般是 &lt;em&gt;&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;Proxy0 、&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 4368.5 955&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;50&quot; d=&quot;M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(751, 0)&quot;&gt;&lt;path data-c=&quot;72&quot; d=&quot;M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1202, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1687, 0)&quot;&gt;&lt;path data-c=&quot;78&quot; d=&quot;M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2259, 0)&quot;&gt;&lt;path data-c=&quot;79&quot; d=&quot;M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(2749, 0)&quot;&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3526.8, 0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot; font-size=&quot;841.9px&quot; font-family=&quot;serif&quot;&gt;、&lt;/text&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;Proxy1&lt;/em&gt;这种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 apply 方法是一个&lt;strong&gt;根据接口和类加载器进行代理实例创建的工厂方法&lt;/strong&gt;，下面是这段代码的核心。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; apply(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces) {&lt;br/&gt;&lt;br/&gt;  ...&lt;br/&gt;    &lt;br/&gt;  &lt;span&gt;long&lt;/span&gt; num = nextUniqueNumber.getAndIncrement();&lt;br/&gt;  String proxyName = proxyPkg + proxyClassNamePrefix + num;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;byte&lt;/span&gt;[] proxyClassFile = ProxyGenerator.generateProxyClass(&lt;br/&gt;    proxyName, interfaces, accessFlags);&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; defineClass0(loader, proxyName,&lt;br/&gt;                        proxyClassFile, &lt;span&gt;0&lt;/span&gt;, proxyClassFile.length);&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (ClassFormatError e) {&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(e.toString());&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，代理实例的命名就是我们上面所描述的那种命名方式，只不过它这里加上了 &lt;em&gt;proxyPkg&lt;/em&gt; 包名的路径。然后下面就是生成代理实例的关键代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ProxyGenerator.generateProxyClass 我们跟进去是只能看到 .class 文件的，class 文件是虚拟机编译之后的结果，所以我们要看一下 .java 文件源码。.java 源码位于 &lt;em&gt;OpenJDK&lt;/em&gt;中的 sun.misc 包中的 ProxyGenerator 下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此类的 generateProxyClass() 静态方法的核心内容就是去调用 generateClassFile() 实例方法来生成 Class 文件。方法太长了我们不贴了，这里就大致解释以下其作用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一步：收集所有要生成的代理方法，将其包装成 ProxyMethod 对象并注册到 Map 集合中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二步：收集所有要为 Class 文件生成的字段信息和方法信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三步：完成了上面的工作后，开始组装 Class 文件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 defineClass0 这个方法我们点进去是 native ，底层是 C/C++ 实现的，于是我又去看了一下 C/C++ 源码，路径在&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.15566625155666253&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaT40LtvZPBHqrnpUGk6DMoLKI3YJl1xnDkzcHaAUmSLABDF2icAN3jbrnUxDy64lTghDxYm8V7wVeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1606&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点开之后的 C/C++ 源码还是挺让人绝望的。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9787234042553191&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaT40LtvZPBHqrnpUGk6DMoL8PWkU4XFgwhjqzXrjMz88oZvNT8tpAzUQzCJgTNxWwFsfZibvymQgcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1128&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过我们再回头看一下这个 defineClass0 方法，它实际上就是根据上面生成的 proxyClassFile 字节数组来生成对应的实例罢了，所以我们不必再深究 C/C++ 对于代理对象的合成过程了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以总结一下可以看出，JDK 为我们的生成了一个叫 $Proxy0 的代理类，这个类文件放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以最开始的 dynamicProxy 方法我们反编译后的代码就是这样的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; $&lt;span&gt;Proxy0&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;.&lt;span&gt;lang&lt;/span&gt;.&lt;span&gt;reflect&lt;/span&gt;.&lt;span&gt;Proxy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;.&lt;span&gt;cxuan&lt;/span&gt;.&lt;span&gt;dynamic&lt;/span&gt;.&lt;span&gt;UserDao&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; $Proxy0(java.lang.reflect.InvocationHandler) &lt;span&gt;throws&lt;/span&gt; ;&lt;br/&gt;    Code:&lt;br/&gt;       &lt;span&gt;0&lt;/span&gt;: aload_0&lt;br/&gt;       &lt;span&gt;1&lt;/span&gt;: aload_1&lt;br/&gt;       &lt;span&gt;2&lt;/span&gt;: invokespecial #&lt;span&gt;8&lt;/span&gt;                  &lt;span&gt;// Method java/lang/reflect/Proxy.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/reflect/InvocationHandler;)V&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;5&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到代理类继承了 Proxy 类，所以也就决定了 Java 动态代理只能对接口进行代理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3715976331360947&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaT40LtvZPBHqrnpUGk6DMoLuPsj5fic0ic2l8kibXZuAkk1Ok50ElGQFpZ6iaDtCcvYj3kTnyoVHRicdSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1690&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，上面这个图你应该就可以看懂了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;invoke 方法中第一个参数 proxy 的作用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;细心的小伙伴们可能都发现了，invoke 方法中第一个 proxy 的作用是啥？代码里面好像 proxy 也没用到啊，这个参数的意义是啥呢？它运行时的类型是啥啊？为什么不使用 this 代替呢？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.24408468244084683&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaT40LtvZPBHqrnpUGk6DMoLSmicC5ElCdkdHSQAL233icj9WQlIbSnHkTrqtRk6sWRcPzOfhgADLMLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1606&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Stackoverflow 给出了我们一个回答 https://stackoverflow.com/questions/22930195/understanding-proxy-arguments-of-the-invoke-method-of-java-lang-reflect-invoca&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么意思呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是说这个 proxy ，它是真正的代理对象，invoke 方法可以返回调用代理对象方法的返回结果，也可以返回对象的真实代理对象，也就是 $Proxy0，这也是它运行时的类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于为什么不用 this 来代替 proxy，因为实现了 InvocationHandler 的对象中的 this ，指代的还是 InvocationHandler 接口实现类本身，而不是真实的代理对象。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，这段时间公众号出了一些状况，大家在公众号回复的一些关键词都没有对应的连接了，这里和大家说明抱歉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过从今天开始，公众号已经正常了，大家可以在公众号后台回复「cxuan」和「网络」领取我自己写的 PDF 哦！&lt;/p&gt;&lt;p&gt;&lt;span&gt; 往期推荐 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;🔗&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&amp;amp;mid=2247494651&amp;amp;idx=1&amp;amp;sn=32934fc5f1b2fef8404fc9f86d195eef&amp;amp;chksm=e99a1ee9deed97ffb3574fac2ba0de974d18d2f3b6c5726082c0c8b963ac9e446fd01beadfc8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;这篇 Linux 总结的很棒啊！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;这篇 Linux 总结的很棒啊！&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&amp;amp;mid=2247494643&amp;amp;idx=1&amp;amp;sn=96b35e6e29ced2e7f1b6ab70570ddf26&amp;amp;chksm=e99a1ee1deed97f78dd868040c7bf05b839b42eef718b7b0ad0ee5818aab7f55b68f71a60905&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;看完这篇 Linux 权限，通透了！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;看完这篇 Linux 权限，通透了！&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&amp;amp;mid=2247494560&amp;amp;idx=1&amp;amp;sn=7eaaf866cfe676a87aacc2bde3e996bb&amp;amp;chksm=e99a1eb2deed97a440151894b506b4419f492c5c1efb49b2fd663e09d4b8bf9c73ea89fe721a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;李纳斯是个怎样的人？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;李纳斯是个怎样的人？&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&amp;amp;mid=2247494554&amp;amp;idx=1&amp;amp;sn=6cfa7a5ac3bd443e7734b0a688b53294&amp;amp;chksm=e99a1e88deed979ed721e9885dcb4a0ac86bd4fd14eb76056832050762eeb9b8c7423870f2fc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;原来这才是 Socket！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;原来这才是 Socket！&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&amp;amp;mid=2247494528&amp;amp;idx=1&amp;amp;sn=0275a178c09c191a899b6588c576e1ab&amp;amp;chksm=e99a1e92deed978453a2e9d75705e5a23066f08bc01946d2eb5980274f80a93d0a1f499a35cb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;手撕汇编。。。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;手撕汇编。。。&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100010184&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6883239171374764&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQ3d20HJqInIIvpwO7Cea3T3SBnpOFQRYzwpH5j9Ribebt635yyUBib3saV7ibSnwceXWeY9ibYJ4xjSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2124&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100010183&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8695652173913043&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQ3d20HJqInIIvpwO7Cea3TkxFhCaIWx35YOv5S7BqH9hDNJtqIKmNharSjCFgJCC418VEEXh8tDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>66249416ff47ba02ea2d7dc8be098837</guid>
<title>谈谈服务治理</title>
<link>https://toutiao.io/k/fvpd29b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;　　本文首发于2017年，这次只是留存到公众号上，让自己记住当初那个没把告警治理当成自己的事情来做的我。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;本期我们组的技术分享，打算跟大家讲讲服务治理。我在上篇文章中介绍了我们美团.点评北京总部用的OCTO框架，其实在上海点评部门用的是另一套Pigeon。这两套框架都很重。这是和我们的业务有关的，其实服务治理这个东西从创业公司到成熟的大公司都在用，只是做到的程度不同。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;　　先说说服务治理的边界。本质上任何能提升服务可用性，性能，让服务更稳定等等，只要是能让服务运行的更好，都属于服务治理的范畴。服务治理比较常见的话题：服务发现，服务变更管理，服务监控，服务扩容缩容，服务自我保护，服务降级，服务授权防攻击，服务上线验证和灰度发布，服务问题定位和跟踪，服务负载，服务实例的调度等等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;　　说服务治理就要先聊聊服务。从业务角度而言，服务是一个可重复的任务。我是个做业务的，业务可以被粗粒度的划分为一系列粗粒度的服务和流程。这本质上符合SOA架构的风格，而现在比较流行的微服务出现实际上应当归功于SOA原则的成功。而微服务将服务划分的更细，更多，会导致出问题的概率变大。这时候，服务治理的手段没有进步的话，实际上服务的压力是变大了。所以大家在选择架构的时候，需要按照自己的业务发展现状和趋势合理的辩证的做决断。就好像我在上篇文章里举的例子：如果要建一间房子，可能随便建个土房子或者茅草房子就能用几十年，但是随着规模的扩大，建成四合院就要讲究格局，建成一个小区，建成一座城市，就需要运用各种工程学的知识更加统筹的规划。这就是为什么我要来美团。我在乐视其实过得很舒服，很自由。因为我家微微一笑很倾城的男神老大不仅英俊帅气，智商情商双高，而且管理风格open，很合适我这种有自己想法的下属。但是乐视各个部门更像是一个村落，大家都在各自建各自的房子，好处是有才能的人可以比较自由的发挥，缺点是格局不够统一，各个部门做了很多重复的工作。所以乐视出来的人有水平非常高的，也有水平非常一般的。我个人觉得如果你个人能力非常好，可以去乐视试一试，说不定可以发挥自己的潜能。但是对于我而言，我发现了自己格局的问题，如果我坚持还是要去阿里的话，到那边也是个拧螺丝的，平台很好，但是能不能发挥是个问题。而来美团，我至少能够得到的保证是：完成一个从对工作负责到对结果负责的转变。什么意思呢？我来这边，我们架构师说我来之前，他需要找各个开发去告诉他们我们的工作，每个开发都听明白了，然后回到工位完成了自己的那份工作。结果中间衔接的部分职责模糊的部分就很可能被漏掉了。我来了，我的工作是对结果负责，那么涉及到内部职责的划分，上下游的对接和业务了解。任何能让结果变得更好的事情都属于我的职责范围。这和服务治理的理念不谋而合，这就是为什么我要来研究服务治理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;　　我也自己创过业，做的最小的项目本质上也用到了服务治理相关的东西，就是nginx。nginx本身不处理业务逻辑。它做了什么事情呢？服务发现，负载均衡。我自己觉得与其将其归类为一个具体的服务组件，划分为服务治理组件更为合适。nginx的服务发现大家都知道是在upstream里配置的，可以做DNS动态解析。服务更变修改配置文件后用nginx -s reload让nginx发现最新的配置，可以说是一个轻巧简单的服务发现机制。nginx的负载均衡大家说的比较多了，我就不详述了。但是它做负载均衡的前提是它还实现了服务的分离。它可以将前端静态请求转发到静态服务上，动态api转发到api服务上，rpc调用转发到rpc服务上。nginx的服务治理能力还体现在所有这些分离的服务，请求的log都是走nginx服务，我们可以更方便的观察监控请求，所以相对于分散的服务有更好的治理能力的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;　　服务再大一些，就是用到另一个大家熟知的东西，就是zookeeper来做配置变更管理。有一本书叫做《从paxos到zookeeper》讲了zookeeper的内部实现，怎样保证其一致性和分区一致性。但是zookeeper的最大问题是网络抖动对其的影响。为了解决这个问题，美团.点评的OCTO服务治理框架采用了本地代理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;　　服务自动扩容缩容对于美团.点评这样的，交易时间高峰基本在中午11点到13点。这段时间交易量大，实际上是需要扩容来保证的。交易量低的时段机器闲置造成很大的资源浪费。这种自动扩容缩容需要区分是正常的请求扩容还是异常请求扩容。一个环节扩容会不会给其他环节造成更大的压力，反而压垮整个链路。如果是异常请求，这个时候应该采用的是拒绝请求。比如有数据库慢查询，显示调用结果是线程池满了，要排队。如果这时候采取了扩容，反而压垮数据库。这时候应该是报警而不是扩容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;　　在乐视的时候，阿里的阳哥自己开发了一个基于redis的异常日志收集器。这个其实也属于服务治理的范畴，这是一个统一的服务监控报警机制。报警是触发门槛很低的异常处理机制。所以我在乐视的时候邮件，手机短信报警太多了，我就想换了工作再也不用收这些报警了。结果，好吧，换工作后多了N倍。异常再达到一定量级，可能会触发过载保护。过载保护再不解决问题就要降级了。我之前博客里也提到的乐视用guava的RateLimiter做了限流，这就是过载保护的一种方式。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1e22e4414b07b7f0d29b33c0799106a1</guid>
<title>2022 年别再焦虑啦！加入我们！</title>
<link>https://toutiao.io/k/obimloc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e2942b7d42e782caaadd68dae1a38228</guid>
<title>Go 原生并发原语和最佳实践</title>
<link>https://toutiao.io/k/iuovf7l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是程序员幽鬼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 编程语言是用并发作为一等公民创建的。它是一种语言，通过抽象出语言中并发原语1背后的并行性细节，您可以轻松编写高度并行的程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大多数语言都将并行化作为标准库的一部分，或者期望开发者生态系统提供并行化库。通过在 Go 语言中包含并发原语，你可以编写并行性的程序，而无需了解编写并行代码的来龙去脉。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、并发（Concurrent）设计&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 的设计者非常重视并发设计，将其作为一种方法论，这种方法论的基础是交流关键信息，而不是阻塞和共享这些信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对并发设计的强调允许应用程序代码正确地按顺序或并行执行，而无需设计和实现并行化，这是常态。并发设计的想法并不新鲜，事实上一个很好的例子是从瀑布式开发到敏捷开发，这实际上是向并发工程实践（早期迭代、可重复过程）的转变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发设计是关于编写“正确”程序与编写“并行”程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 中构建并发程序时要问的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我是否堵塞在临界区？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;是否有更正确（如以 Go 为中心）的方式来编写此代码？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我可以通过通信来提高代码的功能性和可读性吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果其中任何一个是 Yes，那么你应该重新考虑你的设计，考虑用 Go 的最佳实践。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Communicating Sequential Processes (CSP)&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言的一部分的基础来自 Hoare 的一篇论文，该论文讨论了语言需要将并发视为语言的一部分而不是事后的想法。该论文提出了一种线程安全队列，它允许应用程序中不同进程之间的数据通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你通读这篇论文，你会发现Go 中的  &lt;code&gt;channel&lt;/code&gt; 原语与论文中对原语的描述非常相似，实际上这来自 Rob Pike 之前基于 CSP 构建语言的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Pike 的一次演讲中，他将真正的问题确定为“需要一种方法来编写并发软件，以指导我们的设计和实现。”他接着说并发编程不是让程序并行化以更快地运行，而是“利用流程和通信的力量来设计优雅、响应迅速、可靠的系统。”&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;通过通信实现并发&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从 Go 的创建者那里听到的最常见的短语之一是：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Don’t communicate by sharing memory, share memory by communicating. - Rob Pike&lt;/p&gt;&lt;p&gt;即：不要通过共享内存来通信，而是通过通信来共享内存。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种观点反映了 Go 是基于 CSP 的事实，并且该语言具有用于在线程之间通信的本机原语（goroutine）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的代码是使用通信而不是使用 mutex 来管理对共享资源的访问的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Adapted from https://github.com/devnw/ttl&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// a TTL cache implementation for Go.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;readwriteloop&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;  incoming &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{},&lt;br/&gt;)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt;   &lt;span&gt;// Create a channel to send data to.&lt;/span&gt;&lt;br/&gt;  outgoing = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{})&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;    incoming &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{},&lt;br/&gt;    outgoing &lt;span&gt;chan&lt;/span&gt;&amp;lt;- &lt;span&gt;interface&lt;/span&gt;{},&lt;br/&gt;    )&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(outgoing)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// `value` is the shared &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// resource or critical section.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; value &lt;span&gt;interface&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// incoming is the channel where data is&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// sent to set the shared resource.&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; v, ok := &amp;lt;-incoming:&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;// Exit the go routine.&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Write the data to the shared resource.&lt;/span&gt;&lt;br/&gt;        value = v.v&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// outgoing is the channel that &lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// the shared resource on request&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; outgoing &amp;lt;- value:&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }(incoming, outgoing)&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; outgoing&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们看一下代码，看看它做了什么。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;请注意，这没有使用 &lt;code&gt;sync&lt;/code&gt; 包或任何阻塞函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此代码仅使用 Go 并发原语 &lt;code&gt;go&lt;/code&gt;,&lt;code&gt;select&lt;/code&gt;和&lt;code&gt;chan&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;共享资源的所有权由 goroutine 管理。（第 17 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;即使该方法包含一个 goroutine，对共享资源的访问也不会并行发生。（第 30 和 34 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该 &lt;code&gt;select&lt;/code&gt; 语句用于检查读取或写入请求。（第 24 和 34 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 incoming 会更新该值。（第 24 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 goroutine 外部读取的通道使用共享资源的当前值执行对 outgoing 写入。（第 34 行）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于单个 goroutine 本身没有并行性，因此可以通过返回的只读通道安全地访问共享资源 。事实上，&lt;code&gt;select&lt;/code&gt; 这里使用该语句提供了许多好处。选择原语部分对此进行了更详细的介绍。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;堵塞 vs 通信&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堵塞：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;暂停临界区读/写的进程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要了解阻塞的&lt;strong&gt;必要性&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要了解如何避免竞争和死锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存元素由多个进程/线程直接共享&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通信：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据要求共享临界区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当有事情要做时，进程开始工作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存元素是通过通信共享，而不是直接共享的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、Go 原生并发原语&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Goroutine&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是 Goroutine？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;goroutine 是轻量级的线程。一旦 goroutine 从父 goroutine 中分离出来，它就会被移交给 Go 运行时执行。然而，与&amp;amp;in不同的是，bash这些进程被安排在 Go 运行时中执行，而不必并行执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2294455066921606&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowRmDVNKzB72JQwjiaFbUqiaz6lwnibYdtV5HkMD8hIKGgIaVR6NeIpWYGZAheTjDXlLVgWCGgOat49VA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;Goroutine 拆分示例&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里“调度”的区别很重要，因为 Go 运行时多路复用 goroutine 的执行，以提高操作系统调度之上的性能。这意味着无法对 goroutine 何时执行做出任何假设。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Goroutine 的泄露&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由 &lt;code&gt;go&lt;/code&gt; 原语创建的 goroutine 很轻量，但重要的是要知道它们&lt;strong&gt;不是&lt;/strong&gt;免费的。清理 goroutine 对于确保在 Go 运行时中正确收集资源非常重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应该花时间在设计上考虑清理。确保长时间运行的 goroutine 在发生故障时正确退出。同样重要的是不要创建无数的 goroutine。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成一个 goroutine 很简单，因此很容易无节制的生成新的 goroutine，生成的每个 goroutine 的最小开销约为 2kb。如果你的代码创建了太多 goroutine，并且每个 goroutine 都有很大的开销，那么栈空间可能不够。这在生产环境中调试起来非常困难，因为很难判断堆栈在哪里溢出以及堆栈在哪里泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当发生堆栈溢出时，运行时将 panic，程序将退出，每个 goroutine 都会将堆栈信息打印到标准错误。这会在日志中产生大量噪音并且不是很有用。不仅堆栈信息没有用，而且还会输出大量数据（每个 goroutine 的日志，包括它的标识符和状态）。这也很难调试，因为通常操作系统上的日志缓冲区可能太小而无法容纳所有堆栈信息。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：公平地说，我只在应用程序使用&lt;strong&gt;超过 400,000 个&lt;/strong&gt;大型 goroutine 的生产环境中看到这种情况。这可能很少见，对于大多数应用程序来说都不是问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TL;DR：设计 goroutines 时要考虑到最终结果，以便它们在完成时正确停止。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Goroutine 中的 panic&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，Go 应用程序中的 panic 是违反最佳实践的，应该避免。代替 panic，你应该返回并处理函数中的错误。但是，如果有必要使用  &lt;code&gt;panic&lt;/code&gt;，必须知道，在 goroutine 如果没有 defer 的 recover，panic 会导致整个应用程序崩溃。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;最佳实践：&lt;/strong&gt;不要 Panic！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这在生产环境中非常难以调试，因为它需要&lt;code&gt;stderr&lt;/code&gt;重定向到文件，因为你的应用程序很可能作为守护进程运行。如果你有一个日志聚合器并且它被设置为监控标准错误或文件日志，这会更容易。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果不确定，可以在 goroutine 增加 defer/recover&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; r := &lt;span&gt;recover&lt;/span&gt;(); r != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// Handle Panic HERE&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Channels&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go 中的 Channel 是什么？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源自 Hoare (1977) 的 Communicating Sequential Processes 论文通道是 Go 中的一种通信机制，它支持以线程安全的方式传输数据。它可用于安全有效地在并行 goroutine 之间进行通信，而无需 mutex。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道将构建并行代码的困难抽象到 Go 运行时，并提供了一种在 goroutine 之间进行通信的简单方法。从本质上讲，通道的最简单形式是数据队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 Rob Pike 的话来说：“Channels orchestrate; mutexes serialize.”&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通道在 Go 中是如何工作的？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，通道是阻塞的。这意味着，如果你尝试从通道读取，它将阻止该 goroutine 的处理，直到有要读取的内容（即数据发送到通道）。同样，如果你尝试写入通道并且没有数据消费者（即从通道读取），它将阻止该 goroutine 的处理，直到有消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 中，围绕通道有一些非常重要的行为。Go 运行时被设计为非常高效，因此如果有一个 goroutine 在读取或写入通道上被阻塞，则运行时将在等待执行某些操作时使 goroutine 休眠。一旦通道有生产者或消费者，它将唤醒阻塞的 goroutine 并继续处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解这一点非常重要，因为它允许你通过使用通道显式地利用系统的 CPU 争用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 一个 nil 通道总是堵塞&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关闭 Channel&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 完成后，最好关闭它。这通过 &lt;code&gt;close&lt;/code&gt; 实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时可能无法关闭通道，因为它会在应用程序的其他地方引起 panic（即往关闭的通道写入）。在这种情况下，当通道超出作用范围时，它将被垃圾收集。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Create the channel&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Do something with the channel&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Close the channel&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;close&lt;/span&gt;(ch)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果通道被限制在同一个作用域（即函数），你可以使用 &lt;code&gt;defer&lt;/code&gt;关键字来保证函数返回时通道是关闭的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Create the channel&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(ch) &lt;span&gt;// Close the channel when func returns&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Do something with the channel&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个通道关闭时，不允许再写入。注意关闭通道的方式非常重要，因为如果你尝试写入已关闭的通道，运行时将 panic。因此，过早关闭通道可能会产生意想不到的副作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道关闭后，它将不再阻塞读取。这意味着所有阻塞在通道上的 goroutine 都将被唤醒并继续处理。读取时返回的零值将是通道类型的值，读取返回的第二个值将是 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Create the channel&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Do something with the channel&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Close the channel&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;close&lt;/span&gt;(ch)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Read from closed channel&lt;/span&gt;&lt;br/&gt;  data, ok := &amp;lt;-ch&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;    &lt;span&gt;// Channel is closed&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在上面的示例中关闭了通道，则 &lt;code&gt;ok&lt;/code&gt;参数将是 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;  只读 channel 不能关闭&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Channels 类型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 中有几种不同类型的通道。它们每个都有各自的优点和缺点。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;无缓冲 Channels&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Unbuffered channels are the simplest type of channel.&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要创建无缓冲通道，请调用 make 函数，并提供通道类型。不要在第二个参数中提供大小值，如上例所示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无缓冲通道默认是阻塞的，并且会阻塞 goroutine 直到有东西要读取或写入。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓冲 Channels&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Buffered channels are the other primary type of channel.&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要创建缓冲通道，调用 make 函数，提供通道类型和缓冲区大小。上面的示例将创建一个缓冲区大小为 10 的通道。如果你尝试写入已满的通道，它将阻塞 goroutine，直到缓冲区中有空间。如果你试图从一个空的通道中读取，它将阻塞 goroutine，直到有东西要读取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果你想写入通道并且缓冲区有可用空间，则它不会阻塞 goroutine。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 通常，仅在真的需要时才使用缓冲通道。最佳实践是使用无缓冲通道。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;只读和只写 Channels&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道的一个有趣用例是拥有一个仅用于读取或写入的通道。当你有一个需要从通道读取但你不希望该 goroutine 写入时，这很有用，反之亦然。这对于下面描述的所有者模式特别有用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是创建只读或只写通道的语法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Define the variable with var&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; writeOnly &lt;span&gt;chan&lt;/span&gt;&amp;lt;- &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; readOnly &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  mychan := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Assign the channel to the variable&lt;/span&gt;&lt;br/&gt;  readOnly = mychan&lt;br/&gt;  writeOnly = mychan&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;箭头指示通道的方向。&lt;code&gt;chan&lt;/code&gt;前面的箭头表示数据流进入通道，而 &lt;code&gt;chan&lt;/code&gt; 后面的箭头表示数据流流出通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只读通道的一个示例是&lt;code&gt;time.Tick&lt;/code&gt; 函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Tick is a convenience wrapper for NewTicker providing access to the ticking&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// channel only&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Tick&lt;/span&gt;&lt;span&gt;(d Duration)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;Time&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此方法返回一个只读通道，&lt;code&gt;time&lt;/code&gt;包以指定的时间间隔在内部写入该通道。这种模式确保了时钟滴答的实现逻辑与&lt;code&gt;time&lt;/code&gt;包隔离，因为用户不需要往通道写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你需要写入通道但你知道 goroutine 不需要从中读取时，只写通道非常有用。下面描述的所有者模式就是一个很好的例子 。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Channels 的设计注意事项&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计注意事项包括：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;哪个作用域拥有 channel？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非所有者有什么能力？&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;完全所有权&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只读&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只写&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;channel 将如何清理？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;哪个 goroutine 负责清理 channel？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;所有者模式&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Owner Pattern 是 Go 中的一种常见设计模式，用于确保通道的所有权由创建或拥有 goroutine 正确管理。这允许 goroutine 管理通道的整个生命周期并确保正确关闭通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是 Go 中所有者模式的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewTime&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Time&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  tchan := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; time.Time)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(tchan &lt;span&gt;chan&lt;/span&gt;&amp;lt;- time.Time)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(tchan)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; tchan &amp;lt;- time.Now():&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }(tchan)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; tchan&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好处:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;NewTime 控制通道实例化和清理（第 2 行和第 5 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过定义只读/只写边界避免乱用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;限制行为不一致的可能性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于此示例的重要说明。上下文 &lt;code&gt;ctx&lt;/code&gt; 传递给函数 &lt;code&gt;NewTime&lt;/code&gt;并用于指示 goroutine 停止。&lt;code&gt;tchan&lt;/code&gt; 通道是普通的无缓冲通道，但以只读方式返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当传递给内部 goroutine 时，&lt;code&gt;tchan&lt;/code&gt;通道作为只写通道传递。因为内部 goroutine 提供了一个只写通道，所以它有责任在完成时关闭通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;select&lt;/code&gt; 语句，&lt;code&gt;time.Now()&lt;/code&gt; 调用仅在从通道读取时执行。这确保&lt;code&gt;time.Now()&lt;/code&gt; 调用的执行与从通道读取同步。这种类型的模式有助于抢先减少 CPU 周期。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;循环 Channels&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从通道读取的一种方法是使用&lt;code&gt;for&lt;/code&gt;循环。这在某些情况下可能很有用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;var&lt;/span&gt; tchan &amp;lt;-&lt;span&gt;chan&lt;/span&gt; time.Time&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; t := &lt;span&gt;range&lt;/span&gt; tchan {&lt;br/&gt;    fmt.Println(t)&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我不推荐这种方法有几个原因。首先，不能保证通道会关闭（打破循环）。其次，循环不遵守上下文，这意味着如果取消上下文，循环将永远不会退出。&lt;strong&gt;第二点特别重要，因为没有优雅的方式来退出 goroutine。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我建议不要在通道上循环，而是使用以下模式，在该模式中使用带有&lt;code&gt;select&lt;/code&gt;语句的无限循环。这种模式确保检查上下文，如果它被取消，循环退出，同时还允许循环仍然从通道中读取。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;var&lt;/span&gt; tchan &amp;lt;-&lt;span&gt;chan&lt;/span&gt; time.Time&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done(): &lt;span&gt;// Graceful exit&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; t, ok := &amp;lt;-tchan: &lt;span&gt;// Read from the time ticker&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; !ok { &lt;span&gt;// Channel closed, exit&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;      fmt.Println(t)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下文会详细讨论这个。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;转发 Channels&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在适当的情况下，将通道从一个转发到另一个也是一种有用的模式。这是使用&lt;code&gt;&amp;lt;- &amp;lt;-&lt;/code&gt;运算符完成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是将一个通道转发到另一个通道的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;forward&lt;/span&gt;&lt;span&gt;(ctx context.Context, from &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  to := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; to &amp;lt;- &amp;lt;-from: &lt;span&gt;// Forward from into the to channel&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }()&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; to&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 使用此模式，你无法检测&lt;code&gt;from&lt;/code&gt;通道何时关闭。这意味着&lt;code&gt;from&lt;/code&gt;通道将不断地向 &lt;code&gt;to&lt;/code&gt; 通道发送数据，并且内部 goroutine 将永远不会退出，从而导致大量零值数据和 goroutine 泄漏。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据你的使用场景，这可能是可取的，但是，重要的是要注意，当你需要检测关闭的通道时，这种模式不是一个好方式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Select 语句&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select&lt;/code&gt; 语句允许在 Go 应用程序中管理多个通道，并可用于触发操作、管理数据或以其他方式创建逻辑并发流。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; data, ok := &amp;lt;- incoming: &lt;span&gt;// Data Read&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; outgoing &amp;lt;- data: &lt;span&gt;// Data Write&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;default&lt;/span&gt;: &lt;span&gt;// Non-blocking default action&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// ... &lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：&lt;code&gt;select&lt;/code&gt; 本质上是&lt;em&gt;随机&lt;/em&gt;的。这意味着如果有多个通道准备好同时读取或写入，该&lt;code&gt;select&lt;/code&gt;语句将随机选择一个 case 语句来执行。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试 Select 语句&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;select 语句的随机性会使测试 select 语句有点棘手，尤其是在测试以确保上下文取消正确退出例程时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个如何使用统计测试来测试 select 语句的示例，其中测试执行的次数确保测试失败的统计可能性很低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此测试通过在并行例程中运行相同的已取消上下文 100 次来工作，其中两个上下文中只有一个已被取消。在这种情况下，总会有一个通道的消费者，因此每次循环运行时，都有 50% 的可能性会执行 context case。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过运行 100 次，有 50% 的机会选择触发上下文情况，测试将无法检测到所有 100 个测试的上下文取消的可能性非常非常低。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;带上下文的 Work 取消&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在构建 Go 应用程序的早期，用户构建具有&lt;code&gt;done&lt;/code&gt;通道的应用程序，他们将在其中创建一个看起来像这样的通道：&lt;code&gt;done := make(chan struct{})&lt;/code&gt;，这是一种非常简单的方法，可以向 goroutine 发出它应该退出的信号，因为你所要做的就是关闭通道并将其用作退出信号。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Example of a simple done channel&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  done := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt;&lt;br/&gt;    &lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; doWork(done)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Exit anything using the done channel&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(done)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Do some more work&lt;/span&gt;&lt;br/&gt;  }()&lt;br/&gt;&lt;br/&gt;  &amp;lt;-done&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doWork&lt;/span&gt;&lt;span&gt;(done &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-done:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;: &lt;br/&gt;      &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式变得如此普遍，以至于 Go 团队创建了context 包 作为替代。该包提供了一个接口&lt;code&gt;context.Context&lt;/code&gt;，可用于向 goroutine 发出信号，告知它在&lt;code&gt;Done&lt;/code&gt; 方法返回的只读通道返回时退出 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doWork&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;default&lt;/span&gt;: &lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，他们还提供了一些用于创建分层上下文、超时上下文和可以取消的上下文的方法。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;context.WithCancel&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;返回 &lt;code&gt;context.Context&lt;/code&gt;以及&lt;code&gt;context.CancelFunc&lt;/code&gt;，可用于取消上下文的函数字面值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;context.WithTimeout&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;与&lt;code&gt;WithCancel&lt;/code&gt;返回一致，但具有超时，将在指定&lt;code&gt;time.Duration&lt;/code&gt;时间过去后取消上下文。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;context.WithDeadline&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;与 WithCancel 返回一致，但有一个截止日期，将在指定的时间过去后取消上下文。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;：接受上下文的函数的第一个参数应该 &lt;strong&gt;始终&lt;/strong&gt; 是 context，并且应该命名为 &lt;code&gt;ctx&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://benjiv.com/go-native-concurrency-primitives/。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>