<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>cf66e2ba847b507d0ac6dc9e4ba7cb65</guid>
<title>阿里巴巴开源高性能 JSON 库 FASTJSON v2</title>
<link>https://toutiao.io/k/qy5z8im</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655078619&amp;amp;idx=1&amp;amp;sn=b4db7f1880038187eecd0454d0f61be9&amp;amp;chksm=bd2918ec8a5e91fae83ccb2a9e977418dcd284c620ad44a25974071e9b1b4d8857628f26ad18&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNav9oso6Gxia5jcD3Wgg3yvKNEpy1FkFVItdSic9wV0kdNVdZbLl1nID64c4NCC9U6Pmd1eNQKQmhSM2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655078619&amp;amp;idx=1&amp;amp;sn=b4db7f1880038187eecd0454d0f61be9&amp;amp;chksm=bd2918ec8a5e91fae83ccb2a9e977418dcd284c620ad44a25974071e9b1b4d8857628f26ad18&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;疫情之中，写给大家的几句话｜码农周刊VIP会员专属邮件周报 Vol.089&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;码农周刊VIP会员专属邮件周报 Vol.089&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;FASTJSON v2是FASTJSON项目的重要升级，目标是&lt;strong&gt;为下一个十年提供一个高性能的JSON库&lt;/strong&gt;。通过同一套API，&lt;br/&gt;- 支持JSON/JSONB两种协议，JSONPath是一等公民；&lt;br/&gt;- 支持全量解析和部分解析；&lt;br/&gt;- 支持Java服务端、客户端Android、大数据场景。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.36&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav9oso6Gxia5jcD3Wgg3yvKNECticLB0cOSwYRw2owmicL2m9BLdnB61L2kwdK3CkXunp38g3zuv0Bw4g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9b38c084cfc18820f204ba54e75a0761</guid>
<title>HiveQL 进阶之以柔克刚 - 将简单语法运用到极致</title>
<link>https://toutiao.io/k/nxy3pln</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-14bz7qe&quot; options=&quot;[object Object]&quot;&gt;&lt;h2 data-first-child=&quot;&quot; id=&quot;h_508038040_0&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;前言&lt;/b&gt;&lt;/h2&gt;&lt;h3 id=&quot;h_508038040_1&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;初衷&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;dsStpuLp&quot;&gt;&lt;b&gt;如何高效地使用 HiveQL ，将 HiveQL 运用到极致。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;Zkg-Pxd5&quot;&gt;在大数据如此流行的今天，不只是专业的数据人员，需要经常地跟 SQL 打交道，即使是产品、运营等非技术伙伴，也会或多或少地使用过 SQL ，如何高效地发挥 SQL 的能力，继而发挥数据的能力，变得尤为重要。&lt;/p&gt;&lt;p data-pid=&quot;Un0-K3hI&quot;&gt;HiveQL 发展到今天已经颇为成熟，作为一种 SQL 方言，其支持大多数查询语法，具有较为丰富的内置函数，同时还支持开窗函数、用户自定义函数、反射机制等诸多高级特性。面对一个复杂的数据场景，或许有人技术娴熟，选择使用 HiveQL 高级特性解决，如：编写用户自定义函数扩展 SQL 的数据处理能力；或许有人选择敬而远之，转向使用其他非 SQL 类型的解决方案。本文并不讨论不同方式的优劣，而是尝试独辟蹊径，不是强调偏僻的语法特性或是复杂的 UDF 实现，而是强调 &lt;b&gt;通过灵活的、发散性的数据处理思维，就可以用最简单的语法，解决复杂的数据场景。&lt;/b&gt;&lt;/p&gt;&lt;h3 id=&quot;h_508038040_2&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;适合人群&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;tr_XElYl&quot;&gt;不论是数据开发初学者还是资深人员，本篇文章或许都能有所帮助，不过更适合中级、高级读者阅读。&lt;/p&gt;&lt;p data-pid=&quot;pZ7BqR9X&quot;&gt;本篇文章重点介绍数据处理思维，并没有涉及到过多高阶的语法，同时为了避免主题发散，文中涉及的函数、语法特性等，不会花费篇幅进行专门的介绍，读者可以按自身情况自行了解。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_3&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;内容结构&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;7k535JYC&quot;&gt;本篇文章将围绕数列生成、区间变换、排列组合、连续判别等主题进行介绍，并附以案例进行实际运用讲解。每个主题之间有轻微的前后依赖关系，依次阅读更佳。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_4&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;提示信息&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;NRQ0H870&quot;&gt;本篇文章涉及的 SQL 语句只使用到了 HiveQL 基本的语法特性，理论上可以在目前的主流版本中运行，同时特意注明，运行环境、兼容性等问题不在本篇文章关注范围内。&lt;/p&gt;&lt;h2 id=&quot;h_508038040_5&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;快速制造测试数据&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;8zF_Ahh2&quot;&gt;生成用户访问日志表 visit_log ，每一行数据表示一条用户访问日志。该表将被用作下文各类场景的测试数据。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 1
with visit_log as (
    select stack (
        6,
        &#x27;2022-01-01&#x27;, &#x27;101&#x27;, &#x27;湖北&#x27;, &#x27;武汉&#x27;, &#x27;Android&#x27;,
        &#x27;2022-01-01&#x27;, &#x27;102&#x27;, &#x27;湖南&#x27;, &#x27;长沙&#x27;, &#x27;IOS&#x27;,
        &#x27;2022-01-01&#x27;, &#x27;103&#x27;, &#x27;四川&#x27;, &#x27;成都&#x27;, &#x27;Windows&#x27;,
        &#x27;2022-01-02&#x27;, &#x27;101&#x27;, &#x27;湖北&#x27;, &#x27;孝感&#x27;, &#x27;Mac&#x27;,
        &#x27;2022-01-02&#x27;, &#x27;102&#x27;, &#x27;湖南&#x27;, &#x27;邵阳&#x27;, &#x27;Android&#x27;,
        &#x27;2022-01-03&#x27;, &#x27;101&#x27;, &#x27;湖北&#x27;, &#x27;武汉&#x27;, &#x27;IOS&#x27;
    ) as (dt, user_id, province, city, device_type)
)
select * from visit_log;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;h_508038040_6&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;数列&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;EcKTYznT&quot;&gt;数列是最常见的数据形式之一，实际数据开发场景中遇到的基本都是有限数列，也是本节将要重点介绍的内容。本节将从最简单的递增数列开始，找出一般方法并推广到更泛化的场景。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_7&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;仙人指路&lt;/b&gt;&lt;/h3&gt;&lt;h3 id=&quot;h_508038040_8&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;一个简单的递增数列&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;osPpRNZV&quot;&gt;首先引出一个简单的递增整数数列场景：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;42iVqSTD&quot;&gt;从数值 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+0+&quot; alt=&quot; 0 &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; 开始；&lt;/li&gt;&lt;li data-pid=&quot;Ms4DHjQb&quot;&gt;之后的每个数值递增 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+1+&quot; alt=&quot; 1 &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; ；&lt;/li&gt;&lt;li data-pid=&quot;rZ8Ocd6O&quot;&gt;至数值 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+3+&quot; alt=&quot; 3 &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; 结束； 如何生成满足以上三个条件的数列？即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5B0%2C1%2C2%2C3%5D+&quot; alt=&quot; [0,1,2,3] &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; 。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;BAujbTaN&quot;&gt;实际上，生成该数列的方式有多种，此处介绍其中一种简单且通用的方案。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 2
select
    t.pos as a_n
from (
    select posexplode(split(space(3), space(1)))
) t;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;zADWlPxf&quot;&gt;通过上述 SQL 片段可得知，生成一个递增序列只需要三个步骤：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;MMfkR_4e&quot;&gt;生成一个长度合适的数组，数组中的元素不需要具有实际含义；&lt;/li&gt;&lt;li data-pid=&quot;Zck-p59T&quot;&gt;通过 UDTF 函数 posexplode 对数组中的每个元素生成索引下标；&lt;/li&gt;&lt;li data-pid=&quot;AkBeOn_x&quot;&gt;取出每个元素的索引下标。 以上三个步骤可以推广至更一般的数列场景：等差数列、等比数列。下文将以此为基础，直接给出最终实现模板。&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;h_508038040_9&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;等差数列&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;lzHyfwtq&quot;&gt;若设首项 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a_1+%3D+a+&quot; alt=&quot; a_1 = a &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; ，公差为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+d+&quot; alt=&quot; d &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; ，则等差数列的通项公式为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a_n+%3D+a_1+%2B+%28n+-+1%29d+&quot; alt=&quot; a_n = a_1 + (n - 1)d &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; 。 SQL 实现：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 3
select
    a_1 + t.pos * d as a_n
from (
    select posexplode(split(space(n - 1), space(1)))
) t;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;h_508038040_10&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;等比数列&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;dZDIrol0&quot;&gt;若设首项 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a_1+%3D+a+&quot; alt=&quot; a_1 = a &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; ，公比为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+r+&quot; alt=&quot; r &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; ，则等比数列的通项公式为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a_n+%3D+ar%5E%7Bn-1%7D+&quot; alt=&quot; a_n = ar^{n-1} &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; 。 SQL 实现：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 4
select
    a_1 * pow(r, t.pos) as a_n
from (
    select posexplode(split(space(n - 1), space(1)))
) t;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;h_508038040_11&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;应用场景举例&lt;/b&gt;&lt;/h3&gt;&lt;h3 id=&quot;h_508038040_12&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;如何还原任意维度组合下的维度列簇名称？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;LKKt37p5&quot;&gt;在多维分析场景下，可能会用到高阶聚合函数，如 &lt;i&gt;cube&lt;/i&gt; 、 &lt;i&gt;rollup&lt;/i&gt; 、 &lt;i&gt;grouping sets&lt;/i&gt; 等，可以针对不同的维度组合下的数据进行聚合统计。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_13&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;场景描述&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;UufnFZLH&quot;&gt;现有用户访问日志表 visit_log ，该表定义见 &lt;b&gt;快速制造测试数据&lt;/b&gt;。 假如针对省份 province , 城市 city, 设备类型 device_type 三个维度列，通过高阶聚合函数，统计得到了不同维度组合下的用户访问量。&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;Njahkaml&quot;&gt;如何知道一条统计结果是根据哪些维度列聚合出来的？&lt;/li&gt;&lt;li data-pid=&quot;CLGo1VS_&quot;&gt;想要输出 &lt;b&gt;聚合的维度列&lt;/b&gt; 的名称，用于下游的报表展示等场景，又该如何处理？&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;h_508038040_14&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;解决思路&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;QZRLBqIN&quot;&gt;&lt;b&gt;可以借助 Hive 提供的 Grouping__ID 来实现，核心方法是对 Grouping__ID 进行逆向实现。&lt;/b&gt; 详细步骤如下：&lt;/p&gt;&lt;p data-pid=&quot;IIzS-gWa&quot;&gt;&lt;b&gt;一、准备好所有的 Grouping__ID 。&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;_f413xyP&quot;&gt;生成一个包含 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+2%5Ex+&quot; alt=&quot; 2^x &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; 个数值的递增数列，每个数值表示一种 Grouping__ID ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+x+&quot; alt=&quot; x &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; 为所有维度列的数量， &lt;img src=&quot;https://www.zhihu.com/equation?tex=+2%5Ex+&quot; alt=&quot; 2^x &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; 为所有维度组合的数量。即 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%7B+0%2C+1%2C+2%2C+...%2C+2%5Ex+-+1+%7D+&quot; alt=&quot; { 0, 1, 2, ..., 2^x - 1 } &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt;&lt;br/&gt; &lt;/li&gt;&lt;li data-pid=&quot;Tx_HxxHU&quot;&gt;将递增数列中的每个 Grouping__ID 转为 2 进制字符串，并展开该 2 进制字符串的每个比特位。例如&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;uD4NOzjP&quot;&gt;&lt;b&gt;二、准备好所有维度列的名称。&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;{ dim_col_1, dim_col_2, ..., dim_col_x }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;2M-Ips0B&quot;&gt;&lt;b&gt;三、将 Grouping__ID 映射到维度列名称。&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;d2R7WVvk&quot;&gt;对于递增数列中的每个数值，将该数值的 2 进制的每个比特位与维度列的下标进行映射。例如&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;grouping__id：3 =&amp;gt; { 0, 0, 0, 1, 1 }
维度列：{ dim_col_1, dim_col_2, dim_col_3, dim_col_4, dim_col_5 }
映射结果：{ 0:dim_col_1, 0:dim_col_2, 0:dim_col_3, 1:dim_col_4, 1:dim_col_5 }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li data-pid=&quot;lSj8aQoq&quot;&gt;对递增数列中的每个数值进行聚合，输出所有比特位等于 0 的维度列。&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;dim_col_1,dim_col_2,dim_col_3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;SQaeeH1W&quot;&gt;注意：不同版本的 Hive 之间， Grouping__ID 实现有差异，以上处理逻辑适用于 2.3.0 及之后的版本。 2.3.0 之前的版本基于上述步骤稍加修改即可，此处不再专门花费篇幅描述。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_15&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;SQL 实现&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 5
with group_dimension as (
    select -- 每种分组对应的维度字段
        gb.group_id, concat_ws(&quot;,&quot;, collect_list(case when gb.placeholder_bit = 0 then dim_col.val else null end)) as dimension_name
    from (
     select groups.pos as group_id, pe.*
        from (
            select posexplode(split(space(cast(pow(2, 3) as int) - 1), space(1)))
        ) groups -- 所有分组
        lateral view posexplode(split(lpad(conv(groups.pos,10,2), 3, &quot;0&quot;), &#x27;&#x27;)) pe as placeholder_idx, placeholder_bit -- 每个分组的bit信息
    ) gb
    left join ( -- 所有维度字段
     select posexplode(split(&quot;省份,城市,设备类型&quot;, &#x27;,&#x27;))
    ) dim_col on gb.placeholder_idx = dim_col.pos
    group by gb.group_id
)
select 
    group_dimension.dimension_name as dimension_name,
    province, city, device_type,
    visit_count
from (
    select
        grouping__id as group_id,
        province, city, device_type,
        count(1) as visit_count
    from visit_log b
    group by province, city, device_type
    GROUPING SETS(
        (province),
        (province, city),
        (province, city, device_type)
    )
) t
join group_dimension on t.group_id = group_dimension.group_id
order by dimension_name;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;dimension_name&lt;/th&gt;&lt;th&gt;province&lt;/th&gt;&lt;th&gt;city&lt;/th&gt;&lt;th&gt;device_type&lt;/th&gt;&lt;th&gt;visit_count&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;省份&lt;/td&gt;&lt;td&gt;湖北&lt;/td&gt;&lt;td&gt;NULL&lt;/td&gt;&lt;td&gt;NULL&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;省份&lt;/td&gt;&lt;td&gt;湖南&lt;/td&gt;&lt;td&gt;NULL&lt;/td&gt;&lt;td&gt;NULL&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;省份&lt;/td&gt;&lt;td&gt;四川&lt;/td&gt;&lt;td&gt;NULL&lt;/td&gt;&lt;td&gt;NULL&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;省份,城市&lt;/td&gt;&lt;td&gt;湖北&lt;/td&gt;&lt;td&gt;武汉&lt;/td&gt;&lt;td&gt;NULL&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;省份,城市&lt;/td&gt;&lt;td&gt;湖南&lt;/td&gt;&lt;td&gt;长沙&lt;/td&gt;&lt;td&gt;NULL&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;省份,城市&lt;/td&gt;&lt;td&gt;湖南&lt;/td&gt;&lt;td&gt;邵阳&lt;/td&gt;&lt;td&gt;NULL&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;省份,城市&lt;/td&gt;&lt;td&gt;湖北&lt;/td&gt;&lt;td&gt;孝感&lt;/td&gt;&lt;td&gt;NULL&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;省份,城市&lt;/td&gt;&lt;td&gt;四川&lt;/td&gt;&lt;td&gt;成都&lt;/td&gt;&lt;td&gt;NULL&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;省份,城市,设备类型&lt;/td&gt;&lt;td&gt;湖北&lt;/td&gt;&lt;td&gt;孝感&lt;/td&gt;&lt;td&gt;Mac&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;省份,城市,设备类型&lt;/td&gt;&lt;td&gt;湖南&lt;/td&gt;&lt;td&gt;长沙&lt;/td&gt;&lt;td&gt;IOS&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;省份,城市,设备类型&lt;/td&gt;&lt;td&gt;湖南&lt;/td&gt;&lt;td&gt;邵阳&lt;/td&gt;&lt;td&gt;Android&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;省份,城市,设备类型&lt;/td&gt;&lt;td&gt;四川&lt;/td&gt;&lt;td&gt;成都&lt;/td&gt;&lt;td&gt;Windows&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;省份,城市,设备类型&lt;/td&gt;&lt;td&gt;湖北&lt;/td&gt;&lt;td&gt;武汉&lt;/td&gt;&lt;td&gt;Android&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;省份,城市,设备类型&lt;/td&gt;&lt;td&gt;湖北&lt;/td&gt;&lt;td&gt;武汉&lt;/td&gt;&lt;td&gt;IOS&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;h_508038040_16&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;区间&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;8_FkKob4&quot;&gt;相比于数列较多用于表示离散数据，区间往往用于描述连续的数据，虽然两者具有不同的数据特征，不过在实际应用中，数列与区间的处理具有较多相通性。本节将介绍一些常见的区间场景，并抽象出通用的解决方案。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_17&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;二鬼拍门&lt;/b&gt;&lt;/h3&gt;&lt;h3 id=&quot;h_508038040_18&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;区间分割&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;vEfvPwQo&quot;&gt;已知一个数值区间 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%5Ba%2Cb%5D+%3D+%5C%7B+x+%7C+a+%5Cleq+x+%5Cleq+b+%5C%7D+&quot; alt=&quot; [a,b] = \{ x | a \leq x \leq b \} &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; ，如何将该区间均分成 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+n+&quot; alt=&quot; n &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; 段子区间？&lt;/p&gt;&lt;p data-pid=&quot;UWHNY4-Q&quot;&gt;该问题可以简化为数列问题，数列公式为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a_n+%3D+a_1+%2B+%28n+-+1%29d+&quot; alt=&quot; a_n = a_1 + (n - 1)d &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; ，其中 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+a_1+%3D+a+&quot; alt=&quot; a_1 = a &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; ， &lt;img src=&quot;https://www.zhihu.com/equation?tex=+d+%3D+%28b+-+a%29+%2F+n+&quot; alt=&quot; d = (b - a) / n &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; ：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;rLBODHMA&quot;&gt;生成一个长度为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+n+&quot; alt=&quot; n &quot; loading=&quot;lazy&quot; eeimg=&quot;1&quot;/&gt; 的数组，数组中的元素不需要具有实际含义；&lt;/li&gt;&lt;li data-pid=&quot;imicPj0T&quot;&gt;通过 UDTF 函数 posexplode 对数组中的每个元素生成索引下标；&lt;/li&gt;&lt;li data-pid=&quot;q_8ErFKX&quot;&gt;取出每个元素的索引下标，并进行数列公式计算，得出每个子区间的起始值与结束值。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;JeEOHGKC&quot;&gt;SQL 实现：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 6
select
    a_1 + t.pos * d as sub_interval_start, -- 子区间起始值
    a_1 + (t.pos + 1) * d as sub_interval_end -- 子区间结束值
from (
    select posexplode(split(space(n - 1), space(1)))
) t;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;h_508038040_19&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;区间交叉&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;3Wzn_eDP&quot;&gt;已知两个日期区间存在交叉 [&#x27;2022-01-01&#x27;, &#x27;2022-01-03&#x27;] 、 [&#x27;2022-01-02&#x27;, &#x27;2022-01-04&#x27;]&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;E9SHb3tr&quot;&gt;如何合并两个日期区间，并返回合并后的新区间？&lt;/li&gt;&lt;li data-pid=&quot;VoWgwEC3&quot;&gt;如何知道哪些日期是交叉日期，并返回该日期交叉次数？&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;UAtkkIHA&quot;&gt;解决上述问题的方法有多种，此处介绍其中一种简单且通用的方案。 核心思路是结合数列生成、区间分割方法，先将日期区间分解为最小处理单元，即多个日期组成的数列，然后再基于日期粒度做统计。具体步骤如下：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;iLC7MPIR&quot;&gt;获取每个日期区间包含的天数；&lt;/li&gt;&lt;li data-pid=&quot;72zlNEqr&quot;&gt;按日期区间包含的天数，将日期区间拆分为相应数量的递增日期序列；&lt;/li&gt;&lt;li data-pid=&quot;oLMWWfGY&quot;&gt;通过日期序列统计合并后的区间，交叉次数；&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;o4WHSqIg&quot;&gt;SQL 实现：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 7
with tbl as (
    select stack(
        2,
        &#x27;2022-01-01&#x27;, &#x27;2022-01-03&#x27;,
        &#x27;2022-01-02&#x27;, &#x27;2022-01-04&#x27;
    ) as (date_start, date_end)
)
select 
    min(date_item) as date_start_merged, 
    max(date_item) as date_end_merged, 
    collect_set( -- 交叉日期计数
        case when date_item_cnt &amp;gt; 1 then concat(date_item, &#x27;:&#x27;, date_item_cnt) else null end
    ) as overlap_date
from (
    select 
        -- 拆解后的单个日期
        date_add(date_start, pos) as date_item,
        -- 拆解后的单个日期出现的次数
        count(1) over(partition by date_add(date_start, pos)) as date_item_cnt
    from tbl
    lateral view posexplode(split(space(datediff(date_end, date_start)), space(1))) t as pos, val
) t;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;date_start_merged&lt;/th&gt;&lt;th&gt;date_end_merged&lt;/th&gt;&lt;th&gt;overlap_date&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-01-01&lt;/td&gt;&lt;td&gt;2022-01-04&lt;/td&gt;&lt;td&gt;[&quot;2022-01-02:2&quot;,&quot;2022-01-03:2&quot;]&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-pid=&quot;CQkMHxzV&quot;&gt;&lt;b&gt;  增加点儿难度 ！&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;-JmYYdi-&quot;&gt;如果有多个日期区间，且区间之间交叉状态未知，上述问题又该如何求解。即：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;5pMysqoq&quot;&gt;如何合并多个日期区间，并返回合并后的多个新区间？&lt;/li&gt;&lt;li data-pid=&quot;H9mKhjwP&quot;&gt;如何知道哪些日期是交叉日期，并返回该日期交叉次数？&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;u8cs4JQo&quot;&gt;SQL 实现：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 8
with tbl as (
    select stack(
        5,
        &#x27;2022-01-01&#x27;, &#x27;2022-01-03&#x27;,
        &#x27;2022-01-02&#x27;, &#x27;2022-01-04&#x27;,
        &#x27;2022-01-06&#x27;, &#x27;2022-01-08&#x27;,
        &#x27;2022-01-08&#x27;, &#x27;2022-01-08&#x27;,
        &#x27;2022-01-07&#x27;, &#x27;2022-01-10&#x27;
    ) as (date_start, date_end)
)
select
    min(date_item) as date_start_merged, 
    max(date_item) as date_end_merged,
    collect_set( -- 交叉日期计数
        case when date_item_cnt &amp;gt; 1 then concat(date_item, &#x27;:&#x27;, date_item_cnt) else null end
    ) as overlap_date
from (
    select 
        -- 拆解后的单个日期
        date_add(date_start, pos) as date_item,
        -- 拆解后的单个日期出现的次数
        count(1) over(partition by date_add(date_start, pos)) as date_item_cnt,
        -- 对于拆解后的单个日期，重组为新区间的标记
        date_add(date_add(date_start, pos), 1 - dense_rank() over(order by date_add(date_start, pos))) as cont
    from tbl
    lateral view posexplode(split(space(datediff(date_end, date_start)), space(1))) t as pos, val
) t
group by cont;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;date_start_merged&lt;/th&gt;&lt;th&gt;date_end_merged&lt;/th&gt;&lt;th&gt;overlap_date&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-01-01&lt;/td&gt;&lt;td&gt;2022-01-04&lt;/td&gt;&lt;td&gt;[&quot;2022-01-02:2&quot;,&quot;2022-01-03:2&quot;]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-01-06&lt;/td&gt;&lt;td&gt;2022-01-10&lt;/td&gt;&lt;td&gt;[&quot;2022-01-07:2&quot;,&quot;2022-01-08:3&quot;]&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;h_508038040_20&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;应用场景举例&lt;/b&gt;&lt;/h3&gt;&lt;h3 id=&quot;h_508038040_21&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;如何按任意时段统计时间区间数据？&lt;/b&gt;&lt;/h3&gt;&lt;h3 id=&quot;h_508038040_22&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;场景描述&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;zWNDsQAF&quot;&gt;现有用户还款计划表 user_repayment ，该表内的一条数据，表示用户在指定日期区间内 [date_start, date_end] ，每天还款 repayment 元。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 9
with user_repayment as (
    select stack(
        3,
        &#x27;101&#x27;, &#x27;2022-01-01&#x27;, &#x27;2022-01-15&#x27;, 10,
        &#x27;102&#x27;, &#x27;2022-01-05&#x27;, &#x27;2022-01-20&#x27;, 20,
        &#x27;103&#x27;, &#x27;2022-01-10&#x27;, &#x27;2022-01-25&#x27;, 30
    ) as (user_id, date_start, date_end, repayment)
)
select * from user_repayment;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;N90ZojeZ&quot;&gt;如何统计某个时段内，每天所有用户的应还款总额？&lt;/p&gt;&lt;h3 id=&quot;h_508038040_23&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;解决思路&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;ITdaB4ka&quot;&gt;核心思路是将日期区间转换为日期序列，再按日期序列进行汇总统计。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_24&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;SQL 实现&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 10
select 
    date_item as day, 
    sum(repayment) as total_repayment
from (
    select 
        date_add(date_start, pos) as date_item,
        repayment
    from user_repayment
    lateral view posexplode(split(space(datediff(date_end, date_start)), space(1))) t as pos, val
) t
where date_item &amp;gt;= &#x27;2022-01-15&#x27; and date_item &amp;lt;= &#x27;2022-01-16&#x27;
group by date_item
order by date_item;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;day&lt;/th&gt;&lt;th&gt;total_repayment&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-01-15&lt;/td&gt;&lt;td&gt;60&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2022-01-16&lt;/td&gt;&lt;td&gt;50&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;h_508038040_25&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;排列组合&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;JMrmQHtz&quot;&gt;排列组合是针对离散数据常用的数据组织方法，实际应用场景中又以组合更为常见，本节将分别介绍排列、组合的实现方法，并结合实例着重介绍通过组合对数据的处理。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_26&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;双马饮泉&lt;/b&gt;&lt;/h3&gt;&lt;h3 id=&quot;h_508038040_27&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;排列&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;20Ryiuwt&quot;&gt;已知字符序列 [ &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; ] ，每次从该序列中可重复地选取出 2 个字符，如何获取到所有的排列？&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 11
select 
    concat(val1, val2) as perm
from (select split(&#x27;A,B,C&#x27;, &#x27;,&#x27;) as characters) dummy
lateral view explode(characters) t1 as val1
lateral view explode(characters) t2 as val2;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;C-vEsb-p&quot;&gt;整体实现比较简单。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_28&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;组合&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;8YimMt8d&quot;&gt;已知字符序列 [ &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; ] ，每次从该序列中可重复地选取出 2 个字符，如何获取到所有的组合？&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 12
select 
    concat(least(val1, val2), greatest(val1, val2)) as comb
from (select split(&#x27;A,B,C&#x27;, &#x27;,&#x27;) as characters) dummy
lateral view explode(characters) t1 as val1
lateral view explode(characters) t2 as val2
group by least(val1, val2), greatest(val1, val2);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;d1CxD-f-&quot;&gt;整体实现比较简单。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_29&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;应用场景举例&lt;/b&gt;&lt;/h3&gt;&lt;h3 id=&quot;h_508038040_30&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;如何对比统计所有组合？&lt;/b&gt;&lt;/h3&gt;&lt;h3 id=&quot;h_508038040_31&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;场景描述&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;LzAuyJm8&quot;&gt;现有用户访问日志表 visit_log ，该表定义见 &lt;b&gt;快速制造测试数据&lt;/b&gt;。 如何按省份两两建立对比组，按对比组展示省份的用户访问量？&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;对比组&lt;/th&gt;&lt;th&gt;省份&lt;/th&gt;&lt;th&gt;用户访问量&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;湖北-湖南&lt;/td&gt;&lt;td&gt;湖北&lt;/td&gt;&lt;td&gt;xxx&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;湖北-湖南&lt;/td&gt;&lt;td&gt;湖南&lt;/td&gt;&lt;td&gt;xxx&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;h_508038040_32&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;解决思路&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;3m7PJU2S&quot;&gt;核心思路是从所有省份列表中不重复地取出 2 个省份，生成所有的组合结果，然后关联 visit_log 表分组统计结果。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_33&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;SQL 实现&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 13
select
    combs.province_comb,
    log.province,
    count(1) as visit_count
from visit_log log
join ( -- 所有对比组
    select 
        concat(least(val1, val2), &#x27;-&#x27;, greatest(val1, val2)) as province_comb,
        least(val1, val2) as province_1, greatest(val1, val2) as province_2
    from (
        select collect_set(province) as provinces
        from visit_log
    ) dummy
    lateral view explode(provinces) t1 as val1
    lateral view explode(provinces) t2 as val2
    where val1 &amp;lt;&amp;gt; val2
    group by least(val1, val2), greatest(val1, val2)
) combs on 1 = 1
where log.province in (combs.province_1, combs.province_2)
group by combs.province_comb, log.province
order by combs.province_comb, log.province;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;对比组&lt;/th&gt;&lt;th&gt;省份&lt;/th&gt;&lt;th&gt;用户访问量&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;四川-湖北&lt;/td&gt;&lt;td&gt;四川&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;四川-湖北&lt;/td&gt;&lt;td&gt;湖北&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;四川-湖南&lt;/td&gt;&lt;td&gt;四川&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;四川-湖南&lt;/td&gt;&lt;td&gt;湖南&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;湖北-湖南&lt;/td&gt;&lt;td&gt;湖北&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;湖北-湖南&lt;/td&gt;&lt;td&gt;湖南&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;h_508038040_34&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;连续&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;eRCfoBOl&quot;&gt;本节主要介绍连续性问题，重点描述了连续活跃场景。对于静态类型的连续活跃、动态类型的连续活跃，分别阐述了不同的实现方案。 本节内容直接贴近具体的应用，大部分篇幅以 SQL 内容为主。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_35&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;静态连续活跃场景统计&lt;/b&gt;&lt;/h3&gt;&lt;h3 id=&quot;h_508038040_36&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;场景描述&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;TWXeU9Um&quot;&gt;现有用户访问日志表 visit_log ，该表定义见 &lt;b&gt;快速制造测试数据&lt;/b&gt;。 如何获取连续登录大于或等于 2 天的用户？&lt;/p&gt;&lt;p data-pid=&quot;8BraI7QM&quot;&gt;上述问题在分析连续性时，获取连续性的结果以超过固定阈值为准，可归类为 &lt;b&gt;连续活跃大于 N 天的静态连续活跃场景统计&lt;/b&gt;。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_37&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;SQL 实现&lt;/b&gt;&lt;/h3&gt;&lt;h3 id=&quot;h_508038040_38&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;基于相邻日期差实现（ lag / lead 版）&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 14
select user_id
from (
    select 
        *,
        lag(dt, 2 - 1) over(partition by user_id order by dt) as lag_dt
    from (select dt, user_id from visit_log group by dt, user_id) t0
) t1
where datediff(dt, lag_dt) + 1 = 2
group by user_id;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;ZciMVFDG&quot;&gt;整体实现比较简单。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_39&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;基于相邻日期差实现（排序版）&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 15
select user_id
from (
    select *, 
        dense_rank() over(partition by user_id order by dt) as dr
    from visit_log
) t1
where datediff(dt, date_add(dt, 1 - dr)) + 1 = 2
group by user_id;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;bCHgsALV&quot;&gt;整体实现比较简单。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_40&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;基于连续活跃天数实现&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 16
select user_id
from (
    select 
        *,
        -- 连续活跃天数
        count(distinct dt) 
            over(partition by user_id, cont) as cont_days
    from (
        select 
            *, 
            date_add(dt, 1 - dense_rank() 
                over(partition by user_id order by dt)) as cont
        from visit_log
    ) t1
) t2
where cont_days &amp;gt;= 2
group by user_id;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;S4TcMlFt&quot;&gt;可以视作 &lt;b&gt;基于相邻日期差实现（排序版）&lt;/b&gt; 的衍生版本，该实现能获取到更多信息，如连续活跃天数。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_41&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;基于连续活跃区间实现&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 17
select user_id
from (
    select 
        user_id, cont, 
        -- 连续活跃区间
        min(dt) as cont_date_start, max(dt) as cont_date_end
    from (
        select 
            *, 
            date_add(dt, 1 - dense_rank() 
                over(partition by user_id order by dt)) as cont
        from visit_log
    ) t1
    group by user_id, cont
) t2
where datediff(cont_date_end, cont_date_start) + 1 &amp;gt;= 2
group by user_id;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;MlNnz0SI&quot;&gt;可以视作 &lt;b&gt;基于相邻日期差实现（排序版）&lt;/b&gt; 的衍生版本，该实现能获取到更多信息，如连续活跃区间。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_42&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;动态连续活跃场景统计&lt;/b&gt;&lt;/h3&gt;&lt;h3 id=&quot;h_508038040_43&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;场景描述&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;otsZyDOQ&quot;&gt;现有用户访问日志表 visit_log ，该表定义见 &lt;b&gt;快速制造测试数据&lt;/b&gt;。 如何获取最长的 2 个连续活跃，输出用户、最长连续活跃天数、最长连续活跃日期区间？&lt;/p&gt;&lt;p data-pid=&quot;xPgYZLXs&quot;&gt;上述问题在分析连续性时，获取连续性的结果不是且无法与固定的阈值作比较，而是各自以最长连续活跃作为动态阈值，可归类为 &lt;b&gt;动态连续活跃场景统计&lt;/b&gt;。&lt;/p&gt;&lt;h3 id=&quot;h_508038040_44&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;SQL 实现&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;nBHgf8dR&quot;&gt;基于 &lt;b&gt;静态连续活跃场景统计&lt;/b&gt; 的思路进行扩展即可，此处直接给出最终 SQL ：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;-- SQL - 18
select
    user_id, 
    -- 最长连续活跃天数
    datediff(max(dt), min(dt)) + 1 as cont_days,
    -- 最长连续活跃日期区间
    min(dt) as cont_date_start, max(dt) as cont_date_end
from (
    select 
        *, 
        date_add(dt, 1 - dense_rank() 
            over(partition by user_id order by dt)) as cont
    from visit_log
) t1
group by user_id, cont
order by cont_days desc
limit 2;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;user_id&lt;/th&gt;&lt;th&gt;cont_days&lt;/th&gt;&lt;th&gt;cont_date_start&lt;/th&gt;&lt;th&gt;cont_date_end&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;101&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;2022-01-01&lt;/td&gt;&lt;td&gt;2022-01-03&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;102&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;2022-01-01&lt;/td&gt;&lt;td&gt;2022-01-02&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;h_508038040_45&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;结语&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;_S7ZgFKU&quot;&gt;&lt;b&gt;通过灵活的、散发性的数据处理思维，就可以用最简单的语法，解决复杂的数据场景&lt;/b&gt; 是本篇文章贯穿全文的思想。文中针对数列生成、区间变换、排列组合、连续判别等常见的场景，给出了相对通用的解决方案，并结合实例进行了实际运用的讲解。&lt;/p&gt;&lt;p data-pid=&quot;LyOINeuF&quot;&gt;本篇文章尝试独辟蹊径，强调灵活的数据处理思维，希望能让读者觉得眼前一亮，更希望真的能给读者产生帮助。同时毕竟个人能力有限，思路不一定是最优的，甚至可能出现错误，欢迎提出意见或建议。为了便于交流探讨，文中的每个 SQL 都标记了编号，可以直接在评论区 @SQL编号 沟通。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7673d947a67377feb1af45a57d9292b6</guid>
<title>DataX 快速入门</title>
<link>https://toutiao.io/k/ltbtbsk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;DataX 版本：3.0&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Github主页地址：https://github.com/alibaba/DataX&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DataX 是一个异构数据源离线同步工具，致力于实现包括关系型数据库(MySQL、Oracle等)、HDFS、Hive、ODPS、HBase、FTP 等各种异构数据源之间稳定高效的数据同步功能。具体请查阅：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0OTYwNTQ4Ng==&amp;amp;mid=2247485711&amp;amp;idx=1&amp;amp;sn=8910e6917b9fb0ad77081e1af36b07af&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;DataX 异构数据源离线同步&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 环境要求&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Linux&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JDK(1.8 以上，推荐 1.8)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Python(推荐 Python2.6.X)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 下载&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接下载 DataX 工具包：下载地址。下载后解压至本地 /opt 目录下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;tar -zxvf datax.tar.gz -C /opt/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;除了直接下载安装包之外，你也可以下载 DataX 源码，自己编译&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入 bin 目录，即可运行同步作业。可以运行如下自查脚本检查安装是否成功：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;python {YOUR_DATAX_HOME}/bin/datax.py {YOUR_DATAX_HOME}/job/job.json&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们这需要运行如下语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;python /opt/datax/bin/datax.py /opt/datax/job/job.json&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到如下运行信息表示我们已经运行成功了：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.0984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9O0Uj9O4MPAYIBYiaHMfFsHQxDexynVL6HyzpjDTe8Q1W0IkClic7vs0DvQqPjxs3g6NYE0czvGeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 示例&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们第一个简单示例是从 Stream 读取数据并打印到控制台。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 查看配置模板&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;配置文件为 json 格式&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DataX 为不同的 Reader 和 Writer 分别提供了不同的配置模块，可以通过如下命令指定 Reader 和 Writer 查看配置模板：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;python {YOUR_DATAX_HOME}/bin/datax.py -r {YOUR_READER} -w {YOUR_WRITER}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这我们需要运行如下语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;python /opt/datax/bin/datax.py -r streamreader -w streamwriter&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出信息中包含了如下配置模板 JSON：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;job&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;content&quot;&lt;/span&gt;: [&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;&quot;reader&quot;&lt;/span&gt;: {&lt;br/&gt;                    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;streamreader&quot;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;&quot;parameter&quot;&lt;/span&gt;: {&lt;br/&gt;                        &lt;span&gt;&quot;column&quot;&lt;/span&gt;: [],&lt;br/&gt;                        &lt;span&gt;&quot;sliceRecordCount&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                },&lt;br/&gt;                &lt;span&gt;&quot;writer&quot;&lt;/span&gt;: {&lt;br/&gt;                    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;streamwriter&quot;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;&quot;parameter&quot;&lt;/span&gt;: {&lt;br/&gt;                        &lt;span&gt;&quot;encoding&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;                        &lt;span&gt;&quot;print&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        ],&lt;br/&gt;        &lt;span&gt;&quot;setting&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;speed&quot;&lt;/span&gt;: {&lt;br/&gt;                &lt;span&gt;&quot;channel&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从配置模板中可以看到配置文件需要配置三部分&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;配置同步任务的读取端 reader：配置同步任务的读取端数据信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置同步任务的写入端 writer：配置同步任务的写入端数据信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置通道控制 setting：配置同步任务全局信息（不包含读取端、写入端外配置信息）。你可以在 setting 中进行同步速率配置，新版本DataX 3.0 提供了包括通道(并发)、记录流、字节流三种流控模式，可以随意控制你的作业速度。此外还提供了脏数据探测能力，可以实现脏数据精确过滤、识别、采集、展示，为用户提供多种的脏数据处理模式。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 根据模板编写配置文件&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(1) 配置同步任务的读取端&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过配置模板已生成了基本的读取端配置。此时你可以继续手动配置同步任务的读取端数据信息，如下所示输出5条记录，第一个字段数据类型为 Long 的 10，第二个字段数据类型为 String 的 &lt;code&gt;hello，DataX&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&quot;reader&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;streamreader&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;parameter&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;column&quot;&lt;/span&gt;: [&lt;br/&gt;          {&lt;br/&gt;              &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;long&quot;&lt;/span&gt;,&lt;br/&gt;              &lt;span&gt;&quot;value&quot;&lt;/span&gt;: &lt;span&gt;&quot;10&quot;&lt;/span&gt;&lt;br/&gt;          },&lt;br/&gt;          {&lt;br/&gt;              &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;              &lt;span&gt;&quot;value&quot;&lt;/span&gt;: &lt;span&gt;&quot;hello，DataX&quot;&lt;/span&gt;&lt;br/&gt;          }&lt;br/&gt;        ],&lt;br/&gt;        &lt;span&gt;&quot;sliceRecordCount&quot;&lt;/span&gt;: &lt;span&gt;&quot;5&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(2) 配置同步任务的写入端&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置完成读取端数据信息后，可以继续手动配置同步任务的写入端数据信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&quot;writer&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;streamwriter&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;parameter&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;encoding&quot;&lt;/span&gt;: &lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;print&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(3) 配置通道控制&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当上述步骤配置完成后，则需要配置同步速率：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&quot;setting&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;speed&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;channel&quot;&lt;/span&gt;: &lt;span&gt;&quot;1&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建配置文件 stream2stream.json 并放入 /opt/datax/job/ 目录下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;job&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;content&quot;&lt;/span&gt;: [&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;&quot;reader&quot;&lt;/span&gt;: {&lt;br/&gt;                    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;streamreader&quot;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;&quot;parameter&quot;&lt;/span&gt;: {&lt;br/&gt;                        &lt;span&gt;&quot;column&quot;&lt;/span&gt;: [&lt;br/&gt;                          {&lt;br/&gt;                              &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;long&quot;&lt;/span&gt;,&lt;br/&gt;                              &lt;span&gt;&quot;value&quot;&lt;/span&gt;: &lt;span&gt;&quot;10&quot;&lt;/span&gt;&lt;br/&gt;                          },&lt;br/&gt;                          {&lt;br/&gt;                              &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;                              &lt;span&gt;&quot;value&quot;&lt;/span&gt;: &lt;span&gt;&quot;hello，DataX&quot;&lt;/span&gt;&lt;br/&gt;                          }&lt;br/&gt;                        ],&lt;br/&gt;                        &lt;span&gt;&quot;sliceRecordCount&quot;&lt;/span&gt;: &lt;span&gt;&quot;5&quot;&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                },&lt;br/&gt;                &lt;span&gt;&quot;writer&quot;&lt;/span&gt;: {&lt;br/&gt;                    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;streamwriter&quot;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;&quot;parameter&quot;&lt;/span&gt;: {&lt;br/&gt;                        &lt;span&gt;&quot;encoding&quot;&lt;/span&gt;: &lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;,&lt;br/&gt;                        &lt;span&gt;&quot;print&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        ],&lt;br/&gt;        &lt;span&gt;&quot;setting&quot;&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;&quot;speed&quot;&lt;/span&gt;: {&lt;br/&gt;                &lt;span&gt;&quot;channel&quot;&lt;/span&gt;: &lt;span&gt;&quot;1&quot;&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 运行&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接运行如下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/opt/datax/bin/datax.py /opt/datax/job/stream2stream.json&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出如下信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;DataX (DATAX-OPENSOURCE-3.0), From Alibaba !&lt;br/&gt;Copyright (C) 2010-2017, Alibaba Group. All Rights Reserved.&lt;br/&gt;&lt;br/&gt;2022-04-30 23:19:42.460 [main] INFO  VMInfo - VMInfo&lt;span&gt;# operatingSystem class =&amp;gt; sun.management.OperatingSystemImpl&lt;/span&gt;&lt;br/&gt;2022-04-30 23:19:42.469 [main] INFO  Engine - the machine info  =&amp;gt;&lt;br/&gt;&lt;br/&gt;...&lt;br/&gt;&lt;br/&gt;2022-04-30 23:19:42.492 [main] INFO  Engine -&lt;br/&gt;{&lt;br/&gt; &lt;span&gt;&quot;content&quot;&lt;/span&gt;:[&lt;br/&gt;  {&lt;br/&gt;   &lt;span&gt;&quot;reader&quot;&lt;/span&gt;:{&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;streamreader&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;parameter&quot;&lt;/span&gt;:{&lt;br/&gt;     &lt;span&gt;&quot;column&quot;&lt;/span&gt;:[&lt;br/&gt;      {&lt;br/&gt;       &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;long&quot;&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;&quot;value&quot;&lt;/span&gt;:&lt;span&gt;&quot;10&quot;&lt;/span&gt;&lt;br/&gt;      },&lt;br/&gt;      {&lt;br/&gt;       &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;&quot;value&quot;&lt;/span&gt;:&lt;span&gt;&quot;hello，DataX&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;     ],&lt;br/&gt;     &lt;span&gt;&quot;sliceRecordCount&quot;&lt;/span&gt;:&lt;span&gt;&quot;5&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;   },&lt;br/&gt;   &lt;span&gt;&quot;writer&quot;&lt;/span&gt;:{&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;streamwriter&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;parameter&quot;&lt;/span&gt;:{&lt;br/&gt;     &lt;span&gt;&quot;encoding&quot;&lt;/span&gt;:&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;,&lt;br/&gt;     &lt;span&gt;&quot;print&quot;&lt;/span&gt;:&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; ],&lt;br/&gt; &lt;span&gt;&quot;setting&quot;&lt;/span&gt;:{&lt;br/&gt;  &lt;span&gt;&quot;speed&quot;&lt;/span&gt;:{&lt;br/&gt;   &lt;span&gt;&quot;channel&quot;&lt;/span&gt;:&lt;span&gt;&quot;1&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;2022-04-30 23:19:42.511 [main] WARN  Engine - prioriy &lt;span&gt;set&lt;/span&gt; to 0, because NumberFormatException, the value is: null&lt;br/&gt;2022-04-30 23:19:42.513 [main] INFO  PerfTrace - PerfTrace traceId=job_-1, isEnable=&lt;span&gt;false&lt;/span&gt;, priority=0&lt;br/&gt;2022-04-30 23:19:42.513 [main] INFO  JobContainer - DataX jobContainer starts job.&lt;br/&gt;2022-04-30 23:19:42.515 [main] INFO  JobContainer - Set jobId = 0&lt;br/&gt;2022-04-30 23:19:42.530 [job-0] INFO  JobContainer - jobContainer starts to &lt;span&gt;do&lt;/span&gt; prepare ...&lt;br/&gt;2022-04-30 23:19:42.531 [job-0] INFO  JobContainer - DataX Reader.Job [streamreader] &lt;span&gt;do&lt;/span&gt; prepare work .&lt;br/&gt;2022-04-30 23:19:42.532 [job-0] INFO  JobContainer - DataX Writer.Job [streamwriter] &lt;span&gt;do&lt;/span&gt; prepare work .&lt;br/&gt;2022-04-30 23:19:42.532 [job-0] INFO  JobContainer - jobContainer starts to &lt;span&gt;do&lt;/span&gt; split ...&lt;br/&gt;2022-04-30 23:19:42.532 [job-0] INFO  JobContainer - Job &lt;span&gt;set&lt;/span&gt; Channel-Number to 1 channels.&lt;br/&gt;2022-04-30 23:19:42.532 [job-0] INFO  JobContainer - DataX Reader.Job [streamreader] splits to [1] tasks.&lt;br/&gt;2022-04-30 23:19:42.533 [job-0] INFO  JobContainer - DataX Writer.Job [streamwriter] splits to [1] tasks.&lt;br/&gt;2022-04-30 23:19:42.549 [job-0] INFO  JobContainer - jobContainer starts to &lt;span&gt;do&lt;/span&gt; schedule ...&lt;br/&gt;2022-04-30 23:19:42.554 [job-0] INFO  JobContainer - Scheduler starts [1] taskGroups.&lt;br/&gt;2022-04-30 23:19:42.556 [job-0] INFO  JobContainer - Running by standalone Mode.&lt;br/&gt;2022-04-30 23:19:42.563 [taskGroup-0] INFO  TaskGroupContainer - taskGroupId=[0] start [1] channels &lt;span&gt;for&lt;/span&gt; [1] tasks.&lt;br/&gt;2022-04-30 23:19:42.567 [taskGroup-0] INFO  Channel - Channel &lt;span&gt;set&lt;/span&gt; byte_speed_limit to -1, No bps activated.&lt;br/&gt;2022-04-30 23:19:42.567 [taskGroup-0] INFO  Channel - Channel &lt;span&gt;set&lt;/span&gt; record_speed_limit to -1, No tps activated.&lt;br/&gt;2022-04-30 23:19:42.580 [taskGroup-0] INFO  TaskGroupContainer - taskGroup[0] taskId[0] attemptCount[1] is started&lt;br/&gt;10 hello，DataX&lt;br/&gt;10 hello，DataX&lt;br/&gt;10 hello，DataX&lt;br/&gt;10 hello，DataX&lt;br/&gt;10 hello，DataX&lt;br/&gt;2022-04-30 23:19:42.685 [taskGroup-0] INFO  TaskGroupContainer - taskGroup[0] taskId[0] is successed, used[107]ms&lt;br/&gt;2022-04-30 23:19:42.686 [taskGroup-0] INFO  TaskGroupContainer - taskGroup[0] completed it&lt;span&gt;&#x27;s tasks.&lt;br/&gt;2022-04-30 23:19:52.573 [job-0] INFO  StandAloneJobContainerCommunicator - Total 5 records, 65 bytes | Speed 6B/s, 0 records/s | Error 0 records, 0 bytes |  All Task WaitWriterTime 0.000s |  All Task WaitReaderTime 0.000s | Percentage 100.00%&lt;br/&gt;2022-04-30 23:19:52.573 [job-0] INFO  AbstractScheduler - Scheduler accomplished all tasks.&lt;br/&gt;2022-04-30 23:19:52.574 [job-0] INFO  JobContainer - DataX Writer.Job [streamwriter] do post work.&lt;br/&gt;2022-04-30 23:19:52.574 [job-0] INFO  JobContainer - DataX Reader.Job [streamreader] do post work.&lt;br/&gt;2022-04-30 23:19:52.575 [job-0] INFO  JobContainer - DataX jobId [0] completed successfully.&lt;br/&gt;2022-04-30 23:19:52.576 [job-0] INFO  HookInvoker - No hook invoked, because base dir not exists or is a file: /opt/datax/hook&lt;br/&gt;2022-04-30 23:19:52.579 [job-0] INFO  JobContainer -&lt;br/&gt;  [total cpu info] =&amp;gt;&lt;br/&gt;  averageCpu                     | maxDeltaCpu                    | minDeltaCpu&lt;br/&gt;  -1.00%                         | -1.00%                         | -1.00%&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  [total gc info] =&amp;gt;&lt;br/&gt;   NAME                 | totalGCCount       | maxDeltaGCCount    | minDeltaGCCount    | totalGCTime        | maxDeltaGCTime     | minDeltaGCTime&lt;br/&gt;   PS MarkSweep         | 0                  | 0                  | 0                  | 0.000s             | 0.000s             | 0.000s&lt;br/&gt;   PS Scavenge          | 0                  | 0                  | 0                  | 0.000s             | 0.000s             | 0.000s&lt;br/&gt;&lt;br/&gt;2022-04-30 23:19:52.580 [job-0] INFO  JobContainer - PerfTrace not enable!&lt;br/&gt;2022-04-30 23:19:52.580 [job-0] INFO  StandAloneJobContainerCommunicator - Total 5 records, 65 bytes | Speed 6B/s, 0 records/s | Error 0 records, 0 bytes |  All Task WaitWriterTime 0.000s |  All Task WaitReaderTime 0.000s | Percentage 100.00%&lt;br/&gt;2022-04-30 23:19:52.581 [job-0] INFO  JobContainer -&lt;br/&gt;任务启动时刻                    : 2022-04-30 23:19:42&lt;br/&gt;任务结束时刻                    : 2022-04-30 23:19:52&lt;br/&gt;任务总计耗时                    :                 10s&lt;br/&gt;任务平均流量                    :                6B/s&lt;br/&gt;记录写入速度                    :              0rec/s&lt;br/&gt;读出记录总数                    :                   5&lt;br/&gt;读写失败总数                    :                   0&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>72354d455f3c1cfe35c91dbb5e63e322</guid>
<title>[推荐] 面渣逆袭：Spring三十五问，四万字+五十图详解！建议收藏！</title>
<link>https://toutiao.io/k/8ab20e9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是老三啊，&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkwODE5ODM0Ng==&amp;amp;action=getalbum&amp;amp;album_id=2041709347461709827&amp;amp;scene=173&amp;amp;from_msgid=2247489004&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;面渣逆袭&lt;/a&gt; 继续，这节我们来搞定另一个面试必问知识点——Spring。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人说，“Java程序员都是Spring程序员”，老三不太赞成这个观点，但是这也可以看出Spring在Java世界里举足轻重的作用。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdFLJg0sAOqwHB1mb24icMADUgxm1qZQft5aN3H37NAmQnOvpGB7J9JVHxC6NSiacxbBP1DYdhIAeyA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;CSDN博客专家、优质创作者，华为云云享专家；肝过外包、混过国企，目前在一家跨境电商搬砖；写过诗，打过拳，佛系小码农。认真讲技术，随性侃人生，关注我，我们一起走的更远。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基础&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.Spring是什么？特性？有哪些模块？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs1kVPQW98hUE4lPjKTOwuNlObyK8s9jrlYpY2Kz2cGoiaYuXlNPr7IZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;Spring Logo&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话概括：&lt;strong&gt;Spring 是一个轻量级、非入侵式的控制反转 (IoC) 和面向切面 (AOP) 的框架。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2003年，一个音乐家Rod Johnson决定发展一个轻量级的Java开发框架，&lt;code&gt;Spring&lt;/code&gt;作为Java战场的龙骑兵渐渐崛起，并淘汰了&lt;code&gt;EJB&lt;/code&gt;这个传统的重装骑兵。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.270996640537514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsVBQbXvrAtHDXCXiagAPNW4h56vZbMCIUleEjrQDToDLruWx6ib9U1Dsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;893&quot;/&gt;&lt;figcaption&gt;Spring重要版本&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到了现在，企业级开发的标配基本就是 &lt;strong&gt;Spring5&lt;/strong&gt; + &lt;strong&gt;Spring Boot 2&lt;/strong&gt; + &lt;strong&gt;JDK 8&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Spring有哪些特性呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring有很多优点：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8233618233618234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsELLaSC9V9hibcK4MjSYOlh5oeFJL4sIAAfsPRibibJXeKc890M8IZUJrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;figcaption&gt;Spring特性&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;IOC&lt;/strong&gt; 和 &lt;strong&gt;DI&lt;/strong&gt; 的支持&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 的核心就是一个大的工厂容器，可以维护所有对象的创建和依赖关系，Spring 工厂用于生成 Bean，并且管理 Bean 的生命周期，实现&lt;strong&gt;高内聚低耦合&lt;/strong&gt;的设计理念。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;AOP 编程的支持&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 提供了&lt;strong&gt;面向切面编程&lt;/strong&gt;，可以方便的实现对程序进行权限拦截、运行监控等切面功能。&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;声明式事务的支持&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式，以前重复的一些事务提交、回滚的JDBC代码，都可以不用自己写了。&lt;/p&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;快捷测试的支持&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 对 Junit 提供支持，可以通过&lt;strong&gt;注解&lt;/strong&gt;快捷地测试 Spring 程序。&lt;/p&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;快速集成功能&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。&lt;/p&gt;&lt;ol start=&quot;6&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;复杂API模板封装&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板化的封装，这些封装 API 的提供使得应用难度大大降低。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.Spring有哪些模块呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 框架是分模块存在，除了最核心的&lt;code&gt;Spring Core Container&lt;/code&gt;是必要模块之外，其他模块都是&lt;code&gt;可选&lt;/code&gt;，大约有 20 多个模块。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7319884726224783&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsiciclyX016BVfa7g8edRug9sz4yyNVOX9Hc1iaheT0ZkP9qNAOdESjsXw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;694&quot;/&gt;&lt;figcaption&gt;Spring模块划分&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最主要的七大模块：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Spring Core&lt;/strong&gt;：Spring 核心，它是框架最基础的部分，提供 IOC 和依赖注入 DI 特性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Spring Context&lt;/strong&gt;：Spring 上下文容器，它是 BeanFactory 功能加强的一个子接口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Spring Web&lt;/strong&gt;：它提供 Web 应用开发的支持。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Spring MVC&lt;/strong&gt;：它针对 Web 应用中 MVC 思想的实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Spring DAO&lt;/strong&gt;：提供对 JDBC 抽象层，简化了 JDBC 编码，同时，编码更具有健壮性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Spring ORM&lt;/strong&gt;：它支持用于流行的 ORM 框架的整合，比如：Spring + Hibernate、Spring + iBatis、Spring + JDO 的整合等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Spring AOP&lt;/strong&gt;：即面向切面编程，它提供了与 AOP 联盟兼容的编程实现。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.Spring有哪些常用注解呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring有很多模块，甚至广义的SpringBoot、SpringCloud也算是Spring的一部分，我们来分模块，按功能来看一下一些常用的注解：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3128654970760234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs9aR2elJWUJvp6ibockInIrcNj1jPTW4NamvGZl4InuG0O6cffuNMtFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1026&quot;/&gt;&lt;figcaption&gt;Spring常用注解&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Web&lt;/strong&gt;:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;@Controller：组合注解（组合了@Component注解），应用在MVC层（控制层）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@RestController：该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@RequestMapping：用于映射Web请求，包括访问路径和参数。如果是Restful风格接口，还可以根据请求类型使用不同的注解：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;@GetMapping&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@PostMapping&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@PutMapping&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@DeleteMapping&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;@ResponseBody：支持将返回值放在response内，而不是一个页面，通常用户返回json数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@RequestBody：允许request的参数在request体中，而不是在直接连接在地址后面。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@PathVariable：用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@RestController：该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;容器&lt;/strong&gt;:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;@Component：表示一个带注释的类是一个“组件”，成为Spring管理的Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component还是一个元注解。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Service：组合注解（组合了@Component注解），应用在service层（业务逻辑层）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Repository：组合注解（组合了@Component注解），应用在dao层（数据访问层）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Autowired：Spring提供的工具（由Spring的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Qualifier：该注解通常跟 @Autowired 一起使用，当想对注入的过程做更多的控制，@Qualifier 可帮助配置，比如两个以上相同类型的 Bean 时 Spring 无法抉择，用到此注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Configuration：声明当前类是一个配置类（相当于一个Spring配置的xml文件）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Value：可用在字段，构造器参数跟方法参数，指定一个默认值，支持 #{} 跟 ${} 两个方式。一般将 SpringbBoot 中的 application.properties 配置的属性值赋值给变量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Bean：注解在方法上，声明当前方法的返回值为一个Bean。返回的Bean对应的类中可以定义init()方法和destroy()方法，然后在@Bean(initMethod=”init”,destroyMethod=”destroy”)定义，在构造之后执行init，在销毁之前执行destroy。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Scope:定义我们采用什么模式去创建Bean（方法上，得有@Bean） 其设置类型包括：Singleton 、Prototype、Request 、 Session、GlobalSession。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AOP&lt;/strong&gt;:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;@Aspect:声明一个切面（类上） 使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@After&lt;/code&gt; ：在方法执行之后执行（方法上）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@Before&lt;/code&gt;：在方法执行之前执行（方法上）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@Around&lt;/code&gt;：在方法执行之前与之后执行（方法上）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@PointCut&lt;/code&gt;：声明切点 在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;事务：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;@Transactional：在要开启事务的方法上使用@Transactional注解，即可声明式开启事务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.Spring 中应用了哪些设计模式呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8389937106918239&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfst3iaqUkGoCUJf1a13Ub5reb0wfPxqHLkHPQricAj6PfbJic5ia3ZmdS6Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;795&quot;/&gt;&lt;figcaption&gt;Spring中用到的设计模式&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;工厂模式&lt;/strong&gt; : Spring 容器本质是一个大工厂，使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;代理模式&lt;/strong&gt; : Spring AOP 功能功能就是通过代理模式来实现的，分为动态代理和静态代理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;单例模式&lt;/strong&gt; : Spring 中的 Bean 默认都是单例的，这样有利于容器对Bean的管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;模板模式&lt;/strong&gt; : Spring 中 JdbcTemplate、RestTemplate 等以 Template结尾的对数据库、网络等等进行操作的模板类，就使用到了模板模式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;观察者模式&lt;/strong&gt;: Spring 事件驱动模型就是观察者模式很经典的一个应用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;适配器模式&lt;/strong&gt; :Spring AOP 的增强或通知 (Advice) 使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;策略模式&lt;/strong&gt;：Spring中有一个Resource接口，它的不同实现类，会根据不同的策略去访问资源。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;IOC&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.说一说什么是IOC？什么是DI?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 是面向对象的编程语言，一个个实例对象相互合作组成了业务逻辑，原来，我们都是在代码里创建对象和对象的依赖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的&lt;strong&gt;IOC&lt;/strong&gt;（控制反转）：就是由容器来负责控制对象的生命周期和对象间的关系。以前是我们想要什么，就自己创建什么，现在是我们需要什么，容器就给我们送来什么。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42781954887218043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs3fibs5nDW3O6lSb3n7SYzOjDMLfarxS1kzONGIa7Ye1jia1jtOFx9xRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot;/&gt;&lt;figcaption&gt;引入IOC之前和引入IOC之后&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，控制对象生命周期的不再是引用它的对象，而是容器。对具体对象，以前是它控制其它对象，现在所有对象都被容器控制，所以这就叫&lt;strong&gt;控制反转&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5450381679389313&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs3M8HjpONB2Bs6LlXkQO4bibuvVctMyq0zsOondP4FrvSpS9yTSt5JiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;&lt;figcaption&gt;控制反转示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DI（依赖注入）&lt;/strong&gt;：指的是容器在实例化对象的时候把它依赖的类注入给它。有的说法IOC和DI是一回事，有的说法是IOC是思想，DI是IOC的实现。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么要使用IOC呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最主要的是两个字&lt;strong&gt;解耦&lt;/strong&gt;，硬编码会造成对象间的过度耦合，使用IOC之后，我们可以不用关心对象间的依赖，专心开发应用就行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.能简单说一下Spring IOC的实现机制吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:这道题老三在面试中被问到过，问法是“&lt;strong&gt;你有自己实现过简单的Spring吗？&lt;/strong&gt;”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring的IOC本质就是一个大工厂，我们想想一个工厂是怎么运行的呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7169014084507043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsIpMzbVObGKSDoZsXOEqJkibkuqsDbOsibh02EUBY9dXK5BVE5gusfZ9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;710&quot;/&gt;&lt;figcaption&gt;工厂运行&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;生产产品&lt;/strong&gt;：一个工厂最核心的功能就是生产产品。在Spring里，不用Bean自己来实例化，而是交给Spring，应该怎么实现呢？——答案毫无疑问，&lt;strong&gt;反射&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;那么这个厂子的生产管理是怎么做的？你应该也知道——&lt;strong&gt;工厂模式&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;库存产品&lt;/strong&gt;：工厂一般都是有库房的，用来库存产品，毕竟生产的产品不能立马就拉走。Spring我们都知道是一个容器，这个容器里存的就是对象，不能每次来取对象，都得现场来反射创建对象，得把创建出的对象存起来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;订单处理&lt;/strong&gt;：还有最重要的一点，工厂根据什么来提供产品呢？订单。这些订单可能五花八门，有线上签签的、有到工厂签的、还有工厂销售上门签的……最后经过处理，指导工厂的出货。&lt;/p&gt;&lt;p&gt;在Spring里，也有这样的订单，它就是我们bean的定义和依赖关系，可以是xml形式，也可以是我们最熟悉的注解形式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们简单地实现一个mini版的Spring IOC：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28180961357210177&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsWX9An2rYbJ3CF2e1icus4xdOw6LMDaBpHxGj8rkLKXicO6T5tN5GVHhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1061&quot;/&gt;&lt;figcaption&gt;mini版本Spring IOC&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Bean定义：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bean通过一个配置文件定义，把它解析成一个类型。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;beans.properties&lt;/p&gt;&lt;p&gt;偷懒，这里直接用了最方便解析的properties，这里直接用一个&amp;lt;key,value&amp;gt;类型的配置来代表Bean的定义，其中key是beanName，value是class&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;userDao:cn.fighter3.bean.UserDao&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;BeanDefinition.java&lt;/p&gt;&lt;p&gt;bean定义类，配置文件中bean定义对应的实体&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BeanDefinition&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String beanName;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Class beanClass;&lt;br/&gt;     &lt;span&gt;//省略getter、setter  &lt;/span&gt;&lt;br/&gt; }   &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ResourceLoader.java&lt;/p&gt;&lt;p&gt;资源加载器，用来完成配置文件中配置的加载&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ResourceLoader&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, BeanDefinition&amp;gt; &lt;span&gt;getResource&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Map&amp;lt;String, BeanDefinition&amp;gt; beanDefinitionMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;        Properties properties = &lt;span&gt;new&lt;/span&gt; Properties();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            InputStream inputStream = ResourceLoader&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getResourceAsStream&lt;/span&gt;(&quot;/&lt;span&gt;beans&lt;/span&gt;.&lt;span&gt;properties&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;            properties.load(inputStream);&lt;br/&gt;            Iterator&amp;lt;String&amp;gt; it = properties.stringPropertyNames().iterator();&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (it.hasNext()) {&lt;br/&gt;                String key = it.next();&lt;br/&gt;                String className = properties.getProperty(key);&lt;br/&gt;                BeanDefinition beanDefinition = &lt;span&gt;new&lt;/span&gt; BeanDefinition();&lt;br/&gt;                beanDefinition.setBeanName(key);&lt;br/&gt;                Class clazz = Class.forName(className);&lt;br/&gt;                beanDefinition.setBeanClass(clazz);&lt;br/&gt;                beanDefinitionMap.put(key, beanDefinition);&lt;br/&gt;            }&lt;br/&gt;            inputStream.close();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException | ClassNotFoundException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; beanDefinitionMap;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;BeanRegister.java&lt;/p&gt;&lt;p&gt;对象注册器，这里用于单例bean的缓存，我们大幅简化，默认所有bean都是单例的。可以看到所谓单例注册，也很简单，不过是往HashMap里存对象。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BeanRegister&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//单例Bean缓存&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; singletonMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取单例Bean&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; beanName bean名称&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getSingletonBean&lt;/span&gt;&lt;span&gt;(String beanName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; singletonMap.get(beanName);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 注册单例bean&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; beanName&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; bean&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerSingletonBean&lt;/span&gt;&lt;span&gt;(String beanName, Object bean)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (singletonMap.containsKey(beanName)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        singletonMap.put(beanName, bean);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;BeanFactory.java&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsQ6zdoYjicRs7HYjLGaQol4UMiaib7PSHPvGp7iaSlDIyYbQia2qIemRfic3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;432&quot;/&gt;&lt;figcaption&gt;BeanFactory&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对象工厂，我们最&lt;strong&gt;核心&lt;/strong&gt;的一个类，在它初始化的时候，创建了bean注册器，完成了资源的加载。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;获取bean的时候，先从单例缓存中取，如果没有取到，就创建并注册一个bean&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BeanFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, BeanDefinition&amp;gt; beanDefinitionMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; BeanRegister beanRegister;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;BeanFactory&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//创建bean注册器&lt;/span&gt;&lt;br/&gt;        beanRegister = &lt;span&gt;new&lt;/span&gt; BeanRegister();&lt;br/&gt;        &lt;span&gt;//加载资源&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.beanDefinitionMap = &lt;span&gt;new&lt;/span&gt; ResourceLoader().getResource();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取bean&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; beanName bean名称&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getBean&lt;/span&gt;&lt;span&gt;(String beanName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//从bean缓存中取&lt;/span&gt;&lt;br/&gt;        Object bean = beanRegister.getSingletonBean(beanName);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (bean != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//根据bean定义，创建bean&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; createBean(beanDefinitionMap.get(beanName));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 创建Bean&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; beanDefinition bean定义&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; Object &lt;span&gt;createBean&lt;/span&gt;&lt;span&gt;(BeanDefinition beanDefinition)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            Object bean = beanDefinition.getBeanClass().newInstance();&lt;br/&gt;            &lt;span&gt;//缓存bean&lt;/span&gt;&lt;br/&gt;            beanRegister.registerSingletonBean(beanDefinition.getBeanName(), bean);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InstantiationException | IllegalAccessException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;测试&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;UserDao.java&lt;/p&gt;&lt;p&gt;我们的Bean类，很简单&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserDao&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;queryUserInfo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;A good man.&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;单元测试&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ApiTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test_BeanFactory&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//1.创建bean工厂(同时完成了加载资源、创建注册单例bean注册器的操作)&lt;/span&gt;&lt;br/&gt;        BeanFactory beanFactory = &lt;span&gt;new&lt;/span&gt; BeanFactory();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//2.第一次获取bean（通过反射创建bean，缓存bean）&lt;/span&gt;&lt;br/&gt;        UserDao userDao1 = (UserDao) beanFactory.getBean(&lt;span&gt;&quot;userDao&quot;&lt;/span&gt;);&lt;br/&gt;        userDao1.queryUserInfo();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//3.第二次获取bean（从缓存中获取bean）&lt;/span&gt;&lt;br/&gt;        UserDao userDao2 = (UserDao) beanFactory.getBean(&lt;span&gt;&quot;userDao&quot;&lt;/span&gt;);&lt;br/&gt;        userDao2.queryUserInfo();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;运行结果&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;A good man.&lt;br/&gt;A good man.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们一个乞丐+破船版的Spring就完成了，代码也比较完整，有条件的可以跑一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:因为时间+篇幅的限制，这个demo比较简陋，没有面向接口、没有解耦、边界检查、异常处理……健壮性、扩展性都有很大的不足，感兴趣可以学习参考[15]。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.说说BeanFactory和ApplicantContext?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以这么形容，BeanFactory是Spring的“心脏”，ApplicantContext是完整的“身躯”。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3757575757575757&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs6RO2C872PoFjMmECiceLjvNvts8QVoyiazaRRZcqbt6tVa67SRogc2FA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;330&quot;/&gt;&lt;figcaption&gt;BeanFactory和ApplicantContext的比喻&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;BeanFactory（Bean工厂）是Spring框架的基础设施，面向Spring本身。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ApplicantContext（应用上下文）建立在BeanFactoty基础上，面向使用Spring框架的开发者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;BeanFactory 接口&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanFactory是类的通用工厂，可以创建并管理各种类的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring为BeanFactory提供了很多种实现，最常用的是XmlBeanFactory，但在Spring 3.2中已被废弃，建议使用XmlBeanDefinitionReader、DefaultListableBeanFactory。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6650366748166259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsoHzkeuWnGIe4I7AhcJyhA6Ee9mj85ol8gOHibcmhAdQZGUb1LoS5orA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1227&quot;/&gt;&lt;figcaption&gt;Spring5 BeanFactory继承体系&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanFactory接口位于类结构树的顶端，它最主要的方法就是getBean(String var1)，这个方法从容器中返回特定名称的Bean。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanFactory的功能通过其它的接口得到了不断的扩展，比如AbstractAutowireCapableBeanFactory定义了将容器中的Bean按照某种规则（比如按名字匹配、按类型匹配等）进行自动装配的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里看一个 XMLBeanFactory（已过期）  获取bean 的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HelloWorldApp&lt;/span&gt;&lt;/span&gt;{ &lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;      BeanFactory factory = &lt;span&gt;new&lt;/span&gt; XmlBeanFactory (&lt;span&gt;new&lt;/span&gt; ClassPathResource(&lt;span&gt;&quot;beans.xml&quot;&lt;/span&gt;)); &lt;br/&gt;      HelloWorld obj = (HelloWorld) factory.getBean(&lt;span&gt;&quot;helloWorld&quot;&lt;/span&gt;);    &lt;br/&gt;      obj.getMessage();    &lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ApplicationContext 接口&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。可以这么说，使用BeanFactory就是手动档，使用ApplicationContext就是自动档。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6947368421052632&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsyEOGK2axU622EHjuQ7Rsa583NM01OqbBIy46angN3EWGgUOPJ5YhfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot;/&gt;&lt;figcaption&gt;Spring5 ApplicationContext部分体系类图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ApplicationContext 继承了HierachicalBeanFactory和ListableBeanFactory接口，在此基础上，还通过其他的接口扩展了BeanFactory的功能，包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Bean instantiation/wiring&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Bean 的实例化/串联&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;自动的 BeanPostProcessor 注册&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;自动的 BeanFactoryPostProcessor 注册&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;方便的 MessageSource 访问（i18n）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ApplicationEvent 的发布与 BeanFactory 懒加载的方式不同，它是预加载，所以，每一个 bean 都在 ApplicationContext 启动之后实例化&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是 ApplicationContext 的使用例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HelloWorldApp&lt;/span&gt;&lt;/span&gt;{ &lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;      ApplicationContext context=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;&quot;beans.xml&quot;&lt;/span&gt;); &lt;br/&gt;      HelloWorld obj = (HelloWorld) context.getBean(&lt;span&gt;&quot;helloWorld&quot;&lt;/span&gt;);    &lt;br/&gt;      obj.getMessage();    &lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ApplicationContext 包含 BeanFactory 的所有特性，通常推荐使用前者。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.你知道Spring容器启动阶段会干什么吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS：这道题老三面试被问到过&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring的IOC容器工作的过程，其实可以划分为两个阶段：&lt;strong&gt;容器启动阶段&lt;/strong&gt;和&lt;strong&gt;Bean实例化阶段&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中容器启动阶段主要做的工作是加载和解析配置文件，保存到对应的Bean定义中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48741721854304637&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs4Lo0JSJ7RkIcFSCKI7FAasJY7KicrWoQmia5DdWC5uHO9Z7zzH1NfgIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;755&quot;/&gt;&lt;figcaption&gt;容器启动和Bean实例化阶段&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;容器启动开始，首先会通过某种途径加载Congiguration MetaData，在大部分情况下，容器需要依赖某些工具类（BeanDefinitionReader）对加载的Congiguration MetaData进行解析和分析，并将分析后的信息组为相应的BeanDefinition。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5280898876404494&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsPe92jRl95ly92lq6BJCzaCGj1NCef4tT97vcXFu0J6h9XkkKRPKvMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;801&quot;/&gt;&lt;figcaption&gt;xml配置信息映射注册过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后把这些保存了Bean定义必要信息的BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器启动就完成了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.能说一下Spring Bean生命周期吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看看：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247490715&amp;amp;idx=1&amp;amp;sn=2bb7a7d6d37321289222e28bf47db77a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Spring Bean生命周期，好像人的一生。。&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Spring中，基本容器BeanFactory和扩展容器ApplicationContext的实例化时机不太一样，BeanFactory采用的是延迟初始化的方式，也就是只有在第一次getBean()的时候，才会实例化Bean；ApplicationContext启动之后会实例化所有的Bean定义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring IOC 中Bean的生命周期大致分为四个阶段：&lt;strong&gt;实例化&lt;/strong&gt;（Instantiation）、&lt;strong&gt;属性赋值&lt;/strong&gt;（Populate）、&lt;strong&gt;初始化&lt;/strong&gt;（Initialization）、&lt;strong&gt;销毁&lt;/strong&gt;（Destruction）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.507&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsmuTuIpm8FYbv4bwcDOA40hMyd1m4PmTpAfb0WwMBmeIicgQr3EUGe8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;Bean生命周期四个阶段&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看一个稍微详细一些的过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;实例化&lt;/strong&gt;：第 1 步，实例化一个 Bean 对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;属性赋值&lt;/strong&gt;：第 2 步，为 Bean 设置相关属性和依赖&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;初始化&lt;/strong&gt;：初始化的阶段的步骤比较多，5、6步是真正的初始化，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，初始化完成之后，Bean就可以被使用了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;销毁&lt;/strong&gt;：第 8~10步，第8步其实也可以算到销毁阶段，但不是真正意义上的销毁，而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁 Bean 时再执行相应的方法&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7785923753665689&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs7hicasRVtianibpy3g0Jy1mgOnucAywCIdgmQaQQEKqjsuMc5tWg39hJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1364&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单总结一下，Bean生命周期里初始化的过程相对步骤会多一些，比如前置、后置的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后通过一个实例来看一下具体的细节：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.561797752808989&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsfMEEhDEfsMtMDKrMUucYGsg5EMzDUmlWeic3PDQSia3nPjtZGicqFj6pA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;定义一个&lt;code&gt;PersonBean&lt;/code&gt;类，实现&lt;code&gt;DisposableBean&lt;/code&gt;,&lt;code&gt; InitializingBean&lt;/code&gt;, &lt;code&gt;BeanFactoryAware&lt;/code&gt;, &lt;code&gt;BeanNameAware&lt;/code&gt;这4个接口，同时还有自定义的&lt;code&gt;init-method&lt;/code&gt;和&lt;code&gt;destroy-method&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonBean&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InitializingBean&lt;/span&gt;, &lt;span&gt;BeanFactoryAware&lt;/span&gt;, &lt;span&gt;BeanNameAware&lt;/span&gt;, &lt;span&gt;DisposableBean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 身份证号&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer no;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 姓名&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;PersonBean&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;1.调用构造方法：我出生了！&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;getNo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; no;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setNo&lt;/span&gt;&lt;span&gt;(Integer no)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.no = no;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; name;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setName&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;2.设置属性：我的名字叫&quot;&lt;/span&gt;+name);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setBeanName&lt;/span&gt;&lt;span&gt;(String s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;3.调用BeanNameAware#setBeanName方法:我要上学了，起了个学名&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setBeanFactory&lt;/span&gt;&lt;span&gt;(BeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;4.调用BeanFactoryAware#setBeanFactory方法：选好学校了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterPropertiesSet&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;6.InitializingBean#afterPropertiesSet方法：入学登记&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;7.自定义init方法：努力上学ing&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;9.DisposableBean#destroy方法：平淡的一生落幕了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;destroyMethod&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;10.自定义destroy方法:睡了，别想叫醒我&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;work&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Bean使用中：工作，只有对社会没有用的人才放假。。&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;定义一个&lt;code&gt;MyBeanPostProcessor&lt;/code&gt;实现&lt;code&gt;BeanPostProcessor&lt;/code&gt;接口。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyBeanPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;postProcessBeforeInitialization&lt;/span&gt;&lt;span&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;5.BeanPostProcessor.postProcessBeforeInitialization方法：到学校报名啦&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;postProcessAfterInitialization&lt;/span&gt;&lt;span&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;8.BeanPostProcessor#postProcessAfterInitialization方法：终于毕业，拿到毕业证啦！&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;配置文件，指定&lt;code&gt;init-method&lt;/code&gt;和&lt;code&gt;destroy-method&lt;/code&gt;属性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;?xml version=&lt;span&gt;&quot;1.0&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;?&amp;gt;&lt;br/&gt;&amp;lt;beans xmlns=&lt;span&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;br/&gt;       xmlns:xsi=&lt;span&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;br/&gt;       xsi:schemaLocation=&lt;span&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;br/&gt;    &amp;lt;bean name=&lt;span&gt;&quot;myBeanPostProcessor&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;cn.fighter3.spring.life.MyBeanPostProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;bean name=&lt;span&gt;&quot;personBean&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;cn.fighter3.spring.life.PersonBean&quot;&lt;/span&gt;&lt;br/&gt;          init-method=&lt;span&gt;&quot;init&quot;&lt;/span&gt; destroy-method=&lt;span&gt;&quot;destroyMethod&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;        &amp;lt;property name=&lt;span&gt;&quot;idNo&quot;&lt;/span&gt; value= &lt;span&gt;&quot;80669865&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;        &amp;lt;property name=&lt;span&gt;&quot;name&quot;&lt;/span&gt; value=&lt;span&gt;&quot;张铁钢&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;/beans&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ApplicationContext context = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;&quot;spring-config.xml&quot;&lt;/span&gt;);&lt;br/&gt;        PersonBean personBean = (PersonBean) context.getBean(&lt;span&gt;&quot;personBean&quot;&lt;/span&gt;);&lt;br/&gt;        personBean.work();&lt;br/&gt;        ((ClassPathXmlApplicationContext) context).destroy();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;.调用构造方法：我出生了！&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;.设置属性：我的名字叫张铁钢&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;.调用BeanNameAware#setBeanName方法:我要上学了，起了个学名&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;.调用BeanFactoryAware#setBeanFactory方法：选好学校了&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;.BeanPostProcessor#postProcessBeforeInitialization方法：到学校报名啦&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;.InitializingBean#afterPropertiesSet方法：入学登记&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;.自定义init方法：努力上学ing&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;.BeanPostProcessor#postProcessAfterInitialization方法：终于毕业，拿到毕业证啦！&lt;br/&gt;Bean使用中：工作，只有对社会没有用的人才放假。。&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;.DisposableBean#destroy方法：平淡的一生落幕了&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;.自定义destroy方法:睡了，别想叫醒我&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于源码，Bean创建过程可以查看&lt;code&gt;AbstractBeanFactory#doGetBean&lt;/code&gt;方法，在这个方法里可以看到Bean的实例化，赋值、初始化的过程，至于最终的销毁，可以看看&lt;code&gt;ConfigurableApplicationContext#close()&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6083707025411061&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsaCSEgw2DGiaNcicHouBSYiciazbUaK9DW5qzxm1JxWLBG0LEDtHdibYwPVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1338&quot;/&gt;&lt;figcaption&gt;Bean生命周期源码追踪&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.Bean定义和依赖定义有哪些方式？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有三种方式：&lt;strong&gt;直接编码方式&lt;/strong&gt;、&lt;strong&gt;配置文件方式&lt;/strong&gt;、&lt;strong&gt;注解方式&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4791666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsaI0tmficqM9yzG4eQxKTbOH4AVArn9a1Q61EqfTPaqZfmVKQonANLxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;figcaption&gt;Bean依赖配置方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;直接编码方式：我们一般接触不到直接编码的方式，但其实其它的方式最终都要通过直接编码来实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置文件方式：通过xml、propreties类型的配置文件，配置相应的依赖关系，Spring读取配置文件，完成依赖关系的注入。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注解方式：注解方式应该是我们用的最多的一种方式了，在相应的地方使用注解修饰，Spring会扫描注解，完成依赖关系的注入。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.有哪些依赖注入的方法？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring支持&lt;strong&gt;构造方法注入&lt;/strong&gt;、&lt;strong&gt;属性注入&lt;/strong&gt;、&lt;strong&gt;工厂方法注入&lt;/strong&gt;,其中工厂方法注入，又可以分为&lt;strong&gt;静态工厂方法注入&lt;/strong&gt;和&lt;strong&gt;非静态工厂方法注入&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3721227621483376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsicOqscVZBksWgz8aa2eCnKlj6DU21p0rk2ahhIzKSvQ7JuL05iaUIwPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1564&quot;/&gt;&lt;figcaption&gt;Spring依赖注入方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;构造方法注入&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过调用类的构造方法，将接口实现类通过构造方法变量传入&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CatDaoImpl&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;. message = message;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;bean id=&lt;span&gt;&quot;CatDaoImpl&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;com.CatDaoImpl&quot;&lt;/span&gt;&amp;gt; &lt;br/&gt;  &amp;lt;constructor-arg value=&lt;span&gt;&quot; message &quot;&lt;/span&gt;&amp;gt;&amp;lt;/constructor-arg&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;属性注入&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过Setter方法完成调用类所需依赖的注入&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Id&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; id; }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setId&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; id)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;this&lt;/span&gt;.id = id; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;bean id=&lt;span&gt;&quot;id&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;com.id &quot;&lt;/span&gt;&amp;gt; &lt;br/&gt;  &amp;lt;property name=&lt;span&gt;&quot;id&quot;&lt;/span&gt; value=&lt;span&gt;&quot;123&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt; &lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;工厂方法注入&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;静态工厂注入&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让 Spring 管理所有对象，我们不能直接通过&quot;工程类.静态方法()&quot;来获取对象，而是依然通过 Spring 注入的形式获取：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DaoFactory&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;//静态工厂&lt;/span&gt;&lt;br/&gt; &lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; FactoryDao &lt;span&gt;getStaticFactoryDaoImpl&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; StaticFacotryDaoImpl();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt; &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SpringAction&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt; &lt;span&gt;//注入对象&lt;/span&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; FactoryDao staticFactoryDao; &lt;br/&gt; &lt;br/&gt; &lt;span&gt;//注入对象的 set 方法&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setStaticFactoryDao&lt;/span&gt;&lt;span&gt;(FactoryDao staticFactoryDao)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;this&lt;/span&gt;.staticFactoryDao = staticFactoryDao;&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//factory-method=&quot;getStaticFactoryDaoImpl&quot;指定调用哪个工厂方法&lt;/span&gt;&lt;br/&gt; &amp;lt;bean name=&lt;span&gt;&quot;springAction&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot; SpringAction&quot;&lt;/span&gt; &amp;gt;&lt;br/&gt;   &amp;lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--&amp;gt;&lt;br/&gt;   &amp;lt;property name=&lt;span&gt;&quot;staticFactoryDao&quot;&lt;/span&gt; ref=&lt;span&gt;&quot;staticFactoryDao&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt; &amp;lt;/bean&amp;gt;&lt;br/&gt; &lt;br/&gt; &amp;lt;!--此处获取对象的方式是从工厂类中获取静态方法--&amp;gt;&lt;br/&gt;&amp;lt;bean name=&lt;span&gt;&quot;staticFactoryDao&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;DaoFactory&quot;&lt;/span&gt;&lt;br/&gt;  factory-method=&lt;span&gt;&quot;getStaticFactoryDaoImpl&quot;&lt;/span&gt;&amp;gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;非静态工厂注入&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;非静态工厂，也叫实例工厂，意思是工厂方法不是静态的，所以我们需要首先 new 一个工厂实例，再调用普通的实例方法。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//非静态工厂 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DaoFactory&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; FactoryDao &lt;span&gt;getFactoryDaoImpl&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FactoryDaoImpl();&lt;br/&gt;   }&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SpringAction&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//注入对象&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; FactoryDao factoryDao; &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setFactoryDao&lt;/span&gt;&lt;span&gt;(FactoryDao factoryDao)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.factoryDao = factoryDao;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt; &amp;lt;bean name=&lt;span&gt;&quot;springAction&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;SpringAction&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;   &amp;lt;!--使用非静态工厂的方法注入对象,对应下面的配置文件--&amp;gt;&lt;br/&gt;   &amp;lt;property name=&lt;span&gt;&quot;factoryDao&quot;&lt;/span&gt; ref=&lt;span&gt;&quot;factoryDao&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt; &amp;lt;/bean&amp;gt;&lt;br/&gt; &lt;br/&gt; &amp;lt;!--此处获取对象的方式是从工厂类中获取实例方法--&amp;gt;&lt;br/&gt; &amp;lt;bean name=&lt;span&gt;&quot;daoFactory&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;com.DaoFactory&quot;&lt;/span&gt;&amp;gt;&amp;lt;/bean&amp;gt;&lt;br/&gt; &lt;br/&gt;&amp;lt;bean name=&lt;span&gt;&quot;factoryDao&quot;&lt;/span&gt; factory-bean=&lt;span&gt;&quot;daoFactory&quot;&lt;/span&gt; factory-method=&lt;span&gt;&quot;getFactoryDaoImpl&quot;&lt;/span&gt;&amp;gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.Spring有哪些自动装配的方式？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是自动装配？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring IOC容器知道所有Bean的配置信息，此外，通过Java反射机制还可以获知实现类的结构信息，如构造方法的结构、属性等信息。掌握所有Bean的这些信息后，Spring IOC容器就可以按照某种规则对容器中的Bean进行自动装配，而无须通过显式的方式进行依赖配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring提供的这种方式，可以按照某些规则进行Bean的自动装配，&lt;bean&gt;元素提供了一个指定自动装配类型的属性：autowire=&quot;&amp;lt;自动装配类型&amp;gt;&quot;&lt;/bean&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;Spring提供了哪几种自动装配类型？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring提供了4种自动装配类型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5915750915750916&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsoLM6zGTOj5Uk0bpEuSL7F6JGbxPxibnBkK8Zs8nIBeGDgAXwiaZNlNYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1092&quot;/&gt;&lt;figcaption&gt;Spring四种自动装配类型&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;byName&lt;/strong&gt;：根据名称进行自动匹配，假设Boss又一个名为car的属性，如果容器中刚好有一个名为car的bean，Spring就会自动将其装配给Boss的car属性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;byType&lt;/strong&gt;：根据类型进行自动匹配，假设Boss有一个Car类型的属性，如果容器中刚好有一个Car类型的Bean，Spring就会自动将其装配给Boss这个属性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;constructor&lt;/strong&gt;：与 byType类似， 只不过它是针对构造函数注入而言的。如果Boss有一个构造函数，构造函数包含一个Car类型的入参，如果容器中有一个Car类型的Bean，则Spring将自动把这个Bean作为Boss构造函数的入参；如果容器中没有找到和构造函数入参匹配类型的Bean，则Spring将抛出异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;autodetect&lt;/strong&gt;：根据Bean的自省机制决定采用byType还是constructor进行自动装配，如果Bean提供了默认的构造函数，则采用byType，否则采用constructor。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.Spring 中的 Bean 的作用域有哪些?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring的Bean主要支持五种作用域：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6557161629434954&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsu25uo4JtZQjxSlskGibYMCVDicK83RZeDvUxDZUXs5uCoYaOPEIdc2Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;761&quot;/&gt;&lt;figcaption&gt;Spring Bean支持作用域&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;singleton&lt;/strong&gt; : 在Spring容器仅存在一个Bean实例，Bean以单实例的方式存在，是Bean默认的作用域。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;prototype&lt;/strong&gt; : 每次从容器重调用Bean时，都会返回一个新的实例。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下三个作用域于只在Web应用中适用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;request&lt;/strong&gt; : 每一次HTTP请求都会产生一个新的Bean，该Bean仅在当前HTTP Request内有效。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;session&lt;/strong&gt; : 同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;globalSession&lt;/strong&gt;：同一个全局Session共享一个Bean，只用于基于Protlet的Web应用，Spring5中已经不存在了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.Spring 中的单例 Bean 会存在线程安全问题吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先结论在这：Spring中的单例Bean&lt;strong&gt;不是线程安全的&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为单例Bean，是全局只有一个Bean，所有线程共享。如果说单例Bean，是一个无状态的，也就是线程中的操作不会对Bean中的成员变量执行&lt;strong&gt;查询&lt;/strong&gt;以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如这个Bean是有状态的，也就是会对Bean中的成员变量进行写操作，那么可能就存在线程安全的问题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6637010676156584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsBvXcYShOmyiau3y6LQ1tMfichrhmck0cUT9ribicr0wOaw9liaTS97qRbqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;562&quot;/&gt;&lt;figcaption&gt;Spring单例Bean线程安全问题&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;单例Bean线程安全问题怎么解决呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的有这么些解决办法：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将Bean定义为多例&lt;/p&gt;&lt;p&gt;这样每一个线程请求过来都会创建一个新的Bean，但是这样容器就不好管理Bean，不能这么办。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在Bean对象中尽量避免定义可变的成员变量&lt;/p&gt;&lt;p&gt;削足适履了属于是，也不能这么干。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将Bean中的成员变量保存在ThreadLocal中⭐&lt;/p&gt;&lt;p&gt;我们知道ThredLoca能保证多线程下变量的隔离，可以在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal里，这是推荐的一种方式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15.说说循环依赖?&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是循环依赖？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0250737463126844&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsK5L2JNYzPmtic5EVZtUiajj081NGMWyNtOBrFvno7dLEibXtJQFgudeaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;678&quot;/&gt;&lt;figcaption&gt;Spring循环依赖&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 循环依赖：简单说就是自己依赖自己，或者和别的Bean相互依赖。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34321223709369025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsNDia2b8xiajZiaiaEFJqgCvMoxnT9RyImkGialNw55ucw5bnCKddNFBhbTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;figcaption&gt;鸡和蛋&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有单例的Bean才存在循环依赖的情况，&lt;strong&gt;原型&lt;/strong&gt;(Prototype)情况下，Spring会直接抛出异常。原因很简单，AB循环依赖，A实例化的时候，发现依赖B，创建B实例，创建B的时候发现需要A，创建A1实例……无限套娃，直接把系统干垮。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;Spring可以解决哪些情况的循环依赖？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring不支持基于构造器注入的循环依赖，但是假如AB循环依赖，如果一个是构造器注入，一个是setter注入呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看几种情形：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5976878612716763&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfshvcI9vicaoPdDZurSwlhec94y5eE8Ide192baOE1oZXDBzb7fyXYgjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;figcaption&gt;循环依赖的几种情形&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第四种可以而第五种不可以的原因是 Spring 在创建 Bean 时默认会根据自然排序进行创建，所以 A 会先于 B 进行创建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以简单总结，当循环依赖的实例都采用setter方法注入的时候，Spring可以支持，都采用构造器注入的时候，不支持，构造器注入和setter注入同时存在的时候，看天。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16.那Spring怎么解决循环依赖的呢？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;PS：其实正确答案是开发人员做好设计，别让Bean循环依赖，但是没办法，面试官不想听这个。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，单例Bean初始化完成，要经历三步：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36396396396396397&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsE8ibXU3hUFXJ9gsRXRqpIyiaOrP52kSYmI4iaAIUpepRqpQGaMRiciczia9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;555&quot;/&gt;&lt;figcaption&gt;Bean初始化步骤&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注入就发生在第二步，&lt;strong&gt;属性赋值&lt;/strong&gt;，结合这个过程，Spring 通过&lt;strong&gt;三级缓存&lt;/strong&gt;解决了循环依赖：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一级缓存 : Map&amp;lt;String,Object&amp;gt; &lt;strong&gt;singletonObjects&lt;/strong&gt;，单例池，用于保存实例化、属性赋值（注入）、初始化完成的 bean 实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;二级缓存 : Map&amp;lt;String,Object&amp;gt; &lt;strong&gt;earlySingletonObjects&lt;/strong&gt;，早期曝光对象，用于保存实例化完成的 bean 实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;三级缓存 : Map&amp;lt;String,ObjectFactory&amp;lt;?&amp;gt;&amp;gt; &lt;strong&gt;singletonFactories&lt;/strong&gt;，早期曝光对象工厂，用于保存 bean 创建工厂，以便于后面扩展有机会创建代理对象。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35868625756266204&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsm8aj6AGPTmicoPADSyviaicaqokJbpiauEQCIfic9DlsCNiaTWChY8YlOMXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1157&quot;/&gt;&lt;figcaption&gt;三级缓存&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下三级缓存解决循环依赖的过程：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 A、B 两个类发生循环依赖时：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5218390804597701&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsasplZicQAgicW5mWwKoULYhfVt7hzBIL72ZfBAzcqW6vDGggtRC4oibCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;435&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A实例的初始化过程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建A实例，实例化的时候把A对象⼯⼚放⼊三级缓存，表示A开始实例化了，虽然我这个对象还不完整，但是先曝光出来让大家知道&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46645367412140576&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs1PISSzSmpHnibCN8qgl6DVkZp3PYAE6C8hrYdJADAXfO7ID2ceWvaiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;939&quot;/&gt;&lt;figcaption&gt;1&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;A注⼊属性时，发现依赖B，此时B还没有被创建出来，所以去实例化B&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;同样，B注⼊属性时发现依赖A，它就会从缓存里找A对象。依次从⼀级到三级缓存查询A，从三级缓存通过对象⼯⼚拿到A，发现A虽然不太完善，但是存在，把A放⼊⼆级缓存，同时删除三级缓存中的A，此时，B已经实例化并且初始化完成，把B放入⼀级缓存。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48004561003420754&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsbFuVs73DZPywohpmPfpiaxavdqE4uW1bs6MD5Pn9EXzibdF1JBKG6wiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;figcaption&gt;2&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接着A继续属性赋值，顺利从⼀级缓存拿到实例化且初始化完成的B对象，A对象创建也完成，删除⼆级缓存中的A，同时把A放⼊⼀级缓存&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最后，⼀级缓存中保存着实例化、初始化都完成的A、B对象&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5777233782129743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs2OuRLxRJvRTibiaWpNdrxWdhQ6J0hmDFzVRqDwNAIP2s6ZKTSLZcz3xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;817&quot;/&gt;&lt;figcaption&gt;5&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们就知道为什么Spring能解决setter注入的循环依赖了，因为实例化和属性赋值是分开的，所以里面有操作的空间。如果都是构造器注入的化，那么都得在实例化这一步完成注入，所以自然是无法支持了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17.为什么要三级缓存？⼆级不⾏吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不行，主要是为了&lt;strong&gt;⽣成代理对象&lt;/strong&gt;。如果是没有代理的情况下，使用二级缓存解决循环依赖也是OK的。但是如果存在代理，三级没有问题，二级就不行了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为三级缓存中放的是⽣成具体对象的匿名内部类，获取Object的时候，它可以⽣成代理对象，也可以返回普通对象。使⽤三级缓存主要是为了保证不管什么时候使⽤的都是⼀个对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设只有⼆级缓存的情况，往⼆级缓存中放的显示⼀个普通的Bean对象，Bean初始化过程中，通过 BeanPostProcessor 去⽣成代理对象之后，覆盖掉⼆级缓存中的普通Bean对象，那么可能就导致取到的Bean对象不一致了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1278493557978196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs6OroRfH6jrJQbm0DT3QibXQ1Fhb4WWcqbKNSUztet3YnetCHJglwglw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1009&quot;/&gt;&lt;figcaption&gt;二级缓存不行的原因&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.@Autowired的实现原理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现@Autowired的关键是：&lt;strong&gt;AutowiredAnnotationBeanPostProcessor&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Bean的初始化阶段，会通过Bean后置处理器来进行一些前置和后置的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现@Autowired的功能，也是通过后置处理器来完成的。这个后置处理器就是AutowiredAnnotationBeanPostProcessor。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Spring在创建bean的过程中，最终会调用到doCreateBean()方法，在doCreateBean()方法中会调用populateBean()方法，来为bean进行属性填充，完成自动装配等工作。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在populateBean()方法中一共调用了两次后置处理器，第一次是为了判断是否需要属性填充，如果不需要进行属性填充，那么就会直接进行return，如果需要进行属性填充，那么方法就会继续向下执行，后面会进行第二次后置处理器的调用，这个时候，就会调用到AutowiredAnnotationBeanPostProcessor的postProcessPropertyValues()方法，在该方法中就会进行@Autowired注解的解析，然后实现自动装配。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt;* 属性赋值&lt;br/&gt;**/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;populateBean&lt;/span&gt;&lt;span&gt;(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;//………… &lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (hasInstAwareBpps) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (pvs == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    pvs = mbd.getPropertyValues();&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                PropertyValues pvsToUse;&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt;(Iterator var9 = &lt;span&gt;this&lt;/span&gt;.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {&lt;br/&gt;                    InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();&lt;br/&gt;                    pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (pvsToUse == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (filteredPds == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                            filteredPds = &lt;span&gt;this&lt;/span&gt;.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;//执行后处理器，填充属性，完成自动装配&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;//调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法&lt;/span&gt;&lt;br/&gt;                        pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (pvsToUse == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;           &lt;span&gt;//…………&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;postProcessorPropertyValues()方法的源码如下，在该方法中，会先调用findAutowiringMetadata()方法解析出bean中带有@Autowired注解、@Inject和@Value注解的属性和方法。然后调用metadata.inject()方法，进行属性填充。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; PropertyValues &lt;span&gt;postProcessProperties&lt;/span&gt;&lt;span&gt;(PropertyValues pvs, Object bean, String beanName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//@Autowired注解、@Inject和@Value注解的属性和方法&lt;/span&gt;&lt;br/&gt;        InjectionMetadata metadata = &lt;span&gt;this&lt;/span&gt;.findAutowiringMetadata(beanName, bean.getClass(), pvs);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//属性填充&lt;/span&gt;&lt;br/&gt;            metadata.inject(bean, beanName, pvs);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; pvs;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (BeanCreationException var6) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; var6;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable var7) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BeanCreationException(beanName, &lt;span&gt;&quot;Injection of autowired dependencies failed&quot;&lt;/span&gt;, var7);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;AOP&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19.说说什么是AOP？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AOP：面向切面编程。简单说，就是把一些业务逻辑中的相同的代码抽取到一个独立的模块中，让业务逻辑更加清爽。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6296296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsuXjJCWZhjSuG0T8NN57gMQK9wZNWJu8hn99OGDla9YM0rro59bjqKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;729&quot;/&gt;&lt;figcaption&gt;横向抽取&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体来说，假如我现在要crud写一堆业务，可是如何业务代码前后前后进行打印日志和参数的校验呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以把&lt;code&gt;日志记录&lt;/code&gt;和&lt;code&gt;数据校验&lt;/code&gt;可重用的功能模块分离出来，然后在程序的执行的合适的地方动态地植入这些代码并执行。这样就简化了代码的书写。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0784313725490196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfswgehrFlAZc0PnBwa0HPL0GXgu04vXhlSebBEwWrkaGSn9Dlich0w8PA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;306&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;figcaption&gt;AOP应用示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务逻辑代码中没有参和通用逻辑的代码，业务模块更简洁，只包含核心业务代码。实现了业务逻辑和通用逻辑的代码分离，便于维护和升级，降低了业务逻辑和通用逻辑的耦合性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AOP 可以将遍布应用各处的功能分离出来形成可重用的组件。在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能。从而实现对业务逻辑的隔离，提高代码的模块化能力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.428380187416332&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsnQJH3O4yWX5NPJxMerqL1JvKcgJblkqyyw3KZCyuhW4QIgS5rPkIbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;747&quot;/&gt;&lt;figcaption&gt;Java语言执行过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AOP 的核心其实就是&lt;strong&gt;动态代理&lt;/strong&gt;，如果是实现了接口的话就会使用 JDK 动态代理，否则使用 CGLIB 代理，主要应用于处理一些具有横切性质的系统级服务，如日志收集、事务管理、安全检查、缓存、对象池管理等。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;AOP有哪些核心概念？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;切面&lt;/strong&gt;（Aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;连接点&lt;/strong&gt;（Joinpoint）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;切点&lt;/strong&gt;（Pointcut）：对连接点进行拦截的定位&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;通知&lt;/strong&gt;（Advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，也可以称作&lt;strong&gt;增强&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;目标对象&lt;/strong&gt; （Target）：代理的目标对象&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;织入&lt;/strong&gt;（Weabing）：织入是将增强添加到目标类的具体连接点上的过程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;编译期织入：切面在目标类编译时被织入&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;类加载期织入：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;运行期织入：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。&lt;/p&gt;&lt;p&gt;Spring采用运行期织入，而AspectJ采用编译期织入和类加载器织入。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;引介&lt;/strong&gt;（introduction）：引介是一种特殊的增强，可以动态地为类添加一些属性和方法&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;AOP有哪些环绕方式？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AOP 一般有 &lt;strong&gt;5 种&lt;/strong&gt;环绕方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;前置通知 (@Before)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回通知 (@AfterReturning)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异常通知 (@AfterThrowing)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后置通知 (@After)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环绕通知 (@Around)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5792276964047937&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs1QW9rzicPN5sXG0fC330NYBtPIGkIwrRUEO5PTQ3o4IOb7zV1pSmR2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;751&quot;/&gt;&lt;figcaption&gt;环绕方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多个切面的情况下，可以通过 @Order 指定先后顺序，数字越小，优先级越高。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20.说说你平时有用到AOP吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS：这道题老三的同事面试候选人的时候问到了，候选人说了一堆AOP原理，同事就势来一句，你能现场写一下AOP的应用吗？结果——场面一度很尴尬。虽然我对面试写这种百度就能出来的东西持保留意见，但是还是加上了这一问，毕竟招人最后都是要撸代码的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里给出一个小例子，SpringBoot项目中，利用AOP打印接口的入参和出参日志，以及执行时间，还是比较快捷的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;引入依赖：引入AOP依赖&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;自定义注解：自定义一个注解作为切点&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span&gt;@Target&lt;/span&gt;({ElementType.METHOD})&lt;br/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; WebLog {&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;配置AOP切面：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Aspect&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebLogAspect&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger         = LoggerFactory.getLogger(WebLogAspect&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 以自定义 &lt;span&gt;@WebLog&lt;/span&gt; 注解为切点&lt;br/&gt;     **/&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Pointcut&lt;/span&gt;(&lt;span&gt;&quot;@annotation(cn.fighter3.spring.aop_demo.WebLog)&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;webLog&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 在切点之前织入&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Before&lt;/span&gt;(&lt;span&gt;&quot;webLog()&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doBefore&lt;/span&gt;&lt;span&gt;(JoinPoint joinPoint)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 开始打印请求日志&lt;/span&gt;&lt;br/&gt;        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();&lt;br/&gt;        HttpServletRequest request = attributes.getRequest();&lt;br/&gt;        &lt;span&gt;// 打印请求相关参数&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;========================================== Start ==========================================&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 打印请求 url&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;URL            : {}&quot;&lt;/span&gt;, request.getRequestURL().toString());&lt;br/&gt;        &lt;span&gt;// 打印 Http method&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;HTTP Method    : {}&quot;&lt;/span&gt;, request.getMethod());&lt;br/&gt;        &lt;span&gt;// 打印调用 controller 的全路径以及执行方法&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;Class Method   : {}.{}&quot;&lt;/span&gt;, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());&lt;br/&gt;        &lt;span&gt;// 打印请求的 IP&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;IP             : {}&quot;&lt;/span&gt;, request.getRemoteAddr());&lt;br/&gt;        &lt;span&gt;// 打印请求入参&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;Request Args   : {}&quot;&lt;/span&gt;,&lt;span&gt;new&lt;/span&gt; ObjectMapper().writeValueAsString(joinPoint.getArgs()));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 在切点之后织入&lt;br/&gt;     * &lt;span&gt;@throws&lt;/span&gt; Throwable&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@After&lt;/span&gt;(&lt;span&gt;&quot;webLog()&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doAfter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 结束后打个分隔线，方便查看&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;=========================================== End ===========================================&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 环绕&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Around&lt;/span&gt;(&lt;span&gt;&quot;webLog()&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;doAround&lt;/span&gt;&lt;span&gt;(ProceedingJoinPoint proceedingJoinPoint)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//开始时间&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; startTime = System.currentTimeMillis();&lt;br/&gt;        Object result = proceedingJoinPoint.proceed();&lt;br/&gt;        &lt;span&gt;// 打印出参&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;Response Args  : {}&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; ObjectMapper().writeValueAsString(result));&lt;br/&gt;        &lt;span&gt;// 执行耗时&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;Time-Consuming : {} ms&quot;&lt;/span&gt;, System.currentTimeMillis() - startTime);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Aspect：标识切面&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Pointcut：设置切点，这里以自定义注解为切点，定义切点有很多其它种方式，自定义注解是比较常用的一种。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Before：在切点之前织入，打印了一些入参信息&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Around：环绕切点，打印返回参数和接口执行时间&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用：只需要在接口上加上自定义注解&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/hello&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@WebLog&lt;/span&gt;(desc = &lt;span&gt;&quot;这是一个欢迎接口&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;hello&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Hello &quot;&lt;/span&gt;+name;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;执行结果：可以看到日志打印了入参、出参和执行时间&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14179531160663236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsMHlOHRoXTH5tpLr8v26ESgaLvkKQT6W7oInMOaicLvhqwTtulYsnVeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1749&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;21.说说JDK 动态代理和 CGLIB 代理 ？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring的AOP是通过&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247490507&amp;amp;idx=1&amp;amp;sn=003af1086e53877662621632fa96284d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;动态代理&lt;/a&gt;来实现的，动态代理主要有两种方式JDK动态代理和Cglib动态代理，这两种动态代理的使用和原理有些不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JDK 动态代理&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Interface&lt;/strong&gt;：对于 JDK 动态代理，目标类需要实现一个Interface。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;InvocationHandler&lt;/strong&gt;：InvocationHandler是一个接口，可以通过实现这个接口，定义横切逻辑，再通过反射机制（invoke）调用目标类的代码，在次过程，可能包装逻辑，对目标方法进行前置后置处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Proxy&lt;/strong&gt;：Proxy利用InvocationHandler动态创建一个符合目标类实现的接口的实例，生成目标类的代理对象。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CgLib 动态代理&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用JDK创建代理有一大限制，它只能为接口创建代理实例，而CgLib 动态代理就没有这个限制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CgLib 动态代理是使用字节码处理框架 &lt;strong&gt;ASM&lt;/strong&gt;，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CgLib&lt;/strong&gt; 创建的动态代理对象性能比 JDK 创建的动态代理对象的性能高不少，但是 CGLib 在创建代理对象时所花费的时间却比 JDK 多得多，所以对于单例的对象，因为无需频繁创建对象，用 CGLib 合适，反之，使用 JDK 方式要更为合适一些。同时，由于 CGLib 由于是采用动态创建子类的方法，对于 final 方法，无法进行代理。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一个常见的小场景，客服中转，解决用户问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5535483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsf9pf7w7ba4tibU3EL9uxDNMo31l4XIZKWPJmbvoLiaZvs1Id1ZXY1ibpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1550&quot;/&gt;&lt;figcaption&gt;用户向客服提问题&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JDK动态代理实现：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5364120781527532&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs2YicZZHAib5bxa0no2WlC6EDkNm98Pz6cjsZ386p6b0gyBxmk8kj0HIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot;/&gt;&lt;figcaption&gt;JDK动态代理类图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接口&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ISolver&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;solve&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;目标类:需要实现对应接口&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solver&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ISolver&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;solve&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;疯狂掉头发解决问题……&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;态代理工厂:ProxyFactory，直接用反射方式生成一个目标对象的代理对象，这里用了一个匿名内部类方式重写InvocationHandler方法，实现接口重写也差不多&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ProxyFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 维护一个目标对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Object target;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ProxyFactory&lt;/span&gt;&lt;span&gt;(Object target)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.target = target;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 为目标对象生成代理对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getProxyInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; InvocationHandler() {&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;invoke&lt;/span&gt;&lt;span&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;请问有什么可以帮到您？&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;                        &lt;span&gt;// 调用目标对象方法&lt;/span&gt;&lt;br/&gt;                        Object returnValue = method.invoke(target, args);&lt;br/&gt;&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;问题已经解决啦！&quot;&lt;/span&gt;);&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端：Client，生成一个代理对象实例，通过代理对象调用目标对象方法&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Client&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//目标对象:程序员&lt;/span&gt;&lt;br/&gt;        ISolver developer = &lt;span&gt;new&lt;/span&gt; Solver();&lt;br/&gt;        &lt;span&gt;//代理：客服小姐姐&lt;/span&gt;&lt;br/&gt;        ISolver csProxy = (ISolver) &lt;span&gt;new&lt;/span&gt; ProxyFactory(developer).getProxyInstance();&lt;br/&gt;        &lt;span&gt;//目标方法：解决问题&lt;/span&gt;&lt;br/&gt;        csProxy.solve();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Cglib动态代理实现：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4627659574468085&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsAQpUo83WicZaIuiaS5DK0cIqdia0W834EtjHAxLnSw2m2TS2Kz5FsCUibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1128&quot;/&gt;&lt;figcaption&gt;Cglib动态代理类图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;目标类：Solver，这里目标类不用再实现接口。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solver&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;solve&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;疯狂掉头发解决问题……&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;动态代理工厂：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ProxyFactory&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;MethodInterceptor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//维护一个目标对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Object target;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ProxyFactory&lt;/span&gt;&lt;span&gt;(Object target)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.target = target;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//为目标对象生成代理对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getProxyInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//工具类&lt;/span&gt;&lt;br/&gt;        Enhancer en = &lt;span&gt;new&lt;/span&gt; Enhancer();&lt;br/&gt;        &lt;span&gt;//设置父类&lt;/span&gt;&lt;br/&gt;        en.setSuperclass(target.getClass());&lt;br/&gt;        &lt;span&gt;//设置回调函数&lt;/span&gt;&lt;br/&gt;        en.setCallback(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//创建子类对象代理&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; en.create();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;intercept&lt;/span&gt;&lt;span&gt;(Object obj, Method method, Object[] args, MethodProxy proxy)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;请问有什么可以帮到您？&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 执行目标对象的方法&lt;/span&gt;&lt;br/&gt;        Object returnValue = method.invoke(target, args);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;问题已经解决啦！&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端：Client&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Client&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//目标对象:程序员&lt;/span&gt;&lt;br/&gt;        Solver developer = &lt;span&gt;new&lt;/span&gt; Solver();&lt;br/&gt;        &lt;span&gt;//代理：客服小姐姐&lt;/span&gt;&lt;br/&gt;        Solver csProxy = (Solver) &lt;span&gt;new&lt;/span&gt; ProxyFactory(developer).getProxyInstance();&lt;br/&gt;        &lt;span&gt;//目标方法：解决问题&lt;/span&gt;&lt;br/&gt;        csProxy.solve();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;22.说说Spring AOP 和 AspectJ AOP 区别?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Spring AOP&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring AOP 属于&lt;code&gt;运行时增强&lt;/code&gt;，主要具有如下特点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;基于动态代理来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Spring AOP 需要依赖 IOC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在性能上，由于 Spring AOP 是基于&lt;strong&gt;动态代理&lt;/strong&gt;来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AspectJ&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AspectJ 是一个易用的功能强大的 AOP 框架，属于&lt;code&gt;编译时增强&lt;/code&gt;，  可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AspectJ 属于&lt;strong&gt;静态织入&lt;/strong&gt;，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体对比如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6075268817204301&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsNCb3fIk5JLLrJmKSk2etMg9lnMyCicDMgBaviaxddNrcFURQ27zYmCiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;930&quot;/&gt;&lt;figcaption&gt;Spring AOP和AspectJ对比&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;事务&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。Spring 只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过数据库自己的事务机制实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;23.Spring 事务的种类？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 支持&lt;code&gt;编程式事务&lt;/code&gt;管理和&lt;code&gt;声明式&lt;/code&gt;事务管理两种方式：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4038800705467372&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs6L8669GNxSicicfyZdNKdywT4Pf1EfNmWgva9OY0TPj8Cz8iaVkzibGROA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;567&quot;/&gt;&lt;figcaption&gt;Spring事务分类&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;编程式事务&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编程式事务管理使用 TransactionTemplate，需要显式执行事务。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;声明式事务&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;声明式事务管理建立在 AOP 之上的。其本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过 @Transactional 注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;24.Spring 的事务隔离级别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring的接口TransactionDefinition中定义了表示隔离级别的常量，当然其实主要还是对应数据库的事务隔离级别：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ISOLATION_DEFAULT：使用后端数据库默认的隔离界别，MySQL 默认可重复读，Oracle 默认读已提交。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ISOLATION_READ_UNCOMMITTED：读未提交&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ISOLATION_READ_COMMITTED：读已提交&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ISOLATION_REPEATABLE_READ：可重复读&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ISOLATION_SERIALIZABLE：串行化&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;25.Spring 的事务传播机制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 事务的传播机制说的是，当多个事务同时存在的时候——一般指的是多个事务方法相互调用时，Spring 如何处理这些事务的行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务传播机制是使用简单的 ThreadLocal 实现的，所以，如果调用的方法是在新线程调用的，事务传播实际上是会失效的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5790816326530612&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsqCWbHaxM0E8fLa9zvnOz9KN03C6v0s9X1LHwdx31V8G3vYMJxVIuyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1568&quot;/&gt;&lt;figcaption&gt;7种事务传播机制&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring默认的事务传播行为是PROPAFATION_REQUIRED，它适合绝大多数情况，如果多个ServiceX#methodX()都工作在事务环境下（均被Spring事务增强），且程序中存在调用链Service1#method1()-&amp;gt;Service2#method2()-&amp;gt;Service3#method3()，那么这3个服务类的三个方法通过Spring的事务传播机制都工作在同一个事务中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;26.声明式事务实现原理了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是通过AOP/动态代理。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;在Bean初始化阶段创建代理对象&lt;/strong&gt;：Spring容器在初始化每个单例bean的时候，会遍历容器中的所有BeanPostProcessor实现类，并执行其postProcessAfterInitialization方法，在执行AbstractAutoProxyCreator类的postProcessAfterInitialization方法时会遍历容器中所有的切面，查找与当前实例化bean匹配的切面，这里会获取事务属性切面，查找@Transactional注解及其属性值，然后根据得到的切面创建一个代理对象，默认是使用JDK动态代理创建代理，如果目标类是接口，则使用JDK动态代理，否则使用Cglib。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;在执行目标方法时进行事务增强操作&lt;/strong&gt;：当通过代理对象调用Bean方法的时候，会触发对应的AOP增强拦截器，声明式事务是一种环绕增强，对应接口为&lt;code&gt;MethodInterceptor&lt;/code&gt;，事务增强对该接口的实现为&lt;code&gt;TransactionInterceptor&lt;/code&gt;，类图如下：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39305555555555555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsDjQ6ufM87pfa1Hq5zXh9Qj6WdjEBvaz2hdDO2VkD1rXf5ib0LDAIn8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;figcaption&gt;图片来源网易技术专栏&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;事务拦截器&lt;code&gt;TransactionInterceptor&lt;/code&gt;在&lt;code&gt;invoke&lt;/code&gt;方法中，通过调用父类&lt;code&gt;TransactionAspectSupport&lt;/code&gt;的&lt;code&gt;invokeWithinTransaction&lt;/code&gt;方法进行事务处理，包括开启事务、事务提交、异常回滚。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;27.声明式事务在哪些情况下会失效？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47074122236671&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsVz3mFErqqibicgIH8liaMuTiaSO9EDBGbMYRsiahoPOk2JJvF7GQRicThpGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;769&quot;/&gt;&lt;figcaption&gt;声明式事务的几种失效的情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、@Transactional 应用在非 public 修饰的方法上&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果Transactional注解应用在非 public 修饰的方法上，Transactional将会失效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是因为在Spring AOP 代理时，TransactionInterceptor  （事务拦截器）在目标方法执行前后进行拦截，DynamicAdvisedInterceptor（CglibAopProxy  的内部类）的intercept方法 或  JdkDynamicAopProxy的invoke方法会间接调用AbstractFallbackTransactionAttributeSource的 &lt;strong&gt;computeTransactionAttribute&lt;/strong&gt;方法，获取Transactional 注解的事务配置信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; TransactionAttribute &lt;span&gt;computeTransactionAttribute&lt;/span&gt;&lt;span&gt;(Method method,&lt;br/&gt;    Class&amp;lt;?&amp;gt; targetClass)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// Don&#x27;t allow no-public methods as required.&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (allowPublicMethodsOnly() &amp;amp;&amp;amp; !Modifier.isPublic(method.getModifiers())) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、@Transactional 注解属性 propagation 设置错误&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3、@Transactional 注解属性 rollbackFor 设置错误&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rollbackFor 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查unchecked异常（继承自 RuntimeException的异常）或者 Error才回滚事务，其他异常不会触发回滚事务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5563549160671463&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs8WQBqZdLzCT7LZZjHuTDNKvll9oRqAubpjqd5cwY3fp6Hk1BxZibg0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1251&quot;/&gt;&lt;figcaption&gt;Spring默认支持的异常回滚&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 希望自定义的异常可以进行回滚&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Transactional&lt;/span&gt;(propagation= Propagation.REQUIRED,rollbackFor= MyException&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4、同一个类中方法调用，导致@Transactional失效&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为啥会出现这种情况？其实这还是由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;//@Transactional&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;&lt;span&gt;private&lt;/span&gt; Integer &lt;span&gt;A&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;         CityInfoDict cityInfoDict = &lt;span&gt;new&lt;/span&gt; CityInfoDict();&lt;br/&gt;         cityInfoDict.setCityName(&lt;span&gt;&quot;2&quot;&lt;/span&gt;);&lt;br/&gt;         &lt;span&gt;/**&lt;br/&gt;          * B 插入字段为 3的数据&lt;br/&gt;          */&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;this&lt;/span&gt;.insertB();&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * A 插入字段为 2的数据&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; insert = cityInfoDictMapper.insert(cityInfoDict);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; insert;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;()&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;insertB&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        CityInfoDict cityInfoDict = &lt;span&gt;new&lt;/span&gt; CityInfoDict();&lt;br/&gt;        cityInfoDict.setCityName(&lt;span&gt;&quot;3&quot;&lt;/span&gt;);&lt;br/&gt;        cityInfoDict.setParentCityId(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; cityInfoDictMapper.insert(cityInfoDict);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况是最常见的一种@Transactional注解失效场景&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Integer &lt;span&gt;A&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; insert = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        CityInfoDict cityInfoDict = &lt;span&gt;new&lt;/span&gt; CityInfoDict();&lt;br/&gt;        cityInfoDict.setCityName(&lt;span&gt;&quot;2&quot;&lt;/span&gt;);&lt;br/&gt;        cityInfoDict.setParentCityId(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * A 插入字段为 2的数据&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        insert = cityInfoDictMapper.insert(cityInfoDict);&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * B 插入字段为 3的数据&lt;br/&gt;        */&lt;/span&gt;&lt;br/&gt;        b.insertB();&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务就不能正常回滚了，会抛出异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MVC&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;28.Spring MVC 的核心组件？&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;DispatcherServlet&lt;/strong&gt;：前置控制器，是整个流程控制的&lt;strong&gt;核心&lt;/strong&gt;，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Handler&lt;/strong&gt;：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;HandlerMapping&lt;/strong&gt;：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;HandlerInterceptor&lt;/strong&gt;：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;HandlerExecutionChain&lt;/strong&gt;：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;HandlerAdapter&lt;/strong&gt;：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ModelAndView&lt;/strong&gt;：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ViewResolver&lt;/strong&gt;：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;29.Spring MVC 的工作流程？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5354545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsic3JSxb51bkchaNiadMkibxxyfPF36JmiavzlLAWVA8PRIjYsZ0vwy9DHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1100&quot;/&gt;&lt;figcaption&gt;Spring MVC的工作流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DispatcherServlet将模型数据填充到视图中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DispatcherServlet将结果响应给客户端&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Spring MVC&lt;/strong&gt; 虽然整体流程复杂，但是实际开发中很简单，大部分的组件不需要开发人员创建和管理，只需要通过配置文件的方式完成配置即可，真正需要开发人员进行处理的只有 &lt;strong&gt;Handler（Controller）&lt;/strong&gt; 、&lt;strong&gt;View&lt;/strong&gt; 、&lt;strong&gt;Model&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然我们现在大部分的开发都是前后端分离，Restful风格接口，后端只需要返回Json数据就行了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;30.SpringMVC Restful风格的接口的流程是什么样的呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:这是一道全新的八股，毕竟ModelAndView这种方式应该没人用了吧？现在都是前后端分离接口，八股也该更新换代了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道Restful接口，响应格式是json，这就用到了一个常用注解：**@ResponseBody**&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/user&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@ResponseBody&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; User &lt;span&gt;user&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;张三&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加入了这个注解后，整体的流程上和使用ModelAndView大体上相同，但是细节上有一些不同：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.418796992481203&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsHssxjGNp9S8WFjHnIU93OSL9JK4rvbIS718UtBz3B1BOZ6xriamz8ug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3990&quot;/&gt;&lt;figcaption&gt;Spring MVC Restful请求响应示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Controller被封装成了ServletInvocableHandlerMethod，HandlerAdapter处理器适配器去执行invokeAndHandle方法，完成对Controller的请求处理&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;HandlerAdapter执行完对Controller的请求，会调用HandlerMethodReturnValueHandler去处理返回值，主要的过程：&lt;/p&gt;&lt;p&gt;5.1. 调用RequestResponseBodyMethodProcessor，创建ServletServerHttpResponse（Spring对原生ServerHttpResponse的封装）实例&lt;/p&gt;&lt;p&gt;5.2.使用HttpMessageConverter的write方法，将返回值写入ServletServerHttpResponse的OutputStream输出流中&lt;/p&gt;&lt;p&gt;5.3.在写入的过程中，会使用JsonGenerator（默认使用Jackson框架）对返回值进行Json序列化&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;执行完请求后，返回的ModealAndView为null，ServletServerHttpResponse里也已经写入了响应，所以不用关心View的处理&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring Boot&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;31.介绍一下SpringBoot，有哪些优点？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring  框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfswYric8SicA4DiaUJz68glEwKeokMLia61w50kjkeQ9B8ia04OvjYwKoBU7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;280&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;figcaption&gt;SpringBoot图标&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Boot 以&lt;code&gt;约定大于配置&lt;/code&gt;核心思想开展工作，相比Spring具有如下优势：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Spring Boot 可以快速创建独立的Spring应用程序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Boot 内嵌了如Tomcat，Jetty和Undertow这样的容器，也就是说可以直接跑起来，用不着再做部署工作了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Boot 无需再像Spring一样使用一堆繁琐的xml文件配置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Boot  可以自动配置(核心)Spring。SpringBoot将原有的XML配置改为Java配置，将bean注入改为使用注解注入的方式(@Autowire)，并将多个xml、properties配置浓缩在一个appliaction.yml配置文件中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Boot 提供了一些现有的功能，如量度工具，表单数据验证以及一些外部配置这样的一些第三方功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Boot 可以快速整合常用依赖（开发库，例如spring-webmvc、jackson-json、validation-api和tomcat等），提供的POM可以简化Maven的配置。当我们引入核心依赖时，SpringBoot会自引入其他依赖。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;32.SpringBoot自动配置原理了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringBoot开启自动配置的注解是&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; ，启动类上的注解&lt;code&gt;@SpringBootApplication&lt;/code&gt;是一个复合注解，包含了@EnableAutoConfiguration：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33617021276595743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsuUuQoo5yqy1bv1ojgBJxNQcLIDsickCf53rZCibbNFibgUcQOmcX2UWxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1175&quot;/&gt;&lt;figcaption&gt;SpringBoot自动配置原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;EnableAutoConfiguration&lt;/code&gt; 只是一个简单的注解，自动装配核心功能的实现实际是通过 &lt;code&gt;AutoConfigurationImportSelector&lt;/code&gt;类&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@AutoConfigurationPackage&lt;/span&gt; &lt;span&gt;//将main同级的包下的所有组件注册到容器中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;({AutoConfigurationImportSelector&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;}) //加载自动装配类 &lt;span&gt;xxxAutoconfiguration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;EnableAutoConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String ENABLED_OVERRIDE_PROPERTY = &lt;span&gt;&quot;spring.boot.enableautoconfiguration&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    Class&amp;lt;?&amp;gt;[] exclude() &lt;span&gt;default&lt;/span&gt; {};&lt;br/&gt;&lt;br/&gt;    String[] excludeName() &lt;span&gt;default&lt;/span&gt; {};&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;AutoConfigurationImportSelector&lt;/code&gt;实现了&lt;code&gt;ImportSelector&lt;/code&gt;接口，这个接口的作用就是收集需要导入的配置类，配合&lt;code&gt;@Import(）&lt;/code&gt;就可以将相应的类导入到Spring容器中&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;获取注入类的方法是selectImports()，它实际调用的是&lt;code&gt;getAutoConfigurationEntry&lt;/code&gt;，这个方法是获取自动装配类的关键，主要流程可以分为这么几步：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取注解的属性，用于后面的排除&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;获取所有需要自动装配的配置类的路径&lt;/strong&gt;：这一步是最关键的，从META-INF/spring.factories获取自动配置类的路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;去掉重复的配置类和需要排除的重复类，把需要自动加载的配置类的路径存储起来&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;protected&lt;/span&gt; AutoConfigurationImportSelector.&lt;span&gt;AutoConfigurationEntry &lt;span&gt;getAutoConfigurationEntry&lt;/span&gt;&lt;span&gt;(AnnotationMetadata annotationMetadata)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.isEnabled(annotationMetadata)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; EMPTY_ENTRY;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//1.获取到注解的属性&lt;/span&gt;&lt;br/&gt;            AnnotationAttributes attributes = &lt;span&gt;this&lt;/span&gt;.getAttributes(annotationMetadata);&lt;br/&gt;            &lt;span&gt;//2.获取需要自动装配的所有配置类，读取META-INF/spring.factories，获取自动配置类路径&lt;/span&gt;&lt;br/&gt;            List&amp;lt;String&amp;gt; configurations = &lt;span&gt;this&lt;/span&gt;.getCandidateConfigurations(annotationMetadata, attributes);&lt;br/&gt;            &lt;span&gt;//3.1.移除重复的配置&lt;/span&gt;&lt;br/&gt;            configurations = &lt;span&gt;this&lt;/span&gt;.removeDuplicates(configurations);&lt;br/&gt;            &lt;span&gt;//3.2.处理需要排除的配置&lt;/span&gt;&lt;br/&gt;            Set&amp;lt;String&amp;gt; exclusions = &lt;span&gt;this&lt;/span&gt;.getExclusions(annotationMetadata, attributes);&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.checkExcludedClasses(configurations, exclusions);&lt;br/&gt;            configurations.removeAll(exclusions);&lt;br/&gt;            configurations = &lt;span&gt;this&lt;/span&gt;.getConfigurationClassFilter().filter(configurations);&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.fireAutoConfigurationImportEvents(configurations, exclusions);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;33.如何自定义一个SpringBoot Srarter?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了自动配置原理，创建一个自定义SpringBoot Starter也很简单。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;创建一个项目，命名为demo-spring-boot-starter，引入SpringBoot相关依赖&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;spring-boot-configuration-processor&amp;lt;/artifactId&amp;gt;&lt;br/&gt;            &amp;lt;optional&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/optional&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;编写配置文件&lt;/p&gt;&lt;p&gt;这里定义了属性配置的前缀&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span&gt;&quot;hello&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HelloProperties&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//省略getter、setter&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;自动装配&lt;/p&gt;&lt;p&gt;创建自动配置类HelloPropertiesConfigure&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@EnableConfigurationProperties&lt;/span&gt;(HelloProperties&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;HelloPropertiesConfigure&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;配置自动类&lt;/p&gt;&lt;p&gt;在&lt;code&gt;/resources/META-INF/spring.factories&lt;/code&gt;文件中添加自动配置类路径&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=\&lt;br/&gt;  cn.fighter3.demo.starter.configure.HelloPropertiesConfigure&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;测试&lt;/p&gt;&lt;p&gt;至此，随手写的一个自定义SpringBoot-Starter就完成了，虽然比较简单，但是完成了主要的自动装配的能力。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建一个工程，引入自定义starter依赖&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;cn.fighter3&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;demo-spring-boot-starter&amp;lt;/artifactId&amp;gt;&lt;br/&gt;            &amp;lt;version&amp;gt;&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;-SNAPSHOT&amp;lt;/version&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在配置文件里添加配置&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;hello.name=张三&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;测试类&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RunWith&lt;/span&gt;(SpringRunner&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;SpringBootTest&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;HelloTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    HelloProperties helloProperties;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;hello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;你好，&quot;&lt;/span&gt;+helloProperties.getName());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;运行结果&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.36829268292682926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsf6A7jpicyw4CWg4mOwQb5WH0cdgN9SZ6PTF847MYEErIJZvKLwBqLOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;410&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;figcaption&gt;运行结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;34.Springboot 启动原理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringApplication 这个类主要做了以下四件事情：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;推断应用的类型是普通的项目还是 Web 项目&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;查找并加载所有可用初始化器 ， 设置到 initializers 属性中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找出所有的应用程序监听器，设置到 listeners 属性中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;推断并设置 main 方法的定义类，找到运行的主类&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringBoot 启动大致流程如下 ：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0148148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsf8eISEyE4LBTJnUIvMg6rrplw76QWZYlcgHMQbFpibAeCSfjCdP8zYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;SpringBoot 启动大致流程-图片来源网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring Cloud&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;35.对SpringCloud了解多少？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringCloud是Spring官方推出的微服务治理框架。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.55&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs5mloaNL0ZKOFuG0h7qV6tkmfT4ZCK5VE8QzVLAxczBvq2doXGvLn6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;Spring Cloud Netfilx核心组件-来源参考[2]&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是微服务？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;2014 年 &lt;strong&gt;Martin Fowler&lt;/strong&gt; 提出的一种新的架构形式。微服务架构是一种&lt;strong&gt;架构模式&lt;/strong&gt;，提倡将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制(如HTTP或Dubbo)互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具(如Maven)对其进行构建。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;微服务架构主要要解决哪些问题？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;服务很多，客户端怎么访问，如何提供对外网关?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这么多服务，服务之间如何通信? HTTP还是RPC?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这么多服务，如何治理? 服务的注册和发现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务挂了怎么办？熔断机制。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;有哪些主流微服务框架？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Spring Cloud Netflix&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Cloud Alibaba&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SpringBoot +  Dubbo  +  ZooKeeper&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;SpringCloud有哪些核心组件？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2132564841498559&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsseGgsbodK21icLPjC0XDm8GCP9VuVVYuQepLSbpvDib4JeCFKNsLtOpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2776&quot;/&gt;&lt;figcaption&gt;SpringCloud&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:微服务后面有机会再扩展，其实面试一般都是结合项目去问。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;big data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[1]. 《Spring揭秘》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[2]. 面试官：关于Spring就问这13个：https://mp.weixin.qq.com/s/-gLXHd_mylv_86sTMOgCBg&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[3]. 15个经典的Spring面试常见问题    ：https://mp.weixin.qq.com/s/OMlwHHnGcN7iZ8lerUvW7w&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[4].面试还不知道BeanFactory和ApplicationContext的区别？：https://juejin.cn/post/6844903877574131726&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[5]. Java面试中常问的Spring方面问题（涵盖七大方向共55道题，含答案：https://juejin.cn/post/6844903654659473416#heading-8&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[6] .Spring Bean 生命周期 （实例结合源码彻底讲透：https://segmentfault.com/a/1190000020747302&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[7]. @Autowired注解的实现原理 ：https://juejin.cn/post/6844903957135884295&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[8].万字长文，带你从源码认识Spring事务原理，让Spring事务不再是面试噩梦https://segmentfault.com/a/1190000022754620&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[9].【技术干货】Spring事务原理一探https://zhuanlan.zhihu.com/p/54067384&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[10]. Spring的声明式事务@Transactional注解的6种失效场景：https://blog.csdn.net/j1231230/article/details/105534599&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[11].Spring官网&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[12].Spring使用了哪些设计模式？：https://zhuanlan.zhihu.com/p/336671458&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[13].《精通Spring4.X企业应用开发实战》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;[14].Spring 中的bean 是线程安全的吗？：https://www.cnblogs.com/myseries/p/11729800.html&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span data-darkmode-bgcolor-16471809271751=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16471809271751=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16471809271751=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16471809271751=&quot;#fff|rgb(63, 63, 63)&quot; data-style=&quot;outline: 0px; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; color: rgb(63, 63, 63); background-color: rgb(255, 255, 255); letter-spacing: 0.408px; font-size: 15px;&quot; class=&quot;js_darkmode__1118&quot;&gt;建了一个技术交流群，金三银四，面试聊的飞起！更有几十本群聊专属计算机图书！添加微信&lt;/span&gt;&lt;span data-darkmode-bgcolor-16471809271751=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16471809271751=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16471809271751=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16471809271751=&quot;#fff|rgb(0, 128, 255)&quot; data-style=&quot;outline: 0px; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; font-size: 16px; background-color: rgb(255, 255, 255); letter-spacing: 0.408px; color: rgb(0, 128, 255);&quot; class=&quot;js_darkmode__1119&quot;&gt;&lt;strong data-darkmode-bgcolor-16471809271751=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16471809271751=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16471809271751=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16471809271751=&quot;#fff|rgb(0, 128, 255)&quot;&gt;ThirdFighter&lt;/strong&gt;&lt;/span&gt;&lt;span data-darkmode-bgcolor-16471809271751=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16471809271751=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16471809271751=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16471809271751=&quot;#fff|rgb(63, 63, 63)&quot; data-style=&quot;outline: 0px; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; color: rgb(63, 63, 63); background-color: rgb(255, 255, 255); letter-spacing: 0.408px; font-size: 15px;&quot; class=&quot;js_darkmode__1120&quot;&gt;，拉你入群。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;512&quot; data-backw=&quot;512&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWeNacvtL2JaV9oyHhSVP7CAOVRdvOo9pRk4Js4kVtJblIcP4fBSf7Za5Nw0dwq2QHSYRJXvxxN6bw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;⭐&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;面渣逆袭系列&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5e467cb71411856c87d58c65af82c285</guid>
<title>[推荐] 微服务网关选型：5种主流 API 网关，哪个最香！</title>
<link>https://toutiao.io/k/jtyo70d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;常用API网关的对比和选型，并讲解我司自研的微服务网关，干货满满！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务近几年非常火，围绕微服务的技术生态也比较多，比如微服务网关、Docker、Kubernetes等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是于2019年开始接触微服务网关，当时和公司的一位同事一起开发，由于技术能力有限，我只负责网关后台，后续微服务网关的迭代，我其实没有参与，不过后来抽空看了微服务网关前台的代码，所以对这套微服务网关的实现原理算是基本掌握。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最近在写技术栈相关的文章，刚好写到微服务网关，就把之前学习的知识进行简单总结，同时也把市面上常用的微服务网关进行梳理，一方面便于后续技术选型，另一方面也算是给自己一个交代。&lt;/span&gt;&lt;span&gt;下面是文章目录：&lt;/span&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7199533255542591&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBytlvnBaaMt3GQALHibIdRscawJFeUvRmceHek3icklwiaib04b5icicysRfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1714&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;API网关基础&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是API网关&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API网关是一个服务器，是系统的唯一入口。&lt;/strong&gt; 从面向对象设计的角度看，它与外观模式类似。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、协议转换、限流熔断、静态响应处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务&lt;/strong&gt;，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关的主要功能&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务网关作为微服务后端服务的统一入口，它可以统筹管理后端服务，主要分为数据平面和控制平面：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;数据平面主要功能是接入用户的HTTP请求和微服务被拆分后的聚合。使用微服务网关统一对外暴露后端服务的API和契约，路由和过滤功能正是网关的核心能力模块。另外，微服务网关可以实现拦截机制和专注跨横切面的功能，包括协议转换、安全认证、熔断限流、灰度发布、日志管理、流量监控等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;控制平面主要功能是对后端服务做统一的管控和配置管理。例如，可以控制网关的弹性伸缩；可以统一下发配置；可以对网关服务添加标签；可以在微服务网关上通过配置Swagger功能统一将后端服务的API契约暴露给使用方，完成文档服务，提高工作效率和降低沟通成本。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9646697388632872&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBZVlibLMicx9QEwvmaRhCfoZmeHu0VNHI76GL8OAYnN5v7Wgh1GCjI2rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;651&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;路由功能&lt;/strong&gt;：路由是微服务网关的核心能力。通过路由功能微服务网关可以将请求转发到目标微服务。在微服务架构中，网关可以结合注册中心的动态服务发现，实现对后端服务的发现，调用方只需要知道网关对外暴露的服务API就可以透明地访问后端微服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;：API网关结合负载均衡技术，利用Eureka或者Consul等服务发现工具，通过轮询、指定权重、IP地址哈希等机制实现下游服务的负载均衡。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;统一鉴权&lt;/strong&gt;：一般而言，无论对内网还是外网的接口都需要做用户身份认证，而用户认证在一些规模较大的系统中都会采用统一的单点登录（Single Sign On）系统，如果每个微服务都要对接单点登录系统，那么显然比较浪费资源且开发效率低。API网关是统一管理安全性的绝佳场所，可以将认证的部分抽取到网关层，微服务系统无须关注认证的逻辑，只关注自身业务即可。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;协议转换&lt;/strong&gt;：API网关的一大作用在于构建异构系统，API网关作为单一入口，通过协议转换整合后台基于REST、AMQP、Dubbo等不同风格和实现技术的微服务，面向Web Mobile、开放平台等特定客户端提供统一服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;指标监控&lt;/strong&gt;：网关可以统计后端服务的请求次数，并且可以实时地更新当前的流量健康状态，可以对URL粒度的服务进行延迟统计，也可以使用Hystrix Dashboard查看后端服务的流量状态及是否有熔断发生。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;限流熔断&lt;/strong&gt;：在某些场景下需要控制客户端的访问次数和访问频率，一些高并发系统有时还会有限流的需求。在网关上可以配置一个阈值，当请求数超过阈值时就直接返回错误而不继续访问后台服务。当出现流量洪峰或者后端服务出现延迟或故障时，网关能够主动进行熔断，保护后端服务，并保持前端用户体验良好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;黑白名单&lt;/strong&gt;：微服务网关可以使用系统黑名单，过滤HTTP请求特征，拦截异常客户端的请求，例如DDoS攻击等侵蚀带宽或资源迫使服务中断等行为，可以在网关层面进行拦截过滤。比较常见的拦截策略是根据IP地址增加黑名单。在存在鉴权管理的路由服务中可以通过设置白名单跳过鉴权管理而直接访问后端服务资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;灰度发布&lt;/strong&gt;：微服务网关可以根据HTTP请求中的特殊标记和后端服务列表元数据标识进行流量控制，实现在用户无感知的情况下完成灰度发布。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;流量染色&lt;/strong&gt;：和灰度发布的原理相似，网关可以根据HTTP请求的Host、Head、Agent等标识对请求进行染色，有了网关的流量染色功能，我们可以对服务后续的调用链路进行跟踪，对服务延迟及服务运行状况进行进一步的链路分析。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;文档中心&lt;/strong&gt;：网关结合Swagger，可以将后端的微服务暴露给网关，网关作为统一的入口给接口的使用方提供查看后端服务的API规范，不需要知道每一个后端微服务的Swagger地址，这样网关起到了对后端API聚合的效果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;日志审计&lt;/strong&gt;：微服务网关可以作为统一的日志记录和收集器，对服务URL粒度的日志请求信息和响应信息进行拦截。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;API网关选型&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常用API网关&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先简单看一下市面上常用的API网关：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5245&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBian5sEsbeASkxkEichmicX08CibiamBiaZVfmb4WBG9fr1klvGkvIYDHt7Yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Nginx&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx是一个高性能的HTTP和反向代理服务器。&lt;strong&gt;Nginx一方面可以做反向代理，另外一方面可以做静态资源服务器，接口使用Lua动态语言可以完成灵活的定制功能。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx 在启动后，会有一个 Master 进程和多个 Worker 进程，Master 进程和 Worker 进程之间是通过进程间通信进行交互的，如图所示。Worker 工作进程的阻塞点是在像 select()、epoll_wait() 等这样的 I/O 多路复用函数调用处，以等待发生数据可读 / 写事件。Nginx 采用了异步非阻塞的方式来处理请求，也就是说，Nginx 是可以同时处理成千上万个请求的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Zuul&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul 是 Netflix 开源的一个API网关组件，它可以和 Eureka、Ribbon、Hystrix 等组件配合使用。社区活跃，融合于 SpringCloud 完整生态，是构建微服务体系前置网关服务的最佳选型之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul 的核心是一系列的过滤器，这些过滤器可以完成以下功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;统一鉴权 + 动态路由 + 负载均衡 + 压力测试&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;审查与监控&lt;/strong&gt;：与边缘位置追踪有意义的数据和统计结果，从而带来精确的生产视图。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;多区域弹性&lt;/strong&gt;：跨越 AWS Region 进行请求路由，旨在实现 ELB（Elastic Load Balancing，弹性负载均衡）使用的多样化，以及让系统的边缘更贴近系统的使用者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul 目前有两个大的版本：&lt;strong&gt;Zuul1 和 Zuul2&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul1 是基于 Servlet 框架构建，如图所示，采用的是阻塞和多线程方式，即一个线程处理一次连接请求，这种方式在内部延迟严重、设备故障较多情况下会引起存活的连接增多和线程增加的情况发生。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5943152454780362&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBZdzBxickmfRynE9lYs9fejz3cYHOl7MCc0yooklJicpqxOFu12KLrR1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1548&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netflix 发布的 Zuul2 有重大的更新，它运行在异步和无阻塞框架上，每个 CPU 核一个线程，处理所有的请求和响应，请求和响应的生命周期是通过事件和回调来处理的，这种方式减少了线程数量，因此开销较小。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7749077490774908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBDCQiaKu7Xu8uPV38I4YorohFoTCughI0lkLSDq97CWWrKicxSuGRrjiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1626&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Spring Cloud GateWay&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Cloud Gateway 是Spring Cloud的一个全新的API网关项目，目的是为了替换掉Zuul1，它基于Spring5.0 + SpringBoot2.0 + WebFlux（基于⾼性能的Reactor模式响应式通信框架Netty，异步⾮阻塞模型）等技术开发，性能⾼于Zuul，官⽅测试，&lt;strong&gt;Spring Cloud GateWay是Zuul的1.6倍&lt;/strong&gt;，旨在为微服务架构提供⼀种简单有效的统⼀的API路由管理⽅式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Cloud Gateway可以与Spring Cloud Discovery Client（如Eureka）、Ribbon、Hystrix等组件配合使用，&lt;strong&gt;实现路由转发、负载均衡、熔断、鉴权、路径重写、⽇志监控等，并且Gateway还内置了限流过滤器，实现了限流的功能。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6675712347354138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBVBMzzNTMrVpMXojqqtoFGADsroLSPic5BibTgn5nWUEmMoTaTPOjcRIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1474&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kong&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong是一款基于OpenResty（Nginx + Lua模块）编写的高可用、易扩展的，由Mashape公司开源的API Gateway项目。&lt;strong&gt;Kong是基于NGINX和Apache Cassandra或PostgreSQL构建的&lt;/strong&gt;，能提供易于使用的RESTful API来操作和配置API管理系统，所以它可以水平扩展多个Kong服务器，通过前置的负载均衡配置把请求均匀地分发到各个Server，来应对大批量的网络请求。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6701986754966888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBYIld46qNHXmzg1DvMExI09l3icQuibtapAR87H1VhQCRFFPQo2waQd9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1510&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong主要有三个组件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Kong Server ：基于Nginx的服务器，用来接收API请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Apache Cassandra/PostgreSQL ：用来存储操作数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kong dashboard：官方推荐UI管理工具，也可以使用 restfull 方式管理admin api。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong采用插件机制进行功能定制，插件集（可以是0或N个）在API请求响应循环的生命周期中被执行。插件使用Lua编写，目前已有几个基础功能：&lt;strong&gt;HTTP基本认证、密钥认证、CORS（Cross-Origin Resource Sharing，跨域资源共享）、TCP、UDP、文件日志、API请求限流、请求转发以及Nginx监控。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4054441260744986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBf3I4xvqwte7ibc6yJqlQBH3dWXBzniaKtsWEIFOUrdxiaDcMZTMvRlAFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong网关具有以下的特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;可扩展性: 通过简单地添加更多的服务器，可以轻松地进行横向扩展，这意味着您的平台可以在一个较低负载的情况下处理任何请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模块化: 可以通过添加新的插件进行扩展，这些插件可以通过RESTful Admin API轻松配置；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在任何基础架构上运行: Kong网关可以在任何地方都能运行。您可以在云或内部网络环境中部署Kong，包括单个或多个数据中心设置，以及public，private 或invite-only APIs。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Traefik&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Træfɪk 是一个为了让部署微服务更加便捷而诞生的现代HTTP反向代理、负载均衡工具。它支持多种后台 (Docker, Swarm, Kubernetes, Marathon, Mesos, Consul, Etcd, Zookeeper, BoltDB, Rest API, file…) 来自动化、动态的应用它的配置文件设置。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBx2Npyq1VKYXJiclK5lknus5cdykFgyoZT8KPdPmCwLDVJvvndMvlXLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重要特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;它非常快，无需安装其他依赖，通过Go语言编写的单一可执行文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;多种后台支持：Docker, Swarm, Kubernetes, Marathon, Mesos, Consul, Etcd；&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持支持Rest API、Websocket、HTTP/2、Docker镜像；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;监听后台变化进而自动化应用新的配置文件设置；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置文件热更新，无需重启进程；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后端断路器、负载均衡、容错机制；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;清爽的前端页面，可监控服务指标。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于Traefik的更多内容，可以查看官网：https://traefik.cn/&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;API网关对比&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7698795180722892&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBPg6u5rcZm6TraAYx2jEm9Ak9QCxxGBZnmU72ccMPGl4hjTujvEmDcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1660&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7158403869407497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBUBQ4IABfcv8unwSibnIXTjCyfYia2OOlTM4fmIkCAkZMicEM1LaPHr3XA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1654&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26964933494558646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBDx2y075cDiaIhcP6BkibPicPFicNXaOP6cxzbTN08cGrBOyh8N4Y0IXfWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1654&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是网关对比截图，偷个懒，大家主要关注Kong、Traefik和Zuul即可：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;开源社区活跃度&lt;/strong&gt;来看，无疑是Kong和Traefik较好；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;成熟度&lt;/strong&gt;来看，较好的是Kong、Tyk、Traefik；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;性能&lt;/strong&gt;来看，Kong要比其他几个领先一些；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;架构优势&lt;/strong&gt;的扩展性来看，Kong、Tyk有丰富的插件，Ambassador也有插件但不多，而Zuul是完全需要自研，但Zuul由于与Spring Cloud深度集成，使用度也很高，近年来Istio服务网格的流行，Ambassador因为能够和Istio无缝集成也是相当大的优势。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是其它网友的思考结论，可供参考：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;性能&lt;/strong&gt;：Nginx+Lua形式必然是高于Java语言实现的网关的，Java技术栈里面Zuul1.0是基于Servlet实现的，剩下都是基于webflux实现，性能是高于基于Servlet实现的。&lt;strong&gt;在性能方面我觉得选择网关可能不算那么重要，多加几台机器就可以搞定。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;可维护性和扩展性&lt;/strong&gt;：Nginx+Lua这个组合掌握的人不算多，如果团队有大神，大佬们就随意了，当没看到这段话，对于一般团队来说的话，选择自己团队擅长的语言更重要。Java技术栈下的3种网关，对于Zuul和Spring Cloud Gateway需要或多或少要搞一些集成和配置页面来维护，但是对于Soul我就无脑看看文章，需要哪个搬哪个好了，尤其是可以无脑对接Dubbo美滋滋，此外Soul2.0以后版本可以摆脱ZK，在我心里再无诟病，我就喜欢无脑操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高可用&lt;/strong&gt;：对于网关高可用基本都是统一的策略都是采用多机器部署的方式，前面挂一个负载，对于而外需要用的一些组件大家注意一下。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基于Traefik自研的微服务网关&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是我司自研的微服务网关，基于Traefik进行开发，下面从技术选型、网关框架、网关后台、协议转换进行讲解，绝对干货！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;技术栈选型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Traefik&lt;/strong&gt;：一款开源的反向代理与负载均衡工具，它最大的优点是能够与常见的微服务系统直接整合，可以实现自动化动态配置。traefik较为轻量，非常易于使用和设置，性能比较好，已在全球范围内用于生产环境。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Etcd&lt;/strong&gt;：一个Go言编写的分布式、高可用的一致性键值存储系统，用于提供可靠的分布式键值存储、配置共享和服务发现等功能。（更多内容可以查看文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&amp;amp;mid=2247485759&amp;amp;idx=1&amp;amp;sn=41957e94a2c69426befafd373fbddcc5&amp;amp;chksm=cf034bddf874c2cb52a7aafea5cd194e70308c7d4ad74183db8a36d3747122be1c7a31b84ee3&amp;amp;token=179167416&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;肝了一个月的ETCD，从Raft原理到实践&lt;/a&gt; ）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Go&lt;/strong&gt;：并发能力强，性能媲美C，处理能力是PHP的4倍，效率高，语法简单，易上手，开发效率接近PHP。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43399810066476735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBibRxyvnVxEXXoibc7HRS13FiajiaibGVGlOT0ReqWUrMR8say8PibeCFqDEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2106&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关框架&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个网关框架分为3块：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;网关后台&lt;/strong&gt;（hal-fe和hal-admin）：用于应用、服务和插件的配置，然后将配置信息发布到ETCD；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Traefik&lt;/strong&gt;：读取ETCD配置，根据配置信息对请求进行路由分发，如果需要鉴权，会直接通过hal-agent模块进行统一鉴权。鉴权完毕后，如果是Http请求，直接打到下游服务，如果是Grpc和Thrift协议，会通过hal-proxy模块进行协议转换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;协议转换模块&lt;/strong&gt;：读取ETCD配置，对Traefik分发过来的请求，进行Grpc和Thrift协议转换（更多内容可以查看文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&amp;amp;mid=2247486405&amp;amp;idx=1&amp;amp;sn=e03722a78de27f7aacea2189461b1848&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;RPC框架：从原理到选型，一文带你搞懂RPC&lt;/a&gt;），并通过服务发现机制，获取服务下游机器，并通过负载均衡，将转换后的数据打到下游服务机器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5683333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBYBticvj5L2INK3jt4ibqymSmHNzBv9BR0VdfLicavrjgMxR5hsv5s3rMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网关后台&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要由3大模块组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;应用&lt;/strong&gt;：主要包括应用名、域名、路径前缀、所属组、状态等，比如印度海外商城、印度社区；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;服务&lt;/strong&gt;：主要包括服务名、注册方式、协议类型、所属组、状态等，比如评论服务、地址服务、搜索服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;插件&lt;/strong&gt;：主要包括插件名称、插件类型、插件属性配置等，比如路径前缀替换插件、鉴权插件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4255&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBVIt0CPjryQ2vAQtbIgymqKExAtwicG57z8xhMd2wgNcsibZFt4Ria1Ficg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一个应用只能绑定一个服务，但是可以绑定多个插件。&lt;/strong&gt; 通过后台完成网关配置后，将这些配置信息生成Config文件，发布到ETCD中，Config文件需要遵循严格的数据格式，比如Traefix配置需要遵循官方的文件配置格式，才能被Traefik识别。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bByLQreTUBd7WOW8zW2ichnQRLrjgE3x7n4ibowYdefMzE7se5uy3LdhcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;协议转换模块&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hal-proxy模块是整个微服务网关最复杂，也是技术含量最高的模块，所以给大家详细讲解一下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题引入&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在讲这个模块前，我们先看下面几个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当请求从上游的trafik过来时，需要知道访问下游的机器IP和端口，才能将请求发送给下游，这些机器如何获取呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有了机器后，我们需要和下游机器建立连接，如果连接用一次就直接释放，肯定对服务会造成很大的压力，这就需要引入Client缓存池，那这个Client缓存池我们又该如何实现呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后就是需要对协议进行转换，因为不同的下游服务，支持的协议类型是不一样的，这个网关又是如何动态支持的呢？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6163175303197354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBtjZLKhJdgInAgDOicm3WEic5CagBQL0ZPoaqicvLic2SueWicutFJjP1UeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1814&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现原理&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5095&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bB0CQAStBiapHJOGKsCbIVCEnTkLPDwusicrqk4TJ5mnM4aak39IYicGu1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是先看一下hal-proxy内部有哪些模块，首先是Resolver模块，这个模块的是什么作用呢？这里我简单介绍一下，目前公司内部通过服务获取到机器列表的方式有多种，比如MIS平台、服务树等，也就是有的是通过平台配置的，有的是直接挂在服务树下，无论哪种方式，我们都通过服务名，通过一定的方式，找到该服务下面所有的主机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以Resolver模块的作用，其实就是通过服务名，找到该服务下的所有机器的IP和服务端口，然后持久化到内存中，并定时更新。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协议模块就是支持不同的协议转换，每个协议类型的转换，都需要单独实现，&lt;strong&gt;这些协议转换，无非就是先通过机器IP和端口初始化Client，然后再将数据进行转换后，直接发送到下游的机器。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后就是连接池，之前我们其实也用到go自带的pool来做，但是当对pool数据进行更新时，需要加锁，所以性能一直起不来，后来&lt;strong&gt;改成了环形队列，然后对数据的操作全部通过原子操作方式，就实现了无锁操作，大大提高的并发性能。&lt;/strong&gt; 环形队列的代码，也给你安排上，可以直接看这篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&amp;amp;mid=2247484024&amp;amp;idx=1&amp;amp;sn=8345b28106df822b7299dc1efaf49f30&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Go语言核心手册-10.原子操作&lt;/a&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现逻辑&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是hal-proxy的逻辑实现图，画了2天，包含所有核心对象的交互方式，这里就不去细讲，能掌握多少，靠大家自己领悟。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6637788778877888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLEXuTOz5IRxEKunvZCtp6bBTW2LnXaNDLWwaWdNF1nich33BBmkAxvcsNn7A5homx0f4K3ZkziadfuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2424&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;尽信书则不如无书，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激。&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;微信8.0将好友放开到了一万，小伙伴可以加我大号了，先到先得，再满就真没了&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;扫描下方二维码即可加我微信啦，&lt;code&gt;2022，抱团取暖，一起牛逼。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/CKvMdchsUwm6azMkIr9xkWmjuVuQWuj03AOILRglqP1zWJg2Qzroat4xkVdUTsqja7xtiaiap34WKSJuoUYAME6g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1Nzg4NjgyMw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/CKvMdchsUwnfLzMS3eAE7gXUvx6GYmnzuANVe5zJIGp0C084ANIia7Xo1nSADddF3eiajuhKDf0EofjI4t7hdqyA/0?wx_fmt=png&quot; data-nickname=&quot;macrozheng&quot; data-alias=&quot;&quot; data-signature=&quot;专注Java技术分享，涵盖SpringBoot、SpringCloud、Docker、中间件等实用技术，作者Github开源项目mall（50K+Star）。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/CKvMdchsUwlkU1ysoMgG69dVYbCQcI6Byneb8ibzZWPfUCr3T8CuBicCSGyFE6SpAtxpxtDCp6VlZ4F1hEL1BNyg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>