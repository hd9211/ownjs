<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f29cef9a44154e00617b3c2e992da024</guid>
<title>华为 18 级工程师十年之作，整整 3625 页互联网大厂面试题合集</title>
<link>https://toutiao.io/k/quakzn8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;最近又赶上跳槽的高峰期，好多粉丝，都问我要有没有最新面试题，索性，我就把我看过的和我面试中的真题，及答案都整理好，&lt;/span&gt;&lt;span&gt;整理了&lt;span&gt;《第2版：互联网大厂面试题》&lt;/span&gt;&lt;/span&gt;&lt;span&gt;并分类 &lt;/span&gt;&lt;span&gt;&lt;span&gt;92份&lt;/span&gt;&lt;/span&gt;&lt;span&gt; PDF&lt;/span&gt;，&lt;span&gt;&lt;span&gt;累计 3625页！&lt;/span&gt;&lt;/span&gt;我会持续更新中，马上就出第三版，涵盖大厂算法会更多！&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3155818540433925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8dYn2MDf4MIibXia0aKcUFkxDB4wxia2Wrb3gjBdWL8eKbsHTHibdy44hwgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;507&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;第2版：题库非常全面&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;包括 Java 集合、JVM、多线程、并发编程、设计模式、Spring全家桶、Java、MyBatis、ZooKeeper、Dubbo、Elasticsearch、Memcached、MongoDB、Redis、MySQL、RabbitMQ、Kafka、Linux、Netty、Tomcat、Python、HTML、CSS、Vue、React、JavaScript、Android 大数据、阿里巴巴等大厂面试题等、等技术栈！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;部分内容预览&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8134777376654633&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8dP3Ho2mU5sm7n21BIfYNRpBUNQOLrcDM6LKVNoLQVWQKaqbw7hjRVdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;831&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8182912154031288&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8dpniaIiawDyT6C8BHrndtnUDuQC1CRlCUqYvetmyXQEKtCbmcztKqicJVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;831&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.2408088235294117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8dJQgIrlOeBdyvoORsB6dL5PbHibRH5U05XtyxN7P3fcESxGnSp5Q78PQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;544&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7444237918215614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8dic8ib2pm8zOmnyw1fsjsOvf4v1JmwfMPiaXanPa37Qv5ic30oLABDkkTUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1076&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7647058823529411&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8diaib6werGOCQvdysGlCj1KtNoe7ricK9sv4Fx0mTFPrFAl9qsaLjoeGbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;969&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;现在这本 PDF 以及3625页面试合集及答案免费分享给你，扫码添加助理备注“面试”&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0236220472440944&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8doc08qGemdXsfPyq0Zme2qsyNm6Jic7G7mC8uZpCwJdYsf5xemovZRTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;254&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Java神器，下载已经近万次，没保存的抓紧了。最重要的是里面有常问面试题，据说已经有小伙伴通过这套资料，&lt;span&gt;成功的入职了蚂蚁金服、字节跳动等大厂&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6305555555555555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8dJk2D0Y7MVoyW0CcYKq8tvNozh2vFChiaS94SLZrjFtpIEtN2Ygpl4Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;而且，这些资料不是扫描版的，里面的文字都可以直接复制，非常便于我们学习。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;面试&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6212962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8dweOdHictrTTziahLWv7pIyN3zFdw8T6bpjfLJyOpTj5mAUNTltYLaIdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;IDEA&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5861111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8dnw4UibSNsqc0ZPxhBBickNZVRY23iahqA0miaZ4Do3ia8dH7EtRj04dT9ag/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Spring Boot&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6240740740740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8diczvhejZTWicDdoCLlsQmU32lYmhEVeMMPYpQynicPhVI8aBoegpyhARw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Nginx&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6111111111111112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8dvEvWuArsa5BzBAJPlfzgZdfRlj6ngGoRcIGrpluXzIO89YLvIFAibbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Spring全家桶&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6453703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8dYk6eMl8PrfTbX9yht9ZWElRG7ExXycssL2J1iapvnTg3PoT93rMUTCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;MyBatis&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5111111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8dE1LuDysnhx0o2SHDqnTk54UxvuG1oaFdtCW57iaibfFF5C4NTvH5qDoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6851851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8dkiaPVfMXpctgkVBC3hY4ibSnYRZr9YmxmwZIfhCibv84OCRj3SohEpmPg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.725925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8dmibsaAMntTosb7CPfZticKwpsrMmgWDXppO38vkjIY4uBWt5EsxDiaWUg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除此之外，还有 &lt;span&gt;Spring、Spring Boot、Dubbo、JVM、集合、多线程、JPA、MyBatis、MySQL、大数据、Nginx、Git、Docker、GitHub、Servlet、JavaWeb、IDEA、Redis、算法、面试题 的 PDF，我就不一一截屏了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面这本是你一直想要的硬核基础知识，可以看看下图的左侧目录。不像教材和普通的书目，这本 PDF &lt;span&gt;讲解通俗易懂，接地气，由浅入深。看起来绝对不枯燥。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6138888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8dDbtsTBQxWyDQDU35RqAuVGicksbHtjhibCGmIp8ycC8krPaHKW4ENZuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基本上涵盖了计算机所有基础知识，从 CPU 到内存、讲解什么是二进制、磁盘、压缩算法、操作系统、汇编等知识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;现在这本 PDF 以及3625页面试合集及答案免费分享给你，扫码添加助理备注“面试”&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0236220472440944&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bMjESHUV2dIIt4Ggls0I7TGpVhXrlE8doc08qGemdXsfPyq0Zme2qsyNm6Jic7G7mC8uZpCwJdYsf5xemovZRTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;254&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>51f097522ce7c9214588ccf237548abf</guid>
<title>大数据时代的用户画像基础介绍和构建流程</title>
<link>https://toutiao.io/k/sjw8ku8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;27&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;27&quot; data-custom=&quot;#1e9be8&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;点击标题下「&lt;em&gt;&lt;strong&gt;搜索与推荐Wiki&lt;/strong&gt;&lt;/em&gt;」可快速关注&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93040&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;92886&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;▼&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;精彩推荐&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;▼&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247487424&amp;amp;idx=1&amp;amp;sn=6281fb41acb7dc2de2d1cb67c2238053&amp;amp;chksm=ea66c75add114e4cc412161e1bc2ed59c58cb643db4a95bb46af84f82dbba0e253b55bfb9339&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;1、&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;&lt;strong&gt;1、&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247489200&amp;amp;idx=1&amp;amp;sn=175956595187e24ddcbd4401b0f4e842&amp;amp;chksm=ea66de2add11573c2958cbb0dfbdaa13dc850f6ba91bea9daa4033d3acff906796c10799e23d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;特征工程｜文本特征处理的四大类主流方法&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247489160&amp;amp;idx=1&amp;amp;sn=528748edcbe58e31b85ef0fa61b255ca&amp;amp;chksm=ea66de12dd1157044bc6c7d80daa11cff13995139a99e6579dde07f3d37d2d2172378632d24d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;计算广告与推荐系统有哪些区别？使用的主流模型有哪些？&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247487424&amp;amp;idx=1&amp;amp;sn=6281fb41acb7dc2de2d1cb67c2238053&amp;amp;chksm=ea66c75add114e4cc412161e1bc2ed59c58cb643db4a95bb46af84f82dbba0e253b55bfb9339&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;独孤九剑：算法模型训练的一般流程&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;4、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247488050&amp;amp;idx=1&amp;amp;sn=5cbc4b48dc49f541d96a418769263d22&amp;amp;chksm=ea66daa8dd1153be05fffc0826136244e12fbce9f3f7ce056a11e7e2b4720cc7fde606adcade&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;&lt;strong&gt;从DSSM语义匹配到Google的双塔深度模型召回和广告场景中的双塔模型思考&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;5、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247488827&amp;amp;idx=1&amp;amp;sn=6248ecc4422d5f0afe29e81ddb796936&amp;amp;chksm=ea66dda1dd1154b7ff30410061f2541a6dba008017bcfebd44c61d507a8d09c4462f2e3ea34c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;算法工程师的数学基础｜如何理解概率分布函数和概率密度函数&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;31&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;导读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-style=&quot;text-indent: 2em;;&quot;&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;在互联网步入大数据时代后，用户行为给企业的产品和服务带来了一系列的改变和重塑，其中最大的变化在于，用户的一切行为在企业面前是可“追溯”“分析”的。企业内保存了大量的原始数据和各种业务数据，这是企业经营活动的真实记录，如何更加有效地利用这些数据进行分析和评估，成为企业基于更大数据量背景的问题所在。随着大数据技术的深入研究与应用，企业的关注点日益聚焦在如何利用大数据来为精细化运营和精准营销服务，而要做精细化运营，首先要建立本企业的用户画像。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;画像简介&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;用户画像，即&lt;/span&gt;&lt;span&gt;用户信息标签化&lt;/span&gt;&lt;span&gt;，通过收集用户的社会属性、消费习惯、偏好特征等各个维度的数据，进而对用户或者产品特征属性进行刻画，并对这些特征进行分析、统计，挖掘潜在价值信息，从而抽象出用户的信息全貌，如图1-1所示。用户画像可看作企业应用大数据的根基，是定向广告投放与个性化推荐的前置条件，为数据驱动运营奠定了基础。由此看来，如何从海量数据中挖掘出有价值的信息越发重要。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;209&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.36237373737373735&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;792&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpTpUfVXDSfibTbvS7tCuiappvNj35twj1ZibMCx0W6dfcFibFVyCSRLVicQg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图1-1　某用户标签化&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;大数据已经兴起多年，其对于互联网公司的应用来说已经如水、电、空气对于人们的生活一样，成为不可或缺的重要组成部分。从基础设施建设到应用层面，主要有数据平台搭建及运维管理、数据仓库开发、上层应用的统计分析、报表生成及可视化、用户画像建模、个性化推荐与精准营销等应用方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多公司在大数据基础建设上投入很多，也做了不少报表，但业务部门觉得大数据和传统报表没什么区别，也没能体会大数据对业务有什么帮助和价值，究其原因，其实是“数据静止在数据仓库，是死的”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而用户画像可以帮助大数据“走出”数据仓库，针对用户进行个性化推荐、精准营销、个性化服务等多样化服务，是大数据落地应用的一个重要方向。数据应用体系的层级划分如图1-2所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;287&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.49634146341463414&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;820&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpaPuUNSibZqNyWibpYpNG1Xp40zKZsZEd9mzEHezPfticyG1nR9YgKXJzA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1-2　数据应用体系的层级划分&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;标签类型：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户画像建模其实就是对用户“打标签”，从对用户打标签的方式来看，一般分为3种类型（如图1-3所示）：①统计类标签；②规则类标签；③机器学习挖掘类标签。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;102&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.17693836978131214&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVp4TQDdvTUze7YPI0L5gh1CB6jlUfyurzePUGpFqfzq0QSN1ubkibsTUg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1-3　标签类型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我们介绍这3种类型的标签的区别：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;① 统计类标签&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这类标签是最为基础也最为常见的标签类型，例如，对于某个用户来说，其性别、年龄、城市、星座、近7日活跃时长、近7日活跃天数、近7日活跃次数等字段可以从用户注册数据、用户访问、消费数据中统计得出。该类标签构成了用户画像的基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;② 规则类标签&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该类标签基于用户行为及确定的规则产生。例如，对平台上“消费活跃”用户这一口径的定义为“近30天交易次数≥2”。在实际开发画像的过程中，由于运营人员对业务更为熟悉，而数据人员对数据的结构、分布、特征更为熟悉，因此规则类标签的规则由运营人员和数据人员共同协商确定；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;③ 机器学习挖掘类标签&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该类标签通过机器学习挖掘产生，用于对用户的某些属性或某些行为进行预测判断。例如，根据一个用户的行为习惯判断该用户是男性还是女性、根据一个用户的消费习惯判断其对某商品的偏好程度。该类标签需要通过算法挖掘产生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在项目工程实践中，一般统计类和规则类的标签即可以满足应用需求，在开发中占有较大比例。机器学习挖掘类标签多用于预测场景，如判断用户性别、用户购买商品偏好、用户流失意向等。&lt;/span&gt;&lt;span&gt;一般地，机器学习标签开发周期较长，开发成本较高，因此其开发所占比例较小。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;数据架构&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在整个工程化方案中，系统依赖的基础设施包括Spark、Hive、HBase、Airflow、MySQL、Redis、Elasticsearch。除去基础设施外，系统主体还包括Spark Streaming、ETL、产品端3个重要组成部分。图1-4所示是用户画像数仓架构图，下面对其进行详细介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;390&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6743383199079401&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;869&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVp2TKMOXBhDvHAsk8MSrxduyprWjDvTEZee8rN8Xj4CxAdFq814k0kAg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1-4　用户画像数仓架构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1-4下方虚线框中为常见的数据仓库ETL加工流程，也就是将每日的业务数据、日志数据、埋点数据等经过ETL过程，加工到数据仓库对应的ODS层、DW层、DM层中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中间的虚线框即为用户画像建模的主要环节，用户画像不是产生数据的源头，而是对基于数据仓库ODS层、DW层、DM层中与用户相关数据的二次建模加工。在ETL过程中将用户标签计算结果写入Hive，由于不同数据库有不同的应用场景，后续需要进一步将数据同步到MySQL、HBase、Elasticsearch等数据库中。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Hive：存储用户标签计算结果、用户人群计算结果、用户特征库计算结果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MySQL：存储标签元数据，监控相关数据，导出到业务系统的数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;HBase：存储线上接口实时调用类数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Elasticsearch：支持海量数据的实时查询分析，用于存储用户人群计算、用户群透视分析所需的用户标签数据（由于用户人群计算、用户群透视分析的条件转化成的SQL语句多条件嵌套较为复杂，使用Impala执行也需花费大量时间）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;用户标签数据在Hive中加工完成后，部分标签通过Sqoop同步到MySQL数据库，提供用于BI报表展示的数据、多维透视分析数据、圈人服务数据；另一部分标签同步到HBase数据库用于产品的线上个性化推荐。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;主要覆盖模块&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;搭建一套用户画像方案整体来说需要考虑8个模块的建设，如图1-5所示。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户画像基础：需要了解、明确用户画像是什么，包含哪些模块，数据仓库架构是什么样子，开发流程，表结构设计，ETL设计等。这些都是框架，大方向的规划，只有明确了方向后续才能做好项目的排期和人员投入预算。这对于评估每个开发阶段重要指标和关键产出非常重要，重点可看1.4节。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据指标体系：根据业务线梳理，包括用户属性、用户行为、用户消费、风险控制等维度的指标体系。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;标签数据存储：标签相关数据可存储在Hive、MySQL、HBase、Elasticsearch等数据库中，不同存储方式适用于不同的应用场景。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;标签数据开发：用户画像工程化的重点模块，包含统计类、规则类、挖掘类、流式计算类标签的开发，以及人群计算功能的开发，打通画像数据和各业务系统之间的通路，提供接口服务等开发内容。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;316&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5470459518599562&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;914&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVp4NkIeMicco9SeWrz14feew70WcEVREcicckVTrJos40icCIy9KshQK87Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1-5　用户画像主要覆盖模块&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;开发性能调优：标签加工、人群计算等脚本上线调度后，为了缩短调度时间、保障数据的稳定性等，需要对开发的脚本进行迭代重构、调优。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;作业流程调度：标签加工、人群计算、同步数据到业务系统、数据监控预警等脚本开发完成后，需要调度工具把整套流程调度起来。本书讲解了Airflow这款开源ETL工具在调度画像相关任务脚本上的应用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户画像产品化：为了能让用户数据更好地服务于业务方，需要以产品化的形态应用在业务上。产品化的模块主要包括标签视图、用户标签查询、用户分群、透视分析等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户画像应用：画像的应用场景包括用户特征分析、短信、邮件、站内信、Push消息的精准推送、客服针对用户的不同话术、针对高价值用户的极速退货退款等VIP服务应用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;开发阶段流程&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本节主要介绍画像系统开发上线的流程以及各阶段的关键产出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 开发上线流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户画像建设项目流程，如图1-6所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;172&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2980891719745223&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpcfpqNsE9sT17YPdxlia8ibFpQian868ianT5aianlqUZrPChknIiaLJ7OvNg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;图1-6　用户画像建设项目流程&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第一阶段：目标解读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在建立用户画像前，首先需要明确用户画像服务于企业的对象，再根据业务方需求，明确未来产品建设目标和用户画像分析之后的预期效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般而言，用户画像的服务对象包括运营人员和数据分析人员。不同业务方对用户画像的需求有不同的侧重点，就运营人员来说，他们需要分析用户的特征、定位用户行为偏好，做商品或内容的个性化推送以提高点击转化率，所以画像的侧重点就落在了用户个人行为偏好上；就数据分析人员来说，他们需要分析用户行为特征，做好用户的流失预警工作，还可根据用户的消费偏好做更有针对性的精准营销。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第二阶段：任务分解与需求调研&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过第一阶段的需求调研和目标解读，我们已经明确了用户画像的服务对象与应用场景，接下来需要针对服务对象的需求侧重点，结合产品现有业务体系和“数据字典”规约实体和标签之间的关联关系，明确分析维度。就后文将要介绍的案例而言，需要从用户属性画像、用户行为画像、用户偏好画像、用户群体偏好画像等角度去进行业务建模。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第三阶段：需求场景讨论与明确&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在本阶段，数据运营人员需要根据与需求方的沟通结果，输出产品用户画像需求文档，在该文档中明确画像应用场景、最终开发出的标签内容与应用方式，并就该文档与需求方反复沟通并确认无误。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第四阶段：应用场景与数据口径确认&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过第三个阶段明确了需求场景与最终实现的标签维度、标签类型后，数据运营人员需要结合业务与数据仓库中已有的相关表，明确与各业务场景相关的数据口径。在该阶段中，数据运营方需要输出产品用户画像开发文档，该文档需要明确应用场景、标签开发的模型、涉及的数据库与表以及应用实施流程。该文档不需要再与运营方讨论，只需面向数据运营团队内部就开发实施流程达成一致意见即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第五阶段：特征选取与模型数据落表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本阶段中数据分析挖掘人员需要根据前面明确的需求场景进行业务建模，写好HQL逻辑，将相应的模型逻辑写入临时表中，并抽取数据校验是否符合业务场景需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第六阶段：线下模型数据验收与测试&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据仓库团队的人员将相关数据落表后，设置定时调度任务，定期增量更新数据。数据运营人员需要验收数仓加工的HQL逻辑是否符合需求，根据业务需求抽取表中数据查看其是否在合理范围内，如果发现问题要及时反馈给数据仓库人员调整代码逻辑和行为权重的数值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第七阶段：线上模型发布与效果追踪&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过第六阶段，数据通过验收之后，会通过Git进行版本管理，部署上线。使用Git进行版本管理，上线后通过持续追踪标签应用效果及业务方反馈，调整优化模型及相关权重配置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 各阶段关键产出&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为保证程序上线的准时性和稳定性，需要规划好各阶段的任务排期和关键产出。画像体系的开发分为几个主要阶段，包括前期指标体系梳理、用户标签开发、ETL调度开发、打通数据服务层、画像产品端开发、面向业务方推广应用、为业务方提供营销策略的解决方案等，如表1-1所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;281&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4859392575928009&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVp0jJTYd2gzWVpeUGTZDUgd7JYRJaC9RROKXwmBophBXStoJlEfBXI1g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;315&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.545556805399325&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpAHB1mTebJEYNyyOFm14GLVYTND1JUGgKib84naFia1xAfM6xAHrRFY2Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;99&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.1713641488162345&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;887&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpVUuPIfqyzAubkeHWgcicNyIpfkmVSkibUyQBlibSGKBcBIaCGgnPYs3fw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1-1　用户画像项目各阶段关键产出&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;标签开发：根据业务需求和应用场景梳理标签指标体系，调研业务上定义的数据口径，确认数据来源，开发相应的标签。标签开发在整个画像项目周期中占有较大比重。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ETL调度开发：梳理需要调度的各任务之间的依赖关系，开发调度脚本及调度监控告警脚本，上线调度系统。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;打通服务层接口：为了让画像数据走出数据仓库，应用到用户身上，需要打通数据仓库和各业务系统的接口。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;画像产品化：需要产品经理与业务人员、技术开发人员一起对接业务需求点和产品功能实现形式，画产品原型，确定工作排期。Java Web端开发完成后，需要数据开发人员向对应的库表中灌入数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;开发调优：在画像的数据和产品端搭建好架构、能提供稳定服务的基础上，为了让调度任务执行起来更加高效、提供服务更加稳健，需要对标签计算脚本、调度脚本、数据同步脚本等相关计算任务进行重构优化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;面向业务方推广应用：用户画像最终的价值产出点是业务方应用画像数据进行用户分析，多渠道触达运营用户，分析ROI，提升用户活跃度或营收。因此，面向业务人员推广画像系统的使用方式、提供针对具体业务场景的解决方案显得尤为重要。在该阶段，相关人员需要撰写画像的使用文档，提供业务支持。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;05&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;画像应用的落地&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户画像最终的价值还是要落地运行，为业务带来实际价值。这里需要开发标签的数据工程师和需求方相互协作，将标签应用到业务中。否则开发完标签后，数据还是只停留在数据仓库中，没有为业务决策带来积极作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;画像开发过程中，还需要开发人员组织数据分析、运营、客服等团队的人员进行画像应用上的推广。对于数据分析人员来说，可能会关注用户画像开发了哪些表、哪些字段以及字段的口径定义；对运营、客服等业务人员来说，可能更关注用户标签定义的口径，如何在Web端使用画像产品进行分析、圈定用户进行定向营销，以及应用在业务上数据的准确性和及时性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只有业务人员在日常工作中真正应用画像数据、画像产品，才能更好地推动画像标签的迭代优化，带来流量提升和营收增长，产出业绩价值。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;06&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;某用户画像案例&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这里通过一个实践案例来将大家更好地带入实际开发画像、应用画像标签的场景中。本节主要介绍案例背景及相关的元数据，以及开发标签中可以设计的表结构样式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在本案例的开发工作中，基于Spark计算引擎，主要涉及的语言包括HiveQL、Python、Scala、Shell等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 案例背景介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;某图书电商网站拥有超过千万的网购用户群体，所售各品类图书100余万种。用户在平台上可进行浏览、搜索、收藏、下单、购买等行为。商城的运营需要解决两个问题：一方面在企业产品线逐渐扩张、信息资源过载的背景下，如何在兼顾自身商业目标的同时更好地满足消费者的需求，为用户带来更个性化的购物体验，通过内容的精准推荐，更好地提高用户的点击转化率；另一方面在用户规模不断增长的背景下，运营方考虑建立用户流失预警机制，及时识别将要流失的用户群体，采取运营措施挽回用户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商城自建立以来，数据仓库中积累着大量的业务数据、日志数据及埋点数据。如何充分挖掘沉淀在数据仓库中的数据的价值，有效支持用户画像的建设，成为当前的重要工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 相关元数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在本案例中，可以获取的数据按其类型分为：业务类数据和用户行为数据。其中业务类数据是指用户在平台上下单、购买、收藏物品、货物配送等与业务相关的数据；用户行为数据是指用户搜索某条信息、访问某个页面、点击某个按钮、提交某个表单等通过操作行为产生（在解析日志的埋点表中）的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;涉及数据仓库中的表主要包括用户信息表、商品订单表、图书信息表、图书类目表、App端日志表、Web端日志表、商品评论表等。下面就用户画像建模过程中会用到的一些数据表做详细介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;① 用户信息表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户信息表（见表1-2）存放有关用户的各种信息，如用户姓名、年龄、性别、电话号码、归属地等信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;315&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5455455455455456&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;999&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVppfm8eJYIV7hgzbSjl6Q77g2PHIBPA5TksO2icYXH5taogN9iaaZ3908A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1-2　用户信息表（dim.user_basic_info）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;② 商品订单表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商品订单表（见表1-3）存放商品订单的各类信息，包括订单编号、用户id、用户姓名、订单生成时间、订单状态等信息。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;359&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.620253164556962&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;948&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpRcDWcJic2G9BnuP9e2WwrbeiciblSrvzZQpjArEvUZo8daVs6qorSIAhA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1-3　商品订单表（dw.order_info_fact）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;③ 埋点日志表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;埋点日志表（见表1-4）存放用户访问App时点击相关控件的打点记录。通过在客户端做埋点，从日志数据中解析出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;131&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.22666666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1050&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVp2aMbDUGibicZJoPQLhs0lm9zBrzicxDSnT28DrxQk0Xia25aAhKjBSicq0w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;169&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2932187201528176&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVp7XEFMHAaqB08qH21WVID1p4gQfuicKG0GyFpx2z3HHLLXwla0C6PboA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1-4　埋点日志表（ods.page_event_log）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;④ 访问日志表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;访问日志表（见表1-5）存放用户访问App的相关信息及用户的LBS相关信息，通过在客户端埋点，从日志数据中解析出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;299&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5166508087535681&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1051&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpfqsB5PI3DVZXSib7MPuqsuQDxXOykrMLhc5S6s9PMfzL10vBLgM2jhw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1-5　访问日志表（ods.page_view_log）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;⑤ 商品评论表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商品评论表（见表1-6）存放用户对商品的评论信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;237&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4094631483166515&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpiawexfHaricV4A8fib6rhLSReYmp2ibqpaFK6O2CZLiaiagiaxC1gQm4LaSzg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1-6　商品评论表（dw.book_comment）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;⑥ 搜索日志表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;搜索日志表（见表1-7）存放用户在App端搜索相关的日志数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;229&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.39617486338797814&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1098&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpIdInicOXMTwLuEY8zuzuRiclvCUiaibg7iaFLQFZ73Lxv80FuEtibEK71eFg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1-7　搜索日志表（dw.app_search_log）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;⑦ 用户收藏表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户收藏表（见表1-8）记录用户收藏图书的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;194&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.33575317604355714&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1102&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVp9mNAPicfIDmabvYSdgh0nw8QUpib3PnemxibIPeHdLnSPyQdHjibPekP9A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1-8　用户收藏表（dw.book_collection_df）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;⑧ 购物车信息表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;购物车信息表（见表1-9）记录用户将图书加入购物车的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;217&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3751135331516803&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpscGQ28EKumicicbo81WaavCCskjkZyEdAurwx8ck3TvahH3cLIXGuCLw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1-9　购物车信息表（dw.shopping_cart_df）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 画像表结构设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表结构设计也是画像开发过程中需要解决的一个重要问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表结构设计的重点是要考虑存储哪些信息、如何存储（数据分区）、如何应用（如何抽取标签）这3个方面的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同业务背景有不同的设计方式，这里提供两种设计思路：一是每日全量数据的表结构；二是每日增量数据的表结构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hive需要对输入进行全盘扫描来满足查询条件，通过使用分区可以优化查询。对于用户标签这种日加工数据，随着时间的推移，分区数量的变动也是均匀的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每日全量数据，即该表的日期分区中记录着截止到当天的全量用户数据。例如，“select  count(*)  from userprofile  where data=&#x27;20180701&#x27;”这条语句查询的是userprofile表截止到2018年7月1日的全量用户数据。日全量数据的优势是方便查询，缺点是不便于探查更细粒度的用户行为。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每日增量数据，即该表的日期分区中记录着当日的用户行为数据。例如，同样是“select count(*) from userprofile where data=&#x27;20180701&#x27;”，这条语句查询的是userprofile表在2018年7月1日记录的当日用户行为数据。日增量数据可视为ODS层的用户行为画像，在应用时还需要基于该增量数据做进一步的建模加工。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面详细介绍这两种表结构的设计方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;① 日全量数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日全量数据表中，在每天对应的日期分区中插入截止到当天为止的全量数据，用户进行查询时，只需查询最近一天的数据即可获得最新全量数据。下面以一个具体的日全量表结构的例子来进行说明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;108&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.18755052546483428&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpiaxzH9qcfqQYUk3WEM1VBTUWEIk1QejuZx9hY4fU44mDQJAJyxnYMYg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里userid表示用户id，labelweight表示标签权重，theme表示标签归属的二级主题，labelid表示一个标签id。通过“日期 +标签归属的二级主题+标签id”的方式进行分区，设置三个分区字段更便于开发和查询数据。该表结构下的标签权重仅考虑统计类型标签的权重，如：历史购买金额标签对应的权重为金额数量，用户近30日访问天数为对应的天数，该权重值的计算未考虑较为复杂的用户行为次数、行为类型、行为距今时间等复杂情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过表名末尾追加“_all”的规范化命名形式，可直观看出这是一张日全量表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如，对于主题类型为“会员”的标签，插入“20190101”日的全量数据，可通过语句：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;insert overwrite table dw. userprofile_userlabel_all partition(data_date= &#x27;20190101&#x27;, theme= &#x27;member&#x27;, labelid=&#x27;ATTRITUBE_U_05_001&#x27;)&lt;/span&gt;&lt;span&gt;来实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查询截止到“20190101”日的被打上会员标签的用户量，可通过语句：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;select count(distinct userid) from dw.userprofile_userlabel_all where data_date=&#x27;20190101&#x27;&lt;/span&gt;&lt;span&gt;来实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;② 日增量数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日增量数据表，即在每天的日期分区中插入当天业务运行产生的数据，用户进行查询时通过限制查询的日期范围，就可以找出在特定时间范围内被打上特定标签的用户。下面以一个具体的日增量表结构的例子来说明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;202&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.35019973368841545&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpXZ9SVNMN9zkrsJ2kxAibPjgD1x0uohVp2KM4fIcI2LZxVcq5gSSBZ0Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里，labelid表示标签名称；cookieid表示用户id；act_cnt表示用户当日行为次数，如用户当日浏览某三级品类商品3次，则打上次数为3；tag_type_id为标签类型,如母婴、3C、数码等不同类型；act_type_id表示行为类型，如浏览、搜索、收藏、下单等行为。分区方式为按日期分区，插入当日数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过表名末尾追加“_append”的规范化命名形式，可直观看出这是一张日增量表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如，某用户在“20180701”日浏览某3C电子商品4次（act_cnt），即给该用户（userid）打上商品对应的三级品类标签（tagid），标签类型（tag_type_id）为3C电子商品，行为类型（act_type_id）为浏览。这里可以通过对标签类型和行为类型两个字段配置维度表的方式，对数据进行管理。例如对于行为类型（act_type_id）字段，可以设定1为购买行为、2为浏览行为、3为收藏行为等，在行为标签表中以数值定义用户行为类型，在维度表中维护每个数值对应的具体含义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该日增量数据表可视为ODS层用户行为标签明细。在查询过程中，例如对于某用户id为001的用户，查询其在“20180701”日到“20180707”日被打上的标签，可通过命令：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;select * from dw.userprofile_act_feature_append where userid = &#x27;001&#x27; and data_date&amp;gt;=&#x27;20180701&#x27; and data_date&amp;lt;= &#x27;20180707&#x27;&lt;/span&gt;&lt;span&gt;查询。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该日增量的表结构记录了用户每天的行为带来的标签，但未计算打在用户身上标签的权重，计算权重时还需做进一步建模加工。标签权重算法详见4.6节的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;③ 关于宽表设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户画像表结构如何设计，没有一定要遵循的固定的格式，符合业务需要、能满足应用即可。下面通过两个宽表设计的案例，提供另一种解决方案的思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户属性宽表设计（见表1-10），主要记录用户基本属性信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;444&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7687420584498094&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;787&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpkNDibfGT0pSyqjNbfVwM2PSeKAY4n26sFypntGAo5l85yaGUzazwOBQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;402&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6959287531806616&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;786&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpwh1DVqY6Fs99cS0vrBqLlYfmSD8cPuforHIhM9ghBFTibLgAAibghWJw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1-10　用户属性宽表设计&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户日活跃宽表设计（见表1-11），主要记录用户每天访问的信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;238&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4123809523809524&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1050&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpqI1iaop228U8kFh3jH8135hetKYbCY43TUxW0xyMatXoESMIKNLx3zQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1-11　用户日活跃宽表设计&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;07&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;定性类画像&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本书重点讲解如何运用大数据定量刻画用户画像，然而对于用户的刻画除了定量维度外，定性刻画也是常见手段。定性类画像多见于用户研究等运营类岗位，通过电话调研、网络调研问卷、当面深入访谈、网上第三方权威数据等方式收集用户信息，帮助其理解用户。这种定性类调研相比大数据定量刻画用户来说，可以更精确地了解用户需求和行为特征，但这个样本量是有限的，得出的结论也不一定能代表大部分用户的观点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过制定调研问卷表，我们可以收集用户基本信息以及设置一个或多个场景，专访用户或网络回收调研问卷，在分析问卷数据后获取用户的画像特征。目前市场上“问卷星”等第三方问卷调查平台可提供用户问卷设计、链接发放、采集数据和信息、调研结果分析等一系列功能，如图1-7所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.3866348448687351&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;419&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpGLgsz12LW3fsKuAavTmUTNNZNzm4AEJ2jb6ehTN6dnfVLIT29MeIjA/640?wx_fmt=png&quot; data-backw=&quot;419&quot; data-backh=&quot;581&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1-7　某调研问卷示例（截图自“问卷星”）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据回收的调研问卷，可结合统计数据进一步分析用户画像特征（如图1-8所示）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;174&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.30165289256198347&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh4WJCtSFtGYXlpCqDmKJVpQtmS6NNeV81wP7uuzjuRcJzznrCPPq5Inic0UvBwbL6aCLyT295YlJA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1-8　回收的调研问卷（截图自“问卷星”）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;08&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本文主要介绍了用户画像的一些基础知识，包括画像的简介、标签类型、整个画像系统的数据架构，开发画像系统主要覆盖的8个模块，以及开发过程中的各阶段关键产出。初步介绍了画像系统的轮廓概貌，帮助读者对于如何设计画像系统、开发周期、画像的应用方式等有宏观的初步的了解。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;——本文摘自机械工业出版社华章图书&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;《用户画像方法论与工程化解决方案》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作者介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;赵宏田，资深大数据技术专家。擅长Hadoop、Spark等大数据技术，以及业务数据分析、数据仓库开发、爬虫、用户画像系统搭建等。著有畅销书《数据化运营：系统方法与实践案例》 《用户画像：方法论与工程化解决方案》。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-backh=&quot;68&quot; data-backw=&quot;548&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/US10Gcd0tQE78f7dkJNjBgeibxuxoocvlffpMYExnaMsoibbMSK8LKYTwX96ATu94u3AVTWEB4ibIvYf5jSibN7kIA/0&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1257.0609318996414&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;155.9856630824373&quot; data-ratio=&quot;0.12410501193317422&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/c6gqmhWiafypu8xMx0VGdz69F9YhVguXuME1NXHKBJvbXrGQUqA33gM6papce4MI1p7licuSL2uPbw5oXkA0YXWQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1257&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-id=&quot;15650&quot; data-md5=&quot;75556&quot;&gt;&lt;section label=&quot;Powered by xmyeditor.com&quot; data-tools=&quot;小蚂蚁编辑器&quot; data-md5=&quot;75556&quot;&gt;&lt;section data-id=&quot;15679&quot; data-md5=&quot;d2aaa&quot;&gt;&lt;section label=&quot;Powered by xmyeditor.com&quot; data-tools=&quot;小蚂蚁编辑器&quot; data-md5=&quot;d2aaa&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;d2aaa&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;d2aaa&quot;&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.1875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/BwrOLGIZh5VJ5cTognH6VYpqmmNdicGuk37yuQiafTlDm8sxlPHyMaw8uIOXr4lNOb7zetTSGDV3HiaDVM50uKGxw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;128&quot; data-width=&quot;10%&quot;/&gt;&lt;span&gt;   &lt;/span&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.1875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/BwrOLGIZh5VJ5cTognH6VYpqmmNdicGuk37yuQiafTlDm8sxlPHyMaw8uIOXr4lNOb7zetTSGDV3HiaDVM50uKGxw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;128&quot; data-width=&quot;10%&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;95390&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;3735&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;88589&quot;&gt;&lt;section data-width=&quot;98%&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;p&gt;真正的努力，&lt;span&gt;都&lt;/span&gt;&lt;span&gt;不喧&lt;/span&gt;&lt;span&gt;嚣！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;40%&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/02kicEWsInicjw3UYDKaIRFbgdoWpOzJ4sxvNrGv2k5Pbob5icVWmsfFgrbc2RiaABlhrCJH51d7aZc6AiaTcFKHIfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;344&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;搜索与推荐Wiki&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;span&gt;All In CTR、DL、ML、RL、NLP&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;95390&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94250&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;91842&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/02kicEWsInicj3oK9alStElyMzciafsRKaV1hV9PFP4icRkALfLsbJOsRbYgoh6S4tryiaY2EiauhrtZsH3f3tBDn6aQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;分享，点赞，在看，安排一下？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b6f2b3a3a8f880b1c28a9eb92df44daf</guid>
<title>一文领略 HTTP 的前世今生</title>
<link>https://toutiao.io/k/x8q4huu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;每个时代，都不会亏待会学习的人。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 协议在当今的互联网可谓是随处可见，一直默默的在背后支持着网络世界的运行，对于我们程序员来说 HTTP 更是熟悉不过了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平日里我们都说架构是演进的，需求推动着技术的迭代、更新和进步，对于 HTTP 协议来说也是如此。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知你是否有想过 HTTP 协议是如何诞生的，一开始是怎样的，又是怎么一步一步发展到今天的 HTTP/3 ?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中经历了哪些不为人知的秘密？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我就想和大家一起来看一看 HTTP 的演进之路，来看看它是如何从一个小宝宝成长为现在统治互联网的存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过在此之前，我们先简单的看看互联网的始祖-阿帕网的一段小历史，还是很有趣的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;互联网的始祖-阿帕网&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 1950 年代，通信研究者们认识到不同计算机用户和网络之间的需要通信，这促使了分布式网络、排队论和封包交互的研究。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在1958 年2月7日，美国国防部长尼尔 · 麦克尔罗伊发布了国防部 5105.15 号指令，建立了高级研究计划局(ARPA) 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.559322033898305&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbLibKic0AJ97yJzbS8JmbpHj7KuUezKIUvlSYxFWbFB4uvxOanTFxdbEew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ARPA 的核心机构之一 IPTO（信息处理处）赞助的一项研究导致了阿帕网的开发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看看这段历史。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 1962 年，ARPA 的主任聘请约瑟夫·利克莱德担任 IPTO 的第一任主任，他是最早预见到现代交互计算及其在各种应用的人之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IPTO 资助了先进的计算机和网络技术的研究，并委托十三个研究小组对人机交互和分布式系统相关技术进行研究。&lt;span&gt;每个小组获得的预算是正常研究补助金的三十至四十倍。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是财大气粗啊，研究人员肯定是干劲十足！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 1963 年利克莱德资助了一个名为 MAC 的研究项目，&lt;span&gt;该项目旨在探索在分时计算机上建立社区的可能性&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个项目对 IPTO 和更广泛的研究界产生了持久的影响，成为广泛联网的原型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且利克莱德的全球网络愿景极大地影响了他在 IPTO 的继任者们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1964 年利克莱德跳槽到了 IBM，第二任主任萨瑟兰上线，他创建了革命性的 Sketchpad 程序，用于存储计算机显示器的内存，在 1965 年他与麻省理工学院的劳伦斯 · 罗伯茨签订了 IPTO 合同，以进一步发展计算机网络技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后，罗伯茨和托马斯 · 梅里尔在麻省理工学院的 TX-2 计算机和加利福尼亚的 Q-32 计算机之间，&lt;span&gt;通过拨号电话连接实现了第一个数据包交换&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1966 年第三任主任鲍勃 · 泰勒上任，他深受利克莱德的影响，巧的是泰勒和利克莱德一样也是个心理声学家。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.50354609929078&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbLrT723Qy87HHlNY0YWNnn4DW38xYtU0Ry5HHk4lzjBvc4NCoX6xa8pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;141&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在泰勒的 IPTO 办公室里有三个不同的终端连接到三个不同的研究站点，他意识到这种架构将严重限制他扩展访问多个站点的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是他想着把一个终端连接到一个可以访问多个站点的网络上，并且从他在五角大楼的职位来说，他有这个能力去实现这个愿景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;美国国防部高级研究计划局局长查理 · 赫茨菲尔德向泰勒承诺，如果 IPTO 能够组织起来，他将提供 100 万美元用于建立一个分布式通信网络。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泰勒一听舒服了，然后他对罗伯茨的工作印象很深刻，邀请他加入并领导这项工作，然后罗伯茨却不乐意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泰勒不高兴了，于是要求赫茨菲尔德&lt;span&gt;让林肯实验室的主任向罗伯茨施压，要求他重新考虑&lt;/span&gt;，这最终促使罗伯茨缓和了态度，于1966年12月加入 IPTO 担任首席科学家。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3277310924369747&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbLywWo0ibfiaDDmxDPBzmCkCibsPGkiaGiaxr510tCbJMP1xGzdib9bA5rjaIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;238&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 1968 年6月3日，罗伯茨向泰勒描述了建立阿帕网的计划，18 天后，也就是 6 月 21 日，泰勒批准了这个计划，14 个月后&lt;span&gt;阿帕网建立&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当阿帕网顺利发展时，泰勒于 1969 年9月将 IPTO 的管理权移交给罗伯茨。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后罗伯茨离开 ARPA 成为 Telenet 的 CEO ，而利克莱德再次回到 IPTO 担任董事，以完成该组织的生命周期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，这段历史暂告一段落，可以看到阿帕网之父罗伯茨还是被施压的才接受这项任务，&lt;span&gt;最终创建了阿帕网，互联网的始祖&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也多亏了利克莱德的远见和砸钱促进了技术的发展，ARPA 不仅成为网络诞生地，同样也是电脑图形、平行过程、计算机模拟飞行等重要成果的诞生地。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;历史就是这么的巧合和有趣。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;互联网的历史&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 1973 年 ARPA 网扩展成互联网，第一批接入的有英国和挪威计算机，逐渐地成为网络连接的骨干。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1974 年 ARPA 的罗伯特·卡恩和斯坦福的文顿·瑟夫提出TCP/IP 协议。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1986 年，美国国家科学基金会（National Science Foundation，NSF）建立了大学之间互联的骨干网络 NSFNET ，这是互联网历史上重要的一步，NSFNET 成为新的骨干，1990 年 ARPANET 退役。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 1990 年 ，&lt;span&gt;蒂姆·伯纳斯-李（下文我就称李老）&lt;/span&gt; 创建了运行万维网所需的所有工具：超文本传输协议（HTTP）、超文本标记语言（HTML）、第一个网页浏览器、第一个网页服务器和第一个网站。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.236331569664903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbLlq0lickjLkYUPeaRrjUE2ZCyeeYiaTgostTP8r97QNyJUx5eg3Ybowng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;567&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，互联网开启了快速发展之路，HTTP 也开始了它的伟大征途。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有很多有趣的历史，比如第一次浏览器大战等等，之后有机会再谈，今天我们的主角是 HTTP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们就看看 HTTP 各大版本的演进，来看看它是如何成长到今天这个样子的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HTTP / 0.9 时代&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 1989 年，李老发表了一篇论文，文中提出了三项现在看来很平常的三个概念。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;URI，统一资源标识符，作为互联网上的唯一标识。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HTML，超文本标记语言，描述超文本。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HTTP ，超文本传输协议，传输超文本。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后李老就付之于行动，把这些都搞出来了，称之为万维网（World Wide Web）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那时候是互联网初期，计算机的处理能力包括网速等等都很弱，所以 HTTP 也逃脱不了那个时代的约束，&lt;span&gt;因此设计的非常简单，而且也是纯文本格式&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;李老当时的想法是文档存在服务器里面，我们只需要从服务器获取文档，&lt;span&gt;因此只有 “GET”，也不需要啥请求头，并且拿完了就结束了，因此请求响应之后连接就断了&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是为什么 HTTP 设计为文本协议，并且一开始只有“GET”、响应之后连接就断了的原因了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们现在看来这协议太简陋了，但是在当时这是互联网发展的一大步！&lt;span&gt;一个东西从无到有是最困难的&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候的 HTTP 还没有版本号的，之所以称之为 HTTP / 0.9 是后人加上去了，为了区别之后的版本。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HTTP 1.0 时代&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人们的需求是无止尽的，随着图像和音频的发展，浏览器也在不断的进步予以支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 1995 年又开发出了 Apache，简化了 HTTP 服务器的搭建，越来越多的人用上了互联网，这也促进了 HTTP 协议的修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需求促使添加各种特性来满足用户的需求，经过了一系列的草案 HTTP/1.0 于 1996 年正式发布。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Dave Raggett 在1995年领导了 HTTP 工作组，他希望通过扩展操作、扩展协商、更丰富的元信息以及与安全协议相关的安全协议来扩展协议，这种安全协议通过添加额外的方法和头字段来提高效率。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbLcuMwlShYOdkPKeLjxXr9TJEN7HQEnIfUmeiaZAUbVicdbs6kLgOJtibTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;201&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在 HTTP/1.0 版本主要增加以下几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;增加了 HEAD、POST 等新方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增加了响应状态码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入了头部，即请求头和响应头。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在请求中加入了 HTTP 版本号。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入了 Content-Type ，使得传输的数据不再限于文本。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到引入了新的方法，填充了操作的语义，像  HEAD 还可以只拿元信息不必传输全部内容，提高某些场景下的效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入的响应状态码让请求方可以得知服务端的情况，可以区分请求出错的原因，不会一头雾水。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入了头部，使得请求和响应更加的灵活，把控制数据和业务实体进行了拆分，也是一种解耦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新增了版本号表明这是一种工程化的象征，说明走上了正途，毕竟没版本号无法管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入了 Content-Type，支持传输不同类型的数据，丰富了协议的载体，充实了用户的眼球。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是那时候 HTTP/1.0 还不是标准，没有实际的约束力，各方势力不吃这一套，大白话就是你算老几。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HTTP 1.1 时代&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP/1.1 版本在 1997 的 RFC 2068 中首次被记录，从 1995 年至 1999 年间的第一次浏览器大战，极大的推动了 Web 的发展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着发展 HTTP/1.0 演进成了 HTTP/1.1，并且在 1999 年废弃了之前的 RFC 2068，发布了 RFC 2616。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从版本号可以得知这是一个小版本的更新，更新主要是因为 HTTP/1.0 很大的性能问题，就是每请求一个资源都得新建一个 TCP 连接，而且只能串行请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在 HTTP/1.1 版本主要增加以下几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;新增了连接管理即 keepalive ，允许持久连接。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持 pipeline，无需等待前面的请求响应，即可发送第二次请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;允许响应数据分块（chunked），即响应的时候不标明Content-Length，客户端就无法断开连接，直到收到服务端的 EOF ，利于传输大文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新增缓存的控制和管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加入了 Host 头，用在你一台机子部署了多个主机，然后多个域名解析又是同一个 IP，此时加入了 Host 头就可以判断你到底是要访问哪个主机。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4723865877712032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbLYA2HiaJl6qGL8a7cicRKXztL5uj3r2ytvDzYWC7MIl77GKDiahqnQf1oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到浏览器大战推进了 Web 的发展，也暴露出 HTTP/1.0 的不足之处，毕竟网络带宽等等都在进步，总不能让协议限制了硬件的发展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此提出了 HTTP/1.1 ，主要是为了解决性能的问题，包括支持持久连接、pipeline、缓存管理等等，也添加了一些特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再后来到 2014 年对 HTTP/1.1 又做了一次修订，因为其太过庞大和复杂，因此进行了拆分，弄成了六份小文档 RFC7230 - RFC7235&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候 HTTP/1.1 已经成了标准，其实标准往往是在各大强力竞争对手相对稳定之后建立的，因为标准意味着统一，统一就不用费劲心思去兼容各种玩意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;只有强大的势力才能定标准，当你足够强大的时候你也可以定标准，去挑战老标准。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HTTP 2 时代&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着 HTTP/1.1 的发布，互联网也开始了爆发式的增长，这种增长暴露出 HTTP 的不足，主要还是性能问题，而 HTTP/1.1 无动于衷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是人的惰性，也符合平日里我们对产品的演进，当你足够强大又安逸的时候，任何的改动你是不想理会的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;别用咯。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbLoyDn9skfLGBTWVHqOqno2kjoD1Bicb2hUrJ7VvRd2JG8wkwKhKXsxfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候 Google 看不下去了，你不搞是吧？我自己搞我的，我自己和我自己玩，我用户群体大，我有 Chrome，我服务多了去了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Google 推出了 SPDY 协议，凭借着它全球的占有率超过了 60% 的底气，2012年7月，开发 SPDY 的小组公开表示，它正在努力实现标准化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 坐不住了，之后互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP/2 版本主要增加以下几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;是二进制协议，不再是纯文本。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持一个 TCP 连接发起多请求，移除了 pipeline。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;利用 HPACK 压缩头部，减少数据传输量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;允许服务端主动推送数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从文本到二进制&lt;/span&gt;其实简化了整齐的复杂性，解析数据的开销更小，数据更加紧凑，减少了网络的延迟，提升了整体的吞吐量。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24888888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbLsAYO63eTQ5We9Moqkx9S7GSgVY8ic4LlBYS0HCYTia2aavich2RKTGxgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;675&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;支持一个 TCP 连接发起多请求&lt;/span&gt;，即支持多路复用，像 HTTP/1.1 pipeline 还是有阻塞的情况，&lt;span&gt;需要等前面的一个响应返回了后面的才能返回&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而多路复用就是完全异步化，这减少了整体的往返时间（RTT），&lt;span&gt;解决了 HTTP 队头阻塞问题，也规避了 TCP 慢启动带来的影响&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;HPACK 压缩头部&lt;/span&gt;，采用了静态表、动态表和哈夫曼编码，在客户端和服务器都维护请求头的列表，所以只需要增量和压缩过的头部信息，服务端拿到之后组装一下就能得到完整的头部信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;形象一点就是如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4391691394658754&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbLT5Rm7rtaVZVx2FnAWCCQzARwLWI5ibdbKCIGHdXZeQCOTN9KuibZvuXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;674&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再具体一点就是下图这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33250311332503113&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbLJLvZTRSibcZ93ewBSx3Z2HDOCIibWnTYLicO3UaNsVoibvkdq3vcbtKDhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;803&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;服务端主动推送数据&lt;/span&gt;，这个其实就是减少了请求的次数，比如客户端请求 1.html，我把 1.html 需要的 js 和 css 也一块送过去，省的之后客户端再请求我要 js ，我要这个 css。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 HTTP/2 的整体演进都是往性能优化的角度发展，因为此时的性能就是痛点，&lt;span&gt;任何东西的演进都是哪里痛医哪里。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然有一些例外，比如一些意外，或者就是“闲的蛋疼”的那种捯饬。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次推进属于用户揭竿而起为之，你再不给我升级我自己搞了，我有着资本，你自己掂量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终结果是好的，Google 后来放弃了 SPDY ，拥抱标准，而 HTTP/1.1 这个历史包袱太重了，所以 HTTP/2 到现在也只有大致一半的网站使用它。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7312186978297162&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbLia67F5ceNVIxiaKW9mLaUzUP2wiajSEYojhqPS4VMPoSw7oMDibOssVdDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;599&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HTTP 3 时代&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这 HTTP/2 还没捂热， HTTP/3 怎么就来了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次又是 Google，它自己突破自己，主要也是源自于痛点，这次的痛点来自于 HTTP 依赖的 TCP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCP 是面向可靠的、有序的传输协议&lt;/span&gt;，因此会有失败重传和按序机制，而 HTTP/2 是所有流共享一个 TCP 连接，所以会有 &lt;span&gt;TCP 层面的队头阻塞&lt;/span&gt;，当发生重传时会影响多个请求响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且 &lt;span&gt;TCP 是基于四元组（源IP，源端口，目标IP，目标端口）来确定连接的&lt;/span&gt;，而在移动网络的情况下 IP 地址会频繁的换，这会导致反复的建连。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有 TCP 与 TLS 的叠加握手，增加了延时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题就出在 TCP 身上，所以 Google 就把目光瞄向了 UDP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UDP 我们知道是无连接的，不管什么顺序，也不管你什么丢包，而 TCP 我在之前的文章说的很清楚了&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjEyNTk1Ng==&amp;amp;mid=2247485428&amp;amp;idx=1&amp;amp;sn=162d5b7b5746af08fafaf7cd28aa0970&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;TCP疑难杂症解析&lt;/a&gt;不了解的同学可以去看看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单的说就是 TCP 太无私了，或者说太保守了，现在需要一种更激进的做法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那怎么搞? TCP 改不动我就换！然后把 TCP 可靠、有序的功能提到应用层来实现，因此 Google 就研究出了 QUIC 协议。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30451612903225805&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbLSQwviawo819KzDPy9ACZ2EfDlNoE7JFD4WjX16nVNibb1HE0aib8rWhLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;775&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;QUIC 层来实现自己的丢包重传和拥塞控制，还有出于安全的考虑我们都会用 HTTPS ，所以需要多次握手。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8050847457627118&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbL7ZZrRCaZWUWwUHvWyo5Wmaunm8s8GM1kVWNAHV6J7V2SenO3t7RWZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我也已经提到了关于四元组的情况，所以在移动互联网时代这握手的消耗就更加放大了，于是 QUIC 引入了个叫 Connection ID 来标识一个链接，所以切换网络之后可以复用这个连接，达到 0 RTT 就能开始传输。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.29073482428115016&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbLDL82wJ2fDw4ZP1icjSeVEiauopd0pVrWMibGeQ1LICCVHdpwrSdj80qLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意上图是在已经和服务端握过手之后的，由于网络切换等原因才有 0 RTT ，&lt;span&gt;也就是 Connection ID 在之前生成过了&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是第一次建连还是需要多次握手的，我们来看一下&lt;span&gt;简化&lt;/span&gt;的握手对比图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5251017639077341&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbL9uvFQ7x0oCbEVE16Hu2icXpCDrsJg9EOThm6ibSkA7DxKLQlXFcGUJdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以所谓的 0RTT 是在之前已经建连的情况下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然还有 HTTP/2 提到的 HPACK，这个是依赖 TCP 的可靠、有序传输的，于是 QUIC 得搞了个 QPACK，也采用了静态表、动态表和哈夫曼编码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它丰富了 HTTP/2 的静态表，从 61 项加到了 98 项。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到的动态表，是用来存储未包含在静态表中的头部项，假设动态表还未收到，后面来解头部的时候肯定要被阻塞的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 QPACK 就另开一条路，在单向的 Stream 里传输动态表的编解码，单向传输好了，接受端到才能开始解码，也就是说&lt;span&gt;还没好你就先别管，防止做一半卡住了&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那还有前面提到的 TCP 队头阻塞， &lt;span&gt;QUIC 是怎么解决的呢？毕竟它也要保证有序和可靠啊。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 TCP 不认识每个流分别是哪个请求的，所以它只能全部阻塞住，而 QUIC 知道，因此比如请求 A 丢包了，我就把 A 卡住了就行，请求 B 完全可以全部放行，丝毫不受影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到基于 UDP 的 QUIC 还是很强大的，而且人家用户多，在 2018 年，互联网标准化组织 IETF 提议将 &lt;span&gt;HTTP over QUIC 更名为 HTTP/3 并获得批准&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到需求又推动技术的进步，由于 TCP 自身机制的限制，我们的目光已经往 UDP 上靠了，那 TCP 会不会成为历史呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们拭目以待。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们大致过了一遍 HTTP 发展的历史和它的演进之路，可以看到技术是源于需求，需求推动着技术的发展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本质上就是人的惰性，只有痛了才会成长&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且标准其实也是巨头们为了他们的利益推动的，不过标准确实能减轻对接的开销，统一而方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然就 HTTP 来说还是有很多内容的，有很多细节，很多算法，比如拿 Connection ID 来说，不同的四元组你如何保证请求一定会转发到之前的服务器上？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以今天我只是浅显的谈了谈大致的演进，具体的实现还是得靠各位自己摸索，或者之后有机会我再写一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过相对于这些实现细节我更感兴趣的是历史的演进，这能让我从时代背景等一些约束来得知，为什么这东西一开始是这么设计的，从而更深刻的理解这玩意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且历史还是很有趣的，不是么？&lt;/p&gt;&lt;section&gt;&lt;mp-qa class=&quot;js_uneditable custom_select_card qa_iframe&quot; data-pluginname=&quot;insertquestion&quot; data-id=&quot;1535339035924234241&quot; data-bizuin=&quot;Mzg2MjEyNTk1Ng==&quot; data-title=&quot;不是么？&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后的最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;个人能力有限，如有纰漏请赶紧联系鞭挞我，如果想进群就&lt;span&gt;备注下进群&lt;/span&gt;，我拉你。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果觉得文章不错还望点个在看支持一下哟。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1018711018711018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibntXq66mzuJBQHSibexlBbLxkTSgs85sssyIuiby671OmZmf4ALyclVUCyEsWqOU3hciajsHLRtUDLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot;/&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是 yes，从一点点到亿点点，我们下篇见&lt;/span&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;巨人的肩膀&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://www.livinginternet.com/i/ii_ipto.htm&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://jacobianengineering.com/blog/2016/11/1543/&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://w3techs.com/technologies/details/ce-http2&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://www.verizondigitalmedia.com/blog/how-quic-speeds-up-all-web-applications/&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://www.oreilly.com/content/http2-a-new-excerpt/&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://www.darpa.mil/about-us/timeline/dod-establishes-arpa&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://en.wikipedia.org/wiki/ARPANET&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;https://en.wikipedia.org/wiki/Internet&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;深入剖析HTTP/3协议 ,陶辉&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;透视HTTP协议 ,罗剑锋&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8b94ef0c1af2832632aedb86b80a0587</guid>
<title>Kubernetes Ingress 入门指南和实践练习</title>
<link>https://toutiao.io/k/8dpctvj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Ingress&lt;/strong&gt;也是Kubernetes项目里的一种 &lt;strong&gt;API&lt;/strong&gt; 对象，它公开了从集群外部到集群内&lt;code&gt;Service&lt;/code&gt;的 &lt;strong&gt;HTTP&lt;/strong&gt; 和 &lt;strong&gt;HTTPS&lt;/strong&gt; 路由，这些路由由 Ingress 资源上定义的规则控制。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    internet&lt;br/&gt;        |&lt;br/&gt;   [ Ingress ]&lt;br/&gt;   --|-----|--&lt;br/&gt;   [ Services ]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用一句话概况&lt;code&gt;Ingress&lt;/code&gt;的话就是：&lt;code&gt;Ingress&lt;/code&gt;是&lt;code&gt;Service&lt;/code&gt;们的反向代理。通过看&lt;code&gt;Ingress&lt;/code&gt;对象的定义你会感觉自己在看&lt;code&gt;Nginx&lt;/code&gt;的配置文件一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Ingress&lt;/code&gt;资源对象的&lt;code&gt;YAML&lt;/code&gt;定义。与大多数Kubernetes资源一样，也需要&lt;code&gt;apiVersion&lt;/code&gt;，&lt;code&gt;Kind&lt;/code&gt;，&lt;code&gt;Metadata&lt;/code&gt;和&lt;code&gt;Spec&lt;/code&gt; 这些组成部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个典型的&lt;code&gt;Ingress&lt;/code&gt;对象的定义如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;extensions/v1beta1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Ingress&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  name:&lt;/span&gt; &lt;span&gt;app-ingress&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  rules:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    - host:&lt;/span&gt; &lt;span&gt;app.example.com&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      http:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        paths:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;          - path:&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            backend:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              serviceName:&lt;/span&gt; &lt;span&gt;app-service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              servicePort:&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;&lt;span&gt;          - path:&lt;/span&gt; &lt;span&gt;/v2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            backend:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              serviceName:&lt;/span&gt; &lt;span&gt;app-service-v2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              servicePort:&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面这个&lt;code&gt;Ingress&lt;/code&gt;的&lt;code&gt;YAML&lt;/code&gt;定义中，最值得我们关注的，是&lt;strong&gt;spec.rules&lt;/strong&gt; 字段。在 Kubernetes 里，这个字段叫作：&lt;strong&gt;IngressRule&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;IngressRule&lt;/code&gt; 里面 &lt;strong&gt;host&lt;/strong&gt; 字段定义的值，就是这个&lt;code&gt;Ingress&lt;/code&gt;的入口。当访问 &lt;code&gt;app.example.com&lt;/code&gt; 的时候，实际上访问到的是这个 &lt;code&gt;Ingress&lt;/code&gt; 对象。这样就能使用 IngressRule 来对请求进行下一步转发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;IngressRule&lt;/code&gt; 的定义，主要依赖于&lt;code&gt;path&lt;/code&gt;字段。可以简单地理解为，这里的每一个&lt;code&gt;path&lt;/code&gt;都对应一个后端 &lt;code&gt;Service&lt;/code&gt;。上面的例子里，定义了两个&lt;code&gt;path&lt;/code&gt;，它们分别对应：&lt;strong&gt;app-service&lt;/strong&gt;和&lt;strong&gt;app-service-v2&lt;/strong&gt; 两个后端&lt;code&gt;Service&lt;/code&gt;。通过&lt;code&gt;Service&lt;/code&gt;，流量最终会到达&lt;code&gt;Service&lt;/code&gt;后面的&lt;code&gt;Pod&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;servicePort&lt;/strong&gt;字段指定的端口值就是在&lt;code&gt;Service&lt;/code&gt;的定义里&lt;code&gt;port&lt;/code&gt;字段的值，上一篇讲Service的文章里已经科普了一下&lt;code&gt;Service&lt;/code&gt;定义里的&lt;code&gt;nodePort&lt;/code&gt;，&lt;code&gt;port&lt;/code&gt;和&lt;code&gt;targetPort&lt;/code&gt;都是什么意思，感觉到懵圈（我自己都有点懵）的读者大大可以翻阅一下文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486082&amp;amp;idx=1&amp;amp;sn=42a9bc8fcfc9da09445e9e2f4cf2fb96&amp;amp;chksm=fa80db15cdf752039494992f71a3bc488cf386841bd1aaaa44115f5e7f155ba55ce468ec89ee&amp;amp;token=1964476830&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;学练结合，快速掌握Kubernetes Service&lt;/a&gt;》里的这部分内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 &lt;code&gt;Ingress&lt;/code&gt; 对象，其实就是 &lt;code&gt;Kubernetes&lt;/code&gt; 项目对&lt;strong&gt;&quot;反向代理&quot;&lt;/strong&gt;的一种抽象。一个 &lt;code&gt;Ingress&lt;/code&gt;对象的主要内容，实际上就是一个&quot;反向代理&quot;服务的配置文件的描述。而这个代理服务对应的转发规则，就是 &lt;code&gt;IngressRule&lt;/code&gt;。这就是为什么在每条 &lt;code&gt;IngressRule&lt;/code&gt; 里，需要有一个 &lt;strong&gt;host&lt;/strong&gt; 字段来作为这条 &lt;code&gt;IngressRule&lt;/code&gt; 的入口，然后还需要有一系列 &lt;code&gt;path&lt;/code&gt; 字段来声明具体的转发策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了&lt;code&gt;Ingress&lt;/code&gt;后我们还需要&lt;code&gt;Ingress Controller&lt;/code&gt;，它会根据你定义的&lt;code&gt;Ingress&lt;/code&gt;对象，提供对应的代理能力。目前，业界常用的各种反向代理项目，比如 Nginx、Envoy 等，都已经为 Kubernetes 专门维护了对应的 Ingress Controller。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我就用最常用的Nginx Ingress Controller给这个系列教程一直以来用的Demo实践应用一下Ingress&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;安装Ingress Controller&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为&lt;code&gt;Minikube&lt;/code&gt;里边内置了Nginx Ingress Controller这个插件， 默认没有启用，所以如果是在&lt;code&gt;Minikube&lt;/code&gt;这个单节点集群里实践的话只需要执行下面的命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;minikube addons enable ingress&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;检查验证 Nginx Ingress 控制器处于运行状态：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kubectl get pods -n kube-system --filed-selector=Running&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有下图红框里的&lt;code&gt;Pod&lt;/code&gt;就证明已经安装成功了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3357271095152603&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f7Cibmniccgicp2LOuOxgpXxicZ3QGjssI5jSX23qjj8BNPddYtehC9vonXtoL4nQUXYnF2LmOvaZwk7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1114&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;因为这个Pod用的官方镜像是在红帽软件的镜像库里，所以安装时间可能会有点长，也可能会失败，如果网络条件允许的话可以在准备阶段先执行 docker pull http://quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.32.0 把镜像下载到本地。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外还有不少安装&lt;code&gt;Nginx Ingress Controller&lt;/code&gt;的方式，比如用Kubernetes的包管理工具&lt;strong&gt;Helm&lt;/strong&gt;安装，这些安装方式可以参考&lt;span&gt;官方的部署指南&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建Ingress&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们之前给应用&lt;code&gt;Pod&lt;/code&gt;创建的&lt;code&gt;Service&lt;/code&gt;名字叫&lt;strong&gt;app-service&lt;/strong&gt;，&lt;code&gt;port&lt;/code&gt;字段指定的是端口80&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;➜  ~ kubectl get svc&lt;br/&gt;NAME          TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE&lt;br/&gt;app-service   NodePort    10.108.26.155   &amp;lt;none&amp;gt;        80:30080/TCP   6d16h&lt;br/&gt;kubernetes    ClusterIP   10.96.0.1       &amp;lt;none&amp;gt;        443/TCP        96d&lt;br/&gt;&lt;br/&gt;➜  ~ kubectl describe svc app-service&lt;br/&gt;Name:                     app-service&lt;br/&gt;Namespace:                default&lt;br/&gt;Labels:                   &amp;lt;none&amp;gt;&lt;br/&gt;Annotations:              &amp;lt;none&amp;gt;&lt;br/&gt;Selector:                 app=go-app&lt;br/&gt;Type:                     NodePort&lt;br/&gt;IP:                       10.108.26.155&lt;br/&gt;Port:                     http  80/TCP&lt;br/&gt;TargetPort:               3000/TCP&lt;br/&gt;NodePort:                 http  30080/TCP&lt;br/&gt;Endpoints:                10.1.0.24:3000,10.1.0.25:3000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就确定了我们要创建建的&lt;code&gt;Ingress&lt;/code&gt;对象，第一个&lt;code&gt;path&lt;/code&gt; 里要设置的&lt;strong&gt;backend.serviceName&lt;/strong&gt;和&lt;strong&gt;backend.servicePort&lt;/strong&gt;字段的值，Ingress对象的&lt;code&gt;YAML&lt;/code&gt;定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# app-ingress.yaml&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;extensions/v1beta1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Ingress&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  name:&lt;/span&gt; &lt;span&gt;app-ingress&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  rules:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    - host:&lt;/span&gt; &lt;span&gt;app.example.com&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      http:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        paths:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;          - path:&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            backend:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              serviceName:&lt;/span&gt; &lt;span&gt;app-service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              servicePort:&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;说明：因为目前为止我们只创建了一个Service，所以在Ingress里也只能设置一个path。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个Ingress定义里设置的&lt;code&gt;IngressRules&lt;/code&gt;是把所有对app.example.com入口的请求都路由到&lt;code&gt;app-service&lt;/code&gt;这个&lt;code&gt;Service&lt;/code&gt;的80端口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义好&lt;code&gt;Ingress&lt;/code&gt;对象后，也是执行&lt;strong&gt;kubectl apply -f&lt;/strong&gt;创建对象，可以看到所有的对象的创建和更新都可以用&lt;strong&gt;apply&lt;/strong&gt;操作搞定，这就是&lt;code&gt;Kubernetes&lt;/code&gt;项目声明式定义的好处。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kubectl apply -f app-ingress.yaml --record&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 执行后的输出&lt;/span&gt;&lt;br/&gt;ingress.networking.k8s.io/app-ingress created&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;验证Ingress&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询Ingress是否创建成功，使用通用的&lt;strong&gt;kubectl get&lt;/strong&gt;命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;➜  ~ kubectl get ingress&lt;br/&gt;NAME          CLASS    HOSTS             ADDRESS        PORTS   AGE&lt;br/&gt;app-ingress   &amp;lt;none&amp;gt;   app.example.com   192.168.64.4   80      20s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有可能需要在提交创建操作几分钟后才能在集群里查询到Ingress&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在集群里查询到Ingress后，就可以通过&lt;strong&gt;kubctl describe ingress&lt;/strong&gt;命令查看&lt;code&gt;Ingress&lt;/code&gt;对象是否按照我们的定义成功代理了&lt;code&gt;app-service&lt;/code&gt;这个&lt;code&gt;Service&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;➜  ~ kubectl describe ingress app-ingress&lt;br/&gt;Name:             app-ingress&lt;br/&gt;Namespace:        default&lt;br/&gt;Address:          192.168.64.4&lt;br/&gt;Default backend:  default-http-backend:80 (&amp;lt;error: endpoints &quot;default-http-backend&quot; not found&amp;gt;)&lt;br/&gt;Rules:&lt;br/&gt;  Host             Path  Backends&lt;br/&gt;  ----             ----  --------&lt;br/&gt;  app.example.com&lt;br/&gt;                   /   app-service:80 (10.1.0.24:3000,10.1.0.25:3000)&lt;br/&gt;Annotations:       kubernetes.io/change-cause: kubectl apply --filename=app-ingress.yaml --record=true&lt;br/&gt;Events:            &amp;lt;none&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面输出里的&lt;code&gt;Rlues&lt;/code&gt;部分可以清楚的看到，把&lt;strong&gt;Host:   app.example.com&lt;/strong&gt;所有请求（定义了Path是/）都代理到了后端&lt;code&gt;app-service&lt;/code&gt;的&lt;span&gt;80端口，Service后面的&lt;/span&gt;&lt;code&gt;Pod&lt;/code&gt;&lt;span&gt;正是它的&lt;/span&gt;&lt;code&gt;Endpoints&lt;/code&gt;&lt;span&gt;，与上面的&lt;/span&gt;&lt;strong&gt;kubctl describe svc app-service&lt;/strong&gt;&lt;span&gt;命令输出里的&lt;/span&gt;&lt;code&gt;Endpoints&lt;/code&gt;&lt;span&gt;信息一致。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来在&lt;code&gt;/etc/hosts&lt;/code&gt;文件里追加下面的内容，就能通过域名访问我们的服务了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;192.168.64.4 app.example.com&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你们在练习的时候，可以自己尝试新增一个&lt;code&gt;Service&lt;/code&gt;，然后更新Ingress，再指定一个&lt;code&gt;/v2&lt;/code&gt;之类的Path，让所有匹配这个规则的请求都能路由给新的Service。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;接下来&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Ingress&lt;/code&gt;还有很多其他的配置，想要简单的讲完，还是挺难的。最常用的比如怎么设置TLS私钥和证书这些配置在&lt;span&gt;Kubernetes官方文档-Ingress&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 部分都有提到，后面自己练习的时候可以试试给&lt;code&gt;Ingress&lt;/code&gt;启用&lt;code&gt;HTTPs&lt;/code&gt;访问的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里了，如果喜欢我的文章就帮我点个赞和在看吧，我会每周通过技术文章分享我的所学所见和第一手实践经验，感谢你的支持。微信搜索关注公众号「网管叨bi叨」第一时间获取我的文章推送。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;官方的部署指南: &lt;span&gt;https://kubernetes.github.io/ingress-nginx/deploy/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Kubernetes官方文档-Ingress: &lt;span&gt;https://kubernetes.io/zh/docs/concepts/services-networking/ingress/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注公众号，获取更多精选技术原创文章&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0188679245283019&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4icJbGAQ8RjXUUVdUZsGADuMBVWePgn7tfrWjjHyc6b8kXTQ7Sdkp0QQFFK4mel5tniczqooMna1CA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5e20128738b18d40452ede84c27ec9f8</guid>
<title>面试官：兄弟，说说 ArrayList 和 LinkedList 有什么区别</title>
<link>https://toutiao.io/k/0xofen5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;ArrayList 和 LinkedList 有什么区别，是面试官非常喜欢问的一个问题。可能大部分小伙伴和我一样，能回答出“ArrayList 是基于数组实现的，LinkedList 是基于双向链表实现的。”&lt;/p&gt;&lt;p&gt;关于这一点，我之前的文章里也提到过了。但说实话，这样苍白的回答并不能令面试官感到满意，他还想知道的更多。&lt;/p&gt;&lt;p&gt;那假如小伙伴们继续做出下面这样的回答：&lt;/p&gt;&lt;p&gt;“ArrayList 在新增和删除元素时，因为涉及到数组复制，所以效率比 LinkedList 低，而在遍历的时候，ArrayList 的效率要高于 LinkedList。”&lt;/p&gt;&lt;p&gt;面试官会感到满意吗？我只能说，如果面试官比较仁慈的话，他可能会让我们回答下一个问题；否则的话，他会让我们回家等通知，这一等，可能意味着杳无音讯了。&lt;/p&gt;&lt;p&gt;为什么会这样呢？为什么为什么？回答的不对吗？&lt;/p&gt;&lt;p&gt;暴躁的小伙伴请喝口奶茶冷静一下。冷静下来后，请随我来，让我们一起肩并肩、手拉手地深入地研究一下 ArrayList 和 LinkedList 的数据结构、实现原理以及源码，可能神秘的面纱就揭开了。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;01、ArrayList 是如何实现的？&lt;/span&gt;&lt;/h3&gt;&lt;figure&gt;&lt;img data-ratio=&quot;2.0155440414507773&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpk9XU6vtj0fN6LsW7TyXVRtNTEMGFsm7uZWeKyH3WCFTDCL2LXfWdJd0q4YTT2R5wX93aSBRNcl6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;193&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;ArrayList 实现了 List 接口，继承了 AbstractList 抽象类，底层是基于数组实现的，并且实现了动态扩容。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ArrayList&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractList&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt;&lt;br/&gt;        &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;List&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt;, &lt;span&gt;RandomAccess&lt;/span&gt;, &lt;span&gt;Cloneable&lt;/span&gt;, &lt;span&gt;java&lt;/span&gt;.&lt;span&gt;io&lt;/span&gt;.&lt;span&gt;Serializable&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CAPACITY = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;transient&lt;/span&gt; Object[] elementData;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ArrayList 还实现了 RandomAccess 接口，这是一个标记接口：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;RandomAccess&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内部是空的，标记“实现了这个接口的类支持快速（通常是固定时间）随机访问”。快速随机访问是什么意思呢？就是说不需要遍历，就可以通过下标（索引）直接访问到内存地址。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Objects.checkIndex(index, size);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; elementData(index);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;E &lt;span&gt;elementData&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (E) elementData[index];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ArrayList 还实现了 Cloneable 接口，这表明 ArrayList 是支持拷贝的。ArrayList 内部的确也重写了 Object 类的 &lt;code&gt;clone()&lt;/code&gt; 方法。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;clone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        ArrayList&amp;lt;?&amp;gt; v = (ArrayList&amp;lt;?&amp;gt;) &lt;span&gt;super&lt;/span&gt;.clone();&lt;br/&gt;        v.elementData = Arrays.copyOf(elementData, size);&lt;br/&gt;        v.modCount = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; v;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (CloneNotSupportedException e) {&lt;br/&gt;        &lt;span&gt;// this shouldn&#x27;t happen, since we are Cloneable&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InternalError(e);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ArrayList 还实现了 Serializable 接口，同样是一个标记接口：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Serializable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内部也是空的，标记“实现了这个接口的类支持序列化”。序列化是什么意思呢？Java 的序列化是指，将对象转换成以字节序列的形式来表示，这些字节序中包含了对象的字段和方法。序列化后的对象可以被写到数据库、写到文件，也可用于网络传输。&lt;/p&gt;&lt;p&gt;眼睛雪亮的小伙伴可能会注意到，ArrayList 中的关键字段 elementData 使用了 transient 关键字修饰，这个关键字的作用是，让它修饰的字段不被序列化。&lt;/p&gt;&lt;p&gt;这不前后矛盾吗？一个类既然实现了 Serilizable 接口，肯定是想要被序列化的，对吧？那为什么保存关键数据的 elementData 又不想被序列化呢?&lt;/p&gt;&lt;p&gt;这还得从 “ArrayList 是基于数组实现的”开始说起。大家都知道，数组是定长的，就是说，数组一旦声明了，长度（容量）就是固定的，不能像某些东西一样伸缩自如。这就很麻烦，数组一旦装满了，就不能添加新的元素进来了。&lt;/p&gt;&lt;p&gt;ArrayList 不想像数组这样活着，它想能屈能伸，所以它实现了动态扩容。一旦在添加元素的时候，发现容量用满了 &lt;code&gt;s == elementData.length&lt;/code&gt;，就按照原来数组的 1.5 倍（&lt;code&gt;oldCapacity &amp;gt;&amp;gt; 1&lt;/code&gt;）进行扩容。扩容之后，再将原有的数组复制到新分配的内存地址上 &lt;code&gt;Arrays.copyOf(elementData, newCapacity)&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(E e, Object[] elementData, &lt;span&gt;int&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (s == elementData.length)&lt;br/&gt;        elementData = grow();&lt;br/&gt;    elementData[s] = e;&lt;br/&gt;    size = s + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Object[] grow() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; grow(size + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Object[] grow(&lt;span&gt;int&lt;/span&gt; minCapacity) {&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; oldCapacity = elementData.length;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (oldCapacity &amp;gt; &lt;span&gt;0&lt;/span&gt; || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; newCapacity = ArraysSupport.newLength(oldCapacity,&lt;br/&gt;                minCapacity - oldCapacity, &lt;span&gt;/* minimum growth */&lt;/span&gt;&lt;br/&gt;                oldCapacity &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;           &lt;span&gt;/* preferred growth */&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; elementData = Arrays.copyOf(elementData, newCapacity);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; elementData = &lt;span&gt;new&lt;/span&gt; Object[Math.max(DEFAULT_CAPACITY, minCapacity)];&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;动态扩容意味着什么？大家伙想一下。嗯，还是我来告诉大家答案吧，有点迫不及待。&lt;/p&gt;&lt;p&gt;意味着数组的实际大小可能永远无法被填满的，总有多余出来空置的内存空间。&lt;/p&gt;&lt;p&gt;比如说，默认的数组大小是 10，当添加第 11 个元素的时候，数组的长度扩容了 1.5 倍，也就是 15，意味着还有 4 个内存空间是闲置的，对吧？&lt;/p&gt;&lt;p&gt;序列化的时候，如果把整个数组都序列化的话，是不是就多序列化了 4 个内存空间。当存储的元素数量非常非常多的时候，闲置的空间就非常非常大，序列化耗费的时间就会非常非常多。&lt;/p&gt;&lt;p&gt;于是，ArrayList 做了一个愉快而又聪明的决定，内部提供了两个私有方法 writeObject 和 readObject 来完成序列化和反序列化。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(java.io.ObjectOutputStream s)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; java.io.IOException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// Write out element count, and any hidden stuff&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; expectedModCount = modCount;&lt;br/&gt;    s.defaultWriteObject();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Write out size as capacity for behavioral compatibility with clone()&lt;/span&gt;&lt;br/&gt;    s.writeInt(size);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Write out all elements in the proper order.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;size; i++) {&lt;br/&gt;        s.writeObject(elementData[i]);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (modCount != expectedModCount) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ConcurrentModificationException();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从 writeObject 方法的源码中可以看得出，它使用了 ArrayList 的实际大小 size 而不是数组的长度（&lt;code&gt;elementData.length&lt;/code&gt;）来作为元素的上限进行序列化。&lt;/p&gt;&lt;p&gt;此处应该有掌声啊！不是为我，为 Java 源码的作者们，他们真的是太厉害了，可以用两个词来形容他们——殚精竭虑、精益求精。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/z40lCFUAHpk9XU6vtj0fN6LsW7TyXVRtgbEEm5DOh77CU8WFouTScFVVVFRvaicz8gjRk8mD5d03FJ8OpT9kKjA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;110&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;02、LinkedList 是如何实现的？&lt;/span&gt;&lt;/h3&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7768518518518519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpk9XU6vtj0fN6LsW7TyXVRtXLFicYusdGPEDWNvACWFXaJk8RliaBDmJ3gqzKt7ZcxPvWIU2ImfATYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;LinkedList 是一个继承自 AbstractSequentialList 的双向链表，因此它也可以被当作堆栈、队列或双端队列进行操作。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LinkedList&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt;&lt;br/&gt;    &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractSequentialList&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt;&lt;br/&gt;    &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;List&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt;, &lt;span&gt;Deque&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt;, &lt;span&gt;Cloneable&lt;/span&gt;, &lt;span&gt;java&lt;/span&gt;.&lt;span&gt;io&lt;/span&gt;.&lt;span&gt;Serializable&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt; first;&lt;br/&gt;    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt; last;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;LinkedList 内部定义了一个 Node 节点，它包含 3 个部分：元素内容 item，前引用 prev 和后引用 next。代码如下所示：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    E item;&lt;br/&gt;    LinkedList.Node&amp;lt;E&amp;gt; next;&lt;br/&gt;    LinkedList.Node&amp;lt;E&amp;gt; prev;&lt;br/&gt;&lt;br/&gt;    Node(LinkedList.Node&amp;lt;E&amp;gt; prev, E element, LinkedList.Node&amp;lt;E&amp;gt; next) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.item = element;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.next = next;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.prev = prev;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;LinkedList 还实现了 Cloneable 接口，这表明 LinkedList 是支持拷贝的。&lt;/p&gt;&lt;p&gt;LinkedList 还实现了 Serializable 接口，这表明 LinkedList 是支持序列化的。眼睛雪亮的小伙伴可能又注意到了，LinkedList 中的关键字段 size、first、last 都使用了 transient 关键字修饰，这不又矛盾了吗？到底是想序列化还是不想序列化？&lt;/p&gt;&lt;p&gt;答案是 LinkedList 想按照自己的方式序列化，来看它自己实现的 &lt;code&gt;writeObject()&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(java.io.ObjectOutputStream s)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; java.io.IOException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// Write out any hidden serialization magic&lt;/span&gt;&lt;br/&gt;    s.defaultWriteObject();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Write out size&lt;/span&gt;&lt;br/&gt;    s.writeInt(size);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Write out all elements in the proper order.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (LinkedList.Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x = x.next)&lt;br/&gt;        s.writeObject(x.item);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发现没？LinkedList 在序列化的时候只保留了元素的内容 item，并没有保留元素的前后引用。这样就节省了不少内存空间，对吧？&lt;/p&gt;&lt;p&gt;那有些小伙伴可能就疑惑了，只保留元素内容，不保留前后引用，那反序列化的时候怎么办？&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;(java.io.ObjectInputStream s)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; java.io.IOException, ClassNotFoundException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// Read in any hidden serialization magic&lt;/span&gt;&lt;br/&gt;    s.defaultReadObject();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Read in size&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; size = s.readInt();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Read in all elements in the proper order.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i++)&lt;br/&gt;        linkLast((E)s.readObject());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;linkLast&lt;/span&gt;&lt;span&gt;(E e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; LinkedList.Node&amp;lt;E&amp;gt; l = last;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; LinkedList.Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; LinkedList.Node&amp;lt;&amp;gt;(l, e, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    last = newNode;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        first = newNode;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        l.next = newNode;&lt;br/&gt;    size++;&lt;br/&gt;    modCount++;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意 for 循环中的 &lt;code&gt;linkLast()&lt;/code&gt; 方法，它可以把链表重新链接起来，这样就恢复了链表序列化之前的顺序。很妙，对吧？&lt;/p&gt;&lt;p&gt;和 ArrayList 相比，LinkedList 没有实现 RandomAccess 接口，这是因为 LinkedList 存储数据的内存地址是不连续的，所以不支持随机访问。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;03、ArrayList 和 LinkedList 新增元素时究竟谁快？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;前面我们已经从多个维度了解了 ArrayList 和 LinkedList 的实现原理和各自的特点。那接下来，我们就来聊聊 ArrayList 和 LinkedList 在新增元素时究竟谁快？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）ArrayList&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;ArrayList 新增元素有两种情况，一种是直接将元素添加到数组末尾，一种是将元素插入到指定位置。&lt;/p&gt;&lt;p&gt;添加到数组末尾的源码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(E e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    modCount++;&lt;br/&gt;    add(e, elementData, size);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(E e, Object[] elementData, &lt;span&gt;int&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (s == elementData.length)&lt;br/&gt;        elementData = grow();&lt;br/&gt;    elementData[s] = e;&lt;br/&gt;    size = s + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很简单，先判断是否需要扩容，然后直接通过索引将元素添加到末尾。&lt;/p&gt;&lt;p&gt;插入到指定位置的源码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index, E element)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    rangeCheckForAdd(index);&lt;br/&gt;    modCount++;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; s;&lt;br/&gt;    Object[] elementData;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((s = size) == (elementData = &lt;span&gt;this&lt;/span&gt;.elementData).length)&lt;br/&gt;        elementData = grow();&lt;br/&gt;    System.arraycopy(elementData, index,&lt;br/&gt;            elementData, index + &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;            s - index);&lt;br/&gt;    elementData[index] = element;&lt;br/&gt;    size = s + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先检查插入的位置是否在合理的范围之内，然后判断是否需要扩容，再把该位置以后的元素复制到新添加元素的位置之后，最后通过索引将元素添加到指定的位置。这种情况是非常伤的，性能会比较差。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）LinkedList&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;LinkedList 新增元素也有两种情况，一种是直接将元素添加到队尾，一种是将元素插入到指定位置。&lt;/p&gt;&lt;p&gt;添加到队尾的源码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(E e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    linkLast(e);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;linkLast&lt;/span&gt;&lt;span&gt;(E e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; LinkedList.Node&amp;lt;E&amp;gt; l = last;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; LinkedList.Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; LinkedList.Node&amp;lt;&amp;gt;(l, e, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    last = newNode;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        first = newNode;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        l.next = newNode;&lt;br/&gt;    size++;&lt;br/&gt;    modCount++;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先将队尾的节点 last 存放到临时变量 l 中（不是说不建议使用 I 作为变量名吗？Java 的作者们明知故犯啊），然后生成新的 Node 节点，并赋给 last，如果 l  为 null，说明是第一次添加，所以 first 为新的节点；否则将新的节点赋给之前 last 的 next。&lt;/p&gt;&lt;p&gt;插入到指定位置的源码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index, E element)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    checkPositionIndex(index);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (index == size)&lt;br/&gt;        linkLast(element);&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        linkBefore(element, node(index));&lt;br/&gt;}&lt;br/&gt;LinkedList.&lt;span&gt;Node&amp;lt;E&amp;gt; &lt;span&gt;node&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// assert isElementIndex(index);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;)) {&lt;br/&gt;        LinkedList.Node&amp;lt;E&amp;gt; x = first;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; index; i++)&lt;br/&gt;            x = x.next;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        LinkedList.Node&amp;lt;E&amp;gt; x = last;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = size - &lt;span&gt;1&lt;/span&gt;; i &amp;gt; index; i--)&lt;br/&gt;            x = x.prev;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;linkBefore&lt;/span&gt;&lt;span&gt;(E e, LinkedList.Node&amp;lt;E&amp;gt; succ)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// assert succ != null;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; LinkedList.Node&amp;lt;E&amp;gt; pred = succ.prev;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; LinkedList.Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; LinkedList.Node&amp;lt;&amp;gt;(pred, e, succ);&lt;br/&gt;    succ.prev = newNode;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (pred == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        first = newNode;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        pred.next = newNode;&lt;br/&gt;    size++;&lt;br/&gt;    modCount++;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先检查插入的位置是否在合理的范围之内，然后判断插入的位置是否是队尾，如果是，添加到队尾；否则执行 &lt;code&gt;linkBefore()&lt;/code&gt; 方法。&lt;/p&gt;&lt;p&gt;在执行 &lt;code&gt;linkBefore()&lt;/code&gt; 方法之前，会调用 &lt;code&gt;node()&lt;/code&gt; 方法查找指定位置上的元素，这一步是需要遍历 LinkedList 的。如果插入的位置靠前前半段，就从队头开始往后找；否则从队尾往前找。也就是说，如果插入的位置越靠近 LinkedList 的中间位置，遍历所花费的时间就越多。&lt;/p&gt;&lt;p&gt;找到指定位置上的元素（succ）之后，就开始执行 &lt;code&gt;linkBefore()&lt;/code&gt; 方法了，先将 succ 的前一个节点（prev）存放到临时变量 pred 中，然后生成新的 Node 节点（newNode），并将 succ 的前一个节点变更为 newNode，如果 pred 为 null，说明插入的是队头，所以 first 为新节点；否则将 pred 的后一个节点变更为 newNode。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7403225806451613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpk9XU6vtj0fN6LsW7TyXVRtibry9l5KhM9H0pXuIFeF0tAqJZ9MJzMlICUW47MZFJYWo9pUSNRdHGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;经过源码分析以后，小伙伴们是不是在想：“好像 ArrayList 在新增元素的时候效率并不一定比 LinkedList 低啊！”&lt;/p&gt;&lt;p&gt;当两者的起始长度是一样的情况下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ArrayListTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addFromHeaderTest&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; num)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ArrayList&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;(num);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timeStart = System.currentTimeMillis();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (i &amp;lt; num) {&lt;br/&gt;            list.add(&lt;span&gt;0&lt;/span&gt;, i + &lt;span&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;            i++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timeEnd = System.currentTimeMillis();&lt;br/&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;ArrayList从集合头部位置新增元素花费的时间&quot;&lt;/span&gt; + (timeEnd - timeStart));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 微信搜「沉默王二」，回复关键字 PDF&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LinkedListTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addFromHeaderTest&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; num)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        LinkedList&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;String&amp;gt;();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timeStart = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (i &amp;lt; num) {&lt;br/&gt;            list.addFirst(i + &lt;span&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;            i++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timeEnd = System.currentTimeMillis();&lt;br/&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;LinkedList从集合头部位置新增元素花费的时间&quot;&lt;/span&gt; + (timeEnd - timeStart));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;num 为 10000，代码实测后的时间如下所示：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ArrayList从集合头部位置新增元素花费的时间595&lt;br/&gt;LinkedList从集合头部位置新增元素花费的时间15&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ArrayList 花费的时间比 LinkedList 要多很多。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ArrayListTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addFromMidTest&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; num)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ArrayList&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;(num);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timeStart = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (i &amp;lt; num) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; temp = list.size();&lt;br/&gt;            list.add(temp / &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;            i++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timeEnd = System.currentTimeMillis();&lt;br/&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;ArrayList从集合中间位置新增元素花费的时间&quot;&lt;/span&gt; + (timeEnd - timeStart));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LinkedListTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addFromMidTest&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; num)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        LinkedList&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;String&amp;gt;();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timeStart = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (i &amp;lt; num) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; temp = list.size();&lt;br/&gt;            list.add(temp / &lt;span&gt;2&lt;/span&gt;, i + &lt;span&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;            i++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timeEnd = System.currentTimeMillis();&lt;br/&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;LinkedList从集合中间位置新增元素花费的时间&quot;&lt;/span&gt; + (timeEnd - timeStart));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;num 为 10000，代码实测后的时间如下所示：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ArrayList从集合中间位置新增元素花费的时间1&lt;br/&gt;LinkedList从集合中间位置新增元素花费的时间101&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ArrayList 花费的时间比 LinkedList 要少很多很多。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ArrayListTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addFromTailTest&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; num)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ArrayList&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;(num);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timeStart = System.currentTimeMillis();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (i &amp;lt; num) {&lt;br/&gt;            list.add(i + &lt;span&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;            i++;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timeEnd = System.currentTimeMillis();&lt;br/&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;ArrayList从集合尾部位置新增元素花费的时间&quot;&lt;/span&gt; + (timeEnd - timeStart));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LinkedListTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addFromTailTest&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; num)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        LinkedList&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;String&amp;gt;();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timeStart = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (i &amp;lt; num) {&lt;br/&gt;            list.add(i + &lt;span&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;            i++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timeEnd = System.currentTimeMillis();&lt;br/&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;LinkedList从集合尾部位置新增元素花费的时间&quot;&lt;/span&gt; + (timeEnd - timeStart));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;num 为 10000，代码实测后的时间如下所示：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ArrayList从集合尾部位置新增元素花费的时间69&lt;br/&gt;LinkedList从集合尾部位置新增元素花费的时间193&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ArrayList 花费的时间比 LinkedList 要少一些。&lt;/p&gt;&lt;p&gt;这样的结论和预期的是不是不太相符？ArrayList 在添加元素的时候如果不涉及到扩容，性能在两种情况下（中间位置新增元素、尾部新增元素）比 LinkedList 好很多，只有头部新增元素的时候比 LinkedList 差，因为数组复制的原因。&lt;/p&gt;&lt;p&gt;当然了，如果涉及到数组扩容的话，ArrayList 的性能就没那么可观了，因为扩容的时候也要复制数组。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;04、ArrayList 和 LinkedList 删除元素时究竟谁快？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1）ArrayList&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;ArrayList 删除元素的时候，有两种方式，一种是直接删除元素（&lt;code&gt;remove(Object)&lt;/code&gt;），需要直先遍历数组，找到元素对应的索引；一种是按照索引删除元素（&lt;code&gt;remove(int)&lt;/code&gt;）。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Object[] es = elementData;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;this&lt;/span&gt;.size;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    found: {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (; i &amp;lt; size; i++)&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (es[i] == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt; found;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (; i &amp;lt; size; i++)&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (o.equals(es[i]))&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt; found;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    fastRemove(es, i);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Objects.checkIndex(index, size);&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Object[] es = elementData;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;) E oldValue = (E) es[index];&lt;br/&gt;    fastRemove(es, index);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; oldValue;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但从本质上讲，都是一样的，因为它们最后调用的都是 &lt;code&gt;fastRemove(Object, int)&lt;/code&gt; 方法。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fastRemove&lt;/span&gt;&lt;span&gt;(Object[] es, &lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    modCount++;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; newSize;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((newSize = size - &lt;span&gt;1&lt;/span&gt;) &amp;gt; i)&lt;br/&gt;        System.arraycopy(es, i + &lt;span&gt;1&lt;/span&gt;, es, i, newSize - i);&lt;br/&gt;    es[size = newSize] = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从源码可以看得出，只要删除的不是最后一个元素，都需要数组重组。删除的元素位置越靠前，代价就越大。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）LinkedList&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;LinkedList 删除元素的时候，有四种常用的方式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    checkElementIndex(index);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; unlink(node(index));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先检查索引，再调用 &lt;code&gt;node(int)&lt;/code&gt; 方法（ 前后半段遍历，和新增元素操作一样）找到节点 Node，然后调用 &lt;code&gt;unlink(Node)&lt;/code&gt; 解除节点的前后引用，同时更新前节点的后引用和后节点的前引用：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;E &lt;span&gt;unlink&lt;/span&gt;&lt;span&gt;(Node&amp;lt;E&amp;gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// assert x != null;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; E element = x.item;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; next = x.next;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; prev = x.prev;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (prev == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            first = next;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            prev.next = next;&lt;br/&gt;            x.prev = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            last = prev;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            next.prev = prev;&lt;br/&gt;            x.next = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        x.item = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        size--;&lt;br/&gt;        modCount++;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; element;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (LinkedList.Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x = x.next) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (x.item == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                unlink(x);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (LinkedList.Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x = x.next) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (o.equals(x.item)) {&lt;br/&gt;                unlink(x);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也是先前后半段遍历，找到要删除的元素后调用 &lt;code&gt;unlink(Node)&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;removeFirst&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; LinkedList.Node&amp;lt;E&amp;gt; f = first;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NoSuchElementException();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; unlinkFirst(f);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; E &lt;span&gt;unlinkFirst&lt;/span&gt;&lt;span&gt;(LinkedList.Node&amp;lt;E&amp;gt; f)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// assert f == first &amp;amp;&amp;amp; f != null;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; E element = f.item;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; LinkedList.Node&amp;lt;E&amp;gt; next = f.next;&lt;br/&gt;    f.item = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    f.next = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// help GC&lt;/span&gt;&lt;br/&gt;    first = next;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        last = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        next.prev = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    size--;&lt;br/&gt;    modCount++;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; element;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除第一个节点就不需要遍历了，只需要把第二个节点更新为第一个节点即可。&lt;/p&gt;&lt;p&gt;删除最后一个节点和删除第一个节点类似，只需要把倒数第二个节点更新为最后一个节点即可。&lt;/p&gt;&lt;p&gt;可以看得出，LinkedList 在删除比较靠前和比较靠后的元素时，非常高效，但如果删除的是中间位置的元素，效率就比较低了。&lt;/p&gt;&lt;p&gt;这里就不再做代码测试了，感兴趣的小伙伴可以自己试试，结果和新增元素保持一致：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;从集合头部删除元素时，ArrayList 花费的时间比 LinkedList 多很多；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;从集合中间位置删除元素时，ArrayList 花费的时间比 LinkedList 少很多；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;从集合尾部删除元素时，ArrayList 花费的时间比 LinkedList 少一点。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我本地的统计结果如下所示，小伙伴们可以作为参考：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ArrayList从集合头部位置删除元素花费的时间380&lt;br/&gt;LinkedList从集合头部位置删除元素花费的时间4&lt;br/&gt;ArrayList从集合中间位置删除元素花费的时间381&lt;br/&gt;LinkedList从集合中间位置删除元素花费的时间5922&lt;br/&gt;ArrayList从集合尾部位置删除元素花费的时间8&lt;br/&gt;LinkedList从集合尾部位置删除元素花费的时间12&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;05、ArrayList 和 LinkedList 遍历元素时究竟谁快？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1）ArrayList&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;遍历 ArrayList 找到某个元素的话，通常有两种形式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Objects.checkIndex(index, size);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; elementData(index);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于 ArrayList 是由数组实现的，所以根据索引找元素非常的快，一步到位。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;indexOf&lt;/span&gt;&lt;span&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; indexOfRange(o, &lt;span&gt;0&lt;/span&gt;, size);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;indexOfRange&lt;/span&gt;&lt;span&gt;(Object o, &lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt; end)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Object[] es = elementData;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt; end; i++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (es[i] == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; i;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt; end; i++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (o.equals(es[i])) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; i;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据元素找索引的话，就需要遍历整个数组了，从头到尾依次找。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）LinkedList&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;遍历 LinkedList 找到某个元素的话，通常也有两种形式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    checkElementIndex(index);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; node(index).item;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;既然需要调用 &lt;code&gt;node(int)&lt;/code&gt; 方法，就意味着需要前后半段遍历了。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;indexOf&lt;/span&gt;&lt;span&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (LinkedList.Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x = x.next) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (x.item == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; index;&lt;br/&gt;            index++;&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (LinkedList.Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x = x.next) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (o.equals(x.item))&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; index;&lt;br/&gt;            index++;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要遍历整个链表，和 ArrayList 的 &lt;code&gt;indexOf()&lt;/code&gt; 类似。&lt;/p&gt;&lt;p&gt;那在我们对集合遍历的时候，通常有两种做法，一种是使用 for 循环，一种是使用迭代器（Iterator）。&lt;/p&gt;&lt;p&gt;如果使用的是 for 循环，可想而知 LinkedList 在 get 的时候性能会非常差，因为每一次外层的 for 循环，都要执行一次 &lt;code&gt;node(int)&lt;/code&gt; 方法进行前后半段的遍历。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;LinkedList.&lt;span&gt;Node&amp;lt;E&amp;gt; &lt;span&gt;node&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// assert isElementIndex(index);&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;)) {&lt;br/&gt;        LinkedList.Node&amp;lt;E&amp;gt; x = first;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; index; i++)&lt;br/&gt;            x = x.next;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        LinkedList.Node&amp;lt;E&amp;gt; x = last;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = size - &lt;span&gt;1&lt;/span&gt;; i &amp;gt; index; i--)&lt;br/&gt;            x = x.prev;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那如果使用的是迭代器呢？&lt;/p&gt;&lt;pre&gt;&lt;code&gt;LinkedList&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;String&amp;gt;();&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (Iterator&amp;lt;String&amp;gt; it = list.iterator(); it.hasNext();) {&lt;br/&gt;    it.next();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;迭代器只会调用一次 &lt;code&gt;node(int)&lt;/code&gt; 方法，在执行 &lt;code&gt;list.iterator()&lt;/code&gt; 的时候：先调用 AbstractSequentialList 类的 &lt;code&gt;iterator()&lt;/code&gt; 方法，再调用 AbstractList 类的 &lt;code&gt;listIterator()&lt;/code&gt; 方法，再调用 LinkedList 类的 &lt;code&gt;listIterator(int)&lt;/code&gt; 方法，如下图所示。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2621951219512195&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpk9XU6vtj0fN6LsW7TyXVRtvESZkY1c5zdNmb6YxJ0coX3ZPyJnY5r4EQHx0u6SYfwk48iaNfLiaTXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后返回的是 LinkedList 类的内部私有类 ListItr 对象：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; ListIterator&amp;lt;E&amp;gt; &lt;span&gt;listIterator&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    checkPositionIndex(index);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LinkedList.ListItr(index);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ListItr&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ListIterator&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; LinkedList.Node&amp;lt;E&amp;gt; lastReturned;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; LinkedList.Node&amp;lt;E&amp;gt; next;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nextIndex;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; expectedModCount = modCount;&lt;br/&gt;&lt;br/&gt;    ListItr(&lt;span&gt;int&lt;/span&gt; index) {&lt;br/&gt;        &lt;span&gt;// assert isPositionIndex(index);&lt;/span&gt;&lt;br/&gt;        next = (index == size) ? &lt;span&gt;null&lt;/span&gt; : node(index);&lt;br/&gt;        nextIndex = index;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasNext&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; nextIndex &amp;lt; size;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        checkForComodification();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!hasNext())&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NoSuchElementException();&lt;br/&gt;&lt;br/&gt;        lastReturned = next;&lt;br/&gt;        next = next.next;&lt;br/&gt;        nextIndex++;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; lastReturned.item;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行 ListItr 的构造方法时调用了一次 &lt;code&gt;node(int)&lt;/code&gt; 方法，返回第一个节点。在此之后，迭代器就执行 &lt;code&gt;hasNext()&lt;/code&gt; 判断有没有下一个，执行 &lt;code&gt;next()&lt;/code&gt; 方法下一个节点。&lt;/p&gt;&lt;p&gt;由此，可以得出这样的结论：&lt;strong&gt;遍历 LinkedList 的时候，千万不要使用 for 循环，要使用迭代器。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;也就是说，for 循环遍历的时候，ArrayList 花费的时间远小于 LinkedList；迭代器遍历的时候，两者性能差不多。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;06、总结&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;花了两天时间，终于肝完了！相信看完这篇文章后，再有面试官问你 ArrayList 和 LinkedList 有什么区别的话，你一定会胸有成竹地和他扯上半小时。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>