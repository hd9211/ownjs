<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5af9470e475126f74ddaf66978914100</guid>
<title>懂了！国际算法体系对称算法 DES 原理</title>
<link>https://toutiao.io/k/hgpzrix</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;概念&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;加密领域主要有国际算法和国密算法两种体系。&lt;span&gt;国密算法是国家密码局认定的国产密码算法。&lt;/span&gt;&lt;span&gt;国际算法是由美国安全局发布的算法。&lt;/span&gt;&lt;span&gt;由于国密算法安全性高等一系列原因。&lt;/span&gt;&lt;span&gt;国内的银行和支付机构都推荐使用国密算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5541958041958042&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ra6mqN4XtugtZnGMuN4ShsaIlnABcCibRQJz0wKj0NQfnap2KoF4ncpQjxK7qwnWQDoIMWLx40Ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;572&quot;/&gt;&lt;/p&gt;&lt;p&gt;从上图可知，对称加密算法在算法体系里占了半壁江山。因为国际和国密算法的过程差异并不大。只是应用的数学公式和秘钥位数不同。DES在里面算是基础，所以今天主要介绍一下DES的原理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;密码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;咱们从加密的原理说起。举个最简单的加密：&lt;/p&gt;&lt;p&gt;我有一段明文：520&lt;/p&gt;&lt;p&gt;我的秘钥是：221&lt;/p&gt;&lt;p&gt;我的加密算法是：加法&lt;/p&gt;&lt;p&gt;加密后的密文就是：741&lt;/p&gt;&lt;p&gt;如果这个密文被截获了，接受者看到的信息是：741(气死你)，和原来明文520是完全不同的，不能知道信息原有的意思。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从这个简单的例子可知：加密是包含：明文、秘钥、加密算法和密文四个要素的。加密算法可公开可不公开，常见的算法有：位移、循环位移、异或、置换、数学函数。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;凯撒密码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;加密技术从古罗马凯撒时候就在用：凯撒密码&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9269746646795827&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8cAoPktdo4nJQEicvibMicVicHYYCWibNKvKqRYUibHvhvRmOEz96p1fPvf9aia21RTSedE80kO6jnaV9BA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;671&quot;/&gt;&lt;/p&gt;&lt;p&gt;凯撒密码是古罗马时期凯撒大帝和他的将军们通信时使用的加密方式：&lt;/p&gt;&lt;p&gt;明文：由26个字母组成&lt;/p&gt;&lt;p&gt;秘钥：1到25之间的任意数字&lt;/p&gt;&lt;p&gt;加密算法：循环位移&lt;/p&gt;&lt;p&gt;密文：举例明文为eat 秘钥为2，对照上面图片的凯撒密码盘可以得到密文是gcv。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;咱们来动手写个凯撒密码(代码已经上传github:&lt;br/&gt;（https://github.com/xiexiaojing/yuna)：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;caesarCipher&lt;/span&gt;() {&lt;br/&gt;    String text = &lt;span&gt;&quot;love was growing in eyes&quot;&lt;/span&gt;&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;明文&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;int &lt;/span&gt;key = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;秘钥&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;String cipher = encryptCaesarCipher(text&lt;span&gt;, &lt;/span&gt;key)&lt;span&gt;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;密文&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(cipher)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;凯撒密码加密算法&lt;br/&gt;&lt;/span&gt;&lt;span&gt;private &lt;/span&gt;String &lt;span&gt;encryptCaesarCipher&lt;/span&gt;(String text&lt;span&gt;, int &lt;/span&gt;key) {&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt;[] chars = text.toCharArray()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    for&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i&amp;lt;chars.&lt;span&gt;length&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i++) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(chars[i] != &lt;span&gt;&#x27; &#x27;&lt;/span&gt;) {&lt;br/&gt;            chars[i] = (&lt;span&gt;char&lt;/span&gt;)(chars[i]+key)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果超过了&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;&lt;span&gt;个字母，则减去&lt;/span&gt;&lt;span&gt;26&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(chars[i]&amp;gt;&lt;span&gt;122&lt;/span&gt;) {&lt;br/&gt;            chars[i] = (&lt;span&gt;char&lt;/span&gt;)(chars[i]-&lt;span&gt;26&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;}&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return new &lt;/span&gt;String(chars)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;p&gt;运行得到密文：oryh zdv jurzlqj lq hbhv&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;凯撒密码连小朋友都能破解。一旦被人知道用的凯撒密码，算法是已知的。要破解秘钥拿个明文和密文试试就知道了。就是平时说的暴力破解法可以很容易破解。对于这种全是英文字符的也可以使用频率分析法。频率分析法可以理解为基于大数据的方法，因为26个字母中，e的使用频率高。如果比如一篇文章，单词足够多的话，出现频率最高的字母xxx就是e。xxx的char值e的char值就是秘钥了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8cAoPktdo4nJQEicvibMicVicHCm6Jjbc6S5wxetM5bSZAAoWkru6NliagRxQ7sghhouibLfP1WuqD7ib5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;540&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;DES&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;DES全称为Data Encryption Standard，即数据加密标准，是一种分组加密算法。&lt;span&gt;其分组长度为64bit，密钥长度为64bit，其中8bit为校验位，所以实际长度为56bit。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;先介绍一下校验位。举个例子，咱们的身份证号码都是18位。这18位包含：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.16144018583042974&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8cAoPktdo4nJQEicvibMicVicHqNj0ib42YhVQrGt5KaW6meQRicicsRj9RyIvpE7WcZQaYJO7GRAj3agXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;/p&gt;&lt;p&gt;其中最后一位就是校验位，原理是利用将前面部分利用某种算法计算得到一个数。如果校验位与算法得到的不一致，则数据是有问题的。所以身份证本身是有不通过查库就可以简单验证有效性功能的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;回到DES算法。DES算法的秘钥必须是64位，参与加密计算的是56位。这是原始秘钥。这个原始秘钥会用一个函数转换成16个64位秘钥。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;加密过程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;DES的加密过程：&lt;/p&gt;&lt;p&gt;明文64位-&amp;gt;初始IP置换-&amp;gt;16轮加密变换-&amp;gt;逆初始IP置换-&amp;gt;密文&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;DES算法的这个过程又被称为Feistel网络。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.412&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRliccia32comB5k8icMWfCISBrQA0gO1KncFiciahA9dHNSiawicufLSCsfT61XcQiamfficSFWfnqtokicPiauwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;简单解释下：&lt;/p&gt;&lt;p&gt;明文我们自己想写多长写多长。但是加密的时候每次以64bit作为一个分组。最后将密文拼接起来。&lt;/p&gt;&lt;p&gt;然后执行一个IP置换(初始置换)操作。IP置换就是按位置换。举例来说64bit就是64个0和1。把第40个位置上的数换成第50个位置上的数就是置换了。&lt;/p&gt;&lt;p&gt;置换好的64个bit会分成两个32bit。然后用相同的加密算法每次传不同的转换后秘钥做16轮。&lt;/p&gt;&lt;p&gt;然后将两组32bit拼接起来再进行一次IP置换(终结置换)变成密文&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分组组合&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;刚才介绍的加密过程是把明文的一块怎么加密成密文。DES密码块与密码块连接方式遵循对称加密的方式。&lt;/p&gt;&lt;p&gt;对称加密有两种方式，一种是分组加密，一种是序列加密。&lt;/p&gt;&lt;p&gt;分组加密，也叫块加密(block cyphers)，一次加密明文中的一个块。是将明文按一定的位长分组，明文组经过加密运算得到密文组，密文组经过解密运算（加密运算的逆运算），还原成明文组。&lt;/p&gt;&lt;p&gt;序列加密，也叫流加密(stream cyphers)，一次加密明文中的一个位。是指利用少量的密钥通过某种复杂的运算（密码算法）产生大量的伪随机位流，用于对明文位流的加密。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分组加密算法中，&lt;span&gt;分组密码的设计基本遵循混淆原则和扩散原则。&lt;/span&gt;有ECB,CBC,CFB,OFB这4种算法模式。DES有ECB和CBC两种实现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;ECB模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;ECB模式就是每组明文分别加密后拼接起来。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5087040618955513&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ra6mqN4XtugtZnGMuN4ShiaBI8hoT3bQpUErNxkg3gwGV3iaf2KS58gHJmtzCYo4C9j6pOoemQCJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1034&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;CBC模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;CBC即密码分组链接（Cipher-block chaining）的简称。在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。在DES中，初始化向量就是秘钥。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.41486359360301034&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ra6mqN4XtugtZnGMuN4ShIsUB09GwMRFvKicToFeMKZLqDsPskLPt67wuA4IJBuBTNTF44iaSmTAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1063&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;程序实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们用程序来实现一下DES加密算法&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;desCiper&lt;/span&gt;() &lt;span&gt;throws &lt;/span&gt;Exception{&lt;br/&gt;    String key = &lt;span&gt;&quot;12345678&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;String text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我知道我是任性很任性，伤透了你的心&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;明文&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;String cipher = encryptDesCipher(text&lt;span&gt;, &lt;/span&gt;key)&lt;span&gt;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;密文&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(cipher)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;text = decryptDesCipher(cipher&lt;span&gt;, &lt;/span&gt;key)&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;明文&lt;br/&gt;&lt;/span&gt;&lt;span&gt;         &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(text)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//DES&lt;/span&gt;&lt;span&gt;加密算法&lt;br/&gt;&lt;/span&gt;&lt;span&gt;private &lt;/span&gt;String &lt;span&gt;encryptDesCipher&lt;/span&gt;(String text&lt;span&gt;, &lt;/span&gt;String origKey) &lt;span&gt;throws &lt;/span&gt;Exception{&lt;br/&gt;    Key key = &lt;span&gt;new &lt;/span&gt;SecretKeySpec(origKey.getBytes()&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;Cipher cipher = Cipher.&lt;span&gt;getInstance&lt;/span&gt;(&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;cipher.init(Cipher.&lt;span&gt;ENCRYPT_MODE&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;key)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    return &lt;/span&gt;Base64.&lt;span&gt;encode&lt;/span&gt;(cipher.doFinal(text.getBytes()))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//DES&lt;/span&gt;&lt;span&gt;加密算法&lt;br/&gt;&lt;/span&gt;&lt;span&gt;private &lt;/span&gt;String &lt;span&gt;decryptDesCipher&lt;/span&gt;(String text&lt;span&gt;, &lt;/span&gt;String origKey) &lt;span&gt;throws &lt;/span&gt;Exception{&lt;br/&gt;    Key key = &lt;span&gt;new &lt;/span&gt;SecretKeySpec(origKey.getBytes()&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;Cipher cipher = Cipher.&lt;span&gt;getInstance&lt;/span&gt;(&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;cipher.init(Cipher.&lt;span&gt;DECRYPT_MODE&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;key)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    return new &lt;/span&gt;String(cipher.doFinal(Base64.&lt;span&gt;decode&lt;/span&gt;(text)))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;运行结果：&lt;/p&gt;&lt;p&gt;xo6mmVe8j1/d60cAAiFz1HAXxihi2FH5d0zMWILvEYISWR52lguy2TbMZQ4vuulCdO8WvxMRuXE=&lt;/p&gt;&lt;p&gt;我知道我是任性很任性，伤透了你的心&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3DES&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3DES即3重加密算法，是对每个数据块应用三次DES算法。这是为了应对计算机计算能力增强，DES变的容易破解而产生的。&lt;/p&gt;&lt;p&gt;主要方法就是DES秘钥64位，3DES秘钥64*3=192位，分成个三个秘钥，进行2轮DES加密，1轮DES解密。最终得到结果。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0022075055187638&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRliccia32comB5k8icMWfCISBrQQr8XXLvY6d0XHDQnou1dq2Tdiau3iciaaZBggxoaRz0dl19MJbA3Jx0kQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;453&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;AES&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;AES全称是高级加密标准(Advanced Encryption Standard)。是用来替代DES/3DES的。主要过程如下，这里不过多介绍。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.718944099378882&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ra6mqN4XtugtZnGMuN4Shl7lk4ibjfMCYgGicJmc3bklod8y3uoSSD0D5ibPBzsW02b7L71MVWMBbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;644&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;应用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们来回顾下https的SSL握手过程：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7711267605633803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ra6mqN4XtugtZnGMuN4ShBpw65zZspytxXRcKuEvYKG1stFXzQs46jCic8CMTVZiao4ZKItrByC4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;852&quot;/&gt;&lt;/p&gt;&lt;p&gt;SSL握手的最后，双方会用非对称秘钥协商出一个对称秘钥。用对称秘钥来加密传输的数据。之所以这样做是因为非对称加密安全性高但是效率低，对称秘钥正好相反。对称秘钥可以被暴力破解，破解需要时间。如果破解出来时就过期了，再通信就用另外的秘钥就能保证信息安全。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们来模拟一下已经协商好的秘钥之后http客户端与服务器端的通信。(代码已经上传github:（https://github.com/xiexiaojing/yuna)：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;client&lt;/span&gt;() &lt;span&gt;throws &lt;/span&gt;Exception {&lt;br/&gt;    &lt;span&gt;int &lt;/span&gt;i = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    while &lt;/span&gt;(i &amp;lt;= &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;        Socket socket = &lt;span&gt;new &lt;/span&gt;Socket(&lt;span&gt;&quot;127.0.0.1&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;520&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向服务器端第一次发送字符串&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;OutputStream netOut = socket.getOutputStream()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;InputStream io = socket.getInputStream()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;String msg = i == &lt;span&gt;1 &lt;/span&gt;? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户端：我知道我是任性太任性，伤透了你的心。我是追梦的人，追一生的缘分。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户端：我愿意嫁给你，你却不能答应我。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(msg)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;netOut.write(encryptDesCipher(msg.getBytes()&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;12345678&quot;&lt;/span&gt;))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;netOut.flush()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        byte&lt;/span&gt;[] bytes = &lt;span&gt;new byte&lt;/span&gt;[i==&lt;span&gt;1&lt;/span&gt;?&lt;span&gt;104&lt;/span&gt;:&lt;span&gt;64&lt;/span&gt;]&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;io.read(bytes)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;String response = &lt;span&gt;new &lt;/span&gt;String(decryptDesCipher(bytes&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;12345678&quot;&lt;/span&gt;))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(response)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;netOut.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;io.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;socket.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;i++&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;server&lt;/span&gt;() &lt;span&gt;throws &lt;/span&gt;Exception {&lt;br/&gt;    ServerSocket serverSocket = &lt;span&gt;new &lt;/span&gt;ServerSocket(&lt;span&gt;520&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    int &lt;/span&gt;i = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    while &lt;/span&gt;(i &amp;lt;= &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;        String msg = i == &lt;span&gt;1 &lt;/span&gt;? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务端：我知道你是任性太任性，伤透了我的心。同是追梦的人，难舍难分。&lt;/span&gt;&lt;span&gt;&quot; &lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务端：你愿意嫁给我，我却不能向你承诺。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;Socket socket = serverSocket.accept()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;InputStream io = socket.getInputStream()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        byte&lt;/span&gt;[] bytes = &lt;span&gt;new byte&lt;/span&gt;[i==&lt;span&gt;1&lt;/span&gt;?&lt;span&gt;112&lt;/span&gt;:&lt;span&gt;64&lt;/span&gt;]&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;io.read(bytes)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;new &lt;/span&gt;String(decryptDesCipher(bytes&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;12345678&quot;&lt;/span&gt;)))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;OutputStream os = socket.getOutputStream()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(msg)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        byte&lt;/span&gt;[] outBytes = encryptDesCipher(msg.getBytes()&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;12345678&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;os.write(outBytes)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;os.flush()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;os.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;io.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;i++&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span&gt;//DES&lt;/span&gt;&lt;span&gt;加密算法&lt;br/&gt;&lt;/span&gt;&lt;span&gt;private byte&lt;/span&gt;[] &lt;span&gt;encryptDesCipher&lt;/span&gt;(&lt;span&gt;byte&lt;/span&gt;[] text&lt;span&gt;, &lt;/span&gt;String origKey) &lt;span&gt;throws &lt;/span&gt;Exception {&lt;br/&gt;    Key key = &lt;span&gt;new &lt;/span&gt;SecretKeySpec(origKey.getBytes()&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;Cipher cipher = Cipher.&lt;span&gt;getInstance&lt;/span&gt;(&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;cipher.init(Cipher.&lt;span&gt;ENCRYPT_MODE&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;key)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    return &lt;/span&gt;cipher.doFinal(text)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//DES&lt;/span&gt;&lt;span&gt;加密算法&lt;br/&gt;&lt;/span&gt;&lt;span&gt;private byte&lt;/span&gt;[] &lt;span&gt;decryptDesCipher&lt;/span&gt;(&lt;span&gt;byte&lt;/span&gt;[] text&lt;span&gt;, &lt;/span&gt;String origKey) &lt;span&gt;throws &lt;/span&gt;Exception {&lt;br/&gt;    Key key = &lt;span&gt;new &lt;/span&gt;SecretKeySpec(origKey.getBytes()&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;Cipher cipher = Cipher.&lt;span&gt;getInstance&lt;/span&gt;(&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;cipher.init(Cipher.&lt;span&gt;DECRYPT_MODE&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;key)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    return &lt;/span&gt;cipher.doFinal(text)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;运行结果&lt;/p&gt;&lt;p&gt;客户端：我知道我是任性太任性，伤透了你的心。我是追梦的人，追一生的缘分。&lt;/p&gt;&lt;p&gt;服务端：我知道你是任性太任性，伤透了我的心。同是追梦的人，难舍难分。&lt;/p&gt;&lt;p&gt;客户端：我愿意嫁给你，你却不能答应我。&lt;/p&gt;&lt;p&gt;服务端：你愿意嫁给我，我却不能向你承诺。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个程序实现了简单的客户端和服务器端的DES加密方式通信。稍加改造可以实现一个信息加密的聊天小程序。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;本文使用概念、原理、应用的传统型逻辑架构来对DES做系统梳理。里面涉及到的一些基本知识限于篇幅省略了一些。&lt;/p&gt;&lt;p&gt;比如Base64编码。它是加密时常用的编码方式，我们平时所看到的密钥都是base64后的结果。可以简单理解为对2的6次方进行64进制运算，可防止乱码丢失字节。&lt;/p&gt;&lt;p&gt;再比如填充字节这部分也没有介绍，有兴趣可以自己查阅下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;加解密很多人工作中或多或少都有涉及。我个人认为只要涉及的地方至少要了解到原理和架构层面，才能避免遇到问题时【拿着锤子找钉子】找不到真正问题的窘境。而只有动手实践才能避免当时了解了，过后又忘了需要再看一遍而产生重复工作的问题。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cdc8863f3f3457a6194dfa8efcd6851c</guid>
<title>Dubbo 日志链路追踪 TraceId 选型</title>
<link>https://toutiao.io/k/b0y1ksy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Hic4icvNgYCicZvwodbNQryOoDKF56ncD3xibWXERbb6xlrL2GlLyKiagVTeg16G7ppkOhxqIAPiaN3oshebbCkDpKhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;figcaption&gt;链路追踪ID&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、目的&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发排查系统问题用得最多的手段就是查看系统日志，但是在分布式环境下使用日志定位问题还是比较麻烦，需要借助 &lt;code&gt;全链路追踪ID&lt;/code&gt;  把上下文串联起来，本文主要分享基于 &lt;code&gt;Spring Boot&lt;/code&gt; + &lt;code&gt;Dubbo&lt;/code&gt; 框架下 &lt;code&gt;日志链路追踪ID&lt;/code&gt; 的实现方案选型思路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前大多数分布式追踪系统的思想模型都来自 Google&#x27;s Dapper 论文&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6796296296296296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Hic4icvNgYCicZvwodbNQryOoDKF56ncD3xlpM9C8K7W9MAbG8LotAWicSxqo6P3uD3KFsJEyiaNlkG3uzdFqQxmODw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;Dapper&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全链路追踪的核心思想：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为每条请求都单独分配一个唯一的 &lt;code&gt;traceId&lt;/code&gt; 用来标识一条请求链路，该 &lt;code&gt;traceId&lt;/code&gt; 会贯穿整个请求处理过程的所有服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个服务/线程都拥有自己的 &lt;code&gt;spanId&lt;/code&gt; 标识，代表请求的其中一段处理步骤&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个请求包含一个 &lt;code&gt;traceId&lt;/code&gt; 和一个或多个 &lt;code&gt;spanId&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;「日志全链路追踪」&lt;/strong&gt; 就是在每条系统日志里都添加显示 &lt;code&gt;traceId&lt;/code&gt; 和 &lt;code&gt;spanId&lt;/code&gt; 信息&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37424547283702214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Hic4icvNgYCicZvwodbNQryOoDKF56ncD3xUwlpGH25lmKD7s1seERvjGiaX6doZXJpOy6ZQXcwXTtV8XiaiaCfZRSCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、方案选型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1. 方案一(apm-toolkit)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是 &lt;code&gt;SkyWalking&lt;/code&gt; 的一个日志插件，通过这个插件可以在日志中输出&lt;code&gt;traceId&lt;/code&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.1. 使用方式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「配置依赖」&lt;/strong&gt;，在 pom 文件中添加以下内容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.skywalking&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;apm-toolkit-logback-1.x&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;8.1.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「配置日志模板」&lt;/strong&gt;，修改 &lt;code&gt;logback-spring.xml&lt;/code&gt; 文件中 &lt;code&gt;Appender&lt;/code&gt; 元素的 &lt;code&gt;encoder&lt;/code&gt; 为以下内容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;encoder&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;ch.qos.logback.core.encoder.LayoutWrappingEncoder&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;layout&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;org.apache.skywalking.apm.toolkit.log.logback.v1.x.TraceIdPatternLogbackLayout&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%tid] [%thread] %-5level %logger{35} - %msg%n&lt;span&gt;&amp;lt;/&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;layout&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;encoder&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;「ps:」&lt;/strong&gt; pattern 中的内容按需修改，其中的 %tid 就是相当于 traceId，默认 TID:N/A，当有请求调用时会生成并显示 traceId&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.2. 总结&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;「优点」&lt;/strong&gt;：无需编码，业务无入侵，可与 &lt;code&gt;SkyWalking&lt;/code&gt; 的图形化界面中使用该ID快速定位各种接口的调用关系&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;「缺点」&lt;/strong&gt;：强耦合 &lt;code&gt;SkyWalking&lt;/code&gt; 才能生效&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;必须添加sk的 &lt;code&gt;javaagent&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;必&lt;span&gt;须&lt;/span&gt;部署 &lt;code&gt;SkyWalking&lt;/code&gt; 服务端&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2. 方案二(sleuth)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Sleuth&lt;/code&gt; 是 &lt;code&gt;Spring Cloud&lt;/code&gt; 的组件之一，它为 &lt;code&gt;Spring Cloud&lt;/code&gt; 实现了一种分布式追踪解决方案，兼容Zipkin，HTrace与其他日志追踪系统&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.1. 使用方式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「配置父依赖」&lt;/strong&gt;，在 pom 文件中添加以下内容管理版本号&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependencyManagement&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-sleuth&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.2.4.RELEASE&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependencyManagement&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「配置依赖」&lt;/strong&gt;，在 pom 文件中添加以下内容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-sleuth&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「适配dubbo」&lt;/strong&gt;，要让 &lt;code&gt;sleuth&lt;/code&gt; 支持 &lt;code&gt;dubbo&lt;/code&gt; 框架，需要增加以下两个步骤：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先添加 dubbo 的插件依赖&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;io.zipkin.brave&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;brave-instrumentation-dubbo-rpc&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;5.12.6&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置 dubbo 过滤器&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;dubbo:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  provider:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    filter:&lt;/span&gt; &lt;span&gt;tracing&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  consumer:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    filter:&lt;/span&gt; &lt;span&gt;tracing&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「配置日志模板」&lt;/strong&gt;，修改 &lt;code&gt;logback-spring.xml&lt;/code&gt; 文件中 &lt;code&gt;Appender&lt;/code&gt; 元素的 &lt;code&gt;encoder&lt;/code&gt; 为以下内容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;encoder&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{X-B3-TraceId},%X{X-B3-SpanId}] [%thread] %-5level %logger{35} - %msg%n&lt;span&gt;&amp;lt;/&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;charset&lt;/span&gt;&amp;gt;&lt;/span&gt;utf-8&lt;span&gt;&amp;lt;/&lt;span&gt;charset&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;encoder&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;「ps:」&lt;/strong&gt; pattern 中的内容按需修改，其中的 %X{X-B3-TraceId} 为 traceId，%X{X-B3-SpanId} 为 spanId&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.2. 总结&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;「优点」&lt;/strong&gt;：业务无入侵，有丰富的插件进行扩展包括定时任务、MQ等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;「缺点」&lt;/strong&gt;：&lt;code&gt;brave-instrumentation-dubbo-rpc&lt;/code&gt; 不支持 &lt;code&gt;dubbo 2.7.x&lt;/code&gt; 需要自行开发插件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3. 方案三(自研)&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.1. 无入侵增加 traceId&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;Logback&lt;/code&gt; 的 &lt;code&gt;MDC&lt;/code&gt; 机制，在日志模板中加入 &lt;code&gt;traceId&lt;/code&gt; 标识，取值方式为 &lt;code&gt;%X{traceId}&lt;/code&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;系统入口（api网关）创建 &lt;code&gt;traceId&lt;/code&gt; 的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;MDC&lt;/code&gt; 保存 &lt;code&gt;traceId&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改 &lt;code&gt;logback&lt;/code&gt; 配置文件模板格式添加标识 &lt;code&gt;%X{traceId}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;MDC（Mapped Diagnostic Context，映射调试上下文）是 log4j 和 logback 提供的一种方便在多线程条件下记录日志的功能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.2. 跨线程传递&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决 &lt;code&gt;traceId&lt;/code&gt; 跨线程丢失问题&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6342281879194631&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Hic4icvNgYCicZvwodbNQryOoDKF56ncD3xTqibShsN3wuo4kDQtTzjWo1h5YgficGzDw0Wn4X6PRfoUInIvWfJE5og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1192&quot;/&gt;&lt;figcaption&gt;file&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 &lt;code&gt;MDC&lt;/code&gt; 内部使用的是 &lt;code&gt;ThreadLocal&lt;/code&gt; 所以只有本线程才有效，子线程和下游的服务 &lt;code&gt;MDC&lt;/code&gt; 里的值会丢失；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要解决 &lt;code&gt;Spring&lt;/code&gt; 的各种线程池与异步方法的父子线程间传递。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「解决思路」&lt;/strong&gt;：重写一个 &lt;code&gt;MDCAdapter&lt;/code&gt; 使用阿里的 &lt;code&gt;TransmittableThreadLocal&lt;/code&gt; 替换原来的 &lt;code&gt;ThreadLocal&lt;/code&gt; 对象，解决各种线程池（&lt;code&gt;ExecutorService&lt;/code&gt; / &lt;code&gt;ForkJoinPool&lt;/code&gt; / &lt;code&gt;TimerTask&lt;/code&gt;）父子进程传值问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要使用 &lt;code&gt;TtlRunnable&lt;/code&gt; 和 &lt;code&gt;TtlCallable&lt;/code&gt; 来修饰传入线程池的 &lt;code&gt;Runnable&lt;/code&gt; 和 &lt;code&gt;Callable&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.3. 跨进程传递&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决 &lt;code&gt;traceId&lt;/code&gt; 跨进程丢失问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「dubbo服务」&lt;/strong&gt; 使用 &lt;code&gt;org.apache.dubbo.rpc.Filter&lt;/code&gt; 创建一个过滤器进行 &lt;code&gt;traceId&lt;/code&gt; 传递&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;服务消费者：负责传递链路追踪 ID&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务提供者：负责接收 ID 并保存到 &lt;code&gt;MDC&lt;/code&gt; 中&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.4. 总结&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;「优点」&lt;/strong&gt;：业务无入侵，最小依赖，扩展灵活，适配性强。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;「缺点」&lt;/strong&gt;：需要自行实现，有大量的开发工作量。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、方案总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方案&lt;/th&gt;&lt;th&gt;开发工作量&lt;/th&gt;&lt;th&gt;可维护性&lt;/th&gt;&lt;th&gt;入侵性&lt;/th&gt;&lt;th&gt;性能&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;apm-toolkit&lt;/td&gt;&lt;td&gt;无&lt;/td&gt;&lt;td&gt;低&lt;/td&gt;&lt;td&gt;业务无入侵&lt;/td&gt;&lt;td&gt;中&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sleuth&lt;/td&gt;&lt;td&gt;中&lt;/td&gt;&lt;td&gt;中&lt;/td&gt;&lt;td&gt;业务无入侵&lt;/td&gt;&lt;td&gt;中&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;自研&lt;/td&gt;&lt;td&gt;高&lt;/td&gt;&lt;td&gt;高&lt;/td&gt;&lt;td&gt;业务无入侵&lt;/td&gt;&lt;td&gt;高&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>61681e417fb3e17bb41eea27acc2ea9e</guid>
<title>揭秘 Apache Pulsar 如何挑战 Kafka</title>
<link>https://toutiao.io/k/ao9ceoz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;开源流数据公司 &lt;/span&gt;&lt;span&gt;StreamNative&lt;/span&gt;&lt;span&gt; 近期&lt;/span&gt;&lt;span&gt;宣布完成数百万美元 Pre-A 轮融资&lt;/span&gt;&lt;span&gt;，日前&lt;/span&gt;&lt;span&gt;正式加入 CNCF&lt;/span&gt;&lt;span&gt;。其创始团队成员是 Apache Pulsar、Apache BookKeeper 项目的原生核心开发者，StreamNative 也被称为开源消息系统基础设施 Pulsar 背后的公司。（本文中 Pulsar、BookKeeper 分别指代&lt;/span&gt;&lt;span&gt; Apache Pulsar&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Apache BookKeeper&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StreamNative 是一家基于 Pulsar 的商业公司，提供云原生的实时消息和流数据处理技术。Pulsar 是 Yahoo 内部在 2012 年为构建统一消息平台而构建的，采用分层分片的系统架构。上层 Pulsar Broker 提供无状态的服务层；底层 BookKeeper 提供高性能、低延迟和强一致性的 IO 服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在今年 6 月的 Pulsar Summit 中，Splunk 和 Yahoo 做了测试和分析：Pulsar 帮助 Splunk 将成本降低了 1.5 - 2 倍，延迟降低了 5 - 50 倍，运营成本降低 2 - 3 倍；&lt;span&gt;在 Yahoo 的部署中，Pulsar 支持同等规模的业务量，还在保证更高数据服务质量的情况下，消耗只有 Apache Kafka 的一半的实际硬件资源成本。&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，在目前开源的分布式消息系统中，Kafka 依旧有很高的知名度和使用率，也同样是 Apache 基金会的顶级项目。Pulsar 在技术和生态上有什么地方上优于 Kafka？未来是否有更大的发展空间？Pulsar 和 StreamNative 是如何共生的？StreamNative 因何获得投资，这对其他开源项目公司有什么启发？对此，我们采访了 StreamNative 联合创始人兼 CTO 翟佳。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;翟佳，StreamNative 联合创始人兼 CTO。在创办 StreamNative 之前，在 EMC 从事分布式、文件系统、流存储相关的设计和开发，目前是 Apache BookKeeper 和 Apache Pulsar 两个项目的 PMC 成员。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开源消息系统基础设施 Pulsar&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;Pulsar 诞生于 2012 年，最初的目的是为在 Yahoo 内部，取代其他消息系统，构建统一逻辑大集群的消息平台。当时的其他消息系统（包括 Kafka），都不能满足 Yahoo 的需求，比如大集群多租户、稳定可靠的 IO 服务质量、百万级 Topic、跨地域复制等，因此 Pulsar 应运而生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“当时在 Yahoo 内部叫 CMS（Cloud Message Service），从名字可以看出 Pulsar 诞生时就坚定了云的方向”，翟佳介绍，2015 年，Pulsar 完成了在 Yahoo 内部的部署和替换，大规模部署在 Yahoo 内部， 服务于 Yahoo mail、 Yahoo Finance、 Yahoo Sports/ Flickr 及广告平台等大规模的场景。2017 年 6 月 Pulsar 被捐赠给 Apache 基金会，2018 年 9 月毕业成为 ASF 顶级项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在，Pulsar 被  StreamNative 看做是一个兼属“流数据+云原生”领域的项目。那么 Pulsar 作为一个以“云”为方向的消息基础设施，其“流数据”和“云原生”特性都是如何实现的呢？这里翟佳介绍了一些 Pulsar 的技术特性：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Pulsar 作为消息的基础设施，必然会和存储、和计算层有深入的交互。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在存储方面，Pulsar 利用 Apache BookKeeper 的优势，积极扩展和挖掘 Pulsar 架构的优势。基于 Pulsar 对 Topic 的分片存储，我们可以很自然地将老的分片从 BookKeeper 迁移到的二级存储中。通过层级存储，可以支持无限量的流数据。此外我们正在二级存储中支持列存模式的支持，这样可以更高效的支撑批处理的请求，真正实现批流融合的存储需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6574074074074074&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRK9SQEH3MBDRrIEWYWOeq271Wz9N4f1X7azlibheN8SKYYxMjeLNYHHHaF6RetaYyp1aQAKMlbpyzEw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于计算层，Pulsar 的思路是更多地拥抱其他开源项目。我们在 Pulsar 中提供了结构化（Schema）的支持，保证 Pulsar 中的数据可以按照数据结构被其他系统理解。比如 StreamNative 开源的 pulsar-spark、&lt;/span&gt;&lt;span&gt;pulsar-flink 连接器&lt;/span&gt;&lt;span&gt;等，都是为了更好的和其他大数据引擎整合的例子。Pulsar SQL 也是直接整合 Presto 来支持 Pulsar 中的数据查询。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;函数式轻量化计算（Pulsar Functions），是 Pulsar 结合 Serverless 的理念在消息领域的一个创新。函数的编写很简单，运行时，每个消息触发一次函数的计算。这种轻量级的计算，为用户提供了 Spark、Flink 之外一个很好的补充，可以方便用户处理很多常见的简单计算场景，比如数据的清洗、路由、Enhancement 等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pulsar 借助在存储层的优势，通过和更多的大数据生态整合，为用户提供一整套基于事件流的数据处理平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;在消息领域&lt;/span&gt;，&lt;span&gt;Pulsar 是第一个将存储计算分离云原生架构落地的开源项目。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了存储计算的分层架构，Pulsar 系统中的节点对等、大集群管理带来的资源池化、高可用特性带来的系统弹性等和云原生的理念十分契合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流数据按照有没有明确的起止位置，可以分为有界流和无界流。流入消息平台中每个 Topic 的数据，很自然地可以作为事件流的一种数据表现。Pulsar 的 Pub/Sub 接口，可以让计算平台更方便地把 Topic 当作流数据来处理。同时 Pulsar 底层的存储层 BookKeeper，又将一个 Topic 分为了多个有界的分片，和 HDFS 中的数据块对应，直接访问 BookKeeper 中的分片，更加方便批数据的处理引擎。结合 Pulsar，可以更便捷地完成在数据处理中的批流统一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.44565217391304346&quot; data-type=&quot;png&quot; data-w=&quot;828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRK9SQEH3MBDRrIEWYWOeq271ia13x1ibqKuV6Qdy06eh1ZcjOnws35dL4VbWiaXERHIiaY3wtQfF2mWXPw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在批流统一的实践中，Flink/Spark 等计算引擎都有了很好的抽象，但是在数据的存储层没有太多的工作，StreamNative 认为 Pulsar 的架构很匹配批流融合的存储需求，这是 Pulsar 在数据处理领域的一个优势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;StreamNative 正在 Pulsar 的二级存储中支持列存格式，让访问 Pulsar 的批处理引擎更加高效。&lt;/span&gt;这样 Pulsar 提供了统一的数据存储层，用户只用关心上层的数据处理，而不用关心底层的数据存储细节。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Pulsar 使用 BookKeeper 作为存储中心&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;Pulsar 使用 BookKeeper 作为存储中心。BookKeeper 提供的 API 抽象度很高，简单来说就是一个提供无限个 Write-Ahead-Log（WAL）的分布式存储系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从 BookKeeper 毕业成为 Apache 顶级项目，已经有 5 年多的时间，期间一直有 Yahoo、Twitter、Salesforce、EMC 等公司的深度使用和积极贡献，BookKeeper 相对来说已经比较稳定和成熟。StreamNative 主要通过 Pulsar 的社区增长来带动 BookKeeper 的社区增长。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据 Pulsar 的功能需求，相应地增加 BookKeeper 的功能。StreamNative 组织的线上线下活动中，也常邀请 BookKeeper 的相关用户参与分享和交流。从 GitHub 上 BookKeeper 项目 Star 数的增长趋势，也可以很明显的看到两个社区的相互带动。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Pulsar 和 Kafka 对比&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;开发者最关心的问题可能还是 Pulsar 好用在哪？翟佳从三个方面对比 Pulsar 与 Kafka，以说明 Pulsar 的特点和优势：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一，从应用场景来说，Pulsar 对用户来说提供了统一的消息模型，一方面可以满足各种 MQ，例如 RabbitMQ、ActiveMQ 等线上交易系统的需求；一方面可以满足和 Kafka 类似的高吞吐的需求的场景。这决定了 Pulsar 在生态上，有比 Kafka 更多的使用场景和需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二，架构上，Pulsar 有存储计算分离的云原生架构的优势。由于在 Broker 层不存储任何数据，这种架构为用户带来了更高的可用性、更灵活的扩容和管理、避免数据的 reblance 和 catch-up。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;BookKeeper 作为 Pulsar 的存储层，它诞生时就是为元数据的一致性服务的，可以在保证高带宽、低延迟的情况下，为用户提供更好的一致性保障；相比 Kafka 依赖文件系统来保证一致性，BookKeeper 有原生的一致性协议，数据实时刷盘，读写硬件隔离，这些都为 Pulsar 带来了更高可靠性和数据服务质量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三，在社区上，Kafka 作为当时流数据的唯一选择有一定的先发优势。Pulsar 凭借架构和功能方面的优势，在过去两年的关注度和使用量不断快速增加，国内外的 Pulsar 用户和贡献者数量也在快速增加。在前两周，全球项目贡献者人数已突破 300 位。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前公司对消息平台的需求升级集中在降低成本、便捷操作两个方面。Pulsar 以下的特性正是符合消息平台发展的趋势：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;云原生，降低系统的人工运维和管理的成本；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;大集群，统一管控系统资源；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;统一平台，便捷数据的共享和管理。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;翟佳总结，Pulsar 的优势在于其&lt;span&gt;独特设计和分层分片的系统架构&lt;/span&gt;。借助 Pulsar 的架构和功能，用户可以部署统一的集群，通过池化的资源和多租户，来满足整个组织内部的各种消息场景的需求，减少小集群、多集群的复杂管理，提高资源利用率，方便集群内部数据的共享。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pulsar 借助 BookKeeper 也为用户提供了更好的数据服务质量， 在保证高带宽、低延迟的同时，提供了更高的一致性和持久化。从运维和资源弹性角度看，Pulsar 集群的扩缩容更加迅速便捷；节点的替换和更新不会影响业务的可靠性和可用性。从线上部署成本来说，对比 Kafka，Pulsar 也有相当大的优势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;基于 Pulsar 的 StreamNative&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在了解了 Pulsar 的基础之上，才能更好理解 StreamNative。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StreamNative 在开发与运维 Pulsar 的同时，主要提供基于 Pulsar 的云端托管与运维、技术支持服务。需要注意的是，Pulsar 是 Apache 基金会下的顶级开源项目，其所有权属于中立的基金会，这也是 StreamNative 可以为 Pulsar 做社区运营的信任基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StreamNative 成立于 2019 年，公司开发人员都是 Apache Pulsar 早期的一批贡献者，很多成员也是 Apache Pulsar 的 PMC 成员或 Committer，其联合创始人兼 CEO 郭斯杰 是 Apache Pulsar 原型设计和主要开发者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;翟佳介绍，StreamNative 聚焦的两个主要方向是 Pulsar 社区和云，这也是投资人极为看好的方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;产品方面，&lt;span&gt;StreamNative 的产品是 StreamNative Cloud，为企业在云上提供全托管式的 “Apache Pulsar 即服务”，翟佳介绍，“&lt;/span&gt;熟悉 Pulsar 的工程师会对 Pulsar 的存储计算分离和分层分片的弹性系统架构，印象比较深刻，这也是StreamNative 常说 Pulsar 拥有云原生架构的一个原因。”StreamNative 的服务适合对 Pulsar 集群运行质量、管控和维护有更高需求的客户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StreamNative 团队目前的主要工作内容还包括完善 Pulsar 社区。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对 Pulsar 社区的构建主要是集中在产品及与用户的互动，贡献和改进 Pulsar 的功能、丰富 Pulsar 的周边生态、帮助 Pulsar 的版本发布和维护、沟通社区用户并帮忙解决上线 Pulsar 中遇到的障碍、组织参加相关 Pulsar 的 meetup 等推广宣传活动等。这些工作主要是完善 Pulsar 的文档、降低 Pulsar 的入门门槛，丰富 Pulsar 和其他系统的集成和交互，做好用户起步的基础工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;“长期来看，更重要的是丰富社区的用户场景、吸引更多的用户参与社区，构建一个活跃的、可以长期持续发展的社区”&lt;/span&gt;，翟佳透露，除了 Pulsar 自身的优势，社区和客户的认可也是促成 Pre-A 轮融资成功的原因之一。目前 Pulsar 已经在一线的互联网场景中得到了广泛的应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，StreamNative 也在完善 StreamNative 基于 K8S 的云平台。目前已经在 Google Cloud 上发布了云平台预览版 StreamNative Cloud，预计在年底发布国内的预览版。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开源项目与商业公司&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;在这次访谈中，翟佳大部分时间都在介绍 Pulsar。他认为，&lt;span&gt;开源项目与商业公司是相互成就的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;成功的开源项目背后，都有一家商业化公司来为社区和用户持续提供核心支持：社区用户被开源产品的架构和功能所吸引，参与社区；公司在服务社区的过程中，不断获得反馈和创新，完善开源产品在各种生产环境的综合表现；公司再利用成熟的项目和积淀来服务有需要的社区客户——这样形成一个良性循环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由 Pulsar 核心团队带领的 StreamNative 公司和 Pulsar 社区也是这样一种关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;谈到&lt;span&gt;创业商机&lt;/span&gt;，作为技术人的翟佳表示自己一直抱着“技术改变世界”的梦想，“StreamNative 创始团队成员亲身见证经历了 3000+ Pulsar 存储集群规模的搭建和运维，见证和经历了 Pulsar 和 BookKeeper 在 Yahoo、Twitter 线上的长期磨砺和迭代，明确感受到 Pulsar 在架构和功能方面的优势，以及与云原生方向的匹配和一致性。同时，我们看到开发者对 Pulsar 的架构和产品的认可，也感受到用户在使用时遇到的痛点。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外近两年开源商业化的模式不断成熟，在 Spark、ES、MongoDB、TiDB 等开源项目背后，都有商业公司在崛起，StreamNative 认为 Pulsar 和 StreamNative 有同样的机会。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，StreamNative 花费了如此多的时间与精力在 Pulsar 与其社区生态上，是否会造成 Pulsar 与商业公司绑定，削弱项目的开源协作属性呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对此翟佳认为，&lt;span&gt;这种绑定，是对开源协作的促进，而非削弱。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pulsar 的核心是全部开源的，StreamNative 公司和社区用户用的是同样的一份代码。StreamNative 投入社区会带来社区的信任和发展；社区的反馈会带来 Pulsar 的成熟和创新迭代；最终会有更多的用户相信 Pulsar 和 StreamNative。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，金融、证券、零售、IoT 等领域都有客户在拥抱和使用 Pulsar。StreamNative 在支持这些客户的同时，Pulsar 也通过不同的场景变得更加成熟。通过对客户的服务，StreamNative 可以了解相关垂直领域的需求，进而不断接触和满足更多相同领域的客户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pulsar 和 Kafka 很类似，都是 Apache 软件基金会的项目，Linkedin 在捐赠 Kafka 之后，成为了 Kafka 的用户，Yahoo 现在也是 Pulsar 的用户。 在 Linkedin 和 Yahoo 的角度，维护开源项目（Kafka/Pulsar）在原公司的使用，满足原公司线上的业务需求是最重要的，除此之外开源能让项目更加成熟和健壮，对原公司有不少好处。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上， Pulsar 项目本身往云原生方向发展，看好此方向的 StreamNative 投入绝对的精力和时间在 Pulsar 上，一方面帮助拓展 Pulsar 的生态，反刍自身的商业资源，另一方面握住 Pulsar 和 BookKeeper 的技术优势，以区别其他的 Pulsar 服务商。这些或许就是投资人现在看好 StreamNative 的原因，未来也可能会是更多开发者和用户选择 StreamNative 的理由。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&amp;amp;mid=2650095312&amp;amp;idx=1&amp;amp;sn=6dc4571475e963b86625070ef1b25828&amp;amp;chksm=bedae5be89ad6ca8d1403569c04c542ae8c0c6895e7738f12f89d598d6e06842b64a7bf04915&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;尤雨溪：全职做开源年薪百万，非科班程序员也能成功&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&amp;amp;mid=2650095283&amp;amp;idx=1&amp;amp;sn=a42eb68ddfb55c262a5a7ebe0e6681c4&amp;amp;chksm=bedae5dd89ad6ccb38acd98d3d9f3d3cee5c314b4f27164cfcd29c33f18f782c7589b8bdbf33&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Vue 3发布&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&amp;amp;mid=2650095280&amp;amp;idx=1&amp;amp;sn=c9db17ec6e2297c045b81921661036db&amp;amp;chksm=bedae5de89ad6cc8a46f71a267e5223d02dbdbe33f1f499af32c0ae5f6c936b11ef4c1eec562&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;TypeScript之父：JS不是竞争对手&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&amp;amp;mid=2650095283&amp;amp;idx=2&amp;amp;sn=702e7bb79973d66d37b91e516ec52366&amp;amp;chksm=bedae5dd89ad6ccbd730f57884afb5f9ce17ffc59bf0371698ed9babe653dd450a85d19142bc&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;领导层缺失，Ubuntu创始人反思&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&amp;amp;mid=2650095291&amp;amp;idx=1&amp;amp;sn=7f8ecba66a02f1996345eff941001bd8&amp;amp;chksm=bedae5d589ad6cc3b134691af153e2ba7c331e9629507f814d9a08ca966055727e2be50b2a94&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;几天后，GitHub的“master”将更改为“main”&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fd145b4b5b6fd93fe65ac1de182298ac</guid>
<title>技术人员发展四阶段</title>
<link>https://toutiao.io/k/lfucbgj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>33e0603f8c21fdc36a0828d115e85476</guid>
<title>从 12.9K 的前端开源项目我学到了啥？</title>
<link>https://toutiao.io/k/4nhsi51</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;近期我们团队的小伙伴小池同学分享了 “&lt;strong&gt;BetterScroll 2.0 发布：精益求精，与你同行&lt;/strong&gt;” 这篇文章到团队内部群，看到了 &lt;strong&gt;插件化&lt;/strong&gt; 的架构设计，阿宝哥突然来了兴趣，因为之前阿宝哥在团队内部也做过相关的分享。既然已经来了兴趣，那就决定开启 BetterScroll 2.0 源码的学习之旅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来本文的重心将围绕 &lt;strong&gt;插件化&lt;/strong&gt; 的架构设计展开，不过在分析 BetterScroll 2.0 插件化架构之前，我们先来简单了解一下 BetterScroll。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一、BetterScroll 简介&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BetterScroll 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。它的核心是借鉴的 iscroll 的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BetterScroll 1.0 共发布了 &lt;strong&gt;30&lt;/strong&gt; 多个版本，npm 月下载量 &lt;strong&gt;5&lt;/strong&gt; 万，累计 star 数 &lt;strong&gt;12600+&lt;/strong&gt;。那么为什么升级 2.0 呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;做 v2 版本的初衷源于社区的一个需求：&lt;/p&gt;&lt;p&gt;来源于：BetterScroll 2.0 发布：精益求精，与你同行&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了支持插件的按需加载，BetterScroll 2.0 采用了 &lt;strong&gt;插件化&lt;/strong&gt; 的架构设计。CoreScroll 作为最小的滚动单元，暴露了丰富的&lt;strong&gt;事件&lt;/strong&gt;以及&lt;strong&gt;钩子&lt;/strong&gt;，其余的功能都由不同的插件来扩展，这样会让 BetterScroll 使用起来更加的灵活，也能适应不同的场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 BetterScroll 2.0 整体的架构图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4513844172569221&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jQmwTIFl1V1BfwhPstDvHYES7xlBBYY2PhUl40e7PDrHvqylicccdubBiaozljZuZmLgTUI6V30eOOiajFoKfKCCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1553&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图片来源：https://juejin.im/post/6868086607027650573）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该项目采用的是 monorepos 的组织方式，使用 lerna 进行多包管理，每个组件都是一个独立的 npm 包：&lt;/p&gt;&lt;img data-ratio=&quot;0.6098360655737705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V1BfwhPstDvHYES7xlBBYY2fcF9E22sKTSpMwW515OkMQTWK2szOFeawxenRCFjx7u4l6gXuN0hag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1220&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与西瓜播放器一样，BetterScroll 2.0 也是采用 &lt;strong&gt;插件化&lt;/strong&gt; 的设计思想，CoreScroll 作为最小的滚动单元，其余的功能都是通过插件来扩展。&lt;span&gt;比如长列表中常见的上拉加载和下拉刷新功能，在 BetterScroll 2.0  中这些功能分别通过 &lt;/span&gt;&lt;code&gt;pull-up&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;pull-down&lt;/code&gt;&lt;span&gt; 这两个插件来实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插件化的好处之一就是可以支持按需加载，此外把独立功能都拆分成独立的插件，会让核心系统更加稳定，拥有一定的健壮性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的，简单介绍了一下 BetterScroll，接下来我们步入正题来分析一下这个项目中一些值得我们学习的地方。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、开发体验方面&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 更好的智能提示&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BetterScroll 2.0 采用 TypeScript 进行开发，为了让开发者在使用 BetterScroll 时能够拥有较好的智能提示，BetterScroll 团队充分利用了 TypeScript 接口自动合并的功能，让开发者在使用某个插件时，能够有对应的 Options 提示以及  bs（BetterScroll 实例）能够有对应的方法提示。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.1 智能插件 Options 提示&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4986842105263158&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V1BfwhPstDvHYES7xlBBYY2db1nXjGNiakgcnCDbUX7TXBEEqxW2jDjRW7uiaKcRbQJdiczWe0EH8WoA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1520&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.2 智能 BetterScroll 实例方法提示&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.506578947368421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V1BfwhPstDvHYES7xlBBYY2KsS4SC276pLj1YZpsicsnrIdPrWJ8tEFtpvD1uKmnW4mP352nibxqbQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1520&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，为了后面能更好地理解 BetterScroll 的设计思想，我们先来简单介绍一下插件化架构。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、插件化架构简介&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 插件化架构的概念&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插件化架构（Plug-in Architecture），是一种面向功能进行拆分的可扩展性架构，通常用于实现基于产品的应用。插件化架构模式允许你将其他应用程序功能作为插件添加到核心应用程序，从而提供可扩展性以及功能分离和隔离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插件化架构模式包括两种类型的架构组件：&lt;strong&gt;核心系统（Core System）和插件模块（Plug-in modules）&lt;/strong&gt;。应用逻辑被分割为独立的插件模块和核心系统，提供了可扩展性、灵活性、功能隔离和自定义处理逻辑的特性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V1BfwhPstDvHYES7xlBBYY2HmEUZ34icH7Ss8bwY4eFLq5NpTBVR8JvOn3owdRM4j7M37YiavibgLl9A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;650&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中 Core System 的功能相对稳定，不会因为业务功能扩展而不断修改，而插件模块是可以根据实际业务功能的需要不断地调整或扩展。&lt;strong&gt;插件化架构的本质就是将可能需要不断变化的部分封装在插件中，从而达到快速灵活扩展的目的，而又不影响整体系统的稳定。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插件化架构的核心系统通常提供系统运行所需的最小功能集。插件模块是独立的模块，包含特定的处理、额外的功能和自定义代码，来向核心系统增强或扩展额外的业务能力。&lt;strong&gt;通常插件模块之间也是独立的，也有一些插件是依赖于若干其它插件的。重要的是，尽量减少插件之间的通信以避免依赖的问题。&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 插件化架构的优点&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;灵活性高：整体灵活性是对环境变化快速响应的能力。由于插件之间的低耦合，改变通常是隔离的，可以快速实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可测试性：插件可以独立测试，也很容易被模拟，不需修改核心系统就可以演示或构建新特性的原型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能高：虽然插件化架构本身不会使应用高性能，但通常使用插件化架构构建的应用性能都还不错，因为可以自定义或者裁剪掉不需要的功能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍完插件化架构相关的基础知识，接下来我们来分析一下 BetterScroll 2.0 是如何设计插件化架构的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、BetterScroll 插件化架构实现&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于插件化的核心系统设计来说，它涉及三个关键点：插件管理、插件连接和插件通信。下面我们将围绕这三个关键点来逐步分析 BetterScroll 2.0 是如何实现插件化架构。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 插件管理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了统一管理内置的插件，也方便开发者根据业务需求开发符合规范的自定义插件。BetterScroll 2.0 约定了统一的插件开发规范。&lt;strong&gt;BetterScroll 2.0 的插件需要是一个类，并且具有以下特性：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.静态的 pluginName 属性；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.实现 PluginAPI 接口（当且仅当需要把插件方法代理至 bs）；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.constructor 的第一个参数就是 BetterScroll 实例 &lt;code&gt;bs&lt;/code&gt;，你可以通过 bs 的 &lt;strong&gt;事件&lt;/strong&gt; 或者 &lt;strong&gt;钩子&lt;/strong&gt; 来注入自己的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里为了直观地理解以上的开发规范，我们将以内置的 PullUp 插件为例，来看一下它是如何实现上述规范的。PullUp 插件为 BetterScroll 扩展上拉加载的能力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35145888594164454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V1BfwhPstDvHYES7xlBBYY2gpkbibaFrnk68icQnic4vxfrnOtygj3sTIJogVSHXyRh0RadybeTMAgXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1508&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义，静态的 &lt;code&gt;pluginName&lt;/code&gt; 属性表示插件的名称，而 PluginAPI 接口表示插件实例对外提供的 API 接口，通过 PluginAPI 接口可知它支持 4 个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;finishPullUp(): void：结束上拉加载行为；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;openPullUp(config?: PullUpLoadOptions): void：动态开启上拉功能；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;closePullUp(): void：关闭上拉加载功能；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;autoPullUpLoad(): void：自动执行上拉加载。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插件通过构造函数注入 BetterScroll 实例 &lt;code&gt;bs&lt;/code&gt;，之后我们就可以通过 bs 的&lt;strong&gt;事件&lt;/strong&gt;或者&lt;strong&gt;钩子&lt;/strong&gt;来注入自己的逻辑。那么为什么要注入 bs 实例？如何利用 bs 实例？这里我们先记住这些问题，后面我们再来分析它们。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 插件连接&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心系统需要知道当前有哪些插件可用，如何加载这些插件，什么时候加载插件。常见的实现方法是插件注册表机制。核心系统提供插件注册表（可以是配置文件，也可以是代码，还可以是数据库），插件注册表含有每个插件模块的信息，包括它的名字、位置、加载时机（启动就加载，或是按需加载）等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们以前面提到的 PullUp 插件为例，来看一下如何注册和使用该插件。首先你需要使用以下命令安装 PullUp 插件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; npm install @better-scroll/pull-up --save&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;成功安装完 pullup 插件之后，你需要通过 &lt;code&gt;BScroll.use&lt;/code&gt; 方法来注册插件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; BScroll &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@better-scroll/core&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Pullup &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@better-scroll/pull-up&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;BScroll.use(Pullup)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，实例化 BetterScroll 时需要传入 PullUp 插件的配置项。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; BScroll(&lt;span&gt;&#x27;.bs-wrapper&#x27;&lt;/span&gt;, {&lt;br/&gt;  pullUpLoad: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经知道通过 &lt;code&gt;BScroll.use&lt;/code&gt; 方法可以注册插件，那么该方法内部做了哪些处理？要回答这个问题，我们来看一下对应的源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// better-scroll/packages/core/src/BScroll.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; BScroll = (createBScroll &lt;span&gt;as&lt;/span&gt; unknown) &lt;span&gt;as&lt;/span&gt; BScrollFactory&lt;br/&gt;createBScroll.use = BScrollConstructor.use&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;BScroll.ts&lt;/code&gt; 文件中， &lt;code&gt;BScroll.use&lt;/code&gt; 方法指向的是 &lt;code&gt;BScrollConstructor.use&lt;/code&gt; 静态方法，该方法的实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BScrollConstructor&amp;lt;O = {}&amp;gt; &lt;span&gt;extends&lt;/span&gt; EventEmitter {&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; plugins: PluginItem[] = []&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; pluginsMap: PluginsMap = {}&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; use(ctor: PluginCtor) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; name = ctor.pluginName&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; installed = BScrollConstructor.plugins.some(&lt;br/&gt;      &lt;span&gt;(&lt;span&gt;plugin&lt;/span&gt;) =&amp;gt;&lt;/span&gt; ctor === plugin.ctor&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (installed) &lt;span&gt;return&lt;/span&gt; BScrollConstructor&lt;br/&gt;    BScrollConstructor.pluginsMap[name] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    BScrollConstructor.plugins.push({&lt;br/&gt;      name,&lt;br/&gt;      applyOrder: ctor.applyOrder,&lt;br/&gt;      ctor,&lt;br/&gt;    })&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; BScrollConstructor&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过观察以上代码，可知 &lt;code&gt;use&lt;/code&gt; 方法接收一个参数，该参数的类型是 &lt;code&gt;PluginCtor&lt;/code&gt;，用于描述插件构造函数的特点。&lt;code&gt;PluginCtor&lt;/code&gt; 类型的具体声明如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; PluginCtor {&lt;br/&gt;  pluginName: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;  applyOrder?: ApplyOrder&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; (scroll: BScroll): &lt;span&gt;any&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们调用 &lt;code&gt;BScroll.use(Pullup)&lt;/code&gt; 方法时，会先获取当前插件的名称，然后判断当前插件是否已经安装过了。如果已经安装则直接返回 BScrollConstructor 对象，否则会对插件进行注册。即把当前插件的信息分别保存到 pluginsMap（{}） 和 plugins（[]） 对象中：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4937833037300178&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V1BfwhPstDvHYES7xlBBYY2eSNcNGLy9geia0bNpx7cibyzntdHlBt69E60anI0YhDgK1Czopuh6sPQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1126&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外调用 &lt;code&gt;use&lt;/code&gt; 静态方法后，会返回 &lt;code&gt;BScrollConstructor&lt;/code&gt; 对象，这是为了支持链式调用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;BScroll.use(MouseWheel)&lt;br/&gt;  .use(ObserveDom)&lt;br/&gt;  .use(PullDownRefresh)&lt;br/&gt;  .use(PullUpLoad)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经知道 &lt;code&gt;BScroll.use&lt;/code&gt; 方法内部是如何注册插件的，注册插件只是第一步，要使用已注册的插件，我们还需要在实例化 BetterScroll 时传入插件的配置项，从而进行插件的初始化。对于 PullUp 插件，我们通过以下方式进行插件的初始化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; BScroll(&lt;span&gt;&#x27;.bs-wrapper&#x27;&lt;/span&gt;, {&lt;br/&gt;  pullUpLoad: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以想了解插件是如何连接到核心系统并进行插件初始化，我们就需要来分析一下 &lt;code&gt;BScroll&lt;/code&gt; 构造函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// packages/core/src/BScroll.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; BScroll = (createBScroll &lt;span&gt;as&lt;/span&gt; unknown) &lt;span&gt;as&lt;/span&gt; BScrollFactory&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createBScroll&lt;/span&gt;&amp;lt;&lt;span&gt;O&lt;/span&gt; = &lt;/span&gt;{}&amp;gt;(&lt;br/&gt;  el: ElementParam,&lt;br/&gt;  options?: Options &amp;amp; O&lt;br/&gt;): BScrollConstructor &amp;amp; UnionToIntersection&amp;lt;ExtractAPI&amp;lt;O&amp;gt;&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; bs = &lt;span&gt;new&lt;/span&gt; BScrollConstructor(el, options)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (bs &lt;span&gt;as&lt;/span&gt; unknown) &lt;span&gt;as&lt;/span&gt; BScrollConstructor &amp;amp;&lt;br/&gt;    UnionToIntersection&amp;lt;ExtractAPI&amp;lt;O&amp;gt;&amp;gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;createBScroll&lt;/code&gt; 工厂方法内部会通过 &lt;code&gt;new&lt;/code&gt; 关键字调用 &lt;code&gt;BScrollConstructor&lt;/code&gt; 构造函数来创建 BetterScroll 实例。因此接下来的重点就是分析 &lt;code&gt;BScrollConstructor&lt;/code&gt; 构造函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// packages/core/src/BScroll.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BScrollConstructor&amp;lt;O = {}&amp;gt; &lt;span&gt;extends&lt;/span&gt; EventEmitter {&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;el: ElementParam, options?: Options &amp;amp; O&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; wrapper = getElement(el)&lt;br/&gt;    &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.plugins = {}&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.hooks = &lt;span&gt;new&lt;/span&gt; EventEmitter([...])&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.init(wrapper)&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; init(wrapper: MountedBScrollHTMLElement) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.wrapper = wrapper&lt;br/&gt;    &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.applyPlugins()&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过阅读 BScrollConstructor 的源码，我们发现在 BScrollConstructor 构造函数内部会调用 &lt;code&gt;init&lt;/code&gt; 方法进行初始化，而在 &lt;code&gt;init&lt;/code&gt; 方法内部会进一步调用 &lt;code&gt;applyPlugins&lt;/code&gt; 方法来应用已注册的插件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// packages/core/src/BScroll.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BScrollConstructor&amp;lt;O = {}&amp;gt; &lt;span&gt;extends&lt;/span&gt; EventEmitter {  &lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; applyPlugins() {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; options = &lt;span&gt;this&lt;/span&gt;.options&lt;br/&gt;    BScrollConstructor.plugins&lt;br/&gt;      .sort(&lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; applyOrderMap = {&lt;br/&gt;          [ApplyOrder.Pre]: &lt;span&gt;-1&lt;/span&gt;,&lt;br/&gt;          [ApplyOrder.Post]: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; aOrder = a.applyOrder ? applyOrderMap[a.applyOrder] : &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; bOrder = b.applyOrder ? applyOrderMap[b.applyOrder] : &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; aOrder - bOrder&lt;br/&gt;      })&lt;br/&gt;      .forEach(&lt;span&gt;(&lt;span&gt;item: PluginItem&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; ctor = item.ctor&lt;br/&gt;    &lt;span&gt;// 当启用指定插件的时候且插件构造函数的类型是函数的话，再创建对应的插件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (options[item.name] &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; ctor === &lt;span&gt;&#x27;function&#x27;&lt;/span&gt;) {&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.plugins[item.name] = &lt;span&gt;new&lt;/span&gt; ctor(&lt;span&gt;this&lt;/span&gt;)&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;applyPlugins&lt;/code&gt; 方法内部会根据插件设置的顺序进行排序，然后会使用 &lt;code&gt;bs&lt;/code&gt; 实例作为参数调用插件的构造函数来创建插件，并把插件的实例保存到 &lt;code&gt;bs&lt;/code&gt; 实例内部的 plugins（{}） 属性中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3193916349809886&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V1BfwhPstDvHYES7xlBBYY25KHjT9QFz9qdpLdpYrt5lwQhcod8CcZNVcjXmGibcAQQen3U5kb7Z1A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1578&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里我们已经介绍了插件管理和插件连接，下面我们来介绍最后一个关键点 —— 插件通信。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 插件通信&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插件通信是指插件间的通信。虽然设计的时候插件间是完全解耦的，但实际业务运行过程中，必然会出现某个业务流程需要多个插件协作，这就要求两个插件间进行通信；&lt;strong&gt;由于插件之间没有直接联系，通信必须通过核心系统，因此核心系统需要提供插件通信机制&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况和计算机类似，计算机的 CPU、硬盘、内存、网卡是独立设计的配置，但计算机运行过程中，CPU 和内存、内存和硬盘肯定是有通信的，计算机通过主板上的总线提供了这些组件之间的通信功能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.78&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jQmwTIFl1V1BfwhPstDvHYES7xlBBYY2AezItQZ0Z2FbTqSMpBxzGvY0VfoOcpIMsOBcQsiaLYLIYQSXX0ro2ng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，对于插件化架构的系统来说，通常核心系统会以事件总线的形式提供插件通信机制。提到事件总线，可能有一些小伙伴会有一些陌生。但如果说是使用了 &lt;strong&gt;发布订阅模式&lt;/strong&gt; 的话，应该就很容易理解了。这里阿宝哥不打算在展开介绍发布订阅模式，只用一张图来回顾一下该模式。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5759599332220368&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V1BfwhPstDvHYES7xlBBYY2PkLXibdy0NliaoicXTdwVba30LeES2yEspvXQia4VprdqX5ejrpD1W7vvw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1198&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 BetterScroll 来说，它的核心是 &lt;code&gt;BScrollConstructor&lt;/code&gt; 类，该类继承了 &lt;code&gt;EventEmitter&lt;/code&gt; 事件派发器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// packages/core/src/BScroll.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BScrollConstructor&amp;lt;O = {}&amp;gt; &lt;span&gt;extends&lt;/span&gt; EventEmitter {  &lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;el: ElementParam, options?: Options &amp;amp; O&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.hooks = &lt;span&gt;new&lt;/span&gt; EventEmitter([&lt;br/&gt;      &lt;span&gt;&#x27;refresh&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&#x27;enable&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&#x27;disable&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&#x27;destroy&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&#x27;beforeInitialScrollTo&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&#x27;contentChanged&#x27;&lt;/span&gt;,&lt;br/&gt;    ])&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.init(wrapper)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;EventEmitter 类是由 BetterScroll 内部提供的，它的实例将会对外提供事件总线的功能，而该类对应的 UML 类图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48295454545454547&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V1BfwhPstDvHYES7xlBBYY2MItBaUVFSvC4lrkL2rB34mpK9QbTxKRgfRnfEc85rm9aJBRtxSoaAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;704&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲到这里我们就可以来回答前面留下的第一个问题：“那么为什么要注入 bs 实例？”。因为 bs（BScrollConstructor）实例的本质也是一个事件派发器，在创建插件时，注入 bs 实例是为了让插件间能通过统一的事件派发器进行通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个问题我们已经知道答案了，接下来我们来看第二个问题：”如何利用 bs 实例？“。要回答这个问题，我们将继续以 PullUp 插件为例，来看一下该插件内部是如何利用 bs 实例进行消息通信的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PullUp &lt;span&gt;implements&lt;/span&gt; PluginAPI {&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; pluginName = &lt;span&gt;&#x27;pullUpLoad&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;&lt;span&gt;public&lt;/span&gt; scroll: BScroll&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.init()&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 PullUp 构造函数中，bs 实例会被保存到 PullUp 实例内部的 &lt;code&gt;scroll&lt;/code&gt; 属性中，之后在 PullUp 插件内部就可以通过注入的 bs 实例来进行事件通信。比如派发插件的内部事件，在 PullUp 插件中，当距离滚动到底部小于 &lt;code&gt;threshold&lt;/code&gt; 值时，触发一次 &lt;code&gt;pullingUp&lt;/code&gt; 事件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; checkPullUp(pos: { x: &lt;span&gt;number&lt;/span&gt;; y: &lt;span&gt;number&lt;/span&gt; }) {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { threshold } = &lt;span&gt;this&lt;/span&gt;.options&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (...) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.pulling = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.scroll.trigger(PULL_UP_HOOKS_NAME) &lt;span&gt;// &#x27;pullingUp&#x27;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道如何利用 bs 实例派发事件之后，我们再来看一下在插件内部如何利用它来监听插件所感兴趣的事件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// packages/pull-up/src/index.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PullUp &lt;span&gt;implements&lt;/span&gt; PluginAPI {&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; pluginName = &lt;span&gt;&#x27;pullUpLoad&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;&lt;span&gt;public&lt;/span&gt; scroll: BScroll&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.init()&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; init() {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.handleBScroll()&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.handleOptions(&lt;span&gt;this&lt;/span&gt;.scroll.options.pullUpLoad)&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.handleHooks()&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.watch()&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 PullUp 构造函数中会调用 &lt;code&gt;init&lt;/code&gt; 方法进行插件初始化，而在 &lt;code&gt;init&lt;/code&gt; 方法内部会分别调用不同的方法执行不同的初始化操作，这里跟事件相关的是 &lt;code&gt;handleHooks&lt;/code&gt; 方法，该方法的实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; handleHooks() {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.hooksFn = []&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.registerHooks(&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scroll.hooks,&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scroll.hooks.eventTypes.contentChanged,&lt;br/&gt;    &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.finishPullUp()&lt;br/&gt;    }&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显在 &lt;code&gt;handleHooks&lt;/code&gt; 方法内部，会进一步调用 &lt;code&gt;registerHooks&lt;/code&gt; 方法来注册钩子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; registerHooks(hooks: EventEmitter, name: &lt;span&gt;string&lt;/span&gt;, handler: &lt;span&gt;Function&lt;/span&gt;) {&lt;br/&gt;  hooks.on(name, handler, &lt;span&gt;this&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.hooksFn.push([hooks, name, handler])&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过观察 &lt;code&gt;registerHooks&lt;/code&gt; 方法的签名可知，它支持 3 个参数，第 1 个参数是 &lt;code&gt;EventEmitter&lt;/code&gt; 对象，而另外 2 个参数分别表示事件名和事件处理器。在 &lt;code&gt;registerHooks&lt;/code&gt; 方法内部，它就是简单地通过 &lt;code&gt;hooks&lt;/code&gt; 对象来监听指定的事件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 &lt;code&gt;this.scroll.hooks&lt;/code&gt; 对象是什么时候创建的呢？在 &lt;code&gt;BScrollConstructor&lt;/code&gt; 构造函数中我们找到了答案。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// packages/core/src/BScroll.ts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BScrollConstructor&amp;lt;O = {}&amp;gt; &lt;span&gt;extends&lt;/span&gt; EventEmitter {&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;el: ElementParam, options?: Options &amp;amp; O&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.hooks = &lt;span&gt;new&lt;/span&gt; EventEmitter([&lt;br/&gt;      &lt;span&gt;&#x27;refresh&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&#x27;enable&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&#x27;disable&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&#x27;destroy&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&#x27;beforeInitialScrollTo&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&#x27;contentChanged&#x27;&lt;/span&gt;,&lt;br/&gt;    ]) &lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显&lt;span&gt; &lt;/span&gt;&lt;code&gt;this.hooks&lt;/code&gt;&lt;span&gt; &lt;/span&gt;也是一个&lt;span&gt; &lt;/span&gt;&lt;code&gt;EventEmitter&lt;/code&gt;&lt;span&gt; 对象&lt;/span&gt;，所以可以通过它来进行事件处理。好的，插件通信的内容就先介绍到这里，下面我们用一张图来总结一下该部分的内容：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5238095238095238&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V1BfwhPstDvHYES7xlBBYY2N0KibZYT1xLh1wRu6cAsrsjoXOequDib4GTb9kNwLarEEWg4q1tlNCAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1218&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍完 BetterScroll 插件化架构的实现，最后我们来简单聊一下 BetterScroll 项目工程化方面的内容。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五、工程化方面&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在工程化方面，BetterScroll 使用了业内一些常见的解决方案：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;lerna：Lerna 是一个管理工具，用于管理包含多个软件包（package）的 JavaScript 项目。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;prettier：Prettier 中文的意思是漂亮的、美丽的，是一个流行的代码格式化的工具。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tslint：TSLint 是可扩展的静态分析工具，用于检查 TypeScript 代码的可读性，可维护性和功能性错误。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;commitizen &amp;amp; cz-conventional-changelog：用于帮助我们生成符合规范的 commit message。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;husky：husky 能够防止不规范代码被 commit、push、merge 等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jest：Jest 是由 Facebook 维护的 JavaScript 测试框架。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;coveralls：用于获取 Coveralls.io 的覆盖率报告，并在 README 文件中添加一个不错的覆盖率按钮。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;vuepress：Vue 驱动的静态网站生成器，它用于生成 BetterScroll 2.0 的文档。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为本文的重点不在工程化，所以上面阿宝哥只是简单罗列了 BetterScroll 在工程化方面使用的开源库。如果你对 BetterScroll 项目也感兴趣的话，可以看看项目中的 &lt;code&gt;package.json&lt;/code&gt; 文件，并重点看一下项目中 &lt;strong&gt;npm scripts&lt;/strong&gt; 的配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然 BetterScroll 项目还有很多值得学习的地方，剩下的就等大家去发掘吧，欢迎感兴趣的小伙伴跟阿宝哥一起交流与讨论。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;六、参考资源&lt;span/&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>