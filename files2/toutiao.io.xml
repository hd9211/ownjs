<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>dd725b1b0ae3074638a3bbb369005e7a</guid>
<title>撸猫必备三件套，立即下单现价仅需8.9元！</title>
<link>https://toutiao.io/k/14kxbpf</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;


&lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7741dff969960664aecfa95530f9c2fb</guid>
<title>[推荐] 非常哇塞的 ES读场景、写场景 性能优化指南！你值得拥有！</title>
<link>https://toutiao.io/k/5pjb28q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4767123287671233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES作为NoSQL数据库里非常重要的一员，使用越来越广泛。虽然它因为索引延迟的原因，数据在时效性上有一些缺陷，但其大容量、分布式的优秀设计，使得它在时效性要求并不是特别高的类实时搜索领域，能够大展身手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据使用场景和用途，ES可以分为写入和读取两种典型的应用方式。比如ELKB，我们就需要额外关注它的&lt;code&gt;写优化&lt;/code&gt;；再比如从MySQL中同步数据到ES的宽表，我们就需要额外关注它的&lt;code&gt;读优化&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废话不多说，我们直接show一下优化方法。如果你对ES的一些概念还不是很清楚，建议收藏本文慢慢看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.写入优化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志属于写多读少的业务场景，对写入速度要求很高。拿我们其中一个集群来说，单集群日志量达到百TB，每秒钟日志写入量达到10W条。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据写入，主要有三个动作：flush、refresh和merge。通过调整它们的行为，即可在性能和数据可靠性之间进行权衡。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 translog异步化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，ES需要写一份translog，它类似于MySQL中的redolog，为的是避免在断电的时候数据丢失。ES默认每次请求都进行一次flush，但对于日志来说，这没有必要，可以将这个过程改为异步的，刷盘间隔为60秒。参数如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl-H&lt;span&gt;&quot;Content-Type: application/json&quot;&lt;/span&gt;-XPUT&lt;span&gt;&#x27;http://localhost:9200/_all/_settings?preserve_existing=true&#x27;&lt;/span&gt;-d&lt;span&gt;&#x27;{&lt;br/&gt;  &quot;index.translog.durability&quot; : &quot;async&quot;,&lt;br/&gt;  &quot;index.translog.flush_threshold_size&quot; : &quot;512mb&quot;,&lt;br/&gt;  &quot;index.translog.sync_interval&quot; : &quot;60s&quot;&lt;br/&gt;}&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这可以说是最重要的一步优化了，对性能的影响最大，但在极端情况下会有丢失部分数据的可能。对于日志系统来说，是可以忍受的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 增加refresh间隔&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了写translog，ES还会将数据写入到一个缓冲区中。但是注意了！此时，缓冲区的内容是无法被搜索到的，它还需要写入到segment里面才可以，也就是刷新到lucence索引里面。这就是refresh动作，默认1秒。也就是你写入的数据，大概率1秒之后才会被搜索到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是为什么ES不是实时搜索系统的原因，它从数据写入到数据读出，一般是有一个合并过程的，有一定的时间差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过index.refresh_interval可以修改这个刷新间隔。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于日志系统来说，当然要把它调大一点啦。xjjdog这里调整到了120s，减少了这些落到segment的频率，I/O的压力自然会小，写入速度自然会快。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl-H&lt;span&gt;&quot;Content-Type: application/json&quot;&lt;/span&gt;-XPUT&lt;span&gt;&#x27;http://localhost:9200/_all/_settings?preserve_existing=true&#x27;&lt;/span&gt;-d&lt;span&gt;&#x27;{&lt;br/&gt;  &quot;index.refresh_interval&quot; : &quot;120s&quot;&lt;br/&gt;}&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 merge&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;merge其实是lucene的机制，它主要是合并小的segment块，生成更大的segment，来提高检索的速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因就是refresh过程会生成一大堆小segment文件，数据删除也会产生空间碎片。所以merge，通俗来讲就像是碎片整理进程。像postgresql等，也有vaccum进程在干同样的事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显而易见，这种整理操作，既浪费I/O，又浪费CPU。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的系统merge非常频繁，那么调整merge的块大小和频率，是一个比较好的方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.读取优化&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 指定路由&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你向ES里写数据，那么它会为你设置一个离散的隐藏ID，落到哪个分片，是不一定的。如果你根据一个查询条件查询数据，你设置了6个shards的话，它要查询6次才行。如果能够在路由的时候就知道数据在哪个分片上，查询速度自然会上升，这就要求我们在构造数据的时候，人工指定路由规则。它的实际运行规则如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;shard = &lt;span&gt;hash&lt;/span&gt;(routing) % number_of_primary_shards&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，一个查询会变成这样。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;GET my-index-000001/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;terms&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;_routing&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;user1&quot;&lt;/span&gt; ] &lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，如果你的查询维度较多，又对数据的查询速度有非常高的有求，根据routing存放多份数据是一个比较好的选择。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 rollover冷热分离&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rollover根据索引大小，文档数或使用期限自动过渡到新索引。当rollover触发后，将创建新索引，写别名将更新为指向新索引，所有后续更新都将写入新索引，比如&lt;code&gt;indexname-000001.&lt;/code&gt;这种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从rollover这个名字可以看出来，它和Java的log日志有一定的相似之处，比如Log4j的RollingFileAppender。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当索引变的非常大，通常是几十GB，那它的查询效率将变的非常的低，索引重建的成本也较大。实际上，很多索引的数据在时间维度上有较为明显的规律，一些冷数据将很少被用到。这个时候，建立滚动索引将是一个比较好的办法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;滚动索引一般可以与索引模板结合使用，实现按一定条件自动创建索引，ES的官方文档有具体的_rollover建立方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 使用BoolQuery替代TermQuery&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bool查询现在包括四种子句，must、filter、should和must_not。Bool查询是true、false对比，而TermQuery是精确的字符串比对，所以如果需求相似，BoolQuery自然会快于TermQuery。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 将大查询拆成分段查询&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些业务的查询比较复杂，我们不得不拼接一张非常大的宽表放在ES中，这有两个比较明显的问题。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;宽表的数据往往需要从其他数据源中回查拼接而成，数据更新时对源库或者ES本身都有较大的压力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务的查询JSON需要书写的非常复杂，查询效率未知，一次查询锁定的内存过高，无法进行深入优化&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，宽表不论在RDBMS中还是ES中，都会与复杂的查询语句有关，其锁定时间都较长，业务也不够灵活。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应对这种场景的策略，通常将复杂的数据查询，转移到业务代码的拼接上来。比如，将一段非常冗长的单条查询，拆分成循环遍历的100条小查询。所有的数据库都对较小的查询请求有较好的响应，其整体性能整体上将优于复杂的单条查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对我们的ES索引建模能力和编码能力提出了挑战。毕竟，在ES层面，互不相关的几个索引，将作为整体为其他服务提供所谓的数据中台接口。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 增加第一次索引的速度&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多业务的索引数据往往来自于MySQL等传统数据库，第一次索引往往是全量索引，后面才是增量索引。必要的时候，也会进行索引的重建，大量的数据灌入造成了ES的索引速度建立缓慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了缓解这种情况，建议在创建索引的时候，把副本数量设置成1，即没有从副本。等所有数据索引完毕，再将副本数量增加到正常水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，数据能够快速索引，副本会在后台慢慢复制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.通用优化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，我们还可以针对ES做一些通用的优化。比如，使用监控接口或者trace工具，发现线程池有明显的瓶颈，则需要调整线程池的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的优化项如下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 线程池优化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新版本对线程池的配置进行了优化，不需要配置复杂的search、bulk、index线程池。有需要配置下面几个就行了：thread_pool.get.size, thread_pool.write.size, thread_pool.listener.size, thread_pool.analyze.size。具体可观测_cat/thread_pool接口暴露的数据进行调整。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 物理冷热分离&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的rollover接口，我们可以实现索引滚动。但是如何将冷数据存放在比较慢但是便宜的节点上？如何将某些索引移动过去？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES支持给节点打标签，具体方式是在elasticsearch.yml文件中增加一些属性。比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//热节点&lt;/span&gt;&lt;br/&gt;node.attr.temperature: hot &lt;br/&gt;&lt;span&gt;//冷节点&lt;/span&gt;&lt;br/&gt;node.attr.temperature: cold &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;节点有了冷热属性后，接下来就是指定数据的冷热属性，来设置和调整数据分布。ES提供了index shard filtering功能来实现索引的迁移。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，可以对索引也设置冷热属性。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;PUT hot_data_index/_settings&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;index.routing.allocation.require.temperature&quot;&lt;/span&gt;: &lt;span&gt;&quot;hot&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些索引将自动转移到冷设备上。我们可以写一些定时任务，通过_cat接口的数据，自动的完成这个转移过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 多磁盘分散I/O&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，可以通过配置多块磁盘的方式，来分散I/O的压力，但容易会造成数据热点集中在单块磁盘上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES支持在一台机器上配置多块磁盘，所以在存储规模上有更大的伸缩性。在配置文件中，配置path.data属性，即可挂载多块磁盘。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;path.data : /data1, /data2, /data3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，如果你是在扩容，那么就需要配合reroute接口进行索引的重新分配。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 减少单条记录的大小&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lucene的索引建立过程，非常耗费CPU，可以减少倒排索引的数量来减少CPU的损耗。第一个优化就是减少字段的数量；第二个优化就是减少索引字段的数量。具体的操作，是将不需要搜索的字段，index属性设置为not_analyzed或者no。至于_source和_all，在实际调试中效果不大，不再赘述。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;End&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES的使用越来越广泛，从ELKB到APM，从NoSQL到搜索引擎，ES在企业中的地位也越来越重要。本文通过分析ES写入和读取场景的优化，力求从原理到实践层面，助你为ES加速。希望你在使用ES时能够更加得心应手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，一个ES集群对配置的要求是较高的，尤其是APM等场景，甚至会占到PaaS平台的1/3资源甚至更多。ES提供了较多的配置选项，我们可以根据应用场景，调整ES的表现，使其更好的为我们服务。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：&lt;strong&gt;小姐姐味道&lt;/strong&gt;  (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1c012d41cbbfad492738e4d915df738e</guid>
<title>[推荐] 画架构图的神器</title>
<link>https://toutiao.io/k/4773s9p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;fieldset&gt;&lt;section data-brushtype=&quot;text&quot;&gt;架构师（JiaGouX）&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;我们都是架构师！&lt;br/&gt;架构未来，你来不来？&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/fieldset&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwNjQwNzU2NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RCNb3RYsCgx02T4J55ia2SnemY7uJHsDChxq6jAibbATlIKDgzLxz0zekXWjblzCDcL86AjbMNp02Tg/0?wx_fmt=png&quot; data-nickname=&quot;架构师&quot; data-alias=&quot;JiaGouX&quot; data-signature=&quot;架构师云集，三高（高可用、高性能、高稳定）架构、大数据、机器学习、Java架构、系统架构、大规模分布式架构、人工智能等的架构讨论交流，以及结合互联网技术的架构调整，大规模架构实战分享。欢迎有想法、乐于分享的架构师交流学习。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看过我以往文章的小伙伴可能会发现，我的大部分文章都有很多配图。我的文章风格是图文相结合，更便于大家理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近有很多小伙伴发私信问我：文章中的图是用什么工具画的。他们觉得我画的图风格挺小清新的，能够让人眼前一亮。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先上几张图让大家看看效果：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7021996615905245&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEcQeQVeSPhd00alFgESSqkDNsO0rWriam0JoiccWGEP4ewJdibk25nZZiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1182&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.513677811550152&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBESNLJibcUXjyxw8wBM9S04knvpJRWzxGQzQcYATR48MicUtbTHKkGax4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1316&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4361525704809287&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBExhcMHxwz8Qq45Q2sJeBBTxLtWGRaaFHkRbHLicrPn8ZVKnObEiaKMxkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1206&quot;/&gt;说实话，问我的人太多了，我真的没法一个个回复。同时问我的人多，也恰恰说明了这个工具的优秀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天特地写一篇介绍画图工具的文章，给有需要的朋友一个参考。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 用什么画的图？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于画流程图的工具，之前大家用得比较多的可能是：&lt;code&gt;visio&lt;/code&gt;和&lt;code&gt;process on&lt;/code&gt;了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;visio&lt;/code&gt;是微软的一款画图软件，需要在电脑上安装，正版软件是付费的，但网上也可以搜到很多破解版。它是我用过的最早的画流程图工具了，后面使用mac电脑办公之后，就没有用过它了，之前觉得它跨电脑办公有点不方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;process on&lt;/code&gt;是一款免费在线画图工具，功能非常强大。除了常规的各种流程图之外，对于思维导图支持也非常友好。但有个缺点是只能免费保存最近9张图，想保留更多的图，需要付费升级。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的两款画图工具，说到底还是收费的，对于喜欢白嫖的我们来说，有点无法接受。那么，有没有一款免费、在线、功能强大的画流程图的工具呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：有，可以使用：&lt;code&gt;diagrams&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，我文章中的图都是用&lt;code&gt;diagrams&lt;/code&gt;画出来的，也可以叫它：&lt;code&gt;draw.io&lt;/code&gt;，它已经成为了我画图首选工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这款画图工具的官网地址是：https://app.diagrams.net/，它的前身是：https://draw.io/。这两个url都能访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时它也提供了离线版的画图软件，大家可以自己下载diagrams的安装软件，不过有个坏处是它是收费的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我用的最多的还是在线版的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 如何进入画图界面？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面已经知道，我的文章都是用&lt;code&gt;diagrams&lt;/code&gt;画流程图的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如何进入diagrams的画图界面呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在浏览器上输入diagrams的官网地址，我平时喜欢输入：&lt;code&gt;https://draw.io/&lt;/code&gt;，因为它比较好记。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次访问的时候有点慢，因为它要初始化一些东西。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2803819444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEkicr9pN4EjtlBrLhFveOKiawBA7NZN0to7h7d08apyjvJz7CuwSLibLCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2304&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，会弹出一个窗口，让我们选择画的图，需要保存到哪里。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48214285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEz6LoWib1bdic6VXFiaXYyP0lJtZY9hwU0959MFVMRyOCp22aZLCFFSzzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2464&quot;/&gt;它主要支持四种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;OneDrive：即云&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Device：即设备&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Gitlab&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我目前为了图方便，用的最多的是&lt;code&gt;Device&lt;/code&gt;，它可以把画的图保存到本地电脑，也可以从本地电脑导入已有的图。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实如果可以的话，把图保存到&lt;code&gt;Github&lt;/code&gt;，也是个不错的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，会弹出一个窗口，让你选择是Create New Diagram（创建新流程图），还是选择Open Existing Diagram（打开已有的流程图）。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7270471464019851&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBESZhribz7pkaq82baW6iaYnb27QE16vR5CLLHvJqultLNhC70zGDxN31w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;806&quot;/&gt;我们第一次进来，当然是选择创建新流程图了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，进入了画流程图的主界面：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5746388443017657&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBE6yxHRaA0VhHxKurYQ3t7Y1d6oATeaD2ibibZgL1lxxqt6a9swiaQnNMlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2492&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 画图界面的组成部分&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;diagrams的工作界面主要是由以下几个部分组成：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5211155378486055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEdYwF3yvNND7Qxkm97LZ2W079xic5VzuVU73ozAZQia8T4rA4SicDyyM6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2510&quot;/&gt;此外，在这里顺便说一句，如果你想修改流程图名称的话，可以双击左上角的：&lt;code&gt;Untitled Diagram.drawio&lt;/code&gt;这几个字，会弹出如下窗口：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38235294117647056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEaSJ3tFGJ0OpyJYCibudZL736yskF1rl2ezw3eNcuicWrFUngdnxZwqiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;816&quot;/&gt;在这个窗口中可以修改流程图的名称和文件类型，默认是&lt;code&gt;.drawio&lt;/code&gt;格式的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图总结一下，diagrams的工作界面主要组成部分：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7270788912579957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEUZzzvjNiaicf6LFmHibuZTb2Iouia8dGLwbrSZXJGuuQtQq3ORFxADcKzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.1 菜单栏&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11148648648648649&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEMiaKwpoRmxicKG3H09elk4dxGqAmOghCQOG3r3DHArJbrQ6tTrqBLC5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;592&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;File&lt;/code&gt;菜单：包含了一系列的文件操作，包括：新建、打开文件、打开最近的文件、保存文件、另存为文件、分享文件、重命名、拷贝文件、导入、导出、打印、关闭等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Edit&lt;/code&gt;菜单：包含了一系列工作区的操作，包括：回退、撤回、剪切、复制、粘贴、删除、查找、替换、编辑、编辑属性、选择、全选等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;View&lt;/code&gt;菜单：包含了一系列的视图操作，包括：恢复默认布局、大纲视图、图层、标签、网格、滚动条、全屏等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Arrange&lt;/code&gt;菜单：包含了一系列图形排列操作，包含：在前面、在后面、插入图形、对齐等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Extras&lt;/code&gt;菜单：包含了一系列额外的操作，包含：主题、展开、收缩、插件、编辑画图区、配置等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Help&lt;/code&gt;菜单：主要包含一系列全局的操作，包含：搜索、快捷键、关于等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.2 工具栏&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.02857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBE7528BHib30X3v53TI2IZL7fhPETiabuP803sm5WnFgXDxE5EVxCkVMibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2450&quot;/&gt;工具栏中包含了一些常用的功能，比如：图片尺寸、放大、缩小、退回、撤销、删除、在前、在后、背景色、字体颜色、连接、阴影、添加表格、添加图形、全屏、展开、收缩等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些功能真的太实用了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.3 左边图形区&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个区域可以选择我们画图时，需要的图形，默认有这7类图形。&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;1066&quot; data-backw=&quot;426&quot; data-ratio=&quot;2.5023474178403755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEhpZOib4Nmfj6kgDMcFo3jNfy2nPsYfWSeIicP9PODU2K6RkRNCI7GqPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;426&quot;/&gt;如果不满足要求，可以点击 More Shapes 按钮，选择更多类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.739568345323741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEhNNAoyh3nTtsThQde1HLlXw7ozIibVzSnr6socA0cGDt2wwlGBouY1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1390&quot;/&gt;上图中我另外加了&lt;code&gt;IOS&lt;/code&gt;类的图形。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我个人喜欢使用&lt;code&gt;General&lt;/code&gt;类的图形：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7208121827411167&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBE0Wm1lb7mrxKaQhAicFu7tav8qmywMovZ8sphbWn6yVbibhSzEvNlmyJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;里面常用的图形都有，画一般的流程图是够用的。当然你也可以根据个人喜欢，选择更多的类型画图。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.4 画图区&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6675257731958762&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEmnCP8AoM9dnhbKI8oNrB8BKPnUZic1EoADIFt4OW0wokNgveAZVbzng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1552&quot;/&gt;画图区是最重要的地方了，你的流程图是在这片区域完成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以在左边的图形区选择好图形之后，用鼠标拖到画图区。也可以直接在画图区复制已有的图形。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以加网格：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5284653465346535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBE63d8GR4EVibKM6yvoMSeibVm4EwIbaEOJpKjELjjMbU4I2so8KL2GrHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1616&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;右键空白的地方，会出现一些操作选项：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9698492462311558&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBE4AXjicv7EWaicbJSBwn4XU0Np31XJ5TKVmfoXoGpNrRNMrgKoG2ibia12Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;796&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;右键某个具体图形，会出现一些图形相关的选项：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2914691943127963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBETmAzsHLaXdcIcQUU97GHAyVUfMp6o6EnpSAPrAXqibOa3VFxqD5ibbEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.5 右边样式区&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9958333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEMGxGicRBdDxKxThGMVOXcbDJtqlvxP8OELrz9CgvB0oXGpcrFzMfKnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;480&quot;/&gt;右边样式区可以说是diagrams的灵魂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择的图形，在画图区默认是这样的：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4981949458483754&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEoE4aibg7hv82N12zGycZQcgIiaAZm9y8mMFwgiapFzcpMBPQIl5sk7LQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;一眼看过去，显得非常单调。但如果在右边样式区，我加了一些样式之后，图形马上变得不一样了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5981554677206851&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEukaBHqX4lRUIpQOdh51vV2fX0PRedu66fVb1icrKPPCHzicEJWL4Curw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1518&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于文本样式也有挺多功能可以设置的：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5431606905710491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEPxjjibSXOgF7zGlLBmLXh5UAg5svf7lfz3LNqnal3ZLwwYHNUxHfw8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1506&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.6 底部&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05672823218997362&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEseqOogg5tHGPRrD16A2NrRWUhro0jcO1gSqL5icvqDHwLicDHIoicqfsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1516&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;底部主要展示的是每页的名称。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击左侧三个点：&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;422&quot; data-backw=&quot;438&quot; data-ratio=&quot;0.9634703196347032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEJF9XiaACQqqWGYkR6FEP8Xib4kBCdDLYXlD7FiaQH0LSJyTDic6xa9SNjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;438&quot;/&gt;可以切换、插入、删除和重命名页面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;点击右侧的加号：&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09336099585062241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEDDRebca26ZSVDGIjWiaErmofVNMPWPliacrjKxVpJFQHvKzSjxFYsprg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;span&gt;可以立刻新增页面。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们每次画图需要在某个页面上操作。&lt;/span&gt;&lt;span&gt;但如果你需要画的图很多，可以使用页进行归类，方面今后维护。&lt;/span&gt;&lt;span&gt;不太建议，一页上画的图太多，不然画图时会非常卡。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要介绍了diagrams画图工具，它是一款免费的在线画图工具，也叫做draw.io。它的功能非常强大，包括：菜单栏、工具栏、左边图形区、画图区、右边样式区、底部等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时还介绍了如何进入画图区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然本文只是抛砖引玉，给大家介绍了diagrams的一小部分功能。它的强大之处，需要大家自己多动手摸索。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图给大家展示一下，我是如何使用diagrams画图的：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47346938775510206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBETZ3yDdsUI1XpZEHlPX7IHhHaGg3iaCzcBvTHRNdIvmEEqy6U65FQmVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2450&quot;/&gt;好了，今天的内容先分享到这里，我们下期再见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果大家觉得这个工具不错，或者看了我的分享有些收获的话，请帮我点个在看。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如喜欢本文，请点击右上角，把文章分享到朋友圈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如有想了解学习的技术点，请留言给若飞安排分享&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;·END·&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools-id=&quot;23409&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作者：苏三呀    &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：苏三说技术&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;版权申明：&lt;/span&gt;&lt;span&gt;内容来源网络，版权归原创者所有。&lt;/span&gt;&lt;span&gt;除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。&lt;/span&gt;&lt;span&gt;谢谢!&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;article ng-controller=&quot;EntryCtrl&quot; ui-lightbox=&quot;&quot;&gt;&lt;section ng-bind-html=&quot;postContentTrustedHtml&quot;&gt;&lt;section data-id=&quot;702&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;架构师&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;我们都是架构师！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img border=&quot;0&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RB58TtkIHwhn4lpsqLnZgian9d5tr1BibP7XpibGTFFib1nq9YuYq209XZUEfCOqMzepDOBbN9KD9wMSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-width=&quot;200px&quot; height=&quot;&quot; opacity=&quot;&quot; title=&quot;&quot; vspace=&quot;0&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;关注&lt;/strong&gt;架构师(JiaGouX)，添加“星标”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;获取每天技术干货，一起成为牛逼架构师&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;技术群请&lt;/strong&gt;&lt;strong&gt;加若飞：&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;1321113940 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;进架构师群&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投稿、合作、版权等邮箱：&lt;strong&gt;&lt;span&gt;admin@137x.com&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/article&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c23d048cdaa3a668d501f399e25bacf1</guid>
<title>[推荐] 再见了 VMware，一款更轻量级的虚拟机！</title>
<link>https://toutiao.io/k/xw2lnva</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;pre&gt;&lt;section class=&quot;js_darkmode__1&quot;&gt;&lt;span&gt;公众号关注&lt;/span&gt;&lt;span&gt; “GitHubDaily”&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;设为 “&lt;/span&gt;&lt;span&gt;星标&lt;/span&gt;&lt;span&gt;”，每天带你逛 GitHub！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcs8C07b1Ih2doNmiaicSttMccejE1onYNcszau24r6lIzHr6Fib3XlicibHcg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;大家好，我是小 G。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近，打算在 &lt;/span&gt;&lt;strong&gt;Mac&lt;/strong&gt;&lt;span&gt; 电脑上安装一个虚拟机，用来学习 &lt;/span&gt;&lt;strong&gt;K8S&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;首先想到的是 &lt;strong&gt;Vmware&lt;/strong&gt; 和 &lt;strong&gt;Parallels Desktop&lt;/strong&gt;，然后打开浏览器找了找，发现都只提供付费版本，只有 &lt;strong&gt;Parallels Desktop&lt;/strong&gt; 提供了 &lt;strong&gt;14&lt;/strong&gt; 天的免费试用。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsCKOCmkQFvjvr9uqCL45fUVicA4uFf5iaNiaicY6kcTXK9rxfOWicwicWwh4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot; title=&quot;无法白嫖&quot;/&gt;&lt;figcaption&gt;无法白嫖&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;然后，开始尝试使用免费 &lt;strong&gt;VirtualBox&lt;/strong&gt;，但是在安装 &lt;strong&gt;CentOS&lt;/strong&gt; 的时候，貌似因为 &lt;strong&gt;MacOS&lt;/strong&gt; 最新版本的原因，总是报错，花费了好几天的时间，试过各种方案，最终解决无果，就放弃了。。&lt;/p&gt;&lt;p&gt;就在陌溪要放弃的时候，突然在 &lt;strong&gt;Ubuntu&lt;/strong&gt; 官网进行冲浪的时候，发现了一款叫 &lt;strong&gt;Multipass&lt;/strong&gt; 的东西。&lt;/p&gt;&lt;p&gt;它可以快速在电脑上快速搭建一个轻量级的虚拟机，并且相比于 &lt;strong&gt;Vmware&lt;/strong&gt; 更加轻量，只需一行命令快速创建 &lt;strong&gt;Ubuntu&lt;/strong&gt; 虚拟机。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Multipass&lt;/strong&gt; 是一个轻量虚拟机管理器，是由 &lt;strong&gt;Ubuntu&lt;/strong&gt; 运营公司 &lt;strong&gt;Canonical&lt;/strong&gt; 所推出的开源项目。运行环境支持 &lt;strong&gt;Linux&lt;/strong&gt;、&lt;strong&gt;Windows&lt;/strong&gt;、&lt;strong&gt;macOS&lt;/strong&gt;。在不同的操作系统上，使用的是不同的虚拟化技术。在 &lt;strong&gt;Linux&lt;/strong&gt; 上使用的是 &lt;strong&gt;KVM&lt;/strong&gt;、&lt;strong&gt;Window&lt;/strong&gt; 上使用 &lt;strong&gt;Hyper-V&lt;/strong&gt;、&lt;strong&gt;macOS&lt;/strong&gt; 中使用 &lt;strong&gt;HyperKit&lt;/strong&gt; 以最小开销运行VM，支持在笔记本模拟小型云。&lt;/p&gt;&lt;p&gt;同时，&lt;strong&gt;Multipass&lt;/strong&gt; 提供了一个命令行界面来启动和管理 &lt;strong&gt;Linux&lt;/strong&gt; 实例。下载一个全新的镜像需要几秒钟的时间，并且在几分钟内就可以启动并运行 &lt;strong&gt;VM&lt;/strong&gt;。（直呼好家伙，大大降低的我们安装虚拟机的成本了）&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Multipass官网：https://multipass.run/&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5435185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsQ45NQiaofsON9YRJTedbwFRuqjGRIxDJ3icaxa7jicJRXoxrI4iapRSyGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;Multipass官网&quot;/&gt;&lt;figcaption&gt;Multipass官网&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;开始使用&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在使用 &lt;strong&gt;Multipass&lt;/strong&gt; 之前 ，首先需要安装 &lt;strong&gt;Multipass&lt;/strong&gt; 工具，可以打开官网进行下载&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https:&lt;span&gt;//multipass.run/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;选择对应的操作系统，因为我的是 &lt;strong&gt;Mac&lt;/strong&gt; 电脑，所以选择 MacOS，点击 &lt;strong&gt;Download&lt;/strong&gt; 开始下载&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36018518518518516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsw2biaGewZU8V4TKK2tE67EnX91WqwFBhLu1lbMewrialrl419NIdwfIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;image-20211120120019913&quot;/&gt;&lt;figcaption&gt;选择对应版本安装&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果电脑装了 &lt;strong&gt;brew&lt;/strong&gt; 可以直接命令行下载安装:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;brew&lt;/span&gt; cask install multipass&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下载安装成功后, 执行以下命令可以查看当前软件版本:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; --version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装成功后，点击运行，即可打开 &lt;strong&gt;Multipass&lt;/strong&gt; 客户端，这里能够快速的通过 &lt;strong&gt;Open Shell&lt;/strong&gt; 创建和启动一个虚拟机&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7735849056603774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcs8hqCKQmRFhia7ic3pgBhtL2gd9M55Rf0Gib3icFE6YeqZ28P2b7hiaNyf5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot; title=&quot;Multipass客户端&quot;/&gt;&lt;figcaption&gt;Multipass客户端&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;下面，我们来介绍如何通过命令的方式，创建一台虚拟机&lt;/p&gt;&lt;h2&gt;&lt;span&gt;创建Ubuntu虚拟机&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;首先，通过以下指令查看可供下载的 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; find&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行成功后，可以看到下面的这些镜像列表，包含各种版本的&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Image&lt;/span&gt;                       &lt;span&gt;Aliases&lt;/span&gt;           &lt;span&gt;Version&lt;/span&gt;          &lt;span&gt;Description&lt;/span&gt;&lt;br/&gt;&lt;span&gt;core&lt;/span&gt;                        &lt;span&gt;core16&lt;/span&gt;            20200818         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Core&lt;/span&gt; 16&lt;br/&gt;&lt;span&gt;core18&lt;/span&gt;                                        20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Core&lt;/span&gt; 18&lt;br/&gt;18&lt;span&gt;.04&lt;/span&gt;                       &lt;span&gt;bionic&lt;/span&gt;            20211109         &lt;span&gt;Ubuntu&lt;/span&gt; 18&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;20&lt;span&gt;.04&lt;/span&gt;                       &lt;span&gt;focal&lt;/span&gt;,&lt;span&gt;lts&lt;/span&gt;         20211118         &lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;21&lt;span&gt;.04&lt;/span&gt;                       &lt;span&gt;hirsute&lt;/span&gt;           20211119         &lt;span&gt;Ubuntu&lt;/span&gt; 21&lt;span&gt;.04&lt;/span&gt;&lt;br/&gt;21&lt;span&gt;.10&lt;/span&gt;                       &lt;span&gt;impish&lt;/span&gt;            20211103         &lt;span&gt;Ubuntu&lt;/span&gt; 21&lt;span&gt;.10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:adguard-home&lt;/span&gt;                        20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;AdGuard&lt;/span&gt; &lt;span&gt;Home&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:mosquitto&lt;/span&gt;                           20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Mosquitto&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:nextcloud&lt;/span&gt;                           20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Nextcloud&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:openhab&lt;/span&gt;                             20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;openHAB&lt;/span&gt; &lt;span&gt;Home&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:plexmediaserver&lt;/span&gt;                     20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Plex&lt;/span&gt; &lt;span&gt;Media&lt;/span&gt; &lt;span&gt;Server&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;anbox-cloud-appliance&lt;/span&gt;                         &lt;span&gt;latest&lt;/span&gt;           &lt;span&gt;Anbox&lt;/span&gt; &lt;span&gt;Cloud&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;minikube&lt;/span&gt;                                      &lt;span&gt;latest&lt;/span&gt;           &lt;span&gt;minikube&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; &lt;span&gt;Kubernetes&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下载最新版的 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像并运行，初次创建时需要下载 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像，网络畅通的情况下，稍等片刻即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; launch -n vm01 -c &lt;span&gt;1&lt;/span&gt; -m &lt;span&gt;1G&lt;/span&gt; -d &lt;span&gt;10G&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;自定义配置创建可以参考如下方式:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;-n, --name: 名称&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-c, --cpus: cpu核心数, 默认: 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-m, --mem: 内存大小, 默认: 1G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-d, --disk: 硬盘大小, 默认: 5G&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;操作虚拟机&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;查看虚拟机列表&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;虚拟机创建完成后，可以使用 &lt;strong&gt;multipass list&lt;/strong&gt; 命令进行查看虚拟机列表&lt;/p&gt;&lt;pre&gt;&lt;code&gt;% &lt;span&gt;multipass&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Name&lt;/span&gt;                    &lt;span&gt;State&lt;/span&gt;             &lt;span&gt;IPv4&lt;/span&gt;             &lt;span&gt;Image&lt;/span&gt;&lt;br/&gt;&lt;span&gt;vm01&lt;/span&gt;                    &lt;span&gt;Running&lt;/span&gt;           192&lt;span&gt;.168.64.2&lt;/span&gt;     &lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到目前正在运行一台 &lt;strong&gt;Ubuntu 20.04&lt;/strong&gt; 版本的虚拟机，并且对应的 &lt;strong&gt;IP&lt;/strong&gt; 地址为 &lt;strong&gt;192.168.64.2&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;外部操作虚拟机&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;strong&gt;multipass exec&lt;/strong&gt; 命令在实例内执行给定的命令。第一个参数是运行命令的实例，也就是 &lt;strong&gt;vm01&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们通过 &lt;strong&gt;exec&lt;/strong&gt; 命令，就可以在外部操作刚刚创建的虚拟机，例如查看内部所处的目录，执行 &lt;strong&gt;pwd&lt;/strong&gt; 命令&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; multipass &lt;span&gt;exec&lt;/span&gt; vm01 &lt;span&gt;pwd&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;/home/ubuntu&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;查看虚拟机信息&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;strong&gt;multipass info&lt;/strong&gt; 命令，即可查看当前运行的虚拟机信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# &lt;span&gt;multipass&lt;/span&gt; &lt;span&gt;info&lt;/span&gt; &lt;span&gt;vm01&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Name&lt;/span&gt;:           &lt;span&gt;vm01&lt;/span&gt;&lt;br/&gt;&lt;span&gt;State&lt;/span&gt;:          &lt;span&gt;Running&lt;/span&gt;&lt;br/&gt;&lt;span&gt;IPv4&lt;/span&gt;:           192&lt;span&gt;.168.64.2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Release&lt;/span&gt;:        &lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04.3&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Image&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;:     91740&lt;span&gt;d72ffff&lt;/span&gt; (&lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;Load&lt;/span&gt;:           0&lt;span&gt;.00&lt;/span&gt; 0&lt;span&gt;.00&lt;/span&gt; 0&lt;span&gt;.00&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Disk&lt;/span&gt; &lt;span&gt;usage&lt;/span&gt;:     1&lt;span&gt;.3G&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; 9&lt;span&gt;.5G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Memory&lt;/span&gt; &lt;span&gt;usage&lt;/span&gt;:   170&lt;span&gt;.9M&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; 1&lt;span&gt;.9G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Mounts&lt;/span&gt;:         &lt;span&gt;--&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;进入虚拟机&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;strong&gt;multipass shell&lt;/strong&gt; 命令，即可进入到虚拟机内部&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; shell vm01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行后的结果如下所示，可以看到目前虚拟机的一些系统配置信息，以及内存和磁盘的使用情况&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7129629629629629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcskVp6KUe7Mm9HbLT6dmUhJzpnabyPt7rKHAbulLKO6ib1UUMNrsN0xXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;image-20211121085114961&quot;/&gt;&lt;figcaption&gt;进入虚拟机内部&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;同时会运行一个新的 &lt;strong&gt;Ubuntu&lt;/strong&gt; 系统，此时便进入到了&lt;strong&gt;Ubuntu&lt;/strong&gt; 环境中, 在里面可以执行相关的 &lt;strong&gt;linux&lt;/strong&gt; 指令&lt;/p&gt;&lt;p&gt;当然如果不想进入系统内部，也可以通过上述提到的 &lt;strong&gt;multipass exce&lt;/strong&gt; 命令，来操作 &lt;strong&gt;Ubuntu&lt;/strong&gt; 系统&lt;/p&gt;&lt;p&gt;首先执行下面命令，给系统设置一个 &lt;strong&gt;root&lt;/strong&gt; 密码，设置好密码后，使用 &lt;strong&gt;su root&lt;/strong&gt; 切换到 &lt;strong&gt;root&lt;/strong&gt; 用户&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 设置密码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sudo&lt;/span&gt; passwd&lt;br/&gt;&lt;span&gt;# 切换 root&lt;/span&gt;&lt;br/&gt;su root&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;ubuntu&lt;/strong&gt; 是使用 &lt;strong&gt;apt-get&lt;/strong&gt; 来进行包管理的，首先更新一下 &lt;strong&gt;apt-get&lt;/strong&gt;，然后安装 &lt;strong&gt;nginx&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 更新apt&lt;/span&gt;&lt;br/&gt;apt-get &lt;span&gt;update&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 安装 nginx&lt;/span&gt;&lt;br/&gt;apt-&lt;span&gt;get&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装好 &lt;strong&gt;nginx&lt;/strong&gt; 后，可以到 /etc/nginx 目录即可看到刚刚的 &lt;strong&gt;nginx&lt;/strong&gt; 配置信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;root@vm01&lt;span&gt;:/lost+found&lt;/span&gt;&lt;span&gt;# cd /etc/nginx/&lt;/span&gt;&lt;br/&gt;root@vm01&lt;span&gt;:/etc/nginx&lt;/span&gt;&lt;span&gt;# ls&lt;/span&gt;&lt;br/&gt;conf.d        fastcgi_params  koi-win     modules-available  nginx.conf    scgi_params      sites-enabled  uwsgi_params&lt;br/&gt;fastcgi.conf  koi-utf         mime.types  modules-enabled    proxy_params  sites-available  snippets       win-utf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面我们可以测试一下，&lt;strong&gt;nginx&lt;/strong&gt; 是否安装成功，在 &lt;strong&gt;mac&lt;/strong&gt; 上打开浏览器，输入虚拟机的 &lt;strong&gt;ip&lt;/strong&gt; 地址 &lt;strong&gt;192.168.64.2&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsUBdjGbOeCEodmicmTpQIYIe9oBNlhExhKudlB5HqryPI1YeAa5UKvGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;image-20211121094727506&quot;/&gt;&lt;figcaption&gt;nginx安装成功&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;可以看出，目前 &lt;strong&gt;nginx&lt;/strong&gt; 已经成功运行了，后续的话，可能会考虑在上面部署更多的应用，感兴趣的小伙伴欢迎关注～&lt;/p&gt;&lt;h3&gt;&lt;span&gt;挂载数据卷&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;multipass&lt;/strong&gt; 还提供和 &lt;strong&gt;Docker&lt;/strong&gt; 一样的挂载数据卷的功能，能够与外部宿主机的文件保持同步。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 挂载格式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;multipass&lt;/span&gt; mount 宿主机目录  实例名:虚拟机目录&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面，我在用户的目录下，创建一个 &lt;strong&gt;hello&lt;/strong&gt; 目录&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 创建hello目录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;mkdir&lt;/span&gt; hello&lt;br/&gt;&lt;span&gt;# 挂载&lt;/span&gt;&lt;br/&gt;multipass mount /Users/moxi/hello  vm01:/hello&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;挂载完成后，我们回到实例 vm01 中，可以看出多了一个 &lt;strong&gt;hello&lt;/strong&gt; 文件夹，说明已经成功挂载～&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18181818181818182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsWKnic6p04c1vu5iaTib7bziaz2iaZwXCZutNm18U6wng3t7ljIBUldLHiayA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;528&quot; title=&quot;image-20211121110217283&quot;/&gt;&lt;figcaption&gt;挂载成功&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;因此，以后在 &lt;strong&gt;vm01&lt;/strong&gt; 的 &lt;strong&gt;hello文件夹&lt;/strong&gt; 中创建的文件，都会在的宿主机的 &lt;strong&gt;hello 文件夹&lt;/strong&gt;同步显示&lt;/p&gt;&lt;h3&gt;&lt;span&gt;卸载数据卷&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;如果以后不需要用到挂载了，可以使用 &lt;strong&gt;unmount&lt;/strong&gt; 命令卸载&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#卸载数据卷&lt;/span&gt;&lt;br/&gt;&lt;span&gt;multipass&lt;/span&gt; umount 容器名&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;传输文件&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;除了使用上述的 &lt;strong&gt;mount&lt;/strong&gt; 挂载卷的方式实现文件的交互，同时还可以通过 transfer 命令，将宿主机的文件，发送到虚拟机内部&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; transfer 主机文件 容器名:容器目录&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如，将 &lt;strong&gt;hello.txt&lt;/strong&gt; 发送到&lt;/p&gt;&lt;pre&gt;&lt;code&gt;multipass transfer hello.txt vm01:&lt;span&gt;/home/ubuntu/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;删除和释放实例&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;使用下面的命令，可以开启、停止、删除和释放实例&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 启动实例&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;start&lt;/span&gt; vm01&lt;br/&gt;&lt;span&gt;# 停止实例&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;stop&lt;/span&gt; vm01&lt;br/&gt;&lt;span&gt;# 删除实例（删除后，还会存在）&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;delete&lt;/span&gt; vm01&lt;br/&gt;&lt;span&gt;# 释放实例（彻底删除）&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;purge&lt;/span&gt; vm01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;容器配置自动化&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;为了保持开发环境和线上环境一致性 同时节省部署时间 &lt;strong&gt;multipass&lt;/strong&gt; 给我们提供了 &lt;strong&gt;--cloud-init&lt;/strong&gt; 选项进行容器启动初始化配置:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; &lt;span&gt;launch&lt;/span&gt; &lt;span&gt;--name&lt;/span&gt; &lt;span&gt;ubuntu&lt;/span&gt; &lt;span&gt;--cloud-init&lt;/span&gt; &lt;span&gt;config&lt;/span&gt;&lt;span&gt;.yaml&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面 &lt;strong&gt;config.yaml&lt;/strong&gt; 则是容器的初始化配置文件，例如，我们想在初始化容器的时候，自动下载安装 &lt;strong&gt;Node.js&lt;/strong&gt;，内容如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#cloud-config&lt;/span&gt;&lt;br/&gt;runcmd:&lt;br/&gt;  - curl -sL https:&lt;span&gt;//deb.nodesource.com/setup_12.x | sudo -E bash -&lt;/span&gt;&lt;br/&gt;  - sudo apt-&lt;span&gt;get&lt;/span&gt; install -y nodejs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;runcmd&lt;/code&gt; 可以指定容器 &lt;strong&gt;首次启动&lt;/strong&gt; 时运行的命令&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;凡是用户自定义的cloud-init的配置文件,必须以#cloud-config开头，这是cloud-init识别它的方式。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;yaml&lt;/strong&gt; 配置文件可以参考下面的文章&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https://cloudinit.readthedocs.io/en/latest/topics/examples.html?highlight=&lt;span&gt;lock&lt;/span&gt;-passwd&lt;span&gt;#including-users-and-groups&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多关于 &lt;strong&gt;multipass&lt;/strong&gt; 的高阶的技巧，欢迎访问 &lt;strong&gt;multipass&lt;/strong&gt; 官方文档&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https:&lt;span&gt;//m&lt;/span&gt;ultipass.run&lt;span&gt;/docs/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好了，本期关于 &lt;strong&gt;Multipass&lt;/strong&gt; 的基础学习就到这里了，感兴趣的小伙伴环境下载自己动手学习呢～&lt;/p&gt;&lt;h2&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;使用了一阵子后，&lt;strong&gt;Multipass&lt;/strong&gt; 在使用起来很简洁直观，在整体操作上和 &lt;strong&gt;docker&lt;/strong&gt; 类似，如果想在自己电脑上快速搭建一个 &lt;strong&gt;Linux&lt;/strong&gt; 系统用于学习的话，选择使用 &lt;strong&gt;Multipass&lt;/strong&gt; 还是非常方便的。&lt;/p&gt;&lt;p&gt;唯一不足的地方就是，&lt;strong&gt;Multipass&lt;/strong&gt; 是由 &lt;strong&gt;Ubuntu&lt;/strong&gt; 背后的 &lt;strong&gt;Canonical&lt;/strong&gt; 公司开发的，因此 &lt;strong&gt;Multipass&lt;/strong&gt; 所使用的镜像也都是 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像（这也可以理解，毕竟支持自家的产品），不过对于习惯了使用 &lt;strong&gt;CentOS&lt;/strong&gt; 的用户来说，还是用些许不太习惯。&lt;/p&gt;&lt;p&gt;不过瑕不掩瑜，&lt;strong&gt;Multipass&lt;/strong&gt; 在我看来还是一款非常棒的软件～&lt;/p&gt;&lt;p&gt;另外，它的代码也在 GitHub 开源了，需要进一步研究的小伙伴也可以看下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;GitHub：https://github.com/canonical/multipass&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxOTcxNTIwNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28ia8xsyOClt8NDDCTAZNaDsEic4EEpUG1FPduFr5TUMK1GbDiaFX0qNCJiaS2XPfHzWlFicK95v1a9ic7Vg/0?wx_fmt=png&quot; data-nickname=&quot;GitHubDaily&quot; data-alias=&quot;GitHubDaily&quot; data-signature=&quot;专注于分享 GitHub 上知名的 Python、Java、Web、AI、数据分析等多个领域的优质学习资源、开源项目及开发者工具，为 GitHub 开发者提供优质编程资讯。&quot; data-from=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1650abb6796a707f506e2cb5cbe17f98</guid>
<title>[推荐] 面渣逆袭：JVM经典五十问，这下面试稳了！</title>
<link>https://toutiao.io/k/wideaab</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是老三，“&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkwODE5ODM0Ng==&amp;amp;action=getalbum&amp;amp;album_id=2041709347461709827&amp;amp;scene=173&amp;amp;from_msgid=2247488709&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;面渣逆袭&lt;/a&gt;“系列继续，这节我们来搞定JVM。说真的，JVM调优什么的一个程序员可能整个职业生涯都碰不到两次，但是，一旦用到的时候，那就是救命了，而且最重要的是——面试必问，所以，还能怎么办？整！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.什么是JVM?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM——Java虚拟机，它是Java实现平台无关性的基石。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java程序运行的时候，编译器将Java文件编译成平台无关的Java字节码文件（.class）,接下来对应平台JVM对字节码文件进行解释，翻译成对应平台匹配的机器指令并运行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT6sCpCRPEkDmXia2Af3mnSXiaDAdXlxP4crT1Ph9RZGg5rVyGzK4d3P4A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java语言编译运行&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时JVM也是一个跨语言的平台，和语言无关，只和class的文件格式关联，任何语言，只要能翻译成符合规范的字节码文件，都能被JVM运行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTNhiae9Zu0KoxXUE44fxKLMQTNwAdAfn4Ih4o16MUpPEGRdxk1MyXm6A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JVM跨语言&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内存管理&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.能说一下JVM的内存区域吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM内存区域最粗略的划分可以分为&lt;code&gt;堆&lt;/code&gt;和&lt;code&gt;栈&lt;/code&gt;，当然，按照虚拟机规范，可以划分为以下几个区域：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTrefbiarN08NsiabzYjseLpa5ib4rlxRWl3icjNQGZ6f6pcAmfZKiaOLTGbw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java虚拟机运行时数据区&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM内存分为线程私有区和线程共享区，其中&lt;code&gt;方法区&lt;/code&gt;和&lt;code&gt;堆&lt;/code&gt;是线程共享区，&lt;code&gt;虚拟机栈&lt;/code&gt;、&lt;code&gt;本地方法栈&lt;/code&gt;和&lt;code&gt;程序计数器&lt;/code&gt;是线程隔离的数据区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、程序计数器&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序计数器（Program Counter Register）也被称为PC寄存器，是一块较小的内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它可以看作是当前线程所执行的字节码的行号指示器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、Java虚拟机栈&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机栈描述的是Java方法执行的线程内存模型：方法执行时，JVM会同步创建一个栈帧，用来存储局部变量表、操作数栈、动态连接等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTN2lzU3fCTMeSzcuLs9N9CWxN7LGpHZ6B3v0iaAwPAzpickO70BCHiaplw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java虚拟机栈&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3、本地方法栈&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4、Java堆&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java里“&lt;strong&gt;几乎&lt;/strong&gt;”所有的对象实例都在这里分配内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现&lt;code&gt;新生代&lt;/code&gt;、&lt;code&gt;老年代&lt;/code&gt;、&lt;code&gt;Eden空间&lt;/code&gt;、&lt;code&gt;From Survivor空间&lt;/code&gt;、&lt;code&gt;To Survivor空间&lt;/code&gt;等名词，需要注意的是这种划分只是根据垃圾回收机制来进行的划分，不是Java虚拟机规范本身制定的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT0V3y5wXvIu5EQdSuAibX23yicpNNFfQ99CTZkhhYRGicvQh0HegfqQpGw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java 堆内存结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5.方法区&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法区是比较特别的一块区域，和堆类似，它也是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它特别在Java虚拟机规范对它的约束非常宽松，所以方法区的具体实现历经了许多变迁，例如jdk1.7之前使用永久代作为方法区的实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.说一下JDK1.6、1.7、1.8内存区域的变化？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK1.6、1.7/1.8内存区域发生了变化，主要体现在方法区的实现：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTcbdiaps8YA1WTibKewfAIEf82Y0ickAh2wB2iaD6yEVED9Kib8iaqKzS6T8A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JDK 1.6内存区域&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;JDK1.7时发生了一些变化，将字符串常量池、静态变量，存放在堆上&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTEsicg5FQqMuq51jv3hHfj6y0n3RXibicTZP8dDgQeiaXxflug804zicpuSw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JDK 1.7内存区域&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在JDK1.8时彻底干掉了永久代，而在直接内存中划出一块区域作为&lt;strong&gt;元空间&lt;/strong&gt;，运行时常量池、类常量池都移动到元空间。&lt;/p&gt;&lt;figure&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTLm5dph6wcoQ7LsBzWeWd9LqJNpPIGXOTfwj6oXAYL9pv9GtNsUq0JQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JDK 1.8内存区域&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.为什么使用元空间替代永久代作为方法区的实现？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机规范规定的方法区只是换种方式实现。有客观和主观两个原因。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客观上使用永久代来实现方法区的决定的设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法 （例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主观上当Oracle收购BEA获得了JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的 时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.对象创建的过程了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM中对象的创建，我们从一个new指令开始：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;类加载检查通过后，接下来虚拟机将为新生对象分配内存。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内存分配完成之后，虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接下来设置对象头，请求头里包含了对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程大概图示如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTI3SsibF3J171z2nX1QL460maVXOnL3GJTFicsO4y6iaIicFgMic4zsnSJyw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;对象创建过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.什么是指针碰撞？什么是空闲列表？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存分配有两种方式，&lt;strong&gt;指针碰撞&lt;/strong&gt;（Bump The Pointer）、&lt;strong&gt;空闲列表&lt;/strong&gt;（Free List）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTqkW9BcnpksRB5NcMtyjpwlKviayTmu68j4MflCtpY8oEl7dXsQkOicrw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;指针碰撞和空闲列表&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;指针碰撞：假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;空闲列表：如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两种方式的选择由Java堆是否规整决定，Java堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会，假设JVM虚拟机上，每一次new 对象时，指针就会向右移动一个对象size的距离，一个线程正在给A对象分配内存，指针还没有来的及修改，另一个为B对象分配内存的线程，又引用了这个指针来分配内存，这就发生了抢占。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两种可选方案来解决这个问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT76tQN7aZYXZhgc9v9pDxibzE4FoYWFSSHTZZwAV4PhjZgwmbceYAXAg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;堆抢占和解决方案&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;采用CAS分配重试的方式来保证更新操作的原子性&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个线程在Java堆中预先分配一小块内存，也就是本地线程分配缓冲（Thread Local Allocation&lt;/p&gt;&lt;p&gt;Buffer，TLAB），要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.能说一下对象的内存布局吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTY5FSkH1KVsMXcZnjc1ErBkakvpYmCr08wfb4BqEFzKVLqVBhMQQrOg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;对象的存储布局&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对象头&lt;/strong&gt;主要由两部分组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称它为Mark Word，它是个动态的结构，随着对象状态变化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二部分是类型指针，指向对象的类元数据类型（即对象代表哪个类）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此外，如果对象是一个Java数组，那还应该有一块用于记录数组长度的数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实例数据&lt;/strong&gt;用来存储对象真正的有效信息，也就是我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承的，还是自己定义的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对齐填充&lt;/strong&gt;不是必须的，没有特别含义，仅仅起着占位符的作用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;9.对象怎么访问定位？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java程序会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTXFcy5QuefJhIRibTDBr80RIficQPJN5rk8glVNQ0nRj9XL72ppLZTJiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;通过句柄访问对象&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTYldac8BLjSK1jQblvnPz5XOdwHsbSH0VDYCntop74tav3UQxIDr1nA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;通过直接指针访问对象&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HotSpot虚拟机主要使用直接指针来进行对象访问。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10.内存溢出和内存泄漏是什么意思？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄露就是申请的内存空间没有被正确释放，导致内存被白白占用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存溢出就是申请的内存超过了可用内存，内存不够了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两者关系：内存泄露可能会导致内存溢出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一个有味道的比喻，内存溢出就是排队去蹲坑，发现没坑位了，内存泄漏，就是有人占着茅坑不拉屎，占着茅坑不拉屎的多了可能会导致坑位不够用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTbl6wa1yZSXBJhnQYdo4EmKL91w2U3b3k8uFNV5sY7OHVNnIPricuq2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;内存泄漏、内存溢出&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;11.能手写内存溢出的例子吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM的几个内存区域中，除了程序计数器外，其他几个运行时区域都有发生内存溢出（OOM）异常的可能，重点关注堆和栈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java堆用于储存对象实例，只要不断创建不可被回收的对象，比如静态对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常（OutOfMemoryError）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就相当于一个房子里，不断堆积不能被收走的杂物，那么房子很快就会被堆满了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * VM参数： -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HeapOOM&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OOMObject&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;OOMObject&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;OOMObject&amp;gt;();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            list.add(&lt;span&gt;new&lt;/span&gt; OOMObject());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK使用的HotSpot虚拟机的栈内存大小是固定的，我们可以把栈的内存设大一点，然后不断地去创建线程，因为操作系统给每个进程分配的内存是有限的，所以到最后，也会发生OutOfMemoryError异常。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * vm参数：-Xss2M&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JavaVMStackOOM&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;dontStop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;stackLeakByThread&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    dontStop();&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;            thread.start();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        JavaVMStackOOM oom = &lt;span&gt;new&lt;/span&gt; JavaVMStackOOM();&lt;br/&gt;        oom.stackLeakByThread();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;12.内存泄漏可能由哪些原因导致呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄漏可能的原因有很多种：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTj2R64dfqznKMQcFWzASAQNSl9gcuDxbc6icjeMpe6GiaeI9Cbyu3ficqw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;内存泄漏可能原因&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;静态集合类引起内存泄漏&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OOM&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;static&lt;/span&gt; List list = &lt;span&gt;new&lt;/span&gt; ArrayList();&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;oomTests&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;   Object obj = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;&lt;br/&gt;   list.add(obj);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;单例模式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和上面的例子原理类似，单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据连接、IO、Socket等连接&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建的连接不再使用时，需要调用 &lt;strong&gt;close&lt;/strong&gt; 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            Connection conn = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            Class.forName(&lt;span&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;);&lt;br/&gt;            conn = DriverManager.getConnection(&lt;span&gt;&quot;url&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;            Statement stmt = conn.createStatement();&lt;br/&gt;            ResultSet rs = stmt.executeQuery(&lt;span&gt;&quot;....&quot;&lt;/span&gt;);&lt;br/&gt;          } &lt;span&gt;catch&lt;/span&gt; (Exception e) { &lt;br/&gt;           &lt;br/&gt;          }&lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//不关闭连接&lt;/span&gt;&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;变量不合理的作用域&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个变量的定义作用域大于其使用范围，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Simple&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Object object;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        object = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;        &lt;span&gt;//...其他代码&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//由于作用域原因，method1执行完成之后，object 对象所分配的内存不会马上释放&lt;/span&gt;&lt;br/&gt;        object = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;hash值发生变化&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象Hash值改变，使用HashMap、HashSet等容器中时候，由于对象修改之后的Hah值和存储进容器时的Hash值不同，所以无法找到存入的对象，自然也无法单独删除了，这也会造成内存泄漏。说句题外话，这也是为什么String类型被设置成了不可变类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ThreadLocal使用不当&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal的弱引用导致内存泄漏也是个老生常谈的话题了，使用完ThreadLocal一定要记得使用remove方法来进行清除。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;13.如何判断对象仍然存活？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两种方式，**引用计数算法（reference counting）**和可达性分析算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用计数器的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTZiaq73lOU6kKF1PmDdLnPnIDjFAfffCMTu5vP7BkKDopUiaDGvNx78HA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;引用计数算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（Gc Root Set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTwXhzhPuC1NmAzWXmE5FmZXwcMRz8thEPVc3lKkF74gILtribxRJ0LUg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;14.Java中可作为GC Roots的对象有哪几种？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以作为GC Roots的主要有四种对象：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;虚拟机栈(栈帧中的本地变量表)中引用的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法区中类静态属性引用的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法区中常量引用的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地方法栈中JNI引用的对象&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;15.说一下对象有哪几种引用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中的引用有四种，分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;强引用是最传统的&lt;code&gt;引用&lt;/code&gt;的定义，是指在程序代码之中普遍存在的引用赋值，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Object obj =&lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        Object obj = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;        ReferenceQueue queue = &lt;span&gt;new&lt;/span&gt; ReferenceQueue();&lt;br/&gt;        SoftReference reference = &lt;span&gt;new&lt;/span&gt; SoftReference(obj, queue);&lt;br/&gt;        &lt;span&gt;//强引用对象滞空，保留软引用&lt;/span&gt;&lt;br/&gt;        obj = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        Object obj = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;        ReferenceQueue queue = &lt;span&gt;new&lt;/span&gt; ReferenceQueue();&lt;br/&gt;        WeakReference reference = &lt;span&gt;new&lt;/span&gt; WeakReference(obj, queue);&lt;br/&gt;        &lt;span&gt;//强引用对象滞空，保留软引用&lt;/span&gt;&lt;br/&gt;        obj = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        Object obj = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;        ReferenceQueue queue = &lt;span&gt;new&lt;/span&gt; ReferenceQueue();&lt;br/&gt;        PhantomReference reference = &lt;span&gt;new&lt;/span&gt; PhantomReference(obj, queue);&lt;br/&gt;        &lt;span&gt;//强引用对象滞空，保留软引用&lt;/span&gt;&lt;br/&gt;        obj = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTzEruV6Mu4mKfWqZdAyicj71dyWhU4j6Kedwic2W4nwmaAj8EzoVFcDGw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;四种引用总结&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;16.finalize()方法了解吗？有什么作用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一个不太贴切的比喻，垃圾回收就是古代的秋后问斩，finalize()就是刀下留人，在人犯被处决之前，还要做最后一次审计，青天大老爷看看有没有什么冤情，需不需要刀下留人。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT76PAiaQLAV8hQpg8Ezg36uVItzNkqzX5jP66L2zl21Km74Uqcicw5DFg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;刀下留人&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。如果对象在在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它就”逃过一劫“；但是如果没有抓住这个机会，那么对象就真的要被回收了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;17.Java堆的内存分区了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照垃圾收集，将Java堆划分为**新生代 （Young Generation）&lt;strong&gt;和&lt;/strong&gt;老年代（Old Generation）**两个区域，新生代存放存活时间短的对象，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而新生代又可以分为三个区域，eden、from、to，比例是8：1：1，而新生代的内存分区同样是从垃圾收集的角度来分配的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTILmlIV9ECMWEVibImt63ebRsXqP6exzE0lNLQ8eJAV2cXicnk8jwLs0A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java堆内存划分&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;18.垃圾收集算法了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集算法主要有三种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;标记-清除算法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;见名知义，&lt;code&gt;标记-清除&lt;/code&gt;（Mark-Sweep）算法分为两个阶段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;标记&lt;/strong&gt; : 标记出所有需要回收的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;清除&lt;/strong&gt;：回收所有被标记的对象&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT03GOXRmjSQLq8Kp9AvtUFahuwI6ibIv4KzXt9whicxqDf2AJ0BRe3MiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;标记-清除算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-清除算法比较基础，但是主要存在两个缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;标记-复制算法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-复制算法解决了标记-清除算法面对大量可回收对象时执行效率低的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过程也比较简单：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTu9U2nWFMGA4rWRXW0qHGPiaNYzMicoMSibP848Sxwg3rLFfcrsh9VvTRA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;标记-复制算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种算法存在一个明显的缺点：一部分空间没有使用，存在空间的浪费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新生代垃圾收集主要采用这种算法，因为新生代的存活对象比较少，每次复制的只是少量的存活对象。当然，实际新生代的收集不是按照这个比例。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;标记-整理算法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了降低内存的消耗，引入一种针对性的算法：&lt;code&gt;标记-整理&lt;/code&gt;（Mark-Compact）算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTx2Iafn9HyDvr0UXP6fq41xVPvnAYQd0eJ7eP53XDEWR8j7F1FjZEag/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;标记-整理算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-整理算法主要用于老年代，移动存活对象是个极为负重的操作，而且这种操作需要Stop The World才能进行，只是从整体的吞吐量来考量，老年代使用标记-整理算法更加合适。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;19.说一下新生代的区域划分？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新生代的垃圾收集主要采用标记-复制算法，因为新生代的存活对象比较少，每次复制少量的存活对象效率比较高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于这种算法，虚拟机将内存分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。默认Eden和Survivor的大小比例是8∶1。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT4YHlwFclfhibRsibkPxqrp2eHSXY71WBAytV0CjrjdyoruE7s9rQeDRg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;新生代内存划分&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;20.Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC都是什么意思？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;部分收集&lt;/strong&gt;（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前&lt;strong&gt;只有&lt;/strong&gt;CMS收集器会有单独收集老年代的行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;整堆收集&lt;/strong&gt;（Full GC）：收集整个Java堆和方法区的垃圾收集。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;21.Minor GC/Young GC什么时候触发？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新创建的对象优先在新生代Eden区进行分配，如果Eden区没有足够的空间时，就会触发Young GC来清理新生代。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;22.什么时候会触发Full GC？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个触发条件稍微有点多，往下看：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTia2jz8FrptJQ3N8DQRmYTzogpLO2jiaVZV0ZPyTZdomnoolVWPaKvTOg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Full GC触发条件&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Young GC之前检查老年代&lt;/strong&gt;：在要进行 Young GC 的时候，发现&lt;code&gt;老年代可用的连续内存空间&lt;/code&gt; &amp;lt; &lt;code&gt;新生代历次Young GC后升入老年代的对象总和的平均大小&lt;/code&gt;，说明本次Young GC后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间,那就会触发 Full GC。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Young GC之后老年代空间不足&lt;/strong&gt;：执行Young GC之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象了，此时必须立即触发一次Full GC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;老年代空间不足&lt;/strong&gt;，老年代内存使用率过高，达到一定比例，也会触发Full GC。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;空间分配担保失败&lt;/strong&gt;（ Promotion Failure），新生代的 To 区放不下从 Eden 和 From 拷贝过来对象，或者新生代对象 GC 年龄到达阈值需要晋升这两种情况，老年代如果放不下的话都会触发 Full GC。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;方法区内存空间不足&lt;/strong&gt;：如果方法区由永久代实现，永久代空间不足 Full GC。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;System.gc()等命令触发&lt;/strong&gt;：System.gc()、jmap -dump 等命令会触发 full gc。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;23.对象什么时候会进入老年代？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTkR19bP4X5X1dqDVckbYcB8M68a3Aq4swUxickib8HBJKe3yYribgZNhHw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;对象进入老年代&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;长期存活的对象将进入老年代&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在对象的对象头信息中存储着对象的迭代年龄,迭代年龄会在每次YoungGC之后对象的移区操作中增加,每一次移区年龄加一.当这个年龄达到15(默认)之后,这个对象将会被移入老年代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过这个参数设置这个年龄值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;- XX:MaxTenuringThreshold&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;大对象直接进入老年代&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一些占用大量连续内存空间的对象在被加载就会直接进入老年代.这样的大对象一般是一些数组,长字符串之类的对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HotSpot虚拟机提供了这个参数来设置。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;-XX：PretenureSizeThreshold&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;动态对象年龄判定&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到- XX：MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;空间分配担保&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如在Young GC之后，新生代仍然有大量对象存活，就需要老年代进行分配担保，把Survivor无法容纳的对象直接送入老年代。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;24.知道有哪些垃圾收集器吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要垃圾收集器如下，图中标出了它们的工作区域、垃圾收集算法，以及配合关系。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTH8Vib0FiayIHPwScYicjhJ4ibEiceMnOz4LXHMKRiaxbETf2p1xVEcCn9N4g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;HotSpot虚拟机垃圾收集器&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些收集器里，面试的重点是两个——&lt;strong&gt;CMS&lt;/strong&gt;和&lt;strong&gt;G1&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial收集器是最基础、历史最悠久的收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如同它的名字（串行），它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束——这就是所谓的“Stop The World”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial/Serial Old收集器的运行过程如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTrsAicwCPx0558QjDzvLYiagicoSdLdSdD6GXa6JKeV8R3AaPYPEnO3GoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Serial/Serial Old收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ParNew收集器实质上是Serial收集器的多线程并行版本，使用多条线程进行垃圾收集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ParNew/Serial Old收集器运行示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTx2taFoj9KkJk0gJOg0yn4kH3fADYzPuDqea5wKNIcgouf3I2QyYI4A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ParNew/Serial Old收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge收集器是一款新生代收集器，基于标记-复制算法实现，也能够并行收集。和ParNew有些类似，但Parallel Scavenge主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是CPU用于运行用户代码的时间和总消耗时间的比值，比值越大，说明垃圾收集的占比越小。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT8eb1TJQZFLyvX1ZRYeiaG6tIzNicd9XOcxQLHRnKWzCUkr285AZhfaxg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;吞吐量&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTW7Fiab6ToYoS76g2YAulthtYZiafxct4L7eGQwlDgCFGdSLACZa1zWWA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Parallel Scavenge/Parallel Old收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，同样是老年代的收集器，采用标记-清除算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Garbage First（简称G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于Region的内存布局形式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;25.什么是Stop The World ? 什么是 OopMap ？什么是安全点？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为&lt;code&gt;Stop The World&lt;/code&gt;。也简称为STW。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在HotSpot中，有个数据结构（映射表）称为&lt;code&gt;OopMap&lt;/code&gt;。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，记录到OopMap。在即时编译过程中，也会在&lt;code&gt;特定的位置&lt;/code&gt;生成 OopMap，记录下栈上和寄存器里哪些位置是引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些特定的位置主要在：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1.循环的末尾（非 counted 循环）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2.方法临返回前 / 调用方法的call指令后&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3.可能抛异常的位置&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些位置就叫作&lt;strong&gt;安全点(safepoint)。&lt;/strong&gt; 用户程序执行时并非在代码指令流的任意位置都能够在停顿下来开始垃圾收集，而是必须是执行到安全点才能够暂停。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用通俗的比喻，假如老王去拉车，车上东西很重，老王累的汗流浃背，但是老王不能在上坡或者下坡休息，只能在平地上停下来擦擦汗，喝口水。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT8LZHjoVgNeiaVMsLeicGn7aHEyazxGy9GSVOPnEEwrjSuzkcalu8ARxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;老王拉车只能在平路休息&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;26.能详细说一下CMS收集器的垃圾收集过程吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS收集齐的垃圾收集分为四步：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;初始标记&lt;/strong&gt;（CMS initial mark）：单线程运行，需要Stop The World，标记GC Roots能直达的对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;并发标记&lt;/strong&gt;（（CMS concurrent mark）：无停顿，和用户线程同时运行，从GC Roots直达对象开始遍历整个对象图。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;重新标记&lt;/strong&gt;（CMS remark）：多线程运行，需要Stop The World，标记并发标记阶段产生对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;并发清除&lt;/strong&gt;（CMS concurrent sweep）：无停顿，和用户线程同时运行，清理掉标记阶段标记的死亡的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Concurrent Mark Sweep收集器运行示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT2sTricwq5keYkNCoEW12KA7IeUNQq1Q4kXj8wqELUiac71VB00iaorgUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Concurrent Mark Sweep收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;27.G1垃圾收集器了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Garbage First（简称G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于Region的内存布局形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异。以前的收集器分代是划分新生代、老年代、持久代等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT6FqGp13gGUHUpD94omUYNSba7EF1E2C95F3bduicH6lYiasfaQhLZXibg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;G1 Heap Regions&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就避免了收集整个堆，而是按照若干个Region集进行收集，同时维护一个优先级列表，跟踪各个Region回收的“价值，优先收集价值高的Region。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1收集器的运行过程大致可划分为以下四个步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;初始标记&lt;/strong&gt;（initial mark），标记了从GC Root开始直接关联可达的对象。STW（Stop the World）执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;并发标记&lt;/strong&gt;（concurrent marking），和用户线程并发执行，从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象、&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;最终标记&lt;/strong&gt;（Remark），STW，标记再并发标记过程中产生的垃圾。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;筛选回收&lt;/strong&gt;（Live Data Counting And Evacuation），制定回收计划，选择多个Region 构成回收集，把回收集中Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。需要STW。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTnibUuMAwtqgTqNuGu7fHUK4XSLXCzR1G0WakjBicOcBjS1LgyZpS55Ig/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;G1收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;28.有了CMS，为什么还要引入G1？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：CMS最主要的优点在名字上已经体现出来——并发收集、低停顿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：CMS同样有三个明显的缺点。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Mark Sweep算法会导致内存碎片比较多&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMS的并发能力比较依赖于CPU资源，并发回收时垃圾收集线程可能会抢占用户线程的资源，导致用户程序性能下降。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发清除阶段，用户线程依然在运行，会产生所谓的理“浮动垃圾”（Floating Garbage），本次垃圾收集无法处理浮动垃圾，必须到下一次垃圾收集才能处理。如果浮动垃圾太多，会触发新的垃圾回收，导致性能降低。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1主要解决了内存碎片过多的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;29.你们线上用的什么垃圾收集器？为什么要用它？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么说呢，虽然调优说的震天响，但是我们一般都是用默认。管你Java怎么升，我用8，那么JDK1.8默认用的是什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java -XX:+PrintCommandLineFlags -version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到有这么一行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;-XX:+UseParallelGC&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;UseParallelGC&lt;/code&gt; = &lt;code&gt;Parallel Scavenge + Parallel Old&lt;/code&gt;，表示的是新生代用的&lt;code&gt;Parallel Scavenge&lt;/code&gt;收集器，老年代用的是&lt;code&gt;Parallel Old&lt;/code&gt; 收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为什么要用这个呢？默认的呗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然面试肯定不能这么答。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge的特点是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高吞吐，我们可以回答：因为我们系统是业务相对复杂，但并发并不是非常高，所以希望尽可能的利用处理器资源，出于提高吞吐量的考虑采用&lt;code&gt;Parallel Scavenge + Parallel Old&lt;/code&gt;的组合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这个默认虽然也有说法，但不太讨喜。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以说：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用&lt;code&gt;Parallel New&lt;/code&gt;+&lt;code&gt;CMS&lt;/code&gt;的组合，我们比较关注服务的响应速度，所以采用了CMS来降低停顿时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者一步到位：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们线上采用了设计比较优秀的G1垃圾收集器，因为它不仅满足我们低停顿的要求，而且解决了CMS的浮动垃圾问题、内存碎片问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;30.垃圾收集器应该如何选择？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集器的选择需要权衡的点还是比较多的——例如运行应用的基础设施如何？使用JDK的发行商是什么？等等……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里简单地列一下上面提到的一些收集器的适用场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Serial ：如果应用程序有一个很小的内存空间（大约100 MB）亦或它在没有停顿时间要求的单线程处理器上运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Parallel：如果优先考虑应用程序的峰值性能，并且没有时间要求要求，或者可以接受1秒或更长的停顿时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMS/G1：如果响应时间比吞吐量优先级高，或者垃圾收集暂停必须保持在大约1秒以内。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ZGC：如果响应时间是高优先级的，或者堆空间比较大。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;31.对象一定分配在堆中吗？有没有了解逃逸分析技术？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对象一定分配在堆中吗？&lt;/strong&gt; 不一定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着JIT编译期的发展与逃逸分析技术逐渐成熟，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。其实，在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么是逃逸分析？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逃逸分析&lt;/strong&gt;是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通俗点讲，当一个对象被new出来之后，它可能被外部所调用，如果是作为参数传递到外部了，就称之为方法逃逸。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTynkkcDXF9sKPjYEbYzMD8SaIW4j1iawsVqy4xy2ukHuaItaPwUXNnfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;逃逸&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，如果对象还有可能被外部线程访问到，例如赋值给可以在其它线程中访问的实例变量，这种就被称为线程逃逸。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTTOX3vvAdwcByN7iaxpH1MiakOAnH9KgvR4sOgRH962y6tatVXFMKqFzg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;逃逸强度&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逃逸分析的好处&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果确定一个对象不会逃逸到线程之外，那么久可以考虑将这个对象在栈上分配，对象占用的内存随着栈帧出栈而销毁，这样一来，垃圾收集的压力就降低很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个数据是基本数据类型，不可拆分，它就被称之为标量。把一个Java对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么可以不创建对象，直接用创建若干个成员变量代替，可以让对象的成员变量在栈上分配和读写。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JVM调优&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;32.有哪些常用的命令行性能监控和故障处理工具？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;操作系统工具&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;top：显示系统整体资源使用情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;vmstat：监控内存和CPU&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;iostat：监控IO使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;netstat：监控网络使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JDK性能监控工具&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;jps：虚拟机进程查看&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jstat：虚拟机运行时信息查看&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jinfo：虚拟机配置查看&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jmap：内存映像（导出）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jhat：堆转储快照分析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jstack：Java堆栈跟踪&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jcmd：实现上面除了jstat外所有命令的功能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;33.了解哪些可视化的性能监控和故障处理工具？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是一些JDK自带的可视化性能监控和故障处理工具：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTibBKNxlQnYeOVuUaBEsuIJ3kXTqCkFKQ7vvtC7ibiab8Q2ryYiaMl6ibhlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JConsole概览&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTd5Ks3dLxgcznsRWvAUjGYrnYibsTpIlnE1APYGg7EDFO6jm2lxnb5bQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;VisualVM安装插件&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTic6Bc6zaxFx6kEHCXhDWibd6vY5bb8iagBlmOrqpDia6ELCp1MiauNsRPAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JMC主要界面&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还有一些第三方的工具：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 堆内存分析工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GC 日志分析工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;GC&lt;/code&gt; 日志分析工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;商用的性能分析利器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿里开源诊断工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 应用性能分析工具，开源、火焰图、跨平台。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;34.JVM的常见参数配置知道哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些常见的参数配置：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;堆配置：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-Xms:初始堆大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xms：最大堆大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:NewSize=n:设置年轻代大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:NewRatio=n:设置年轻代和年老代的比值。如：为3表示年轻代和年老代比值为1：3，年轻代占整个年轻代年老代和的1/4&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如3表示Eden：3 Survivor：2，一个Survivor区占整个年轻代的1/5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MaxPermSize=n:设置持久代大小&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;收集器设置：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-XX:+UseSerialGC:设置串行收集器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParallelGC:设置并行收集器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParalledlOldGC:设置并行年老代收集器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseConcMarkSweepGC:设置并发收集器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;并行收集器设置&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MaxGCPauseMillis=n:设置并行收集最大的暂停时间（如果到这个时间了，垃圾回收器依然没有回收完，也会停止回收）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为：1/(1+n)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:ParallelGCThreads=n:设置并发收集器年轻代手机方式为并行收集时，使用的CPU数。并行收集线程数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打印GC回收的过程日志信息&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-XX:+PrintGC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+PrintGCDetails&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+PrintGCTimeStamps&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xloggc:filename&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;35.有做过JVM调优吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM调优是一件很严肃的事情，不是拍脑门就开始调优的，需要有严密的分析和监控机制，大概的一个JVM调优流程图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT4jicGxb8ENuyvB7pwKLWylruUQbqR0xAgFyNNMHPWXRwickIMefjlWgA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JVM调优大致流程图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，JVM调优是不得已而为之，有那功夫，好好把烂代码重构一下不比瞎调JVM强。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，面试官非要问怎么办？可以从处理问题的角度来回答（对应图中事后），这是一个中规中矩的案例：电商公司的运营后台系统，偶发性的引发OOM异常，堆内存溢出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、因为是偶发性的，所以第一次简单的认为就是堆内存不足导致，单方面的加大了堆内存从4G调整到8G   -Xms8g。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、但是问题依然没有解决，只能从堆内存信息下手，通过开启了-XX:+HeapDumpOnOutOfMemoryError参数 获得堆内存的dump文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、用JProfiler 对  堆dump文件进行分析，通过JProfiler查看到占用内存最大的对象是String对象，本来想跟踪着String对象找到其引用的地方，但dump文件太大，跟踪进去的时候总是卡死，而String对象占用比较多也比较正常，最开始也没有认定就是这里的问题，于是就从线程信息里面找突破点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、通过线程进行分析，先找到了几个正在运行的业务线程，然后逐一跟进业务线程看了下代码，有个方法引起了我的注意，&lt;code&gt;导出订单信息&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、因为订单信息导出这个方法可能会有几万的数据量，首先要从数据库里面查询出来订单信息，然后把订单信息生成excel，这个过程会产生大量的String对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、为了验证自己的猜想，于是准备登录后台去测试下，结果在测试的过程中发现导出订单的按钮前端居然没有做点击后按钮置灰交互事件，后端也没有做防止重复提交，因为导出订单数据本来就非常慢，使用的人员可能发现点击后很久后页面都没反应，然后就一直点，结果就大量的请求进入到后台，堆内存产生了大量的订单对象和EXCEL对象，而且方法执行非常慢，导致这一段时间内这些对象都无法被回收，所以最终导致内存溢出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7、知道了问题就容易解决了，最终没有调整任何JVM参数，只是做了两个处理：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在前端的导出订单按钮上加上了置灰状态，等后端响应之后按钮才可以进行点击&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后端代码加分布式锁，做防重处理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样双管齐下，保证导出的请求不会一直打到服务端，问题解决！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;36.线上服务CPU占用过高怎么排查？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题分析：CPU高一定是某个程序长期占用了CPU资源。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTiaAoib9d8fhbGUaPsOZ121D3fLC7EUY0HtO8b5JY1g2Su7LhahcQaWzw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;CPU飙高&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、所以先需要找出那个进程占用CPU高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、然后根据找到对应进行里哪个线程占用CPU高。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;top -Hp 进程ID   列出对应进程里面的线程占用资源情况&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、找到对应线程ID后，再打印出对应线程的堆栈信息&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;printf &quot;%x\n&quot;  PID    把线程ID转换为16进制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jstack PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为16进制的线程ID对应的线程信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看是否有线程长时间的watting 或blocked，如果线程长期处于watting状态下， 关注watting on xxxxxx，说明线程在等待这把锁，然后根据锁的地址找到持有锁的线程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;37.内存飙高问题怎么排查？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析：内存飚高如果是发生在java进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、先观察垃圾回收的情况&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;jstat -gc PID 1000 查看GC次数，时间等信息，每隔一秒打印一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jmap -histo PID | head -20   查看堆内存占用空间最大的前20个对象类型,可初步查看是哪个对象占用了内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果每次GC次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、导出堆内存文件快照&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;jmap -dump:live,format=b,file=/home/myheapdump.hprof PID  dump堆内存信息到文件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、使用visualVM对dump文件进行离线分析，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;38.频繁 minor gc 怎么办？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化Minor GC频繁问题：通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor  GC，因此可以通过增大新生代空间&lt;code&gt;-Xmn&lt;/code&gt;来降低Minor GC的频率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;39.频繁Full GC怎么办？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Full GC的排查思路大概如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;清楚从程序角度，有哪些原因导致FGC？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;大对象&lt;/strong&gt;：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内存泄漏&lt;/strong&gt;：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序频繁生成一些&lt;strong&gt;长生命周期的对象&lt;/strong&gt;，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. （即本文中的案例）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;程序BUG&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码中&lt;strong&gt;显式调用了gc&lt;/strong&gt;方法，包括自己的代码甚至框架中的代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;清楚排查问题时能使用哪些工具&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;公司的监控系统：大部分公司都会有，可全方位监控JVM的各项指标。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JDK的自带工具，包括jmap、jstat等常用命令：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看堆内存各区域的使用率以及GC情况&lt;/span&gt;&lt;br/&gt;jstat -gcutil -h20 pid 1000&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看堆内存中的存活对象，并按空间排序&lt;/span&gt;&lt;br/&gt;jmap -histo pid | head -n20&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; dump堆内存文件&lt;/span&gt;&lt;br/&gt;jmap -dump:format=b,file=heap pid&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可视化的堆内存分析工具：JVisualVM、MAT等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;排查指南&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;了解该时间点之前有没有程序上线、基础组件升级等情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析JVM参数设置是否合理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再对步骤1中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用gc方法比较容易排查。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对大对象或者长生命周期对象导致的FGC，可通过 jmap -histo 命令并结合dump堆内存文件作进一步分析，需要先定位到可疑对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过可疑对象定位到具体代码再次分析，这时候要结合GC原理和JVM参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;40.有没有处理过内存泄漏问题？是如何定位的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄漏是内在病源，外在病症表现可能有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;应用程序长时间连续运行时性能严重下降&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU 使用率飙升，甚至到 100%&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;频繁 Full GC，各种报警，例如接口超时报警等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用程序抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 错误&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用程序偶尔会耗尽连接对象&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;严重&lt;strong&gt;内存泄漏&lt;/strong&gt;往往伴随频繁的 &lt;strong&gt;Full GC&lt;/strong&gt;，所以分析排查内存泄漏问题首先还得从查看 Full GC 入手。主要有以下操作步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 &lt;code&gt;jps&lt;/code&gt; 查看运行的 Java 进程 ID&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用&lt;code&gt;top -p [pid]&lt;/code&gt; 查看进程使用 CPU 和 MEM 的情况&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 &lt;code&gt;top -Hp [pid]&lt;/code&gt; 查看进程下的所有线程占 CPU 和 MEM 的情况&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将线程 ID 转换为 16 进制：&lt;code&gt;printf &quot;%x\n&quot; [pid]&lt;/code&gt;，输出的值就是线程栈信息中的 &lt;strong&gt;nid&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;例如：&lt;code&gt;printf &quot;%x\n&quot; 29471&lt;/code&gt;，换行输出 &lt;strong&gt;731f&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;抓取线程栈：&lt;code&gt;jstack 29452 &amp;gt; 29452.txt&lt;/code&gt;，可以多抓几次做个对比。&lt;/p&gt;&lt;p&gt;在线程栈信息中找到对应线程号的 16 进制值，如下是 &lt;strong&gt;731f&lt;/strong&gt; 线程的信息。线程栈分析可使用 Visualvm 插件 &lt;strong&gt;TDA&lt;/strong&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&quot;Service Thread&quot;&lt;/span&gt; #&lt;span&gt;7&lt;/span&gt; daemon prio=&lt;span&gt;9&lt;/span&gt; os_prio=&lt;span&gt;0&lt;/span&gt; tid=&lt;span&gt;0x00007fbe2c164000&lt;/span&gt; nid=&lt;span&gt;0x731f&lt;/span&gt; runnable [&lt;span&gt;0x0000000000000000&lt;/span&gt;]&lt;br/&gt;   java.lang.Thread.State: RUNNABLE&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用&lt;code&gt;jstat -gcutil [pid] 5000 10&lt;/code&gt; 每隔 5 秒输出 GC 信息，输出 10 次，查看 &lt;strong&gt;YGC&lt;/strong&gt; 和 &lt;strong&gt;Full GC&lt;/strong&gt; 次数。通常会出现 YGC 不增加或增加缓慢，而 Full GC 增加很快。&lt;/p&gt;&lt;p&gt;或使用 &lt;code&gt;jstat -gccause [pid] 5000&lt;/code&gt; ，同样是输出 GC 摘要信息。&lt;/p&gt;&lt;p&gt;或使用 &lt;code&gt;jmap -heap [pid]&lt;/code&gt; 查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果发现 &lt;code&gt;Full GC&lt;/code&gt; 次数太多，就很大概率存在内存泄漏了&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 &lt;code&gt;jmap -histo:live [pid]&lt;/code&gt; 输出每个类的对象数量，内存大小(字节单位)及全限定类名。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;生成 &lt;code&gt;dump&lt;/code&gt; 文件，借助工具分析哪 个对象非常多，基本就能定位到问题在那了&lt;/p&gt;&lt;p&gt;使用 jmap 生成 dump 文件：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# jmap -dump:live,format=b,file=&lt;span&gt;29471&lt;/span&gt;.dump &lt;span&gt;29471&lt;/span&gt;&lt;br/&gt;Dumping heap to /root/dump ...&lt;br/&gt;Heap dump file created&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以使用 &lt;strong&gt;jhat&lt;/strong&gt; 命令分析：&lt;code&gt;jhat -port 8000 29471.dump&lt;/code&gt;，浏览器访问 jhat 服务，端口是 8000。&lt;/p&gt;&lt;p&gt;通常使用图形化工具分析，如 JDK 自带的 &lt;strong&gt;jvisualvm&lt;/strong&gt;，从菜单 &amp;gt; 文件 &amp;gt; 装入 dump 文件。&lt;/p&gt;&lt;p&gt;或使用第三方式具分析的，如 &lt;strong&gt;JProfiler&lt;/strong&gt; 也是个图形化工具，&lt;strong&gt;GCViewer&lt;/strong&gt; 工具。Eclipse 或以使用 MAT 工具查看。或使用在线分析平台 &lt;strong&gt;GCEasy&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;注意：如果 dump 文件较大的话，分析会占比较大的内存。&lt;/p&gt;&lt;p&gt;基本上就可以定位到代码层的逻辑了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol start=&quot;11&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 dump 文析结果中查找存在大量的对象，再查对其的引用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dump 文件分析&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;41.有没有处理过内存溢出问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄漏和内存溢出二者关系非常密切，内存溢出可能会有很多原因导致，内存泄漏最可能的罪魁祸首之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排查过程和排查内存泄漏过程类似。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虚拟机执行&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;42.能说一下类的生命周期吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个类从被加载到虚拟机内存中开始，到从内存中卸载，整个生命周期需要经过七个阶段：加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading），其中验证、准备、解析三个部分统称为连接（Linking）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTQ4kgKmAgYMV4GYJSLgiaOZeyLX7ibpRenh6ebqiaQkiaBHaOx2kVFRBS4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;类的生命周期&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;43.类加载的过程知道吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载是JVM加载的起点，具体什么时候开始加载，《Java虚拟机规范》中并没有进行强制约束，可以交给虚拟机的具体实现来自由把握。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在加载过程，JVM要做三件事情：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTpWvLTEpdH0icvwhcCqmUm78AOAdXWA9o8ZELScYBU5Yh2XZ7wgVx1Iw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;加载&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1）通过一个类的全限定名来获取定义此类的二进制字节流。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象， 这个对象将作为程序访问方法区中的类型数据的外部接口。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;44.类加载器有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有四种类加载器:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;启动类加载器&lt;/strong&gt;(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;扩展类加载器&lt;/strong&gt;(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;系统类加载器&lt;/strong&gt;（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;用户自定义类加载器&lt;/strong&gt; (user class loader)，用户通过继承 java.lang.ClassLoader类的方式自行实现的类加载器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;45.什么是双亲委派机制？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTtcyiaOeuLwFYlzwvuNujp8nkcg12lY7C631yKNy9I3HibB3HsKpoeQkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;双亲委派模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;46.为什么要用双亲委派机制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是为了保证应用程序的稳定有序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如类java.lang.Object，它存放在rt.jar之中，通过双亲委派机制，保证最终都是委派给处于模型最顶端的启动类加载器进行加载，保证Object的一致。反之，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的 ClassPath中，那系统中就会出现多个不同的Object类。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;47.如何破坏双亲委派机制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不想打破双亲委派模型，就重写ClassLoader类中的fifindClass()方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。而如果想打破双亲委派模型则需要重写loadClass()方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;48.历史上有哪几次双亲委派机制的破坏？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派机制在历史上主要有三次破坏：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTOicIJL9OMa5am46V4EpXLL2qoWSDyTeMOeJpgSxI4FBkNBb8SaPmqQw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;双亲委派模型的三次破坏&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;第一次破坏&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类  java.lang.ClassLoader则在Java的第一个版本中就已经存在，为了向下兼容旧代码，所以无法以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个新的  protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass()中编写代码。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;第二次破坏&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，如果有基础类型又要调用回用户的代码，那该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如我们比较熟悉的JDBC:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各个厂商各有不同的JDBC的实现，Java在核心包&lt;code&gt;\lib&lt;/code&gt;里定义了对应的SPI，那么这个就毫无疑问由&lt;code&gt;启动类加载器&lt;/code&gt;加载器加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是各个厂商的实现，是没办法放在核心包里的，只能放在&lt;code&gt;classpath&lt;/code&gt;里，只能被&lt;code&gt;应用类加载器&lt;/code&gt;加载。那么，问题来了，启动类加载器它就加载不到厂商提供的SPI服务代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，引入了一个不太优雅的设计：线程上下文类加载器 （Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;第三次破坏&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，例如代码热替换（Hot Swap）、模块热部署（Hot Deployment）等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为 Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;49.你觉得应该怎么实现一个热部署功能？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经知道了Java类的加载过程。一个Java类文件到虚拟机里的对象，要经过如下过程:首先通过Java编译器，将Java文件编译成class字节码，类加载器读取class字节码，再将类转化为实例，对实例newInstance就可以生成对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载器ClassLoader功能，也就是将class字节码转换到类的实例。在Java应用中，所有的实例都是由类加载器，加载而来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般在系统中，类的加载都是由系统自带的类加载器完成，而且对于同一个全限定名的java类（如com.csiar.soc.HelloWorld），只能被加载一次，而且无法被卸载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候问题就来了，如果我们希望将java类卸载，并且替换更新版本的java类，该怎么做呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然在类加载器中，Java类只能被加载一次，并且无法卸载。那么我们是不是可以直接把Java类加载器干掉呢？答案是可以的，我们可以自定义类加载器，并重写ClassLoader的findClass方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要实现热部署可以分以下三个步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;销毁原来的自定义ClassLoader&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新class类文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建新的ClassLoader去加载更新后的class类文件。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到此，一个热部署的功能就这样实现了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;50.Tomcat的类加载机制了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat是主流的Java Web服务器之一，为了实现一些特殊的功能需求，自定义了一些类加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat类加载器如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTMGYrkqKcRpLsXsiaicqrvSRhr9XaibAvk2beJwFCCcWjtcjoeueUSrQeg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Tomcat类加载器&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat实际上也是破坏了双亲委派模型的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomact是web容器，可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如多个应用都要依赖hollis.jar，但是A应用需要依赖1.0.0版本，但是B应用需要依赖1.0.1版本。这两个版本中都有一个类是com.hollis.Test.class。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，Tomcat破坏了&lt;strong&gt;双亲委派原则&lt;/strong&gt;，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器。每一个WebAppClassLoader负责加载本身的目录下的class文件，加载不到时再交CommonClassLoader加载，这和双亲委派刚好相反。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;好了，本期的50道JVM面试题就分享到这了，下期继续分享Java并发相关面试题，&lt;big&gt;&lt;strong&gt;点赞&lt;/strong&gt;&lt;/big&gt;、&lt;big&gt;&lt;strong&gt;关注&lt;/strong&gt;&lt;/big&gt;  不迷路，咱们下期见！&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>